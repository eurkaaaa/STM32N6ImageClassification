
STM32N6DK2_FSBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00025270  34180750  34180750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00014788  341a59c0  341a59c0  000259c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .version      0000000c  341ba148  341ba148  0003a148  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  341ba154  341ba154  0003b320  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  341ba154  341ba154  0003a154  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  341ba15c  341ba15c  0003b320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  341ba15c  341ba15c  0003a15c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  341ba160  341ba160  0003a160  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000190  341c0000  341ba164  0003b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000000  341c0190  341c0190  0003b320  2**0
                  CONTENTS
 11 .gnu.sgstubs  00000020  341ba300  341ba300  0003b300  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00001cc8  341c0190  341c0190  0003c190  2**3
                  ALLOC
 13 ._user_heap_stack 00000a00  341c1e58  341c1e58  0003c190  2**0
                  ALLOC
 14 .psram_section 00000000  91000000  91000000  0003b320  2**0
                  CONTENTS
 15 .ARM.attributes 0000003a  00000000  00000000  0003b320  2**0
                  CONTENTS, READONLY
 16 .debug_info   00055b4e  00000000  00000000  0003b35a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00007834  00000000  00000000  00090ea8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00003888  00000000  00000000  000986e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00002b7b  00000000  00000000  0009bf68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0006717c  00000000  00000000  0009eae3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0003fe08  00000000  00000000  00105c5f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    002d68c1  00000000  00000000  00145a67  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  0041c328  2**0
                  CONTENTS, READONLY
 24 .debug_frame  00010308  00000000  00000000  0041c3b0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 00000073  00000000  00000000  0042c6b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34180750 <__do_global_dtors_aux>:
34180750:	b510      	push	{r4, lr}
34180752:	4c05      	ldr	r4, [pc, #20]	@ (34180768 <__do_global_dtors_aux+0x18>)
34180754:	7823      	ldrb	r3, [r4, #0]
34180756:	b933      	cbnz	r3, 34180766 <__do_global_dtors_aux+0x16>
34180758:	4b04      	ldr	r3, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x1c>)
3418075a:	b113      	cbz	r3, 34180762 <__do_global_dtors_aux+0x12>
3418075c:	4804      	ldr	r0, [pc, #16]	@ (34180770 <__do_global_dtors_aux+0x20>)
3418075e:	f3af 8000 	nop.w
34180762:	2301      	movs	r3, #1
34180764:	7023      	strb	r3, [r4, #0]
34180766:	bd10      	pop	{r4, pc}
34180768:	341c0190 	.word	0x341c0190
3418076c:	00000000 	.word	0x00000000
34180770:	341a59a8 	.word	0x341a59a8

34180774 <frame_dummy>:
34180774:	b508      	push	{r3, lr}
34180776:	4b03      	ldr	r3, [pc, #12]	@ (34180784 <frame_dummy+0x10>)
34180778:	b11b      	cbz	r3, 34180782 <frame_dummy+0xe>
3418077a:	4903      	ldr	r1, [pc, #12]	@ (34180788 <frame_dummy+0x14>)
3418077c:	4803      	ldr	r0, [pc, #12]	@ (3418078c <frame_dummy+0x18>)
3418077e:	f3af 8000 	nop.w
34180782:	bd08      	pop	{r3, pc}
34180784:	00000000 	.word	0x00000000
34180788:	341c0194 	.word	0x341c0194
3418078c:	341a59a8 	.word	0x341a59a8

34180790 <vVjsiRnEsi>:
34180790:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
34180794:	b530      	push	{r4, r5, lr}
34180796:	ed2d 8b10 	vpush	{d8-d15}
3418079a:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
3418079e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
341807a2:	b087      	sub	sp, #28
341807a4:	ed8d 7b00 	vstr	d7, [sp]
341807a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341807ac:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
341807b0:	4604      	mov	r4, r0
341807b2:	ed91 5a01 	vldr	s10, [r1, #4]
341807b6:	ed91 4a00 	vldr	s8, [r1]
341807ba:	ed91 fb02 	vldr	d15, [r1, #8]
341807be:	ed91 8b04 	vldr	d8, [r1, #16]
341807c2:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
341807c6:	ed90 dbaa 	vldr	d13, [r0, #680]	@ 0x2a8
341807ca:	ed90 bb16 	vldr	d11, [r0, #88]	@ 0x58
341807ce:	ed8d 7b04 	vstr	d7, [sp, #16]
341807d2:	ed90 eba6 	vldr	d14, [r0, #664]	@ 0x298
341807d6:	dc09      	bgt.n	341807ec <vVjsiRnEsi+0x5c>
341807d8:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
341807dc:	48d4      	ldr	r0, [pc, #848]	@ (34180b30 <vVjsiRnEsi+0x3a0>)
341807de:	4798      	blx	r3
341807e0:	f04f 30ff 	mov.w	r0, #4294967295
341807e4:	b007      	add	sp, #28
341807e6:	ecbd 8b10 	vpop	{d8-d15}
341807ea:	bd30      	pop	{r4, r5, pc}
341807ec:	eeb8 5b45 	vcvt.f64.u32	d5, s10
341807f0:	ed9f 7bc1 	vldr	d7, [pc, #772]	@ 34180af8 <vVjsiRnEsi+0x368>
341807f4:	eeb8 4b44 	vcvt.f64.u32	d4, s8
341807f8:	ee25 7b07 	vmul.f64	d7, d5, d7
341807fc:	eeb4 7bc4 	vcmpe.f64	d7, d4
34180800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180804:	dd0f      	ble.n	34180826 <vVjsiRnEsi+0x96>
34180806:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
3418080a:	ed9f 2bbd 	vldr	d2, [pc, #756]	@ 34180b00 <vVjsiRnEsi+0x370>
3418080e:	ee37 2b02 	vadd.f64	d2, d7, d2
34180812:	ed9f 7bbd 	vldr	d7, [pc, #756]	@ 34180b08 <vVjsiRnEsi+0x378>
34180816:	eeb4 2bc7 	vcmpe.f64	d2, d7
3418081a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418081e:	fe37 7b02 	vselgt.f64	d7, d7, d2
34180822:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
34180826:	ed9f 7bba 	vldr	d7, [pc, #744]	@ 34180b10 <vVjsiRnEsi+0x380>
3418082a:	ee25 5b07 	vmul.f64	d5, d5, d7
3418082e:	eeb4 5bc4 	vcmpe.f64	d5, d4
34180832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180836:	d510      	bpl.n	3418085a <vVjsiRnEsi+0xca>
34180838:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3418083c:	ed9f 5bb0 	vldr	d5, [pc, #704]	@ 34180b00 <vVjsiRnEsi+0x370>
34180840:	ee37 7b45 	vsub.f64	d7, d7, d5
34180844:	ed9f 5bb4 	vldr	d5, [pc, #720]	@ 34180b18 <vVjsiRnEsi+0x388>
34180848:	eeb4 7bc5 	vcmpe.f64	d7, d5
3418084c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180850:	bf58      	it	pl
34180852:	eeb0 5b47 	vmovpl.f64	d5, d7
34180856:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
3418085a:	ee83 9b0d 	vdiv.f64	d9, d3, d13
3418085e:	eebc 9bc9 	vcvt.u32.f64	s18, d9
34180862:	eeb8 9b49 	vcvt.f64.u32	d9, s18
34180866:	ee29 9b0d 	vmul.f64	d9, d9, d13
3418086a:	eefc 7bc9 	vcvt.u32.f64	s15, d9
3418086e:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34180872:	edcd 7a03 	vstr	s15, [sp, #12]
34180876:	2d01      	cmp	r5, #1
34180878:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3418087c:	d152      	bne.n	34180924 <vVjsiRnEsi+0x194>
3418087e:	ed9f 7ba8 	vldr	d7, [pc, #672]	@ 34180b20 <vVjsiRnEsi+0x390>
34180882:	ee3f 5b48 	vsub.f64	d5, d15, d8
34180886:	ee85 cb07 	vdiv.f64	d12, d5, d7
3418088a:	ee3f 5b08 	vadd.f64	d5, d15, d8
3418088e:	ee85 ab07 	vdiv.f64	d10, d5, d7
34180892:	eeb0 7bcc 	vabs.f64	d7, d12
34180896:	eeb4 6bc7 	vcmpe.f64	d6, d7
3418089a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418089e:	eeb0 5bca 	vabs.f64	d5, d10
341808a2:	db0d      	blt.n	341808c0 <vVjsiRnEsi+0x130>
341808a4:	eeb4 6bc5 	vcmpe.f64	d6, d5
341808a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808ac:	db08      	blt.n	341808c0 <vVjsiRnEsi+0x130>
341808ae:	2300      	movs	r3, #0
341808b0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
341808b4:	2300      	movs	r3, #0
341808b6:	eeb0 8b49 	vmov.f64	d8, d9
341808ba:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341808be:	e049      	b.n	34180954 <vVjsiRnEsi+0x1c4>
341808c0:	eeb4 6bc5 	vcmpe.f64	d6, d5
341808c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808c8:	d50c      	bpl.n	341808e4 <vVjsiRnEsi+0x154>
341808ca:	ee8a 5b0c 	vdiv.f64	d5, d10, d12
341808ce:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
341808d2:	eeb0 5bc5 	vabs.f64	d5, d5
341808d6:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
341808da:	eeb4 5bc6 	vcmpe.f64	d5, d6
341808de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808e2:	dae7      	bge.n	341808b4 <vVjsiRnEsi+0x124>
341808e4:	2300      	movs	r3, #0
341808e6:	eef7 0bcb 	vcvt.f32.f64	s1, d11
341808ea:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
341808ee:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341808f2:	f024 fcc9 	bl	341a5288 <powf>
341808f6:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
341808fa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341808fe:	eeb0 6bc8 	vabs.f64	d6, d8
34180902:	ee20 0b07 	vmul.f64	d0, d0, d7
34180906:	eeb0 7bcf 	vabs.f64	d7, d15
3418090a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3418090e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180912:	dd6f      	ble.n	341809f4 <vVjsiRnEsi+0x264>
34180914:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34180918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418091c:	d56f      	bpl.n	341809fe <vVjsiRnEsi+0x26e>
3418091e:	ee39 0b40 	vsub.f64	d0, d9, d0
34180922:	e06e      	b.n	34180a02 <vVjsiRnEsi+0x272>
34180924:	eeb0 5bcf 	vabs.f64	d5, d15
34180928:	eeb0 7bc8 	vabs.f64	d7, d8
3418092c:	eeb4 7bc5 	vcmpe.f64	d7, d5
34180930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180934:	fe37 7b05 	vselgt.f64	d7, d7, d5
34180938:	eeb4 7bc6 	vcmpe.f64	d7, d6
3418093c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180940:	d853      	bhi.n	341809ea <vVjsiRnEsi+0x25a>
34180942:	ed9f ab79 	vldr	d10, [pc, #484]	@ 34180b28 <vVjsiRnEsi+0x398>
34180946:	2300      	movs	r3, #0
34180948:	eeb0 8b49 	vmov.f64	d8, d9
3418094c:	eeb0 cb4a 	vmov.f64	d12, d10
34180950:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34180954:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34180958:	bb2b      	cbnz	r3, 341809a6 <vVjsiRnEsi+0x216>
3418095a:	2210      	movs	r2, #16
3418095c:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34180960:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34180964:	f023 fa04 	bl	341a3d70 <memmove>
34180968:	2210      	movs	r2, #16
3418096a:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
3418096e:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34180972:	f023 f9fd 	bl	341a3d70 <memmove>
34180976:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
3418097a:	ed84 9b24 	vstr	d9, [r4, #144]	@ 0x90
3418097e:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34180982:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34180986:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
3418098a:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
3418098e:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34180992:	ed84 cb34 	vstr	d12, [r4, #208]	@ 0xd0
34180996:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
3418099a:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
3418099e:	ed84 ab36 	vstr	d10, [r4, #216]	@ 0xd8
341809a2:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
341809a6:	eefc 7bc8 	vcvt.u32.f64	s15, d8
341809aa:	ee17 3a90 	vmov	r3, s15
341809ae:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
341809b2:	9a03      	ldr	r2, [sp, #12]
341809b4:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
341809b8:	4293      	cmp	r3, r2
341809ba:	bf1c      	itt	ne
341809bc:	2301      	movne	r3, #1
341809be:	f884 3060 	strbne.w	r3, [r4, #96]	@ 0x60
341809c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809c6:	f340 80b5 	ble.w	34180b34 <vVjsiRnEsi+0x3a4>
341809ca:	2301      	movs	r3, #1
341809cc:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341809d0:	ed9d 7b00 	vldr	d7, [sp]
341809d4:	eeb4 bbc7 	vcmpe.f64	d11, d7
341809d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809dc:	f140 80bd 	bpl.w	34180b5a <vVjsiRnEsi+0x3ca>
341809e0:	ed9d 7b04 	vldr	d7, [sp, #16]
341809e4:	ee3b eb07 	vadd.f64	d14, d11, d7
341809e8:	e0a9      	b.n	34180b3e <vVjsiRnEsi+0x3ae>
341809ea:	ed9f ab4f 	vldr	d10, [pc, #316]	@ 34180b28 <vVjsiRnEsi+0x398>
341809ee:	eeb0 cb4a 	vmov.f64	d12, d10
341809f2:	e777      	b.n	341808e4 <vVjsiRnEsi+0x154>
341809f4:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
341809f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809fc:	d58f      	bpl.n	3418091e <vVjsiRnEsi+0x18e>
341809fe:	ee39 0b00 	vadd.f64	d0, d9, d0
34180a02:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
34180a06:	eeb4 7bc0 	vcmpe.f64	d7, d0
34180a0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a0e:	d42c      	bmi.n	34180a6a <vVjsiRnEsi+0x2da>
34180a10:	eeb0 7b40 	vmov.f64	d7, d0
34180a14:	ed94 6b3a 	vldr	d6, [r4, #232]	@ 0xe8
34180a18:	eeb4 6bc7 	vcmpe.f64	d6, d7
34180a1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a20:	dc26      	bgt.n	34180a70 <vVjsiRnEsi+0x2e0>
34180a22:	eeb0 6b47 	vmov.f64	d6, d7
34180a26:	ee86 8b0d 	vdiv.f64	d8, d6, d13
34180a2a:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34180a2e:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34180a32:	2d01      	cmp	r5, #1
34180a34:	ee2d 8b08 	vmul.f64	d8, d13, d8
34180a38:	d18c      	bne.n	34180954 <vVjsiRnEsi+0x1c4>
34180a3a:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
34180a3e:	2b02      	cmp	r3, #2
34180a40:	d819      	bhi.n	34180a76 <vVjsiRnEsi+0x2e6>
34180a42:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34180a46:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34180a4a:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
34180a4e:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
34180a52:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
34180a56:	eb04 1203 	add.w	r2, r4, r3, lsl #4
34180a5a:	3301      	adds	r3, #1
34180a5c:	ed82 cb2c 	vstr	d12, [r2, #176]	@ 0xb0
34180a60:	ed82 ab2e 	vstr	d10, [r2, #184]	@ 0xb8
34180a64:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34180a68:	e774      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180a6a:	eeb0 bb4e 	vmov.f64	d11, d14
34180a6e:	e7d1      	b.n	34180a14 <vVjsiRnEsi+0x284>
34180a70:	eeb0 bb4e 	vmov.f64	d11, d14
34180a74:	e7d7      	b.n	34180a26 <vVjsiRnEsi+0x296>
34180a76:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34180a7a:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34180a7e:	ee38 7b47 	vsub.f64	d7, d8, d7
34180a82:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34180a86:	eeb0 7bc7 	vabs.f64	d7, d7
34180a8a:	eeb4 7bc6 	vcmpe.f64	d7, d6
34180a8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a92:	db28      	blt.n	34180ae6 <vVjsiRnEsi+0x356>
34180a94:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34180a98:	ee38 7b47 	vsub.f64	d7, d8, d7
34180a9c:	eeb0 7bc7 	vabs.f64	d7, d7
34180aa0:	eeb4 6bc7 	vcmpe.f64	d6, d7
34180aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180aa8:	dd1d      	ble.n	34180ae6 <vVjsiRnEsi+0x356>
34180aaa:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34180aae:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34180ab2:	ee3a 0b40 	vsub.f64	d0, d10, d0
34180ab6:	ee3c 7b47 	vsub.f64	d7, d12, d7
34180aba:	ee20 0b00 	vmul.f64	d0, d0, d0
34180abe:	eea7 0b07 	vfma.f64	d0, d7, d7
34180ac2:	f024 f91d 	bl	341a4d00 <sqrt>
34180ac6:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34180aca:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180ace:	eeb4 0bc7 	vcmpe.f64	d0, d7
34180ad2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180ad6:	d506      	bpl.n	34180ae6 <vVjsiRnEsi+0x356>
34180ad8:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34180adc:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34180ae0:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34180ae4:	e736      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180ae6:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34180aea:	2b01      	cmp	r3, #1
34180aec:	f47f af32 	bne.w	34180954 <vVjsiRnEsi+0x1c4>
34180af0:	2300      	movs	r3, #0
34180af2:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34180af6:	e72d      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180af8:	9999999a 	.word	0x9999999a
34180afc:	3fa99999 	.word	0x3fa99999
34180b00:	47ae147b 	.word	0x47ae147b
34180b04:	3f847ae1 	.word	0x3f847ae1
34180b08:	33333334 	.word	0x33333334
34180b0c:	3fc33333 	.word	0x3fc33333
34180b10:	33333333 	.word	0x33333333
34180b14:	3fc33333 	.word	0x3fc33333
34180b18:	11111111 	.word	0x11111111
34180b1c:	3fb11111 	.word	0x3fb11111
34180b20:	667f3bcd 	.word	0x667f3bcd
34180b24:	3ff6a09e 	.word	0x3ff6a09e
	...
34180b30:	341b767c 	.word	0x341b767c
34180b34:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34180b38:	2b00      	cmp	r3, #0
34180b3a:	f47f af49 	bne.w	341809d0 <vVjsiRnEsi+0x240>
34180b3e:	ee88 7b0d 	vdiv.f64	d7, d8, d13
34180b42:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34180b46:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34180b4a:	ee27 7b0d 	vmul.f64	d7, d7, d13
34180b4e:	ed84 eb16 	vstr	d14, [r4, #88]	@ 0x58
34180b52:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34180b56:	2001      	movs	r0, #1
34180b58:	e644      	b.n	341807e4 <vVjsiRnEsi+0x54>
34180b5a:	ed9d eb00 	vldr	d14, [sp]
34180b5e:	e7ee      	b.n	34180b3e <vVjsiRnEsi+0x3ae>

34180b60 <RGqhTVOsSg>:
34180b60:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34180b64:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34180b68:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34180b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180b70:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34180b74:	eeb0 7b46 	vmov.f64	d7, d6
34180b78:	bfdf      	itttt	le
34180b7a:	ee84 7b05 	vdivle.f64	d7, d4, d5
34180b7e:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34180b82:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34180b86:	ee27 7b05 	vmulle.f64	d7, d7, d5
34180b8a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34180b8e:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34180b92:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34180b96:	eeb4 4bc5 	vcmpe.f64	d4, d5
34180b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180b9e:	bfc8      	it	gt
34180ba0:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34180ba4:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34180ba8:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34180bac:	eeb4 4bc5 	vcmpe.f64	d4, d5
34180bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180bb4:	bf48      	it	mi
34180bb6:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34180bba:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34180bbe:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34180bc2:	b530      	push	{r4, r5, lr}
34180bc4:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34180bc8:	ed93 5a00 	vldr	s10, [r3]
34180bcc:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34180bd0:	eeb4 5ac7 	vcmpe.f32	s10, s14
34180bd4:	eef1 5a67 	vneg.f32	s11, s15
34180bd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180bdc:	f04f 0100 	mov.w	r1, #0
34180be0:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34180be4:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34180be8:	3b01      	subs	r3, #1
34180bea:	b28a      	uxth	r2, r1
34180bec:	4293      	cmp	r3, r2
34180bee:	d805      	bhi.n	34180bfc <RGqhTVOsSg+0x9c>
34180bf0:	2244      	movs	r2, #68	@ 0x44
34180bf2:	fb02 0303 	mla	r3, r2, r3, r0
34180bf6:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34180bfa:	e011      	b.n	34180c20 <RGqhTVOsSg+0xc0>
34180bfc:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34180c00:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34180c04:	ee77 5aa5 	vadd.f32	s11, s15, s11
34180c08:	eef4 5ac7 	vcmpe.f32	s11, s14
34180c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180c10:	f101 0101 	add.w	r1, r1, #1
34180c14:	dbe9      	blt.n	34180bea <RGqhTVOsSg+0x8a>
34180c16:	2344      	movs	r3, #68	@ 0x44
34180c18:	fb03 0202 	mla	r2, r3, r2, r0
34180c1c:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34180c20:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34180c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180c28:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34180c2c:	dc05      	bgt.n	34180c3a <RGqhTVOsSg+0xda>
34180c2e:	ed93 7a00 	vldr	s14, [r3]
34180c32:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180c36:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34180c3a:	685a      	ldr	r2, [r3, #4]
34180c3c:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34180c40:	6042      	str	r2, [r0, #4]
34180c42:	689a      	ldr	r2, [r3, #8]
34180c44:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34180c48:	6082      	str	r2, [r0, #8]
34180c4a:	68da      	ldr	r2, [r3, #12]
34180c4c:	60c2      	str	r2, [r0, #12]
34180c4e:	691a      	ldr	r2, [r3, #16]
34180c50:	6102      	str	r2, [r0, #16]
34180c52:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34180c56:	695d      	ldr	r5, [r3, #20]
34180c58:	330c      	adds	r3, #12
34180c5a:	6145      	str	r5, [r0, #20]
34180c5c:	68dd      	ldr	r5, [r3, #12]
34180c5e:	300c      	adds	r0, #12
34180c60:	60c5      	str	r5, [r0, #12]
34180c62:	691d      	ldr	r5, [r3, #16]
34180c64:	42a3      	cmp	r3, r4
34180c66:	6105      	str	r5, [r0, #16]
34180c68:	f851 5b04 	ldr.w	r5, [r1], #4
34180c6c:	f842 5b04 	str.w	r5, [r2], #4
34180c70:	d1f1      	bne.n	34180c56 <RGqhTVOsSg+0xf6>
34180c72:	2001      	movs	r0, #1
34180c74:	bd30      	pop	{r4, r5, pc}

34180c76 <evision_api_awb_new>:
34180c76:	b510      	push	{r4, lr}
34180c78:	b090      	sub	sp, #64	@ 0x40
34180c7a:	b178      	cbz	r0, 34180c9c <evision_api_awb_new+0x26>
34180c7c:	2200      	movs	r2, #0
34180c7e:	4c08      	ldr	r4, [pc, #32]	@ (34180ca0 <evision_api_awb_new+0x2a>)
34180c80:	2140      	movs	r1, #64	@ 0x40
34180c82:	4b08      	ldr	r3, [pc, #32]	@ (34180ca4 <evision_api_awb_new+0x2e>)
34180c84:	7022      	strb	r2, [r4, #0]
34180c86:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34180c8a:	4a07      	ldr	r2, [pc, #28]	@ (34180ca8 <evision_api_awb_new+0x32>)
34180c8c:	4668      	mov	r0, sp
34180c8e:	f022 ff61 	bl	341a3b54 <sniprintf>
34180c92:	4668      	mov	r0, sp
34180c94:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180c98:	4798      	blx	r3
34180c9a:	4620      	mov	r0, r4
34180c9c:	b010      	add	sp, #64	@ 0x40
34180c9e:	bd10      	pop	{r4, pc}
34180ca0:	341c01b0 	.word	0x341c01b0
34180ca4:	341ba148 	.word	0x341ba148
34180ca8:	341b76bc 	.word	0x341b76bc

34180cac <evision_api_awb_delete>:
34180cac:	2800      	cmp	r0, #0
34180cae:	bf0c      	ite	eq
34180cb0:	f04f 30ff 	moveq.w	r0, #4294967295
34180cb4:	2001      	movne	r0, #1
34180cb6:	4770      	bx	lr

34180cb8 <evision_api_awb_set_profile>:
34180cb8:	b530      	push	{r4, r5, lr}
34180cba:	ed80 0a00 	vstr	s0, [r0]
34180cbe:	680c      	ldr	r4, [r1, #0]
34180cc0:	6044      	str	r4, [r0, #4]
34180cc2:	684c      	ldr	r4, [r1, #4]
34180cc4:	6084      	str	r4, [r0, #8]
34180cc6:	688c      	ldr	r4, [r1, #8]
34180cc8:	60c4      	str	r4, [r0, #12]
34180cca:	68c9      	ldr	r1, [r1, #12]
34180ccc:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34180cd0:	6101      	str	r1, [r0, #16]
34180cd2:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34180cd6:	6815      	ldr	r5, [r2, #0]
34180cd8:	320c      	adds	r2, #12
34180cda:	6145      	str	r5, [r0, #20]
34180cdc:	f852 5c08 	ldr.w	r5, [r2, #-8]
34180ce0:	300c      	adds	r0, #12
34180ce2:	60c5      	str	r5, [r0, #12]
34180ce4:	f852 5c04 	ldr.w	r5, [r2, #-4]
34180ce8:	42a2      	cmp	r2, r4
34180cea:	6105      	str	r5, [r0, #16]
34180cec:	f853 5b04 	ldr.w	r5, [r3], #4
34180cf0:	f841 5b04 	str.w	r5, [r1], #4
34180cf4:	d1ef      	bne.n	34180cd6 <evision_api_awb_set_profile+0x1e>
34180cf6:	bd30      	pop	{r4, r5, pc}

34180cf8 <evision_api_awb_init_profiles>:
34180cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34180cfc:	ed2d 8b06 	vpush	{d8-d10}
34180d00:	460d      	mov	r5, r1
34180d02:	eeb0 9b40 	vmov.f64	d9, d0
34180d06:	eeb0 8b41 	vmov.f64	d8, d1
34180d0a:	461e      	mov	r6, r3
34180d0c:	4604      	mov	r4, r0
34180d0e:	b0c9      	sub	sp, #292	@ 0x124
34180d10:	2800      	cmp	r0, #0
34180d12:	f000 8185 	beq.w	34181020 <evision_api_awb_init_profiles+0x328>
34180d16:	ed9f abc6 	vldr	d10, [pc, #792]	@ 34181030 <evision_api_awb_init_profiles+0x338>
34180d1a:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34180d1e:	2000      	movs	r0, #0
34180d20:	49c9      	ldr	r1, [pc, #804]	@ (34181048 <evision_api_awb_init_profiles+0x350>)
34180d22:	f04f 0800 	mov.w	r8, #0
34180d26:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34180d2a:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34180d2e:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34180d32:	49c6      	ldr	r1, [pc, #792]	@ (3418104c <evision_api_awb_init_profiles+0x354>)
34180d34:	f8df 9348 	ldr.w	r9, [pc, #840]	@ 34181080 <evision_api_awb_init_profiles+0x388>
34180d38:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34180d3c:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34180d40:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34180d44:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34180d48:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34180d4c:	f20f 29e8 	addw	r9, pc, #744	@ 0x2e8
34180d50:	e9d9 8900 	ldrd	r8, r9, [r9]
34180d54:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34180d58:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34180d5c:	f04f 0800 	mov.w	r8, #0
34180d60:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34180d64:	49ba      	ldr	r1, [pc, #744]	@ (34181050 <evision_api_awb_init_profiles+0x358>)
34180d66:	f8df 931c 	ldr.w	r9, [pc, #796]	@ 34181084 <evision_api_awb_init_profiles+0x38c>
34180d6a:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34180d6e:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34180d72:	2300      	movs	r3, #0
34180d74:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34180d78:	2701      	movs	r7, #1
34180d7a:	f04f 0800 	mov.w	r8, #0
34180d7e:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34180d82:	1e69      	subs	r1, r5, #1
34180d84:	f8df 9300 	ldr.w	r9, [pc, #768]	@ 34181088 <evision_api_awb_init_profiles+0x390>
34180d88:	b288      	uxth	r0, r1
34180d8a:	2804      	cmp	r0, #4
34180d8c:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34180d90:	f20f 29ac 	addw	r9, pc, #684	@ 0x2ac
34180d94:	e9d9 8900 	ldrd	r8, r9, [r9]
34180d98:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34180d9c:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34180da0:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34180da4:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34180da8:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34180dac:	d914      	bls.n	34180dd8 <evision_api_awb_init_profiles+0xe0>
34180dae:	2305      	movs	r3, #5
34180db0:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180db4:	4aa7      	ldr	r2, [pc, #668]	@ (34181054 <evision_api_awb_init_profiles+0x35c>)
34180db6:	a808      	add	r0, sp, #32
34180db8:	f022 fecc 	bl	341a3b54 <sniprintf>
34180dbc:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180dc0:	a808      	add	r0, sp, #32
34180dc2:	4798      	blx	r3
34180dc4:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34180dc8:	4620      	mov	r0, r4
34180dca:	b049      	add	sp, #292	@ 0x124
34180dcc:	ecbd 8b06 	vpop	{d8-d10}
34180dd0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34180dd4:	f7ff bec4 	b.w	34180b60 <RGqhTVOsSg>
34180dd8:	ed96 7a00 	vldr	s14, [r6]
34180ddc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180de0:	eeb4 0bc7 	vcmpe.f64	d0, d7
34180de4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180de8:	dd12      	ble.n	34180e10 <evision_api_awb_init_profiles+0x118>
34180dea:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180dee:	489a      	ldr	r0, [pc, #616]	@ (34181058 <evision_api_awb_init_profiles+0x360>)
34180df0:	4798      	blx	r3
34180df2:	ed96 7a00 	vldr	s14, [r6]
34180df6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180dfa:	ed8d 9b00 	vstr	d9, [sp]
34180dfe:	ed8d 7b02 	vstr	d7, [sp, #8]
34180e02:	4a96      	ldr	r2, [pc, #600]	@ (3418105c <evision_api_awb_init_profiles+0x364>)
34180e04:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180e08:	a808      	add	r0, sp, #32
34180e0a:	f022 fea3 	bl	341a3b54 <sniprintf>
34180e0e:	e7d5      	b.n	34180dbc <evision_api_awb_init_profiles+0xc4>
34180e10:	f04f 0844 	mov.w	r8, #68	@ 0x44
34180e14:	fb08 f805 	mul.w	r8, r8, r5
34180e18:	eb06 0908 	add.w	r9, r6, r8
34180e1c:	ed19 7a11 	vldr	s14, [r9, #-68]	@ 0xffffffbc
34180e20:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180e24:	eeb4 1bc7 	vcmpe.f64	d1, d7
34180e28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180e2c:	d445      	bmi.n	34180eba <evision_api_awb_init_profiles+0x1c2>
34180e2e:	46b3      	mov	fp, r6
34180e30:	4637      	mov	r7, r6
34180e32:	4699      	mov	r9, r3
34180e34:	4628      	mov	r0, r5
34180e36:	3801      	subs	r0, #1
34180e38:	d14d      	bne.n	34180ed6 <evision_api_awb_init_profiles+0x1de>
34180e3a:	4610      	mov	r0, r2
34180e3c:	4691      	mov	r9, r2
34180e3e:	2700      	movs	r7, #0
34180e40:	f1a5 0e02 	sub.w	lr, r5, #2
34180e44:	f101 0c01 	add.w	ip, r1, #1
34180e48:	f1bc 0c01 	subs.w	ip, ip, #1
34180e4c:	d175      	bne.n	34180f3a <evision_api_awb_init_profiles+0x242>
34180e4e:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34180e52:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
34180e56:	f021 4140 	bic.w	r1, r1, #3221225472	@ 0xc0000000
34180e5a:	f8a4 50f8 	strh.w	r5, [r4, #248]	@ 0xf8
34180e5e:	f504 7388 	add.w	r3, r4, #272	@ 0x110
34180e62:	3101      	adds	r1, #1
34180e64:	3901      	subs	r1, #1
34180e66:	f040 80bf 	bne.w	34180fe8 <evision_api_awb_init_profiles+0x2f0>
34180e6a:	2700      	movs	r7, #0
34180e6c:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34180e70:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34180e74:	eb06 0b07 	add.w	fp, r6, r7
34180e78:	eb09 0007 	add.w	r0, r9, r7
34180e7c:	2244      	movs	r2, #68	@ 0x44
34180e7e:	4659      	mov	r1, fp
34180e80:	f023 f80b 	bl	341a3e9a <memcpy>
34180e84:	3744      	adds	r7, #68	@ 0x44
34180e86:	f8db 3000 	ldr.w	r3, [fp]
34180e8a:	45b8      	cmp	r8, r7
34180e8c:	f84a 3b04 	str.w	r3, [sl], #4
34180e90:	d1f0      	bne.n	34180e74 <evision_api_awb_init_profiles+0x17c>
34180e92:	1e6b      	subs	r3, r5, #1
34180e94:	b29b      	uxth	r3, r3
34180e96:	2d00      	cmp	r5, #0
34180e98:	f103 0301 	add.w	r3, r3, #1
34180e9c:	bf14      	ite	ne
34180e9e:	461a      	movne	r2, r3
34180ea0:	2201      	moveq	r2, #1
34180ea2:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34180ea6:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34180eaa:	3a01      	subs	r2, #1
34180eac:	f040 80a1 	bne.w	34180ff2 <evision_api_awb_init_profiles+0x2fa>
34180eb0:	2301      	movs	r3, #1
34180eb2:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34180eb6:	7023      	strb	r3, [r4, #0]
34180eb8:	e786      	b.n	34180dc8 <evision_api_awb_init_profiles+0xd0>
34180eba:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180ebe:	4868      	ldr	r0, [pc, #416]	@ (34181060 <evision_api_awb_init_profiles+0x368>)
34180ec0:	4798      	blx	r3
34180ec2:	ed99 7a00 	vldr	s14, [r9]
34180ec6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180eca:	ed8d 8b00 	vstr	d8, [sp]
34180ece:	ed8d 7b02 	vstr	d7, [sp, #8]
34180ed2:	4a64      	ldr	r2, [pc, #400]	@ (34181064 <evision_api_awb_init_profiles+0x36c>)
34180ed4:	e796      	b.n	34180e04 <evision_api_awb_init_profiles+0x10c>
34180ed6:	46ba      	mov	sl, r7
34180ed8:	ed9a 7a00 	vldr	s14, [sl]
34180edc:	edda 7a11 	vldr	s15, [sl, #68]	@ 0x44
34180ee0:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180ee8:	f109 0301 	add.w	r3, r9, #1
34180eec:	f107 0744 	add.w	r7, r7, #68	@ 0x44
34180ef0:	db21      	blt.n	34180f36 <evision_api_awb_init_profiles+0x23e>
34180ef2:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34180ef6:	485c      	ldr	r0, [pc, #368]	@ (34181068 <evision_api_awb_init_profiles+0x370>)
34180ef8:	9307      	str	r3, [sp, #28]
34180efa:	4790      	blx	r2
34180efc:	ed97 7a00 	vldr	s14, [r7]
34180f00:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f04:	ed8d 7b04 	vstr	d7, [sp, #16]
34180f08:	9b07      	ldr	r3, [sp, #28]
34180f0a:	4a58      	ldr	r2, [pc, #352]	@ (3418106c <evision_api_awb_init_profiles+0x374>)
34180f0c:	9302      	str	r3, [sp, #8]
34180f0e:	ed9a 7a00 	vldr	s14, [sl]
34180f12:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f16:	464b      	mov	r3, r9
34180f18:	ed8d 7b00 	vstr	d7, [sp]
34180f1c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180f20:	a808      	add	r0, sp, #32
34180f22:	f022 fe17 	bl	341a3b54 <sniprintf>
34180f26:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180f2a:	a808      	add	r0, sp, #32
34180f2c:	4798      	blx	r3
34180f2e:	2301      	movs	r3, #1
34180f30:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34180f34:	e748      	b.n	34180dc8 <evision_api_awb_init_profiles+0xd0>
34180f36:	4699      	mov	r9, r3
34180f38:	e77d      	b.n	34180e36 <evision_api_awb_init_profiles+0x13e>
34180f3a:	45be      	cmp	lr, r7
34180f3c:	46ca      	mov	sl, r9
34180f3e:	f107 0201 	add.w	r2, r7, #1
34180f42:	ecf9 7a01 	vldmia	r9!, {s15}
34180f46:	d91c      	bls.n	34180f82 <evision_api_awb_init_profiles+0x28a>
34180f48:	ed99 7a00 	vldr	s14, [r9]
34180f4c:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180f54:	d815      	bhi.n	34180f82 <evision_api_awb_init_profiles+0x28a>
34180f56:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180f5a:	4845      	ldr	r0, [pc, #276]	@ (34181070 <evision_api_awb_init_profiles+0x378>)
34180f5c:	9207      	str	r2, [sp, #28]
34180f5e:	4798      	blx	r3
34180f60:	ed99 7a00 	vldr	s14, [r9]
34180f64:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f68:	ed8d 7b04 	vstr	d7, [sp, #16]
34180f6c:	9a07      	ldr	r2, [sp, #28]
34180f6e:	463b      	mov	r3, r7
34180f70:	9202      	str	r2, [sp, #8]
34180f72:	ed9a 7a00 	vldr	s14, [sl]
34180f76:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f7a:	4a3e      	ldr	r2, [pc, #248]	@ (34181074 <evision_api_awb_init_profiles+0x37c>)
34180f7c:	ed8d 7b00 	vstr	d7, [sp]
34180f80:	e7cc      	b.n	34180f1c <evision_api_awb_init_profiles+0x224>
34180f82:	465b      	mov	r3, fp
34180f84:	ed93 7a00 	vldr	s14, [r3]
34180f88:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180f90:	f10b 0b44 	add.w	fp, fp, #68	@ 0x44
34180f94:	da06      	bge.n	34180fa4 <evision_api_awb_init_profiles+0x2ac>
34180f96:	ed93 7a11 	vldr	s14, [r3, #68]	@ 0x44
34180f9a:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180fa2:	d81f      	bhi.n	34180fe4 <evision_api_awb_init_profiles+0x2ec>
34180fa4:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34180fa8:	4833      	ldr	r0, [pc, #204]	@ (34181078 <evision_api_awb_init_profiles+0x380>)
34180faa:	9307      	str	r3, [sp, #28]
34180fac:	4790      	blx	r2
34180fae:	ed9b 7a00 	vldr	s14, [fp]
34180fb2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fb6:	ed8d 7b04 	vstr	d7, [sp, #16]
34180fba:	9b07      	ldr	r3, [sp, #28]
34180fbc:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180fc0:	ed93 7a00 	vldr	s14, [r3]
34180fc4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fc8:	ed8d 7b02 	vstr	d7, [sp, #8]
34180fcc:	ed9a 7a00 	vldr	s14, [sl]
34180fd0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fd4:	463b      	mov	r3, r7
34180fd6:	ed8d 7b00 	vstr	d7, [sp]
34180fda:	4a28      	ldr	r2, [pc, #160]	@ (3418107c <evision_api_awb_init_profiles+0x384>)
34180fdc:	a808      	add	r0, sp, #32
34180fde:	f022 fdb9 	bl	341a3b54 <sniprintf>
34180fe2:	e7a0      	b.n	34180f26 <evision_api_awb_init_profiles+0x22e>
34180fe4:	4617      	mov	r7, r2
34180fe6:	e72f      	b.n	34180e48 <evision_api_awb_init_profiles+0x150>
34180fe8:	f850 2b04 	ldr.w	r2, [r0], #4
34180fec:	f843 2b04 	str.w	r2, [r3], #4
34180ff0:	e738      	b.n	34180e64 <evision_api_awb_init_profiles+0x16c>
34180ff2:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34180ff6:	ed91 6a00 	vldr	s12, [r1]
34180ffa:	ed93 7a00 	vldr	s14, [r3]
34180ffe:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34181002:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34181006:	ee36 6b4a 	vsub.f64	d6, d6, d10
3418100a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3418100e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34181012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181016:	bf48      	it	mi
34181018:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3418101c:	3144      	adds	r1, #68	@ 0x44
3418101e:	e744      	b.n	34180eaa <evision_api_awb_init_profiles+0x1b2>
34181020:	f04f 30ff 	mov.w	r0, #4294967295
34181024:	b049      	add	sp, #292	@ 0x124
34181026:	ecbd 8b06 	vpop	{d8-d10}
3418102a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3418102e:	bf00      	nop
34181030:	00000000 	.word	0x00000000
34181034:	40b38800 	.word	0x40b38800
34181038:	9999999a 	.word	0x9999999a
3418103c:	3fb99999 	.word	0x3fb99999
34181040:	00000000 	.word	0x00000000
34181044:	406ea000 	.word	0x406ea000
34181048:	3ff00000 	.word	0x3ff00000
3418104c:	42480000 	.word	0x42480000
34181050:	432f0000 	.word	0x432f0000
34181054:	341b76cc 	.word	0x341b76cc
34181058:	341b7710 	.word	0x341b7710
3418105c:	341b7797 	.word	0x341b7797
34181060:	341b77f5 	.word	0x341b77f5
34181064:	341b787d 	.word	0x341b787d
34181068:	341b78da 	.word	0x341b78da
3418106c:	341b793e 	.word	0x341b793e
34181070:	341b7996 	.word	0x341b7996
34181074:	341b7a05 	.word	0x341b7a05
34181078:	341b7a6f 	.word	0x341b7a6f
3418107c:	341b7ac6 	.word	0x341b7ac6
34181080:	bff00000 	.word	0xbff00000
34181084:	40080000 	.word	0x40080000
34181088:	40240000 	.word	0x40240000

3418108c <evision_api_awb_run_average>:
3418108c:	b530      	push	{r4, r5, lr}
3418108e:	4605      	mov	r5, r0
34181090:	4614      	mov	r4, r2
34181092:	b08d      	sub	sp, #52	@ 0x34
34181094:	b952      	cbnz	r2, 341810ac <evision_api_awb_run_average+0x20>
34181096:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
3418109a:	481d      	ldr	r0, [pc, #116]	@ (34181110 <evision_api_awb_run_average+0x84>)
3418109c:	4798      	blx	r3
3418109e:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
341810a2:	481c      	ldr	r0, [pc, #112]	@ (34181114 <evision_api_awb_run_average+0x88>)
341810a4:	4798      	blx	r3
341810a6:	4620      	mov	r0, r4
341810a8:	b00d      	add	sp, #52	@ 0x34
341810aa:	bd30      	pop	{r4, r5, pc}
341810ac:	ed93 2b04 	vldr	d2, [r3, #16]
341810b0:	ed93 1b02 	vldr	d1, [r3, #8]
341810b4:	ed93 0b00 	vldr	d0, [r3]
341810b8:	aa0a      	add	r2, sp, #40	@ 0x28
341810ba:	a908      	add	r1, sp, #32
341810bc:	a806      	add	r0, sp, #24
341810be:	f000 f82f 	bl	34181120 <VGuzhuiVXN>
341810c2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
341810c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
341810ca:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
341810ce:	e9cd 2304 	strd	r2, r3, [sp, #16]
341810d2:	2301      	movs	r3, #1
341810d4:	4298      	cmp	r0, r3
341810d6:	4604      	mov	r4, r0
341810d8:	e9cd 3300 	strd	r3, r3, [sp]
341810dc:	d1df      	bne.n	3418109e <evision_api_awb_run_average+0x12>
341810de:	4669      	mov	r1, sp
341810e0:	4628      	mov	r0, r5
341810e2:	f7ff fb55 	bl	34180790 <vVjsiRnEsi>
341810e6:	2801      	cmp	r0, #1
341810e8:	4604      	mov	r4, r0
341810ea:	d003      	beq.n	341810f4 <evision_api_awb_run_average+0x68>
341810ec:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
341810f0:	4809      	ldr	r0, [pc, #36]	@ (34181118 <evision_api_awb_run_average+0x8c>)
341810f2:	e7d7      	b.n	341810a4 <evision_api_awb_run_average+0x18>
341810f4:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
341810f8:	2b01      	cmp	r3, #1
341810fa:	d1d4      	bne.n	341810a6 <evision_api_awb_run_average+0x1a>
341810fc:	4628      	mov	r0, r5
341810fe:	f7ff fd2f 	bl	34180b60 <RGqhTVOsSg>
34181102:	2801      	cmp	r0, #1
34181104:	4604      	mov	r4, r0
34181106:	d0ce      	beq.n	341810a6 <evision_api_awb_run_average+0x1a>
34181108:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3418110c:	4803      	ldr	r0, [pc, #12]	@ (3418111c <evision_api_awb_run_average+0x90>)
3418110e:	e7c9      	b.n	341810a4 <evision_api_awb_run_average+0x18>
34181110:	341b7b4c 	.word	0x341b7b4c
34181114:	341b7bad 	.word	0x341b7bad
34181118:	341b7bd6 	.word	0x341b7bd6
3418111c:	341b7c0a 	.word	0x341b7c0a

34181120 <VGuzhuiVXN>:
34181120:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34181124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3418112a:	eeb0 7b41 	vmov.f64	d7, d1
3418112e:	4613      	mov	r3, r2
34181130:	d409      	bmi.n	34181146 <VGuzhuiVXN+0x26>
34181132:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
34181136:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418113a:	d404      	bmi.n	34181146 <VGuzhuiVXN+0x26>
3418113c:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
34181140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181144:	d50d      	bpl.n	34181162 <VGuzhuiVXN+0x42>
34181146:	ed8d 2b02 	vstr	d2, [sp, #8]
3418114a:	ed8d 7b00 	vstr	d7, [sp]
3418114e:	ec53 2b10 	vmov	r2, r3, d0
34181152:	4845      	ldr	r0, [pc, #276]	@ (34181268 <VGuzhuiVXN+0x148>)
34181154:	f022 fc8e 	bl	341a3a74 <iprintf>
34181158:	f04f 30ff 	mov.w	r0, #4294967295
3418115c:	b005      	add	sp, #20
3418115e:	f85d fb04 	ldr.w	pc, [sp], #4
34181162:	ed9f 6b33 	vldr	d6, [pc, #204]	@ 34181230 <VGuzhuiVXN+0x110>
34181166:	eeb4 0bc6 	vcmpe.f64	d0, d6
3418116a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418116e:	dc09      	bgt.n	34181184 <VGuzhuiVXN+0x64>
34181170:	eeb4 1bc6 	vcmpe.f64	d1, d6
34181174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181178:	dc04      	bgt.n	34181184 <VGuzhuiVXN+0x64>
3418117a:	eeb4 2bc6 	vcmpe.f64	d2, d6
3418117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181182:	dd07      	ble.n	34181194 <VGuzhuiVXN+0x74>
34181184:	ed8d 2b02 	vstr	d2, [sp, #8]
34181188:	ed8d 7b00 	vstr	d7, [sp]
3418118c:	ec53 2b10 	vmov	r2, r3, d0
34181190:	4836      	ldr	r0, [pc, #216]	@ (3418126c <VGuzhuiVXN+0x14c>)
34181192:	e7df      	b.n	34181154 <VGuzhuiVXN+0x34>
34181194:	b128      	cbz	r0, 341811a2 <VGuzhuiVXN+0x82>
34181196:	b181      	cbz	r1, 341811ba <VGuzhuiVXN+0x9a>
34181198:	b9aa      	cbnz	r2, 341811c6 <VGuzhuiVXN+0xa6>
3418119a:	4935      	ldr	r1, [pc, #212]	@ (34181270 <VGuzhuiVXN+0x150>)
3418119c:	4b35      	ldr	r3, [pc, #212]	@ (34181274 <VGuzhuiVXN+0x154>)
3418119e:	460a      	mov	r2, r1
341811a0:	e007      	b.n	341811b2 <VGuzhuiVXN+0x92>
341811a2:	b969      	cbnz	r1, 341811c0 <VGuzhuiVXN+0xa0>
341811a4:	4933      	ldr	r1, [pc, #204]	@ (34181274 <VGuzhuiVXN+0x154>)
341811a6:	460a      	mov	r2, r1
341811a8:	4832      	ldr	r0, [pc, #200]	@ (34181274 <VGuzhuiVXN+0x154>)
341811aa:	2b00      	cmp	r3, #0
341811ac:	4b30      	ldr	r3, [pc, #192]	@ (34181270 <VGuzhuiVXN+0x150>)
341811ae:	bf08      	it	eq
341811b0:	4603      	moveq	r3, r0
341811b2:	4831      	ldr	r0, [pc, #196]	@ (34181278 <VGuzhuiVXN+0x158>)
341811b4:	f022 fc5e 	bl	341a3a74 <iprintf>
341811b8:	e7ce      	b.n	34181158 <VGuzhuiVXN+0x38>
341811ba:	492d      	ldr	r1, [pc, #180]	@ (34181270 <VGuzhuiVXN+0x150>)
341811bc:	4a2d      	ldr	r2, [pc, #180]	@ (34181274 <VGuzhuiVXN+0x154>)
341811be:	e7f3      	b.n	341811a8 <VGuzhuiVXN+0x88>
341811c0:	492c      	ldr	r1, [pc, #176]	@ (34181274 <VGuzhuiVXN+0x154>)
341811c2:	4a2b      	ldr	r2, [pc, #172]	@ (34181270 <VGuzhuiVXN+0x150>)
341811c4:	e7f0      	b.n	341811a8 <VGuzhuiVXN+0x88>
341811c6:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34181238 <VGuzhuiVXN+0x118>
341811ca:	ed9f 5b1d 	vldr	d5, [pc, #116]	@ 34181240 <VGuzhuiVXN+0x120>
341811ce:	ee21 6b06 	vmul.f64	d6, d1, d6
341811d2:	eeb3 4b00 	vmov.f64	d4, #48	@ 0x41800000  16.0
341811d6:	eea0 6b05 	vfma.f64	d6, d0, d5
341811da:	ed9f 5b1b 	vldr	d5, [pc, #108]	@ 34181248 <VGuzhuiVXN+0x128>
341811de:	eea2 6b04 	vfma.f64	d6, d2, d4
341811e2:	eea6 4b05 	vfma.f64	d4, d6, d5
341811e6:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34181250 <VGuzhuiVXN+0x130>
341811ea:	ed80 4b00 	vstr	d4, [r0]
341811ee:	ee26 6b41 	vnmul.f64	d6, d6, d1
341811f2:	eebb 4b0a 	vmov.f64	d4, #186	@ 0xc1d00000 -26.0
341811f6:	ed9f 1b18 	vldr	d1, [pc, #96]	@ 34181258 <VGuzhuiVXN+0x138>
341811fa:	eea0 6b04 	vfma.f64	d6, d0, d4
341811fe:	ee21 1b47 	vnmul.f64	d1, d1, d7
34181202:	ed9f 4b17 	vldr	d4, [pc, #92]	@ 34181260 <VGuzhuiVXN+0x140>
34181206:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
3418120a:	eea0 1b04 	vfma.f64	d1, d0, d4
3418120e:	eea2 6b04 	vfma.f64	d6, d2, d4
34181212:	eea2 1b47 	vfms.f64	d1, d2, d7
34181216:	ee26 6b05 	vmul.f64	d6, d6, d5
3418121a:	ee21 1b05 	vmul.f64	d1, d1, d5
3418121e:	ed81 6b00 	vstr	d6, [r1]
34181222:	2001      	movs	r0, #1
34181224:	ed82 1b00 	vstr	d1, [r2]
34181228:	e798      	b.n	3418115c <VGuzhuiVXN+0x3c>
3418122a:	bf00      	nop
3418122c:	f3af 8000 	nop.w
34181230:	00000000 	.word	0x00000000
34181234:	406fe000 	.word	0x406fe000
34181238:	00000000 	.word	0x00000000
3418123c:	4063a000 	.word	0x4063a000
34181240:	00000000 	.word	0x00000000
34181244:	40478000 	.word	0x40478000
34181248:	00000000 	.word	0x00000000
3418124c:	3f700000 	.word	0x3f700000
34181250:	00000000 	.word	0x00000000
34181254:	40558000 	.word	0x40558000
34181258:	00000000 	.word	0x00000000
3418125c:	40598000 	.word	0x40598000
34181260:	00000000 	.word	0x00000000
34181264:	405c0000 	.word	0x405c0000
34181268:	341b7c47 	.word	0x341b7c47
3418126c:	341b7c85 	.word	0x341b7c85
34181270:	341b7c41 	.word	0x341b7c41
34181274:	341b7c3f 	.word	0x341b7c3f
34181278:	341b7cc5 	.word	0x341b7cc5
3418127c:	00000000 	.word	0x00000000

34181280 <GTePMGhCOh>:
34181280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34181284:	4606      	mov	r6, r0
34181286:	4698      	mov	r8, r3
34181288:	6d73      	ldr	r3, [r6, #84]	@ 0x54
3418128a:	460f      	mov	r7, r1
3418128c:	4610      	mov	r0, r2
3418128e:	9906      	ldr	r1, [sp, #24]
34181290:	b923      	cbnz	r3, 3418129c <GTePMGhCOh+0x1c>
34181292:	f8c8 7000 	str.w	r7, [r8]
34181296:	6008      	str	r0, [r1, #0]
34181298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3418129c:	4d20      	ldr	r5, [pc, #128]	@ (34181320 <GTePMGhCOh+0xa0>)
3418129e:	005b      	lsls	r3, r3, #1
341812a0:	fbb5 f5f3 	udiv	r5, r5, r3
341812a4:	4295      	cmp	r5, r2
341812a6:	d2f4      	bcs.n	34181292 <GTePMGhCOh+0x12>
341812a8:	fbb2 f4f5 	udiv	r4, r2, r5
341812ac:	ee07 2a90 	vmov	s15, r2
341812b0:	fb04 5205 	mla	r2, r4, r5, r5
341812b4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341812b8:	ee07 2a90 	vmov	s15, r2
341812bc:	eddf 6a19 	vldr	s13, [pc, #100]	@ 34181324 <GTePMGhCOh+0xa4>
341812c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
341812c4:	ee67 7aa6 	vmul.f32	s15, s15, s13
341812c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
341812cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341812d0:	d5df      	bpl.n	34181292 <GTePMGhCOh+0x12>
341812d2:	1b52      	subs	r2, r2, r5
341812d4:	600a      	str	r2, [r1, #0]
341812d6:	3201      	adds	r2, #1
341812d8:	ee07 2a90 	vmov	s15, r2
341812dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
341812e0:	ee87 0a27 	vdiv.f32	s0, s14, s15
341812e4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341812e8:	f023 fcd6 	bl	341a4c98 <log10>
341812ec:	ed9f 7b0a 	vldr	d7, [pc, #40]	@ 34181318 <GTePMGhCOh+0x98>
341812f0:	ee20 0b07 	vmul.f64	d0, d0, d7
341812f4:	eebc 0bc0 	vcvt.u32.f64	s0, d0
341812f8:	ee10 3a10 	vmov	r3, s0
341812fc:	443b      	add	r3, r7
341812fe:	461f      	mov	r7, r3
34181300:	f8c8 3000 	str.w	r3, [r8]
34181304:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
34181306:	42bb      	cmp	r3, r7
34181308:	bf94      	ite	ls
3418130a:	f8c8 3000 	strls.w	r3, [r8]
3418130e:	f8c8 7000 	strhi.w	r7, [r8]
34181312:	e7c1      	b.n	34181298 <GTePMGhCOh+0x18>
34181314:	f3af 8000 	nop.w
34181318:	00000000 	.word	0x00000000
3418131c:	40d38800 	.word	0x40d38800
34181320:	000f4240 	.word	0x000f4240
34181324:	3f733333 	.word	0x3f733333

34181328 <jHlPSTIzmc>:
34181328:	ee07 1a90 	vmov	s15, r1
3418132c:	ed9f 7a28 	vldr	s14, [pc, #160]	@ 341813d0 <jHlPSTIzmc+0xa8>
34181330:	eef8 7a67 	vcvt.f32.u32	s15, s15
34181334:	b570      	push	{r4, r5, r6, lr}
34181336:	ee87 1a87 	vdiv.f32	s2, s15, s14
3418133a:	ed2d 8b02 	vpush	{d8}
3418133e:	ee08 2a10 	vmov	s16, r2
34181342:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
34181346:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3418134a:	4605      	mov	r5, r0
3418134c:	461c      	mov	r4, r3
3418134e:	9e06      	ldr	r6, [sp, #24]
34181350:	f023 fd32 	bl	341a4db8 <pow>
34181354:	eeb8 7b48 	vcvt.f64.u32	d7, s16
34181358:	ee27 7b00 	vmul.f64	d7, d7, d0
3418135c:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34181360:	ee17 2a90 	vmov	r2, s15
34181364:	6c69      	ldr	r1, [r5, #68]	@ 0x44
34181366:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418136a:	4291      	cmp	r1, r2
3418136c:	d916      	bls.n	3418139c <jHlPSTIzmc+0x74>
3418136e:	2300      	movs	r3, #0
34181370:	6023      	str	r3, [r4, #0]
34181372:	edc6 7a00 	vstr	s15, [r6]
34181376:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34181378:	eddf 6a16 	vldr	s13, [pc, #88]	@ 341813d4 <jHlPSTIzmc+0xac>
3418137c:	ee07 3a90 	vmov	s15, r3
34181380:	eef8 7a67 	vcvt.f32.u32	s15, s15
34181384:	ee67 7aa6 	vmul.f32	s15, s15, s13
34181388:	eeb4 7a67 	vcmp.f32	s14, s15
3418138c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181390:	bfc8      	it	gt
34181392:	461a      	movgt	r2, r3
34181394:	6032      	str	r2, [r6, #0]
34181396:	ecbd 8b02 	vpop	{d8}
3418139a:	bd70      	pop	{r4, r5, r6, pc}
3418139c:	ee07 1a90 	vmov	s15, r1
341813a0:	eef8 7a67 	vcvt.f32.u32	s15, s15
341813a4:	ee87 0a27 	vdiv.f32	s0, s14, s15
341813a8:	6031      	str	r1, [r6, #0]
341813aa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341813ae:	f023 fc73 	bl	341a4c98 <log10>
341813b2:	ed9f 7b05 	vldr	d7, [pc, #20]	@ 341813c8 <jHlPSTIzmc+0xa0>
341813b6:	ee20 0b07 	vmul.f64	d0, d0, d7
341813ba:	eebc 0bc0 	vcvt.u32.f64	s0, d0
341813be:	ed84 0a00 	vstr	s0, [r4]
341813c2:	e7e8      	b.n	34181396 <jHlPSTIzmc+0x6e>
341813c4:	f3af 8000 	nop.w
341813c8:	00000000 	.word	0x00000000
341813cc:	40d38800 	.word	0x40d38800
341813d0:	469c4000 	.word	0x469c4000
341813d4:	3f7ae148 	.word	0x3f7ae148

341813d8 <evision_api_st_ae_new>:
341813d8:	b510      	push	{r4, lr}
341813da:	b090      	sub	sp, #64	@ 0x40
341813dc:	b168      	cbz	r0, 341813fa <evision_api_st_ae_new+0x22>
341813de:	2200      	movs	r2, #0
341813e0:	4c07      	ldr	r4, [pc, #28]	@ (34181400 <evision_api_st_ae_new+0x28>)
341813e2:	2140      	movs	r1, #64	@ 0x40
341813e4:	4b07      	ldr	r3, [pc, #28]	@ (34181404 <evision_api_st_ae_new+0x2c>)
341813e6:	7022      	strb	r2, [r4, #0]
341813e8:	65a0      	str	r0, [r4, #88]	@ 0x58
341813ea:	4a07      	ldr	r2, [pc, #28]	@ (34181408 <evision_api_st_ae_new+0x30>)
341813ec:	4668      	mov	r0, sp
341813ee:	f022 fbb1 	bl	341a3b54 <sniprintf>
341813f2:	4668      	mov	r0, sp
341813f4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
341813f6:	4798      	blx	r3
341813f8:	4620      	mov	r0, r4
341813fa:	b010      	add	sp, #64	@ 0x40
341813fc:	bd10      	pop	{r4, pc}
341813fe:	bf00      	nop
34181400:	341c0480 	.word	0x341c0480
34181404:	341ba14e 	.word	0x341ba14e
34181408:	341b7d0f 	.word	0x341b7d0f

3418140c <evision_api_st_ae_delete>:
3418140c:	2800      	cmp	r0, #0
3418140e:	bf0c      	ite	eq
34181410:	f04f 30ff 	moveq.w	r0, #4294967295
34181414:	2001      	movne	r0, #1
34181416:	4770      	bx	lr

34181418 <BnNqZEfmZx>:
34181418:	2238      	movs	r2, #56	@ 0x38
3418141a:	230a      	movs	r3, #10
3418141c:	b530      	push	{r4, r5, lr}
3418141e:	e9c0 2304 	strd	r2, r3, [r0, #16]
34181422:	2264      	movs	r2, #100	@ 0x64
34181424:	232d      	movs	r3, #45	@ 0x2d
34181426:	2178      	movs	r1, #120	@ 0x78
34181428:	e9c0 2306 	strd	r2, r3, [r0, #24]
3418142c:	f240 53dc 	movw	r3, #1500	@ 0x5dc
34181430:	f241 7470 	movw	r4, #6000	@ 0x1770
34181434:	e9c0 1308 	strd	r1, r3, [r0, #32]
34181438:	f642 63e0 	movw	r3, #12000	@ 0x2ee0
3418143c:	e9c0 430a 	strd	r4, r3, [r0, #40]	@ 0x28
34181440:	a50b      	add	r5, pc, #44	@ (adr r5, 34181470 <BnNqZEfmZx+0x58>)
34181442:	e9d5 4500 	ldrd	r4, r5, [r5]
34181446:	2305      	movs	r3, #5
34181448:	f248 01e8 	movw	r1, #33000	@ 0x80e8
3418144c:	6503      	str	r3, [r0, #80]	@ 0x50
3418144e:	2300      	movs	r3, #0
34181450:	e9c0 3110 	strd	r3, r1, [r0, #64]	@ 0x40
34181454:	2101      	movs	r1, #1
34181456:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3418145a:	a507      	add	r5, pc, #28	@ (adr r5, 34181478 <BnNqZEfmZx+0x60>)
3418145c:	e9d5 4500 	ldrd	r4, r5, [r5]
34181460:	e9c0 1212 	strd	r1, r2, [r0, #72]	@ 0x48
34181464:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
34181468:	6543      	str	r3, [r0, #84]	@ 0x54
3418146a:	bd30      	pop	{r4, r5, pc}
3418146c:	f3af 8000 	nop.w
34181470:	40000000 	.word	0x40000000
34181474:	3f947ae1 	.word	0x3f947ae1
34181478:	e0000000 	.word	0xe0000000
3418147c:	3f70624d 	.word	0x3f70624d

34181480 <evision_api_st_ae_init>:
34181480:	b510      	push	{r4, lr}
34181482:	4604      	mov	r4, r0
34181484:	b120      	cbz	r0, 34181490 <evision_api_st_ae_init+0x10>
34181486:	f7ff ffc7 	bl	34181418 <BnNqZEfmZx>
3418148a:	2001      	movs	r0, #1
3418148c:	7020      	strb	r0, [r4, #0]
3418148e:	bd10      	pop	{r4, pc}
34181490:	f04f 30ff 	mov.w	r0, #4294967295
34181494:	e7fb      	b.n	3418148e <evision_api_st_ae_init+0xe>

34181496 <evision_api_st_ae_process>:
34181496:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3418149a:	460f      	mov	r7, r1
3418149c:	4615      	mov	r5, r2
3418149e:	4698      	mov	r8, r3
341814a0:	4604      	mov	r4, r0
341814a2:	b089      	sub	sp, #36	@ 0x24
341814a4:	2800      	cmp	r0, #0
341814a6:	f000 813b 	beq.w	34181720 <evision_api_st_ae_process+0x28a>
341814aa:	7803      	ldrb	r3, [r0, #0]
341814ac:	2b01      	cmp	r3, #1
341814ae:	d11c      	bne.n	341814ea <evision_api_st_ae_process+0x54>
341814b0:	2302      	movs	r3, #2
341814b2:	7003      	strb	r3, [r0, #0]
341814b4:	f8d4 9054 	ldr.w	r9, [r4, #84]	@ 0x54
341814b8:	f1b9 0f00 	cmp.w	r9, #0
341814bc:	d019      	beq.n	341814f2 <evision_api_st_ae_process+0x5c>
341814be:	4b9c      	ldr	r3, [pc, #624]	@ (34181730 <evision_api_st_ae_process+0x29a>)
341814c0:	ea4f 0249 	mov.w	r2, r9, lsl #1
341814c4:	fbb3 f3f2 	udiv	r3, r3, r2
341814c8:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
341814ca:	42be      	cmp	r6, r7
341814cc:	d213      	bcs.n	341814f6 <evision_api_st_ae_process+0x60>
341814ce:	6c62      	ldr	r2, [r4, #68]	@ 0x44
341814d0:	42aa      	cmp	r2, r5
341814d2:	d910      	bls.n	341814f6 <evision_api_st_ae_process+0x60>
341814d4:	fbb5 f2f3 	udiv	r2, r5, r3
341814d8:	fb03 5312 	mls	r3, r3, r2, r5
341814dc:	b15b      	cbz	r3, 341814f6 <evision_api_st_ae_process+0x60>
341814de:	e9c4 5601 	strd	r5, r6, [r4, #4]
341814e2:	2001      	movs	r0, #1
341814e4:	b009      	add	sp, #36	@ 0x24
341814e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341814ea:	2b02      	cmp	r3, #2
341814ec:	d0e2      	beq.n	341814b4 <evision_api_st_ae_process+0x1e>
341814ee:	2000      	movs	r0, #0
341814f0:	e7f8      	b.n	341814e4 <evision_api_st_ae_process+0x4e>
341814f2:	2301      	movs	r3, #1
341814f4:	e7e8      	b.n	341814c8 <evision_api_st_ae_process+0x32>
341814f6:	f10d 0a14 	add.w	sl, sp, #20
341814fa:	4639      	mov	r1, r7
341814fc:	ab04      	add	r3, sp, #16
341814fe:	462a      	mov	r2, r5
34181500:	4620      	mov	r0, r4
34181502:	f8cd a000 	str.w	sl, [sp]
34181506:	f7ff ff0f 	bl	34181328 <jHlPSTIzmc>
3418150a:	e9dd b104 	ldrd	fp, r1, [sp, #16]
3418150e:	f8d4 c010 	ldr.w	ip, [r4, #16]
34181512:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34181516:	ee07 ca90 	vmov	s15, ip
3418151a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3418151e:	ee07 8a90 	vmov	s15, r8
34181522:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34181526:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3418152a:	ee37 7b05 	vadd.f64	d7, d7, d5
3418152e:	ee86 0b07 	vdiv.f64	d0, d6, d7
34181532:	6d23      	ldr	r3, [r4, #80]	@ 0x50
34181534:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34181538:	4598      	cmp	r8, r3
3418153a:	d30e      	bcc.n	3418155a <evision_api_st_ae_process+0xc4>
3418153c:	ebac 0008 	sub.w	r0, ip, r8
34181540:	69e3      	ldr	r3, [r4, #28]
34181542:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
34181546:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
3418154a:	429a      	cmp	r2, r3
3418154c:	d959      	bls.n	34181602 <evision_api_st_ae_process+0x16c>
3418154e:	6a23      	ldr	r3, [r4, #32]
34181550:	429a      	cmp	r2, r3
34181552:	bf2c      	ite	cs
34181554:	6ae3      	ldrcs	r3, [r4, #44]	@ 0x2c
34181556:	6aa3      	ldrcc	r3, [r4, #40]	@ 0x28
34181558:	e054      	b.n	34181604 <evision_api_st_ae_process+0x16e>
3418155a:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
3418155e:	eeb4 0ae7 	vcmpe.f32	s0, s15
34181562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181566:	d4e9      	bmi.n	3418153c <evision_api_st_ae_process+0xa6>
34181568:	6c62      	ldr	r2, [r4, #68]	@ 0x44
3418156a:	4291      	cmp	r1, r2
3418156c:	d22b      	bcs.n	341815c6 <evision_api_st_ae_process+0x130>
3418156e:	2901      	cmp	r1, #1
34181570:	460b      	mov	r3, r1
34181572:	bf38      	it	cc
34181574:	2301      	movcc	r3, #1
34181576:	ee07 3a90 	vmov	s15, r3
3418157a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3418157e:	ee67 7a80 	vmul.f32	s15, s15, s0
34181582:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34181586:	ee17 3a90 	vmov	r3, s15
3418158a:	4293      	cmp	r3, r2
3418158c:	dc0e      	bgt.n	341815ac <evision_api_st_ae_process+0x116>
3418158e:	edc4 7a01 	vstr	s15, [r4, #4]
34181592:	ab07      	add	r3, sp, #28
34181594:	9300      	str	r3, [sp, #0]
34181596:	4620      	mov	r0, r4
34181598:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3418159c:	ab06      	add	r3, sp, #24
3418159e:	f7ff fe6f 	bl	34181280 <GTePMGhCOh>
341815a2:	9b06      	ldr	r3, [sp, #24]
341815a4:	60a3      	str	r3, [r4, #8]
341815a6:	9b07      	ldr	r3, [sp, #28]
341815a8:	6063      	str	r3, [r4, #4]
341815aa:	e79a      	b.n	341814e2 <evision_api_st_ae_process+0x4c>
341815ac:	ee07 2a90 	vmov	s15, r2
341815b0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
341815b4:	ee07 1a90 	vmov	s15, r1
341815b8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341815bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
341815c0:	ee80 0a27 	vdiv.f32	s0, s0, s15
341815c4:	6062      	str	r2, [r4, #4]
341815c6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341815ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
341815ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341815d2:	ddde      	ble.n	34181592 <evision_api_st_ae_process+0xfc>
341815d4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341815d8:	f023 fb5e 	bl	341a4c98 <log10>
341815dc:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
341815e0:	ee20 0b07 	vmul.f64	d0, d0, d7
341815e4:	ed9f 7b50 	vldr	d7, [pc, #320]	@ 34181728 <evision_api_st_ae_process+0x292>
341815e8:	ee20 0b07 	vmul.f64	d0, d0, d7
341815ec:	eebd 0bc0 	vcvt.s32.f64	s0, d0
341815f0:	ee10 3a10 	vmov	r3, s0
341815f4:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
341815f6:	445b      	add	r3, fp
341815f8:	4293      	cmp	r3, r2
341815fa:	bfd4      	ite	le
341815fc:	60a3      	strle	r3, [r4, #8]
341815fe:	60a2      	strgt	r2, [r4, #8]
34181600:	e7c7      	b.n	34181592 <evision_api_st_ae_process+0xfc>
34181602:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34181604:	f8d4 e014 	ldr.w	lr, [r4, #20]
34181608:	69a2      	ldr	r2, [r4, #24]
3418160a:	9303      	str	r3, [sp, #12]
3418160c:	eb0e 030c 	add.w	r3, lr, ip
34181610:	4543      	cmp	r3, r8
34181612:	fb00 f202 	mul.w	r2, r0, r2
34181616:	d24c      	bcs.n	341816b2 <evision_api_st_ae_process+0x21c>
34181618:	eddd 7a03 	vldr	s15, [sp, #12]
3418161c:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 34181734 <evision_api_st_ae_process+0x29e>
34181620:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34181624:	ee67 7a87 	vmul.f32	s15, s15, s14
34181628:	ee07 2a10 	vmov	s14, r2
3418162c:	eef1 6a67 	vneg.f32	s13, s15
34181630:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34181634:	eeb4 7ae6 	vcmpe.f32	s14, s13
34181638:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418163c:	d504      	bpl.n	34181648 <evision_api_st_ae_process+0x1b2>
3418163e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34181642:	ee17 3a90 	vmov	r3, s15
34181646:	425a      	negs	r2, r3
34181648:	2a00      	cmp	r2, #0
3418164a:	d057      	beq.n	341816fc <evision_api_st_ae_process+0x266>
3418164c:	455e      	cmp	r6, fp
3418164e:	d14a      	bne.n	341816e6 <evision_api_st_ae_process+0x250>
34181650:	6c65      	ldr	r5, [r4, #68]	@ 0x44
34181652:	42a9      	cmp	r1, r5
34181654:	d336      	bcc.n	341816c4 <evision_api_st_ae_process+0x22e>
34181656:	2a00      	cmp	r2, #0
34181658:	da45      	bge.n	341816e6 <evision_api_st_ae_process+0x250>
3418165a:	fb01 0000 	mla	r0, r1, r0, r0
3418165e:	ee07 0a90 	vmov	s15, r0
34181662:	eeb8 6be7 	vcvt.f64.s32	d6, s15
34181666:	ee07 1a90 	vmov	s15, r1
3418166a:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
3418166e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34181672:	eea6 7b05 	vfma.f64	d7, d6, d5
34181676:	eebd 7bc7 	vcvt.s32.f64	s14, d7
3418167a:	ee17 2a10 	vmov	r2, s14
3418167e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34181680:	f8c4 b008 	str.w	fp, [r4, #8]
34181684:	429a      	cmp	r2, r3
34181686:	bfb8      	it	lt
34181688:	461a      	movlt	r2, r3
3418168a:	42aa      	cmp	r2, r5
3418168c:	bfd4      	ite	le
3418168e:	6062      	strle	r2, [r4, #4]
34181690:	6065      	strgt	r5, [r4, #4]
34181692:	4620      	mov	r0, r4
34181694:	f8cd a000 	str.w	sl, [sp]
34181698:	ab04      	add	r3, sp, #16
3418169a:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3418169e:	f7ff fdef 	bl	34181280 <GTePMGhCOh>
341816a2:	9b04      	ldr	r3, [sp, #16]
341816a4:	9d05      	ldr	r5, [sp, #20]
341816a6:	60a3      	str	r3, [r4, #8]
341816a8:	4b23      	ldr	r3, [pc, #140]	@ (34181738 <evision_api_st_ae_process+0x2a2>)
341816aa:	6065      	str	r5, [r4, #4]
341816ac:	f8c3 9060 	str.w	r9, [r3, #96]	@ 0x60
341816b0:	e717      	b.n	341814e2 <evision_api_st_ae_process+0x4c>
341816b2:	ebac 0c0e 	sub.w	ip, ip, lr
341816b6:	45c4      	cmp	ip, r8
341816b8:	dd20      	ble.n	341816fc <evision_api_st_ae_process+0x266>
341816ba:	9b03      	ldr	r3, [sp, #12]
341816bc:	429a      	cmp	r2, r3
341816be:	bfa8      	it	ge
341816c0:	461a      	movge	r2, r3
341816c2:	e7c1      	b.n	34181648 <evision_api_st_ae_process+0x1b2>
341816c4:	2a00      	cmp	r2, #0
341816c6:	dbc8      	blt.n	3418165a <evision_api_st_ae_process+0x1c4>
341816c8:	fb01 0000 	mla	r0, r1, r0, r0
341816cc:	ee07 0a90 	vmov	s15, r0
341816d0:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341816d4:	ee07 1a90 	vmov	s15, r1
341816d8:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
341816dc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
341816e0:	eea5 7b06 	vfma.f64	d7, d5, d6
341816e4:	e7c7      	b.n	34181676 <evision_api_st_ae_process+0x1e0>
341816e6:	4493      	add	fp, r2
341816e8:	455e      	cmp	r6, fp
341816ea:	dc04      	bgt.n	341816f6 <evision_api_st_ae_process+0x260>
341816ec:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
341816ee:	465e      	mov	r6, fp
341816f0:	459b      	cmp	fp, r3
341816f2:	bfa8      	it	ge
341816f4:	461e      	movge	r6, r3
341816f6:	e9c4 1601 	strd	r1, r6, [r4, #4]
341816fa:	e7ca      	b.n	34181692 <evision_api_st_ae_process+0x1fc>
341816fc:	4b0e      	ldr	r3, [pc, #56]	@ (34181738 <evision_api_st_ae_process+0x2a2>)
341816fe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34181700:	4599      	cmp	r9, r3
34181702:	d00b      	beq.n	3418171c <evision_api_st_ae_process+0x286>
34181704:	462a      	mov	r2, r5
34181706:	4639      	mov	r1, r7
34181708:	4620      	mov	r0, r4
3418170a:	f8cd a000 	str.w	sl, [sp]
3418170e:	ab04      	add	r3, sp, #16
34181710:	f1b9 0f00 	cmp.w	r9, #0
34181714:	d1c3      	bne.n	3418169e <evision_api_st_ae_process+0x208>
34181716:	f7ff fe07 	bl	34181328 <jHlPSTIzmc>
3418171a:	e7c2      	b.n	341816a2 <evision_api_st_ae_process+0x20c>
3418171c:	60a7      	str	r7, [r4, #8]
3418171e:	e7c3      	b.n	341816a8 <evision_api_st_ae_process+0x212>
34181720:	f04f 30ff 	mov.w	r0, #4294967295
34181724:	e6de      	b.n	341814e4 <evision_api_st_ae_process+0x4e>
34181726:	bf00      	nop
34181728:	00000000 	.word	0x00000000
3418172c:	408f4000 	.word	0x408f4000
34181730:	000f4240 	.word	0x000f4240
34181734:	3f59999a 	.word	0x3f59999a
34181738:	341c0480 	.word	0x341c0480

3418173c <__aeabi_ldivmod>:
3418173c:	b97b      	cbnz	r3, 3418175e <__aeabi_ldivmod+0x22>
3418173e:	b972      	cbnz	r2, 3418175e <__aeabi_ldivmod+0x22>
34181740:	2900      	cmp	r1, #0
34181742:	bfbe      	ittt	lt
34181744:	2000      	movlt	r0, #0
34181746:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3418174a:	e006      	blt.n	3418175a <__aeabi_ldivmod+0x1e>
3418174c:	bf08      	it	eq
3418174e:	2800      	cmpeq	r0, #0
34181750:	bf1c      	itt	ne
34181752:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34181756:	f04f 30ff 	movne.w	r0, #4294967295
3418175a:	f000 b9fb 	b.w	34181b54 <__aeabi_idiv0>
3418175e:	f1ad 0c08 	sub.w	ip, sp, #8
34181762:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34181766:	2900      	cmp	r1, #0
34181768:	db09      	blt.n	3418177e <__aeabi_ldivmod+0x42>
3418176a:	2b00      	cmp	r3, #0
3418176c:	db1a      	blt.n	341817a4 <__aeabi_ldivmod+0x68>
3418176e:	f000 f84d 	bl	3418180c <__udivmoddi4>
34181772:	f8dd e004 	ldr.w	lr, [sp, #4]
34181776:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3418177a:	b004      	add	sp, #16
3418177c:	4770      	bx	lr
3418177e:	4240      	negs	r0, r0
34181780:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34181784:	2b00      	cmp	r3, #0
34181786:	db1b      	blt.n	341817c0 <__aeabi_ldivmod+0x84>
34181788:	f000 f840 	bl	3418180c <__udivmoddi4>
3418178c:	f8dd e004 	ldr.w	lr, [sp, #4]
34181790:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34181794:	b004      	add	sp, #16
34181796:	4240      	negs	r0, r0
34181798:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
3418179c:	4252      	negs	r2, r2
3418179e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817a2:	4770      	bx	lr
341817a4:	4252      	negs	r2, r2
341817a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817aa:	f000 f82f 	bl	3418180c <__udivmoddi4>
341817ae:	f8dd e004 	ldr.w	lr, [sp, #4]
341817b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
341817b6:	b004      	add	sp, #16
341817b8:	4240      	negs	r0, r0
341817ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
341817be:	4770      	bx	lr
341817c0:	4252      	negs	r2, r2
341817c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817c6:	f000 f821 	bl	3418180c <__udivmoddi4>
341817ca:	f8dd e004 	ldr.w	lr, [sp, #4]
341817ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
341817d2:	b004      	add	sp, #16
341817d4:	4252      	negs	r2, r2
341817d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817da:	4770      	bx	lr

341817dc <__aeabi_uldivmod>:
341817dc:	b953      	cbnz	r3, 341817f4 <__aeabi_uldivmod+0x18>
341817de:	b94a      	cbnz	r2, 341817f4 <__aeabi_uldivmod+0x18>
341817e0:	2900      	cmp	r1, #0
341817e2:	bf08      	it	eq
341817e4:	2800      	cmpeq	r0, #0
341817e6:	bf1c      	itt	ne
341817e8:	f04f 31ff 	movne.w	r1, #4294967295
341817ec:	f04f 30ff 	movne.w	r0, #4294967295
341817f0:	f000 b9b0 	b.w	34181b54 <__aeabi_idiv0>
341817f4:	f1ad 0c08 	sub.w	ip, sp, #8
341817f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
341817fc:	f000 f806 	bl	3418180c <__udivmoddi4>
34181800:	f8dd e004 	ldr.w	lr, [sp, #4]
34181804:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34181808:	b004      	add	sp, #16
3418180a:	4770      	bx	lr

3418180c <__udivmoddi4>:
3418180c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34181810:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34181812:	4688      	mov	r8, r1
34181814:	4604      	mov	r4, r0
34181816:	468e      	mov	lr, r1
34181818:	2b00      	cmp	r3, #0
3418181a:	d14a      	bne.n	341818b2 <__udivmoddi4+0xa6>
3418181c:	428a      	cmp	r2, r1
3418181e:	4617      	mov	r7, r2
34181820:	d95f      	bls.n	341818e2 <__udivmoddi4+0xd6>
34181822:	fab2 f682 	clz	r6, r2
34181826:	b14e      	cbz	r6, 3418183c <__udivmoddi4+0x30>
34181828:	f1c6 0320 	rsb	r3, r6, #32
3418182c:	fa01 fe06 	lsl.w	lr, r1, r6
34181830:	40b7      	lsls	r7, r6
34181832:	40b4      	lsls	r4, r6
34181834:	fa20 f303 	lsr.w	r3, r0, r3
34181838:	ea43 0e0e 	orr.w	lr, r3, lr
3418183c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34181840:	fa1f fc87 	uxth.w	ip, r7
34181844:	0c23      	lsrs	r3, r4, #16
34181846:	fbbe f1f8 	udiv	r1, lr, r8
3418184a:	fb08 ee11 	mls	lr, r8, r1, lr
3418184e:	fb01 f20c 	mul.w	r2, r1, ip
34181852:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34181856:	429a      	cmp	r2, r3
34181858:	d907      	bls.n	3418186a <__udivmoddi4+0x5e>
3418185a:	18fb      	adds	r3, r7, r3
3418185c:	f101 30ff 	add.w	r0, r1, #4294967295
34181860:	d202      	bcs.n	34181868 <__udivmoddi4+0x5c>
34181862:	429a      	cmp	r2, r3
34181864:	f200 8154 	bhi.w	34181b10 <__udivmoddi4+0x304>
34181868:	4601      	mov	r1, r0
3418186a:	1a9b      	subs	r3, r3, r2
3418186c:	b2a2      	uxth	r2, r4
3418186e:	fbb3 f0f8 	udiv	r0, r3, r8
34181872:	fb08 3310 	mls	r3, r8, r0, r3
34181876:	fb00 fc0c 	mul.w	ip, r0, ip
3418187a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3418187e:	4594      	cmp	ip, r2
34181880:	d90b      	bls.n	3418189a <__udivmoddi4+0x8e>
34181882:	18ba      	adds	r2, r7, r2
34181884:	f100 33ff 	add.w	r3, r0, #4294967295
34181888:	bf2c      	ite	cs
3418188a:	2401      	movcs	r4, #1
3418188c:	2400      	movcc	r4, #0
3418188e:	4594      	cmp	ip, r2
34181890:	d902      	bls.n	34181898 <__udivmoddi4+0x8c>
34181892:	2c00      	cmp	r4, #0
34181894:	f000 813f 	beq.w	34181b16 <__udivmoddi4+0x30a>
34181898:	4618      	mov	r0, r3
3418189a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3418189e:	eba2 020c 	sub.w	r2, r2, ip
341818a2:	2100      	movs	r1, #0
341818a4:	b11d      	cbz	r5, 341818ae <__udivmoddi4+0xa2>
341818a6:	40f2      	lsrs	r2, r6
341818a8:	2300      	movs	r3, #0
341818aa:	e9c5 2300 	strd	r2, r3, [r5]
341818ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341818b2:	428b      	cmp	r3, r1
341818b4:	d905      	bls.n	341818c2 <__udivmoddi4+0xb6>
341818b6:	b10d      	cbz	r5, 341818bc <__udivmoddi4+0xb0>
341818b8:	e9c5 0100 	strd	r0, r1, [r5]
341818bc:	2100      	movs	r1, #0
341818be:	4608      	mov	r0, r1
341818c0:	e7f5      	b.n	341818ae <__udivmoddi4+0xa2>
341818c2:	fab3 f183 	clz	r1, r3
341818c6:	2900      	cmp	r1, #0
341818c8:	d14e      	bne.n	34181968 <__udivmoddi4+0x15c>
341818ca:	4543      	cmp	r3, r8
341818cc:	f0c0 8112 	bcc.w	34181af4 <__udivmoddi4+0x2e8>
341818d0:	4282      	cmp	r2, r0
341818d2:	f240 810f 	bls.w	34181af4 <__udivmoddi4+0x2e8>
341818d6:	4608      	mov	r0, r1
341818d8:	2d00      	cmp	r5, #0
341818da:	d0e8      	beq.n	341818ae <__udivmoddi4+0xa2>
341818dc:	e9c5 4e00 	strd	r4, lr, [r5]
341818e0:	e7e5      	b.n	341818ae <__udivmoddi4+0xa2>
341818e2:	2a00      	cmp	r2, #0
341818e4:	f000 80ac 	beq.w	34181a40 <__udivmoddi4+0x234>
341818e8:	fab2 f682 	clz	r6, r2
341818ec:	2e00      	cmp	r6, #0
341818ee:	f040 80bb 	bne.w	34181a68 <__udivmoddi4+0x25c>
341818f2:	1a8b      	subs	r3, r1, r2
341818f4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
341818f8:	b2bc      	uxth	r4, r7
341818fa:	2101      	movs	r1, #1
341818fc:	0c02      	lsrs	r2, r0, #16
341818fe:	b280      	uxth	r0, r0
34181900:	fbb3 fcfe 	udiv	ip, r3, lr
34181904:	fb0e 331c 	mls	r3, lr, ip, r3
34181908:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3418190c:	fb04 f20c 	mul.w	r2, r4, ip
34181910:	429a      	cmp	r2, r3
34181912:	d90e      	bls.n	34181932 <__udivmoddi4+0x126>
34181914:	18fb      	adds	r3, r7, r3
34181916:	f10c 38ff 	add.w	r8, ip, #4294967295
3418191a:	bf2c      	ite	cs
3418191c:	f04f 0901 	movcs.w	r9, #1
34181920:	f04f 0900 	movcc.w	r9, #0
34181924:	429a      	cmp	r2, r3
34181926:	d903      	bls.n	34181930 <__udivmoddi4+0x124>
34181928:	f1b9 0f00 	cmp.w	r9, #0
3418192c:	f000 80ec 	beq.w	34181b08 <__udivmoddi4+0x2fc>
34181930:	46c4      	mov	ip, r8
34181932:	1a9b      	subs	r3, r3, r2
34181934:	fbb3 f8fe 	udiv	r8, r3, lr
34181938:	fb0e 3318 	mls	r3, lr, r8, r3
3418193c:	fb04 f408 	mul.w	r4, r4, r8
34181940:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34181944:	4294      	cmp	r4, r2
34181946:	d90b      	bls.n	34181960 <__udivmoddi4+0x154>
34181948:	18ba      	adds	r2, r7, r2
3418194a:	f108 33ff 	add.w	r3, r8, #4294967295
3418194e:	bf2c      	ite	cs
34181950:	2001      	movcs	r0, #1
34181952:	2000      	movcc	r0, #0
34181954:	4294      	cmp	r4, r2
34181956:	d902      	bls.n	3418195e <__udivmoddi4+0x152>
34181958:	2800      	cmp	r0, #0
3418195a:	f000 80d1 	beq.w	34181b00 <__udivmoddi4+0x2f4>
3418195e:	4698      	mov	r8, r3
34181960:	1b12      	subs	r2, r2, r4
34181962:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34181966:	e79d      	b.n	341818a4 <__udivmoddi4+0x98>
34181968:	f1c1 0620 	rsb	r6, r1, #32
3418196c:	408b      	lsls	r3, r1
3418196e:	fa08 f401 	lsl.w	r4, r8, r1
34181972:	fa00 f901 	lsl.w	r9, r0, r1
34181976:	fa22 f706 	lsr.w	r7, r2, r6
3418197a:	fa28 f806 	lsr.w	r8, r8, r6
3418197e:	408a      	lsls	r2, r1
34181980:	431f      	orrs	r7, r3
34181982:	fa20 f306 	lsr.w	r3, r0, r6
34181986:	0c38      	lsrs	r0, r7, #16
34181988:	4323      	orrs	r3, r4
3418198a:	fa1f fc87 	uxth.w	ip, r7
3418198e:	0c1c      	lsrs	r4, r3, #16
34181990:	fbb8 fef0 	udiv	lr, r8, r0
34181994:	fb00 881e 	mls	r8, r0, lr, r8
34181998:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3418199c:	fb0e f80c 	mul.w	r8, lr, ip
341819a0:	45a0      	cmp	r8, r4
341819a2:	d90e      	bls.n	341819c2 <__udivmoddi4+0x1b6>
341819a4:	193c      	adds	r4, r7, r4
341819a6:	f10e 3aff 	add.w	sl, lr, #4294967295
341819aa:	bf2c      	ite	cs
341819ac:	f04f 0b01 	movcs.w	fp, #1
341819b0:	f04f 0b00 	movcc.w	fp, #0
341819b4:	45a0      	cmp	r8, r4
341819b6:	d903      	bls.n	341819c0 <__udivmoddi4+0x1b4>
341819b8:	f1bb 0f00 	cmp.w	fp, #0
341819bc:	f000 80b8 	beq.w	34181b30 <__udivmoddi4+0x324>
341819c0:	46d6      	mov	lr, sl
341819c2:	eba4 0408 	sub.w	r4, r4, r8
341819c6:	fa1f f883 	uxth.w	r8, r3
341819ca:	fbb4 f3f0 	udiv	r3, r4, r0
341819ce:	fb00 4413 	mls	r4, r0, r3, r4
341819d2:	fb03 fc0c 	mul.w	ip, r3, ip
341819d6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
341819da:	45a4      	cmp	ip, r4
341819dc:	d90e      	bls.n	341819fc <__udivmoddi4+0x1f0>
341819de:	193c      	adds	r4, r7, r4
341819e0:	f103 30ff 	add.w	r0, r3, #4294967295
341819e4:	bf2c      	ite	cs
341819e6:	f04f 0801 	movcs.w	r8, #1
341819ea:	f04f 0800 	movcc.w	r8, #0
341819ee:	45a4      	cmp	ip, r4
341819f0:	d903      	bls.n	341819fa <__udivmoddi4+0x1ee>
341819f2:	f1b8 0f00 	cmp.w	r8, #0
341819f6:	f000 809f 	beq.w	34181b38 <__udivmoddi4+0x32c>
341819fa:	4603      	mov	r3, r0
341819fc:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34181a00:	eba4 040c 	sub.w	r4, r4, ip
34181a04:	fba0 ec02 	umull	lr, ip, r0, r2
34181a08:	4564      	cmp	r4, ip
34181a0a:	4673      	mov	r3, lr
34181a0c:	46e0      	mov	r8, ip
34181a0e:	d302      	bcc.n	34181a16 <__udivmoddi4+0x20a>
34181a10:	d107      	bne.n	34181a22 <__udivmoddi4+0x216>
34181a12:	45f1      	cmp	r9, lr
34181a14:	d205      	bcs.n	34181a22 <__udivmoddi4+0x216>
34181a16:	ebbe 0302 	subs.w	r3, lr, r2
34181a1a:	eb6c 0c07 	sbc.w	ip, ip, r7
34181a1e:	3801      	subs	r0, #1
34181a20:	46e0      	mov	r8, ip
34181a22:	b15d      	cbz	r5, 34181a3c <__udivmoddi4+0x230>
34181a24:	ebb9 0203 	subs.w	r2, r9, r3
34181a28:	eb64 0408 	sbc.w	r4, r4, r8
34181a2c:	fa04 f606 	lsl.w	r6, r4, r6
34181a30:	fa22 f301 	lsr.w	r3, r2, r1
34181a34:	40cc      	lsrs	r4, r1
34181a36:	431e      	orrs	r6, r3
34181a38:	e9c5 6400 	strd	r6, r4, [r5]
34181a3c:	2100      	movs	r1, #0
34181a3e:	e736      	b.n	341818ae <__udivmoddi4+0xa2>
34181a40:	fbb1 fcf2 	udiv	ip, r1, r2
34181a44:	0c01      	lsrs	r1, r0, #16
34181a46:	4614      	mov	r4, r2
34181a48:	b280      	uxth	r0, r0
34181a4a:	4696      	mov	lr, r2
34181a4c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34181a50:	2620      	movs	r6, #32
34181a52:	4690      	mov	r8, r2
34181a54:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34181a58:	4610      	mov	r0, r2
34181a5a:	fbb1 f1f2 	udiv	r1, r1, r2
34181a5e:	eba3 0308 	sub.w	r3, r3, r8
34181a62:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34181a66:	e74b      	b.n	34181900 <__udivmoddi4+0xf4>
34181a68:	40b7      	lsls	r7, r6
34181a6a:	f1c6 0320 	rsb	r3, r6, #32
34181a6e:	fa01 f206 	lsl.w	r2, r1, r6
34181a72:	fa21 f803 	lsr.w	r8, r1, r3
34181a76:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34181a7a:	fa20 f303 	lsr.w	r3, r0, r3
34181a7e:	b2bc      	uxth	r4, r7
34181a80:	40b0      	lsls	r0, r6
34181a82:	4313      	orrs	r3, r2
34181a84:	0c02      	lsrs	r2, r0, #16
34181a86:	0c19      	lsrs	r1, r3, #16
34181a88:	b280      	uxth	r0, r0
34181a8a:	fbb8 f9fe 	udiv	r9, r8, lr
34181a8e:	fb0e 8819 	mls	r8, lr, r9, r8
34181a92:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34181a96:	fb09 f804 	mul.w	r8, r9, r4
34181a9a:	4588      	cmp	r8, r1
34181a9c:	d951      	bls.n	34181b42 <__udivmoddi4+0x336>
34181a9e:	1879      	adds	r1, r7, r1
34181aa0:	f109 3cff 	add.w	ip, r9, #4294967295
34181aa4:	bf2c      	ite	cs
34181aa6:	f04f 0a01 	movcs.w	sl, #1
34181aaa:	f04f 0a00 	movcc.w	sl, #0
34181aae:	4588      	cmp	r8, r1
34181ab0:	d902      	bls.n	34181ab8 <__udivmoddi4+0x2ac>
34181ab2:	f1ba 0f00 	cmp.w	sl, #0
34181ab6:	d031      	beq.n	34181b1c <__udivmoddi4+0x310>
34181ab8:	eba1 0108 	sub.w	r1, r1, r8
34181abc:	fbb1 f9fe 	udiv	r9, r1, lr
34181ac0:	fb09 f804 	mul.w	r8, r9, r4
34181ac4:	fb0e 1119 	mls	r1, lr, r9, r1
34181ac8:	b29b      	uxth	r3, r3
34181aca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34181ace:	4543      	cmp	r3, r8
34181ad0:	d235      	bcs.n	34181b3e <__udivmoddi4+0x332>
34181ad2:	18fb      	adds	r3, r7, r3
34181ad4:	f109 31ff 	add.w	r1, r9, #4294967295
34181ad8:	bf2c      	ite	cs
34181ada:	f04f 0a01 	movcs.w	sl, #1
34181ade:	f04f 0a00 	movcc.w	sl, #0
34181ae2:	4543      	cmp	r3, r8
34181ae4:	d2bb      	bcs.n	34181a5e <__udivmoddi4+0x252>
34181ae6:	f1ba 0f00 	cmp.w	sl, #0
34181aea:	d1b8      	bne.n	34181a5e <__udivmoddi4+0x252>
34181aec:	f1a9 0102 	sub.w	r1, r9, #2
34181af0:	443b      	add	r3, r7
34181af2:	e7b4      	b.n	34181a5e <__udivmoddi4+0x252>
34181af4:	1a84      	subs	r4, r0, r2
34181af6:	eb68 0203 	sbc.w	r2, r8, r3
34181afa:	2001      	movs	r0, #1
34181afc:	4696      	mov	lr, r2
34181afe:	e6eb      	b.n	341818d8 <__udivmoddi4+0xcc>
34181b00:	443a      	add	r2, r7
34181b02:	f1a8 0802 	sub.w	r8, r8, #2
34181b06:	e72b      	b.n	34181960 <__udivmoddi4+0x154>
34181b08:	f1ac 0c02 	sub.w	ip, ip, #2
34181b0c:	443b      	add	r3, r7
34181b0e:	e710      	b.n	34181932 <__udivmoddi4+0x126>
34181b10:	3902      	subs	r1, #2
34181b12:	443b      	add	r3, r7
34181b14:	e6a9      	b.n	3418186a <__udivmoddi4+0x5e>
34181b16:	443a      	add	r2, r7
34181b18:	3802      	subs	r0, #2
34181b1a:	e6be      	b.n	3418189a <__udivmoddi4+0x8e>
34181b1c:	eba7 0808 	sub.w	r8, r7, r8
34181b20:	f1a9 0c02 	sub.w	ip, r9, #2
34181b24:	4441      	add	r1, r8
34181b26:	fbb1 f9fe 	udiv	r9, r1, lr
34181b2a:	fb09 f804 	mul.w	r8, r9, r4
34181b2e:	e7c9      	b.n	34181ac4 <__udivmoddi4+0x2b8>
34181b30:	f1ae 0e02 	sub.w	lr, lr, #2
34181b34:	443c      	add	r4, r7
34181b36:	e744      	b.n	341819c2 <__udivmoddi4+0x1b6>
34181b38:	3b02      	subs	r3, #2
34181b3a:	443c      	add	r4, r7
34181b3c:	e75e      	b.n	341819fc <__udivmoddi4+0x1f0>
34181b3e:	4649      	mov	r1, r9
34181b40:	e78d      	b.n	34181a5e <__udivmoddi4+0x252>
34181b42:	eba1 0108 	sub.w	r1, r1, r8
34181b46:	46cc      	mov	ip, r9
34181b48:	fbb1 f9fe 	udiv	r9, r1, lr
34181b4c:	fb09 f804 	mul.w	r8, r9, r4
34181b50:	e7b8      	b.n	34181ac4 <__udivmoddi4+0x2b8>
34181b52:	bf00      	nop

34181b54 <__aeabi_idiv0>:
34181b54:	4770      	bx	lr
34181b56:	bf00      	nop

34181b58 <DCMIPP_PipeInitDisplay>:
#define CAMERA_FPS 30

extern int32_t cameraFrameReceived;

static void DCMIPP_PipeInitDisplay(CMW_CameraInit_t *camConf, uint32_t *bg_width, uint32_t *bg_height)
{
34181b58:	b580      	push	{r7, lr}
34181b5a:	b094      	sub	sp, #80	@ 0x50
34181b5c:	af00      	add	r7, sp, #0
34181b5e:	60f8      	str	r0, [r7, #12]
34181b60:	60b9      	str	r1, [r7, #8]
34181b62:	607a      	str	r2, [r7, #4]
  CMW_Aspect_Ratio_Mode_t aspect_ratio;
  CMW_DCMIPP_Conf_t dcmipp_conf = {0};
34181b64:	f107 0314 	add.w	r3, r7, #20
34181b68:	222c      	movs	r2, #44	@ 0x2c
34181b6a:	2100      	movs	r1, #0
34181b6c:	4618      	mov	r0, r3
34181b6e:	f022 f919 	bl	341a3da4 <memset>
  int ret;

  if (ASPECT_RATIO_MODE == ASPECT_RATIO_CROP)
  {
    aspect_ratio = CMW_Aspect_ratio_crop;
34181b72:	2300      	movs	r3, #0
34181b74:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  }

  int lcd_bg_width;
  int lcd_bg_height;

  lcd_bg_height = (camConf->height <= SCREEN_HEIGHT) ? camConf->height : SCREEN_HEIGHT;
34181b78:	68fb      	ldr	r3, [r7, #12]
34181b7a:	685b      	ldr	r3, [r3, #4]
34181b7c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34181b80:	bf28      	it	cs
34181b82:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
34181b86:	64bb      	str	r3, [r7, #72]	@ 0x48

#if ASPECT_RATIO_MODE == ASPECT_RATIO_FULLSCREEN
  lcd_bg_width = (((camConf->width*lcd_bg_height)/camConf->height) - ((camConf->width*lcd_bg_height)/camConf->height) % 16);
#else
  lcd_bg_width = (camConf->height <= SCREEN_HEIGHT) ? camConf->height : SCREEN_HEIGHT;
34181b88:	68fb      	ldr	r3, [r7, #12]
34181b8a:	685b      	ldr	r3, [r3, #4]
34181b8c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34181b90:	bf28      	it	cs
34181b92:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
34181b96:	647b      	str	r3, [r7, #68]	@ 0x44
#endif

  *bg_width = lcd_bg_width;
34181b98:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34181b9a:	68bb      	ldr	r3, [r7, #8]
34181b9c:	601a      	str	r2, [r3, #0]
  *bg_height = lcd_bg_height;
34181b9e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34181ba0:	687b      	ldr	r3, [r7, #4]
34181ba2:	601a      	str	r2, [r3, #0]

  dcmipp_conf.output_width = lcd_bg_width;
34181ba4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34181ba6:	617b      	str	r3, [r7, #20]
  dcmipp_conf.output_height = lcd_bg_height;
34181ba8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34181baa:	61bb      	str	r3, [r7, #24]
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34181bac:	2301      	movs	r3, #1
34181bae:	61fb      	str	r3, [r7, #28]
  dcmipp_conf.output_bpp = 2;
34181bb0:	2302      	movs	r3, #2
34181bb2:	623b      	str	r3, [r7, #32]
  dcmipp_conf.mode = aspect_ratio;
34181bb4:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34181bb8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34181bba:	2300      	movs	r3, #0
34181bbc:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t pitch;
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
34181bbe:	f107 0210 	add.w	r2, r7, #16
34181bc2:	f107 0314 	add.w	r3, r7, #20
34181bc6:	4619      	mov	r1, r3
34181bc8:	2001      	movs	r0, #1
34181bca:	f018 fadb 	bl	3419a184 <CMW_CAMERA_SetPipeConfig>
34181bce:	6438      	str	r0, [r7, #64]	@ 0x40
  assert(ret == HAL_OK);
34181bd0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34181bd2:	2b00      	cmp	r3, #0
34181bd4:	d005      	beq.n	34181be2 <DCMIPP_PipeInitDisplay+0x8a>
34181bd6:	4b0b      	ldr	r3, [pc, #44]	@ (34181c04 <DCMIPP_PipeInitDisplay+0xac>)
34181bd8:	4a0b      	ldr	r2, [pc, #44]	@ (34181c08 <DCMIPP_PipeInitDisplay+0xb0>)
34181bda:	2151      	movs	r1, #81	@ 0x51
34181bdc:	480b      	ldr	r0, [pc, #44]	@ (34181c0c <DCMIPP_PipeInitDisplay+0xb4>)
34181bde:	f021 fe57 	bl	341a3890 <__assert_func>
  assert(dcmipp_conf.output_width * dcmipp_conf.output_bpp == pitch);
34181be2:	697b      	ldr	r3, [r7, #20]
34181be4:	6a3a      	ldr	r2, [r7, #32]
34181be6:	fb03 f202 	mul.w	r2, r3, r2
34181bea:	693b      	ldr	r3, [r7, #16]
34181bec:	429a      	cmp	r2, r3
34181bee:	d005      	beq.n	34181bfc <DCMIPP_PipeInitDisplay+0xa4>
34181bf0:	4b07      	ldr	r3, [pc, #28]	@ (34181c10 <DCMIPP_PipeInitDisplay+0xb8>)
34181bf2:	4a05      	ldr	r2, [pc, #20]	@ (34181c08 <DCMIPP_PipeInitDisplay+0xb0>)
34181bf4:	2152      	movs	r1, #82	@ 0x52
34181bf6:	4805      	ldr	r0, [pc, #20]	@ (34181c0c <DCMIPP_PipeInitDisplay+0xb4>)
34181bf8:	f021 fe4a 	bl	341a3890 <__assert_func>
}
34181bfc:	bf00      	nop
34181bfe:	3750      	adds	r7, #80	@ 0x50
34181c00:	46bd      	mov	sp, r7
34181c02:	bd80      	pop	{r7, pc}
34181c04:	341a59c0 	.word	0x341a59c0
34181c08:	341a670c 	.word	0x341a670c
34181c0c:	341a59d0 	.word	0x341a59d0
34181c10:	341a5a00 	.word	0x341a5a00

34181c14 <DCMIPP_PipeInitNn>:

static void DCMIPP_PipeInitNn(uint32_t *pitch)
{
34181c14:	b580      	push	{r7, lr}
34181c16:	b090      	sub	sp, #64	@ 0x40
34181c18:	af00      	add	r7, sp, #0
34181c1a:	6078      	str	r0, [r7, #4]
  CMW_DCMIPP_Conf_t dcmipp_conf;
  int ret;

  if (ASPECT_RATIO_MODE == ASPECT_RATIO_CROP)
  {
    aspect_ratio = CMW_Aspect_ratio_crop;
34181c1c:	2300      	movs	r3, #0
34181c1e:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  else if (ASPECT_RATIO_MODE == ASPECT_RATIO_FULLSCREEN)
  {
    aspect_ratio = CMW_Aspect_ratio_fit;
  }

  dcmipp_conf.output_width = NN_WIDTH;
34181c22:	23f0      	movs	r3, #240	@ 0xf0
34181c24:	60fb      	str	r3, [r7, #12]
  dcmipp_conf.output_height = NN_HEIGHT;
34181c26:	23f0      	movs	r3, #240	@ 0xf0
34181c28:	613b      	str	r3, [r7, #16]
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34181c2a:	2300      	movs	r3, #0
34181c2c:	617b      	str	r3, [r7, #20]
  dcmipp_conf.output_bpp = NN_BPP;
34181c2e:	2303      	movs	r3, #3
34181c30:	61bb      	str	r3, [r7, #24]
  dcmipp_conf.mode = aspect_ratio;
34181c32:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
34181c36:	627b      	str	r3, [r7, #36]	@ 0x24
  dcmipp_conf.enable_swap = COLOR_MODE;
34181c38:	2301      	movs	r3, #1
34181c3a:	61fb      	str	r3, [r7, #28]
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34181c3c:	2300      	movs	r3, #0
34181c3e:	623b      	str	r3, [r7, #32]
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &dcmipp_conf, pitch);
34181c40:	f107 030c 	add.w	r3, r7, #12
34181c44:	687a      	ldr	r2, [r7, #4]
34181c46:	4619      	mov	r1, r3
34181c48:	2002      	movs	r0, #2
34181c4a:	f018 fa9b 	bl	3419a184 <CMW_CAMERA_SetPipeConfig>
34181c4e:	63b8      	str	r0, [r7, #56]	@ 0x38
  assert(ret == HAL_OK);
34181c50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34181c52:	2b00      	cmp	r3, #0
34181c54:	d005      	beq.n	34181c62 <DCMIPP_PipeInitNn+0x4e>
34181c56:	4b05      	ldr	r3, [pc, #20]	@ (34181c6c <DCMIPP_PipeInitNn+0x58>)
34181c58:	4a05      	ldr	r2, [pc, #20]	@ (34181c70 <DCMIPP_PipeInitNn+0x5c>)
34181c5a:	2170      	movs	r1, #112	@ 0x70
34181c5c:	4805      	ldr	r0, [pc, #20]	@ (34181c74 <DCMIPP_PipeInitNn+0x60>)
34181c5e:	f021 fe17 	bl	341a3890 <__assert_func>
}
34181c62:	bf00      	nop
34181c64:	3740      	adds	r7, #64	@ 0x40
34181c66:	46bd      	mov	sp, r7
34181c68:	bd80      	pop	{r7, pc}
34181c6a:	bf00      	nop
34181c6c:	341a59c0 	.word	0x341a59c0
34181c70:	341a6724 	.word	0x341a6724
34181c74:	341a59d0 	.word	0x341a59d0

34181c78 <CameraPipeline_Init>:
* @param lcd_bg_width display width
* @param lcd_bg_height display height
* @param pitch_nn output pitch computed by the CMW
*/
void CameraPipeline_Init(uint32_t *lcd_bg_width, uint32_t *lcd_bg_height, uint32_t *pitch_nn)
{
34181c78:	b580      	push	{r7, lr}
34181c7a:	b08c      	sub	sp, #48	@ 0x30
34181c7c:	af00      	add	r7, sp, #0
34181c7e:	60f8      	str	r0, [r7, #12]
34181c80:	60b9      	str	r1, [r7, #8]
34181c82:	607a      	str	r2, [r7, #4]
  int ret;
  CMW_CameraInit_t cam_conf;

  cam_conf.width = CAMERA_WIDTH;
34181c84:	2300      	movs	r3, #0
34181c86:	617b      	str	r3, [r7, #20]
  cam_conf.height = CAMERA_HEIGHT;
34181c88:	2300      	movs	r3, #0
34181c8a:	61bb      	str	r3, [r7, #24]
  cam_conf.fps = CAMERA_FPS;
34181c8c:	231e      	movs	r3, #30
34181c8e:	61fb      	str	r3, [r7, #28]
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
34181c90:	2300      	movs	r3, #0
34181c92:	623b      	str	r3, [r7, #32]
  cam_conf.anti_flicker = 0;
34181c94:	2300      	movs	r3, #0
34181c96:	627b      	str	r3, [r7, #36]	@ 0x24
  cam_conf.mirror_flip = CAMERA_FLIP;
34181c98:	2300      	movs	r3, #0
34181c9a:	62bb      	str	r3, [r7, #40]	@ 0x28

  ret = CMW_CAMERA_Init(&cam_conf, NULL);
34181c9c:	f107 0314 	add.w	r3, r7, #20
34181ca0:	2100      	movs	r1, #0
34181ca2:	4618      	mov	r0, r3
34181ca4:	f018 fab2 	bl	3419a20c <CMW_CAMERA_Init>
34181ca8:	62f8      	str	r0, [r7, #44]	@ 0x2c
  assert(ret == CMW_ERROR_NONE);
34181caa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34181cac:	2b00      	cmp	r3, #0
34181cae:	d005      	beq.n	34181cbc <CameraPipeline_Init+0x44>
34181cb0:	4b09      	ldr	r3, [pc, #36]	@ (34181cd8 <CameraPipeline_Init+0x60>)
34181cb2:	4a0a      	ldr	r2, [pc, #40]	@ (34181cdc <CameraPipeline_Init+0x64>)
34181cb4:	2186      	movs	r1, #134	@ 0x86
34181cb6:	480a      	ldr	r0, [pc, #40]	@ (34181ce0 <CameraPipeline_Init+0x68>)
34181cb8:	f021 fdea 	bl	341a3890 <__assert_func>
  DCMIPP_PipeInitDisplay(&cam_conf, lcd_bg_width, lcd_bg_height);
34181cbc:	f107 0314 	add.w	r3, r7, #20
34181cc0:	68ba      	ldr	r2, [r7, #8]
34181cc2:	68f9      	ldr	r1, [r7, #12]
34181cc4:	4618      	mov	r0, r3
34181cc6:	f7ff ff47 	bl	34181b58 <DCMIPP_PipeInitDisplay>
  DCMIPP_PipeInitNn(pitch_nn);
34181cca:	6878      	ldr	r0, [r7, #4]
34181ccc:	f7ff ffa2 	bl	34181c14 <DCMIPP_PipeInitNn>
}
34181cd0:	bf00      	nop
34181cd2:	3730      	adds	r7, #48	@ 0x30
34181cd4:	46bd      	mov	sp, r7
34181cd6:	bd80      	pop	{r7, pc}
34181cd8:	341a5a3c 	.word	0x341a5a3c
34181cdc:	341a6738 	.word	0x341a6738
34181ce0:	341a59d0 	.word	0x341a59d0

34181ce4 <MX_BSEC_Init>:

/* USER CODE END 0 */

/* BSEC init function */
void MX_BSEC_Init(void)
{
34181ce4:	b480      	push	{r7}
34181ce6:	af00      	add	r7, sp, #0
  /* USER CODE END BSEC_Init 1 */
  /* USER CODE BEGIN BSEC_Init 2 */

  /* USER CODE END BSEC_Init 2 */

}
34181ce8:	bf00      	nop
34181cea:	46bd      	mov	sp, r7
34181cec:	f85d 7b04 	ldr.w	r7, [sp], #4
34181cf0:	4770      	bx	lr
	...

34181cf4 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34181cf4:	b480      	push	{r7}
34181cf6:	b085      	sub	sp, #20
34181cf8:	af00      	add	r7, sp, #0
34181cfa:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34181cfc:	4a07      	ldr	r2, [pc, #28]	@ (34181d1c <LL_AHB5_GRP1_EnableClock+0x28>)
34181cfe:	687b      	ldr	r3, [r7, #4]
34181d00:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34181d04:	4b05      	ldr	r3, [pc, #20]	@ (34181d1c <LL_AHB5_GRP1_EnableClock+0x28>)
34181d06:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34181d0a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34181d0c:	68fb      	ldr	r3, [r7, #12]
}
34181d0e:	bf00      	nop
34181d10:	3714      	adds	r7, #20
34181d12:	46bd      	mov	sp, r7
34181d14:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d18:	4770      	bx	lr
34181d1a:	bf00      	nop
34181d1c:	56028000 	.word	0x56028000

34181d20 <MX_CACHEAXI_Init>:

CACHEAXI_HandleTypeDef hcacheaxi;

/* CACHEAXI init function */
void MX_CACHEAXI_Init(void)
{
34181d20:	b580      	push	{r7, lr}
34181d22:	af00      	add	r7, sp, #0
  /* USER CODE END CACHEAXI_Init 0 */

  /* USER CODE BEGIN CACHEAXI_Init 1 */

  /* USER CODE END CACHEAXI_Init 1 */
  hcacheaxi.Instance = CACHEAXI;
34181d24:	4b06      	ldr	r3, [pc, #24]	@ (34181d40 <MX_CACHEAXI_Init+0x20>)
34181d26:	4a07      	ldr	r2, [pc, #28]	@ (34181d44 <MX_CACHEAXI_Init+0x24>)
34181d28:	601a      	str	r2, [r3, #0]
  if (HAL_CACHEAXI_Init(&hcacheaxi) != HAL_OK)
34181d2a:	4805      	ldr	r0, [pc, #20]	@ (34181d40 <MX_CACHEAXI_Init+0x20>)
34181d2c:	f003 fb40 	bl	341853b0 <HAL_CACHEAXI_Init>
34181d30:	4603      	mov	r3, r0
34181d32:	2b00      	cmp	r3, #0
34181d34:	d001      	beq.n	34181d3a <MX_CACHEAXI_Init+0x1a>
  {
    Error_Handler();
34181d36:	f001 f831 	bl	34182d9c <Error_Handler>
  }
  /* USER CODE BEGIN CACHEAXI_Init 2 */

  /* USER CODE END CACHEAXI_Init 2 */

}
34181d3a:	bf00      	nop
34181d3c:	bd80      	pop	{r7, pc}
34181d3e:	bf00      	nop
34181d40:	341c04e4 	.word	0x341c04e4
34181d44:	580dfc00 	.word	0x580dfc00

34181d48 <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef* cacheaxiHandle)
{
34181d48:	b580      	push	{r7, lr}
34181d4a:	b082      	sub	sp, #8
34181d4c:	af00      	add	r7, sp, #0
34181d4e:	6078      	str	r0, [r7, #4]

  if(cacheaxiHandle->Instance==CACHEAXI)
34181d50:	687b      	ldr	r3, [r7, #4]
34181d52:	681b      	ldr	r3, [r3, #0]
34181d54:	4a05      	ldr	r2, [pc, #20]	@ (34181d6c <HAL_CACHEAXI_MspInit+0x24>)
34181d56:	4293      	cmp	r3, r2
34181d58:	d103      	bne.n	34181d62 <HAL_CACHEAXI_MspInit+0x1a>
  {
  /* USER CODE BEGIN CACHEAXI_MspInit 0 */

  /* USER CODE END CACHEAXI_MspInit 0 */
    /* CACHEAXI clock enable */
    __HAL_RCC_CACHEAXI_CLK_ENABLE();
34181d5a:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34181d5e:	f7ff ffc9 	bl	34181cf4 <LL_AHB5_GRP1_EnableClock>
  /* USER CODE BEGIN CACHEAXI_MspInit 1 */

  /* USER CODE END CACHEAXI_MspInit 1 */
  }
}
34181d62:	bf00      	nop
34181d64:	3708      	adds	r7, #8
34181d66:	46bd      	mov	sp, r7
34181d68:	bd80      	pop	{r7, pc}
34181d6a:	bf00      	nop
34181d6c:	580dfc00 	.word	0x580dfc00

34181d70 <LL_APB5_GRP1_EnableClock>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
34181d70:	b480      	push	{r7}
34181d72:	b085      	sub	sp, #20
34181d74:	af00      	add	r7, sp, #0
34181d76:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
34181d78:	4a07      	ldr	r2, [pc, #28]	@ (34181d98 <LL_APB5_GRP1_EnableClock+0x28>)
34181d7a:	687b      	ldr	r3, [r7, #4]
34181d7c:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
34181d80:	4b05      	ldr	r3, [pc, #20]	@ (34181d98 <LL_APB5_GRP1_EnableClock+0x28>)
34181d82:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
34181d86:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34181d88:	68fb      	ldr	r3, [r7, #12]
}
34181d8a:	bf00      	nop
34181d8c:	3714      	adds	r7, #20
34181d8e:	46bd      	mov	sp, r7
34181d90:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d94:	4770      	bx	lr
34181d96:	bf00      	nop
34181d98:	56028000 	.word	0x56028000

34181d9c <LL_APB5_GRP1_ForceReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ForceReset(uint32_t Periphs)
{
34181d9c:	b480      	push	{r7}
34181d9e:	b083      	sub	sp, #12
34181da0:	af00      	add	r7, sp, #0
34181da2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34181da4:	4a04      	ldr	r2, [pc, #16]	@ (34181db8 <LL_APB5_GRP1_ForceReset+0x1c>)
34181da6:	687b      	ldr	r3, [r7, #4]
34181da8:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34181dac:	bf00      	nop
34181dae:	370c      	adds	r7, #12
34181db0:	46bd      	mov	sp, r7
34181db2:	f85d 7b04 	ldr.w	r7, [sp], #4
34181db6:	4770      	bx	lr
34181db8:	56028000 	.word	0x56028000

34181dbc <LL_APB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34181dbc:	b480      	push	{r7}
34181dbe:	b083      	sub	sp, #12
34181dc0:	af00      	add	r7, sp, #0
34181dc2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34181dc4:	4b06      	ldr	r3, [pc, #24]	@ (34181de0 <LL_APB5_GRP1_ReleaseReset+0x24>)
34181dc6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181dca:	461a      	mov	r2, r3
34181dcc:	687b      	ldr	r3, [r7, #4]
34181dce:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34181dd2:	bf00      	nop
34181dd4:	370c      	adds	r7, #12
34181dd6:	46bd      	mov	sp, r7
34181dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
34181ddc:	4770      	bx	lr
34181dde:	bf00      	nop
34181de0:	56028000 	.word	0x56028000

34181de4 <MX_DCMIPP_Init>:

DCMIPP_HandleTypeDef hdcmipp;

/* DCMIPP init function */
void MX_DCMIPP_Init(void)
{
34181de4:	b580      	push	{r7, lr}
34181de6:	b08a      	sub	sp, #40	@ 0x28
34181de8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DCMIPP_Init 0 */

  /* USER CODE END DCMIPP_Init 0 */

  DCMIPP_CSI_PIPE_ConfTypeDef pCSI_PipeConfig = {0};
34181dea:	f107 031c 	add.w	r3, r7, #28
34181dee:	2200      	movs	r2, #0
34181df0:	601a      	str	r2, [r3, #0]
34181df2:	605a      	str	r2, [r3, #4]
34181df4:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_ConfTypeDef pCSI_Config = {0};
34181df6:	f107 0310 	add.w	r3, r7, #16
34181dfa:	2200      	movs	r2, #0
34181dfc:	601a      	str	r2, [r3, #0]
34181dfe:	605a      	str	r2, [r3, #4]
34181e00:	609a      	str	r2, [r3, #8]
  DCMIPP_PipeConfTypeDef pPipeConfig = {0};
34181e02:	1d3b      	adds	r3, r7, #4
34181e04:	2200      	movs	r2, #0
34181e06:	601a      	str	r2, [r3, #0]
34181e08:	605a      	str	r2, [r3, #4]
34181e0a:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN DCMIPP_Init 1 */

  /* USER CODE END DCMIPP_Init 1 */
  hdcmipp.Instance = DCMIPP;
34181e0c:	4b48      	ldr	r3, [pc, #288]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e0e:	4a49      	ldr	r2, [pc, #292]	@ (34181f34 <MX_DCMIPP_Init+0x150>)
34181e10:	601a      	str	r2, [r3, #0]
  if (HAL_DCMIPP_Init(&hdcmipp) != HAL_OK)
34181e12:	4847      	ldr	r0, [pc, #284]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e14:	f003 fc44 	bl	341856a0 <HAL_DCMIPP_Init>
34181e18:	4603      	mov	r3, r0
34181e1a:	2b00      	cmp	r3, #0
34181e1c:	d001      	beq.n	34181e22 <MX_DCMIPP_Init+0x3e>
  {
    Error_Handler();
34181e1e:	f000 ffbd 	bl	34182d9c <Error_Handler>
  }

  /** Pipe 0 Config
  */
  pCSI_PipeConfig.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34181e22:	2300      	movs	r3, #0
34181e24:	61fb      	str	r3, [r7, #28]
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV420_8;
34181e26:	2318      	movs	r3, #24
34181e28:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_YUV420_8;
34181e2a:	2318      	movs	r3, #24
34181e2c:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pCSI_PipeConfig) != HAL_OK)
34181e2e:	f107 031c 	add.w	r3, r7, #28
34181e32:	461a      	mov	r2, r3
34181e34:	2100      	movs	r1, #0
34181e36:	483e      	ldr	r0, [pc, #248]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e38:	f003 fdc4 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181e3c:	4603      	mov	r3, r0
34181e3e:	2b00      	cmp	r3, #0
34181e40:	d001      	beq.n	34181e46 <MX_DCMIPP_Init+0x62>
  {
    Error_Handler();
34181e42:	f000 ffab 	bl	34182d9c <Error_Handler>
  }
  pCSI_Config.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34181e46:	231c      	movs	r3, #28
34181e48:	61bb      	str	r3, [r7, #24]
  pCSI_Config.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34181e4a:	2301      	movs	r3, #1
34181e4c:	617b      	str	r3, [r7, #20]
  pCSI_Config.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
34181e4e:	f44f 7380 	mov.w	r3, #256	@ 0x100
34181e52:	613b      	str	r3, [r7, #16]
  if (HAL_DCMIPP_CSI_SetConfig(&hdcmipp, &pCSI_Config) != HAL_OK)
34181e54:	f107 0310 	add.w	r3, r7, #16
34181e58:	4619      	mov	r1, r3
34181e5a:	4835      	ldr	r0, [pc, #212]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e5c:	f003 fc4e 	bl	341856fc <HAL_DCMIPP_CSI_SetConfig>
34181e60:	4603      	mov	r3, r0
34181e62:	2b00      	cmp	r3, #0
34181e64:	d001      	beq.n	34181e6a <MX_DCMIPP_Init+0x86>
  {
    Error_Handler();
34181e66:	f000 ff99 	bl	34182d9c <Error_Handler>
  }
  pPipeConfig.FrameRate = DCMIPP_FRAME_RATE_ALL;
34181e6a:	2300      	movs	r3, #0
34181e6c:	607b      	str	r3, [r7, #4]
  pPipeConfig.PixelPipePitch = 240;
34181e6e:	23f0      	movs	r3, #240	@ 0xf0
34181e70:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34181e72:	2300      	movs	r3, #0
34181e74:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pPipeConfig) != HAL_OK)
34181e76:	1d3b      	adds	r3, r7, #4
34181e78:	461a      	mov	r2, r3
34181e7a:	2100      	movs	r1, #0
34181e7c:	482c      	ldr	r0, [pc, #176]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e7e:	f003 fe83 	bl	34185b88 <HAL_DCMIPP_PIPE_SetConfig>
34181e82:	4603      	mov	r3, r0
34181e84:	2b00      	cmp	r3, #0
34181e86:	d001      	beq.n	34181e8c <MX_DCMIPP_Init+0xa8>
  {
    Error_Handler();
34181e88:	f000 ff88 	bl	34182d9c <Error_Handler>
  }
  HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP8);
34181e8c:	2202      	movs	r2, #2
34181e8e:	2100      	movs	r1, #0
34181e90:	4827      	ldr	r0, [pc, #156]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181e92:	f003 fe37 	bl	34185b04 <HAL_DCMIPP_CSI_SetVCConfig>

  /** Pipe 1 Config
  */
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_RGB565;
34181e96:	2322      	movs	r3, #34	@ 0x22
34181e98:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB565;
34181e9a:	2322      	movs	r3, #34	@ 0x22
34181e9c:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pCSI_PipeConfig) != HAL_OK)
34181e9e:	f107 031c 	add.w	r3, r7, #28
34181ea2:	461a      	mov	r2, r3
34181ea4:	2101      	movs	r1, #1
34181ea6:	4822      	ldr	r0, [pc, #136]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181ea8:	f003 fd8c 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181eac:	4603      	mov	r3, r0
34181eae:	2b00      	cmp	r3, #0
34181eb0:	d001      	beq.n	34181eb6 <MX_DCMIPP_Init+0xd2>
  {
    Error_Handler();
34181eb2:	f000 ff73 	bl	34182d9c <Error_Handler>
  }
  pPipeConfig.PixelPipePitch = 480;
34181eb6:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
34181eba:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34181ebc:	2301      	movs	r3, #1
34181ebe:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pPipeConfig) != HAL_OK)
34181ec0:	1d3b      	adds	r3, r7, #4
34181ec2:	461a      	mov	r2, r3
34181ec4:	2101      	movs	r1, #1
34181ec6:	481a      	ldr	r0, [pc, #104]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181ec8:	f003 fe5e 	bl	34185b88 <HAL_DCMIPP_PIPE_SetConfig>
34181ecc:	4603      	mov	r3, r0
34181ece:	2b00      	cmp	r3, #0
34181ed0:	d001      	beq.n	34181ed6 <MX_DCMIPP_Init+0xf2>
  {
    Error_Handler();
34181ed2:	f000 ff63 	bl	34182d9c <Error_Handler>
  }
  if (HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP6) != HAL_OK)
34181ed6:	2200      	movs	r2, #0
34181ed8:	2100      	movs	r1, #0
34181eda:	4815      	ldr	r0, [pc, #84]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181edc:	f003 fe12 	bl	34185b04 <HAL_DCMIPP_CSI_SetVCConfig>
34181ee0:	4603      	mov	r3, r0
34181ee2:	2b00      	cmp	r3, #0
34181ee4:	d001      	beq.n	34181eea <MX_DCMIPP_Init+0x106>
  {
    Error_Handler();
34181ee6:	f000 ff59 	bl	34182d9c <Error_Handler>
  }

  /** Pipe 2 Config
  */
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV422_8;
34181eea:	231e      	movs	r3, #30
34181eec:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB888;
34181eee:	2324      	movs	r3, #36	@ 0x24
34181ef0:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pCSI_PipeConfig) != HAL_OK)
34181ef2:	f107 031c 	add.w	r3, r7, #28
34181ef6:	461a      	mov	r2, r3
34181ef8:	2102      	movs	r1, #2
34181efa:	480d      	ldr	r0, [pc, #52]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181efc:	f003 fd62 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181f00:	4603      	mov	r3, r0
34181f02:	2b00      	cmp	r3, #0
34181f04:	d001      	beq.n	34181f0a <MX_DCMIPP_Init+0x126>
  {
    Error_Handler();
34181f06:	f000 ff49 	bl	34182d9c <Error_Handler>
  }
  pPipeConfig.PixelPipePitch = 10;
34181f0a:	230a      	movs	r3, #10
34181f0c:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34181f0e:	2300      	movs	r3, #0
34181f10:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pPipeConfig) != HAL_OK)
34181f12:	1d3b      	adds	r3, r7, #4
34181f14:	461a      	mov	r2, r3
34181f16:	2102      	movs	r1, #2
34181f18:	4805      	ldr	r0, [pc, #20]	@ (34181f30 <MX_DCMIPP_Init+0x14c>)
34181f1a:	f003 fe35 	bl	34185b88 <HAL_DCMIPP_PIPE_SetConfig>
34181f1e:	4603      	mov	r3, r0
34181f20:	2b00      	cmp	r3, #0
34181f22:	d001      	beq.n	34181f28 <MX_DCMIPP_Init+0x144>
  {
    Error_Handler();
34181f24:	f000 ff3a 	bl	34182d9c <Error_Handler>
  }
  /* USER CODE BEGIN DCMIPP_Init 2 */

  /* USER CODE END DCMIPP_Init 2 */

}
34181f28:	bf00      	nop
34181f2a:	3728      	adds	r7, #40	@ 0x28
34181f2c:	46bd      	mov	sp, r7
34181f2e:	bd80      	pop	{r7, pc}
34181f30:	341c04f0 	.word	0x341c04f0
34181f34:	58002000 	.word	0x58002000

34181f38 <HAL_DCMIPP_MspInit>:

void HAL_DCMIPP_MspInit(DCMIPP_HandleTypeDef* dcmippHandle)
{
34181f38:	b580      	push	{r7, lr}
34181f3a:	b0e6      	sub	sp, #408	@ 0x198
34181f3c:	af00      	add	r7, sp, #0
34181f3e:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f42:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34181f46:	6018      	str	r0, [r3, #0]

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34181f48:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f4c:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181f50:	4618      	mov	r0, r3
34181f52:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34181f56:	461a      	mov	r2, r3
34181f58:	2100      	movs	r1, #0
34181f5a:	f021 ff23 	bl	341a3da4 <memset>
  if(dcmippHandle->Instance==DCMIPP)
34181f5e:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f62:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34181f66:	681b      	ldr	r3, [r3, #0]
34181f68:	681b      	ldr	r3, [r3, #0]
34181f6a:	4a27      	ldr	r2, [pc, #156]	@ (34182008 <HAL_DCMIPP_MspInit+0xd0>)
34181f6c:	4293      	cmp	r3, r2
34181f6e:	d145      	bne.n	34181ffc <HAL_DCMIPP_MspInit+0xc4>

  /* USER CODE END DCMIPP_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP|RCC_PERIPHCLK_CSI;
34181f70:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f74:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34181f78:	f04f 0218 	mov.w	r2, #24
34181f7c:	f04f 0300 	mov.w	r3, #0
34181f80:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_PCLK5;
34181f84:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f88:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181f8c:	2200      	movs	r2, #0
34181f8e:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL4;
34181f92:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f96:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181f9a:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
34181f9e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockDivider = 1;
34181fa2:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181fa6:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181faa:	2201      	movs	r2, #1
34181fac:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34181fb0:	f107 0308 	add.w	r3, r7, #8
34181fb4:	4618      	mov	r0, r3
34181fb6:	f00c fb13 	bl	3418e5e0 <HAL_RCCEx_PeriphCLKConfig>
34181fba:	4603      	mov	r3, r0
34181fbc:	2b00      	cmp	r3, #0
34181fbe:	d001      	beq.n	34181fc4 <HAL_DCMIPP_MspInit+0x8c>
    {
      Error_Handler();
34181fc0:	f000 feec 	bl	34182d9c <Error_Handler>
    }

    /* DCMIPP clock enable */
    __HAL_RCC_DCMIPP_CLK_ENABLE();
34181fc4:	2004      	movs	r0, #4
34181fc6:	f7ff fed3 	bl	34181d70 <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_CLK_ENABLE();
34181fca:	2040      	movs	r0, #64	@ 0x40
34181fcc:	f7ff fed0 	bl	34181d70 <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_FORCE_RESET();
34181fd0:	2040      	movs	r0, #64	@ 0x40
34181fd2:	f7ff fee3 	bl	34181d9c <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_CSI_RELEASE_RESET();
34181fd6:	2040      	movs	r0, #64	@ 0x40
34181fd8:	f7ff fef0 	bl	34181dbc <LL_APB5_GRP1_ReleaseReset>

    /* DCMIPP interrupt Init */
    HAL_NVIC_SetPriority(DCMIPP_IRQn, 0, 0);
34181fdc:	2200      	movs	r2, #0
34181fde:	2100      	movs	r1, #0
34181fe0:	2030      	movs	r0, #48	@ 0x30
34181fe2:	f003 fb26 	bl	34185632 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
34181fe6:	2030      	movs	r0, #48	@ 0x30
34181fe8:	f003 fb40 	bl	3418566c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(CSI_IRQn, 0, 0);
34181fec:	2200      	movs	r2, #0
34181fee:	2100      	movs	r1, #0
34181ff0:	202f      	movs	r0, #47	@ 0x2f
34181ff2:	f003 fb1e 	bl	34185632 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CSI_IRQn);
34181ff6:	202f      	movs	r0, #47	@ 0x2f
34181ff8:	f003 fb38 	bl	3418566c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN DCMIPP_MspInit 1 */

  /* USER CODE END DCMIPP_MspInit 1 */
  }
}
34181ffc:	bf00      	nop
34181ffe:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
34182002:	46bd      	mov	sp, r7
34182004:	bd80      	pop	{r7, pc}
34182006:	bf00      	nop
34182008:	58002000 	.word	0x58002000

3418200c <MX_EXTMEM_MANAGER_Init>:
/**
  * Init External memory manager
  * @retval None
  */
void MX_EXTMEM_MANAGER_Init(void)
{
3418200c:	b580      	push	{r7, lr}
3418200e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_EXTMEM_Init_PreTreatment */

  /* USER CODE END MX_EXTMEM_Init_PreTreatment */

  /* Initialization of the memory parameters */
  memset(extmem_list_config, 0x0, sizeof(extmem_list_config));
34182010:	f44f 72ac 	mov.w	r2, #344	@ 0x158
34182014:	2100      	movs	r1, #0
34182016:	4830      	ldr	r0, [pc, #192]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182018:	f021 fec4 	bl	341a3da4 <memset>

  /* EXTMEMORY_1 */
  extmem_list_config[0].MemType = EXTMEM_NOR_SFDP;
3418201c:	4b2e      	ldr	r3, [pc, #184]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418201e:	2200      	movs	r2, #0
34182020:	701a      	strb	r2, [r3, #0]
  extmem_list_config[0].Handle = (void*)&hxspi2;
34182022:	4b2d      	ldr	r3, [pc, #180]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182024:	4a2d      	ldr	r2, [pc, #180]	@ (341820dc <MX_EXTMEM_MANAGER_Init+0xd0>)
34182026:	605a      	str	r2, [r3, #4]
  extmem_list_config[0].ConfigType = EXTMEM_LINK_CONFIG_8LINES;
34182028:	4b2b      	ldr	r3, [pc, #172]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418202a:	2203      	movs	r2, #3
3418202c:	721a      	strb	r2, [r3, #8]

  /* EXTMEMORY_2 */
  extmem_list_config[1].MemType = EXTMEM_PSRAM;
3418202e:	4b2a      	ldr	r3, [pc, #168]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182030:	2202      	movs	r2, #2
34182032:	f883 20ac 	strb.w	r2, [r3, #172]	@ 0xac
  extmem_list_config[1].Handle = (void*)&hxspi1;
34182036:	4b28      	ldr	r3, [pc, #160]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182038:	4a29      	ldr	r2, [pc, #164]	@ (341820e0 <MX_EXTMEM_MANAGER_Init+0xd4>)
3418203a:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
  extmem_list_config[1].ConfigType = EXTMEM_LINK_CONFIG_1LINE;
3418203e:	4b26      	ldr	r3, [pc, #152]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182040:	2200      	movs	r2, #0
34182042:	f883 20b4 	strb.w	r2, [r3, #180]	@ 0xb4

  extmem_list_config[1].PsramObject.psram_public.MemorySize = HAL_XSPI_SIZE_256MB;
34182046:	4b24      	ldr	r3, [pc, #144]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182048:	2218      	movs	r2, #24
3418204a:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  extmem_list_config[1].PsramObject.psram_public.FreqMax = 200 * 1000000u;
3418204e:	4b22      	ldr	r3, [pc, #136]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182050:	4a24      	ldr	r2, [pc, #144]	@ (341820e4 <MX_EXTMEM_MANAGER_Init+0xd8>)
34182052:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  extmem_list_config[1].PsramObject.psram_public.NumberOfConfig = 0u;
34182056:	4b20      	ldr	r3, [pc, #128]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182058:	2200      	movs	r2, #0
3418205a:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114

  /* Memory command configuration */
  extmem_list_config[1].PsramObject.psram_public.ReadREG           = 0x40u;
3418205e:	4b1e      	ldr	r3, [pc, #120]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182060:	2240      	movs	r2, #64	@ 0x40
34182062:	f883 211e 	strb.w	r2, [r3, #286]	@ 0x11e
  extmem_list_config[1].PsramObject.psram_public.WriteREG          = 0xC0u;
34182066:	4b1c      	ldr	r3, [pc, #112]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182068:	22c0      	movs	r2, #192	@ 0xc0
3418206a:	f883 211f 	strb.w	r2, [r3, #287]	@ 0x11f
  extmem_list_config[1].PsramObject.psram_public.ReadREGSize       = 2u;
3418206e:	4b1a      	ldr	r3, [pc, #104]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182070:	2202      	movs	r2, #2
34182072:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
  extmem_list_config[1].PsramObject.psram_public.REG_DummyCycle    = 4u;
34182076:	4b18      	ldr	r3, [pc, #96]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182078:	2204      	movs	r2, #4
3418207a:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
  extmem_list_config[1].PsramObject.psram_public.Write_command     = 0xA0u;
3418207e:	4b16      	ldr	r3, [pc, #88]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182080:	22a0      	movs	r2, #160	@ 0xa0
34182082:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
  extmem_list_config[1].PsramObject.psram_public.Write_DummyCycle  = 4u;
34182086:	4b14      	ldr	r3, [pc, #80]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182088:	2204      	movs	r2, #4
3418208a:	f883 2123 	strb.w	r2, [r3, #291]	@ 0x123
  extmem_list_config[1].PsramObject.psram_public.Read_command      = 0x20u;
3418208e:	4b12      	ldr	r3, [pc, #72]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182090:	2220      	movs	r2, #32
34182092:	f883 2124 	strb.w	r2, [r3, #292]	@ 0x124
  extmem_list_config[1].PsramObject.psram_public.WrapRead_command  = 0x00u;
34182096:	4b10      	ldr	r3, [pc, #64]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182098:	2200      	movs	r2, #0
3418209a:	f883 2125 	strb.w	r2, [r3, #293]	@ 0x125
  extmem_list_config[1].PsramObject.psram_public.Read_DummyCycle   = 4u;
3418209e:	4b0e      	ldr	r3, [pc, #56]	@ (341820d8 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820a0:	2204      	movs	r2, #4
341820a2:	f883 2126 	strb.w	r2, [r3, #294]	@ 0x126

  EXTMEM_Init(EXTMEMORY_1, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI2));
341820a6:	f04f 0000 	mov.w	r0, #0
341820aa:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
341820ae:	f00e fd7b 	bl	34190ba8 <HAL_RCCEx_GetPeriphCLKFreq>
341820b2:	4603      	mov	r3, r0
341820b4:	4619      	mov	r1, r3
341820b6:	2000      	movs	r0, #0
341820b8:	f01e ffda 	bl	341a1070 <EXTMEM_Init>
  EXTMEM_Init(EXTMEMORY_2, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1));
341820bc:	f04f 0000 	mov.w	r0, #0
341820c0:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
341820c4:	f00e fd70 	bl	34190ba8 <HAL_RCCEx_GetPeriphCLKFreq>
341820c8:	4603      	mov	r3, r0
341820ca:	4619      	mov	r1, r3
341820cc:	2001      	movs	r0, #1
341820ce:	f01e ffcf 	bl	341a1070 <EXTMEM_Init>

  /* USER CODE BEGIN MX_EXTMEM_Init_PostTreatment */

  /* USER CODE END MX_EXTMEM_Init_PostTreatment */
}
341820d2:	bf00      	nop
341820d4:	bd80      	pop	{r7, pc}
341820d6:	bf00      	nop
341820d8:	341c1a2c 	.word	0x341c1a2c
341820dc:	341c060c 	.word	0x341c060c
341820e0:	341c05a8 	.word	0x341c05a8
341820e4:	0bebc200 	.word	0x0bebc200

341820e8 <LL_AHB4_GRP1_EnableClock>:
{
341820e8:	b480      	push	{r7}
341820ea:	b085      	sub	sp, #20
341820ec:	af00      	add	r7, sp, #0
341820ee:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341820f0:	4a07      	ldr	r2, [pc, #28]	@ (34182110 <LL_AHB4_GRP1_EnableClock+0x28>)
341820f2:	687b      	ldr	r3, [r7, #4]
341820f4:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341820f8:	4b05      	ldr	r3, [pc, #20]	@ (34182110 <LL_AHB4_GRP1_EnableClock+0x28>)
341820fa:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341820fe:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34182100:	68fb      	ldr	r3, [r7, #12]
}
34182102:	bf00      	nop
34182104:	3714      	adds	r7, #20
34182106:	46bd      	mov	sp, r7
34182108:	f85d 7b04 	ldr.w	r7, [sp], #4
3418210c:	4770      	bx	lr
3418210e:	bf00      	nop
34182110:	56028000 	.word	0x56028000

34182114 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
34182114:	b580      	push	{r7, lr}
34182116:	b086      	sub	sp, #24
34182118:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
3418211a:	1d3b      	adds	r3, r7, #4
3418211c:	2200      	movs	r2, #0
3418211e:	601a      	str	r2, [r3, #0]
34182120:	605a      	str	r2, [r3, #4]
34182122:	609a      	str	r2, [r3, #8]
34182124:	60da      	str	r2, [r3, #12]
34182126:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOQ_CLK_ENABLE();
34182128:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
3418212c:	f7ff ffdc 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOC_CLK_ENABLE();
34182130:	2004      	movs	r0, #4
34182132:	f7ff ffd9 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34182136:	2080      	movs	r0, #128	@ 0x80
34182138:	f7ff ffd6 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
3418213c:	2002      	movs	r0, #2
3418213e:	f7ff ffd3 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOD_CLK_ENABLE();
34182142:	2008      	movs	r0, #8
34182144:	f7ff ffd0 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
34182148:	2010      	movs	r0, #16
3418214a:	f7ff ffcd 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOP_CLK_ENABLE();
3418214e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34182152:	f7ff ffc9 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34182156:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3418215a:	f7ff ffc5 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
3418215e:	2040      	movs	r0, #64	@ 0x40
34182160:	f7ff ffc2 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
34182164:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34182168:	f7ff ffbe 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
3418216c:	2001      	movs	r0, #1
3418216e:	f7ff ffbb 	bl	341820e8 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOQ, LCD_BL_CTRL_Pin|LCD_ONOFF_Pin, GPIO_PIN_RESET);
34182172:	2200      	movs	r2, #0
34182174:	2148      	movs	r1, #72	@ 0x48
34182176:	4839      	ldr	r0, [pc, #228]	@ (3418225c <MX_GPIO_Init+0x148>)
34182178:	f006 fd7a 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(EN_CAM_GPIO_Port, EN_CAM_Pin, GPIO_PIN_RESET);
3418217c:	2200      	movs	r2, #0
3418217e:	2104      	movs	r1, #4
34182180:	4837      	ldr	r0, [pc, #220]	@ (34182260 <MX_GPIO_Init+0x14c>)
34182182:	f006 fd75 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(NRST_CAM_GPIO_Port, NRST_CAM_Pin, GPIO_PIN_RESET);
34182186:	2200      	movs	r2, #0
34182188:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418218c:	4835      	ldr	r0, [pc, #212]	@ (34182264 <MX_GPIO_Init+0x150>)
3418218e:	f006 fd6f 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_NRST_GPIO_Port, LCD_NRST_Pin, GPIO_PIN_RESET);
34182192:	2200      	movs	r2, #0
34182194:	2102      	movs	r1, #2
34182196:	4834      	ldr	r0, [pc, #208]	@ (34182268 <MX_GPIO_Init+0x154>)
34182198:	f006 fd6a 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
3418219c:	2200      	movs	r2, #0
3418219e:	2102      	movs	r1, #2
341821a0:	4832      	ldr	r0, [pc, #200]	@ (3418226c <MX_GPIO_Init+0x158>)
341821a2:	f006 fd65 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
341821a6:	2200      	movs	r2, #0
341821a8:	f44f 6180 	mov.w	r1, #1024	@ 0x400
341821ac:	4830      	ldr	r0, [pc, #192]	@ (34182270 <MX_GPIO_Init+0x15c>)
341821ae:	f006 fd5f 	bl	34188c70 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LCD_BL_CTRL_Pin LCD_ONOFF_Pin */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin|LCD_ONOFF_Pin;
341821b2:	2348      	movs	r3, #72	@ 0x48
341821b4:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
341821b6:	2301      	movs	r3, #1
341821b8:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
341821ba:	2300      	movs	r3, #0
341821bc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
341821be:	2302      	movs	r3, #2
341821c0:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOQ, &GPIO_InitStruct);
341821c2:	1d3b      	adds	r3, r7, #4
341821c4:	4619      	mov	r1, r3
341821c6:	4825      	ldr	r0, [pc, #148]	@ (3418225c <MX_GPIO_Init+0x148>)
341821c8:	f006 fa60 	bl	3418868c <HAL_GPIO_Init>

  /*Configure GPIO pin : EN_CAM_Pin */
  GPIO_InitStruct.Pin = EN_CAM_Pin;
341821cc:	2304      	movs	r3, #4
341821ce:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
341821d0:	2301      	movs	r3, #1
341821d2:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
341821d4:	2300      	movs	r3, #0
341821d6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
341821d8:	2302      	movs	r3, #2
341821da:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(EN_CAM_GPIO_Port, &GPIO_InitStruct);
341821dc:	1d3b      	adds	r3, r7, #4
341821de:	4619      	mov	r1, r3
341821e0:	481f      	ldr	r0, [pc, #124]	@ (34182260 <MX_GPIO_Init+0x14c>)
341821e2:	f006 fa53 	bl	3418868c <HAL_GPIO_Init>

  /*Configure GPIO pin : NRST_CAM_Pin */
  GPIO_InitStruct.Pin = NRST_CAM_Pin;
341821e6:	f44f 7380 	mov.w	r3, #256	@ 0x100
341821ea:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
341821ec:	2301      	movs	r3, #1
341821ee:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
341821f0:	2300      	movs	r3, #0
341821f2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
341821f4:	2302      	movs	r3, #2
341821f6:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(NRST_CAM_GPIO_Port, &GPIO_InitStruct);
341821f8:	1d3b      	adds	r3, r7, #4
341821fa:	4619      	mov	r1, r3
341821fc:	4819      	ldr	r0, [pc, #100]	@ (34182264 <MX_GPIO_Init+0x150>)
341821fe:	f006 fa45 	bl	3418868c <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_NRST_Pin */
  GPIO_InitStruct.Pin = LCD_NRST_Pin;
34182202:	2302      	movs	r3, #2
34182204:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182206:	2301      	movs	r3, #1
34182208:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
3418220a:	2300      	movs	r3, #0
3418220c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
3418220e:	2302      	movs	r3, #2
34182210:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LCD_NRST_GPIO_Port, &GPIO_InitStruct);
34182212:	1d3b      	adds	r3, r7, #4
34182214:	4619      	mov	r1, r3
34182216:	4814      	ldr	r0, [pc, #80]	@ (34182268 <MX_GPIO_Init+0x154>)
34182218:	f006 fa38 	bl	3418868c <HAL_GPIO_Init>

  /*Configure GPIO pin : LED1_Pin */
  GPIO_InitStruct.Pin = LED1_Pin;
3418221c:	2302      	movs	r3, #2
3418221e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182220:	2301      	movs	r3, #1
34182222:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34182224:	2300      	movs	r3, #0
34182226:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182228:	2300      	movs	r3, #0
3418222a:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
3418222c:	1d3b      	adds	r3, r7, #4
3418222e:	4619      	mov	r1, r3
34182230:	480e      	ldr	r0, [pc, #56]	@ (3418226c <MX_GPIO_Init+0x158>)
34182232:	f006 fa2b 	bl	3418868c <HAL_GPIO_Init>

  /*Configure GPIO pin : LED2_Pin */
  GPIO_InitStruct.Pin = LED2_Pin;
34182236:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3418223a:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
3418223c:	2301      	movs	r3, #1
3418223e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34182240:	2300      	movs	r3, #0
34182242:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182244:	2300      	movs	r3, #0
34182246:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct);
34182248:	1d3b      	adds	r3, r7, #4
3418224a:	4619      	mov	r1, r3
3418224c:	4808      	ldr	r0, [pc, #32]	@ (34182270 <MX_GPIO_Init+0x15c>)
3418224e:	f006 fa1d 	bl	3418868c <HAL_GPIO_Init>

}
34182252:	bf00      	nop
34182254:	3718      	adds	r7, #24
34182256:	46bd      	mov	sp, r7
34182258:	bd80      	pop	{r7, pc}
3418225a:	bf00      	nop
3418225c:	56024000 	.word	0x56024000
34182260:	56020c00 	.word	0x56020c00
34182264:	56020800 	.word	0x56020800
34182268:	56021000 	.word	0x56021000
3418226c:	56023800 	.word	0x56023800
34182270:	56021800 	.word	0x56021800

34182274 <LL_AHB4_GRP1_EnableClock>:
{
34182274:	b480      	push	{r7}
34182276:	b085      	sub	sp, #20
34182278:	af00      	add	r7, sp, #0
3418227a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3418227c:	4a07      	ldr	r2, [pc, #28]	@ (3418229c <LL_AHB4_GRP1_EnableClock+0x28>)
3418227e:	687b      	ldr	r3, [r7, #4]
34182280:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34182284:	4b05      	ldr	r3, [pc, #20]	@ (3418229c <LL_AHB4_GRP1_EnableClock+0x28>)
34182286:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418228a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418228c:	68fb      	ldr	r3, [r7, #12]
}
3418228e:	bf00      	nop
34182290:	3714      	adds	r7, #20
34182292:	46bd      	mov	sp, r7
34182294:	f85d 7b04 	ldr.w	r7, [sp], #4
34182298:	4770      	bx	lr
3418229a:	bf00      	nop
3418229c:	56028000 	.word	0x56028000

341822a0 <LL_APB1_GRP1_EnableClock>:
{
341822a0:	b480      	push	{r7}
341822a2:	b085      	sub	sp, #20
341822a4:	af00      	add	r7, sp, #0
341822a6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
341822a8:	4a07      	ldr	r2, [pc, #28]	@ (341822c8 <LL_APB1_GRP1_EnableClock+0x28>)
341822aa:	687b      	ldr	r3, [r7, #4]
341822ac:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
341822b0:	4b05      	ldr	r3, [pc, #20]	@ (341822c8 <LL_APB1_GRP1_EnableClock+0x28>)
341822b2:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
341822b6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341822b8:	68fb      	ldr	r3, [r7, #12]
}
341822ba:	bf00      	nop
341822bc:	3714      	adds	r7, #20
341822be:	46bd      	mov	sp, r7
341822c0:	f85d 7b04 	ldr.w	r7, [sp], #4
341822c4:	4770      	bx	lr
341822c6:	bf00      	nop
341822c8:	56028000 	.word	0x56028000

341822cc <LL_APB1_GRP1_DisableClock>:
{
341822cc:	b480      	push	{r7}
341822ce:	b083      	sub	sp, #12
341822d0:	af00      	add	r7, sp, #0
341822d2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
341822d4:	4b06      	ldr	r3, [pc, #24]	@ (341822f0 <LL_APB1_GRP1_DisableClock+0x24>)
341822d6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341822da:	461a      	mov	r2, r3
341822dc:	687b      	ldr	r3, [r7, #4]
341822de:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
341822e2:	bf00      	nop
341822e4:	370c      	adds	r7, #12
341822e6:	46bd      	mov	sp, r7
341822e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341822ec:	4770      	bx	lr
341822ee:	bf00      	nop
341822f0:	56028000 	.word	0x56028000

341822f4 <HAL_I2C_MspInit>:
 /* USER CODE END I2C1_Init 2 */

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
341822f4:	b580      	push	{r7, lr}
341822f6:	b0ec      	sub	sp, #432	@ 0x1b0
341822f8:	af00      	add	r7, sp, #0
341822fa:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341822fe:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34182302:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34182304:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182308:	2200      	movs	r2, #0
3418230a:	601a      	str	r2, [r3, #0]
3418230c:	605a      	str	r2, [r3, #4]
3418230e:	609a      	str	r2, [r3, #8]
34182310:	60da      	str	r2, [r3, #12]
34182312:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34182314:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182318:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3418231c:	4618      	mov	r0, r3
3418231e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34182322:	461a      	mov	r2, r3
34182324:	2100      	movs	r1, #0
34182326:	f021 fd3d 	bl	341a3da4 <memset>
  if(i2cHandle->Instance==I2C1)
3418232a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418232e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34182332:	681b      	ldr	r3, [r3, #0]
34182334:	681b      	ldr	r3, [r3, #0]
34182336:	4a2c      	ldr	r2, [pc, #176]	@ (341823e8 <HAL_I2C_MspInit+0xf4>)
34182338:	4293      	cmp	r3, r2
3418233a:	d14f      	bne.n	341823dc <HAL_I2C_MspInit+0xe8>

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
3418233c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182340:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34182344:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34182348:	f04f 0300 	mov.w	r3, #0
3418234c:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
34182350:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182354:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182358:	4a24      	ldr	r2, [pc, #144]	@ (341823ec <HAL_I2C_MspInit+0xf8>)
3418235a:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
3418235e:	f107 0308 	add.w	r3, r7, #8
34182362:	4618      	mov	r0, r3
34182364:	f00c f93c 	bl	3418e5e0 <HAL_RCCEx_PeriphCLKConfig>
34182368:	4603      	mov	r3, r0
3418236a:	2b00      	cmp	r3, #0
3418236c:	d001      	beq.n	34182372 <HAL_I2C_MspInit+0x7e>
    {
      Error_Handler();
3418236e:	f000 fd15 	bl	34182d9c <Error_Handler>
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
34182372:	2004      	movs	r0, #4
34182374:	f7ff ff7e 	bl	34182274 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34182378:	2080      	movs	r0, #128	@ 0x80
3418237a:	f7ff ff7b 	bl	34182274 <LL_AHB4_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1;
3418237e:	2302      	movs	r3, #2
34182380:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
34182384:	2312      	movs	r3, #18
34182386:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418238a:	2300      	movs	r3, #0
3418238c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182390:	2300      	movs	r3, #0
34182392:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
34182396:	2304      	movs	r3, #4
34182398:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
3418239c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341823a0:	4619      	mov	r1, r3
341823a2:	4813      	ldr	r0, [pc, #76]	@ (341823f0 <HAL_I2C_MspInit+0xfc>)
341823a4:	f006 f972 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
341823a8:	f44f 7300 	mov.w	r3, #512	@ 0x200
341823ac:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
341823b0:	2312      	movs	r3, #18
341823b2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341823b6:	2300      	movs	r3, #0
341823b8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341823bc:	2300      	movs	r3, #0
341823be:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
341823c2:	2304      	movs	r3, #4
341823c4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
341823c8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341823cc:	4619      	mov	r1, r3
341823ce:	4809      	ldr	r0, [pc, #36]	@ (341823f4 <HAL_I2C_MspInit+0x100>)
341823d0:	f006 f95c 	bl	3418868c <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
341823d4:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
341823d8:	f7ff ff62 	bl	341822a0 <LL_APB1_GRP1_EnableClock>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
341823dc:	bf00      	nop
341823de:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
341823e2:	46bd      	mov	sp, r7
341823e4:	bd80      	pop	{r7, pc}
341823e6:	bf00      	nop
341823e8:	50005400 	.word	0x50005400
341823ec:	0700000c 	.word	0x0700000c
341823f0:	56020800 	.word	0x56020800
341823f4:	56021c00 	.word	0x56021c00

341823f8 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
341823f8:	b580      	push	{r7, lr}
341823fa:	b082      	sub	sp, #8
341823fc:	af00      	add	r7, sp, #0
341823fe:	6078      	str	r0, [r7, #4]

  if(i2cHandle->Instance==I2C1)
34182400:	687b      	ldr	r3, [r7, #4]
34182402:	681b      	ldr	r3, [r3, #0]
34182404:	4a09      	ldr	r2, [pc, #36]	@ (3418242c <HAL_I2C_MspDeInit+0x34>)
34182406:	4293      	cmp	r3, r2
34182408:	d10c      	bne.n	34182424 <HAL_I2C_MspDeInit+0x2c>
  {
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();
3418240a:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
3418240e:	f7ff ff5d 	bl	341822cc <LL_APB1_GRP1_DisableClock>

    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_1);
34182412:	2102      	movs	r1, #2
34182414:	4806      	ldr	r0, [pc, #24]	@ (34182430 <HAL_I2C_MspDeInit+0x38>)
34182416:	f006 faeb 	bl	341889f0 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOH, GPIO_PIN_9);
3418241a:	f44f 7100 	mov.w	r1, #512	@ 0x200
3418241e:	4805      	ldr	r0, [pc, #20]	@ (34182434 <HAL_I2C_MspDeInit+0x3c>)
34182420:	f006 fae6 	bl	341889f0 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
}
34182424:	bf00      	nop
34182426:	3708      	adds	r7, #8
34182428:	46bd      	mov	sp, r7
3418242a:	bd80      	pop	{r7, pc}
3418242c:	50005400 	.word	0x50005400
34182430:	56020800 	.word	0x56020800
34182434:	56021c00 	.word	0x56021c00

34182438 <LL_AHB4_GRP1_EnableClock>:
{
34182438:	b480      	push	{r7}
3418243a:	b085      	sub	sp, #20
3418243c:	af00      	add	r7, sp, #0
3418243e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34182440:	4a07      	ldr	r2, [pc, #28]	@ (34182460 <LL_AHB4_GRP1_EnableClock+0x28>)
34182442:	687b      	ldr	r3, [r7, #4]
34182444:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34182448:	4b05      	ldr	r3, [pc, #20]	@ (34182460 <LL_AHB4_GRP1_EnableClock+0x28>)
3418244a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418244e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34182450:	68fb      	ldr	r3, [r7, #12]
}
34182452:	bf00      	nop
34182454:	3714      	adds	r7, #20
34182456:	46bd      	mov	sp, r7
34182458:	f85d 7b04 	ldr.w	r7, [sp], #4
3418245c:	4770      	bx	lr
3418245e:	bf00      	nop
34182460:	56028000 	.word	0x56028000

34182464 <LL_APB5_GRP1_EnableClock>:
{
34182464:	b480      	push	{r7}
34182466:	b085      	sub	sp, #20
34182468:	af00      	add	r7, sp, #0
3418246a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
3418246c:	4a07      	ldr	r2, [pc, #28]	@ (3418248c <LL_APB5_GRP1_EnableClock+0x28>)
3418246e:	687b      	ldr	r3, [r7, #4]
34182470:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
34182474:	4b05      	ldr	r3, [pc, #20]	@ (3418248c <LL_APB5_GRP1_EnableClock+0x28>)
34182476:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
3418247a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418247c:	68fb      	ldr	r3, [r7, #12]
}
3418247e:	bf00      	nop
34182480:	3714      	adds	r7, #20
34182482:	46bd      	mov	sp, r7
34182484:	f85d 7b04 	ldr.w	r7, [sp], #4
34182488:	4770      	bx	lr
3418248a:	bf00      	nop
3418248c:	56028000 	.word	0x56028000

34182490 <MX_LTDC_Init_CubeMX>:

LTDC_HandleTypeDef hltdc;

/* LTDC init function */
void MX_LTDC_Init_CubeMX(void)
{
34182490:	b580      	push	{r7, lr}
34182492:	b09c      	sub	sp, #112	@ 0x70
34182494:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
34182496:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
3418249a:	2234      	movs	r2, #52	@ 0x34
3418249c:	2100      	movs	r1, #0
3418249e:	4618      	mov	r0, r3
341824a0:	f021 fc80 	bl	341a3da4 <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
341824a4:	f107 0308 	add.w	r3, r7, #8
341824a8:	2234      	movs	r2, #52	@ 0x34
341824aa:	2100      	movs	r1, #0
341824ac:	4618      	mov	r0, r3
341824ae:	f021 fc79 	bl	341a3da4 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
341824b2:	4b58      	ldr	r3, [pc, #352]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824b4:	4a58      	ldr	r2, [pc, #352]	@ (34182618 <MX_LTDC_Init_CubeMX+0x188>)
341824b6:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
341824b8:	4b56      	ldr	r3, [pc, #344]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824ba:	2200      	movs	r2, #0
341824bc:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
341824be:	4b55      	ldr	r3, [pc, #340]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824c0:	2200      	movs	r2, #0
341824c2:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
341824c4:	4b53      	ldr	r3, [pc, #332]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824c6:	2200      	movs	r2, #0
341824c8:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
341824ca:	4b52      	ldr	r3, [pc, #328]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824cc:	2200      	movs	r2, #0
341824ce:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 4;
341824d0:	4b50      	ldr	r3, [pc, #320]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824d2:	2204      	movs	r2, #4
341824d4:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 4;
341824d6:	4b4f      	ldr	r3, [pc, #316]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824d8:	2204      	movs	r2, #4
341824da:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 12;
341824dc:	4b4d      	ldr	r3, [pc, #308]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824de:	220c      	movs	r2, #12
341824e0:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 12;
341824e2:	4b4c      	ldr	r3, [pc, #304]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824e4:	220c      	movs	r2, #12
341824e6:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 812;
341824e8:	4b4a      	ldr	r3, [pc, #296]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824ea:	f44f 724b 	mov.w	r2, #812	@ 0x32c
341824ee:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc.Init.AccumulatedActiveH = 492;
341824f0:	4b48      	ldr	r3, [pc, #288]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824f2:	f44f 72f6 	mov.w	r2, #492	@ 0x1ec
341824f6:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc.Init.TotalWidth = 820;
341824f8:	4b46      	ldr	r3, [pc, #280]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341824fa:	f44f 724d 	mov.w	r2, #820	@ 0x334
341824fe:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc.Init.TotalHeigh = 500;
34182500:	4b44      	ldr	r3, [pc, #272]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
34182502:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
34182506:	631a      	str	r2, [r3, #48]	@ 0x30
  hltdc.Init.Backcolor.Blue = 0;
34182508:	4b42      	ldr	r3, [pc, #264]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
3418250a:	2200      	movs	r2, #0
3418250c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc.Init.Backcolor.Green = 0;
34182510:	4b40      	ldr	r3, [pc, #256]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
34182512:	2200      	movs	r2, #0
34182514:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc.Init.Backcolor.Red = 0;
34182518:	4b3e      	ldr	r3, [pc, #248]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
3418251a:	2200      	movs	r2, #0
3418251c:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
34182520:	483c      	ldr	r0, [pc, #240]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
34182522:	f007 fa70 	bl	34189a06 <HAL_LTDC_Init>
34182526:	4603      	mov	r3, r0
34182528:	2b00      	cmp	r3, #0
3418252a:	d001      	beq.n	34182530 <MX_LTDC_Init_CubeMX+0xa0>
  {
    Error_Handler();
3418252c:	f000 fc36 	bl	34182d9c <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
34182530:	2300      	movs	r3, #0
34182532:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.WindowX1 = 100;
34182534:	2364      	movs	r3, #100	@ 0x64
34182536:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.WindowY0 = 0;
34182538:	2300      	movs	r3, #0
3418253a:	647b      	str	r3, [r7, #68]	@ 0x44
  pLayerCfg.WindowY1 = 100;
3418253c:	2364      	movs	r3, #100	@ 0x64
3418253e:	64bb      	str	r3, [r7, #72]	@ 0x48
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34182540:	2304      	movs	r3, #4
34182542:	64fb      	str	r3, [r7, #76]	@ 0x4c
  pLayerCfg.Alpha = 255;
34182544:	23ff      	movs	r3, #255	@ 0xff
34182546:	653b      	str	r3, [r7, #80]	@ 0x50
  pLayerCfg.Alpha0 = 128;
34182548:	2380      	movs	r3, #128	@ 0x80
3418254a:	657b      	str	r3, [r7, #84]	@ 0x54
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
3418254c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34182550:	65bb      	str	r3, [r7, #88]	@ 0x58
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
34182552:	2305      	movs	r3, #5
34182554:	65fb      	str	r3, [r7, #92]	@ 0x5c
  pLayerCfg.FBStartAdress = 0;
34182556:	2300      	movs	r3, #0
34182558:	663b      	str	r3, [r7, #96]	@ 0x60
  pLayerCfg.ImageWidth = 100;
3418255a:	2364      	movs	r3, #100	@ 0x64
3418255c:	667b      	str	r3, [r7, #100]	@ 0x64
  pLayerCfg.ImageHeight = 100;
3418255e:	2364      	movs	r3, #100	@ 0x64
34182560:	66bb      	str	r3, [r7, #104]	@ 0x68
  pLayerCfg.Backcolor.Blue = 0;
34182562:	2300      	movs	r3, #0
34182564:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
  pLayerCfg.Backcolor.Green = 255;
34182568:	23ff      	movs	r3, #255	@ 0xff
3418256a:	f887 306d 	strb.w	r3, [r7, #109]	@ 0x6d
  pLayerCfg.Backcolor.Red = 0;
3418256e:	2300      	movs	r3, #0
34182570:	f887 306e 	strb.w	r3, [r7, #110]	@ 0x6e
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
34182574:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34182578:	2200      	movs	r2, #0
3418257a:	4619      	mov	r1, r3
3418257c:	4825      	ldr	r0, [pc, #148]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
3418257e:	f007 faed 	bl	34189b5c <HAL_LTDC_ConfigLayer>
34182582:	4603      	mov	r3, r0
34182584:	2b00      	cmp	r3, #0
34182586:	d001      	beq.n	3418258c <MX_LTDC_Init_CubeMX+0xfc>
  {
    Error_Handler();
34182588:	f000 fc08 	bl	34182d9c <Error_Handler>
  }
  pLayerCfg1.WindowX0 = 0;
3418258c:	2300      	movs	r3, #0
3418258e:	60bb      	str	r3, [r7, #8]
  pLayerCfg1.WindowX1 = 50;
34182590:	2332      	movs	r3, #50	@ 0x32
34182592:	60fb      	str	r3, [r7, #12]
  pLayerCfg1.WindowY0 = 0;
34182594:	2300      	movs	r3, #0
34182596:	613b      	str	r3, [r7, #16]
  pLayerCfg1.WindowY1 = 200;
34182598:	23c8      	movs	r3, #200	@ 0xc8
3418259a:	617b      	str	r3, [r7, #20]
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
3418259c:	2308      	movs	r3, #8
3418259e:	61bb      	str	r3, [r7, #24]
  pLayerCfg1.Alpha = 255;
341825a0:	23ff      	movs	r3, #255	@ 0xff
341825a2:	61fb      	str	r3, [r7, #28]
  pLayerCfg1.Alpha0 = 0;
341825a4:	2300      	movs	r3, #0
341825a6:	623b      	str	r3, [r7, #32]
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
341825a8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341825ac:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
341825ae:	2305      	movs	r3, #5
341825b0:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg1.FBStartAdress = 0;
341825b2:	2300      	movs	r3, #0
341825b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg1.ImageWidth = 50;
341825b6:	2332      	movs	r3, #50	@ 0x32
341825b8:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg1.ImageHeight = 200;
341825ba:	23c8      	movs	r3, #200	@ 0xc8
341825bc:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg1.Backcolor.Blue = 0;
341825be:	2300      	movs	r3, #0
341825c0:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  pLayerCfg1.Backcolor.Green = 255;
341825c4:	23ff      	movs	r3, #255	@ 0xff
341825c6:	f887 3039 	strb.w	r3, [r7, #57]	@ 0x39
  pLayerCfg1.Backcolor.Red = 0;
341825ca:	2300      	movs	r3, #0
341825cc:	f887 303a 	strb.w	r3, [r7, #58]	@ 0x3a
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
341825d0:	f107 0308 	add.w	r3, r7, #8
341825d4:	2201      	movs	r2, #1
341825d6:	4619      	mov	r1, r3
341825d8:	480e      	ldr	r0, [pc, #56]	@ (34182614 <MX_LTDC_Init_CubeMX+0x184>)
341825da:	f007 fabf 	bl	34189b5c <HAL_LTDC_ConfigLayer>
341825de:	4603      	mov	r3, r0
341825e0:	2b00      	cmp	r3, #0
341825e2:	d001      	beq.n	341825e8 <MX_LTDC_Init_CubeMX+0x158>
  {
    Error_Handler();
341825e4:	f000 fbda 	bl	34182d9c <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */
  RIMC_MasterConfig_t RIMC_master = {0};
341825e8:	463b      	mov	r3, r7
341825ea:	2200      	movs	r2, #0
341825ec:	601a      	str	r2, [r3, #0]
341825ee:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
341825f0:	2302      	movs	r3, #2
341825f2:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
341825f4:	2303      	movs	r3, #3
341825f6:	607b      	str	r3, [r7, #4]
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
341825f8:	463b      	mov	r3, r7
341825fa:	4619      	mov	r1, r3
341825fc:	200a      	movs	r0, #10
341825fe:	f012 fc9b 	bl	34194f38 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182602:	2103      	movs	r1, #3
34182604:	4805      	ldr	r0, [pc, #20]	@ (3418261c <MX_LTDC_Init_CubeMX+0x18c>)
34182606:	f012 fcd3 	bl	34194fb0 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  /* USER CODE END LTDC_Init 2 */

}
3418260a:	bf00      	nop
3418260c:	3770      	adds	r7, #112	@ 0x70
3418260e:	46bd      	mov	sp, r7
34182610:	bd80      	pop	{r7, pc}
34182612:	bf00      	nop
34182614:	341c04fc 	.word	0x341c04fc
34182618:	58001000 	.word	0x58001000
3418261c:	30000007 	.word	0x30000007

34182620 <HAL_LTDC_MspInit>:
  MX_LTDC_Init_CubeMX();
  return HAL_OK;
}

void HAL_LTDC_MspInit(LTDC_HandleTypeDef* ltdcHandle)
{
34182620:	b580      	push	{r7, lr}
34182622:	b0ec      	sub	sp, #432	@ 0x1b0
34182624:	af00      	add	r7, sp, #0
34182626:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418262a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3418262e:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34182630:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182634:	2200      	movs	r2, #0
34182636:	601a      	str	r2, [r3, #0]
34182638:	605a      	str	r2, [r3, #4]
3418263a:	609a      	str	r2, [r3, #8]
3418263c:	60da      	str	r2, [r3, #12]
3418263e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34182640:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182644:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182648:	4618      	mov	r0, r3
3418264a:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3418264e:	461a      	mov	r2, r3
34182650:	2100      	movs	r1, #0
34182652:	f021 fba7 	bl	341a3da4 <memset>
  if(ltdcHandle->Instance==LTDC)
34182656:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418265a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3418265e:	681b      	ldr	r3, [r3, #0]
34182660:	681b      	ldr	r3, [r3, #0]
34182662:	4a7c      	ldr	r2, [pc, #496]	@ (34182854 <HAL_LTDC_MspInit+0x234>)
34182664:	4293      	cmp	r3, r2
34182666:	f040 80f0 	bne.w	3418284a <HAL_LTDC_MspInit+0x22a>

  /* USER CODE END LTDC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
3418266a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418266e:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34182672:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34182676:	f04f 0300 	mov.w	r3, #0
3418267a:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
3418267e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182682:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182686:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
3418268a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL4;
3418268e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182692:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182696:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
3418269a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
3418269e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826a2:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341826a6:	2202      	movs	r2, #2
341826a8:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
341826ac:	f107 0308 	add.w	r3, r7, #8
341826b0:	4618      	mov	r0, r3
341826b2:	f00b ff95 	bl	3418e5e0 <HAL_RCCEx_PeriphCLKConfig>
341826b6:	4603      	mov	r3, r0
341826b8:	2b00      	cmp	r3, #0
341826ba:	d001      	beq.n	341826c0 <HAL_LTDC_MspInit+0xa0>
    {
      Error_Handler();
341826bc:	f000 fb6e 	bl	34182d9c <Error_Handler>
    }

    /* LTDC clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
341826c0:	2002      	movs	r0, #2
341826c2:	f7ff fecf 	bl	34182464 <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_GPIOC_CLK_ENABLE();
341826c6:	2004      	movs	r0, #4
341826c8:	f7ff feb6 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
341826cc:	2080      	movs	r0, #128	@ 0x80
341826ce:	f7ff feb3 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
341826d2:	2002      	movs	r0, #2
341826d4:	f7ff feb0 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
341826d8:	2008      	movs	r0, #8
341826da:	f7ff fead 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
341826de:	2010      	movs	r0, #16
341826e0:	f7ff feaa 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
341826e4:	2040      	movs	r0, #64	@ 0x40
341826e6:	f7ff fea7 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
341826ea:	2001      	movs	r0, #1
341826ec:	f7ff fea4 	bl	34182438 <LL_AHB4_GRP1_EnableClock>
    PB4(NJTRST)     ------> LTDC_R3
    PG8     ------> LTDC_G7
    PA8     ------> LTDC_B6
    PA0     ------> LTDC_G3
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_0;
341826f0:	2311      	movs	r3, #17
341826f2:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341826f6:	2302      	movs	r3, #2
341826f8:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341826fc:	2300      	movs	r3, #0
341826fe:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182702:	2300      	movs	r3, #0
34182704:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34182708:	230e      	movs	r3, #14
3418270a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
3418270e:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182712:	4619      	mov	r1, r3
34182714:	4850      	ldr	r0, [pc, #320]	@ (34182858 <HAL_LTDC_MspInit+0x238>)
34182716:	f005 ffb9 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_6;
3418271a:	2348      	movs	r3, #72	@ 0x48
3418271c:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34182720:	2302      	movs	r3, #2
34182722:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182726:	2300      	movs	r3, #0
34182728:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
3418272c:	2300      	movs	r3, #0
3418272e:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34182732:	230e      	movs	r3, #14
34182734:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
34182738:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3418273c:	4619      	mov	r1, r3
3418273e:	4847      	ldr	r0, [pc, #284]	@ (3418285c <HAL_LTDC_MspInit+0x23c>)
34182740:	f005 ffa4 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_15|GPIO_PIN_11
34182744:	f64f 0310 	movw	r3, #63504	@ 0xf810
34182748:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_12|GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418274c:	2302      	movs	r3, #2
3418274e:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182752:	2300      	movs	r3, #0
34182754:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182758:	2300      	movs	r3, #0
3418275a:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3418275e:	230e      	movs	r3, #14
34182760:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
34182764:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182768:	4619      	mov	r1, r3
3418276a:	483d      	ldr	r0, [pc, #244]	@ (34182860 <HAL_LTDC_MspInit+0x240>)
3418276c:	f005 ff8e 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_8;
34182770:	f44f 5304 	mov.w	r3, #8448	@ 0x2100
34182774:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34182778:	2302      	movs	r3, #2
3418277a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418277e:	2300      	movs	r3, #0
34182780:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182784:	2300      	movs	r3, #0
34182786:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3418278a:	230e      	movs	r3, #14
3418278c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
34182790:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182794:	4619      	mov	r1, r3
34182796:	4833      	ldr	r0, [pc, #204]	@ (34182864 <HAL_LTDC_MspInit+0x244>)
34182798:	f005 ff78 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
3418279c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341827a0:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827a4:	2302      	movs	r3, #2
341827a6:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341827aa:	2300      	movs	r3, #0
341827ac:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341827b0:	2300      	movs	r3, #0
341827b2:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
341827b6:	230e      	movs	r3, #14
341827b8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
341827bc:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341827c0:	4619      	mov	r1, r3
341827c2:	4829      	ldr	r0, [pc, #164]	@ (34182868 <HAL_LTDC_MspInit+0x248>)
341827c4:	f005 ff62 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_8;
341827c8:	f44f 73a0 	mov.w	r3, #320	@ 0x140
341827cc:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827d0:	2302      	movs	r3, #2
341827d2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341827d6:	2300      	movs	r3, #0
341827d8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341827dc:	2300      	movs	r3, #0
341827de:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
341827e2:	230e      	movs	r3, #14
341827e4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
341827e8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341827ec:	4619      	mov	r1, r3
341827ee:	481f      	ldr	r0, [pc, #124]	@ (3418286c <HAL_LTDC_MspInit+0x24c>)
341827f0:	f005 ff4c 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
341827f4:	2340      	movs	r3, #64	@ 0x40
341827f6:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827fa:	2302      	movs	r3, #2
341827fc:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182800:	2300      	movs	r3, #0
34182802:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182806:	2300      	movs	r3, #0
34182808:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF12_LCD;
3418280c:	230c      	movs	r3, #12
3418280e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34182812:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182816:	4619      	mov	r1, r3
34182818:	4815      	ldr	r0, [pc, #84]	@ (34182870 <HAL_LTDC_MspInit+0x250>)
3418281a:	f005 ff37 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_0;
3418281e:	f248 1303 	movw	r3, #33027	@ 0x8103
34182822:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34182826:	2302      	movs	r3, #2
34182828:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418282c:	2300      	movs	r3, #0
3418282e:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182832:	2300      	movs	r3, #0
34182834:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34182838:	230e      	movs	r3, #14
3418283a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
3418283e:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182842:	4619      	mov	r1, r3
34182844:	480a      	ldr	r0, [pc, #40]	@ (34182870 <HAL_LTDC_MspInit+0x250>)
34182846:	f005 ff21 	bl	3418868c <HAL_GPIO_Init>

  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }
}
3418284a:	bf00      	nop
3418284c:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34182850:	46bd      	mov	sp, r7
34182852:	bd80      	pop	{r7, pc}
34182854:	58001000 	.word	0x58001000
34182858:	56020800 	.word	0x56020800
3418285c:	56021c00 	.word	0x56021c00
34182860:	56020400 	.word	0x56020400
34182864:	56020c00 	.word	0x56020c00
34182868:	56021000 	.word	0x56021000
3418286c:	56021800 	.word	0x56021800
34182870:	56020000 	.word	0x56020000

34182874 <LL_AHB3_GRP1_EnableClock>:
{
34182874:	b480      	push	{r7}
34182876:	b085      	sub	sp, #20
34182878:	af00      	add	r7, sp, #0
3418287a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3ENSR, Periphs);
3418287c:	4a07      	ldr	r2, [pc, #28]	@ (3418289c <LL_AHB3_GRP1_EnableClock+0x28>)
3418287e:	687b      	ldr	r3, [r7, #4]
34182880:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34182884:	4b05      	ldr	r3, [pc, #20]	@ (3418289c <LL_AHB3_GRP1_EnableClock+0x28>)
34182886:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
3418288a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418288c:	68fb      	ldr	r3, [r7, #12]
}
3418288e:	bf00      	nop
34182890:	3714      	adds	r7, #20
34182892:	46bd      	mov	sp, r7
34182894:	f85d 7b04 	ldr.w	r7, [sp], #4
34182898:	4770      	bx	lr
3418289a:	bf00      	nop
3418289c:	56028000 	.word	0x56028000

341828a0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
341828a0:	b580      	push	{r7, lr}
341828a2:	b08a      	sub	sp, #40	@ 0x28
341828a4:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
341828a6:	4b56      	ldr	r3, [pc, #344]	@ (34182a00 <main+0x160>)
341828a8:	695b      	ldr	r3, [r3, #20]
341828aa:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
341828ae:	2b00      	cmp	r3, #0
341828b0:	d11b      	bne.n	341828ea <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
341828b2:	f3bf 8f4f 	dsb	sy
}
341828b6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341828b8:	f3bf 8f6f 	isb	sy
}
341828bc:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
341828be:	4b50      	ldr	r3, [pc, #320]	@ (34182a00 <main+0x160>)
341828c0:	2200      	movs	r2, #0
341828c2:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
341828c6:	f3bf 8f4f 	dsb	sy
}
341828ca:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341828cc:	f3bf 8f6f 	isb	sy
}
341828d0:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
341828d2:	4b4b      	ldr	r3, [pc, #300]	@ (34182a00 <main+0x160>)
341828d4:	695b      	ldr	r3, [r3, #20]
341828d6:	4a4a      	ldr	r2, [pc, #296]	@ (34182a00 <main+0x160>)
341828d8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
341828dc:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
341828de:	f3bf 8f4f 	dsb	sy
}
341828e2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341828e4:	f3bf 8f6f 	isb	sy
}
341828e8:	e000      	b.n	341828ec <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
341828ea:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
341828ec:	4b44      	ldr	r3, [pc, #272]	@ (34182a00 <main+0x160>)
341828ee:	695b      	ldr	r3, [r3, #20]
341828f0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
341828f4:	2b00      	cmp	r3, #0
341828f6:	d138      	bne.n	3418296a <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
341828f8:	4b41      	ldr	r3, [pc, #260]	@ (34182a00 <main+0x160>)
341828fa:	2200      	movs	r2, #0
341828fc:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34182900:	f3bf 8f4f 	dsb	sy
}
34182904:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
34182906:	4b3e      	ldr	r3, [pc, #248]	@ (34182a00 <main+0x160>)
34182908:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418290c:	627b      	str	r3, [r7, #36]	@ 0x24

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
3418290e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34182910:	0b5b      	lsrs	r3, r3, #13
34182912:	f3c3 030e 	ubfx	r3, r3, #0, #15
34182916:	623b      	str	r3, [r7, #32]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34182918:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418291a:	08db      	lsrs	r3, r3, #3
3418291c:	f3c3 0309 	ubfx	r3, r3, #0, #10
34182920:	61fb      	str	r3, [r7, #28]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34182922:	6a3b      	ldr	r3, [r7, #32]
34182924:	015a      	lsls	r2, r3, #5
34182926:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
3418292a:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
3418292c:	69fa      	ldr	r2, [r7, #28]
3418292e:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34182930:	4933      	ldr	r1, [pc, #204]	@ (34182a00 <main+0x160>)
34182932:	4313      	orrs	r3, r2
34182934:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
34182938:	69fb      	ldr	r3, [r7, #28]
3418293a:	1e5a      	subs	r2, r3, #1
3418293c:	61fa      	str	r2, [r7, #28]
3418293e:	2b00      	cmp	r3, #0
34182940:	d1ef      	bne.n	34182922 <main+0x82>
    } while(sets-- != 0U);
34182942:	6a3b      	ldr	r3, [r7, #32]
34182944:	1e5a      	subs	r2, r3, #1
34182946:	623a      	str	r2, [r7, #32]
34182948:	2b00      	cmp	r3, #0
3418294a:	d1e5      	bne.n	34182918 <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
3418294c:	f3bf 8f4f 	dsb	sy
}
34182950:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
34182952:	4b2b      	ldr	r3, [pc, #172]	@ (34182a00 <main+0x160>)
34182954:	695b      	ldr	r3, [r3, #20]
34182956:	4a2a      	ldr	r2, [pc, #168]	@ (34182a00 <main+0x160>)
34182958:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418295c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
3418295e:	f3bf 8f4f 	dsb	sy
}
34182962:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34182964:	f3bf 8f6f 	isb	sy
}
34182968:	e000      	b.n	3418296c <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
3418296a:	bf00      	nop

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
3418296c:	f002 fc92 	bl	34185294 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
34182970:	f000 f850 	bl	34182a14 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34182974:	f7ff fbce 	bl	34182114 <MX_GPIO_Init>
  MX_BSEC_Init();
34182978:	f7ff f9b4 	bl	34181ce4 <MX_BSEC_Init>
  MX_CACHEAXI_Init();
3418297c:	f7ff f9d0 	bl	34181d20 <MX_CACHEAXI_Init>
  MX_DCMIPP_Init();
34182980:	f7ff fa30 	bl	34181de4 <MX_DCMIPP_Init>
//  MX_I2C1_Init_CubeMX();
  MX_LTDC_Init_CubeMX();
34182984:	f7ff fd84 	bl	34182490 <MX_LTDC_Init_CubeMX>
  MX_XSPI1_Init();
34182988:	f000 fb64 	bl	34183054 <MX_XSPI1_Init>
  MX_XSPI2_Init();
3418298c:	f000 fbbe 	bl	3418310c <MX_XSPI2_Init>
  SystemIsolation_Config();
34182990:	f000 f91c 	bl	34182bcc <SystemIsolation_Config>
  MX_EXTMEM_MANAGER_Init();
34182994:	f7ff fb3a 	bl	3418200c <MX_EXTMEM_MANAGER_Init>
  /* USER CODE BEGIN 2 */

  BSP_XSPI_RAM_Init(0);
34182998:	2000      	movs	r0, #0
3418299a:	f001 fe8d 	bl	341846b8 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
3418299e:	2000      	movs	r0, #0
341829a0:	f001 ff58 	bl	34184854 <BSP_XSPI_RAM_EnableMemoryMappedMode>

  BSP_XSPI_NOR_Init_t NOR_Init;
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
341829a4:	2301      	movs	r3, #1
341829a6:	763b      	strb	r3, [r7, #24]
  NOR_Init.TransferRate = BSP_XSPI_NOR_DTR_TRANSFER;
341829a8:	2301      	movs	r3, #1
341829aa:	767b      	strb	r3, [r7, #25]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
341829ac:	f107 0318 	add.w	r3, r7, #24
341829b0:	4619      	mov	r1, r3
341829b2:	2000      	movs	r0, #0
341829b4:	f001 fc9e 	bl	341842f4 <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
341829b8:	2000      	movs	r0, #0
341829ba:	f001 fd85 	bl	341844c8 <BSP_XSPI_NOR_EnableMemoryMappedMode>
	    done = 1U;
	  }
  }
*/

  uint32_t pitch_nn = 0;
341829be:	2300      	movs	r3, #0
341829c0:	617b      	str	r3, [r7, #20]
  /*** Camera Init ************************************************************/
  CameraPipeline_Init((uint32_t *[2]) {&lcd_bg_area.XSize, &lcd_fg_area.XSize}, (uint32_t *[2]) {&lcd_bg_area.YSize, &lcd_fg_area.YSize}, &pitch_nn);
341829c2:	4a10      	ldr	r2, [pc, #64]	@ (34182a04 <main+0x164>)
341829c4:	f107 030c 	add.w	r3, r7, #12
341829c8:	e892 0003 	ldmia.w	r2, {r0, r1}
341829cc:	e883 0003 	stmia.w	r3, {r0, r1}
341829d0:	4a0d      	ldr	r2, [pc, #52]	@ (34182a08 <main+0x168>)
341829d2:	1d3b      	adds	r3, r7, #4
341829d4:	e892 0003 	ldmia.w	r2, {r0, r1}
341829d8:	e883 0003 	stmia.w	r3, {r0, r1}
341829dc:	f107 0214 	add.w	r2, r7, #20
341829e0:	1d39      	adds	r1, r7, #4
341829e2:	f107 030c 	add.w	r3, r7, #12
341829e6:	4618      	mov	r0, r3
341829e8:	f7ff f946 	bl	34181c78 <CameraPipeline_Init>

  /* Start LCD Display camera pipe stream */
  // CameraPipeline_DisplayPipe_Start(lcd_bg_buffer, CMW_MODE_CONTINUOUS);

  //LCD Test
  HAL_LTDC_SetAddress(&hltdc, (uint32_t) image, 0);
341829ec:	4b07      	ldr	r3, [pc, #28]	@ (34182a0c <main+0x16c>)
341829ee:	681b      	ldr	r3, [r3, #0]
341829f0:	2200      	movs	r2, #0
341829f2:	4619      	mov	r1, r3
341829f4:	4806      	ldr	r0, [pc, #24]	@ (34182a10 <main+0x170>)
341829f6:	f007 f915 	bl	34189c24 <HAL_LTDC_SetAddress>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
341829fa:	bf00      	nop
341829fc:	e7fd      	b.n	341829fa <main+0x15a>
341829fe:	bf00      	nop
34182a00:	e000ed00 	.word	0xe000ed00
34182a04:	341a5a54 	.word	0x341a5a54
34182a08:	341a5a5c 	.word	0x341a5a5c
34182a0c:	341c0020 	.word	0x341c0020
34182a10:	341c04fc 	.word	0x341c04fc

34182a14 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
34182a14:	b580      	push	{r7, lr}
34182a16:	b0b6      	sub	sp, #216	@ 0xd8
34182a18:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34182a1a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182a1e:	2298      	movs	r2, #152	@ 0x98
34182a20:	2100      	movs	r1, #0
34182a22:	4618      	mov	r0, r3
34182a24:	f021 f9be 	bl	341a3da4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34182a28:	463b      	mov	r3, r7
34182a2a:	2240      	movs	r2, #64	@ 0x40
34182a2c:	2100      	movs	r1, #0
34182a2e:	4618      	mov	r0, r3
34182a30:	f021 f9b8 	bl	341a3da4 <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY) != HAL_OK)
34182a34:	2000      	movs	r0, #0
34182a36:	f008 fd0d 	bl	3418b454 <HAL_PWREx_ConfigSupply>
34182a3a:	4603      	mov	r3, r0
34182a3c:	2b00      	cmp	r3, #0
34182a3e:	d001      	beq.n	34182a44 <SystemClock_Config+0x30>
  {
    Error_Handler();
34182a40:	f000 f9ac 	bl	34182d9c <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
34182a44:	2302      	movs	r3, #2
34182a46:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
34182a48:	2308      	movs	r3, #8
34182a4a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
34182a4c:	2300      	movs	r3, #0
34182a4e:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
34182a50:	2300      	movs	r3, #0
34182a52:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
34182a54:	2300      	movs	r3, #0
34182a56:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34182a58:	2300      	movs	r3, #0
34182a5a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34182a5e:	2300      	movs	r3, #0
34182a60:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
34182a64:	2300      	movs	r3, #0
34182a66:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34182a6a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182a6e:	4618      	mov	r0, r3
34182a70:	f009 f832 	bl	3418bad8 <HAL_RCC_OscConfig>
34182a74:	4603      	mov	r3, r0
34182a76:	2b00      	cmp	r3, #0
34182a78:	d001      	beq.n	34182a7e <SystemClock_Config+0x6a>
  {
    Error_Handler();
34182a7a:	f000 f98f 	bl	34182d9c <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
34182a7e:	463b      	mov	r3, r7
34182a80:	4618      	mov	r0, r3
34182a82:	f009 feb1 	bl	3418c7e8 <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34182a86:	687b      	ldr	r3, [r7, #4]
34182a88:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34182a8c:	d003      	beq.n	34182a96 <SystemClock_Config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
34182a8e:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34182a90:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34182a94:	d10e      	bne.n	34182ab4 <SystemClock_Config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
34182a96:	2303      	movs	r3, #3
34182a98:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
34182a9a:	2300      	movs	r3, #0
34182a9c:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
34182a9e:	2300      	movs	r3, #0
34182aa0:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34182aa2:	463b      	mov	r3, r7
34182aa4:	4618      	mov	r0, r3
34182aa6:	f009 fbf7 	bl	3418c298 <HAL_RCC_ClockConfig>
34182aaa:	4603      	mov	r3, r0
34182aac:	2b00      	cmp	r3, #0
34182aae:	d001      	beq.n	34182ab4 <SystemClock_Config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
34182ab0:	f000 f974 	bl	34182d9c <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34182ab4:	2300      	movs	r3, #0
34182ab6:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34182ab8:	2302      	movs	r3, #2
34182aba:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34182abc:	2300      	movs	r3, #0
34182abe:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 2;
34182ac0:	2302      	movs	r3, #2
34182ac2:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 25;
34182ac4:	2319      	movs	r3, #25
34182ac6:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34182ac8:	2300      	movs	r3, #0
34182aca:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34182acc:	2301      	movs	r3, #1
34182ace:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34182ad0:	2301      	movs	r3, #1
34182ad2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
34182ad6:	2302      	movs	r3, #2
34182ad8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34182adc:	2300      	movs	r3, #0
34182ade:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  RCC_OscInitStruct.PLL2.PLLM = 8;
34182ae2:	2308      	movs	r3, #8
34182ae4:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  RCC_OscInitStruct.PLL2.PLLN = 125;
34182ae8:	237d      	movs	r3, #125	@ 0x7d
34182aea:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34182aee:	2300      	movs	r3, #0
34182af0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34182af4:	2301      	movs	r3, #1
34182af6:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
  RCC_OscInitStruct.PLL2.PLLP2 = 1;
34182afa:	2301      	movs	r3, #1
34182afc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34182b00:	2302      	movs	r3, #2
34182b02:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
34182b06:	2300      	movs	r3, #0
34182b08:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLM = 8;
34182b0c:	2308      	movs	r3, #8
34182b0e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  RCC_OscInitStruct.PLL3.PLLN = 225;
34182b12:	23e1      	movs	r3, #225	@ 0xe1
34182b14:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34182b18:	2300      	movs	r3, #0
34182b1a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
34182b1e:	2301      	movs	r3, #1
34182b20:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34182b24:	2302      	movs	r3, #2
34182b26:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
34182b2a:	2302      	movs	r3, #2
34182b2c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34182b30:	2300      	movs	r3, #0
34182b32:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  RCC_OscInitStruct.PLL4.PLLM = 8;
34182b36:	2308      	movs	r3, #8
34182b38:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  RCC_OscInitStruct.PLL4.PLLN = 225;
34182b3c:	23e1      	movs	r3, #225	@ 0xe1
34182b3e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34182b42:	2300      	movs	r3, #0
34182b44:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
34182b48:	2306      	movs	r3, #6
34182b4a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34182b4e:	2306      	movs	r3, #6
34182b50:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34182b54:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182b58:	4618      	mov	r0, r3
34182b5a:	f008 ffbd 	bl	3418bad8 <HAL_RCC_OscConfig>
34182b5e:	4603      	mov	r3, r0
34182b60:	2b00      	cmp	r3, #0
34182b62:	d001      	beq.n	34182b68 <SystemClock_Config+0x154>
  {
    Error_Handler();
34182b64:	f000 f91a 	bl	34182d9c <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34182b68:	237f      	movs	r3, #127	@ 0x7f
34182b6a:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34182b6c:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34182b70:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34182b72:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34182b76:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34182b78:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34182b7c:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34182b7e:	2300      	movs	r3, #0
34182b80:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34182b82:	2300      	movs	r3, #0
34182b84:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34182b86:	2300      	movs	r3, #0
34182b88:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34182b8a:	2300      	movs	r3, #0
34182b8c:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34182b8e:	2300      	movs	r3, #0
34182b90:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34182b92:	2301      	movs	r3, #1
34182b94:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34182b96:	2300      	movs	r3, #0
34182b98:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34182b9a:	2302      	movs	r3, #2
34182b9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34182b9e:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34182ba2:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34182ba4:	2301      	movs	r3, #1
34182ba6:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34182ba8:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34182bac:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34182bae:	2301      	movs	r3, #1
34182bb0:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34182bb2:	463b      	mov	r3, r7
34182bb4:	4618      	mov	r0, r3
34182bb6:	f009 fb6f 	bl	3418c298 <HAL_RCC_ClockConfig>
34182bba:	4603      	mov	r3, r0
34182bbc:	2b00      	cmp	r3, #0
34182bbe:	d001      	beq.n	34182bc4 <SystemClock_Config+0x1b0>
  {
    Error_Handler();
34182bc0:	f000 f8ec 	bl	34182d9c <Error_Handler>
  }
}
34182bc4:	bf00      	nop
34182bc6:	37d8      	adds	r7, #216	@ 0xd8
34182bc8:	46bd      	mov	sp, r7
34182bca:	bd80      	pop	{r7, pc}

34182bcc <SystemIsolation_Config>:
  * @brief RIF Initialization Function
  * @param None
  * @retval None
  */
  static void SystemIsolation_Config(void)
{
34182bcc:	b580      	push	{r7, lr}
34182bce:	b082      	sub	sp, #8
34182bd0:	af00      	add	r7, sp, #0
/* USER CODE BEGIN RIF_Init 0 */

/* USER CODE END RIF_Init 0 */

  /* set all required IPs as secure privileged */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34182bd2:	f44f 7000 	mov.w	r0, #512	@ 0x200
34182bd6:	f7ff fe4d 	bl	34182874 <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34182bda:	463b      	mov	r3, r7
34182bdc:	2200      	movs	r2, #0
34182bde:	601a      	str	r2, [r3, #0]
34182be0:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34182be2:	2302      	movs	r3, #2
34182be4:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34182be6:	2303      	movs	r3, #3
34182be8:	607b      	str	r3, [r7, #4]

  /*RIMC configuration*/
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34182bea:	463b      	mov	r3, r7
34182bec:	4619      	mov	r1, r3
34182bee:	2009      	movs	r0, #9
34182bf0:	f012 f9a2 	bl	34194f38 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1, &RIMC_master);
34182bf4:	463b      	mov	r3, r7
34182bf6:	4619      	mov	r1, r3
34182bf8:	200a      	movs	r0, #10
34182bfa:	f012 f99d 	bl	34194f38 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2, &RIMC_master);
34182bfe:	463b      	mov	r3, r7
34182c00:	4619      	mov	r1, r3
34182c02:	200b      	movs	r0, #11
34182c04:	f012 f998 	bl	34194f38 <HAL_RIF_RIMC_ConfigMasterAttributes>

  /* RIF-Aware IPs Config */

  /* set up PWR configuration */
  HAL_PWR_ConfigAttributes(PWR_ITEM_WKUP1,PWR_SEC_NPRIV);
34182c08:	2120      	movs	r1, #32
34182c0a:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34182c0e:	f008 fbcd 	bl	3418b3ac <HAL_PWR_ConfigAttributes>

  /* set up GPIO configuration */
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c12:	f240 3201 	movw	r2, #769	@ 0x301
34182c16:	2101      	movs	r1, #1
34182c18:	4857      	ldr	r0, [pc, #348]	@ (34182d78 <SystemIsolation_Config+0x1ac>)
34182c1a:	f006 f841 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c1e:	f240 3201 	movw	r2, #769	@ 0x301
34182c22:	2102      	movs	r1, #2
34182c24:	4854      	ldr	r0, [pc, #336]	@ (34182d78 <SystemIsolation_Config+0x1ac>)
34182c26:	f006 f83b 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c2a:	f240 3201 	movw	r2, #769	@ 0x301
34182c2e:	2140      	movs	r1, #64	@ 0x40
34182c30:	4851      	ldr	r0, [pc, #324]	@ (34182d78 <SystemIsolation_Config+0x1ac>)
34182c32:	f006 f835 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c36:	f240 3201 	movw	r2, #769	@ 0x301
34182c3a:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182c3e:	484e      	ldr	r0, [pc, #312]	@ (34182d78 <SystemIsolation_Config+0x1ac>)
34182c40:	f006 f82e 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c44:	f240 3201 	movw	r2, #769	@ 0x301
34182c48:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34182c4c:	484b      	ldr	r0, [pc, #300]	@ (34182d7c <SystemIsolation_Config+0x1b0>)
34182c4e:	f006 f827 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_12,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c52:	f240 3201 	movw	r2, #769	@ 0x301
34182c56:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34182c5a:	4848      	ldr	r0, [pc, #288]	@ (34182d7c <SystemIsolation_Config+0x1b0>)
34182c5c:	f006 f820 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c60:	f240 3201 	movw	r2, #769	@ 0x301
34182c64:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34182c68:	4844      	ldr	r0, [pc, #272]	@ (34182d7c <SystemIsolation_Config+0x1b0>)
34182c6a:	f006 f819 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_14,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c6e:	f240 3201 	movw	r2, #769	@ 0x301
34182c72:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
34182c76:	4841      	ldr	r0, [pc, #260]	@ (34182d7c <SystemIsolation_Config+0x1b0>)
34182c78:	f006 f812 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_15,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c7c:	f240 3201 	movw	r2, #769	@ 0x301
34182c80:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34182c84:	483d      	ldr	r0, [pc, #244]	@ (34182d7c <SystemIsolation_Config+0x1b0>)
34182c86:	f006 f80b 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c8a:	f240 3201 	movw	r2, #769	@ 0x301
34182c8e:	2101      	movs	r1, #1
34182c90:	483b      	ldr	r0, [pc, #236]	@ (34182d80 <SystemIsolation_Config+0x1b4>)
34182c92:	f006 f805 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c96:	f240 3201 	movw	r2, #769	@ 0x301
34182c9a:	2102      	movs	r1, #2
34182c9c:	4838      	ldr	r0, [pc, #224]	@ (34182d80 <SystemIsolation_Config+0x1b4>)
34182c9e:	f005 ffff 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182ca2:	f240 3201 	movw	r2, #769	@ 0x301
34182ca6:	2110      	movs	r1, #16
34182ca8:	4835      	ldr	r0, [pc, #212]	@ (34182d80 <SystemIsolation_Config+0x1b4>)
34182caa:	f005 fff9 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cae:	f240 3201 	movw	r2, #769	@ 0x301
34182cb2:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182cb6:	4832      	ldr	r0, [pc, #200]	@ (34182d80 <SystemIsolation_Config+0x1b4>)
34182cb8:	f005 fff2 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cbc:	f240 3201 	movw	r2, #769	@ 0x301
34182cc0:	2104      	movs	r1, #4
34182cc2:	4830      	ldr	r0, [pc, #192]	@ (34182d84 <SystemIsolation_Config+0x1b8>)
34182cc4:	f005 ffec 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cc8:	f240 3201 	movw	r2, #769	@ 0x301
34182ccc:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182cd0:	482c      	ldr	r0, [pc, #176]	@ (34182d84 <SystemIsolation_Config+0x1b8>)
34182cd2:	f005 ffe5 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cd6:	f240 3201 	movw	r2, #769	@ 0x301
34182cda:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34182cde:	4829      	ldr	r0, [pc, #164]	@ (34182d84 <SystemIsolation_Config+0x1b8>)
34182ce0:	f005 ffde 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182ce4:	f240 3201 	movw	r2, #769	@ 0x301
34182ce8:	2102      	movs	r1, #2
34182cea:	4827      	ldr	r0, [pc, #156]	@ (34182d88 <SystemIsolation_Config+0x1bc>)
34182cec:	f005 ffd8 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cf0:	f240 3201 	movw	r2, #769	@ 0x301
34182cf4:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34182cf8:	4823      	ldr	r0, [pc, #140]	@ (34182d88 <SystemIsolation_Config+0x1bc>)
34182cfa:	f005 ffd1 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cfe:	f240 3201 	movw	r2, #769	@ 0x301
34182d02:	2140      	movs	r1, #64	@ 0x40
34182d04:	4821      	ldr	r0, [pc, #132]	@ (34182d8c <SystemIsolation_Config+0x1c0>)
34182d06:	f005 ffcb 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d0a:	f240 3201 	movw	r2, #769	@ 0x301
34182d0e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182d12:	481e      	ldr	r0, [pc, #120]	@ (34182d8c <SystemIsolation_Config+0x1c0>)
34182d14:	f005 ffc4 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d18:	f240 3201 	movw	r2, #769	@ 0x301
34182d1c:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34182d20:	481a      	ldr	r0, [pc, #104]	@ (34182d8c <SystemIsolation_Config+0x1c0>)
34182d22:	f005 ffbd 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d26:	f240 3201 	movw	r2, #769	@ 0x301
34182d2a:	2108      	movs	r1, #8
34182d2c:	4818      	ldr	r0, [pc, #96]	@ (34182d90 <SystemIsolation_Config+0x1c4>)
34182d2e:	f005 ffb7 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d32:	f240 3201 	movw	r2, #769	@ 0x301
34182d36:	2140      	movs	r1, #64	@ 0x40
34182d38:	4815      	ldr	r0, [pc, #84]	@ (34182d90 <SystemIsolation_Config+0x1c4>)
34182d3a:	f005 ffb1 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d3e:	f240 3201 	movw	r2, #769	@ 0x301
34182d42:	f44f 7100 	mov.w	r1, #512	@ 0x200
34182d46:	4812      	ldr	r0, [pc, #72]	@ (34182d90 <SystemIsolation_Config+0x1c4>)
34182d48:	f005 ffaa 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d4c:	f240 3201 	movw	r2, #769	@ 0x301
34182d50:	2102      	movs	r1, #2
34182d52:	4810      	ldr	r0, [pc, #64]	@ (34182d94 <SystemIsolation_Config+0x1c8>)
34182d54:	f005 ffa4 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOQ,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d58:	f240 3201 	movw	r2, #769	@ 0x301
34182d5c:	2108      	movs	r1, #8
34182d5e:	480e      	ldr	r0, [pc, #56]	@ (34182d98 <SystemIsolation_Config+0x1cc>)
34182d60:	f005 ff9e 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOQ,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d64:	f240 3201 	movw	r2, #769	@ 0x301
34182d68:	2140      	movs	r1, #64	@ 0x40
34182d6a:	480b      	ldr	r0, [pc, #44]	@ (34182d98 <SystemIsolation_Config+0x1cc>)
34182d6c:	f005 ff98 	bl	34188ca0 <HAL_GPIO_ConfigPinAttributes>
/* USER CODE END RIF_Init 1 */
/* USER CODE BEGIN RIF_Init 2 */

/* USER CODE END RIF_Init 2 */

}
34182d70:	bf00      	nop
34182d72:	3708      	adds	r7, #8
34182d74:	46bd      	mov	sp, r7
34182d76:	bd80      	pop	{r7, pc}
34182d78:	56020000 	.word	0x56020000
34182d7c:	56020400 	.word	0x56020400
34182d80:	56020800 	.word	0x56020800
34182d84:	56020c00 	.word	0x56020c00
34182d88:	56021000 	.word	0x56021000
34182d8c:	56021800 	.word	0x56021800
34182d90:	56021c00 	.word	0x56021c00
34182d94:	56023800 	.word	0x56023800
34182d98:	56024000 	.word	0x56024000

34182d9c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34182d9c:	b480      	push	{r7}
34182d9e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34182da0:	b672      	cpsid	i
}
34182da2:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34182da4:	bf00      	nop
34182da6:	e7fd      	b.n	34182da4 <Error_Handler+0x8>

34182da8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34182da8:	b580      	push	{r7, lr}
34182daa:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34182dac:	f008 fbcc 	bl	3418b548 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2,PWR_VDDIO_RANGE_3V3);
34182db0:	2100      	movs	r1, #0
34182db2:	2001      	movs	r0, #1
34182db4:	f008 fb76 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO3();
34182db8:	f008 fbd6 	bl	3418b568 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3,PWR_VDDIO_RANGE_1V8);
34182dbc:	2101      	movs	r1, #1
34182dbe:	2002      	movs	r0, #2
34182dc0:	f008 fb70 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO4();
34182dc4:	f008 fbe0 	bl	3418b588 <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);
34182dc8:	2100      	movs	r1, #0
34182dca:	2003      	movs	r0, #3
34182dcc:	f008 fb6a 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO5();
34182dd0:	f008 fbea 	bl	3418b5a8 <HAL_PWREx_EnableVddIO5>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO5,PWR_VDDIO_RANGE_3V3);
34182dd4:	2100      	movs	r1, #0
34182dd6:	2004      	movs	r0, #4
34182dd8:	f008 fb64 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34182ddc:	bf00      	nop
34182dde:	bd80      	pop	{r7, pc}

34182de0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34182de0:	b480      	push	{r7}
34182de2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34182de4:	bf00      	nop
34182de6:	e7fd      	b.n	34182de4 <NMI_Handler+0x4>

34182de8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34182de8:	b480      	push	{r7}
34182dea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34182dec:	bf00      	nop
34182dee:	e7fd      	b.n	34182dec <HardFault_Handler+0x4>

34182df0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34182df0:	b480      	push	{r7}
34182df2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34182df4:	bf00      	nop
34182df6:	e7fd      	b.n	34182df4 <MemManage_Handler+0x4>

34182df8 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34182df8:	b480      	push	{r7}
34182dfa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34182dfc:	bf00      	nop
34182dfe:	e7fd      	b.n	34182dfc <BusFault_Handler+0x4>

34182e00 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34182e00:	b480      	push	{r7}
34182e02:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34182e04:	bf00      	nop
34182e06:	e7fd      	b.n	34182e04 <UsageFault_Handler+0x4>

34182e08 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34182e08:	b480      	push	{r7}
34182e0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34182e0c:	bf00      	nop
34182e0e:	e7fd      	b.n	34182e0c <SecureFault_Handler+0x4>

34182e10 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34182e10:	b480      	push	{r7}
34182e12:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34182e14:	bf00      	nop
34182e16:	46bd      	mov	sp, r7
34182e18:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e1c:	4770      	bx	lr

34182e1e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34182e1e:	b480      	push	{r7}
34182e20:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34182e22:	bf00      	nop
34182e24:	46bd      	mov	sp, r7
34182e26:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e2a:	4770      	bx	lr

34182e2c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
34182e2c:	b480      	push	{r7}
34182e2e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
34182e30:	bf00      	nop
34182e32:	46bd      	mov	sp, r7
34182e34:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e38:	4770      	bx	lr

34182e3a <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
34182e3a:	b580      	push	{r7, lr}
34182e3c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
34182e3e:	f002 fa73 	bl	34185328 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34182e42:	bf00      	nop
34182e44:	bd80      	pop	{r7, pc}
	...

34182e48 <DCMIPP_IRQHandler>:

/**
  * @brief This function handles DCMIPP global interrupt.
  */
void DCMIPP_IRQHandler(void)
{
34182e48:	b580      	push	{r7, lr}
34182e4a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DCMIPP_IRQn 0 */

  /* USER CODE END DCMIPP_IRQn 0 */
  HAL_DCMIPP_IRQHandler(&hdcmipp);
34182e4c:	4802      	ldr	r0, [pc, #8]	@ (34182e58 <DCMIPP_IRQHandler+0x10>)
34182e4e:	f002 fedd 	bl	34185c0c <HAL_DCMIPP_IRQHandler>
  /* USER CODE BEGIN DCMIPP_IRQn 1 */

  /* USER CODE END DCMIPP_IRQn 1 */
}
34182e52:	bf00      	nop
34182e54:	bd80      	pop	{r7, pc}
34182e56:	bf00      	nop
34182e58:	341c04f0 	.word	0x341c04f0

34182e5c <CSI_IRQHandler>:

/**
  * @brief This function handles CSI global interrupt.
  */
void CSI_IRQHandler(void)
{
34182e5c:	b580      	push	{r7, lr}
34182e5e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN CSI_IRQn 0 */

  /* USER CODE END CSI_IRQn 0 */
  HAL_DCMIPP_CSI_IRQHandler(&hdcmipp);
34182e60:	4802      	ldr	r0, [pc, #8]	@ (34182e6c <CSI_IRQHandler+0x10>)
34182e62:	f003 f8b7 	bl	34185fd4 <HAL_DCMIPP_CSI_IRQHandler>
  /* USER CODE BEGIN CSI_IRQn 1 */

  /* USER CODE END CSI_IRQn 1 */
}
34182e66:	bf00      	nop
34182e68:	bd80      	pop	{r7, pc}
34182e6a:	bf00      	nop
34182e6c:	341c04f0 	.word	0x341c04f0

34182e70 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
34182e70:	b480      	push	{r7}
34182e72:	af00      	add	r7, sp, #0
  return 1;
34182e74:	2301      	movs	r3, #1
}
34182e76:	4618      	mov	r0, r3
34182e78:	46bd      	mov	sp, r7
34182e7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182e7e:	4770      	bx	lr

34182e80 <_kill>:

int _kill(int pid, int sig)
{
34182e80:	b580      	push	{r7, lr}
34182e82:	b082      	sub	sp, #8
34182e84:	af00      	add	r7, sp, #0
34182e86:	6078      	str	r0, [r7, #4]
34182e88:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
34182e8a:	f020 ffd9 	bl	341a3e40 <__errno>
34182e8e:	4603      	mov	r3, r0
34182e90:	2216      	movs	r2, #22
34182e92:	601a      	str	r2, [r3, #0]
  return -1;
34182e94:	f04f 33ff 	mov.w	r3, #4294967295
}
34182e98:	4618      	mov	r0, r3
34182e9a:	3708      	adds	r7, #8
34182e9c:	46bd      	mov	sp, r7
34182e9e:	bd80      	pop	{r7, pc}

34182ea0 <_exit>:

void _exit (int status)
{
34182ea0:	b580      	push	{r7, lr}
34182ea2:	b082      	sub	sp, #8
34182ea4:	af00      	add	r7, sp, #0
34182ea6:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
34182ea8:	f04f 31ff 	mov.w	r1, #4294967295
34182eac:	6878      	ldr	r0, [r7, #4]
34182eae:	f7ff ffe7 	bl	34182e80 <_kill>
  while (1) {}    /* Make sure we hang here */
34182eb2:	bf00      	nop
34182eb4:	e7fd      	b.n	34182eb2 <_exit+0x12>

34182eb6 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
34182eb6:	b580      	push	{r7, lr}
34182eb8:	b086      	sub	sp, #24
34182eba:	af00      	add	r7, sp, #0
34182ebc:	60f8      	str	r0, [r7, #12]
34182ebe:	60b9      	str	r1, [r7, #8]
34182ec0:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34182ec2:	2300      	movs	r3, #0
34182ec4:	617b      	str	r3, [r7, #20]
34182ec6:	e00a      	b.n	34182ede <_read+0x28>
  {
    *ptr++ = __io_getchar();
34182ec8:	f3af 8000 	nop.w
34182ecc:	4601      	mov	r1, r0
34182ece:	68bb      	ldr	r3, [r7, #8]
34182ed0:	1c5a      	adds	r2, r3, #1
34182ed2:	60ba      	str	r2, [r7, #8]
34182ed4:	b2ca      	uxtb	r2, r1
34182ed6:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34182ed8:	697b      	ldr	r3, [r7, #20]
34182eda:	3301      	adds	r3, #1
34182edc:	617b      	str	r3, [r7, #20]
34182ede:	697a      	ldr	r2, [r7, #20]
34182ee0:	687b      	ldr	r3, [r7, #4]
34182ee2:	429a      	cmp	r2, r3
34182ee4:	dbf0      	blt.n	34182ec8 <_read+0x12>
  }

  return len;
34182ee6:	687b      	ldr	r3, [r7, #4]
}
34182ee8:	4618      	mov	r0, r3
34182eea:	3718      	adds	r7, #24
34182eec:	46bd      	mov	sp, r7
34182eee:	bd80      	pop	{r7, pc}

34182ef0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34182ef0:	b580      	push	{r7, lr}
34182ef2:	b086      	sub	sp, #24
34182ef4:	af00      	add	r7, sp, #0
34182ef6:	60f8      	str	r0, [r7, #12]
34182ef8:	60b9      	str	r1, [r7, #8]
34182efa:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34182efc:	2300      	movs	r3, #0
34182efe:	617b      	str	r3, [r7, #20]
34182f00:	e009      	b.n	34182f16 <_write+0x26>
  {
    __io_putchar(*ptr++);
34182f02:	68bb      	ldr	r3, [r7, #8]
34182f04:	1c5a      	adds	r2, r3, #1
34182f06:	60ba      	str	r2, [r7, #8]
34182f08:	781b      	ldrb	r3, [r3, #0]
34182f0a:	4618      	mov	r0, r3
34182f0c:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34182f10:	697b      	ldr	r3, [r7, #20]
34182f12:	3301      	adds	r3, #1
34182f14:	617b      	str	r3, [r7, #20]
34182f16:	697a      	ldr	r2, [r7, #20]
34182f18:	687b      	ldr	r3, [r7, #4]
34182f1a:	429a      	cmp	r2, r3
34182f1c:	dbf1      	blt.n	34182f02 <_write+0x12>
  }
  return len;
34182f1e:	687b      	ldr	r3, [r7, #4]
}
34182f20:	4618      	mov	r0, r3
34182f22:	3718      	adds	r7, #24
34182f24:	46bd      	mov	sp, r7
34182f26:	bd80      	pop	{r7, pc}

34182f28 <_close>:

int _close(int file)
{
34182f28:	b480      	push	{r7}
34182f2a:	b083      	sub	sp, #12
34182f2c:	af00      	add	r7, sp, #0
34182f2e:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
34182f30:	f04f 33ff 	mov.w	r3, #4294967295
}
34182f34:	4618      	mov	r0, r3
34182f36:	370c      	adds	r7, #12
34182f38:	46bd      	mov	sp, r7
34182f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f3e:	4770      	bx	lr

34182f40 <_fstat>:


int _fstat(int file, struct stat *st)
{
34182f40:	b480      	push	{r7}
34182f42:	b083      	sub	sp, #12
34182f44:	af00      	add	r7, sp, #0
34182f46:	6078      	str	r0, [r7, #4]
34182f48:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
34182f4a:	683b      	ldr	r3, [r7, #0]
34182f4c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34182f50:	605a      	str	r2, [r3, #4]
  return 0;
34182f52:	2300      	movs	r3, #0
}
34182f54:	4618      	mov	r0, r3
34182f56:	370c      	adds	r7, #12
34182f58:	46bd      	mov	sp, r7
34182f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f5e:	4770      	bx	lr

34182f60 <_isatty>:

int _isatty(int file)
{
34182f60:	b480      	push	{r7}
34182f62:	b083      	sub	sp, #12
34182f64:	af00      	add	r7, sp, #0
34182f66:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
34182f68:	2301      	movs	r3, #1
}
34182f6a:	4618      	mov	r0, r3
34182f6c:	370c      	adds	r7, #12
34182f6e:	46bd      	mov	sp, r7
34182f70:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f74:	4770      	bx	lr

34182f76 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
34182f76:	b480      	push	{r7}
34182f78:	b085      	sub	sp, #20
34182f7a:	af00      	add	r7, sp, #0
34182f7c:	60f8      	str	r0, [r7, #12]
34182f7e:	60b9      	str	r1, [r7, #8]
34182f80:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
34182f82:	2300      	movs	r3, #0
}
34182f84:	4618      	mov	r0, r3
34182f86:	3714      	adds	r7, #20
34182f88:	46bd      	mov	sp, r7
34182f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34182f8e:	4770      	bx	lr

34182f90 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
34182f90:	b580      	push	{r7, lr}
34182f92:	b086      	sub	sp, #24
34182f94:	af00      	add	r7, sp, #0
34182f96:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
34182f98:	4a14      	ldr	r2, [pc, #80]	@ (34182fec <_sbrk+0x5c>)
34182f9a:	4b15      	ldr	r3, [pc, #84]	@ (34182ff0 <_sbrk+0x60>)
34182f9c:	1ad3      	subs	r3, r2, r3
34182f9e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
34182fa0:	697b      	ldr	r3, [r7, #20]
34182fa2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
34182fa4:	4b13      	ldr	r3, [pc, #76]	@ (34182ff4 <_sbrk+0x64>)
34182fa6:	681b      	ldr	r3, [r3, #0]
34182fa8:	2b00      	cmp	r3, #0
34182faa:	d102      	bne.n	34182fb2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
34182fac:	4b11      	ldr	r3, [pc, #68]	@ (34182ff4 <_sbrk+0x64>)
34182fae:	4a12      	ldr	r2, [pc, #72]	@ (34182ff8 <_sbrk+0x68>)
34182fb0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
34182fb2:	4b10      	ldr	r3, [pc, #64]	@ (34182ff4 <_sbrk+0x64>)
34182fb4:	681a      	ldr	r2, [r3, #0]
34182fb6:	687b      	ldr	r3, [r7, #4]
34182fb8:	4413      	add	r3, r2
34182fba:	693a      	ldr	r2, [r7, #16]
34182fbc:	429a      	cmp	r2, r3
34182fbe:	d207      	bcs.n	34182fd0 <_sbrk+0x40>
  {
    errno = ENOMEM;
34182fc0:	f020 ff3e 	bl	341a3e40 <__errno>
34182fc4:	4603      	mov	r3, r0
34182fc6:	220c      	movs	r2, #12
34182fc8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
34182fca:	f04f 33ff 	mov.w	r3, #4294967295
34182fce:	e009      	b.n	34182fe4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
34182fd0:	4b08      	ldr	r3, [pc, #32]	@ (34182ff4 <_sbrk+0x64>)
34182fd2:	681b      	ldr	r3, [r3, #0]
34182fd4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
34182fd6:	4b07      	ldr	r3, [pc, #28]	@ (34182ff4 <_sbrk+0x64>)
34182fd8:	681a      	ldr	r2, [r3, #0]
34182fda:	687b      	ldr	r3, [r7, #4]
34182fdc:	4413      	add	r3, r2
34182fde:	4a05      	ldr	r2, [pc, #20]	@ (34182ff4 <_sbrk+0x64>)
34182fe0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
34182fe2:	68fb      	ldr	r3, [r7, #12]
}
34182fe4:	4618      	mov	r0, r3
34182fe6:	3718      	adds	r7, #24
34182fe8:	46bd      	mov	sp, r7
34182fea:	bd80      	pop	{r7, pc}
34182fec:	34200000 	.word	0x34200000
34182ff0:	00000800 	.word	0x00000800
34182ff4:	341c05a4 	.word	0x341c05a4
34182ff8:	341c1e58 	.word	0x341c1e58

34182ffc <LL_AHB4_GRP1_EnableClock>:
{
34182ffc:	b480      	push	{r7}
34182ffe:	b085      	sub	sp, #20
34183000:	af00      	add	r7, sp, #0
34183002:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34183004:	4a07      	ldr	r2, [pc, #28]	@ (34183024 <LL_AHB4_GRP1_EnableClock+0x28>)
34183006:	687b      	ldr	r3, [r7, #4]
34183008:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3418300c:	4b05      	ldr	r3, [pc, #20]	@ (34183024 <LL_AHB4_GRP1_EnableClock+0x28>)
3418300e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34183012:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183014:	68fb      	ldr	r3, [r7, #12]
}
34183016:	bf00      	nop
34183018:	3714      	adds	r7, #20
3418301a:	46bd      	mov	sp, r7
3418301c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183020:	4770      	bx	lr
34183022:	bf00      	nop
34183024:	56028000 	.word	0x56028000

34183028 <LL_AHB5_GRP1_EnableClock>:
{
34183028:	b480      	push	{r7}
3418302a:	b085      	sub	sp, #20
3418302c:	af00      	add	r7, sp, #0
3418302e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34183030:	4a07      	ldr	r2, [pc, #28]	@ (34183050 <LL_AHB5_GRP1_EnableClock+0x28>)
34183032:	687b      	ldr	r3, [r7, #4]
34183034:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34183038:	4b05      	ldr	r3, [pc, #20]	@ (34183050 <LL_AHB5_GRP1_EnableClock+0x28>)
3418303a:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
3418303e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183040:	68fb      	ldr	r3, [r7, #12]
}
34183042:	bf00      	nop
34183044:	3714      	adds	r7, #20
34183046:	46bd      	mov	sp, r7
34183048:	f85d 7b04 	ldr.w	r7, [sp], #4
3418304c:	4770      	bx	lr
3418304e:	bf00      	nop
34183050:	56028000 	.word	0x56028000

34183054 <MX_XSPI1_Init>:
XSPI_HandleTypeDef hxspi1;
XSPI_HandleTypeDef hxspi2;

/* XSPI1 init function */
void MX_XSPI1_Init(void)
{
34183054:	b580      	push	{r7, lr}
34183056:	b084      	sub	sp, #16
34183058:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
3418305a:	1d3b      	adds	r3, r7, #4
3418305c:	2200      	movs	r2, #0
3418305e:	601a      	str	r2, [r3, #0]
34183060:	605a      	str	r2, [r3, #4]
34183062:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  hxspi1.Instance = XSPI1;
34183064:	4b27      	ldr	r3, [pc, #156]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183066:	4a28      	ldr	r2, [pc, #160]	@ (34183108 <MX_XSPI1_Init+0xb4>)
34183068:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 8;
3418306a:	4b26      	ldr	r3, [pc, #152]	@ (34183104 <MX_XSPI1_Init+0xb0>)
3418306c:	2208      	movs	r2, #8
3418306e:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34183070:	4b24      	ldr	r3, [pc, #144]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183072:	2200      	movs	r2, #0
34183074:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_APMEM_16BITS;
34183076:	4b23      	ldr	r3, [pc, #140]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183078:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
3418307c:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
3418307e:	4b21      	ldr	r3, [pc, #132]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183080:	2218      	movs	r2, #24
34183082:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 5;
34183084:	4b1f      	ldr	r3, [pc, #124]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183086:	2205      	movs	r2, #5
34183088:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
3418308a:	4b1e      	ldr	r3, [pc, #120]	@ (34183104 <MX_XSPI1_Init+0xb0>)
3418308c:	2200      	movs	r2, #0
3418308e:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34183090:	4b1c      	ldr	r3, [pc, #112]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183092:	2200      	movs	r2, #0
34183094:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34183096:	4b1b      	ldr	r3, [pc, #108]	@ (34183104 <MX_XSPI1_Init+0xb0>)
34183098:	2200      	movs	r2, #0
3418309a:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 3;
3418309c:	4b19      	ldr	r3, [pc, #100]	@ (34183104 <MX_XSPI1_Init+0xb0>)
3418309e:	2203      	movs	r2, #3
341830a0:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
341830a2:	4b18      	ldr	r3, [pc, #96]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830a4:	2200      	movs	r2, #0
341830a6:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
341830a8:	4b16      	ldr	r3, [pc, #88]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830aa:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
341830ae:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
341830b0:	4b14      	ldr	r3, [pc, #80]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830b2:	2200      	movs	r2, #0
341830b4:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
341830b6:	4b13      	ldr	r3, [pc, #76]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830b8:	2200      	movs	r2, #0
341830ba:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
341830bc:	4b11      	ldr	r3, [pc, #68]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830be:	2200      	movs	r2, #0
341830c0:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
341830c2:	4b10      	ldr	r3, [pc, #64]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830c4:	2200      	movs	r2, #0
341830c6:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
341830c8:	480e      	ldr	r0, [pc, #56]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830ca:	f011 ffdb 	bl	34195084 <HAL_XSPI_Init>
341830ce:	4603      	mov	r3, r0
341830d0:	2b00      	cmp	r3, #0
341830d2:	d001      	beq.n	341830d8 <MX_XSPI1_Init+0x84>
  {
    Error_Handler();
341830d4:	f7ff fe62 	bl	34182d9c <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
341830d8:	2310      	movs	r3, #16
341830da:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
341830dc:	2300      	movs	r3, #0
341830de:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
341830e0:	2301      	movs	r3, #1
341830e2:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341830e4:	1d3b      	adds	r3, r7, #4
341830e6:	f241 3288 	movw	r2, #5000	@ 0x1388
341830ea:	4619      	mov	r1, r3
341830ec:	4805      	ldr	r0, [pc, #20]	@ (34183104 <MX_XSPI1_Init+0xb0>)
341830ee:	f012 fc33 	bl	34195958 <HAL_XSPIM_Config>
341830f2:	4603      	mov	r3, r0
341830f4:	2b00      	cmp	r3, #0
341830f6:	d001      	beq.n	341830fc <MX_XSPI1_Init+0xa8>
  {
    Error_Handler();
341830f8:	f7ff fe50 	bl	34182d9c <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
341830fc:	bf00      	nop
341830fe:	3710      	adds	r7, #16
34183100:	46bd      	mov	sp, r7
34183102:	bd80      	pop	{r7, pc}
34183104:	341c05a8 	.word	0x341c05a8
34183108:	58025000 	.word	0x58025000

3418310c <MX_XSPI2_Init>:
/* XSPI2 init function */
void MX_XSPI2_Init(void)
{
3418310c:	b580      	push	{r7, lr}
3418310e:	b084      	sub	sp, #16
34183110:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI2_Init 0 */

  /* USER CODE END XSPI2_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34183112:	1d3b      	adds	r3, r7, #4
34183114:	2200      	movs	r2, #0
34183116:	601a      	str	r2, [r3, #0]
34183118:	605a      	str	r2, [r3, #4]
3418311a:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  hxspi2.Instance = XSPI2;
3418311c:	4b27      	ldr	r3, [pc, #156]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418311e:	4a28      	ldr	r2, [pc, #160]	@ (341831c0 <MX_XSPI2_Init+0xb4>)
34183120:	601a      	str	r2, [r3, #0]
  hxspi2.Init.FifoThresholdByte = 4;
34183122:	4b26      	ldr	r3, [pc, #152]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183124:	2204      	movs	r2, #4
34183126:	605a      	str	r2, [r3, #4]
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34183128:	4b24      	ldr	r3, [pc, #144]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418312a:	2200      	movs	r2, #0
3418312c:	609a      	str	r2, [r3, #8]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MACRONIX;
3418312e:	4b23      	ldr	r3, [pc, #140]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183130:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34183134:	60da      	str	r2, [r3, #12]
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_1GB;
34183136:	4b21      	ldr	r3, [pc, #132]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183138:	221a      	movs	r2, #26
3418313a:	611a      	str	r2, [r3, #16]
  hxspi2.Init.ChipSelectHighTimeCycle = 2;
3418313c:	4b1f      	ldr	r3, [pc, #124]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418313e:	2202      	movs	r2, #2
34183140:	615a      	str	r2, [r3, #20]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34183142:	4b1e      	ldr	r3, [pc, #120]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183144:	2200      	movs	r2, #0
34183146:	619a      	str	r2, [r3, #24]
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34183148:	4b1c      	ldr	r3, [pc, #112]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418314a:	2200      	movs	r2, #0
3418314c:	61da      	str	r2, [r3, #28]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
3418314e:	4b1b      	ldr	r3, [pc, #108]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183150:	2200      	movs	r2, #0
34183152:	621a      	str	r2, [r3, #32]
  hxspi2.Init.ClockPrescaler = 0;
34183154:	4b19      	ldr	r3, [pc, #100]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183156:	2200      	movs	r2, #0
34183158:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3418315a:	4b18      	ldr	r3, [pc, #96]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418315c:	2200      	movs	r2, #0
3418315e:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34183160:	4b16      	ldr	r3, [pc, #88]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183162:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34183166:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34183168:	4b14      	ldr	r3, [pc, #80]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418316a:	2200      	movs	r2, #0
3418316c:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi2.Init.MaxTran = 0;
3418316e:	4b13      	ldr	r3, [pc, #76]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183170:	2200      	movs	r2, #0
34183172:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi2.Init.Refresh = 0;
34183174:	4b11      	ldr	r3, [pc, #68]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183176:	2200      	movs	r2, #0
34183178:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
3418317a:	4b10      	ldr	r3, [pc, #64]	@ (341831bc <MX_XSPI2_Init+0xb0>)
3418317c:	2200      	movs	r2, #0
3418317e:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34183180:	480e      	ldr	r0, [pc, #56]	@ (341831bc <MX_XSPI2_Init+0xb0>)
34183182:	f011 ff7f 	bl	34195084 <HAL_XSPI_Init>
34183186:	4603      	mov	r3, r0
34183188:	2b00      	cmp	r3, #0
3418318a:	d001      	beq.n	34183190 <MX_XSPI2_Init+0x84>
  {
    Error_Handler();
3418318c:	f7ff fe06 	bl	34182d9c <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34183190:	2310      	movs	r3, #16
34183192:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34183194:	2301      	movs	r3, #1
34183196:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
34183198:	2301      	movs	r3, #1
3418319a:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3418319c:	1d3b      	adds	r3, r7, #4
3418319e:	f241 3288 	movw	r2, #5000	@ 0x1388
341831a2:	4619      	mov	r1, r3
341831a4:	4805      	ldr	r0, [pc, #20]	@ (341831bc <MX_XSPI2_Init+0xb0>)
341831a6:	f012 fbd7 	bl	34195958 <HAL_XSPIM_Config>
341831aa:	4603      	mov	r3, r0
341831ac:	2b00      	cmp	r3, #0
341831ae:	d001      	beq.n	341831b4 <MX_XSPI2_Init+0xa8>
  {
    Error_Handler();
341831b0:	f7ff fdf4 	bl	34182d9c <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
341831b4:	bf00      	nop
341831b6:	3710      	adds	r7, #16
341831b8:	46bd      	mov	sp, r7
341831ba:	bd80      	pop	{r7, pc}
341831bc:	341c060c 	.word	0x341c060c
341831c0:	5802a000 	.word	0x5802a000

341831c4 <HAL_XSPI_MspInit>:

static uint32_t HAL_RCC_XSPIM_CLK_ENABLED=0;

void HAL_XSPI_MspInit(XSPI_HandleTypeDef* xspiHandle)
{
341831c4:	b580      	push	{r7, lr}
341831c6:	b0ec      	sub	sp, #432	@ 0x1b0
341831c8:	af00      	add	r7, sp, #0
341831ca:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341831ce:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
341831d2:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
341831d4:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341831d8:	2200      	movs	r2, #0
341831da:	601a      	str	r2, [r3, #0]
341831dc:	605a      	str	r2, [r3, #4]
341831de:	609a      	str	r2, [r3, #8]
341831e0:	60da      	str	r2, [r3, #12]
341831e2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
341831e4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341831e8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341831ec:	4618      	mov	r0, r3
341831ee:	f44f 73c8 	mov.w	r3, #400	@ 0x190
341831f2:	461a      	mov	r2, r3
341831f4:	2100      	movs	r1, #0
341831f6:	f020 fdd5 	bl	341a3da4 <memset>
  if(xspiHandle->Instance==XSPI1)
341831fa:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341831fe:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34183202:	681b      	ldr	r3, [r3, #0]
34183204:	681b      	ldr	r3, [r3, #0]
34183206:	4a5b      	ldr	r2, [pc, #364]	@ (34183374 <HAL_XSPI_MspInit+0x1b0>)
34183208:	4293      	cmp	r3, r2
3418320a:	d15e      	bne.n	341832ca <HAL_XSPI_MspInit+0x106>

  /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
3418320c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34183210:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34183214:	f04f 0200 	mov.w	r2, #0
34183218:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
3418321c:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34183220:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34183224:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34183228:	4a53      	ldr	r2, [pc, #332]	@ (34183378 <HAL_XSPI_MspInit+0x1b4>)
3418322a:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
3418322e:	f107 0308 	add.w	r3, r7, #8
34183232:	4618      	mov	r0, r3
34183234:	f00b f9d4 	bl	3418e5e0 <HAL_RCCEx_PeriphCLKConfig>
34183238:	4603      	mov	r3, r0
3418323a:	2b00      	cmp	r3, #0
3418323c:	d001      	beq.n	34183242 <HAL_XSPI_MspInit+0x7e>
    {
      Error_Handler();
3418323e:	f7ff fdad 	bl	34182d9c <Error_Handler>
    }

    /* XSPI1 clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34183242:	4b4e      	ldr	r3, [pc, #312]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
34183244:	681b      	ldr	r3, [r3, #0]
34183246:	3301      	adds	r3, #1
34183248:	4a4c      	ldr	r2, [pc, #304]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
3418324a:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
3418324c:	4b4b      	ldr	r3, [pc, #300]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
3418324e:	681b      	ldr	r3, [r3, #0]
34183250:	2b01      	cmp	r3, #1
34183252:	d103      	bne.n	3418325c <HAL_XSPI_MspInit+0x98>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34183254:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34183258:	f7ff fee6 	bl	34183028 <LL_AHB5_GRP1_EnableClock>
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
3418325c:	2020      	movs	r0, #32
3418325e:	f7ff fee3 	bl	34183028 <LL_AHB5_GRP1_EnableClock>

    __HAL_RCC_GPIOP_CLK_ENABLE();
34183262:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34183266:	f7ff fec9 	bl	34182ffc <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOO_CLK_ENABLE();
3418326a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3418326e:	f7ff fec5 	bl	34182ffc <LL_AHB4_GRP1_EnableClock>
    PO0     ------> XSPIM_P1_NCS1
    PP9     ------> XSPIM_P1_IO9
    PP10     ------> XSPIM_P1_IO10
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_0|GPIO_PIN_4
34183272:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34183276:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_5|GPIO_PIN_12
                          |GPIO_PIN_3|GPIO_PIN_2|GPIO_PIN_13|GPIO_PIN_11
                          |GPIO_PIN_8|GPIO_PIN_14|GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418327a:	2302      	movs	r3, #2
3418327c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34183280:	2300      	movs	r3, #0
34183282:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34183286:	2303      	movs	r3, #3
34183288:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
3418328c:	2309      	movs	r3, #9
3418328e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34183292:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34183296:	4619      	mov	r1, r3
34183298:	4839      	ldr	r0, [pc, #228]	@ (34183380 <HAL_XSPI_MspInit+0x1bc>)
3418329a:	f005 f9f7 	bl	3418868c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_0|GPIO_PIN_4;
3418329e:	231d      	movs	r3, #29
341832a0:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341832a4:	2302      	movs	r3, #2
341832a6:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341832aa:	2300      	movs	r3, #0
341832ac:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
341832b0:	2303      	movs	r3, #3
341832b2:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
341832b6:	2309      	movs	r3, #9
341832b8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
341832bc:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341832c0:	4619      	mov	r1, r3
341832c2:	4830      	ldr	r0, [pc, #192]	@ (34183384 <HAL_XSPI_MspInit+0x1c0>)
341832c4:	f005 f9e2 	bl	3418868c <HAL_GPIO_Init>

  /* USER CODE BEGIN XSPI2_MspInit 1 */

  /* USER CODE END XSPI2_MspInit 1 */
  }
}
341832c8:	e04e      	b.n	34183368 <HAL_XSPI_MspInit+0x1a4>
  else if(xspiHandle->Instance==XSPI2)
341832ca:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341832ce:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
341832d2:	681b      	ldr	r3, [r3, #0]
341832d4:	681b      	ldr	r3, [r3, #0]
341832d6:	4a2c      	ldr	r2, [pc, #176]	@ (34183388 <HAL_XSPI_MspInit+0x1c4>)
341832d8:	4293      	cmp	r3, r2
341832da:	d145      	bne.n	34183368 <HAL_XSPI_MspInit+0x1a4>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
341832dc:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341832e0:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
341832e4:	f04f 0200 	mov.w	r2, #0
341832e8:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
341832ec:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
341832f0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341832f4:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341832f8:	4a24      	ldr	r2, [pc, #144]	@ (3418338c <HAL_XSPI_MspInit+0x1c8>)
341832fa:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
341832fe:	f107 0308 	add.w	r3, r7, #8
34183302:	4618      	mov	r0, r3
34183304:	f00b f96c 	bl	3418e5e0 <HAL_RCCEx_PeriphCLKConfig>
34183308:	4603      	mov	r3, r0
3418330a:	2b00      	cmp	r3, #0
3418330c:	d001      	beq.n	34183312 <HAL_XSPI_MspInit+0x14e>
      Error_Handler();
3418330e:	f7ff fd45 	bl	34182d9c <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
34183312:	4b1a      	ldr	r3, [pc, #104]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
34183314:	681b      	ldr	r3, [r3, #0]
34183316:	3301      	adds	r3, #1
34183318:	4a18      	ldr	r2, [pc, #96]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
3418331a:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
3418331c:	4b17      	ldr	r3, [pc, #92]	@ (3418337c <HAL_XSPI_MspInit+0x1b8>)
3418331e:	681b      	ldr	r3, [r3, #0]
34183320:	2b01      	cmp	r3, #1
34183322:	d103      	bne.n	3418332c <HAL_XSPI_MspInit+0x168>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34183324:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34183328:	f7ff fe7e 	bl	34183028 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_XSPI2_CLK_ENABLE();
3418332c:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34183330:	f7ff fe7a 	bl	34183028 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_GPION_CLK_ENABLE();
34183334:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34183338:	f7ff fe60 	bl	34182ffc <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_0
3418333c:	f640 737f 	movw	r3, #3967	@ 0xf7f
34183340:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34183344:	2302      	movs	r3, #2
34183346:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418334a:	2300      	movs	r3, #0
3418334c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34183350:	2303      	movs	r3, #3
34183352:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34183356:	2309      	movs	r3, #9
34183358:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
3418335c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34183360:	4619      	mov	r1, r3
34183362:	480b      	ldr	r0, [pc, #44]	@ (34183390 <HAL_XSPI_MspInit+0x1cc>)
34183364:	f005 f992 	bl	3418868c <HAL_GPIO_Init>
}
34183368:	bf00      	nop
3418336a:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
3418336e:	46bd      	mov	sp, r7
34183370:	bd80      	pop	{r7, pc}
34183372:	bf00      	nop
34183374:	58025000 	.word	0x58025000
34183378:	03000014 	.word	0x03000014
3418337c:	341c0670 	.word	0x341c0670
34183380:	56023c00 	.word	0x56023c00
34183384:	56023800 	.word	0x56023800
34183388:	5802a000 	.word	0x5802a000
3418338c:	03000414 	.word	0x03000414
34183390:	56023400 	.word	0x56023400

34183394 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34183394:	480f      	ldr	r0, [pc, #60]	@ (341833d4 <LoopForever+0x4>)
  msr   MSPLIM, r0
34183396:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
3418339a:	480f      	ldr	r0, [pc, #60]	@ (341833d8 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
3418339c:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
3418339e:	f000 f829 	bl	341833f4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
341833a2:	480e      	ldr	r0, [pc, #56]	@ (341833dc <LoopForever+0xc>)
  ldr r1, =_edata
341833a4:	490e      	ldr	r1, [pc, #56]	@ (341833e0 <LoopForever+0x10>)
  ldr r2, =_sidata
341833a6:	4a0f      	ldr	r2, [pc, #60]	@ (341833e4 <LoopForever+0x14>)
  movs r3, #0
341833a8:	2300      	movs	r3, #0
  b LoopCopyDataInit
341833aa:	e002      	b.n	341833b2 <LoopCopyDataInit>

341833ac <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
341833ac:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
341833ae:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
341833b0:	3304      	adds	r3, #4

341833b2 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
341833b2:	18c4      	adds	r4, r0, r3
  cmp r4, r1
341833b4:	428c      	cmp	r4, r1
  bcc CopyDataInit
341833b6:	d3f9      	bcc.n	341833ac <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
341833b8:	4a0b      	ldr	r2, [pc, #44]	@ (341833e8 <LoopForever+0x18>)
  ldr r4, =_ebss
341833ba:	4c0c      	ldr	r4, [pc, #48]	@ (341833ec <LoopForever+0x1c>)
  movs r3, #0
341833bc:	2300      	movs	r3, #0
  b LoopFillZerobss
341833be:	e001      	b.n	341833c4 <LoopFillZerobss>

341833c0 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
341833c0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
341833c2:	3204      	adds	r2, #4

341833c4 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
341833c4:	42a2      	cmp	r2, r4
  bcc FillZerobss
341833c6:	d3fb      	bcc.n	341833c0 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
341833c8:	f020 fd40 	bl	341a3e4c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
341833cc:	f7ff fa68 	bl	341828a0 <main>

341833d0 <LoopForever>:

LoopForever:
  b LoopForever
341833d0:	e7fe      	b.n	341833d0 <LoopForever>
341833d2:	0000      	.short	0x0000
  ldr   r0, =_sstack
341833d4:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
341833d8:	34200000 	.word	0x34200000
  ldr r0, =_sdata
341833dc:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
341833e0:	341c0190 	.word	0x341c0190
  ldr r2, =_sidata
341833e4:	341ba164 	.word	0x341ba164
  ldr r2, =_sbss
341833e8:	341c0190 	.word	0x341c0190
  ldr r4, =_ebss
341833ec:	341c1e58 	.word	0x341c1e58

341833f0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
341833f0:	e7fe      	b.n	341833f0 <ADC1_2_IRQHandler>
	...

341833f4 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
341833f4:	b480      	push	{r7}
341833f6:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
341833f8:	4b6a      	ldr	r3, [pc, #424]	@ (341835a4 <SystemInit+0x1b0>)
341833fa:	4a6b      	ldr	r2, [pc, #428]	@ (341835a8 <SystemInit+0x1b4>)
341833fc:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
341833fe:	4b6b      	ldr	r3, [pc, #428]	@ (341835ac <SystemInit+0x1b8>)
34183400:	2201      	movs	r2, #1
34183402:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
34183406:	4b69      	ldr	r3, [pc, #420]	@ (341835ac <SystemInit+0x1b8>)
34183408:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418340c:	461a      	mov	r2, r3
3418340e:	2301      	movs	r3, #1
34183410:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
34183414:	4b65      	ldr	r3, [pc, #404]	@ (341835ac <SystemInit+0x1b8>)
34183416:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418341a:	461a      	mov	r2, r3
3418341c:	2301      	movs	r3, #1
3418341e:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
34183422:	4b63      	ldr	r3, [pc, #396]	@ (341835b0 <SystemInit+0x1bc>)
34183424:	2200      	movs	r2, #0
34183426:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183428:	4b61      	ldr	r3, [pc, #388]	@ (341835b0 <SystemInit+0x1bc>)
3418342a:	2200      	movs	r2, #0
3418342c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418342e:	4b60      	ldr	r3, [pc, #384]	@ (341835b0 <SystemInit+0x1bc>)
34183430:	2200      	movs	r2, #0
34183432:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
34183434:	4b5e      	ldr	r3, [pc, #376]	@ (341835b0 <SystemInit+0x1bc>)
34183436:	2201      	movs	r2, #1
34183438:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418343a:	4b5d      	ldr	r3, [pc, #372]	@ (341835b0 <SystemInit+0x1bc>)
3418343c:	2200      	movs	r2, #0
3418343e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183440:	4b5b      	ldr	r3, [pc, #364]	@ (341835b0 <SystemInit+0x1bc>)
34183442:	2200      	movs	r2, #0
34183444:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
34183446:	4b5a      	ldr	r3, [pc, #360]	@ (341835b0 <SystemInit+0x1bc>)
34183448:	2202      	movs	r2, #2
3418344a:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418344c:	4b58      	ldr	r3, [pc, #352]	@ (341835b0 <SystemInit+0x1bc>)
3418344e:	2200      	movs	r2, #0
34183450:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183452:	4b57      	ldr	r3, [pc, #348]	@ (341835b0 <SystemInit+0x1bc>)
34183454:	2200      	movs	r2, #0
34183456:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
34183458:	4b55      	ldr	r3, [pc, #340]	@ (341835b0 <SystemInit+0x1bc>)
3418345a:	2203      	movs	r2, #3
3418345c:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418345e:	4b54      	ldr	r3, [pc, #336]	@ (341835b0 <SystemInit+0x1bc>)
34183460:	2200      	movs	r2, #0
34183462:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183464:	4b52      	ldr	r3, [pc, #328]	@ (341835b0 <SystemInit+0x1bc>)
34183466:	2200      	movs	r2, #0
34183468:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
3418346a:	4b51      	ldr	r3, [pc, #324]	@ (341835b0 <SystemInit+0x1bc>)
3418346c:	2204      	movs	r2, #4
3418346e:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183470:	4b4f      	ldr	r3, [pc, #316]	@ (341835b0 <SystemInit+0x1bc>)
34183472:	2200      	movs	r2, #0
34183474:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183476:	4b4e      	ldr	r3, [pc, #312]	@ (341835b0 <SystemInit+0x1bc>)
34183478:	2200      	movs	r2, #0
3418347a:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
3418347c:	4b4c      	ldr	r3, [pc, #304]	@ (341835b0 <SystemInit+0x1bc>)
3418347e:	2205      	movs	r2, #5
34183480:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183482:	4b4b      	ldr	r3, [pc, #300]	@ (341835b0 <SystemInit+0x1bc>)
34183484:	2200      	movs	r2, #0
34183486:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183488:	4b49      	ldr	r3, [pc, #292]	@ (341835b0 <SystemInit+0x1bc>)
3418348a:	2200      	movs	r2, #0
3418348c:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
3418348e:	4b48      	ldr	r3, [pc, #288]	@ (341835b0 <SystemInit+0x1bc>)
34183490:	2206      	movs	r2, #6
34183492:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183494:	4b46      	ldr	r3, [pc, #280]	@ (341835b0 <SystemInit+0x1bc>)
34183496:	2200      	movs	r2, #0
34183498:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418349a:	4b45      	ldr	r3, [pc, #276]	@ (341835b0 <SystemInit+0x1bc>)
3418349c:	2200      	movs	r2, #0
3418349e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
341834a0:	4b43      	ldr	r3, [pc, #268]	@ (341835b0 <SystemInit+0x1bc>)
341834a2:	2207      	movs	r2, #7
341834a4:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341834a6:	4b42      	ldr	r3, [pc, #264]	@ (341835b0 <SystemInit+0x1bc>)
341834a8:	2200      	movs	r2, #0
341834aa:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341834ac:	4b40      	ldr	r3, [pc, #256]	@ (341835b0 <SystemInit+0x1bc>)
341834ae:	2200      	movs	r2, #0
341834b0:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
341834b2:	4b3e      	ldr	r3, [pc, #248]	@ (341835ac <SystemInit+0x1b8>)
341834b4:	2201      	movs	r2, #1
341834b6:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
341834ba:	4b3c      	ldr	r3, [pc, #240]	@ (341835ac <SystemInit+0x1b8>)
341834bc:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
341834c0:	4b38      	ldr	r3, [pc, #224]	@ (341835a4 <SystemInit+0x1b0>)
341834c2:	4a3c      	ldr	r2, [pc, #240]	@ (341835b4 <SystemInit+0x1c0>)
341834c4:	689b      	ldr	r3, [r3, #8]
341834c6:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
341834c8:	4b3b      	ldr	r3, [pc, #236]	@ (341835b8 <SystemInit+0x1c4>)
341834ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341834cc:	4a3a      	ldr	r2, [pc, #232]	@ (341835b8 <SystemInit+0x1c4>)
341834ce:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
341834d2:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
341834d4:	4b38      	ldr	r3, [pc, #224]	@ (341835b8 <SystemInit+0x1c4>)
341834d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341834d8:	4a37      	ldr	r2, [pc, #220]	@ (341835b8 <SystemInit+0x1c4>)
341834da:	f043 0310 	orr.w	r3, r3, #16
341834de:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
341834e0:	4b35      	ldr	r3, [pc, #212]	@ (341835b8 <SystemInit+0x1c4>)
341834e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
341834e4:	4b31      	ldr	r3, [pc, #196]	@ (341835ac <SystemInit+0x1b8>)
341834e6:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
341834ea:	4a30      	ldr	r2, [pc, #192]	@ (341835ac <SystemInit+0x1b8>)
341834ec:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341834f0:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
341834f4:	4b2d      	ldr	r3, [pc, #180]	@ (341835ac <SystemInit+0x1b8>)
341834f6:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
341834fa:	4a2c      	ldr	r2, [pc, #176]	@ (341835ac <SystemInit+0x1b8>)
341834fc:	f043 0310 	orr.w	r3, r3, #16
34183500:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
34183504:	4b29      	ldr	r3, [pc, #164]	@ (341835ac <SystemInit+0x1b8>)
34183506:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
3418350a:	4b28      	ldr	r3, [pc, #160]	@ (341835ac <SystemInit+0x1b8>)
3418350c:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
34183510:	4a26      	ldr	r2, [pc, #152]	@ (341835ac <SystemInit+0x1b8>)
34183512:	f023 0310 	bic.w	r3, r3, #16
34183516:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
3418351a:	4b24      	ldr	r3, [pc, #144]	@ (341835ac <SystemInit+0x1b8>)
3418351c:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34183520:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
34183524:	4b21      	ldr	r3, [pc, #132]	@ (341835ac <SystemInit+0x1b8>)
34183526:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418352a:	461a      	mov	r2, r3
3418352c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34183530:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
34183534:	4b1d      	ldr	r3, [pc, #116]	@ (341835ac <SystemInit+0x1b8>)
34183536:	2201      	movs	r2, #1
34183538:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
3418353c:	4b1b      	ldr	r3, [pc, #108]	@ (341835ac <SystemInit+0x1b8>)
3418353e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183542:	461a      	mov	r2, r3
34183544:	2301      	movs	r3, #1
34183546:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
3418354a:	4b18      	ldr	r3, [pc, #96]	@ (341835ac <SystemInit+0x1b8>)
3418354c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183550:	461a      	mov	r2, r3
34183552:	2301      	movs	r3, #1
34183554:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
34183558:	4b14      	ldr	r3, [pc, #80]	@ (341835ac <SystemInit+0x1b8>)
3418355a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418355e:	461a      	mov	r2, r3
34183560:	2340      	movs	r3, #64	@ 0x40
34183562:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34183566:	4b13      	ldr	r3, [pc, #76]	@ (341835b4 <SystemInit+0x1c0>)
34183568:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
3418356a:	4b10      	ldr	r3, [pc, #64]	@ (341835ac <SystemInit+0x1b8>)
3418356c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183570:	461a      	mov	r2, r3
34183572:	2301      	movs	r3, #1
34183574:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34183578:	4b0a      	ldr	r3, [pc, #40]	@ (341835a4 <SystemInit+0x1b0>)
3418357a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418357e:	4a09      	ldr	r2, [pc, #36]	@ (341835a4 <SystemInit+0x1b0>)
34183580:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34183584:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34183588:	4b0c      	ldr	r3, [pc, #48]	@ (341835bc <SystemInit+0x1c8>)
3418358a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418358e:	4a0b      	ldr	r2, [pc, #44]	@ (341835bc <SystemInit+0x1c8>)
34183590:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34183594:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34183598:	bf00      	nop
3418359a:	46bd      	mov	sp, r7
3418359c:	f85d 7b04 	ldr.w	r7, [sp], #4
341835a0:	4770      	bx	lr
341835a2:	bf00      	nop
341835a4:	e000ed00 	.word	0xe000ed00
341835a8:	34180400 	.word	0x34180400
341835ac:	56028000 	.word	0x56028000
341835b0:	e000edd0 	.word	0xe000edd0
341835b4:	56008000 	.word	0x56008000
341835b8:	56024800 	.word	0x56024800
341835bc:	e002ed00 	.word	0xe002ed00

341835c0 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
341835c0:	b480      	push	{r7}
341835c2:	b08d      	sub	sp, #52	@ 0x34
341835c4:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
341835c6:	2300      	movs	r3, #0
341835c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
341835ca:	2300      	movs	r3, #0
341835cc:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
341835ce:	2300      	movs	r3, #0
341835d0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
341835d2:	2300      	movs	r3, #0
341835d4:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
341835d6:	2300      	movs	r3, #0
341835d8:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
341835da:	2300      	movs	r3, #0
341835dc:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
341835de:	4b9b      	ldr	r3, [pc, #620]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341835e0:	6a1b      	ldr	r3, [r3, #32]
341835e2:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
341835e6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341835ea:	d029      	beq.n	34183640 <SystemCoreClockUpdate+0x80>
341835ec:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341835f0:	f200 8180 	bhi.w	341838f4 <SystemCoreClockUpdate+0x334>
341835f4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341835f8:	d01f      	beq.n	3418363a <SystemCoreClockUpdate+0x7a>
341835fa:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341835fe:	f200 8179 	bhi.w	341838f4 <SystemCoreClockUpdate+0x334>
34183602:	2b00      	cmp	r3, #0
34183604:	d003      	beq.n	3418360e <SystemCoreClockUpdate+0x4e>
34183606:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418360a:	d00a      	beq.n	34183622 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
3418360c:	e172      	b.n	341838f4 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3418360e:	4b8f      	ldr	r3, [pc, #572]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183610:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34183612:	09db      	lsrs	r3, r3, #7
34183614:	f003 0303 	and.w	r3, r3, #3
34183618:	4a8d      	ldr	r2, [pc, #564]	@ (34183850 <SystemCoreClockUpdate+0x290>)
3418361a:	fa22 f303 	lsr.w	r3, r2, r3
3418361e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34183620:	e169      	b.n	341838f6 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34183622:	4b8a      	ldr	r3, [pc, #552]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183624:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34183626:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418362a:	2b00      	cmp	r3, #0
3418362c:	d102      	bne.n	34183634 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
3418362e:	4b89      	ldr	r3, [pc, #548]	@ (34183854 <SystemCoreClockUpdate+0x294>)
34183630:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34183632:	e160      	b.n	341838f6 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34183634:	4b88      	ldr	r3, [pc, #544]	@ (34183858 <SystemCoreClockUpdate+0x298>)
34183636:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34183638:	e15d      	b.n	341838f6 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
3418363a:	4b88      	ldr	r3, [pc, #544]	@ (3418385c <SystemCoreClockUpdate+0x29c>)
3418363c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3418363e:	e15a      	b.n	341838f6 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34183640:	4b82      	ldr	r3, [pc, #520]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183642:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34183646:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
3418364a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418364e:	d066      	beq.n	3418371e <SystemCoreClockUpdate+0x15e>
34183650:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183654:	f200 8091 	bhi.w	3418377a <SystemCoreClockUpdate+0x1ba>
34183658:	2b00      	cmp	r3, #0
3418365a:	d003      	beq.n	34183664 <SystemCoreClockUpdate+0xa4>
3418365c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34183660:	d02f      	beq.n	341836c2 <SystemCoreClockUpdate+0x102>
34183662:	e08a      	b.n	3418377a <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34183664:	4b79      	ldr	r3, [pc, #484]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183666:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418366a:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
3418366c:	68fb      	ldr	r3, [r7, #12]
3418366e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34183672:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34183674:	68fb      	ldr	r3, [r7, #12]
34183676:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418367a:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3418367c:	693b      	ldr	r3, [r7, #16]
3418367e:	2b00      	cmp	r3, #0
34183680:	f040 80a9 	bne.w	341837d6 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34183684:	68fb      	ldr	r3, [r7, #12]
34183686:	0d1b      	lsrs	r3, r3, #20
34183688:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3418368c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
3418368e:	68fb      	ldr	r3, [r7, #12]
34183690:	0a1b      	lsrs	r3, r3, #8
34183692:	f3c3 030b 	ubfx	r3, r3, #0, #12
34183696:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34183698:	4b6c      	ldr	r3, [pc, #432]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
3418369a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418369e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341836a2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
341836a4:	4b69      	ldr	r3, [pc, #420]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341836a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
341836aa:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
341836ac:	68fb      	ldr	r3, [r7, #12]
341836ae:	0edb      	lsrs	r3, r3, #27
341836b0:	f003 0307 	and.w	r3, r3, #7
341836b4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
341836b6:	68fb      	ldr	r3, [r7, #12]
341836b8:	0e1b      	lsrs	r3, r3, #24
341836ba:	f003 0307 	and.w	r3, r3, #7
341836be:	61bb      	str	r3, [r7, #24]
      break;
341836c0:	e089      	b.n	341837d6 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
341836c2:	4b62      	ldr	r3, [pc, #392]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341836c4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
341836c8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
341836ca:	68fb      	ldr	r3, [r7, #12]
341836cc:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
341836d0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
341836d2:	68fb      	ldr	r3, [r7, #12]
341836d4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341836d8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
341836da:	693b      	ldr	r3, [r7, #16]
341836dc:	2b00      	cmp	r3, #0
341836de:	d17c      	bne.n	341837da <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
341836e0:	68fb      	ldr	r3, [r7, #12]
341836e2:	0d1b      	lsrs	r3, r3, #20
341836e4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341836e8:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
341836ea:	68fb      	ldr	r3, [r7, #12]
341836ec:	0a1b      	lsrs	r3, r3, #8
341836ee:	f3c3 030b 	ubfx	r3, r3, #0, #12
341836f2:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
341836f4:	4b55      	ldr	r3, [pc, #340]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341836f6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341836fa:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341836fe:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34183700:	4b52      	ldr	r3, [pc, #328]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183702:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34183706:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34183708:	68fb      	ldr	r3, [r7, #12]
3418370a:	0edb      	lsrs	r3, r3, #27
3418370c:	f003 0307 	and.w	r3, r3, #7
34183710:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34183712:	68fb      	ldr	r3, [r7, #12]
34183714:	0e1b      	lsrs	r3, r3, #24
34183716:	f003 0307 	and.w	r3, r3, #7
3418371a:	61bb      	str	r3, [r7, #24]
      break;
3418371c:	e05d      	b.n	341837da <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
3418371e:	4b4b      	ldr	r3, [pc, #300]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183720:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34183724:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34183726:	68fb      	ldr	r3, [r7, #12]
34183728:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3418372c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
3418372e:	68fb      	ldr	r3, [r7, #12]
34183730:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183734:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34183736:	693b      	ldr	r3, [r7, #16]
34183738:	2b00      	cmp	r3, #0
3418373a:	d150      	bne.n	341837de <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
3418373c:	68fb      	ldr	r3, [r7, #12]
3418373e:	0d1b      	lsrs	r3, r3, #20
34183740:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34183744:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34183746:	68fb      	ldr	r3, [r7, #12]
34183748:	0a1b      	lsrs	r3, r3, #8
3418374a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418374e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34183750:	4b3e      	ldr	r3, [pc, #248]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183752:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34183756:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418375a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
3418375c:	4b3b      	ldr	r3, [pc, #236]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
3418375e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34183762:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34183764:	68fb      	ldr	r3, [r7, #12]
34183766:	0edb      	lsrs	r3, r3, #27
34183768:	f003 0307 	and.w	r3, r3, #7
3418376c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
3418376e:	68fb      	ldr	r3, [r7, #12]
34183770:	0e1b      	lsrs	r3, r3, #24
34183772:	f003 0307 	and.w	r3, r3, #7
34183776:	61bb      	str	r3, [r7, #24]
      break;
34183778:	e031      	b.n	341837de <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
3418377a:	4b34      	ldr	r3, [pc, #208]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
3418377c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183780:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34183782:	68fb      	ldr	r3, [r7, #12]
34183784:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34183788:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
3418378a:	68fb      	ldr	r3, [r7, #12]
3418378c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183790:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34183792:	693b      	ldr	r3, [r7, #16]
34183794:	2b00      	cmp	r3, #0
34183796:	d124      	bne.n	341837e2 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34183798:	68fb      	ldr	r3, [r7, #12]
3418379a:	0d1b      	lsrs	r3, r3, #20
3418379c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341837a0:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
341837a2:	68fb      	ldr	r3, [r7, #12]
341837a4:	0a1b      	lsrs	r3, r3, #8
341837a6:	f3c3 030b 	ubfx	r3, r3, #0, #12
341837aa:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
341837ac:	4b27      	ldr	r3, [pc, #156]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341837ae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
341837b2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341837b6:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
341837b8:	4b24      	ldr	r3, [pc, #144]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
341837ba:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
341837be:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
341837c0:	68fb      	ldr	r3, [r7, #12]
341837c2:	0edb      	lsrs	r3, r3, #27
341837c4:	f003 0307 	and.w	r3, r3, #7
341837c8:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
341837ca:	68fb      	ldr	r3, [r7, #12]
341837cc:	0e1b      	lsrs	r3, r3, #24
341837ce:	f003 0307 	and.w	r3, r3, #7
341837d2:	61bb      	str	r3, [r7, #24]
      break;
341837d4:	e005      	b.n	341837e2 <SystemCoreClockUpdate+0x222>
      break;
341837d6:	bf00      	nop
341837d8:	e004      	b.n	341837e4 <SystemCoreClockUpdate+0x224>
      break;
341837da:	bf00      	nop
341837dc:	e002      	b.n	341837e4 <SystemCoreClockUpdate+0x224>
      break;
341837de:	bf00      	nop
341837e0:	e000      	b.n	341837e4 <SystemCoreClockUpdate+0x224>
      break;
341837e2:	bf00      	nop
    switch (pllsource)
341837e4:	697b      	ldr	r3, [r7, #20]
341837e6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341837ea:	d02c      	beq.n	34183846 <SystemCoreClockUpdate+0x286>
341837ec:	697b      	ldr	r3, [r7, #20]
341837ee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341837f2:	d839      	bhi.n	34183868 <SystemCoreClockUpdate+0x2a8>
341837f4:	697b      	ldr	r3, [r7, #20]
341837f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341837fa:	d021      	beq.n	34183840 <SystemCoreClockUpdate+0x280>
341837fc:	697b      	ldr	r3, [r7, #20]
341837fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183802:	d831      	bhi.n	34183868 <SystemCoreClockUpdate+0x2a8>
34183804:	697b      	ldr	r3, [r7, #20]
34183806:	2b00      	cmp	r3, #0
34183808:	d004      	beq.n	34183814 <SystemCoreClockUpdate+0x254>
3418380a:	697b      	ldr	r3, [r7, #20]
3418380c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34183810:	d00a      	beq.n	34183828 <SystemCoreClockUpdate+0x268>
      break;
34183812:	e029      	b.n	34183868 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34183814:	4b0d      	ldr	r3, [pc, #52]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
34183816:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34183818:	09db      	lsrs	r3, r3, #7
3418381a:	f003 0303 	and.w	r3, r3, #3
3418381e:	4a0c      	ldr	r2, [pc, #48]	@ (34183850 <SystemCoreClockUpdate+0x290>)
34183820:	fa22 f303 	lsr.w	r3, r2, r3
34183824:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183826:	e020      	b.n	3418386a <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34183828:	4b08      	ldr	r3, [pc, #32]	@ (3418384c <SystemCoreClockUpdate+0x28c>)
3418382a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418382c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34183830:	2b00      	cmp	r3, #0
34183832:	d102      	bne.n	3418383a <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34183834:	4b07      	ldr	r3, [pc, #28]	@ (34183854 <SystemCoreClockUpdate+0x294>)
34183836:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183838:	e017      	b.n	3418386a <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
3418383a:	4b07      	ldr	r3, [pc, #28]	@ (34183858 <SystemCoreClockUpdate+0x298>)
3418383c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418383e:	e014      	b.n	3418386a <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34183840:	4b06      	ldr	r3, [pc, #24]	@ (3418385c <SystemCoreClockUpdate+0x29c>)
34183842:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183844:	e011      	b.n	3418386a <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34183846:	4b06      	ldr	r3, [pc, #24]	@ (34183860 <SystemCoreClockUpdate+0x2a0>)
34183848:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3418384a:	e00e      	b.n	3418386a <SystemCoreClockUpdate+0x2aa>
3418384c:	56028000 	.word	0x56028000
34183850:	03d09000 	.word	0x03d09000
34183854:	003d0900 	.word	0x003d0900
34183858:	00f42400 	.word	0x00f42400
3418385c:	02dc6c00 	.word	0x02dc6c00
34183860:	00bb8000 	.word	0x00bb8000
34183864:	4b800000 	.word	0x4b800000
      break;
34183868:	bf00      	nop
    if (pllbypass == 0U)
3418386a:	693b      	ldr	r3, [r7, #16]
3418386c:	2b00      	cmp	r3, #0
3418386e:	d134      	bne.n	341838da <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34183870:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183872:	ee07 3a90 	vmov	s15, r3
34183876:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418387a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418387c:	ee07 3a90 	vmov	s15, r3
34183880:	eef8 6a67 	vcvt.f32.u32	s13, s15
34183884:	6a3b      	ldr	r3, [r7, #32]
34183886:	ee07 3a90 	vmov	s15, r3
3418388a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3418388e:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34183864 <SystemCoreClockUpdate+0x2a4>
34183892:	eec6 7a25 	vdiv.f32	s15, s12, s11
34183896:	ee76 7aa7 	vadd.f32	s15, s13, s15
3418389a:	ee67 6a27 	vmul.f32	s13, s14, s15
3418389e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341838a0:	ee07 3a90 	vmov	s15, r3
341838a4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341838a8:	eec6 7a87 	vdiv.f32	s15, s13, s14
341838ac:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
341838b0:	69fb      	ldr	r3, [r7, #28]
341838b2:	ee07 3a90 	vmov	s15, r3
341838b6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341838ba:	69bb      	ldr	r3, [r7, #24]
341838bc:	ee07 3a90 	vmov	s15, r3
341838c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
341838c4:	ee27 7a27 	vmul.f32	s14, s14, s15
341838c8:	edd7 6a02 	vldr	s13, [r7, #8]
341838cc:	eec6 7a87 	vdiv.f32	s15, s13, s14
341838d0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
341838d4:	ee17 3a90 	vmov	r3, s15
341838d8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
341838da:	4b0b      	ldr	r3, [pc, #44]	@ (34183908 <SystemCoreClockUpdate+0x348>)
341838dc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341838e0:	0c1b      	lsrs	r3, r3, #16
341838e2:	b2db      	uxtb	r3, r3
341838e4:	3301      	adds	r3, #1
341838e6:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
341838e8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341838ea:	687b      	ldr	r3, [r7, #4]
341838ec:	fbb2 f3f3 	udiv	r3, r2, r3
341838f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341838f2:	e000      	b.n	341838f6 <SystemCoreClockUpdate+0x336>
    break;
341838f4:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
341838f6:	4a05      	ldr	r2, [pc, #20]	@ (3418390c <SystemCoreClockUpdate+0x34c>)
341838f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341838fa:	6013      	str	r3, [r2, #0]
}
341838fc:	bf00      	nop
341838fe:	3734      	adds	r7, #52	@ 0x34
34183900:	46bd      	mov	sp, r7
34183902:	f85d 7b04 	ldr.w	r7, [sp], #4
34183906:	4770      	bx	lr
34183908:	56028000 	.word	0x56028000
3418390c:	341c0024 	.word	0x341c0024

34183910 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34183910:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34183914:	b588      	push	{r3, r7, lr}
34183916:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34183918:	f7ff fe52 	bl	341835c0 <SystemCoreClockUpdate>

  return SystemCoreClock;
3418391c:	4b06      	ldr	r3, [pc, #24]	@ (34183938 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
3418391e:	681b      	ldr	r3, [r3, #0]
}
34183920:	4618      	mov	r0, r3
34183922:	46bd      	mov	sp, r7
34183924:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34183928:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
3418392c:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34183930:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34183934:	4774      	bxns	lr
34183936:	bf00      	nop
34183938:	341c0024 	.word	0x341c0024

3418393c <LL_AHB4_GRP1_EnableClock>:
{
3418393c:	b480      	push	{r7}
3418393e:	b085      	sub	sp, #20
34183940:	af00      	add	r7, sp, #0
34183942:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34183944:	4a07      	ldr	r2, [pc, #28]	@ (34183964 <LL_AHB4_GRP1_EnableClock+0x28>)
34183946:	687b      	ldr	r3, [r7, #4]
34183948:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3418394c:	4b05      	ldr	r3, [pc, #20]	@ (34183964 <LL_AHB4_GRP1_EnableClock+0x28>)
3418394e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34183952:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183954:	68fb      	ldr	r3, [r7, #12]
}
34183956:	bf00      	nop
34183958:	3714      	adds	r7, #20
3418395a:	46bd      	mov	sp, r7
3418395c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183960:	4770      	bx	lr
34183962:	bf00      	nop
34183964:	56028000 	.word	0x56028000

34183968 <LL_APB1_GRP1_EnableClock>:
{
34183968:	b480      	push	{r7}
3418396a:	b085      	sub	sp, #20
3418396c:	af00      	add	r7, sp, #0
3418396e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34183970:	4a07      	ldr	r2, [pc, #28]	@ (34183990 <LL_APB1_GRP1_EnableClock+0x28>)
34183972:	687b      	ldr	r3, [r7, #4]
34183974:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34183978:	4b05      	ldr	r3, [pc, #20]	@ (34183990 <LL_APB1_GRP1_EnableClock+0x28>)
3418397a:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
3418397e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183980:	68fb      	ldr	r3, [r7, #12]
}
34183982:	bf00      	nop
34183984:	3714      	adds	r7, #20
34183986:	46bd      	mov	sp, r7
34183988:	f85d 7b04 	ldr.w	r7, [sp], #4
3418398c:	4770      	bx	lr
3418398e:	bf00      	nop
34183990:	56028000 	.word	0x56028000

34183994 <LL_APB1_GRP1_DisableClock>:
{
34183994:	b480      	push	{r7}
34183996:	b083      	sub	sp, #12
34183998:	af00      	add	r7, sp, #0
3418399a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
3418399c:	4b06      	ldr	r3, [pc, #24]	@ (341839b8 <LL_APB1_GRP1_DisableClock+0x24>)
3418399e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341839a2:	461a      	mov	r2, r3
341839a4:	687b      	ldr	r3, [r7, #4]
341839a6:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
341839aa:	bf00      	nop
341839ac:	370c      	adds	r7, #12
341839ae:	46bd      	mov	sp, r7
341839b0:	f85d 7b04 	ldr.w	r7, [sp], #4
341839b4:	4770      	bx	lr
341839b6:	bf00      	nop
341839b8:	56028000 	.word	0x56028000

341839bc <LL_APB1_GRP1_ForceReset>:
{
341839bc:	b480      	push	{r7}
341839be:	b083      	sub	sp, #12
341839c0:	af00      	add	r7, sp, #0
341839c2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
341839c4:	4a04      	ldr	r2, [pc, #16]	@ (341839d8 <LL_APB1_GRP1_ForceReset+0x1c>)
341839c6:	687b      	ldr	r3, [r7, #4]
341839c8:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
}
341839cc:	bf00      	nop
341839ce:	370c      	adds	r7, #12
341839d0:	46bd      	mov	sp, r7
341839d2:	f85d 7b04 	ldr.w	r7, [sp], #4
341839d6:	4770      	bx	lr
341839d8:	56028000 	.word	0x56028000

341839dc <LL_APB1_GRP1_ReleaseReset>:
{
341839dc:	b480      	push	{r7}
341839de:	b083      	sub	sp, #12
341839e0:	af00      	add	r7, sp, #0
341839e2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
341839e4:	4b06      	ldr	r3, [pc, #24]	@ (34183a00 <LL_APB1_GRP1_ReleaseReset+0x24>)
341839e6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341839ea:	461a      	mov	r2, r3
341839ec:	687b      	ldr	r3, [r7, #4]
341839ee:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
}
341839f2:	bf00      	nop
341839f4:	370c      	adds	r7, #12
341839f6:	46bd      	mov	sp, r7
341839f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341839fc:	4770      	bx	lr
341839fe:	bf00      	nop
34183a00:	56028000 	.word	0x56028000

34183a04 <BSP_I2C1_Init>:
/**
  * @brief  Initializes I2C1 HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_Init(void)
{
34183a04:	b580      	push	{r7, lr}
34183a06:	b082      	sub	sp, #8
34183a08:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
34183a0a:	2300      	movs	r3, #0
34183a0c:	607b      	str	r3, [r7, #4]

  hbus_i2c1.Instance = BUS_I2C1;
34183a0e:	4b16      	ldr	r3, [pc, #88]	@ (34183a68 <BSP_I2C1_Init+0x64>)
34183a10:	4a16      	ldr	r2, [pc, #88]	@ (34183a6c <BSP_I2C1_Init+0x68>)
34183a12:	601a      	str	r2, [r3, #0]

  if (I2c1InitCounter == 0U)
34183a14:	4b16      	ldr	r3, [pc, #88]	@ (34183a70 <BSP_I2C1_Init+0x6c>)
34183a16:	681b      	ldr	r3, [r3, #0]
34183a18:	2b00      	cmp	r3, #0
34183a1a:	d11f      	bne.n	34183a5c <BSP_I2C1_Init+0x58>
  {
    I2c1InitCounter++;
34183a1c:	4b14      	ldr	r3, [pc, #80]	@ (34183a70 <BSP_I2C1_Init+0x6c>)
34183a1e:	681b      	ldr	r3, [r3, #0]
34183a20:	3301      	adds	r3, #1
34183a22:	4a13      	ldr	r2, [pc, #76]	@ (34183a70 <BSP_I2C1_Init+0x6c>)
34183a24:	6013      	str	r3, [r2, #0]

    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
34183a26:	4810      	ldr	r0, [pc, #64]	@ (34183a68 <BSP_I2C1_Init+0x64>)
34183a28:	f005 fc7a 	bl	34189320 <HAL_I2C_GetState>
34183a2c:	4603      	mov	r3, r0
34183a2e:	2b00      	cmp	r3, #0
34183a30:	d114      	bne.n	34183a5c <BSP_I2C1_Init+0x58>
        BspI2cSemaphore = osSemaphoreCreate(osSemaphore(BSP_I2C_SEM), 1);
      }
#endif /* BSP_USE_CMSIS_OS */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
      /* Init the I2C1 Msp */
      I2C1_MspInit(&hbus_i2c1);
34183a32:	480d      	ldr	r0, [pc, #52]	@ (34183a68 <BSP_I2C1_Init+0x64>)
34183a34:	f000 f8e2 	bl	34183bfc <I2C1_MspInit>
        }
      }
      if (ret == BSP_ERROR_NONE)
      {
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */
        if (MX_I2C1_Init(&hbus_i2c1, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C1_FREQUENCY)) != HAL_OK)
34183a38:	f008 fec1 	bl	3418c7be <HAL_RCC_GetPCLK1Freq>
34183a3c:	4603      	mov	r3, r0
34183a3e:	490d      	ldr	r1, [pc, #52]	@ (34183a74 <BSP_I2C1_Init+0x70>)
34183a40:	4618      	mov	r0, r3
34183a42:	f000 f991 	bl	34183d68 <I2C_GetTiming>
34183a46:	4603      	mov	r3, r0
34183a48:	4619      	mov	r1, r3
34183a4a:	4807      	ldr	r0, [pc, #28]	@ (34183a68 <BSP_I2C1_Init+0x64>)
34183a4c:	f000 f838 	bl	34183ac0 <MX_I2C1_Init>
34183a50:	4603      	mov	r3, r0
34183a52:	2b00      	cmp	r3, #0
34183a54:	d002      	beq.n	34183a5c <BSP_I2C1_Init+0x58>
        {
          ret = BSP_ERROR_BUS_FAILURE;
34183a56:	f06f 0307 	mvn.w	r3, #7
34183a5a:	607b      	str	r3, [r7, #4]
      }
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 1) */
    }
  }

  return ret;
34183a5c:	687b      	ldr	r3, [r7, #4]
}
34183a5e:	4618      	mov	r0, r3
34183a60:	3708      	adds	r7, #8
34183a62:	46bd      	mov	sp, r7
34183a64:	bd80      	pop	{r7, pc}
34183a66:	bf00      	nop
34183a68:	341c107c 	.word	0x341c107c
34183a6c:	50005400 	.word	0x50005400
34183a70:	341c0674 	.word	0x341c0674
34183a74:	000186a0 	.word	0x000186a0

34183a78 <BSP_I2C1_DeInit>:
/**
  * @brief  DeInitializes I2C1 HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_DeInit(void)
{
34183a78:	b580      	push	{r7, lr}
34183a7a:	b082      	sub	sp, #8
34183a7c:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
34183a7e:	2300      	movs	r3, #0
34183a80:	607b      	str	r3, [r7, #4]

  I2c1InitCounter--;
34183a82:	4b0d      	ldr	r3, [pc, #52]	@ (34183ab8 <BSP_I2C1_DeInit+0x40>)
34183a84:	681b      	ldr	r3, [r3, #0]
34183a86:	3b01      	subs	r3, #1
34183a88:	4a0b      	ldr	r2, [pc, #44]	@ (34183ab8 <BSP_I2C1_DeInit+0x40>)
34183a8a:	6013      	str	r3, [r2, #0]

  if (I2c1InitCounter == 0U)
34183a8c:	4b0a      	ldr	r3, [pc, #40]	@ (34183ab8 <BSP_I2C1_DeInit+0x40>)
34183a8e:	681b      	ldr	r3, [r3, #0]
34183a90:	2b00      	cmp	r3, #0
34183a92:	d10b      	bne.n	34183aac <BSP_I2C1_DeInit+0x34>
  {
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    I2C1_MspDeInit(&hbus_i2c1);
34183a94:	4809      	ldr	r0, [pc, #36]	@ (34183abc <BSP_I2C1_DeInit+0x44>)
34183a96:	f000 f8f3 	bl	34183c80 <I2C1_MspDeInit>
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */

    /* Init the I2C */
    if (HAL_I2C_DeInit(&hbus_i2c1) != HAL_OK)
34183a9a:	4808      	ldr	r0, [pc, #32]	@ (34183abc <BSP_I2C1_DeInit+0x44>)
34183a9c:	f005 f9e2 	bl	34188e64 <HAL_I2C_DeInit>
34183aa0:	4603      	mov	r3, r0
34183aa2:	2b00      	cmp	r3, #0
34183aa4:	d002      	beq.n	34183aac <BSP_I2C1_DeInit+0x34>
    {
      ret = BSP_ERROR_BUS_FAILURE;
34183aa6:	f06f 0307 	mvn.w	r3, #7
34183aaa:	607b      	str	r3, [r7, #4]
    }
  }

  return ret;
34183aac:	687b      	ldr	r3, [r7, #4]
}
34183aae:	4618      	mov	r0, r3
34183ab0:	3708      	adds	r7, #8
34183ab2:	46bd      	mov	sp, r7
34183ab4:	bd80      	pop	{r7, pc}
34183ab6:	bf00      	nop
34183ab8:	341c0674 	.word	0x341c0674
34183abc:	341c107c 	.word	0x341c107c

34183ac0 <MX_I2C1_Init>:
  * @param  hI2c I2C handle
  * @param  timing I2C timing
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_I2C1_Init(I2C_HandleTypeDef *hI2c, uint32_t timing)
{
34183ac0:	b580      	push	{r7, lr}
34183ac2:	b084      	sub	sp, #16
34183ac4:	af00      	add	r7, sp, #0
34183ac6:	6078      	str	r0, [r7, #4]
34183ac8:	6039      	str	r1, [r7, #0]
 HAL_StatusTypeDef status = HAL_OK;
34183aca:	2300      	movs	r3, #0
34183acc:	73fb      	strb	r3, [r7, #15]

 hI2c->Init.Timing           = timing;
34183ace:	687b      	ldr	r3, [r7, #4]
34183ad0:	683a      	ldr	r2, [r7, #0]
34183ad2:	605a      	str	r2, [r3, #4]
 hI2c->Init.OwnAddress1      = 0;
34183ad4:	687b      	ldr	r3, [r7, #4]
34183ad6:	2200      	movs	r2, #0
34183ad8:	609a      	str	r2, [r3, #8]
 hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34183ada:	687b      	ldr	r3, [r7, #4]
34183adc:	2201      	movs	r2, #1
34183ade:	60da      	str	r2, [r3, #12]
 hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
34183ae0:	687b      	ldr	r3, [r7, #4]
34183ae2:	2200      	movs	r2, #0
34183ae4:	611a      	str	r2, [r3, #16]
 hI2c->Init.OwnAddress2      = 0;
34183ae6:	687b      	ldr	r3, [r7, #4]
34183ae8:	2200      	movs	r2, #0
34183aea:	615a      	str	r2, [r3, #20]
 hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
34183aec:	687b      	ldr	r3, [r7, #4]
34183aee:	2200      	movs	r2, #0
34183af0:	619a      	str	r2, [r3, #24]
 hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
34183af2:	687b      	ldr	r3, [r7, #4]
34183af4:	2200      	movs	r2, #0
34183af6:	61da      	str	r2, [r3, #28]
 hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
34183af8:	687b      	ldr	r3, [r7, #4]
34183afa:	2200      	movs	r2, #0
34183afc:	621a      	str	r2, [r3, #32]

 if (HAL_I2C_Init(hI2c) != HAL_OK)
34183afe:	6878      	ldr	r0, [r7, #4]
34183b00:	f005 f915 	bl	34188d2e <HAL_I2C_Init>
34183b04:	4603      	mov	r3, r0
34183b06:	2b00      	cmp	r3, #0
34183b08:	d002      	beq.n	34183b10 <MX_I2C1_Init+0x50>
 {
   status = HAL_ERROR;
34183b0a:	2301      	movs	r3, #1
34183b0c:	73fb      	strb	r3, [r7, #15]
34183b0e:	e014      	b.n	34183b3a <MX_I2C1_Init+0x7a>
 }
 else
 {
   uint32_t analog_filter;

   analog_filter = I2C_ANALOGFILTER_ENABLE;
34183b10:	2300      	movs	r3, #0
34183b12:	60bb      	str	r3, [r7, #8]
   if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
34183b14:	68b9      	ldr	r1, [r7, #8]
34183b16:	6878      	ldr	r0, [r7, #4]
34183b18:	f005 fede 	bl	341898d8 <HAL_I2CEx_ConfigAnalogFilter>
34183b1c:	4603      	mov	r3, r0
34183b1e:	2b00      	cmp	r3, #0
34183b20:	d002      	beq.n	34183b28 <MX_I2C1_Init+0x68>
   {
     status = HAL_ERROR;
34183b22:	2301      	movs	r3, #1
34183b24:	73fb      	strb	r3, [r7, #15]
34183b26:	e008      	b.n	34183b3a <MX_I2C1_Init+0x7a>
   }
   else
   {
     if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
34183b28:	2100      	movs	r1, #0
34183b2a:	6878      	ldr	r0, [r7, #4]
34183b2c:	f005 ff1f 	bl	3418996e <HAL_I2CEx_ConfigDigitalFilter>
34183b30:	4603      	mov	r3, r0
34183b32:	2b00      	cmp	r3, #0
34183b34:	d001      	beq.n	34183b3a <MX_I2C1_Init+0x7a>
     {
       status = HAL_ERROR;
34183b36:	2301      	movs	r3, #1
34183b38:	73fb      	strb	r3, [r7, #15]
     }
   }
 }

 return status;
34183b3a:	7bfb      	ldrb	r3, [r7, #15]
}
34183b3c:	4618      	mov	r0, r3
34183b3e:	3710      	adds	r7, #16
34183b40:	46bd      	mov	sp, r7
34183b42:	bd80      	pop	{r7, pc}

34183b44 <BSP_I2C1_WriteReg16>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval BSP status
  */
int32_t BSP_I2C1_WriteReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
34183b44:	b580      	push	{r7, lr}
34183b46:	b088      	sub	sp, #32
34183b48:	af02      	add	r7, sp, #8
34183b4a:	60ba      	str	r2, [r7, #8]
34183b4c:	461a      	mov	r2, r3
34183b4e:	4603      	mov	r3, r0
34183b50:	81fb      	strh	r3, [r7, #14]
34183b52:	460b      	mov	r3, r1
34183b54:	81bb      	strh	r3, [r7, #12]
34183b56:	4613      	mov	r3, r2
34183b58:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C1_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
34183b5a:	89b9      	ldrh	r1, [r7, #12]
34183b5c:	89f8      	ldrh	r0, [r7, #14]
34183b5e:	88fb      	ldrh	r3, [r7, #6]
34183b60:	9300      	str	r3, [sp, #0]
34183b62:	68bb      	ldr	r3, [r7, #8]
34183b64:	2202      	movs	r2, #2
34183b66:	f000 f8ab 	bl	34183cc0 <I2C1_WriteReg>
34183b6a:	4603      	mov	r3, r0
34183b6c:	2b00      	cmp	r3, #0
34183b6e:	d102      	bne.n	34183b76 <BSP_I2C1_WriteReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
34183b70:	2300      	movs	r3, #0
34183b72:	617b      	str	r3, [r7, #20]
34183b74:	e00c      	b.n	34183b90 <BSP_I2C1_WriteReg16+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34183b76:	4809      	ldr	r0, [pc, #36]	@ (34183b9c <BSP_I2C1_WriteReg16+0x58>)
34183b78:	f005 fbe0 	bl	3418933c <HAL_I2C_GetError>
34183b7c:	4603      	mov	r3, r0
34183b7e:	2b04      	cmp	r3, #4
34183b80:	d103      	bne.n	34183b8a <BSP_I2C1_WriteReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183b82:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183b86:	617b      	str	r3, [r7, #20]
34183b88:	e002      	b.n	34183b90 <BSP_I2C1_WriteReg16+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183b8a:	f06f 0303 	mvn.w	r3, #3
34183b8e:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183b90:	697b      	ldr	r3, [r7, #20]
}
34183b92:	4618      	mov	r0, r3
34183b94:	3718      	adds	r7, #24
34183b96:	46bd      	mov	sp, r7
34183b98:	bd80      	pop	{r7, pc}
34183b9a:	bf00      	nop
34183b9c:	341c107c 	.word	0x341c107c

34183ba0 <BSP_I2C1_ReadReg16>:
  * @param  pData   Pointer to data buffer
  * @param  Length  Length of the data
  * @retval BSP status
  */
int32_t BSP_I2C1_ReadReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
34183ba0:	b580      	push	{r7, lr}
34183ba2:	b088      	sub	sp, #32
34183ba4:	af02      	add	r7, sp, #8
34183ba6:	60ba      	str	r2, [r7, #8]
34183ba8:	461a      	mov	r2, r3
34183baa:	4603      	mov	r3, r0
34183bac:	81fb      	strh	r3, [r7, #14]
34183bae:	460b      	mov	r3, r1
34183bb0:	81bb      	strh	r3, [r7, #12]
34183bb2:	4613      	mov	r3, r2
34183bb4:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C1_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
34183bb6:	89b9      	ldrh	r1, [r7, #12]
34183bb8:	89f8      	ldrh	r0, [r7, #14]
34183bba:	88fb      	ldrh	r3, [r7, #6]
34183bbc:	9300      	str	r3, [sp, #0]
34183bbe:	68bb      	ldr	r3, [r7, #8]
34183bc0:	2202      	movs	r2, #2
34183bc2:	f000 f8a3 	bl	34183d0c <I2C1_ReadReg>
34183bc6:	4603      	mov	r3, r0
34183bc8:	2b00      	cmp	r3, #0
34183bca:	d102      	bne.n	34183bd2 <BSP_I2C1_ReadReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
34183bcc:	2300      	movs	r3, #0
34183bce:	617b      	str	r3, [r7, #20]
34183bd0:	e00c      	b.n	34183bec <BSP_I2C1_ReadReg16+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34183bd2:	4809      	ldr	r0, [pc, #36]	@ (34183bf8 <BSP_I2C1_ReadReg16+0x58>)
34183bd4:	f005 fbb2 	bl	3418933c <HAL_I2C_GetError>
34183bd8:	4603      	mov	r3, r0
34183bda:	2b04      	cmp	r3, #4
34183bdc:	d103      	bne.n	34183be6 <BSP_I2C1_ReadReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183bde:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183be2:	617b      	str	r3, [r7, #20]
34183be4:	e002      	b.n	34183bec <BSP_I2C1_ReadReg16+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183be6:	f06f 0303 	mvn.w	r3, #3
34183bea:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183bec:	697b      	ldr	r3, [r7, #20]
}
34183bee:	4618      	mov	r0, r3
34183bf0:	3718      	adds	r7, #24
34183bf2:	46bd      	mov	sp, r7
34183bf4:	bd80      	pop	{r7, pc}
34183bf6:	bf00      	nop
34183bf8:	341c107c 	.word	0x341c107c

34183bfc <I2C1_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C1_MspInit(I2C_HandleTypeDef *phi2c)
{
34183bfc:	b580      	push	{r7, lr}
34183bfe:	b088      	sub	sp, #32
34183c00:	af00      	add	r7, sp, #0
34183c02:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Enable PWR for I2C1 pins */
  HAL_PWREx_EnableVddIO4();
34183c04:	f007 fcc0 	bl	3418b588 <HAL_PWREx_EnableVddIO4>

  /*** Configure the GPIOs ***/
  /* Enable SCL GPIO clock */
  BUS_I2C1_SCL_GPIO_CLK_ENABLE();
34183c08:	2080      	movs	r0, #128	@ 0x80
34183c0a:	f7ff fe97 	bl	3418393c <LL_AHB4_GRP1_EnableClock>
  /* Enable SDA GPIO clock */
  BUS_I2C1_SDA_GPIO_CLK_ENABLE();
34183c0e:	2004      	movs	r0, #4
34183c10:	f7ff fe94 	bl	3418393c <LL_AHB4_GRP1_EnableClock>

  /* Configure I2C Tx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C1_SCL_PIN;
34183c14:	f44f 7300 	mov.w	r3, #512	@ 0x200
34183c18:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183c1a:	2312      	movs	r3, #18
34183c1c:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183c1e:	2300      	movs	r3, #0
34183c20:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183c22:	2302      	movs	r3, #2
34183c24:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
34183c26:	2304      	movs	r3, #4
34183c28:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
34183c2a:	f107 030c 	add.w	r3, r7, #12
34183c2e:	4619      	mov	r1, r3
34183c30:	4811      	ldr	r0, [pc, #68]	@ (34183c78 <I2C1_MspInit+0x7c>)
34183c32:	f004 fd2b 	bl	3418868c <HAL_GPIO_Init>

  /* Configure I2C Rx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C1_SDA_PIN;
34183c36:	2302      	movs	r3, #2
34183c38:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183c3a:	2312      	movs	r3, #18
34183c3c:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183c3e:	2300      	movs	r3, #0
34183c40:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183c42:	2302      	movs	r3, #2
34183c44:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C1_SDA_AF;
34183c46:	2304      	movs	r3, #4
34183c48:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
34183c4a:	f107 030c 	add.w	r3, r7, #12
34183c4e:	4619      	mov	r1, r3
34183c50:	480a      	ldr	r0, [pc, #40]	@ (34183c7c <I2C1_MspInit+0x80>)
34183c52:	f004 fd1b 	bl	3418868c <HAL_GPIO_Init>

  /*** Configure the I2C peripheral ***/
  /* Enable I2C clock */
  BUS_I2C1_CLK_ENABLE();
34183c56:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183c5a:	f7ff fe85 	bl	34183968 <LL_APB1_GRP1_EnableClock>

  /* Force the I2C peripheral clock reset */
  BUS_I2C1_FORCE_RESET();
34183c5e:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183c62:	f7ff feab 	bl	341839bc <LL_APB1_GRP1_ForceReset>

  /* Release the I2C peripheral clock reset */
  BUS_I2C1_RELEASE_RESET();
34183c66:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183c6a:	f7ff feb7 	bl	341839dc <LL_APB1_GRP1_ReleaseReset>
}
34183c6e:	bf00      	nop
34183c70:	3720      	adds	r7, #32
34183c72:	46bd      	mov	sp, r7
34183c74:	bd80      	pop	{r7, pc}
34183c76:	bf00      	nop
34183c78:	56021c00 	.word	0x56021c00
34183c7c:	56020800 	.word	0x56020800

34183c80 <I2C1_MspDeInit>:
  * @brief  DeInitializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C1_MspDeInit(I2C_HandleTypeDef *phi2c)
{
34183c80:	b580      	push	{r7, lr}
34183c82:	b088      	sub	sp, #32
34183c84:	af00      	add	r7, sp, #0
34183c86:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Configure I2C Tx, Rx as alternate function */
  gpio_init_structure.Pin = BUS_I2C1_SCL_PIN;
34183c88:	f44f 7300 	mov.w	r3, #512	@ 0x200
34183c8c:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, gpio_init_structure.Pin );
34183c8e:	68fb      	ldr	r3, [r7, #12]
34183c90:	4619      	mov	r1, r3
34183c92:	4809      	ldr	r0, [pc, #36]	@ (34183cb8 <I2C1_MspDeInit+0x38>)
34183c94:	f004 feac 	bl	341889f0 <HAL_GPIO_DeInit>
  gpio_init_structure.Pin = BUS_I2C1_SDA_PIN;
34183c98:	2302      	movs	r3, #2
34183c9a:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, gpio_init_structure.Pin);
34183c9c:	68fb      	ldr	r3, [r7, #12]
34183c9e:	4619      	mov	r1, r3
34183ca0:	4806      	ldr	r0, [pc, #24]	@ (34183cbc <I2C1_MspDeInit+0x3c>)
34183ca2:	f004 fea5 	bl	341889f0 <HAL_GPIO_DeInit>

  /* Disable I2C clock */
  BUS_I2C1_CLK_DISABLE();
34183ca6:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183caa:	f7ff fe73 	bl	34183994 <LL_APB1_GRP1_DisableClock>
}
34183cae:	bf00      	nop
34183cb0:	3720      	adds	r7, #32
34183cb2:	46bd      	mov	sp, r7
34183cb4:	bd80      	pop	{r7, pc}
34183cb6:	bf00      	nop
34183cb8:	56021c00 	.word	0x56021c00
34183cbc:	56020800 	.word	0x56020800

34183cc0 <I2C1_WriteReg>:
  * @param  pData      The target register value to be written
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C1_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
34183cc0:	b580      	push	{r7, lr}
34183cc2:	b088      	sub	sp, #32
34183cc4:	af04      	add	r7, sp, #16
34183cc6:	607b      	str	r3, [r7, #4]
34183cc8:	4603      	mov	r3, r0
34183cca:	81fb      	strh	r3, [r7, #14]
34183ccc:	460b      	mov	r3, r1
34183cce:	81bb      	strh	r3, [r7, #12]
34183cd0:	4613      	mov	r3, r2
34183cd2:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34183cd4:	8978      	ldrh	r0, [r7, #10]
34183cd6:	89ba      	ldrh	r2, [r7, #12]
34183cd8:	89f9      	ldrh	r1, [r7, #14]
34183cda:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34183cde:	9302      	str	r3, [sp, #8]
34183ce0:	8b3b      	ldrh	r3, [r7, #24]
34183ce2:	9301      	str	r3, [sp, #4]
34183ce4:	687b      	ldr	r3, [r7, #4]
34183ce6:	9300      	str	r3, [sp, #0]
34183ce8:	4603      	mov	r3, r0
34183cea:	4807      	ldr	r0, [pc, #28]	@ (34183d08 <I2C1_WriteReg+0x48>)
34183cec:	f005 f8ea 	bl	34188ec4 <HAL_I2C_Mem_Write>
34183cf0:	4603      	mov	r3, r0
34183cf2:	2b00      	cmp	r3, #0
34183cf4:	d101      	bne.n	34183cfa <I2C1_WriteReg+0x3a>
  {
    return BSP_ERROR_NONE;
34183cf6:	2300      	movs	r3, #0
34183cf8:	e001      	b.n	34183cfe <I2C1_WriteReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
34183cfa:	f06f 0307 	mvn.w	r3, #7
}
34183cfe:	4618      	mov	r0, r3
34183d00:	3710      	adds	r7, #16
34183d02:	46bd      	mov	sp, r7
34183d04:	bd80      	pop	{r7, pc}
34183d06:	bf00      	nop
34183d08:	341c107c 	.word	0x341c107c

34183d0c <I2C1_ReadReg>:
  * @param  pData      The target register value to be read
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C1_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
34183d0c:	b580      	push	{r7, lr}
34183d0e:	b088      	sub	sp, #32
34183d10:	af04      	add	r7, sp, #16
34183d12:	607b      	str	r3, [r7, #4]
34183d14:	4603      	mov	r3, r0
34183d16:	81fb      	strh	r3, [r7, #14]
34183d18:	460b      	mov	r3, r1
34183d1a:	81bb      	strh	r3, [r7, #12]
34183d1c:	4613      	mov	r3, r2
34183d1e:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34183d20:	8978      	ldrh	r0, [r7, #10]
34183d22:	89ba      	ldrh	r2, [r7, #12]
34183d24:	89f9      	ldrh	r1, [r7, #14]
34183d26:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34183d2a:	9302      	str	r3, [sp, #8]
34183d2c:	8b3b      	ldrh	r3, [r7, #24]
34183d2e:	9301      	str	r3, [sp, #4]
34183d30:	687b      	ldr	r3, [r7, #4]
34183d32:	9300      	str	r3, [sp, #0]
34183d34:	4603      	mov	r3, r0
34183d36:	4807      	ldr	r0, [pc, #28]	@ (34183d54 <I2C1_ReadReg+0x48>)
34183d38:	f005 f9d8 	bl	341890ec <HAL_I2C_Mem_Read>
34183d3c:	4603      	mov	r3, r0
34183d3e:	2b00      	cmp	r3, #0
34183d40:	d101      	bne.n	34183d46 <I2C1_ReadReg+0x3a>
  {
    return BSP_ERROR_NONE;
34183d42:	2300      	movs	r3, #0
34183d44:	e001      	b.n	34183d4a <I2C1_ReadReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
34183d46:	f06f 0307 	mvn.w	r3, #7
}
34183d4a:	4618      	mov	r0, r3
34183d4c:	3710      	adds	r7, #16
34183d4e:	46bd      	mov	sp, r7
34183d50:	bd80      	pop	{r7, pc}
34183d52:	bf00      	nop
34183d54:	341c107c 	.word	0x341c107c

34183d58 <BSP_GetTick>:
/**
  * @brief  Delay function
  * @retval Tick value
  */
int32_t BSP_GetTick(void)
{
34183d58:	b580      	push	{r7, lr}
34183d5a:	af00      	add	r7, sp, #0
  return (int32_t)HAL_GetTick();
34183d5c:	f001 faf8 	bl	34185350 <HAL_GetTick>
34183d60:	4603      	mov	r3, r0
}
34183d62:	4618      	mov	r0, r3
34183d64:	bd80      	pop	{r7, pc}
	...

34183d68 <I2C_GetTiming>:
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
{
34183d68:	b580      	push	{r7, lr}
34183d6a:	b086      	sub	sp, #24
34183d6c:	af00      	add	r7, sp, #0
34183d6e:	6078      	str	r0, [r7, #4]
34183d70:	6039      	str	r1, [r7, #0]
  uint32_t ret = 0;
34183d72:	2300      	movs	r3, #0
34183d74:	617b      	str	r3, [r7, #20]
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
34183d76:	687b      	ldr	r3, [r7, #4]
34183d78:	2b00      	cmp	r3, #0
34183d7a:	d06b      	beq.n	34183e54 <I2C_GetTiming+0xec>
34183d7c:	683b      	ldr	r3, [r7, #0]
34183d7e:	2b00      	cmp	r3, #0
34183d80:	d068      	beq.n	34183e54 <I2C_GetTiming+0xec>
  {
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34183d82:	2300      	movs	r3, #0
34183d84:	613b      	str	r3, [r7, #16]
34183d86:	e060      	b.n	34183e4a <I2C_GetTiming+0xe2>
    {
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183d88:	4a35      	ldr	r2, [pc, #212]	@ (34183e60 <I2C_GetTiming+0xf8>)
34183d8a:	693b      	ldr	r3, [r7, #16]
34183d8c:	212c      	movs	r1, #44	@ 0x2c
34183d8e:	fb01 f303 	mul.w	r3, r1, r3
34183d92:	4413      	add	r3, r2
34183d94:	3304      	adds	r3, #4
34183d96:	681b      	ldr	r3, [r3, #0]
34183d98:	683a      	ldr	r2, [r7, #0]
34183d9a:	429a      	cmp	r2, r3
34183d9c:	d352      	bcc.n	34183e44 <I2C_GetTiming+0xdc>
          (i2c_freq <= I2C_Charac[speed].freq_max))
34183d9e:	4a30      	ldr	r2, [pc, #192]	@ (34183e60 <I2C_GetTiming+0xf8>)
34183da0:	693b      	ldr	r3, [r7, #16]
34183da2:	212c      	movs	r1, #44	@ 0x2c
34183da4:	fb01 f303 	mul.w	r3, r1, r3
34183da8:	4413      	add	r3, r2
34183daa:	3308      	adds	r3, #8
34183dac:	681b      	ldr	r3, [r3, #0]
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183dae:	683a      	ldr	r2, [r7, #0]
34183db0:	429a      	cmp	r2, r3
34183db2:	d847      	bhi.n	34183e44 <I2C_GetTiming+0xdc>
      {
        I2C_Compute_PRESC_SCLDEL_SDADEL(clock_src_freq, speed);
34183db4:	6939      	ldr	r1, [r7, #16]
34183db6:	6878      	ldr	r0, [r7, #4]
34183db8:	f000 f856 	bl	34183e68 <I2C_Compute_PRESC_SCLDEL_SDADEL>
        idx = I2C_Compute_SCLL_SCLH(clock_src_freq, speed);
34183dbc:	6939      	ldr	r1, [r7, #16]
34183dbe:	6878      	ldr	r0, [r7, #4]
34183dc0:	f000 f940 	bl	34184044 <I2C_Compute_SCLL_SCLH>
34183dc4:	60f8      	str	r0, [r7, #12]

        if (idx < I2C_VALID_TIMING_NBR)
34183dc6:	68fb      	ldr	r3, [r7, #12]
34183dc8:	2b7f      	cmp	r3, #127	@ 0x7f
34183dca:	d842      	bhi.n	34183e52 <I2C_GetTiming+0xea>
        {
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183dcc:	4925      	ldr	r1, [pc, #148]	@ (34183e64 <I2C_GetTiming+0xfc>)
34183dce:	68fa      	ldr	r2, [r7, #12]
34183dd0:	4613      	mov	r3, r2
34183dd2:	009b      	lsls	r3, r3, #2
34183dd4:	4413      	add	r3, r2
34183dd6:	009b      	lsls	r3, r3, #2
34183dd8:	440b      	add	r3, r1
34183dda:	681b      	ldr	r3, [r3, #0]
34183ddc:	0719      	lsls	r1, r3, #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183dde:	4821      	ldr	r0, [pc, #132]	@ (34183e64 <I2C_GetTiming+0xfc>)
34183de0:	68fa      	ldr	r2, [r7, #12]
34183de2:	4613      	mov	r3, r2
34183de4:	009b      	lsls	r3, r3, #2
34183de6:	4413      	add	r3, r2
34183de8:	009b      	lsls	r3, r3, #2
34183dea:	4403      	add	r3, r0
34183dec:	3304      	adds	r3, #4
34183dee:	681b      	ldr	r3, [r3, #0]
34183df0:	051b      	lsls	r3, r3, #20
34183df2:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183df6:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183df8:	481a      	ldr	r0, [pc, #104]	@ (34183e64 <I2C_GetTiming+0xfc>)
34183dfa:	68fa      	ldr	r2, [r7, #12]
34183dfc:	4613      	mov	r3, r2
34183dfe:	009b      	lsls	r3, r3, #2
34183e00:	4413      	add	r3, r2
34183e02:	009b      	lsls	r3, r3, #2
34183e04:	4403      	add	r3, r0
34183e06:	3308      	adds	r3, #8
34183e08:	681b      	ldr	r3, [r3, #0]
34183e0a:	041b      	lsls	r3, r3, #16
34183e0c:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183e10:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
34183e12:	4814      	ldr	r0, [pc, #80]	@ (34183e64 <I2C_GetTiming+0xfc>)
34183e14:	68fa      	ldr	r2, [r7, #12]
34183e16:	4613      	mov	r3, r2
34183e18:	009b      	lsls	r3, r3, #2
34183e1a:	4413      	add	r3, r2
34183e1c:	009b      	lsls	r3, r3, #2
34183e1e:	4403      	add	r3, r0
34183e20:	330c      	adds	r3, #12
34183e22:	681b      	ldr	r3, [r3, #0]
34183e24:	021b      	lsls	r3, r3, #8
34183e26:	b29b      	uxth	r3, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183e28:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
34183e2a:	480e      	ldr	r0, [pc, #56]	@ (34183e64 <I2C_GetTiming+0xfc>)
34183e2c:	68fa      	ldr	r2, [r7, #12]
34183e2e:	4613      	mov	r3, r2
34183e30:	009b      	lsls	r3, r3, #2
34183e32:	4413      	add	r3, r2
34183e34:	009b      	lsls	r3, r3, #2
34183e36:	4403      	add	r3, r0
34183e38:	3310      	adds	r3, #16
34183e3a:	681b      	ldr	r3, [r3, #0]
34183e3c:	b2db      	uxtb	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183e3e:	430b      	orrs	r3, r1
34183e40:	617b      	str	r3, [r7, #20]
        }
        break;
34183e42:	e006      	b.n	34183e52 <I2C_GetTiming+0xea>
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34183e44:	693b      	ldr	r3, [r7, #16]
34183e46:	3301      	adds	r3, #1
34183e48:	613b      	str	r3, [r7, #16]
34183e4a:	693b      	ldr	r3, [r7, #16]
34183e4c:	2b02      	cmp	r3, #2
34183e4e:	d99b      	bls.n	34183d88 <I2C_GetTiming+0x20>
34183e50:	e000      	b.n	34183e54 <I2C_GetTiming+0xec>
        break;
34183e52:	bf00      	nop
      }
    }
  }

  return ret;
34183e54:	697b      	ldr	r3, [r7, #20]
}
34183e56:	4618      	mov	r0, r3
34183e58:	3718      	adds	r7, #24
34183e5a:	46bd      	mov	sp, r7
34183e5c:	bd80      	pop	{r7, pc}
34183e5e:	bf00      	nop
34183e60:	341b0e7c 	.word	0x341b0e7c
34183e64:	341c0678 	.word	0x341c0678

34183e68 <I2C_Compute_PRESC_SCLDEL_SDADEL>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval None.
  */
static void I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed)
{
34183e68:	b480      	push	{r7}
34183e6a:	b08f      	sub	sp, #60	@ 0x3c
34183e6c:	af00      	add	r7, sp, #0
34183e6e:	6078      	str	r0, [r7, #4]
34183e70:	6039      	str	r1, [r7, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
34183e72:	2310      	movs	r3, #16
34183e74:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34183e76:	687b      	ldr	r3, [r7, #4]
34183e78:	085a      	lsrs	r2, r3, #1
34183e7a:	4b6e      	ldr	r3, [pc, #440]	@ (34184034 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1cc>)
34183e7c:	4413      	add	r3, r2
34183e7e:	687a      	ldr	r2, [r7, #4]
34183e80:	fbb3 f3f2 	udiv	r3, r3, r2
34183e84:	61fb      	str	r3, [r7, #28]

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
34183e86:	2332      	movs	r3, #50	@ 0x32
34183e88:	61bb      	str	r3, [r7, #24]
  tafdel_max = I2C_ANALOG_FILTER_DELAY_MAX;
34183e8a:	f44f 7382 	mov.w	r3, #260	@ 0x104
34183e8e:	617b      	str	r3, [r7, #20]
  /* tDNF = DNF x tI2CCLK
     tPRESC = (PRESC+1) x tI2CCLK
     SDADEL >= {tf +tHD;DAT(min) - tAF(min) - tDNF - [3 x tI2CCLK]} / tPRESC
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183e90:	4a69      	ldr	r2, [pc, #420]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183e92:	683b      	ldr	r3, [r7, #0]
34183e94:	212c      	movs	r1, #44	@ 0x2c
34183e96:	fb01 f303 	mul.w	r3, r1, r3
34183e9a:	4413      	add	r3, r2
34183e9c:	3324      	adds	r3, #36	@ 0x24
34183e9e:	681b      	ldr	r3, [r3, #0]
34183ea0:	4618      	mov	r0, r3
34183ea2:	4a65      	ldr	r2, [pc, #404]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183ea4:	683b      	ldr	r3, [r7, #0]
34183ea6:	212c      	movs	r1, #44	@ 0x2c
34183ea8:	fb01 f303 	mul.w	r3, r1, r3
34183eac:	4413      	add	r3, r2
34183eae:	330c      	adds	r3, #12
34183eb0:	681b      	ldr	r3, [r3, #0]
34183eb2:	18c2      	adds	r2, r0, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34183eb4:	69bb      	ldr	r3, [r7, #24]
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183eb6:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34183eb8:	495f      	ldr	r1, [pc, #380]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183eba:	683b      	ldr	r3, [r7, #0]
34183ebc:	202c      	movs	r0, #44	@ 0x2c
34183ebe:	fb00 f303 	mul.w	r3, r0, r3
34183ec2:	440b      	add	r3, r1
34183ec4:	3328      	adds	r3, #40	@ 0x28
34183ec6:	681b      	ldr	r3, [r3, #0]
34183ec8:	3303      	adds	r3, #3
34183eca:	69f9      	ldr	r1, [r7, #28]
34183ecc:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34183ed0:	1ad3      	subs	r3, r2, r3
34183ed2:	633b      	str	r3, [r7, #48]	@ 0x30

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183ed4:	4a58      	ldr	r2, [pc, #352]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183ed6:	683b      	ldr	r3, [r7, #0]
34183ed8:	212c      	movs	r1, #44	@ 0x2c
34183eda:	fb01 f303 	mul.w	r3, r1, r3
34183ede:	4413      	add	r3, r2
34183ee0:	3310      	adds	r3, #16
34183ee2:	681b      	ldr	r3, [r3, #0]
34183ee4:	4618      	mov	r0, r3
34183ee6:	4a54      	ldr	r2, [pc, #336]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183ee8:	683b      	ldr	r3, [r7, #0]
34183eea:	212c      	movs	r1, #44	@ 0x2c
34183eec:	fb01 f303 	mul.w	r3, r1, r3
34183ef0:	4413      	add	r3, r2
34183ef2:	3320      	adds	r3, #32
34183ef4:	681b      	ldr	r3, [r3, #0]
34183ef6:	1ac2      	subs	r2, r0, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
34183ef8:	697b      	ldr	r3, [r7, #20]
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183efa:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
34183efc:	494e      	ldr	r1, [pc, #312]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183efe:	683b      	ldr	r3, [r7, #0]
34183f00:	202c      	movs	r0, #44	@ 0x2c
34183f02:	fb00 f303 	mul.w	r3, r0, r3
34183f06:	440b      	add	r3, r1
34183f08:	3328      	adds	r3, #40	@ 0x28
34183f0a:	681b      	ldr	r3, [r3, #0]
34183f0c:	3304      	adds	r3, #4
34183f0e:	69f9      	ldr	r1, [r7, #28]
34183f10:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34183f14:	1ad3      	subs	r3, r2, r3
34183f16:	62fb      	str	r3, [r7, #44]	@ 0x2c


  /* {[tr+ tSU;DAT(min)] / [tPRESC]} - 1 <= SCLDEL */
  tscldel_min = (int32_t)I2C_Charac[I2C_speed].trise + (int32_t)I2C_Charac[I2C_speed].sudat_min;
34183f18:	4a47      	ldr	r2, [pc, #284]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183f1a:	683b      	ldr	r3, [r7, #0]
34183f1c:	212c      	movs	r1, #44	@ 0x2c
34183f1e:	fb01 f303 	mul.w	r3, r1, r3
34183f22:	4413      	add	r3, r2
34183f24:	3320      	adds	r3, #32
34183f26:	681b      	ldr	r3, [r3, #0]
34183f28:	4618      	mov	r0, r3
34183f2a:	4a43      	ldr	r2, [pc, #268]	@ (34184038 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34183f2c:	683b      	ldr	r3, [r7, #0]
34183f2e:	212c      	movs	r1, #44	@ 0x2c
34183f30:	fb01 f303 	mul.w	r3, r1, r3
34183f34:	4413      	add	r3, r2
34183f36:	3314      	adds	r3, #20
34183f38:	681b      	ldr	r3, [r3, #0]
34183f3a:	4403      	add	r3, r0
34183f3c:	613b      	str	r3, [r7, #16]

  if (tsdadel_min <= 0)
34183f3e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f40:	2b00      	cmp	r3, #0
34183f42:	dc01      	bgt.n	34183f48 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xe0>
  {
    tsdadel_min = 0;
34183f44:	2300      	movs	r3, #0
34183f46:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (tsdadel_max <= 0)
34183f48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183f4a:	2b00      	cmp	r3, #0
34183f4c:	dc01      	bgt.n	34183f52 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xea>
  {
    tsdadel_max = 0;
34183f4e:	2300      	movs	r3, #0
34183f50:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34183f52:	2300      	movs	r3, #0
34183f54:	62bb      	str	r3, [r7, #40]	@ 0x28
34183f56:	e062      	b.n	3418401e <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1b6>
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
34183f58:	2300      	movs	r3, #0
34183f5a:	627b      	str	r3, [r7, #36]	@ 0x24
34183f5c:	e059      	b.n	34184012 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1aa>
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
34183f5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183f60:	3301      	adds	r3, #1
34183f62:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183f64:	3201      	adds	r2, #1
34183f66:	fb03 f202 	mul.w	r2, r3, r2
34183f6a:	69fb      	ldr	r3, [r7, #28]
34183f6c:	fb02 f303 	mul.w	r3, r2, r3
34183f70:	60fb      	str	r3, [r7, #12]

      if (tscldel >= (uint32_t)tscldel_min)
34183f72:	693b      	ldr	r3, [r7, #16]
34183f74:	68fa      	ldr	r2, [r7, #12]
34183f76:	429a      	cmp	r2, r3
34183f78:	d348      	bcc.n	3418400c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1a4>
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34183f7a:	2300      	movs	r3, #0
34183f7c:	623b      	str	r3, [r7, #32]
34183f7e:	e042      	b.n	34184006 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x19e>
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;
34183f80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183f82:	3301      	adds	r3, #1
34183f84:	6a3a      	ldr	r2, [r7, #32]
34183f86:	fb03 f202 	mul.w	r2, r3, r2
34183f8a:	69fb      	ldr	r3, [r7, #28]
34183f8c:	fb02 f303 	mul.w	r3, r2, r3
34183f90:	60bb      	str	r3, [r7, #8]

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
34183f92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34183f94:	68ba      	ldr	r2, [r7, #8]
34183f96:	429a      	cmp	r2, r3
34183f98:	d332      	bcc.n	34184000 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
34183f9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183f9c:	68ba      	ldr	r2, [r7, #8]
34183f9e:	429a      	cmp	r2, r3
34183fa0:	d82e      	bhi.n	34184000 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
          {
            if (presc != prev_presc)
34183fa2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183fa4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34183fa6:	429a      	cmp	r2, r3
34183fa8:	d02a      	beq.n	34184000 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
34183faa:	4b24      	ldr	r3, [pc, #144]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183fac:	681a      	ldr	r2, [r3, #0]
34183fae:	4924      	ldr	r1, [pc, #144]	@ (34184040 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183fb0:	4613      	mov	r3, r2
34183fb2:	009b      	lsls	r3, r3, #2
34183fb4:	4413      	add	r3, r2
34183fb6:	009b      	lsls	r3, r3, #2
34183fb8:	440b      	add	r3, r1
34183fba:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34183fbc:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
34183fbe:	4b1f      	ldr	r3, [pc, #124]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183fc0:	681a      	ldr	r2, [r3, #0]
34183fc2:	491f      	ldr	r1, [pc, #124]	@ (34184040 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183fc4:	4613      	mov	r3, r2
34183fc6:	009b      	lsls	r3, r3, #2
34183fc8:	4413      	add	r3, r2
34183fca:	009b      	lsls	r3, r3, #2
34183fcc:	440b      	add	r3, r1
34183fce:	3304      	adds	r3, #4
34183fd0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34183fd2:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
34183fd4:	4b19      	ldr	r3, [pc, #100]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183fd6:	681a      	ldr	r2, [r3, #0]
34183fd8:	4919      	ldr	r1, [pc, #100]	@ (34184040 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34183fda:	4613      	mov	r3, r2
34183fdc:	009b      	lsls	r3, r3, #2
34183fde:	4413      	add	r3, r2
34183fe0:	009b      	lsls	r3, r3, #2
34183fe2:	440b      	add	r3, r1
34183fe4:	3308      	adds	r3, #8
34183fe6:	6a3a      	ldr	r2, [r7, #32]
34183fe8:	601a      	str	r2, [r3, #0]
              prev_presc = presc;
34183fea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183fec:	637b      	str	r3, [r7, #52]	@ 0x34
              I2c_valid_timing_nbr ++;
34183fee:	4b13      	ldr	r3, [pc, #76]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183ff0:	681b      	ldr	r3, [r3, #0]
34183ff2:	3301      	adds	r3, #1
34183ff4:	4a11      	ldr	r2, [pc, #68]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183ff6:	6013      	str	r3, [r2, #0]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
34183ff8:	4b10      	ldr	r3, [pc, #64]	@ (3418403c <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34183ffa:	681b      	ldr	r3, [r3, #0]
34183ffc:	2b7f      	cmp	r3, #127	@ 0x7f
34183ffe:	d812      	bhi.n	34184026 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1be>
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
34184000:	6a3b      	ldr	r3, [r7, #32]
34184002:	3301      	adds	r3, #1
34184004:	623b      	str	r3, [r7, #32]
34184006:	6a3b      	ldr	r3, [r7, #32]
34184008:	2b0f      	cmp	r3, #15
3418400a:	d9b9      	bls.n	34183f80 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x118>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
3418400c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418400e:	3301      	adds	r3, #1
34184010:	627b      	str	r3, [r7, #36]	@ 0x24
34184012:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184014:	2b0f      	cmp	r3, #15
34184016:	d9a2      	bls.n	34183f5e <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf6>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34184018:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418401a:	3301      	adds	r3, #1
3418401c:	62bb      	str	r3, [r7, #40]	@ 0x28
3418401e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184020:	2b0f      	cmp	r3, #15
34184022:	d999      	bls.n	34183f58 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf0>
34184024:	e000      	b.n	34184028 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1c0>
              {
                return;
34184026:	bf00      	nop
          }
        }
      }
    }
  }
}
34184028:	373c      	adds	r7, #60	@ 0x3c
3418402a:	46bd      	mov	sp, r7
3418402c:	f85d 7b04 	ldr.w	r7, [sp], #4
34184030:	4770      	bx	lr
34184032:	bf00      	nop
34184034:	3b9aca00 	.word	0x3b9aca00
34184038:	341b0e7c 	.word	0x341b0e7c
3418403c:	341c1078 	.word	0x341c1078
34184040:	341c0678 	.word	0x341c0678

34184044 <I2C_Compute_SCLL_SCLH>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval config index (0 to I2C_VALID_TIMING_NBR], 0xFFFFFFFF for no valid config.
  */
static uint32_t I2C_Compute_SCLL_SCLH (uint32_t clock_src_freq, uint32_t I2C_speed)
{
34184044:	b480      	push	{r7}
34184046:	b093      	sub	sp, #76	@ 0x4c
34184048:	af00      	add	r7, sp, #0
3418404a:	6078      	str	r0, [r7, #4]
3418404c:	6039      	str	r1, [r7, #0]
 uint32_t ret = 0xFFFFFFFFU;
3418404e:	f04f 33ff 	mov.w	r3, #4294967295
34184052:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t clk_max;
  uint32_t scll;
  uint32_t sclh;
  uint32_t tafdel_min;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34184054:	687b      	ldr	r3, [r7, #4]
34184056:	085a      	lsrs	r2, r3, #1
34184058:	4b7a      	ldr	r3, [pc, #488]	@ (34184244 <I2C_Compute_SCLL_SCLH+0x200>)
3418405a:	4413      	add	r3, r2
3418405c:	687a      	ldr	r2, [r7, #4]
3418405e:	fbb3 f3f2 	udiv	r3, r3, r2
34184062:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ti2cspeed = (SEC2NSEC + (I2C_Charac[I2C_speed].freq / 2U))/ I2C_Charac[I2C_speed].freq;
34184064:	4a78      	ldr	r2, [pc, #480]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
34184066:	683b      	ldr	r3, [r7, #0]
34184068:	212c      	movs	r1, #44	@ 0x2c
3418406a:	fb01 f303 	mul.w	r3, r1, r3
3418406e:	4413      	add	r3, r2
34184070:	681b      	ldr	r3, [r3, #0]
34184072:	085a      	lsrs	r2, r3, #1
34184074:	4b73      	ldr	r3, [pc, #460]	@ (34184244 <I2C_Compute_SCLL_SCLH+0x200>)
34184076:	4413      	add	r3, r2
34184078:	4973      	ldr	r1, [pc, #460]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
3418407a:	683a      	ldr	r2, [r7, #0]
3418407c:	202c      	movs	r0, #44	@ 0x2c
3418407e:	fb00 f202 	mul.w	r2, r0, r2
34184082:	440a      	add	r2, r1
34184084:	6812      	ldr	r2, [r2, #0]
34184086:	fbb3 f3f2 	udiv	r3, r3, r2
3418408a:	62bb      	str	r3, [r7, #40]	@ 0x28

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
3418408c:	2332      	movs	r3, #50	@ 0x32
3418408e:	627b      	str	r3, [r7, #36]	@ 0x24

  /* tDNF = DNF x tI2CCLK */
  dnf_delay = I2C_Charac[I2C_speed].dnf * ti2cclk;
34184090:	4a6d      	ldr	r2, [pc, #436]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
34184092:	683b      	ldr	r3, [r7, #0]
34184094:	212c      	movs	r1, #44	@ 0x2c
34184096:	fb01 f303 	mul.w	r3, r1, r3
3418409a:	4413      	add	r3, r2
3418409c:	3328      	adds	r3, #40	@ 0x28
3418409e:	681a      	ldr	r2, [r3, #0]
341840a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341840a2:	fb02 f303 	mul.w	r3, r2, r3
341840a6:	623b      	str	r3, [r7, #32]

  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
341840a8:	4a67      	ldr	r2, [pc, #412]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
341840aa:	683b      	ldr	r3, [r7, #0]
341840ac:	212c      	movs	r1, #44	@ 0x2c
341840ae:	fb01 f303 	mul.w	r3, r1, r3
341840b2:	4413      	add	r3, r2
341840b4:	3304      	adds	r3, #4
341840b6:	681b      	ldr	r3, [r3, #0]
341840b8:	4a62      	ldr	r2, [pc, #392]	@ (34184244 <I2C_Compute_SCLL_SCLH+0x200>)
341840ba:	fbb2 f3f3 	udiv	r3, r2, r3
341840be:	61fb      	str	r3, [r7, #28]
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;
341840c0:	4a61      	ldr	r2, [pc, #388]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
341840c2:	683b      	ldr	r3, [r7, #0]
341840c4:	212c      	movs	r1, #44	@ 0x2c
341840c6:	fb01 f303 	mul.w	r3, r1, r3
341840ca:	4413      	add	r3, r2
341840cc:	3308      	adds	r3, #8
341840ce:	681b      	ldr	r3, [r3, #0]
341840d0:	4a5c      	ldr	r2, [pc, #368]	@ (34184244 <I2C_Compute_SCLL_SCLH+0x200>)
341840d2:	fbb2 f3f3 	udiv	r3, r2, r3
341840d6:	61bb      	str	r3, [r7, #24]

  prev_error = ti2cspeed;
341840d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341840da:	643b      	str	r3, [r7, #64]	@ 0x40

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
341840dc:	2300      	movs	r3, #0
341840de:	637b      	str	r3, [r7, #52]	@ 0x34
341840e0:	e0a3      	b.n	3418422a <I2C_Compute_SCLL_SCLH+0x1e6>
  {
    /* tPRESC = (PRESC+1) x tI2CCLK*/
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
341840e2:	495a      	ldr	r1, [pc, #360]	@ (3418424c <I2C_Compute_SCLL_SCLH+0x208>)
341840e4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341840e6:	4613      	mov	r3, r2
341840e8:	009b      	lsls	r3, r3, #2
341840ea:	4413      	add	r3, r2
341840ec:	009b      	lsls	r3, r3, #2
341840ee:	440b      	add	r3, r1
341840f0:	681b      	ldr	r3, [r3, #0]
341840f2:	1c5a      	adds	r2, r3, #1
341840f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341840f6:	fb02 f303 	mul.w	r3, r2, r3
341840fa:	617b      	str	r3, [r7, #20]

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
341840fc:	2300      	movs	r3, #0
341840fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
34184100:	e08c      	b.n	3418421c <I2C_Compute_SCLL_SCLH+0x1d8>
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
34184102:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34184104:	6a3b      	ldr	r3, [r7, #32]
34184106:	441a      	add	r2, r3
34184108:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418410a:	3301      	adds	r3, #1
3418410c:	6979      	ldr	r1, [r7, #20]
3418410e:	fb03 f101 	mul.w	r1, r3, r1
34184112:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184114:	005b      	lsls	r3, r3, #1
34184116:	440b      	add	r3, r1
34184118:	4413      	add	r3, r2
3418411a:	613b      	str	r3, [r7, #16]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
3418411c:	4a4a      	ldr	r2, [pc, #296]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
3418411e:	683b      	ldr	r3, [r7, #0]
34184120:	212c      	movs	r1, #44	@ 0x2c
34184122:	fb01 f303 	mul.w	r3, r1, r3
34184126:	4413      	add	r3, r2
34184128:	3318      	adds	r3, #24
3418412a:	681b      	ldr	r3, [r3, #0]
3418412c:	693a      	ldr	r2, [r7, #16]
3418412e:	429a      	cmp	r2, r3
34184130:	d971      	bls.n	34184216 <I2C_Compute_SCLL_SCLH+0x1d2>
34184132:	693a      	ldr	r2, [r7, #16]
34184134:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184136:	1ad2      	subs	r2, r2, r3
34184138:	6a3b      	ldr	r3, [r7, #32]
3418413a:	1ad3      	subs	r3, r2, r3
3418413c:	089b      	lsrs	r3, r3, #2
3418413e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34184140:	429a      	cmp	r2, r3
34184142:	d268      	bcs.n	34184216 <I2C_Compute_SCLL_SCLH+0x1d2>
      {
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34184144:	2300      	movs	r3, #0
34184146:	63bb      	str	r3, [r7, #56]	@ 0x38
34184148:	e062      	b.n	34184210 <I2C_Compute_SCLL_SCLH+0x1cc>
        {
          /* tHIGH(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLH+1) x tPRESC] */
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
3418414a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418414c:	6a3b      	ldr	r3, [r7, #32]
3418414e:	441a      	add	r2, r3
34184150:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34184152:	3301      	adds	r3, #1
34184154:	6979      	ldr	r1, [r7, #20]
34184156:	fb03 f101 	mul.w	r1, r3, r1
3418415a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418415c:	005b      	lsls	r3, r3, #1
3418415e:	440b      	add	r3, r1
34184160:	4413      	add	r3, r2
34184162:	60fb      	str	r3, [r7, #12]

          /* tSCL = tf + tLOW + tr + tHIGH */
          uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;
34184164:	693a      	ldr	r2, [r7, #16]
34184166:	68fb      	ldr	r3, [r7, #12]
34184168:	441a      	add	r2, r3
3418416a:	4937      	ldr	r1, [pc, #220]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
3418416c:	683b      	ldr	r3, [r7, #0]
3418416e:	202c      	movs	r0, #44	@ 0x2c
34184170:	fb00 f303 	mul.w	r3, r0, r3
34184174:	440b      	add	r3, r1
34184176:	3320      	adds	r3, #32
34184178:	681b      	ldr	r3, [r3, #0]
3418417a:	441a      	add	r2, r3
3418417c:	4932      	ldr	r1, [pc, #200]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
3418417e:	683b      	ldr	r3, [r7, #0]
34184180:	202c      	movs	r0, #44	@ 0x2c
34184182:	fb00 f303 	mul.w	r3, r0, r3
34184186:	440b      	add	r3, r1
34184188:	3324      	adds	r3, #36	@ 0x24
3418418a:	681b      	ldr	r3, [r3, #0]
3418418c:	4413      	add	r3, r2
3418418e:	60bb      	str	r3, [r7, #8]

          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
34184190:	68ba      	ldr	r2, [r7, #8]
34184192:	69bb      	ldr	r3, [r7, #24]
34184194:	429a      	cmp	r2, r3
34184196:	d338      	bcc.n	3418420a <I2C_Compute_SCLL_SCLH+0x1c6>
34184198:	68ba      	ldr	r2, [r7, #8]
3418419a:	69fb      	ldr	r3, [r7, #28]
3418419c:	429a      	cmp	r2, r3
3418419e:	d834      	bhi.n	3418420a <I2C_Compute_SCLL_SCLH+0x1c6>
341841a0:	4a29      	ldr	r2, [pc, #164]	@ (34184248 <I2C_Compute_SCLL_SCLH+0x204>)
341841a2:	683b      	ldr	r3, [r7, #0]
341841a4:	212c      	movs	r1, #44	@ 0x2c
341841a6:	fb01 f303 	mul.w	r3, r1, r3
341841aa:	4413      	add	r3, r2
341841ac:	331c      	adds	r3, #28
341841ae:	681b      	ldr	r3, [r3, #0]
341841b0:	68fa      	ldr	r2, [r7, #12]
341841b2:	429a      	cmp	r2, r3
341841b4:	d329      	bcc.n	3418420a <I2C_Compute_SCLL_SCLH+0x1c6>
341841b6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
341841b8:	68fb      	ldr	r3, [r7, #12]
341841ba:	429a      	cmp	r2, r3
341841bc:	d225      	bcs.n	3418420a <I2C_Compute_SCLL_SCLH+0x1c6>
          {
            int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;
341841be:	68ba      	ldr	r2, [r7, #8]
341841c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341841c2:	1ad3      	subs	r3, r2, r3
341841c4:	633b      	str	r3, [r7, #48]	@ 0x30

            if (error < 0)
341841c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341841c8:	2b00      	cmp	r3, #0
341841ca:	da02      	bge.n	341841d2 <I2C_Compute_SCLL_SCLH+0x18e>
            {
              error = -error;
341841cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341841ce:	425b      	negs	r3, r3
341841d0:	633b      	str	r3, [r7, #48]	@ 0x30
            }

            /* look for the timings with the lowest clock error */
            if ((uint32_t)error < prev_error)
341841d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341841d4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
341841d6:	429a      	cmp	r2, r3
341841d8:	d917      	bls.n	3418420a <I2C_Compute_SCLL_SCLH+0x1c6>
            {
              prev_error = (uint32_t)error;
341841da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341841dc:	643b      	str	r3, [r7, #64]	@ 0x40
              I2c_valid_timing[count].scll = scll;
341841de:	491b      	ldr	r1, [pc, #108]	@ (3418424c <I2C_Compute_SCLL_SCLH+0x208>)
341841e0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341841e2:	4613      	mov	r3, r2
341841e4:	009b      	lsls	r3, r3, #2
341841e6:	4413      	add	r3, r2
341841e8:	009b      	lsls	r3, r3, #2
341841ea:	440b      	add	r3, r1
341841ec:	3310      	adds	r3, #16
341841ee:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
341841f0:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[count].sclh = sclh;
341841f2:	4916      	ldr	r1, [pc, #88]	@ (3418424c <I2C_Compute_SCLL_SCLH+0x208>)
341841f4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341841f6:	4613      	mov	r3, r2
341841f8:	009b      	lsls	r3, r3, #2
341841fa:	4413      	add	r3, r2
341841fc:	009b      	lsls	r3, r3, #2
341841fe:	440b      	add	r3, r1
34184200:	330c      	adds	r3, #12
34184202:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34184204:	601a      	str	r2, [r3, #0]
              ret = count;
34184206:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34184208:	647b      	str	r3, [r7, #68]	@ 0x44
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
3418420a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418420c:	3301      	adds	r3, #1
3418420e:	63bb      	str	r3, [r7, #56]	@ 0x38
34184210:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34184212:	2bff      	cmp	r3, #255	@ 0xff
34184214:	d999      	bls.n	3418414a <I2C_Compute_SCLL_SCLH+0x106>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
34184216:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34184218:	3301      	adds	r3, #1
3418421a:	63fb      	str	r3, [r7, #60]	@ 0x3c
3418421c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418421e:	2bff      	cmp	r3, #255	@ 0xff
34184220:	f67f af6f 	bls.w	34184102 <I2C_Compute_SCLL_SCLH+0xbe>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
34184224:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34184226:	3301      	adds	r3, #1
34184228:	637b      	str	r3, [r7, #52]	@ 0x34
3418422a:	4b09      	ldr	r3, [pc, #36]	@ (34184250 <I2C_Compute_SCLL_SCLH+0x20c>)
3418422c:	681b      	ldr	r3, [r3, #0]
3418422e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34184230:	429a      	cmp	r2, r3
34184232:	f4ff af56 	bcc.w	341840e2 <I2C_Compute_SCLL_SCLH+0x9e>
        }
      }
    }
  }

  return ret;
34184236:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34184238:	4618      	mov	r0, r3
3418423a:	374c      	adds	r7, #76	@ 0x4c
3418423c:	46bd      	mov	sp, r7
3418423e:	f85d 7b04 	ldr.w	r7, [sp], #4
34184242:	4770      	bx	lr
34184244:	3b9aca00 	.word	0x3b9aca00
34184248:	341b0e7c 	.word	0x341b0e7c
3418424c:	341c0678 	.word	0x341c0678
34184250:	341c1078 	.word	0x341c1078

34184254 <LL_AHB4_GRP1_EnableClock>:
{
34184254:	b480      	push	{r7}
34184256:	b085      	sub	sp, #20
34184258:	af00      	add	r7, sp, #0
3418425a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3418425c:	4a07      	ldr	r2, [pc, #28]	@ (3418427c <LL_AHB4_GRP1_EnableClock+0x28>)
3418425e:	687b      	ldr	r3, [r7, #4]
34184260:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34184264:	4b05      	ldr	r3, [pc, #20]	@ (3418427c <LL_AHB4_GRP1_EnableClock+0x28>)
34184266:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418426a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418426c:	68fb      	ldr	r3, [r7, #12]
}
3418426e:	bf00      	nop
34184270:	3714      	adds	r7, #20
34184272:	46bd      	mov	sp, r7
34184274:	f85d 7b04 	ldr.w	r7, [sp], #4
34184278:	4770      	bx	lr
3418427a:	bf00      	nop
3418427c:	56028000 	.word	0x56028000

34184280 <LL_AHB5_GRP1_EnableClock>:
{
34184280:	b480      	push	{r7}
34184282:	b085      	sub	sp, #20
34184284:	af00      	add	r7, sp, #0
34184286:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34184288:	4a07      	ldr	r2, [pc, #28]	@ (341842a8 <LL_AHB5_GRP1_EnableClock+0x28>)
3418428a:	687b      	ldr	r3, [r7, #4]
3418428c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34184290:	4b05      	ldr	r3, [pc, #20]	@ (341842a8 <LL_AHB5_GRP1_EnableClock+0x28>)
34184292:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34184296:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34184298:	68fb      	ldr	r3, [r7, #12]
}
3418429a:	bf00      	nop
3418429c:	3714      	adds	r7, #20
3418429e:	46bd      	mov	sp, r7
341842a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341842a4:	4770      	bx	lr
341842a6:	bf00      	nop
341842a8:	56028000 	.word	0x56028000

341842ac <LL_AHB5_GRP1_ForceReset>:
{
341842ac:	b480      	push	{r7}
341842ae:	b083      	sub	sp, #12
341842b0:	af00      	add	r7, sp, #0
341842b2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
341842b4:	4a04      	ldr	r2, [pc, #16]	@ (341842c8 <LL_AHB5_GRP1_ForceReset+0x1c>)
341842b6:	687b      	ldr	r3, [r7, #4]
341842b8:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
341842bc:	bf00      	nop
341842be:	370c      	adds	r7, #12
341842c0:	46bd      	mov	sp, r7
341842c2:	f85d 7b04 	ldr.w	r7, [sp], #4
341842c6:	4770      	bx	lr
341842c8:	56028000 	.word	0x56028000

341842cc <LL_AHB5_GRP1_ReleaseReset>:
{
341842cc:	b480      	push	{r7}
341842ce:	b083      	sub	sp, #12
341842d0:	af00      	add	r7, sp, #0
341842d2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
341842d4:	4b06      	ldr	r3, [pc, #24]	@ (341842f0 <LL_AHB5_GRP1_ReleaseReset+0x24>)
341842d6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341842da:	461a      	mov	r2, r3
341842dc:	687b      	ldr	r3, [r7, #4]
341842de:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
341842e2:	bf00      	nop
341842e4:	370c      	adds	r7, #12
341842e6:	46bd      	mov	sp, r7
341842e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341842ec:	4770      	bx	lr
341842ee:	bf00      	nop
341842f0:	56028000 	.word	0x56028000

341842f4 <BSP_XSPI_NOR_Init>:
  * @param  Instance   XSPI Instance
  * @param  Init       XSPI Init structure
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_Init(uint32_t Instance, BSP_XSPI_NOR_Init_t *Init)
{
341842f4:	b590      	push	{r4, r7, lr}
341842f6:	b095      	sub	sp, #84	@ 0x54
341842f8:	af00      	add	r7, sp, #0
341842fa:	6078      	str	r0, [r7, #4]
341842fc:	6039      	str	r1, [r7, #0]
  int32_t ret;
  BSP_XSPI_NOR_Info_t pInfo;
  MX_XSPI_InitTypeDef xspi_init;

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
341842fe:	687b      	ldr	r3, [r7, #4]
34184300:	2b00      	cmp	r3, #0
34184302:	d003      	beq.n	3418430c <BSP_XSPI_NOR_Init+0x18>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184304:	f06f 0301 	mvn.w	r3, #1
34184308:	64fb      	str	r3, [r7, #76]	@ 0x4c
3418430a:	e080      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
3418430c:	4947      	ldr	r1, [pc, #284]	@ (3418442c <BSP_XSPI_NOR_Init+0x138>)
3418430e:	687a      	ldr	r2, [r7, #4]
34184310:	4613      	mov	r3, r2
34184312:	005b      	lsls	r3, r3, #1
34184314:	4413      	add	r3, r2
34184316:	440b      	add	r3, r1
34184318:	781b      	ldrb	r3, [r3, #0]
3418431a:	2b00      	cmp	r3, #0
3418431c:	d175      	bne.n	3418440a <BSP_XSPI_NOR_Init+0x116>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_NOR_MspInit(&hxspi_nor[Instance]);
3418431e:	687b      	ldr	r3, [r7, #4]
34184320:	2264      	movs	r2, #100	@ 0x64
34184322:	fb02 f303 	mul.w	r3, r2, r3
34184326:	4a42      	ldr	r2, [pc, #264]	@ (34184430 <BSP_XSPI_NOR_Init+0x13c>)
34184328:	4413      	add	r3, r2
3418432a:	4618      	mov	r0, r3
3418432c:	f000 faba 	bl	341848a4 <XSPI_NOR_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Get Flash information of one memory */
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
34184330:	f107 031c 	add.w	r3, r7, #28
34184334:	4618      	mov	r0, r3
34184336:	f011 ff40 	bl	341961ba <MX66UW1G45G_GetFlashInfo>

      /* Fill config structure */
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
3418433a:	2303      	movs	r3, #3
3418433c:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
3418433e:	69fb      	ldr	r3, [r7, #28]
34184340:	647b      	str	r3, [r7, #68]	@ 0x44
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34184342:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34184344:	fa93 f3a3 	rbit	r3, r3
34184348:	643b      	str	r3, [r7, #64]	@ 0x40
  return result;
3418434a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3418434c:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (value == 0U)
3418434e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34184350:	2b00      	cmp	r3, #0
34184352:	d101      	bne.n	34184358 <BSP_XSPI_NOR_Init+0x64>
    return 32U;
34184354:	2320      	movs	r3, #32
34184356:	e003      	b.n	34184360 <BSP_XSPI_NOR_Init+0x6c>
  return __builtin_clz(value);
34184358:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418435a:	fab3 f383 	clz	r3, r3
3418435e:	b2db      	uxtb	r3, r3
34184360:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34184362:	2300      	movs	r3, #0
34184364:	617b      	str	r3, [r7, #20]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
34184366:	683b      	ldr	r3, [r7, #0]
34184368:	785b      	ldrb	r3, [r3, #1]
3418436a:	61bb      	str	r3, [r7, #24]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
3418436c:	687b      	ldr	r3, [r7, #4]
3418436e:	2264      	movs	r2, #100	@ 0x64
34184370:	fb02 f303 	mul.w	r3, r2, r3
34184374:	4a2e      	ldr	r2, [pc, #184]	@ (34184430 <BSP_XSPI_NOR_Init+0x13c>)
34184376:	4413      	add	r3, r2
34184378:	f107 020c 	add.w	r2, r7, #12
3418437c:	4611      	mov	r1, r2
3418437e:	4618      	mov	r0, r3
34184380:	f000 f858 	bl	34184434 <MX_XSPI_NOR_Init>
34184384:	4603      	mov	r3, r0
34184386:	2b00      	cmp	r3, #0
34184388:	d003      	beq.n	34184392 <BSP_XSPI_NOR_Init+0x9e>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
3418438a:	f06f 0303 	mvn.w	r3, #3
3418438e:	64fb      	str	r3, [r7, #76]	@ 0x4c
34184390:	e03d      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
      }
      /* XSPI memory reset */
      else if (XSPI_NOR_ResetMemory(Instance) != BSP_ERROR_NONE)
34184392:	6878      	ldr	r0, [r7, #4]
34184394:	f000 fb4c 	bl	34184a30 <XSPI_NOR_ResetMemory>
34184398:	4603      	mov	r3, r0
3418439a:	2b00      	cmp	r3, #0
3418439c:	d003      	beq.n	341843a6 <BSP_XSPI_NOR_Init+0xb2>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
3418439e:	f06f 0304 	mvn.w	r3, #4
341843a2:	64fb      	str	r3, [r7, #76]	@ 0x4c
341843a4:	e033      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Check if memory is ready */
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
341843a6:	687b      	ldr	r3, [r7, #4]
341843a8:	2264      	movs	r2, #100	@ 0x64
341843aa:	fb02 f303 	mul.w	r3, r2, r3
341843ae:	4a20      	ldr	r2, [pc, #128]	@ (34184430 <BSP_XSPI_NOR_Init+0x13c>)
341843b0:	1898      	adds	r0, r3, r2
341843b2:	491e      	ldr	r1, [pc, #120]	@ (3418442c <BSP_XSPI_NOR_Init+0x138>)
341843b4:	687a      	ldr	r2, [r7, #4]
341843b6:	4613      	mov	r3, r2
341843b8:	005b      	lsls	r3, r3, #1
341843ba:	4413      	add	r3, r2
341843bc:	440b      	add	r3, r1
341843be:	3301      	adds	r3, #1
341843c0:	7819      	ldrb	r1, [r3, #0]
341843c2:	4c1a      	ldr	r4, [pc, #104]	@ (3418442c <BSP_XSPI_NOR_Init+0x138>)
341843c4:	687a      	ldr	r2, [r7, #4]
341843c6:	4613      	mov	r3, r2
341843c8:	005b      	lsls	r3, r3, #1
341843ca:	4413      	add	r3, r2
341843cc:	4423      	add	r3, r4
341843ce:	3302      	adds	r3, #2
341843d0:	781b      	ldrb	r3, [r3, #0]
341843d2:	461a      	mov	r2, r3
341843d4:	f011 ff20 	bl	34196218 <MX66UW1G45G_AutoPollingMemReady>
341843d8:	4603      	mov	r3, r0
341843da:	2b00      	cmp	r3, #0
341843dc:	d003      	beq.n	341843e6 <BSP_XSPI_NOR_Init+0xf2>
                                                XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
341843de:	f06f 0304 	mvn.w	r3, #4
341843e2:	64fb      	str	r3, [r7, #76]	@ 0x4c
341843e4:	e013      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Configure the memory */
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
341843e6:	683b      	ldr	r3, [r7, #0]
341843e8:	7819      	ldrb	r1, [r3, #0]
341843ea:	683b      	ldr	r3, [r7, #0]
341843ec:	785b      	ldrb	r3, [r3, #1]
341843ee:	461a      	mov	r2, r3
341843f0:	6878      	ldr	r0, [r7, #4]
341843f2:	f000 f8d5 	bl	341845a0 <BSP_XSPI_NOR_ConfigFlash>
341843f6:	4603      	mov	r3, r0
341843f8:	2b00      	cmp	r3, #0
341843fa:	d003      	beq.n	34184404 <BSP_XSPI_NOR_Init+0x110>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
341843fc:	f06f 0304 	mvn.w	r3, #4
34184400:	64fb      	str	r3, [r7, #76]	@ 0x4c
34184402:	e004      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
34184404:	2300      	movs	r3, #0
34184406:	64fb      	str	r3, [r7, #76]	@ 0x4c
34184408:	e001      	b.n	3418440e <BSP_XSPI_NOR_Init+0x11a>
      }
    }
    else
    {
      ret = BSP_ERROR_NONE;
3418440a:	2300      	movs	r3, #0
3418440c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
3418440e:	687b      	ldr	r3, [r7, #4]
34184410:	2264      	movs	r2, #100	@ 0x64
34184412:	fb02 f303 	mul.w	r3, r2, r3
34184416:	4a06      	ldr	r2, [pc, #24]	@ (34184430 <BSP_XSPI_NOR_Init+0x13c>)
34184418:	4413      	add	r3, r2
3418441a:	2100      	movs	r1, #0
3418441c:	4618      	mov	r0, r3
3418441e:	f011 fa64 	bl	341958ea <HAL_XSPI_SetClockPrescaler>

  /* Return BSP status */
  return ret;
34184422:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
34184424:	4618      	mov	r0, r3
34184426:	3754      	adds	r7, #84	@ 0x54
34184428:	46bd      	mov	sp, r7
3418442a:	bd90      	pop	{r4, r7, pc}
3418442c:	341c1134 	.word	0x341c1134
34184430:	341c10d0 	.word	0x341c10d0

34184434 <MX_XSPI_NOR_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_NOR_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
34184434:	b580      	push	{r7, lr}
34184436:	b082      	sub	sp, #8
34184438:	af00      	add	r7, sp, #0
3418443a:	6078      	str	r0, [r7, #4]
3418443c:	6039      	str	r1, [r7, #0]
  /* XSPI initialization */
  hxspi->Instance = XSPI2;
3418443e:	687b      	ldr	r3, [r7, #4]
34184440:	4a20      	ldr	r2, [pc, #128]	@ (341844c4 <MX_XSPI_NOR_Init+0x90>)
34184442:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte       = 1;
34184444:	687b      	ldr	r3, [r7, #4]
34184446:	2201      	movs	r2, #1
34184448:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
3418444a:	683b      	ldr	r3, [r7, #0]
3418444c:	681a      	ldr	r2, [r3, #0]
3418444e:	687b      	ldr	r3, [r7, #4]
34184450:	611a      	str	r2, [r3, #16]
  hxspi->Init.ChipSelectHighTimeCycle = 2;
34184452:	687b      	ldr	r3, [r7, #4]
34184454:	2202      	movs	r2, #2
34184456:	615a      	str	r2, [r3, #20]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34184458:	687b      	ldr	r3, [r7, #4]
3418445a:	2200      	movs	r2, #0
3418445c:	619a      	str	r2, [r3, #24]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
3418445e:	687b      	ldr	r3, [r7, #4]
34184460:	2200      	movs	r2, #0
34184462:	61da      	str	r2, [r3, #28]
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
34184464:	687b      	ldr	r3, [r7, #4]
34184466:	2200      	movs	r2, #0
34184468:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
3418446a:	683b      	ldr	r3, [r7, #0]
3418446c:	685a      	ldr	r2, [r3, #4]
3418446e:	687b      	ldr	r3, [r7, #4]
34184470:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34184472:	683b      	ldr	r3, [r7, #0]
34184474:	689a      	ldr	r2, [r3, #8]
34184476:	687b      	ldr	r3, [r7, #4]
34184478:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
3418447a:	687b      	ldr	r3, [r7, #4]
3418447c:	2200      	movs	r2, #0
3418447e:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
34184480:	687b      	ldr	r3, [r7, #4]
34184482:	2200      	movs	r2, #0
34184484:	609a      	str	r2, [r3, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34184486:	687b      	ldr	r3, [r7, #4]
34184488:	2200      	movs	r2, #0
3418448a:	621a      	str	r2, [r3, #32]

  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
3418448c:	683b      	ldr	r3, [r7, #0]
3418448e:	68db      	ldr	r3, [r3, #12]
34184490:	2b01      	cmp	r3, #1
34184492:	d108      	bne.n	341844a6 <MX_XSPI_NOR_Init+0x72>
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34184494:	687b      	ldr	r3, [r7, #4]
34184496:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3418449a:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
3418449c:	687b      	ldr	r3, [r7, #4]
3418449e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
341844a2:	62da      	str	r2, [r3, #44]	@ 0x2c
341844a4:	e006      	b.n	341844b4 <MX_XSPI_NOR_Init+0x80>
  }
  else
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
341844a6:	687b      	ldr	r3, [r7, #4]
341844a8:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
341844ac:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
341844ae:	687b      	ldr	r3, [r7, #4]
341844b0:	2200      	movs	r2, #0
341844b2:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
  return HAL_XSPI_Init(hxspi);
341844b4:	6878      	ldr	r0, [r7, #4]
341844b6:	f010 fde5 	bl	34195084 <HAL_XSPI_Init>
341844ba:	4603      	mov	r3, r0
}
341844bc:	4618      	mov	r0, r3
341844be:	3708      	adds	r7, #8
341844c0:	46bd      	mov	sp, r7
341844c2:	bd80      	pop	{r7, pc}
341844c4:	5802a000 	.word	0x5802a000

341844c8 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_EnableMemoryMappedMode(uint32_t Instance)
{
341844c8:	b580      	push	{r7, lr}
341844ca:	b084      	sub	sp, #16
341844cc:	af00      	add	r7, sp, #0
341844ce:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
341844d0:	2300      	movs	r3, #0
341844d2:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
341844d4:	687b      	ldr	r3, [r7, #4]
341844d6:	2b00      	cmp	r3, #0
341844d8:	d003      	beq.n	341844e2 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341844da:	f06f 0301 	mvn.w	r3, #1
341844de:	60fb      	str	r3, [r7, #12]
341844e0:	e055      	b.n	3418458e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
  }
  else
  {

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
341844e2:	687b      	ldr	r3, [r7, #4]
341844e4:	2264      	movs	r2, #100	@ 0x64
341844e6:	fb02 f303 	mul.w	r3, r2, r3
341844ea:	4a2b      	ldr	r2, [pc, #172]	@ (34184598 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
341844ec:	4413      	add	r3, r2
341844ee:	2100      	movs	r1, #0
341844f0:	4618      	mov	r0, r3
341844f2:	f011 f9fa 	bl	341958ea <HAL_XSPI_SetClockPrescaler>

    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
341844f6:	4929      	ldr	r1, [pc, #164]	@ (3418459c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
341844f8:	687a      	ldr	r2, [r7, #4]
341844fa:	4613      	mov	r3, r2
341844fc:	005b      	lsls	r3, r3, #1
341844fe:	4413      	add	r3, r2
34184500:	440b      	add	r3, r1
34184502:	3302      	adds	r3, #2
34184504:	781b      	ldrb	r3, [r3, #0]
34184506:	2b00      	cmp	r3, #0
34184508:	d121      	bne.n	3418454e <BSP_XSPI_NOR_EnableMemoryMappedMode+0x86>
    {
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
3418450a:	687b      	ldr	r3, [r7, #4]
3418450c:	2264      	movs	r2, #100	@ 0x64
3418450e:	fb02 f303 	mul.w	r3, r2, r3
34184512:	4a21      	ldr	r2, [pc, #132]	@ (34184598 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
34184514:	1898      	adds	r0, r3, r2
34184516:	4921      	ldr	r1, [pc, #132]	@ (3418459c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34184518:	687a      	ldr	r2, [r7, #4]
3418451a:	4613      	mov	r3, r2
3418451c:	005b      	lsls	r3, r3, #1
3418451e:	4413      	add	r3, r2
34184520:	440b      	add	r3, r1
34184522:	3301      	adds	r3, #1
34184524:	781b      	ldrb	r3, [r3, #0]
34184526:	2201      	movs	r2, #1
34184528:	4619      	mov	r1, r3
3418452a:	f011 ff23 	bl	34196374 <MX66UW1G45G_EnableSTRMemoryMappedMode>
3418452e:	4603      	mov	r3, r0
34184530:	2b00      	cmp	r3, #0
34184532:	d003      	beq.n	3418453c <BSP_XSPI_NOR_EnableMemoryMappedMode+0x74>
                                                 MX66UW1G45G_4BYTES_SIZE) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34184534:	f06f 0304 	mvn.w	r3, #4
34184538:	60fb      	str	r3, [r7, #12]
3418453a:	e028      	b.n	3418458e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
3418453c:	4917      	ldr	r1, [pc, #92]	@ (3418459c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
3418453e:	687a      	ldr	r2, [r7, #4]
34184540:	4613      	mov	r3, r2
34184542:	005b      	lsls	r3, r3, #1
34184544:	4413      	add	r3, r2
34184546:	440b      	add	r3, r1
34184548:	2202      	movs	r2, #2
3418454a:	701a      	strb	r2, [r3, #0]
3418454c:	e01f      	b.n	3418458e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
    }
    else
    {
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
3418454e:	687b      	ldr	r3, [r7, #4]
34184550:	2264      	movs	r2, #100	@ 0x64
34184552:	fb02 f303 	mul.w	r3, r2, r3
34184556:	4a10      	ldr	r2, [pc, #64]	@ (34184598 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
34184558:	1898      	adds	r0, r3, r2
3418455a:	4910      	ldr	r1, [pc, #64]	@ (3418459c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
3418455c:	687a      	ldr	r2, [r7, #4]
3418455e:	4613      	mov	r3, r2
34184560:	005b      	lsls	r3, r3, #1
34184562:	4413      	add	r3, r2
34184564:	440b      	add	r3, r1
34184566:	3301      	adds	r3, #1
34184568:	781b      	ldrb	r3, [r3, #0]
3418456a:	4619      	mov	r1, r3
3418456c:	f011 ffaa 	bl	341964c4 <MX66UW1G45G_EnableDTRMemoryMappedMode>
34184570:	4603      	mov	r3, r0
34184572:	2b00      	cmp	r3, #0
34184574:	d003      	beq.n	3418457e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb6>
                                                 XSPI_Nor_Ctx[Instance].InterfaceMode) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34184576:	f06f 0304 	mvn.w	r3, #4
3418457a:	60fb      	str	r3, [r7, #12]
3418457c:	e007      	b.n	3418458e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {

       XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
3418457e:	4907      	ldr	r1, [pc, #28]	@ (3418459c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34184580:	687a      	ldr	r2, [r7, #4]
34184582:	4613      	mov	r3, r2
34184584:	005b      	lsls	r3, r3, #1
34184586:	4413      	add	r3, r2
34184588:	440b      	add	r3, r1
3418458a:	2202      	movs	r2, #2
3418458c:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
3418458e:	68fb      	ldr	r3, [r7, #12]
}
34184590:	4618      	mov	r0, r3
34184592:	3710      	adds	r7, #16
34184594:	46bd      	mov	sp, r7
34184596:	bd80      	pop	{r7, pc}
34184598:	341c10d0 	.word	0x341c10d0
3418459c:	341c1134 	.word	0x341c1134

341845a0 <BSP_XSPI_NOR_ConfigFlash>:
  * @param  Mode      XSPI mode
  * @param  Rate      XSPI transfer rate
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_ConfigFlash(uint32_t Instance, BSP_XSPI_NOR_Interface_t Mode, BSP_XSPI_NOR_Transfer_t Rate)
{
341845a0:	b580      	push	{r7, lr}
341845a2:	b084      	sub	sp, #16
341845a4:	af00      	add	r7, sp, #0
341845a6:	6078      	str	r0, [r7, #4]
341845a8:	460b      	mov	r3, r1
341845aa:	70fb      	strb	r3, [r7, #3]
341845ac:	4613      	mov	r3, r2
341845ae:	70bb      	strb	r3, [r7, #2]
  int32_t ret = BSP_ERROR_NONE;
341845b0:	2300      	movs	r3, #0
341845b2:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
341845b4:	687b      	ldr	r3, [r7, #4]
341845b6:	2b00      	cmp	r3, #0
341845b8:	d003      	beq.n	341845c2 <BSP_XSPI_NOR_ConfigFlash+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341845ba:	f06f 0301 	mvn.w	r3, #1
341845be:	60fb      	str	r3, [r7, #12]
341845c0:	e072      	b.n	341846a8 <BSP_XSPI_NOR_ConfigFlash+0x108>
  }
  else
  {
    /* Check if MMP mode locked ************************************************/
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
341845c2:	493c      	ldr	r1, [pc, #240]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
341845c4:	687a      	ldr	r2, [r7, #4]
341845c6:	4613      	mov	r3, r2
341845c8:	005b      	lsls	r3, r3, #1
341845ca:	4413      	add	r3, r2
341845cc:	440b      	add	r3, r1
341845ce:	781b      	ldrb	r3, [r3, #0]
341845d0:	2b02      	cmp	r3, #2
341845d2:	d103      	bne.n	341845dc <BSP_XSPI_NOR_ConfigFlash+0x3c>
    {
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
341845d4:	f06f 0319 	mvn.w	r3, #25
341845d8:	60fb      	str	r3, [r7, #12]
341845da:	e065      	b.n	341846a8 <BSP_XSPI_NOR_ConfigFlash+0x108>
    }
    else
    {
      /* Setup Flash interface ***************************************************/
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
341845dc:	4935      	ldr	r1, [pc, #212]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
341845de:	687a      	ldr	r2, [r7, #4]
341845e0:	4613      	mov	r3, r2
341845e2:	005b      	lsls	r3, r3, #1
341845e4:	4413      	add	r3, r2
341845e6:	440b      	add	r3, r1
341845e8:	3301      	adds	r3, #1
341845ea:	781b      	ldrb	r3, [r3, #0]
341845ec:	2b01      	cmp	r3, #1
341845ee:	d12b      	bne.n	34184648 <BSP_XSPI_NOR_ConfigFlash+0xa8>
      {
        case BSP_XSPI_NOR_OPI_MODE :  /* 8-8-8 commands */
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
341845f0:	78fb      	ldrb	r3, [r7, #3]
341845f2:	2b01      	cmp	r3, #1
341845f4:	d10a      	bne.n	3418460c <BSP_XSPI_NOR_ConfigFlash+0x6c>
341845f6:	492f      	ldr	r1, [pc, #188]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
341845f8:	687a      	ldr	r2, [r7, #4]
341845fa:	4613      	mov	r3, r2
341845fc:	005b      	lsls	r3, r3, #1
341845fe:	4413      	add	r3, r2
34184600:	440b      	add	r3, r1
34184602:	3302      	adds	r3, #2
34184604:	781b      	ldrb	r3, [r3, #0]
34184606:	78ba      	ldrb	r2, [r7, #2]
34184608:	429a      	cmp	r2, r3
3418460a:	d02d      	beq.n	34184668 <BSP_XSPI_NOR_ConfigFlash+0xc8>
          {
            /* Exit OPI mode */
            ret = XSPI_NOR_ExitOPIMode(Instance);
3418460c:	6878      	ldr	r0, [r7, #4]
3418460e:	f000 fc57 	bl	34184ec0 <XSPI_NOR_ExitOPIMode>
34184612:	60f8      	str	r0, [r7, #12]

            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
34184614:	68fb      	ldr	r3, [r7, #12]
34184616:	2b00      	cmp	r3, #0
34184618:	d126      	bne.n	34184668 <BSP_XSPI_NOR_ConfigFlash+0xc8>
3418461a:	78fb      	ldrb	r3, [r7, #3]
3418461c:	2b01      	cmp	r3, #1
3418461e:	d123      	bne.n	34184668 <BSP_XSPI_NOR_ConfigFlash+0xc8>
            {

              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
34184620:	4924      	ldr	r1, [pc, #144]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34184622:	687a      	ldr	r2, [r7, #4]
34184624:	4613      	mov	r3, r2
34184626:	005b      	lsls	r3, r3, #1
34184628:	4413      	add	r3, r2
3418462a:	440b      	add	r3, r1
3418462c:	3302      	adds	r3, #2
3418462e:	781b      	ldrb	r3, [r3, #0]
34184630:	2b00      	cmp	r3, #0
34184632:	d104      	bne.n	3418463e <BSP_XSPI_NOR_ConfigFlash+0x9e>
              {
                /* Enter DTR OPI mode */
                ret = XSPI_NOR_EnterDOPIMode(Instance);
34184634:	6878      	ldr	r0, [r7, #4]
34184636:	f000 fa93 	bl	34184b60 <XSPI_NOR_EnterDOPIMode>
3418463a:	60f8      	str	r0, [r7, #12]
                /* Enter STR OPI mode */
                ret = XSPI_NOR_EnterSOPIMode(Instance);
              }
            }
          }
          break;
3418463c:	e014      	b.n	34184668 <BSP_XSPI_NOR_ConfigFlash+0xc8>
                ret = XSPI_NOR_EnterSOPIMode(Instance);
3418463e:	6878      	ldr	r0, [r7, #4]
34184640:	f000 fb78 	bl	34184d34 <XSPI_NOR_EnterSOPIMode>
34184644:	60f8      	str	r0, [r7, #12]
          break;
34184646:	e00f      	b.n	34184668 <BSP_XSPI_NOR_ConfigFlash+0xc8>

        case BSP_XSPI_NOR_SPI_MODE :  /* 1-1-1 commands, Power on H/W default setting */
        default :
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34184648:	78fb      	ldrb	r3, [r7, #3]
3418464a:	2b01      	cmp	r3, #1
3418464c:	d10e      	bne.n	3418466c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          {
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
3418464e:	78bb      	ldrb	r3, [r7, #2]
34184650:	2b00      	cmp	r3, #0
34184652:	d104      	bne.n	3418465e <BSP_XSPI_NOR_ConfigFlash+0xbe>
            {
              /* Enter STR OPI mode */
              ret = XSPI_NOR_EnterSOPIMode(Instance);
34184654:	6878      	ldr	r0, [r7, #4]
34184656:	f000 fb6d 	bl	34184d34 <XSPI_NOR_EnterSOPIMode>
3418465a:	60f8      	str	r0, [r7, #12]
            {
              /* Enter DTR OPI mode */
              ret = XSPI_NOR_EnterDOPIMode(Instance);
            }
          }
          break;
3418465c:	e006      	b.n	3418466c <BSP_XSPI_NOR_ConfigFlash+0xcc>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
3418465e:	6878      	ldr	r0, [r7, #4]
34184660:	f000 fa7e 	bl	34184b60 <XSPI_NOR_EnterDOPIMode>
34184664:	60f8      	str	r0, [r7, #12]
          break;
34184666:	e001      	b.n	3418466c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          break;
34184668:	bf00      	nop
3418466a:	e000      	b.n	3418466e <BSP_XSPI_NOR_ConfigFlash+0xce>
          break;
3418466c:	bf00      	nop
      }

      /* Update XSPI context if all operations are well done */
      if (ret == BSP_ERROR_NONE)
3418466e:	68fb      	ldr	r3, [r7, #12]
34184670:	2b00      	cmp	r3, #0
34184672:	d119      	bne.n	341846a8 <BSP_XSPI_NOR_ConfigFlash+0x108>
      {
        /* Update current status parameter *****************************************/
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34184674:	490f      	ldr	r1, [pc, #60]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34184676:	687a      	ldr	r2, [r7, #4]
34184678:	4613      	mov	r3, r2
3418467a:	005b      	lsls	r3, r3, #1
3418467c:	4413      	add	r3, r2
3418467e:	440b      	add	r3, r1
34184680:	2201      	movs	r2, #1
34184682:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
34184684:	490b      	ldr	r1, [pc, #44]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34184686:	687a      	ldr	r2, [r7, #4]
34184688:	4613      	mov	r3, r2
3418468a:	005b      	lsls	r3, r3, #1
3418468c:	4413      	add	r3, r2
3418468e:	440b      	add	r3, r1
34184690:	3301      	adds	r3, #1
34184692:	78fa      	ldrb	r2, [r7, #3]
34184694:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34184696:	4907      	ldr	r1, [pc, #28]	@ (341846b4 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34184698:	687a      	ldr	r2, [r7, #4]
3418469a:	4613      	mov	r3, r2
3418469c:	005b      	lsls	r3, r3, #1
3418469e:	4413      	add	r3, r2
341846a0:	440b      	add	r3, r1
341846a2:	3302      	adds	r3, #2
341846a4:	78ba      	ldrb	r2, [r7, #2]
341846a6:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
341846a8:	68fb      	ldr	r3, [r7, #12]
}
341846aa:	4618      	mov	r0, r3
341846ac:	3710      	adds	r7, #16
341846ae:	46bd      	mov	sp, r7
341846b0:	bd80      	pop	{r7, pc}
341846b2:	bf00      	nop
341846b4:	341c1134 	.word	0x341c1134

341846b8 <BSP_XSPI_RAM_Init>:
  * @brief  Initializes the XSPI interface.
  * @param  Instance   XSPI Instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_Init(uint32_t Instance)
{
341846b8:	b580      	push	{r7, lr}
341846ba:	b088      	sub	sp, #32
341846bc:	af00      	add	r7, sp, #0
341846be:	6078      	str	r0, [r7, #4]
  MX_XSPI_InitTypeDef xspi_init;
  int32_t ret = BSP_ERROR_NONE;
341846c0:	2300      	movs	r3, #0
341846c2:	61fb      	str	r3, [r7, #28]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
341846c4:	687b      	ldr	r3, [r7, #4]
341846c6:	2b00      	cmp	r3, #0
341846c8:	d003      	beq.n	341846d2 <BSP_XSPI_RAM_Init+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341846ca:	f06f 0301 	mvn.w	r3, #1
341846ce:	61fb      	str	r3, [r7, #28]
341846d0:	e062      	b.n	34184798 <BSP_XSPI_RAM_Init+0xe0>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
341846d2:	4a34      	ldr	r2, [pc, #208]	@ (341847a4 <BSP_XSPI_RAM_Init+0xec>)
341846d4:	687b      	ldr	r3, [r7, #4]
341846d6:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
341846da:	2b00      	cmp	r3, #0
341846dc:	d131      	bne.n	34184742 <BSP_XSPI_RAM_Init+0x8a>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_RAM_MspInit(&hxspi_ram[Instance]);
341846de:	687b      	ldr	r3, [r7, #4]
341846e0:	2264      	movs	r2, #100	@ 0x64
341846e2:	fb02 f303 	mul.w	r3, r2, r3
341846e6:	4a30      	ldr	r2, [pc, #192]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
341846e8:	4413      	add	r3, r2
341846ea:	4618      	mov	r0, r3
341846ec:	f000 fc9c 	bl	34185028 <XSPI_RAM_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Fill config structure */
      xspi_init.ClockPrescaler = 3;
341846f0:	2303      	movs	r3, #3
341846f2:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
341846f4:	2318      	movs	r3, #24
341846f6:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
341846f8:	2300      	movs	r3, #0
341846fa:	617b      	str	r3, [r7, #20]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
341846fc:	687b      	ldr	r3, [r7, #4]
341846fe:	2264      	movs	r2, #100	@ 0x64
34184700:	fb02 f303 	mul.w	r3, r2, r3
34184704:	4a28      	ldr	r2, [pc, #160]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
34184706:	4413      	add	r3, r2
34184708:	f107 020c 	add.w	r2, r7, #12
3418470c:	4611      	mov	r1, r2
3418470e:	4618      	mov	r0, r3
34184710:	f000 f84c 	bl	341847ac <MX_XSPI_RAM_Init>
34184714:	4603      	mov	r3, r0
34184716:	2b00      	cmp	r3, #0
34184718:	d002      	beq.n	34184720 <BSP_XSPI_RAM_Init+0x68>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
3418471a:	f06f 0303 	mvn.w	r3, #3
3418471e:	61fb      	str	r3, [r7, #28]
      }
      /* Update current status parameter */
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34184720:	4a20      	ldr	r2, [pc, #128]	@ (341847a4 <BSP_XSPI_RAM_Init+0xec>)
34184722:	687b      	ldr	r3, [r7, #4]
34184724:	2101      	movs	r1, #1
34184726:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
3418472a:	4a1e      	ldr	r2, [pc, #120]	@ (341847a4 <BSP_XSPI_RAM_Init+0xec>)
3418472c:	687b      	ldr	r3, [r7, #4]
3418472e:	009b      	lsls	r3, r3, #2
34184730:	4413      	add	r3, r2
34184732:	2201      	movs	r2, #1
34184734:	705a      	strb	r2, [r3, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
34184736:	4a1b      	ldr	r2, [pc, #108]	@ (341847a4 <BSP_XSPI_RAM_Init+0xec>)
34184738:	687b      	ldr	r3, [r7, #4]
3418473a:	009b      	lsls	r3, r3, #2
3418473c:	4413      	add	r3, r2
3418473e:	2201      	movs	r2, #1
34184740:	709a      	strb	r2, [r3, #2]
    }

    /* Read Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
34184742:	687b      	ldr	r3, [r7, #4]
34184744:	2264      	movs	r2, #100	@ 0x64
34184746:	fb02 f303 	mul.w	r3, r2, r3
3418474a:	4a17      	ldr	r2, [pc, #92]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
3418474c:	4413      	add	r3, r2
3418474e:	2230      	movs	r2, #48	@ 0x30
34184750:	2100      	movs	r1, #0
34184752:	4618      	mov	r0, r3
34184754:	f011 fce0 	bl	34196118 <APS256XX_WriteReg>

    /* Write Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
34184758:	687b      	ldr	r3, [r7, #4]
3418475a:	2264      	movs	r2, #100	@ 0x64
3418475c:	fb02 f303 	mul.w	r3, r2, r3
34184760:	4a11      	ldr	r2, [pc, #68]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
34184762:	4413      	add	r3, r2
34184764:	2220      	movs	r2, #32
34184766:	2104      	movs	r1, #4
34184768:	4618      	mov	r0, r3
3418476a:	f011 fcd5 	bl	34196118 <APS256XX_WriteReg>

    /* Switch to x16 mode */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
3418476e:	687b      	ldr	r3, [r7, #4]
34184770:	2264      	movs	r2, #100	@ 0x64
34184772:	fb02 f303 	mul.w	r3, r2, r3
34184776:	4a0c      	ldr	r2, [pc, #48]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
34184778:	4413      	add	r3, r2
3418477a:	2240      	movs	r2, #64	@ 0x40
3418477c:	2108      	movs	r1, #8
3418477e:	4618      	mov	r0, r3
34184780:	f011 fcca 	bl	34196118 <APS256XX_WriteReg>

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
34184784:	687b      	ldr	r3, [r7, #4]
34184786:	2264      	movs	r2, #100	@ 0x64
34184788:	fb02 f303 	mul.w	r3, r2, r3
3418478c:	4a06      	ldr	r2, [pc, #24]	@ (341847a8 <BSP_XSPI_RAM_Init+0xf0>)
3418478e:	4413      	add	r3, r2
34184790:	2100      	movs	r1, #0
34184792:	4618      	mov	r0, r3
34184794:	f011 f8a9 	bl	341958ea <HAL_XSPI_SetClockPrescaler>

  }

  /* Return BSP status */
  return ret;
34184798:	69fb      	ldr	r3, [r7, #28]
}
3418479a:	4618      	mov	r0, r3
3418479c:	3720      	adds	r7, #32
3418479e:	46bd      	mov	sp, r7
341847a0:	bd80      	pop	{r7, pc}
341847a2:	bf00      	nop
341847a4:	341c119c 	.word	0x341c119c
341847a8:	341c1138 	.word	0x341c1138

341847ac <MX_XSPI_RAM_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_RAM_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
341847ac:	b580      	push	{r7, lr}
341847ae:	b084      	sub	sp, #16
341847b0:	af00      	add	r7, sp, #0
341847b2:	6078      	str	r0, [r7, #4]
341847b4:	6039      	str	r1, [r7, #0]
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
341847b6:	f04f 0000 	mov.w	r0, #0
341847ba:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
341847be:	f00c f9f3 	bl	34190ba8 <HAL_RCCEx_GetPeriphCLKFreq>
341847c2:	60f8      	str	r0, [r7, #12]

  /* XSPI initialization */
  hxspi->Instance = XSPI1;
341847c4:	687b      	ldr	r3, [r7, #4]
341847c6:	4a21      	ldr	r2, [pc, #132]	@ (3418484c <MX_XSPI_RAM_Init+0xa0>)
341847c8:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte          = 8;
341847ca:	687b      	ldr	r3, [r7, #4]
341847cc:	2208      	movs	r2, #8
341847ce:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemoryType                 = HAL_XSPI_MEMTYPE_APMEM_16BITS;
341847d0:	687b      	ldr	r3, [r7, #4]
341847d2:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
341847d6:	60da      	str	r2, [r3, #12]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
341847d8:	687b      	ldr	r3, [r7, #4]
341847da:	2200      	movs	r2, #0
341847dc:	609a      	str	r2, [r3, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
341847de:	683b      	ldr	r3, [r7, #0]
341847e0:	681a      	ldr	r2, [r3, #0]
341847e2:	687b      	ldr	r3, [r7, #4]
341847e4:	611a      	str	r2, [r3, #16]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
341847e6:	687b      	ldr	r3, [r7, #4]
341847e8:	2200      	movs	r2, #0
341847ea:	63da      	str	r2, [r3, #60]	@ 0x3c
  hxspi->Init.ChipSelectHighTimeCycle    = 5;
341847ec:	687b      	ldr	r3, [r7, #4]
341847ee:	2205      	movs	r2, #5
341847f0:	615a      	str	r2, [r3, #20]
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
341847f2:	687b      	ldr	r3, [r7, #4]
341847f4:	2200      	movs	r2, #0
341847f6:	61da      	str	r2, [r3, #28]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
341847f8:	683b      	ldr	r3, [r7, #0]
341847fa:	685a      	ldr	r2, [r3, #4]
341847fc:	687b      	ldr	r3, [r7, #4]
341847fe:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting             = Init->SampleShifting;
34184800:	683b      	ldr	r3, [r7, #0]
34184802:	689a      	ldr	r2, [r3, #8]
34184804:	687b      	ldr	r3, [r7, #4]
34184806:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.DelayHoldQuarterCycle      = HAL_XSPI_DHQC_ENABLE;
34184808:	687b      	ldr	r3, [r7, #4]
3418480a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
3418480e:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
34184810:	687b      	ldr	r3, [r7, #4]
34184812:	220b      	movs	r2, #11
34184814:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
34184816:	687b      	ldr	r3, [r7, #4]
34184818:	2200      	movs	r2, #0
3418481a:	619a      	str	r2, [r3, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
3418481c:	687b      	ldr	r3, [r7, #4]
3418481e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34184820:	68fa      	ldr	r2, [r7, #12]
34184822:	fbb2 f3f3 	udiv	r3, r2, r3
34184826:	005b      	lsls	r3, r3, #1
34184828:	4a09      	ldr	r2, [pc, #36]	@ (34184850 <MX_XSPI_RAM_Init+0xa4>)
3418482a:	fba2 2303 	umull	r2, r3, r2, r3
3418482e:	0c9b      	lsrs	r3, r3, #18
34184830:	1f1a      	subs	r2, r3, #4
34184832:	687b      	ldr	r3, [r7, #4]
34184834:	639a      	str	r2, [r3, #56]	@ 0x38
#if defined (OCTOSPI_DCR1_DLYBYP)
  hxspi->Init.DelayBlockBypass           = HAL_XSPI_DELAY_BLOCK_BYPASS;
#endif /* defined (OCTOSPI_DCR1_DLYBYP) */
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
34184836:	687b      	ldr	r3, [r7, #4]
34184838:	2200      	movs	r2, #0
3418483a:	621a      	str	r2, [r3, #32]

  return HAL_XSPI_Init(hxspi);
3418483c:	6878      	ldr	r0, [r7, #4]
3418483e:	f010 fc21 	bl	34195084 <HAL_XSPI_Init>
34184842:	4603      	mov	r3, r0
}
34184844:	4618      	mov	r0, r3
34184846:	3710      	adds	r7, #16
34184848:	46bd      	mov	sp, r7
3418484a:	bd80      	pop	{r7, pc}
3418484c:	58025000 	.word	0x58025000
34184850:	431bde83 	.word	0x431bde83

34184854 <BSP_XSPI_RAM_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_EnableMemoryMappedMode(uint32_t Instance)
{
34184854:	b580      	push	{r7, lr}
34184856:	b086      	sub	sp, #24
34184858:	af02      	add	r7, sp, #8
3418485a:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
3418485c:	2300      	movs	r3, #0
3418485e:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34184860:	687b      	ldr	r3, [r7, #4]
34184862:	2b00      	cmp	r3, #0
34184864:	d003      	beq.n	3418486e <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184866:	f06f 0301 	mvn.w	r3, #1
3418486a:	60fb      	str	r3, [r7, #12]
3418486c:	e012      	b.n	34184894 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
  }
  else
  {
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
3418486e:	687b      	ldr	r3, [r7, #4]
34184870:	2264      	movs	r2, #100	@ 0x64
34184872:	fb02 f303 	mul.w	r3, r2, r3
34184876:	4a0a      	ldr	r2, [pc, #40]	@ (341848a0 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x4c>)
34184878:	1898      	adds	r0, r3, r2
3418487a:	2300      	movs	r3, #0
3418487c:	9300      	str	r3, [sp, #0]
3418487e:	2301      	movs	r3, #1
34184880:	2207      	movs	r2, #7
34184882:	2107      	movs	r1, #7
34184884:	f011 fbcc 	bl	34196020 <APS256XX_EnableMemoryMappedMode>
34184888:	4603      	mov	r3, r0
3418488a:	2b00      	cmp	r3, #0
3418488c:	d002      	beq.n	34184894 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
3418488e:	f06f 0303 	mvn.w	r3, #3
34184892:	60fb      	str	r3, [r7, #12]
    }
  }


  /* Return BSP status */
  return ret;
34184894:	68fb      	ldr	r3, [r7, #12]
}
34184896:	4618      	mov	r0, r3
34184898:	3710      	adds	r7, #16
3418489a:	46bd      	mov	sp, r7
3418489c:	bd80      	pop	{r7, pc}
3418489e:	bf00      	nop
341848a0:	341c1138 	.word	0x341c1138

341848a4 <XSPI_NOR_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_NOR_MspInit(const XSPI_HandleTypeDef *hxspi)
{
341848a4:	b580      	push	{r7, lr}
341848a6:	b088      	sub	sp, #32
341848a8:	af00      	add	r7, sp, #0
341848aa:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

  /* Enable the XSPI memory interface clock */
  XSPI_NOR_CLK_ENABLE();
341848ac:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
341848b0:	f7ff fce6 	bl	34184280 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_NOR_FORCE_RESET();
341848b4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
341848b8:	f7ff fcf8 	bl	341842ac <LL_AHB5_GRP1_ForceReset>
  XSPI_NOR_RELEASE_RESET();
341848bc:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
341848c0:	f7ff fd04 	bl	341842cc <LL_AHB5_GRP1_ReleaseReset>

  /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
341848c4:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
341848c8:	f7ff fcc4 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
341848cc:	f006 fe4c 	bl	3418b568 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
341848d0:	2101      	movs	r1, #1
341848d2:	2002      	movs	r0, #2
341848d4:	f006 fde6 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  /* Enable GPIO clocks */
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
341848d8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341848dc:	f7ff fcba 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
341848e0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341848e4:	f7ff fcb6 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
341848e8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341848ec:	f7ff fcb2 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
341848f0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341848f4:	f7ff fcae 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
341848f8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341848fc:	f7ff fcaa 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
34184900:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34184904:	f7ff fca6 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
34184908:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418490c:	f7ff fca2 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
34184910:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34184914:	f7ff fc9e 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
34184918:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418491c:	f7ff fc9a 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
34184920:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34184924:	f7ff fc96 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
34184928:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418492c:	f7ff fc92 	bl	34184254 <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
34184930:	2302      	movs	r3, #2
34184932:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34184934:	2302      	movs	r3, #2
34184936:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34184938:	2301      	movs	r3, #1
3418493a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3418493c:	2303      	movs	r3, #3
3418493e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34184940:	2309      	movs	r3, #9
34184942:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
34184944:	f107 030c 	add.w	r3, r7, #12
34184948:	4619      	mov	r1, r3
3418494a:	4838      	ldr	r0, [pc, #224]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
3418494c:	f003 fe9e 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI DQS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
34184950:	2301      	movs	r3, #1
34184952:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
34184954:	2309      	movs	r3, #9
34184956:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
34184958:	f107 030c 	add.w	r3, r7, #12
3418495c:	4619      	mov	r1, r3
3418495e:	4833      	ldr	r0, [pc, #204]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
34184960:	f003 fe94 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
34184964:	2340      	movs	r3, #64	@ 0x40
34184966:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
34184968:	2300      	movs	r3, #0
3418496a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
3418496c:	2309      	movs	r3, #9
3418496e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
34184970:	f107 030c 	add.w	r3, r7, #12
34184974:	4619      	mov	r1, r3
34184976:	482d      	ldr	r0, [pc, #180]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
34184978:	f003 fe88 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
3418497c:	2304      	movs	r3, #4
3418497e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
34184980:	2309      	movs	r3, #9
34184982:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34184984:	f107 030c 	add.w	r3, r7, #12
34184988:	4619      	mov	r1, r3
3418498a:	4828      	ldr	r0, [pc, #160]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
3418498c:	f003 fe7e 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
34184990:	2308      	movs	r3, #8
34184992:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
34184994:	2309      	movs	r3, #9
34184996:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
34184998:	f107 030c 	add.w	r3, r7, #12
3418499c:	4619      	mov	r1, r3
3418499e:	4823      	ldr	r0, [pc, #140]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
341849a0:	f003 fe74 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
341849a4:	2310      	movs	r3, #16
341849a6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
341849a8:	2309      	movs	r3, #9
341849aa:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
341849ac:	f107 030c 	add.w	r3, r7, #12
341849b0:	4619      	mov	r1, r3
341849b2:	481e      	ldr	r0, [pc, #120]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
341849b4:	f003 fe6a 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
341849b8:	2320      	movs	r3, #32
341849ba:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
341849bc:	2309      	movs	r3, #9
341849be:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
341849c0:	f107 030c 	add.w	r3, r7, #12
341849c4:	4619      	mov	r1, r3
341849c6:	4819      	ldr	r0, [pc, #100]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
341849c8:	f003 fe60 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
341849cc:	f44f 7380 	mov.w	r3, #256	@ 0x100
341849d0:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
341849d2:	2309      	movs	r3, #9
341849d4:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
341849d6:	f107 030c 	add.w	r3, r7, #12
341849da:	4619      	mov	r1, r3
341849dc:	4813      	ldr	r0, [pc, #76]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
341849de:	f003 fe55 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
341849e2:	f44f 7300 	mov.w	r3, #512	@ 0x200
341849e6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
341849e8:	2309      	movs	r3, #9
341849ea:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
341849ec:	f107 030c 	add.w	r3, r7, #12
341849f0:	4619      	mov	r1, r3
341849f2:	480e      	ldr	r0, [pc, #56]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
341849f4:	f003 fe4a 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
341849f8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341849fc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
341849fe:	2309      	movs	r3, #9
34184a00:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
34184a02:	f107 030c 	add.w	r3, r7, #12
34184a06:	4619      	mov	r1, r3
34184a08:	4808      	ldr	r0, [pc, #32]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
34184a0a:	f003 fe3f 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34184a0e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34184a12:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
34184a14:	2309      	movs	r3, #9
34184a16:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34184a18:	f107 030c 	add.w	r3, r7, #12
34184a1c:	4619      	mov	r1, r3
34184a1e:	4803      	ldr	r0, [pc, #12]	@ (34184a2c <XSPI_NOR_MspInit+0x188>)
34184a20:	f003 fe34 	bl	3418868c <HAL_GPIO_Init>
}
34184a24:	bf00      	nop
34184a26:	3720      	adds	r7, #32
34184a28:	46bd      	mov	sp, r7
34184a2a:	bd80      	pop	{r7, pc}
34184a2c:	56023400 	.word	0x56023400

34184a30 <XSPI_NOR_ResetMemory>:
  * @brief  This function reset the XSPI memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ResetMemory(uint32_t Instance)
{
34184a30:	b580      	push	{r7, lr}
34184a32:	b084      	sub	sp, #16
34184a34:	af00      	add	r7, sp, #0
34184a36:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34184a38:	2300      	movs	r3, #0
34184a3a:	60fb      	str	r3, [r7, #12]

  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34184a3c:	687b      	ldr	r3, [r7, #4]
34184a3e:	2264      	movs	r2, #100	@ 0x64
34184a40:	fb02 f303 	mul.w	r3, r2, r3
34184a44:	4a44      	ldr	r2, [pc, #272]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184a46:	4413      	add	r3, r2
34184a48:	2200      	movs	r2, #0
34184a4a:	2100      	movs	r1, #0
34184a4c:	4618      	mov	r0, r3
34184a4e:	f011 ff9e 	bl	3419698e <MX66UW1G45G_ResetEnable>
34184a52:	4603      	mov	r3, r0
34184a54:	2b00      	cmp	r3, #0
34184a56:	d003      	beq.n	34184a60 <XSPI_NOR_ResetMemory+0x30>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184a58:	f06f 0304 	mvn.w	r3, #4
34184a5c:	60fb      	str	r3, [r7, #12]
34184a5e:	e076      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34184a60:	687b      	ldr	r3, [r7, #4]
34184a62:	2264      	movs	r2, #100	@ 0x64
34184a64:	fb02 f303 	mul.w	r3, r2, r3
34184a68:	4a3b      	ldr	r2, [pc, #236]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184a6a:	4413      	add	r3, r2
34184a6c:	2200      	movs	r2, #0
34184a6e:	2100      	movs	r1, #0
34184a70:	4618      	mov	r0, r3
34184a72:	f011 ffe2 	bl	34196a3a <MX66UW1G45G_ResetMemory>
34184a76:	4603      	mov	r3, r0
34184a78:	2b00      	cmp	r3, #0
34184a7a:	d003      	beq.n	34184a84 <XSPI_NOR_ResetMemory+0x54>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184a7c:	f06f 0304 	mvn.w	r3, #4
34184a80:	60fb      	str	r3, [r7, #12]
34184a82:	e064      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184a84:	687b      	ldr	r3, [r7, #4]
34184a86:	2264      	movs	r2, #100	@ 0x64
34184a88:	fb02 f303 	mul.w	r3, r2, r3
34184a8c:	4a32      	ldr	r2, [pc, #200]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184a8e:	4413      	add	r3, r2
34184a90:	2200      	movs	r2, #0
34184a92:	2101      	movs	r1, #1
34184a94:	4618      	mov	r0, r3
34184a96:	f011 ff7a 	bl	3419698e <MX66UW1G45G_ResetEnable>
34184a9a:	4603      	mov	r3, r0
34184a9c:	2b00      	cmp	r3, #0
34184a9e:	d003      	beq.n	34184aa8 <XSPI_NOR_ResetMemory+0x78>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184aa0:	f06f 0304 	mvn.w	r3, #4
34184aa4:	60fb      	str	r3, [r7, #12]
34184aa6:	e052      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184aa8:	687b      	ldr	r3, [r7, #4]
34184aaa:	2264      	movs	r2, #100	@ 0x64
34184aac:	fb02 f303 	mul.w	r3, r2, r3
34184ab0:	4a29      	ldr	r2, [pc, #164]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184ab2:	4413      	add	r3, r2
34184ab4:	2200      	movs	r2, #0
34184ab6:	2101      	movs	r1, #1
34184ab8:	4618      	mov	r0, r3
34184aba:	f011 ffbe 	bl	34196a3a <MX66UW1G45G_ResetMemory>
34184abe:	4603      	mov	r3, r0
34184ac0:	2b00      	cmp	r3, #0
34184ac2:	d003      	beq.n	34184acc <XSPI_NOR_ResetMemory+0x9c>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184ac4:	f06f 0304 	mvn.w	r3, #4
34184ac8:	60fb      	str	r3, [r7, #12]
34184aca:	e040      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184acc:	687b      	ldr	r3, [r7, #4]
34184ace:	2264      	movs	r2, #100	@ 0x64
34184ad0:	fb02 f303 	mul.w	r3, r2, r3
34184ad4:	4a20      	ldr	r2, [pc, #128]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184ad6:	4413      	add	r3, r2
34184ad8:	2201      	movs	r2, #1
34184ada:	2101      	movs	r1, #1
34184adc:	4618      	mov	r0, r3
34184ade:	f011 ff56 	bl	3419698e <MX66UW1G45G_ResetEnable>
34184ae2:	4603      	mov	r3, r0
34184ae4:	2b00      	cmp	r3, #0
34184ae6:	d003      	beq.n	34184af0 <XSPI_NOR_ResetMemory+0xc0>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184ae8:	f06f 0304 	mvn.w	r3, #4
34184aec:	60fb      	str	r3, [r7, #12]
34184aee:	e02e      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184af0:	687b      	ldr	r3, [r7, #4]
34184af2:	2264      	movs	r2, #100	@ 0x64
34184af4:	fb02 f303 	mul.w	r3, r2, r3
34184af8:	4a17      	ldr	r2, [pc, #92]	@ (34184b58 <XSPI_NOR_ResetMemory+0x128>)
34184afa:	4413      	add	r3, r2
34184afc:	2201      	movs	r2, #1
34184afe:	2101      	movs	r1, #1
34184b00:	4618      	mov	r0, r3
34184b02:	f011 ff9a 	bl	34196a3a <MX66UW1G45G_ResetMemory>
34184b06:	4603      	mov	r3, r0
34184b08:	2b00      	cmp	r3, #0
34184b0a:	d003      	beq.n	34184b14 <XSPI_NOR_ResetMemory+0xe4>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184b0c:	f06f 0304 	mvn.w	r3, #4
34184b10:	60fb      	str	r3, [r7, #12]
34184b12:	e01c      	b.n	34184b4e <XSPI_NOR_ResetMemory+0x11e>
  }
  else
  {
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
34184b14:	4911      	ldr	r1, [pc, #68]	@ (34184b5c <XSPI_NOR_ResetMemory+0x12c>)
34184b16:	687a      	ldr	r2, [r7, #4]
34184b18:	4613      	mov	r3, r2
34184b1a:	005b      	lsls	r3, r3, #1
34184b1c:	4413      	add	r3, r2
34184b1e:	440b      	add	r3, r1
34184b20:	2201      	movs	r2, #1
34184b22:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
34184b24:	490d      	ldr	r1, [pc, #52]	@ (34184b5c <XSPI_NOR_ResetMemory+0x12c>)
34184b26:	687a      	ldr	r2, [r7, #4]
34184b28:	4613      	mov	r3, r2
34184b2a:	005b      	lsls	r3, r3, #1
34184b2c:	4413      	add	r3, r2
34184b2e:	440b      	add	r3, r1
34184b30:	3301      	adds	r3, #1
34184b32:	2200      	movs	r2, #0
34184b34:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
34184b36:	4909      	ldr	r1, [pc, #36]	@ (34184b5c <XSPI_NOR_ResetMemory+0x12c>)
34184b38:	687a      	ldr	r2, [r7, #4]
34184b3a:	4613      	mov	r3, r2
34184b3c:	005b      	lsls	r3, r3, #1
34184b3e:	4413      	add	r3, r2
34184b40:	440b      	add	r3, r1
34184b42:	3302      	adds	r3, #2
34184b44:	2200      	movs	r2, #0
34184b46:	701a      	strb	r2, [r3, #0]

    /* After SWreset CMD, wait in case SWReset occurred during erase operation */
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34184b48:	2064      	movs	r0, #100	@ 0x64
34184b4a:	f000 fc0d 	bl	34185368 <HAL_Delay>
  }

  /* Return BSP status */
  return ret;
34184b4e:	68fb      	ldr	r3, [r7, #12]
}
34184b50:	4618      	mov	r0, r3
34184b52:	3710      	adds	r7, #16
34184b54:	46bd      	mov	sp, r7
34184b56:	bd80      	pop	{r7, pc}
34184b58:	341c10d0 	.word	0x341c10d0
34184b5c:	341c1134 	.word	0x341c1134

34184b60 <XSPI_NOR_EnterDOPIMode>:
  * @brief  This function enables the octal DTR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
{
34184b60:	b590      	push	{r4, r7, lr}
34184b62:	b087      	sub	sp, #28
34184b64:	af02      	add	r7, sp, #8
34184b66:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184b68:	687b      	ldr	r3, [r7, #4]
34184b6a:	2264      	movs	r2, #100	@ 0x64
34184b6c:	fb02 f303 	mul.w	r3, r2, r3
34184b70:	4a6e      	ldr	r2, [pc, #440]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184b72:	1898      	adds	r0, r3, r2
34184b74:	496e      	ldr	r1, [pc, #440]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184b76:	687a      	ldr	r2, [r7, #4]
34184b78:	4613      	mov	r3, r2
34184b7a:	005b      	lsls	r3, r3, #1
34184b7c:	4413      	add	r3, r2
34184b7e:	440b      	add	r3, r1
34184b80:	3301      	adds	r3, #1
34184b82:	7819      	ldrb	r1, [r3, #0]
34184b84:	4c6a      	ldr	r4, [pc, #424]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184b86:	687a      	ldr	r2, [r7, #4]
34184b88:	4613      	mov	r3, r2
34184b8a:	005b      	lsls	r3, r3, #1
34184b8c:	4413      	add	r3, r2
34184b8e:	4423      	add	r3, r4
34184b90:	3302      	adds	r3, #2
34184b92:	781b      	ldrb	r3, [r3, #0]
34184b94:	461a      	mov	r2, r3
34184b96:	f011 fd02 	bl	3419659e <MX66UW1G45G_WriteEnable>
34184b9a:	4603      	mov	r3, r0
34184b9c:	2b00      	cmp	r3, #0
34184b9e:	d003      	beq.n	34184ba8 <XSPI_NOR_EnterDOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184ba0:	f06f 0304 	mvn.w	r3, #4
34184ba4:	60fb      	str	r3, [r7, #12]
34184ba6:	e0bb      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184ba8:	687b      	ldr	r3, [r7, #4]
34184baa:	2264      	movs	r2, #100	@ 0x64
34184bac:	fb02 f303 	mul.w	r3, r2, r3
34184bb0:	4a5e      	ldr	r2, [pc, #376]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184bb2:	1898      	adds	r0, r3, r2
34184bb4:	495e      	ldr	r1, [pc, #376]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184bb6:	687a      	ldr	r2, [r7, #4]
34184bb8:	4613      	mov	r3, r2
34184bba:	005b      	lsls	r3, r3, #1
34184bbc:	4413      	add	r3, r2
34184bbe:	440b      	add	r3, r1
34184bc0:	3301      	adds	r3, #1
34184bc2:	7819      	ldrb	r1, [r3, #0]
34184bc4:	4c5a      	ldr	r4, [pc, #360]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184bc6:	687a      	ldr	r2, [r7, #4]
34184bc8:	4613      	mov	r3, r2
34184bca:	005b      	lsls	r3, r3, #1
34184bcc:	4413      	add	r3, r2
34184bce:	4423      	add	r3, r4
34184bd0:	3302      	adds	r3, #2
34184bd2:	781a      	ldrb	r2, [r3, #0]
34184bd4:	2300      	movs	r3, #0
34184bd6:	9300      	str	r3, [sp, #0]
34184bd8:	f44f 7340 	mov.w	r3, #768	@ 0x300
34184bdc:	f011 fdab 	bl	34196736 <MX66UW1G45G_WriteCfg2Register>
34184be0:	4603      	mov	r3, r0
34184be2:	2b00      	cmp	r3, #0
34184be4:	d003      	beq.n	34184bee <XSPI_NOR_EnterDOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184be6:	f06f 0304 	mvn.w	r3, #4
34184bea:	60fb      	str	r3, [r7, #12]
34184bec:	e098      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184bee:	687b      	ldr	r3, [r7, #4]
34184bf0:	2264      	movs	r2, #100	@ 0x64
34184bf2:	fb02 f303 	mul.w	r3, r2, r3
34184bf6:	4a4d      	ldr	r2, [pc, #308]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184bf8:	1898      	adds	r0, r3, r2
34184bfa:	494d      	ldr	r1, [pc, #308]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184bfc:	687a      	ldr	r2, [r7, #4]
34184bfe:	4613      	mov	r3, r2
34184c00:	005b      	lsls	r3, r3, #1
34184c02:	4413      	add	r3, r2
34184c04:	440b      	add	r3, r1
34184c06:	3301      	adds	r3, #1
34184c08:	7819      	ldrb	r1, [r3, #0]
34184c0a:	4c49      	ldr	r4, [pc, #292]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184c0c:	687a      	ldr	r2, [r7, #4]
34184c0e:	4613      	mov	r3, r2
34184c10:	005b      	lsls	r3, r3, #1
34184c12:	4413      	add	r3, r2
34184c14:	4423      	add	r3, r4
34184c16:	3302      	adds	r3, #2
34184c18:	781b      	ldrb	r3, [r3, #0]
34184c1a:	461a      	mov	r2, r3
34184c1c:	f011 fcbf 	bl	3419659e <MX66UW1G45G_WriteEnable>
34184c20:	4603      	mov	r3, r0
34184c22:	2b00      	cmp	r3, #0
34184c24:	d003      	beq.n	34184c2e <XSPI_NOR_EnterDOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184c26:	f06f 0304 	mvn.w	r3, #4
34184c2a:	60fb      	str	r3, [r7, #12]
34184c2c:	e078      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184c2e:	687b      	ldr	r3, [r7, #4]
34184c30:	2264      	movs	r2, #100	@ 0x64
34184c32:	fb02 f303 	mul.w	r3, r2, r3
34184c36:	4a3d      	ldr	r2, [pc, #244]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184c38:	1898      	adds	r0, r3, r2
34184c3a:	493d      	ldr	r1, [pc, #244]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184c3c:	687a      	ldr	r2, [r7, #4]
34184c3e:	4613      	mov	r3, r2
34184c40:	005b      	lsls	r3, r3, #1
34184c42:	4413      	add	r3, r2
34184c44:	440b      	add	r3, r1
34184c46:	3301      	adds	r3, #1
34184c48:	7819      	ldrb	r1, [r3, #0]
34184c4a:	4c39      	ldr	r4, [pc, #228]	@ (34184d30 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34184c4c:	687a      	ldr	r2, [r7, #4]
34184c4e:	4613      	mov	r3, r2
34184c50:	005b      	lsls	r3, r3, #1
34184c52:	4413      	add	r3, r2
34184c54:	4423      	add	r3, r4
34184c56:	3302      	adds	r3, #2
34184c58:	781a      	ldrb	r2, [r3, #0]
34184c5a:	2302      	movs	r3, #2
34184c5c:	9300      	str	r3, [sp, #0]
34184c5e:	2300      	movs	r3, #0
34184c60:	f011 fd69 	bl	34196736 <MX66UW1G45G_WriteCfg2Register>
34184c64:	4603      	mov	r3, r0
34184c66:	2b00      	cmp	r3, #0
34184c68:	d003      	beq.n	34184c72 <XSPI_NOR_EnterDOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_DOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184c6a:	f06f 0304 	mvn.w	r3, #4
34184c6e:	60fb      	str	r3, [r7, #12]
34184c70:	e056      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34184c72:	2028      	movs	r0, #40	@ 0x28
34184c74:	f000 fb78 	bl	34185368 <HAL_Delay>

    /* Reconfigure the memory type of the peripheral */
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34184c78:	4a2c      	ldr	r2, [pc, #176]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184c7a:	687b      	ldr	r3, [r7, #4]
34184c7c:	2164      	movs	r1, #100	@ 0x64
34184c7e:	fb01 f303 	mul.w	r3, r1, r3
34184c82:	4413      	add	r3, r2
34184c84:	330c      	adds	r3, #12
34184c86:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34184c8a:	601a      	str	r2, [r3, #0]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34184c8c:	4a27      	ldr	r2, [pc, #156]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184c8e:	687b      	ldr	r3, [r7, #4]
34184c90:	2164      	movs	r1, #100	@ 0x64
34184c92:	fb01 f303 	mul.w	r3, r1, r3
34184c96:	4413      	add	r3, r2
34184c98:	332c      	adds	r3, #44	@ 0x2c
34184c9a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34184c9e:	601a      	str	r2, [r3, #0]
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34184ca0:	687b      	ldr	r3, [r7, #4]
34184ca2:	2264      	movs	r2, #100	@ 0x64
34184ca4:	fb02 f303 	mul.w	r3, r2, r3
34184ca8:	4a20      	ldr	r2, [pc, #128]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184caa:	4413      	add	r3, r2
34184cac:	4618      	mov	r0, r3
34184cae:	f010 f9e9 	bl	34195084 <HAL_XSPI_Init>
34184cb2:	4603      	mov	r3, r0
34184cb4:	2b00      	cmp	r3, #0
34184cb6:	d003      	beq.n	34184cc0 <XSPI_NOR_EnterDOPIMode+0x160>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34184cb8:	f06f 0303 	mvn.w	r3, #3
34184cbc:	60fb      	str	r3, [r7, #12]
34184cbe:	e02f      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check Flash busy ? */
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184cc0:	687b      	ldr	r3, [r7, #4]
34184cc2:	2264      	movs	r2, #100	@ 0x64
34184cc4:	fb02 f303 	mul.w	r3, r2, r3
34184cc8:	4a18      	ldr	r2, [pc, #96]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184cca:	4413      	add	r3, r2
34184ccc:	2201      	movs	r2, #1
34184cce:	2101      	movs	r1, #1
34184cd0:	4618      	mov	r0, r3
34184cd2:	f011 faa1 	bl	34196218 <MX66UW1G45G_AutoPollingMemReady>
34184cd6:	4603      	mov	r3, r0
34184cd8:	2b00      	cmp	r3, #0
34184cda:	d003      	beq.n	34184ce4 <XSPI_NOR_EnterDOPIMode+0x184>
                                              BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184cdc:	f06f 0304 	mvn.w	r3, #4
34184ce0:	60fb      	str	r3, [r7, #12]
34184ce2:	e01d      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34184ce4:	687b      	ldr	r3, [r7, #4]
34184ce6:	2264      	movs	r2, #100	@ 0x64
34184ce8:	fb02 f303 	mul.w	r3, r2, r3
34184cec:	4a0f      	ldr	r2, [pc, #60]	@ (34184d2c <XSPI_NOR_EnterDOPIMode+0x1cc>)
34184cee:	1898      	adds	r0, r3, r2
34184cf0:	f107 0308 	add.w	r3, r7, #8
34184cf4:	9300      	str	r3, [sp, #0]
34184cf6:	2300      	movs	r3, #0
34184cf8:	2201      	movs	r2, #1
34184cfa:	2101      	movs	r1, #1
34184cfc:	f011 fdac 	bl	34196858 <MX66UW1G45G_ReadCfg2Register>
34184d00:	4603      	mov	r3, r0
34184d02:	2b00      	cmp	r3, #0
34184d04:	d003      	beq.n	34184d0e <XSPI_NOR_EnterDOPIMode+0x1ae>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184d06:	f06f 0304 	mvn.w	r3, #4
34184d0a:	60fb      	str	r3, [r7, #12]
34184d0c:	e008      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34184d0e:	7a3b      	ldrb	r3, [r7, #8]
34184d10:	2b02      	cmp	r3, #2
34184d12:	d003      	beq.n	34184d1c <XSPI_NOR_EnterDOPIMode+0x1bc>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184d14:	f06f 0304 	mvn.w	r3, #4
34184d18:	60fb      	str	r3, [r7, #12]
34184d1a:	e001      	b.n	34184d20 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34184d1c:	2300      	movs	r3, #0
34184d1e:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34184d20:	68fb      	ldr	r3, [r7, #12]
}
34184d22:	4618      	mov	r0, r3
34184d24:	3714      	adds	r7, #20
34184d26:	46bd      	mov	sp, r7
34184d28:	bd90      	pop	{r4, r7, pc}
34184d2a:	bf00      	nop
34184d2c:	341c10d0 	.word	0x341c10d0
34184d30:	341c1134 	.word	0x341c1134

34184d34 <XSPI_NOR_EnterSOPIMode>:
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
{
34184d34:	b590      	push	{r4, r7, lr}
34184d36:	b087      	sub	sp, #28
34184d38:	af02      	add	r7, sp, #8
34184d3a:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184d3c:	687b      	ldr	r3, [r7, #4]
34184d3e:	2264      	movs	r2, #100	@ 0x64
34184d40:	fb02 f303 	mul.w	r3, r2, r3
34184d44:	4a5c      	ldr	r2, [pc, #368]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184d46:	1898      	adds	r0, r3, r2
34184d48:	495c      	ldr	r1, [pc, #368]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184d4a:	687a      	ldr	r2, [r7, #4]
34184d4c:	4613      	mov	r3, r2
34184d4e:	005b      	lsls	r3, r3, #1
34184d50:	4413      	add	r3, r2
34184d52:	440b      	add	r3, r1
34184d54:	3301      	adds	r3, #1
34184d56:	7819      	ldrb	r1, [r3, #0]
34184d58:	4c58      	ldr	r4, [pc, #352]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184d5a:	687a      	ldr	r2, [r7, #4]
34184d5c:	4613      	mov	r3, r2
34184d5e:	005b      	lsls	r3, r3, #1
34184d60:	4413      	add	r3, r2
34184d62:	4423      	add	r3, r4
34184d64:	3302      	adds	r3, #2
34184d66:	781b      	ldrb	r3, [r3, #0]
34184d68:	461a      	mov	r2, r3
34184d6a:	f011 fc18 	bl	3419659e <MX66UW1G45G_WriteEnable>
34184d6e:	4603      	mov	r3, r0
34184d70:	2b00      	cmp	r3, #0
34184d72:	d003      	beq.n	34184d7c <XSPI_NOR_EnterSOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184d74:	f06f 0304 	mvn.w	r3, #4
34184d78:	60fb      	str	r3, [r7, #12]
34184d7a:	e097      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184d7c:	687b      	ldr	r3, [r7, #4]
34184d7e:	2264      	movs	r2, #100	@ 0x64
34184d80:	fb02 f303 	mul.w	r3, r2, r3
34184d84:	4a4c      	ldr	r2, [pc, #304]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184d86:	1898      	adds	r0, r3, r2
34184d88:	494c      	ldr	r1, [pc, #304]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184d8a:	687a      	ldr	r2, [r7, #4]
34184d8c:	4613      	mov	r3, r2
34184d8e:	005b      	lsls	r3, r3, #1
34184d90:	4413      	add	r3, r2
34184d92:	440b      	add	r3, r1
34184d94:	3301      	adds	r3, #1
34184d96:	7819      	ldrb	r1, [r3, #0]
34184d98:	4c48      	ldr	r4, [pc, #288]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184d9a:	687a      	ldr	r2, [r7, #4]
34184d9c:	4613      	mov	r3, r2
34184d9e:	005b      	lsls	r3, r3, #1
34184da0:	4413      	add	r3, r2
34184da2:	4423      	add	r3, r4
34184da4:	3302      	adds	r3, #2
34184da6:	781a      	ldrb	r2, [r3, #0]
34184da8:	2300      	movs	r3, #0
34184daa:	9300      	str	r3, [sp, #0]
34184dac:	f44f 7340 	mov.w	r3, #768	@ 0x300
34184db0:	f011 fcc1 	bl	34196736 <MX66UW1G45G_WriteCfg2Register>
34184db4:	4603      	mov	r3, r0
34184db6:	2b00      	cmp	r3, #0
34184db8:	d003      	beq.n	34184dc2 <XSPI_NOR_EnterSOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184dba:	f06f 0304 	mvn.w	r3, #4
34184dbe:	60fb      	str	r3, [r7, #12]
34184dc0:	e074      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184dc2:	687b      	ldr	r3, [r7, #4]
34184dc4:	2264      	movs	r2, #100	@ 0x64
34184dc6:	fb02 f303 	mul.w	r3, r2, r3
34184dca:	4a3b      	ldr	r2, [pc, #236]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184dcc:	1898      	adds	r0, r3, r2
34184dce:	493b      	ldr	r1, [pc, #236]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184dd0:	687a      	ldr	r2, [r7, #4]
34184dd2:	4613      	mov	r3, r2
34184dd4:	005b      	lsls	r3, r3, #1
34184dd6:	4413      	add	r3, r2
34184dd8:	440b      	add	r3, r1
34184dda:	3301      	adds	r3, #1
34184ddc:	7819      	ldrb	r1, [r3, #0]
34184dde:	4c37      	ldr	r4, [pc, #220]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184de0:	687a      	ldr	r2, [r7, #4]
34184de2:	4613      	mov	r3, r2
34184de4:	005b      	lsls	r3, r3, #1
34184de6:	4413      	add	r3, r2
34184de8:	4423      	add	r3, r4
34184dea:	3302      	adds	r3, #2
34184dec:	781b      	ldrb	r3, [r3, #0]
34184dee:	461a      	mov	r2, r3
34184df0:	f011 fbd5 	bl	3419659e <MX66UW1G45G_WriteEnable>
34184df4:	4603      	mov	r3, r0
34184df6:	2b00      	cmp	r3, #0
34184df8:	d003      	beq.n	34184e02 <XSPI_NOR_EnterSOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184dfa:	f06f 0304 	mvn.w	r3, #4
34184dfe:	60fb      	str	r3, [r7, #12]
34184e00:	e054      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184e02:	687b      	ldr	r3, [r7, #4]
34184e04:	2264      	movs	r2, #100	@ 0x64
34184e06:	fb02 f303 	mul.w	r3, r2, r3
34184e0a:	4a2b      	ldr	r2, [pc, #172]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184e0c:	1898      	adds	r0, r3, r2
34184e0e:	492b      	ldr	r1, [pc, #172]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184e10:	687a      	ldr	r2, [r7, #4]
34184e12:	4613      	mov	r3, r2
34184e14:	005b      	lsls	r3, r3, #1
34184e16:	4413      	add	r3, r2
34184e18:	440b      	add	r3, r1
34184e1a:	3301      	adds	r3, #1
34184e1c:	7819      	ldrb	r1, [r3, #0]
34184e1e:	4c27      	ldr	r4, [pc, #156]	@ (34184ebc <XSPI_NOR_EnterSOPIMode+0x188>)
34184e20:	687a      	ldr	r2, [r7, #4]
34184e22:	4613      	mov	r3, r2
34184e24:	005b      	lsls	r3, r3, #1
34184e26:	4413      	add	r3, r2
34184e28:	4423      	add	r3, r4
34184e2a:	3302      	adds	r3, #2
34184e2c:	781a      	ldrb	r2, [r3, #0]
34184e2e:	2301      	movs	r3, #1
34184e30:	9300      	str	r3, [sp, #0]
34184e32:	2300      	movs	r3, #0
34184e34:	f011 fc7f 	bl	34196736 <MX66UW1G45G_WriteCfg2Register>
34184e38:	4603      	mov	r3, r0
34184e3a:	2b00      	cmp	r3, #0
34184e3c:	d003      	beq.n	34184e46 <XSPI_NOR_EnterSOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_SOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184e3e:	f06f 0304 	mvn.w	r3, #4
34184e42:	60fb      	str	r3, [r7, #12]
34184e44:	e032      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34184e46:	2028      	movs	r0, #40	@ 0x28
34184e48:	f000 fa8e 	bl	34185368 <HAL_Delay>

    /* Check Flash busy ? */
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34184e4c:	687b      	ldr	r3, [r7, #4]
34184e4e:	2264      	movs	r2, #100	@ 0x64
34184e50:	fb02 f303 	mul.w	r3, r2, r3
34184e54:	4a18      	ldr	r2, [pc, #96]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184e56:	4413      	add	r3, r2
34184e58:	2200      	movs	r2, #0
34184e5a:	2101      	movs	r1, #1
34184e5c:	4618      	mov	r0, r3
34184e5e:	f011 f9db 	bl	34196218 <MX66UW1G45G_AutoPollingMemReady>
34184e62:	4603      	mov	r3, r0
34184e64:	2b00      	cmp	r3, #0
34184e66:	d003      	beq.n	34184e70 <XSPI_NOR_EnterSOPIMode+0x13c>
                                         BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184e68:	f06f 0304 	mvn.w	r3, #4
34184e6c:	60fb      	str	r3, [r7, #12]
34184e6e:	e01d      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34184e70:	687b      	ldr	r3, [r7, #4]
34184e72:	2264      	movs	r2, #100	@ 0x64
34184e74:	fb02 f303 	mul.w	r3, r2, r3
34184e78:	4a0f      	ldr	r2, [pc, #60]	@ (34184eb8 <XSPI_NOR_EnterSOPIMode+0x184>)
34184e7a:	1898      	adds	r0, r3, r2
34184e7c:	f107 0308 	add.w	r3, r7, #8
34184e80:	9300      	str	r3, [sp, #0]
34184e82:	2300      	movs	r3, #0
34184e84:	2200      	movs	r2, #0
34184e86:	2101      	movs	r1, #1
34184e88:	f011 fce6 	bl	34196858 <MX66UW1G45G_ReadCfg2Register>
34184e8c:	4603      	mov	r3, r0
34184e8e:	2b00      	cmp	r3, #0
34184e90:	d003      	beq.n	34184e9a <XSPI_NOR_EnterSOPIMode+0x166>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184e92:	f06f 0304 	mvn.w	r3, #4
34184e96:	60fb      	str	r3, [r7, #12]
34184e98:	e008      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
34184e9a:	7a3b      	ldrb	r3, [r7, #8]
34184e9c:	2b01      	cmp	r3, #1
34184e9e:	d003      	beq.n	34184ea8 <XSPI_NOR_EnterSOPIMode+0x174>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184ea0:	f06f 0304 	mvn.w	r3, #4
34184ea4:	60fb      	str	r3, [r7, #12]
34184ea6:	e001      	b.n	34184eac <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34184ea8:	2300      	movs	r3, #0
34184eaa:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34184eac:	68fb      	ldr	r3, [r7, #12]
}
34184eae:	4618      	mov	r0, r3
34184eb0:	3714      	adds	r7, #20
34184eb2:	46bd      	mov	sp, r7
34184eb4:	bd90      	pop	{r4, r7, pc}
34184eb6:	bf00      	nop
34184eb8:	341c10d0 	.word	0x341c10d0
34184ebc:	341c1134 	.word	0x341c1134

34184ec0 <XSPI_NOR_ExitOPIMode>:
  * @brief  This function disables the octal DTR or STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
34184ec0:	b590      	push	{r4, r7, lr}
34184ec2:	b087      	sub	sp, #28
34184ec4:	af02      	add	r7, sp, #8
34184ec6:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34184ec8:	2300      	movs	r3, #0
34184eca:	60fb      	str	r3, [r7, #12]
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184ecc:	687b      	ldr	r3, [r7, #4]
34184ece:	2264      	movs	r2, #100	@ 0x64
34184ed0:	fb02 f303 	mul.w	r3, r2, r3
34184ed4:	4a52      	ldr	r2, [pc, #328]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184ed6:	1898      	adds	r0, r3, r2
34184ed8:	4952      	ldr	r1, [pc, #328]	@ (34185024 <XSPI_NOR_ExitOPIMode+0x164>)
34184eda:	687a      	ldr	r2, [r7, #4]
34184edc:	4613      	mov	r3, r2
34184ede:	005b      	lsls	r3, r3, #1
34184ee0:	4413      	add	r3, r2
34184ee2:	440b      	add	r3, r1
34184ee4:	3301      	adds	r3, #1
34184ee6:	7819      	ldrb	r1, [r3, #0]
34184ee8:	4c4e      	ldr	r4, [pc, #312]	@ (34185024 <XSPI_NOR_ExitOPIMode+0x164>)
34184eea:	687a      	ldr	r2, [r7, #4]
34184eec:	4613      	mov	r3, r2
34184eee:	005b      	lsls	r3, r3, #1
34184ef0:	4413      	add	r3, r2
34184ef2:	4423      	add	r3, r4
34184ef4:	3302      	adds	r3, #2
34184ef6:	781b      	ldrb	r3, [r3, #0]
34184ef8:	461a      	mov	r2, r3
34184efa:	f011 fb50 	bl	3419659e <MX66UW1G45G_WriteEnable>
34184efe:	4603      	mov	r3, r0
34184f00:	2b00      	cmp	r3, #0
34184f02:	d003      	beq.n	34184f0c <XSPI_NOR_ExitOPIMode+0x4c>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34184f04:	f06f 0304 	mvn.w	r3, #4
34184f08:	60fb      	str	r3, [r7, #12]
34184f0a:	e083      	b.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
34184f0c:	2300      	movs	r3, #0
34184f0e:	723b      	strb	r3, [r7, #8]
    reg[1] = 0;
34184f10:	2300      	movs	r3, #0
34184f12:	727b      	strb	r3, [r7, #9]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34184f14:	687b      	ldr	r3, [r7, #4]
34184f16:	2264      	movs	r2, #100	@ 0x64
34184f18:	fb02 f303 	mul.w	r3, r2, r3
34184f1c:	4a40      	ldr	r2, [pc, #256]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184f1e:	1898      	adds	r0, r3, r2
34184f20:	4940      	ldr	r1, [pc, #256]	@ (34185024 <XSPI_NOR_ExitOPIMode+0x164>)
34184f22:	687a      	ldr	r2, [r7, #4]
34184f24:	4613      	mov	r3, r2
34184f26:	005b      	lsls	r3, r3, #1
34184f28:	4413      	add	r3, r2
34184f2a:	440b      	add	r3, r1
34184f2c:	3301      	adds	r3, #1
34184f2e:	7819      	ldrb	r1, [r3, #0]
34184f30:	4c3c      	ldr	r4, [pc, #240]	@ (34185024 <XSPI_NOR_ExitOPIMode+0x164>)
34184f32:	687a      	ldr	r2, [r7, #4]
34184f34:	4613      	mov	r3, r2
34184f36:	005b      	lsls	r3, r3, #1
34184f38:	4413      	add	r3, r2
34184f3a:	4423      	add	r3, r4
34184f3c:	3302      	adds	r3, #2
34184f3e:	781a      	ldrb	r2, [r3, #0]
34184f40:	7a3b      	ldrb	r3, [r7, #8]
34184f42:	9300      	str	r3, [sp, #0]
34184f44:	2300      	movs	r3, #0
34184f46:	f011 fbf6 	bl	34196736 <MX66UW1G45G_WriteCfg2Register>
34184f4a:	4603      	mov	r3, r0
34184f4c:	2b00      	cmp	r3, #0
34184f4e:	d003      	beq.n	34184f58 <XSPI_NOR_ExitOPIMode+0x98>
                                       XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                       reg[0]) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34184f50:	f06f 0304 	mvn.w	r3, #4
34184f54:	60fb      	str	r3, [r7, #12]
34184f56:	e05d      	b.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34184f58:	2028      	movs	r0, #40	@ 0x28
34184f5a:	f000 fa05 	bl	34185368 <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
34184f5e:	4931      	ldr	r1, [pc, #196]	@ (34185024 <XSPI_NOR_ExitOPIMode+0x164>)
34184f60:	687a      	ldr	r2, [r7, #4]
34184f62:	4613      	mov	r3, r2
34184f64:	005b      	lsls	r3, r3, #1
34184f66:	4413      	add	r3, r2
34184f68:	440b      	add	r3, r1
34184f6a:	3302      	adds	r3, #2
34184f6c:	781b      	ldrb	r3, [r3, #0]
34184f6e:	2b01      	cmp	r3, #1
34184f70:	d120      	bne.n	34184fb4 <XSPI_NOR_ExitOPIMode+0xf4>
      {
        /* Reconfigure the memory type of the peripheral */
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34184f72:	4a2b      	ldr	r2, [pc, #172]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184f74:	687b      	ldr	r3, [r7, #4]
34184f76:	2164      	movs	r1, #100	@ 0x64
34184f78:	fb01 f303 	mul.w	r3, r1, r3
34184f7c:	4413      	add	r3, r2
34184f7e:	330c      	adds	r3, #12
34184f80:	2200      	movs	r2, #0
34184f82:	601a      	str	r2, [r3, #0]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34184f84:	4a26      	ldr	r2, [pc, #152]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184f86:	687b      	ldr	r3, [r7, #4]
34184f88:	2164      	movs	r1, #100	@ 0x64
34184f8a:	fb01 f303 	mul.w	r3, r1, r3
34184f8e:	4413      	add	r3, r2
34184f90:	332c      	adds	r3, #44	@ 0x2c
34184f92:	2200      	movs	r2, #0
34184f94:	601a      	str	r2, [r3, #0]
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34184f96:	687b      	ldr	r3, [r7, #4]
34184f98:	2264      	movs	r2, #100	@ 0x64
34184f9a:	fb02 f303 	mul.w	r3, r2, r3
34184f9e:	4a20      	ldr	r2, [pc, #128]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184fa0:	4413      	add	r3, r2
34184fa2:	4618      	mov	r0, r3
34184fa4:	f010 f86e 	bl	34195084 <HAL_XSPI_Init>
34184fa8:	4603      	mov	r3, r0
34184faa:	2b00      	cmp	r3, #0
34184fac:	d002      	beq.n	34184fb4 <XSPI_NOR_ExitOPIMode+0xf4>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34184fae:	f06f 0303 	mvn.w	r3, #3
34184fb2:	60fb      	str	r3, [r7, #12]
        }
      }

      if (ret == BSP_ERROR_NONE)
34184fb4:	68fb      	ldr	r3, [r7, #12]
34184fb6:	2b00      	cmp	r3, #0
34184fb8:	d12c      	bne.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34184fba:	687b      	ldr	r3, [r7, #4]
34184fbc:	2264      	movs	r2, #100	@ 0x64
34184fbe:	fb02 f303 	mul.w	r3, r2, r3
34184fc2:	4a17      	ldr	r2, [pc, #92]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184fc4:	4413      	add	r3, r2
34184fc6:	2200      	movs	r2, #0
34184fc8:	2100      	movs	r1, #0
34184fca:	4618      	mov	r0, r3
34184fcc:	f011 f924 	bl	34196218 <MX66UW1G45G_AutoPollingMemReady>
34184fd0:	4603      	mov	r3, r0
34184fd2:	2b00      	cmp	r3, #0
34184fd4:	d003      	beq.n	34184fde <XSPI_NOR_ExitOPIMode+0x11e>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34184fd6:	f06f 0304 	mvn.w	r3, #4
34184fda:	60fb      	str	r3, [r7, #12]
34184fdc:	e01a      	b.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34184fde:	687b      	ldr	r3, [r7, #4]
34184fe0:	2264      	movs	r2, #100	@ 0x64
34184fe2:	fb02 f303 	mul.w	r3, r2, r3
34184fe6:	4a0e      	ldr	r2, [pc, #56]	@ (34185020 <XSPI_NOR_ExitOPIMode+0x160>)
34184fe8:	1898      	adds	r0, r3, r2
34184fea:	f107 0308 	add.w	r3, r7, #8
34184fee:	9300      	str	r3, [sp, #0]
34184ff0:	2300      	movs	r3, #0
34184ff2:	2200      	movs	r2, #0
34184ff4:	2100      	movs	r1, #0
34184ff6:	f011 fc2f 	bl	34196858 <MX66UW1G45G_ReadCfg2Register>
34184ffa:	4603      	mov	r3, r0
34184ffc:	2b00      	cmp	r3, #0
34184ffe:	d003      	beq.n	34185008 <XSPI_NOR_ExitOPIMode+0x148>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34185000:	f06f 0304 	mvn.w	r3, #4
34185004:	60fb      	str	r3, [r7, #12]
34185006:	e005      	b.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
        }
        else if (reg[0] != 0U)
34185008:	7a3b      	ldrb	r3, [r7, #8]
3418500a:	2b00      	cmp	r3, #0
3418500c:	d002      	beq.n	34185014 <XSPI_NOR_ExitOPIMode+0x154>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
3418500e:	f06f 0304 	mvn.w	r3, #4
34185012:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  /* Return BSP status */
  return ret;
34185014:	68fb      	ldr	r3, [r7, #12]
}
34185016:	4618      	mov	r0, r3
34185018:	3714      	adds	r7, #20
3418501a:	46bd      	mov	sp, r7
3418501c:	bd90      	pop	{r4, r7, pc}
3418501e:	bf00      	nop
34185020:	341c10d0 	.word	0x341c10d0
34185024:	341c1134 	.word	0x341c1134

34185028 <XSPI_RAM_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_RAM_MspInit(const XSPI_HandleTypeDef *hxspi)
{
34185028:	b580      	push	{r7, lr}
3418502a:	b088      	sub	sp, #32
3418502c:	af00      	add	r7, sp, #0
3418502e:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
34185030:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34185034:	f7ff f90e 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
34185038:	f006 fa86 	bl	3418b548 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
3418503c:	2101      	movs	r1, #1
3418503e:	2001      	movs	r0, #1
34185040:	f006 fa30 	bl	3418b4a4 <HAL_PWREx_ConfigVddIORange>

  /* Enable the XSPI memory interface clock */
  XSPI_RAM_CLK_ENABLE();
34185044:	2020      	movs	r0, #32
34185046:	f7ff f91b 	bl	34184280 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_RAM_FORCE_RESET();
3418504a:	2020      	movs	r0, #32
3418504c:	f7ff f92e 	bl	341842ac <LL_AHB5_GRP1_ForceReset>
  XSPI_RAM_RELEASE_RESET();
34185050:	2020      	movs	r0, #32
34185052:	f7ff f93b 	bl	341842cc <LL_AHB5_GRP1_ReleaseReset>

  /* Enable and reset XSPI I/O Manager */
  __HAL_RCC_XSPIM_CLK_ENABLE();
34185056:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418505a:	f7ff f911 	bl	34184280 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_XSPIM_FORCE_RESET();
3418505e:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185062:	f7ff f923 	bl	341842ac <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_XSPIM_RELEASE_RESET();
34185066:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418506a:	f7ff f92f 	bl	341842cc <LL_AHB5_GRP1_ReleaseReset>

  /* Enable GPIO clocks */
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
3418506e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34185072:	f7ff f8ef 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
34185076:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3418507a:	f7ff f8eb 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
3418507e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34185082:	f7ff f8e7 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
34185086:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418508a:	f7ff f8e3 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
3418508e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34185092:	f7ff f8df 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
34185096:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418509a:	f7ff f8db 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
3418509e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341850a2:	f7ff f8d7 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
341850a6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341850aa:	f7ff f8d3 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
341850ae:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341850b2:	f7ff f8cf 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
341850b6:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341850ba:	f7ff f8cb 	bl	34184254 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
341850be:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
341850c2:	f7ff f8c7 	bl	34184254 <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
341850c6:	2301      	movs	r3, #1
341850c8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
341850ca:	2302      	movs	r3, #2
341850cc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341850ce:	2301      	movs	r3, #1
341850d0:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
341850d2:	2303      	movs	r3, #3
341850d4:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
341850d6:	2309      	movs	r3, #9
341850d8:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
341850da:	f107 030c 	add.w	r3, r7, #12
341850de:	4619      	mov	r1, r3
341850e0:	486a      	ldr	r0, [pc, #424]	@ (3418528c <XSPI_RAM_MspInit+0x264>)
341850e2:	f003 fad3 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
341850e6:	2304      	movs	r3, #4
341850e8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
341850ea:	2309      	movs	r3, #9
341850ec:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341850ee:	2301      	movs	r3, #1
341850f0:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
341850f2:	f107 030c 	add.w	r3, r7, #12
341850f6:	4619      	mov	r1, r3
341850f8:	4864      	ldr	r0, [pc, #400]	@ (3418528c <XSPI_RAM_MspInit+0x264>)
341850fa:	f003 fac7 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
341850fe:	2308      	movs	r3, #8
34185100:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
34185102:	2309      	movs	r3, #9
34185104:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34185106:	2301      	movs	r3, #1
34185108:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
3418510a:	f107 030c 	add.w	r3, r7, #12
3418510e:	4619      	mov	r1, r3
34185110:	485e      	ldr	r0, [pc, #376]	@ (3418528c <XSPI_RAM_MspInit+0x264>)
34185112:	f003 fabb 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
34185116:	2310      	movs	r3, #16
34185118:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
3418511a:	2301      	movs	r3, #1
3418511c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
3418511e:	2309      	movs	r3, #9
34185120:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
34185122:	f107 030c 	add.w	r3, r7, #12
34185126:	4619      	mov	r1, r3
34185128:	4858      	ldr	r0, [pc, #352]	@ (3418528c <XSPI_RAM_MspInit+0x264>)
3418512a:	f003 faaf 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
3418512e:	2301      	movs	r3, #1
34185130:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
34185132:	2309      	movs	r3, #9
34185134:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34185136:	2301      	movs	r3, #1
34185138:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
3418513a:	f107 030c 	add.w	r3, r7, #12
3418513e:	4619      	mov	r1, r3
34185140:	4853      	ldr	r0, [pc, #332]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185142:	f003 faa3 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
34185146:	2302      	movs	r3, #2
34185148:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
3418514a:	2309      	movs	r3, #9
3418514c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
3418514e:	f107 030c 	add.w	r3, r7, #12
34185152:	4619      	mov	r1, r3
34185154:	484e      	ldr	r0, [pc, #312]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185156:	f003 fa99 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
3418515a:	2304      	movs	r3, #4
3418515c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
3418515e:	2309      	movs	r3, #9
34185160:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
34185162:	f107 030c 	add.w	r3, r7, #12
34185166:	4619      	mov	r1, r3
34185168:	4849      	ldr	r0, [pc, #292]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
3418516a:	f003 fa8f 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
3418516e:	2308      	movs	r3, #8
34185170:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
34185172:	2309      	movs	r3, #9
34185174:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
34185176:	f107 030c 	add.w	r3, r7, #12
3418517a:	4619      	mov	r1, r3
3418517c:	4844      	ldr	r0, [pc, #272]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
3418517e:	f003 fa85 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
34185182:	2310      	movs	r3, #16
34185184:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
34185186:	2309      	movs	r3, #9
34185188:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
3418518a:	f107 030c 	add.w	r3, r7, #12
3418518e:	4619      	mov	r1, r3
34185190:	483f      	ldr	r0, [pc, #252]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185192:	f003 fa7b 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
34185196:	2320      	movs	r3, #32
34185198:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
3418519a:	2309      	movs	r3, #9
3418519c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
3418519e:	f107 030c 	add.w	r3, r7, #12
341851a2:	4619      	mov	r1, r3
341851a4:	483a      	ldr	r0, [pc, #232]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
341851a6:	f003 fa71 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
341851aa:	2340      	movs	r3, #64	@ 0x40
341851ac:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
341851ae:	2309      	movs	r3, #9
341851b0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
341851b2:	f107 030c 	add.w	r3, r7, #12
341851b6:	4619      	mov	r1, r3
341851b8:	4835      	ldr	r0, [pc, #212]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
341851ba:	f003 fa67 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
341851be:	2380      	movs	r3, #128	@ 0x80
341851c0:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
341851c2:	2309      	movs	r3, #9
341851c4:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
341851c6:	f107 030c 	add.w	r3, r7, #12
341851ca:	4619      	mov	r1, r3
341851cc:	4830      	ldr	r0, [pc, #192]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
341851ce:	f003 fa5d 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
341851d2:	f44f 7380 	mov.w	r3, #256	@ 0x100
341851d6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
341851d8:	2309      	movs	r3, #9
341851da:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
341851dc:	f107 030c 	add.w	r3, r7, #12
341851e0:	4619      	mov	r1, r3
341851e2:	482b      	ldr	r0, [pc, #172]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
341851e4:	f003 fa52 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
341851e8:	f44f 7300 	mov.w	r3, #512	@ 0x200
341851ec:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
341851ee:	2309      	movs	r3, #9
341851f0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
341851f2:	f107 030c 	add.w	r3, r7, #12
341851f6:	4619      	mov	r1, r3
341851f8:	4825      	ldr	r0, [pc, #148]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
341851fa:	f003 fa47 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
341851fe:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34185202:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
34185204:	2309      	movs	r3, #9
34185206:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
34185208:	f107 030c 	add.w	r3, r7, #12
3418520c:	4619      	mov	r1, r3
3418520e:	4820      	ldr	r0, [pc, #128]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185210:	f003 fa3c 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
34185214:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34185218:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
3418521a:	2309      	movs	r3, #9
3418521c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
3418521e:	f107 030c 	add.w	r3, r7, #12
34185222:	4619      	mov	r1, r3
34185224:	481a      	ldr	r0, [pc, #104]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185226:	f003 fa31 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
3418522a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3418522e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
34185230:	2309      	movs	r3, #9
34185232:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
34185234:	f107 030c 	add.w	r3, r7, #12
34185238:	4619      	mov	r1, r3
3418523a:	4815      	ldr	r0, [pc, #84]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
3418523c:	f003 fa26 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34185240:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34185244:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
34185246:	2309      	movs	r3, #9
34185248:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
3418524a:	f107 030c 	add.w	r3, r7, #12
3418524e:	4619      	mov	r1, r3
34185250:	480f      	ldr	r0, [pc, #60]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185252:	f003 fa1b 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34185256:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418525a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
3418525c:	2309      	movs	r3, #9
3418525e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34185260:	f107 030c 	add.w	r3, r7, #12
34185264:	4619      	mov	r1, r3
34185266:	480a      	ldr	r0, [pc, #40]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
34185268:	f003 fa10 	bl	3418868c <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
3418526c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34185270:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
34185272:	2309      	movs	r3, #9
34185274:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34185276:	f107 030c 	add.w	r3, r7, #12
3418527a:	4619      	mov	r1, r3
3418527c:	4804      	ldr	r0, [pc, #16]	@ (34185290 <XSPI_RAM_MspInit+0x268>)
3418527e:	f003 fa05 	bl	3418868c <HAL_GPIO_Init>
}
34185282:	bf00      	nop
34185284:	3720      	adds	r7, #32
34185286:	46bd      	mov	sp, r7
34185288:	bd80      	pop	{r7, pc}
3418528a:	bf00      	nop
3418528c:	56023800 	.word	0x56023800
34185290:	56023c00 	.word	0x56023c00

34185294 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34185294:	b580      	push	{r7, lr}
34185296:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34185298:	2003      	movs	r0, #3
3418529a:	f000 f9bf 	bl	3418561c <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
3418529e:	f7fe f98f 	bl	341835c0 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
341852a2:	200f      	movs	r0, #15
341852a4:	f000 f80a 	bl	341852bc <HAL_InitTick>
341852a8:	4603      	mov	r3, r0
341852aa:	2b00      	cmp	r3, #0
341852ac:	d001      	beq.n	341852b2 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
341852ae:	2301      	movs	r3, #1
341852b0:	e002      	b.n	341852b8 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
341852b2:	f7fd fd79 	bl	34182da8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
341852b6:	2300      	movs	r3, #0
}
341852b8:	4618      	mov	r0, r3
341852ba:	bd80      	pop	{r7, pc}

341852bc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
341852bc:	b580      	push	{r7, lr}
341852be:	b082      	sub	sp, #8
341852c0:	af00      	add	r7, sp, #0
341852c2:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
341852c4:	4b15      	ldr	r3, [pc, #84]	@ (3418531c <HAL_InitTick+0x60>)
341852c6:	781b      	ldrb	r3, [r3, #0]
341852c8:	2b00      	cmp	r3, #0
341852ca:	d101      	bne.n	341852d0 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
341852cc:	2301      	movs	r3, #1
341852ce:	e021      	b.n	34185314 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
341852d0:	4b13      	ldr	r3, [pc, #76]	@ (34185320 <HAL_InitTick+0x64>)
341852d2:	681a      	ldr	r2, [r3, #0]
341852d4:	4b11      	ldr	r3, [pc, #68]	@ (3418531c <HAL_InitTick+0x60>)
341852d6:	781b      	ldrb	r3, [r3, #0]
341852d8:	4619      	mov	r1, r3
341852da:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
341852de:	fbb3 f3f1 	udiv	r3, r3, r1
341852e2:	fbb2 f3f3 	udiv	r3, r2, r3
341852e6:	4618      	mov	r0, r3
341852e8:	f000 f9ce 	bl	34185688 <HAL_SYSTICK_Config>
341852ec:	4603      	mov	r3, r0
341852ee:	2b00      	cmp	r3, #0
341852f0:	d001      	beq.n	341852f6 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
341852f2:	2301      	movs	r3, #1
341852f4:	e00e      	b.n	34185314 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
341852f6:	687b      	ldr	r3, [r7, #4]
341852f8:	2b0f      	cmp	r3, #15
341852fa:	d80a      	bhi.n	34185312 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
341852fc:	2200      	movs	r2, #0
341852fe:	6879      	ldr	r1, [r7, #4]
34185300:	f04f 30ff 	mov.w	r0, #4294967295
34185304:	f000 f995 	bl	34185632 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34185308:	4a06      	ldr	r2, [pc, #24]	@ (34185324 <HAL_InitTick+0x68>)
3418530a:	687b      	ldr	r3, [r7, #4]
3418530c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
3418530e:	2300      	movs	r3, #0
34185310:	e000      	b.n	34185314 <HAL_InitTick+0x58>
    return HAL_ERROR;
34185312:	2301      	movs	r3, #1
}
34185314:	4618      	mov	r0, r3
34185316:	3708      	adds	r7, #8
34185318:	46bd      	mov	sp, r7
3418531a:	bd80      	pop	{r7, pc}
3418531c:	341c002c 	.word	0x341c002c
34185320:	341c0024 	.word	0x341c0024
34185324:	341c0028 	.word	0x341c0028

34185328 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34185328:	b480      	push	{r7}
3418532a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
3418532c:	4b06      	ldr	r3, [pc, #24]	@ (34185348 <HAL_IncTick+0x20>)
3418532e:	781b      	ldrb	r3, [r3, #0]
34185330:	461a      	mov	r2, r3
34185332:	4b06      	ldr	r3, [pc, #24]	@ (3418534c <HAL_IncTick+0x24>)
34185334:	681b      	ldr	r3, [r3, #0]
34185336:	4413      	add	r3, r2
34185338:	4a04      	ldr	r2, [pc, #16]	@ (3418534c <HAL_IncTick+0x24>)
3418533a:	6013      	str	r3, [r2, #0]
}
3418533c:	bf00      	nop
3418533e:	46bd      	mov	sp, r7
34185340:	f85d 7b04 	ldr.w	r7, [sp], #4
34185344:	4770      	bx	lr
34185346:	bf00      	nop
34185348:	341c002c 	.word	0x341c002c
3418534c:	341c11a0 	.word	0x341c11a0

34185350 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34185350:	b480      	push	{r7}
34185352:	af00      	add	r7, sp, #0
  return uwTick;
34185354:	4b03      	ldr	r3, [pc, #12]	@ (34185364 <HAL_GetTick+0x14>)
34185356:	681b      	ldr	r3, [r3, #0]
}
34185358:	4618      	mov	r0, r3
3418535a:	46bd      	mov	sp, r7
3418535c:	f85d 7b04 	ldr.w	r7, [sp], #4
34185360:	4770      	bx	lr
34185362:	bf00      	nop
34185364:	341c11a0 	.word	0x341c11a0

34185368 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
34185368:	b580      	push	{r7, lr}
3418536a:	b084      	sub	sp, #16
3418536c:	af00      	add	r7, sp, #0
3418536e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
34185370:	f7ff ffee 	bl	34185350 <HAL_GetTick>
34185374:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
34185376:	687b      	ldr	r3, [r7, #4]
34185378:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
3418537a:	68fb      	ldr	r3, [r7, #12]
3418537c:	f1b3 3fff 	cmp.w	r3, #4294967295
34185380:	d005      	beq.n	3418538e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
34185382:	4b0a      	ldr	r3, [pc, #40]	@ (341853ac <HAL_Delay+0x44>)
34185384:	781b      	ldrb	r3, [r3, #0]
34185386:	461a      	mov	r2, r3
34185388:	68fb      	ldr	r3, [r7, #12]
3418538a:	4413      	add	r3, r2
3418538c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
3418538e:	bf00      	nop
34185390:	f7ff ffde 	bl	34185350 <HAL_GetTick>
34185394:	4602      	mov	r2, r0
34185396:	68bb      	ldr	r3, [r7, #8]
34185398:	1ad3      	subs	r3, r2, r3
3418539a:	68fa      	ldr	r2, [r7, #12]
3418539c:	429a      	cmp	r2, r3
3418539e:	d8f7      	bhi.n	34185390 <HAL_Delay+0x28>
  {
  }
}
341853a0:	bf00      	nop
341853a2:	bf00      	nop
341853a4:	3710      	adds	r7, #16
341853a6:	46bd      	mov	sp, r7
341853a8:	bd80      	pop	{r7, pc}
341853aa:	bf00      	nop
341853ac:	341c002c 	.word	0x341c002c

341853b0 <HAL_CACHEAXI_Init>:
  * @note   In case HAL_CACHEAXI_Init() returns HAL_BUSY because an invalidation
  *         procedure is ongoing, the application should call again HAL_CACHEAXI_Init()
  *         until it returns HAL_OK to have the CACHEAXI enabled
  */
HAL_StatusTypeDef  HAL_CACHEAXI_Init(CACHEAXI_HandleTypeDef *hcacheaxi)
{
341853b0:	b580      	push	{r7, lr}
341853b2:	b084      	sub	sp, #16
341853b4:	af00      	add	r7, sp, #0
341853b6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the CACHEAXI handle allocation */
  if (hcacheaxi == NULL)
341853b8:	687b      	ldr	r3, [r7, #4]
341853ba:	2b00      	cmp	r3, #0
341853bc:	d101      	bne.n	341853c2 <HAL_CACHEAXI_Init+0x12>
  {
    return HAL_ERROR;
341853be:	2301      	movs	r3, #1
341853c0:	e013      	b.n	341853ea <HAL_CACHEAXI_Init+0x3a>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
341853c2:	687b      	ldr	r3, [r7, #4]
341853c4:	791b      	ldrb	r3, [r3, #4]
341853c6:	b2db      	uxtb	r3, r3
341853c8:	2b00      	cmp	r3, #0
341853ca:	d102      	bne.n	341853d2 <HAL_CACHEAXI_Init+0x22>

    /* Init the low level hardware */
    hcacheaxi->MspInitCallback(hcacheaxi);
#else
    /* Init the low level hardware */
    HAL_CACHEAXI_MspInit(hcacheaxi);
341853cc:	6878      	ldr	r0, [r7, #4]
341853ce:	f7fc fcbb 	bl	34181d48 <HAL_CACHEAXI_MspInit>
#endif /* USE_HAL_CACHEAXI_REGISTER_CALLBACKS */
  }

  /* Init the error code */
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
341853d2:	687b      	ldr	r3, [r7, #4]
341853d4:	2200      	movs	r2, #0
341853d6:	609a      	str	r2, [r3, #8]

  /* Init the CACHEAXI handle state */
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
341853d8:	687b      	ldr	r3, [r7, #4]
341853da:	2201      	movs	r2, #1
341853dc:	711a      	strb	r2, [r3, #4]

  /* Enable the selected CACHEAXI peripheral */
  status = HAL_CACHEAXI_Enable(hcacheaxi);
341853de:	6878      	ldr	r0, [r7, #4]
341853e0:	f000 f807 	bl	341853f2 <HAL_CACHEAXI_Enable>
341853e4:	4603      	mov	r3, r0
341853e6:	73fb      	strb	r3, [r7, #15]

  return status;
341853e8:	7bfb      	ldrb	r3, [r7, #15]
}
341853ea:	4618      	mov	r0, r3
341853ec:	3710      	adds	r7, #16
341853ee:	46bd      	mov	sp, r7
341853f0:	bd80      	pop	{r7, pc}

341853f2 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
341853f2:	b580      	push	{r7, lr}
341853f4:	b084      	sub	sp, #16
341853f6:	af00      	add	r7, sp, #0
341853f8:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
341853fa:	2300      	movs	r3, #0
341853fc:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
341853fe:	687b      	ldr	r3, [r7, #4]
34185400:	2b00      	cmp	r3, #0
34185402:	d101      	bne.n	34185408 <HAL_CACHEAXI_Enable+0x16>
  {
    return HAL_ERROR;
34185404:	2301      	movs	r3, #1
34185406:	e034      	b.n	34185472 <HAL_CACHEAXI_Enable+0x80>

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34185408:	687b      	ldr	r3, [r7, #4]
3418540a:	681b      	ldr	r3, [r3, #0]
3418540c:	685b      	ldr	r3, [r3, #4]
3418540e:	f003 0301 	and.w	r3, r3, #1
34185412:	2b00      	cmp	r3, #0
34185414:	d01e      	beq.n	34185454 <HAL_CACHEAXI_Enable+0x62>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34185416:	f7ff ff9b 	bl	34185350 <HAL_GetTick>
3418541a:	60b8      	str	r0, [r7, #8]

    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
3418541c:	e013      	b.n	34185446 <HAL_CACHEAXI_Enable+0x54>
    {
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
3418541e:	f7ff ff97 	bl	34185350 <HAL_GetTick>
34185422:	4602      	mov	r2, r0
34185424:	68bb      	ldr	r3, [r7, #8]
34185426:	1ad3      	subs	r3, r2, r3
34185428:	2b01      	cmp	r3, #1
3418542a:	d90c      	bls.n	34185446 <HAL_CACHEAXI_Enable+0x54>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
3418542c:	687b      	ldr	r3, [r7, #4]
3418542e:	681b      	ldr	r3, [r3, #0]
34185430:	685b      	ldr	r3, [r3, #4]
34185432:	f003 0301 	and.w	r3, r3, #1
34185436:	2b00      	cmp	r3, #0
34185438:	d105      	bne.n	34185446 <HAL_CACHEAXI_Enable+0x54>
        {
          /* Update error code */
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
3418543a:	687b      	ldr	r3, [r7, #4]
3418543c:	2210      	movs	r2, #16
3418543e:	609a      	str	r2, [r3, #8]
          /* Return error status */
          status =  HAL_ERROR;
34185440:	2301      	movs	r3, #1
34185442:	73fb      	strb	r3, [r7, #15]
          break;
34185444:	e006      	b.n	34185454 <HAL_CACHEAXI_Enable+0x62>
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34185446:	687b      	ldr	r3, [r7, #4]
34185448:	681b      	ldr	r3, [r3, #0]
3418544a:	685b      	ldr	r3, [r3, #4]
3418544c:	f003 0301 	and.w	r3, r3, #1
34185450:	2b00      	cmp	r3, #0
34185452:	d1e4      	bne.n	3418541e <HAL_CACHEAXI_Enable+0x2c>
        }
      }
    }
  }

  if (status == HAL_OK)
34185454:	7bfb      	ldrb	r3, [r7, #15]
34185456:	2b00      	cmp	r3, #0
34185458:	d10a      	bne.n	34185470 <HAL_CACHEAXI_Enable+0x7e>
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
3418545a:	687b      	ldr	r3, [r7, #4]
3418545c:	2200      	movs	r2, #0
3418545e:	609a      	str	r2, [r3, #8]
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34185460:	687b      	ldr	r3, [r7, #4]
34185462:	681b      	ldr	r3, [r3, #0]
34185464:	681a      	ldr	r2, [r3, #0]
34185466:	687b      	ldr	r3, [r7, #4]
34185468:	681b      	ldr	r3, [r3, #0]
3418546a:	f042 0201 	orr.w	r2, r2, #1
3418546e:	601a      	str	r2, [r3, #0]
  }

  return status;
34185470:	7bfb      	ldrb	r3, [r7, #15]
}
34185472:	4618      	mov	r0, r3
34185474:	3710      	adds	r7, #16
34185476:	46bd      	mov	sp, r7
34185478:	bd80      	pop	{r7, pc}
	...

3418547c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3418547c:	b480      	push	{r7}
3418547e:	b085      	sub	sp, #20
34185480:	af00      	add	r7, sp, #0
34185482:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34185484:	687b      	ldr	r3, [r7, #4]
34185486:	f003 0307 	and.w	r3, r3, #7
3418548a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
3418548c:	4b0c      	ldr	r3, [pc, #48]	@ (341854c0 <__NVIC_SetPriorityGrouping+0x44>)
3418548e:	68db      	ldr	r3, [r3, #12]
34185490:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34185492:	68ba      	ldr	r2, [r7, #8]
34185494:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34185498:	4013      	ands	r3, r2
3418549a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3418549c:	68fb      	ldr	r3, [r7, #12]
3418549e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
341854a0:	68bb      	ldr	r3, [r7, #8]
341854a2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
341854a4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
341854a8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
341854ac:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
341854ae:	4a04      	ldr	r2, [pc, #16]	@ (341854c0 <__NVIC_SetPriorityGrouping+0x44>)
341854b0:	68bb      	ldr	r3, [r7, #8]
341854b2:	60d3      	str	r3, [r2, #12]
}
341854b4:	bf00      	nop
341854b6:	3714      	adds	r7, #20
341854b8:	46bd      	mov	sp, r7
341854ba:	f85d 7b04 	ldr.w	r7, [sp], #4
341854be:	4770      	bx	lr
341854c0:	e000ed00 	.word	0xe000ed00

341854c4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
341854c4:	b480      	push	{r7}
341854c6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
341854c8:	4b04      	ldr	r3, [pc, #16]	@ (341854dc <__NVIC_GetPriorityGrouping+0x18>)
341854ca:	68db      	ldr	r3, [r3, #12]
341854cc:	0a1b      	lsrs	r3, r3, #8
341854ce:	f003 0307 	and.w	r3, r3, #7
}
341854d2:	4618      	mov	r0, r3
341854d4:	46bd      	mov	sp, r7
341854d6:	f85d 7b04 	ldr.w	r7, [sp], #4
341854da:	4770      	bx	lr
341854dc:	e000ed00 	.word	0xe000ed00

341854e0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
341854e0:	b480      	push	{r7}
341854e2:	b083      	sub	sp, #12
341854e4:	af00      	add	r7, sp, #0
341854e6:	4603      	mov	r3, r0
341854e8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341854ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341854ee:	2b00      	cmp	r3, #0
341854f0:	db0b      	blt.n	3418550a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
341854f2:	88fb      	ldrh	r3, [r7, #6]
341854f4:	f003 021f 	and.w	r2, r3, #31
341854f8:	4907      	ldr	r1, [pc, #28]	@ (34185518 <__NVIC_EnableIRQ+0x38>)
341854fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341854fe:	095b      	lsrs	r3, r3, #5
34185500:	2001      	movs	r0, #1
34185502:	fa00 f202 	lsl.w	r2, r0, r2
34185506:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
3418550a:	bf00      	nop
3418550c:	370c      	adds	r7, #12
3418550e:	46bd      	mov	sp, r7
34185510:	f85d 7b04 	ldr.w	r7, [sp], #4
34185514:	4770      	bx	lr
34185516:	bf00      	nop
34185518:	e000e100 	.word	0xe000e100

3418551c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
3418551c:	b480      	push	{r7}
3418551e:	b083      	sub	sp, #12
34185520:	af00      	add	r7, sp, #0
34185522:	4603      	mov	r3, r0
34185524:	6039      	str	r1, [r7, #0]
34185526:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34185528:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418552c:	2b00      	cmp	r3, #0
3418552e:	db0a      	blt.n	34185546 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34185530:	683b      	ldr	r3, [r7, #0]
34185532:	b2da      	uxtb	r2, r3
34185534:	490c      	ldr	r1, [pc, #48]	@ (34185568 <__NVIC_SetPriority+0x4c>)
34185536:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418553a:	0112      	lsls	r2, r2, #4
3418553c:	b2d2      	uxtb	r2, r2
3418553e:	440b      	add	r3, r1
34185540:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34185544:	e00a      	b.n	3418555c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34185546:	683b      	ldr	r3, [r7, #0]
34185548:	b2da      	uxtb	r2, r3
3418554a:	4908      	ldr	r1, [pc, #32]	@ (3418556c <__NVIC_SetPriority+0x50>)
3418554c:	88fb      	ldrh	r3, [r7, #6]
3418554e:	f003 030f 	and.w	r3, r3, #15
34185552:	3b04      	subs	r3, #4
34185554:	0112      	lsls	r2, r2, #4
34185556:	b2d2      	uxtb	r2, r2
34185558:	440b      	add	r3, r1
3418555a:	761a      	strb	r2, [r3, #24]
}
3418555c:	bf00      	nop
3418555e:	370c      	adds	r7, #12
34185560:	46bd      	mov	sp, r7
34185562:	f85d 7b04 	ldr.w	r7, [sp], #4
34185566:	4770      	bx	lr
34185568:	e000e100 	.word	0xe000e100
3418556c:	e000ed00 	.word	0xe000ed00

34185570 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34185570:	b480      	push	{r7}
34185572:	b089      	sub	sp, #36	@ 0x24
34185574:	af00      	add	r7, sp, #0
34185576:	60f8      	str	r0, [r7, #12]
34185578:	60b9      	str	r1, [r7, #8]
3418557a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
3418557c:	68fb      	ldr	r3, [r7, #12]
3418557e:	f003 0307 	and.w	r3, r3, #7
34185582:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34185584:	69fb      	ldr	r3, [r7, #28]
34185586:	f1c3 0307 	rsb	r3, r3, #7
3418558a:	2b04      	cmp	r3, #4
3418558c:	bf28      	it	cs
3418558e:	2304      	movcs	r3, #4
34185590:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34185592:	69fb      	ldr	r3, [r7, #28]
34185594:	3304      	adds	r3, #4
34185596:	2b06      	cmp	r3, #6
34185598:	d902      	bls.n	341855a0 <NVIC_EncodePriority+0x30>
3418559a:	69fb      	ldr	r3, [r7, #28]
3418559c:	3b03      	subs	r3, #3
3418559e:	e000      	b.n	341855a2 <NVIC_EncodePriority+0x32>
341855a0:	2300      	movs	r3, #0
341855a2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
341855a4:	f04f 32ff 	mov.w	r2, #4294967295
341855a8:	69bb      	ldr	r3, [r7, #24]
341855aa:	fa02 f303 	lsl.w	r3, r2, r3
341855ae:	43da      	mvns	r2, r3
341855b0:	68bb      	ldr	r3, [r7, #8]
341855b2:	401a      	ands	r2, r3
341855b4:	697b      	ldr	r3, [r7, #20]
341855b6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
341855b8:	f04f 31ff 	mov.w	r1, #4294967295
341855bc:	697b      	ldr	r3, [r7, #20]
341855be:	fa01 f303 	lsl.w	r3, r1, r3
341855c2:	43d9      	mvns	r1, r3
341855c4:	687b      	ldr	r3, [r7, #4]
341855c6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
341855c8:	4313      	orrs	r3, r2
         );
}
341855ca:	4618      	mov	r0, r3
341855cc:	3724      	adds	r7, #36	@ 0x24
341855ce:	46bd      	mov	sp, r7
341855d0:	f85d 7b04 	ldr.w	r7, [sp], #4
341855d4:	4770      	bx	lr
	...

341855d8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
341855d8:	b580      	push	{r7, lr}
341855da:	b082      	sub	sp, #8
341855dc:	af00      	add	r7, sp, #0
341855de:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
341855e0:	687b      	ldr	r3, [r7, #4]
341855e2:	3b01      	subs	r3, #1
341855e4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341855e8:	d301      	bcc.n	341855ee <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
341855ea:	2301      	movs	r3, #1
341855ec:	e00f      	b.n	3418560e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
341855ee:	4a0a      	ldr	r2, [pc, #40]	@ (34185618 <SysTick_Config+0x40>)
341855f0:	687b      	ldr	r3, [r7, #4]
341855f2:	3b01      	subs	r3, #1
341855f4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
341855f6:	210f      	movs	r1, #15
341855f8:	f04f 30ff 	mov.w	r0, #4294967295
341855fc:	f7ff ff8e 	bl	3418551c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34185600:	4b05      	ldr	r3, [pc, #20]	@ (34185618 <SysTick_Config+0x40>)
34185602:	2200      	movs	r2, #0
34185604:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34185606:	4b04      	ldr	r3, [pc, #16]	@ (34185618 <SysTick_Config+0x40>)
34185608:	2207      	movs	r2, #7
3418560a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
3418560c:	2300      	movs	r3, #0
}
3418560e:	4618      	mov	r0, r3
34185610:	3708      	adds	r7, #8
34185612:	46bd      	mov	sp, r7
34185614:	bd80      	pop	{r7, pc}
34185616:	bf00      	nop
34185618:	e000e010 	.word	0xe000e010

3418561c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3418561c:	b580      	push	{r7, lr}
3418561e:	b082      	sub	sp, #8
34185620:	af00      	add	r7, sp, #0
34185622:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34185624:	6878      	ldr	r0, [r7, #4]
34185626:	f7ff ff29 	bl	3418547c <__NVIC_SetPriorityGrouping>
}
3418562a:	bf00      	nop
3418562c:	3708      	adds	r7, #8
3418562e:	46bd      	mov	sp, r7
34185630:	bd80      	pop	{r7, pc}

34185632 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34185632:	b580      	push	{r7, lr}
34185634:	b086      	sub	sp, #24
34185636:	af00      	add	r7, sp, #0
34185638:	4603      	mov	r3, r0
3418563a:	60b9      	str	r1, [r7, #8]
3418563c:	607a      	str	r2, [r7, #4]
3418563e:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34185640:	f7ff ff40 	bl	341854c4 <__NVIC_GetPriorityGrouping>
34185644:	4603      	mov	r3, r0
34185646:	f003 0307 	and.w	r3, r3, #7
3418564a:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
3418564c:	687a      	ldr	r2, [r7, #4]
3418564e:	68b9      	ldr	r1, [r7, #8]
34185650:	6978      	ldr	r0, [r7, #20]
34185652:	f7ff ff8d 	bl	34185570 <NVIC_EncodePriority>
34185656:	4602      	mov	r2, r0
34185658:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3418565c:	4611      	mov	r1, r2
3418565e:	4618      	mov	r0, r3
34185660:	f7ff ff5c 	bl	3418551c <__NVIC_SetPriority>
}
34185664:	bf00      	nop
34185666:	3718      	adds	r7, #24
34185668:	46bd      	mov	sp, r7
3418566a:	bd80      	pop	{r7, pc}

3418566c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
3418566c:	b580      	push	{r7, lr}
3418566e:	b082      	sub	sp, #8
34185670:	af00      	add	r7, sp, #0
34185672:	4603      	mov	r3, r0
34185674:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34185676:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418567a:	4618      	mov	r0, r3
3418567c:	f7ff ff30 	bl	341854e0 <__NVIC_EnableIRQ>
}
34185680:	bf00      	nop
34185682:	3708      	adds	r7, #8
34185684:	46bd      	mov	sp, r7
34185686:	bd80      	pop	{r7, pc}

34185688 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34185688:	b580      	push	{r7, lr}
3418568a:	b082      	sub	sp, #8
3418568c:	af00      	add	r7, sp, #0
3418568e:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34185690:	6878      	ldr	r0, [r7, #4]
34185692:	f7ff ffa1 	bl	341855d8 <SysTick_Config>
34185696:	4603      	mov	r3, r0
}
34185698:	4618      	mov	r0, r3
3418569a:	3708      	adds	r7, #8
3418569c:	46bd      	mov	sp, r7
3418569e:	bd80      	pop	{r7, pc}

341856a0 <HAL_DCMIPP_Init>:
  * @brief  Initialize the selected HAL DCMIPP handle and associate a DCMIPP peripheral instance.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_Init(DCMIPP_HandleTypeDef *hdcmipp)
{
341856a0:	b580      	push	{r7, lr}
341856a2:	b084      	sub	sp, #16
341856a4:	af00      	add	r7, sp, #0
341856a6:	6078      	str	r0, [r7, #4]
  uint32_t pipe_index;

  /* Check pointer validity */
  if (hdcmipp == NULL)
341856a8:	687b      	ldr	r3, [r7, #4]
341856aa:	2b00      	cmp	r3, #0
341856ac:	d101      	bne.n	341856b2 <HAL_DCMIPP_Init+0x12>
  {
    return HAL_ERROR;
341856ae:	2301      	movs	r3, #1
341856b0:	e020      	b.n	341856f4 <HAL_DCMIPP_Init+0x54>
  }

  /* Check function parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));

  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
341856b2:	687b      	ldr	r3, [r7, #4]
341856b4:	791b      	ldrb	r3, [r3, #4]
341856b6:	b2db      	uxtb	r3, r3
341856b8:	2b00      	cmp	r3, #0
341856ba:	d102      	bne.n	341856c2 <HAL_DCMIPP_Init+0x22>
    }
    /* Initialize the low level hardware (MSP) */
    hdcmipp->MspInitCallback(hdcmipp);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMIPP_MspInit(hdcmipp);
341856bc:	6878      	ldr	r0, [r7, #4]
341856be:	f7fc fc3b 	bl	34181f38 <HAL_DCMIPP_MspInit>
#endif /* (USE_HAL_DCMIPP_REGISTER_CALLBACKS) */
  }

  /* Change the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
341856c2:	687b      	ldr	r3, [r7, #4]
341856c4:	2203      	movs	r2, #3
341856c6:	711a      	strb	r2, [r3, #4]

  /* Reset DCMIPP Pipe state */
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
341856c8:	2300      	movs	r3, #0
341856ca:	60fb      	str	r3, [r7, #12]
341856cc:	e008      	b.n	341856e0 <HAL_DCMIPP_Init+0x40>
  {
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
341856ce:	687a      	ldr	r2, [r7, #4]
341856d0:	68fb      	ldr	r3, [r7, #12]
341856d2:	4413      	add	r3, r2
341856d4:	3305      	adds	r3, #5
341856d6:	2200      	movs	r2, #0
341856d8:	701a      	strb	r2, [r3, #0]
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
341856da:	68fb      	ldr	r3, [r7, #12]
341856dc:	3301      	adds	r3, #1
341856de:	60fb      	str	r3, [r7, #12]
341856e0:	68fb      	ldr	r3, [r7, #12]
341856e2:	2b02      	cmp	r3, #2
341856e4:	d9f3      	bls.n	341856ce <HAL_DCMIPP_Init+0x2e>
  }

  /* Update error code */
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
341856e6:	687b      	ldr	r3, [r7, #4]
341856e8:	2200      	movs	r2, #0
341856ea:	609a      	str	r2, [r3, #8]

  /* Update the DCMIPP state*/
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
341856ec:	687b      	ldr	r3, [r7, #4]
341856ee:	2201      	movs	r2, #1
341856f0:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
341856f2:	2300      	movs	r3, #0
}
341856f4:	4618      	mov	r0, r3
341856f6:	3710      	adds	r7, #16
341856f8:	46bd      	mov	sp, r7
341856fa:	bd80      	pop	{r7, pc}

341856fc <HAL_DCMIPP_CSI_SetConfig>:
  *                     configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetConfig(const DCMIPP_HandleTypeDef *hdcmipp,
                                           const DCMIPP_CSI_ConfTypeDef *pCSI_Config)
{
341856fc:	b580      	push	{r7, lr}
341856fe:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
34185702:	af00      	add	r7, sp, #0
34185704:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185708:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
3418570c:	6018      	str	r0, [r3, #0]
3418570e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185712:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34185716:	6019      	str	r1, [r3, #0]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34185718:	4ba8      	ldr	r3, [pc, #672]	@ (341859bc <HAL_DCMIPP_CSI_SetConfig+0x2c0>)
3418571a:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204

  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
3418571e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185722:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34185726:	4aa6      	ldr	r2, [pc, #664]	@ (341859c0 <HAL_DCMIPP_CSI_SetConfig+0x2c4>)
34185728:	4618      	mov	r0, r3
3418572a:	4611      	mov	r1, r2
3418572c:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
34185730:	461a      	mov	r2, r3
34185732:	f01e fbb2 	bl	341a3e9a <memcpy>
    { 0x48U, 451U },  /* HAL_CSI_BT_2450 */
    { 0x49U, 460U },  /* HAL_CSI_BT_2500 */
  };

  /* Check parameters */
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34185736:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418573a:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
3418573e:	681b      	ldr	r3, [r3, #0]
34185740:	2b00      	cmp	r3, #0
34185742:	d006      	beq.n	34185752 <HAL_DCMIPP_CSI_SetConfig+0x56>
34185744:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185748:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418574c:	681b      	ldr	r3, [r3, #0]
3418574e:	2b00      	cmp	r3, #0
34185750:	d101      	bne.n	34185756 <HAL_DCMIPP_CSI_SetConfig+0x5a>
  {
    return HAL_ERROR;
34185752:	2301      	movs	r3, #1
34185754:	e12c      	b.n	341859b0 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));

  /* Ensure the CSI is disabled */
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34185756:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418575a:	681b      	ldr	r3, [r3, #0]
3418575c:	f023 0201 	bic.w	r2, r3, #1
34185760:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185764:	601a      	str	r2, [r3, #0]

  /* Configure the Lane Merger */
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34185766:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418576a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418576e:	681b      	ldr	r3, [r3, #0]
34185770:	685b      	ldr	r3, [r3, #4]
34185772:	2b01      	cmp	r3, #1
34185774:	d10b      	bne.n	3418578e <HAL_DCMIPP_CSI_SetConfig+0x92>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34185776:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418577a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418577e:	681b      	ldr	r3, [r3, #0]
34185780:	681b      	ldr	r3, [r3, #0]
34185782:	f443 1204 	orr.w	r2, r3, #2162688	@ 0x210000
34185786:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418578a:	671a      	str	r2, [r3, #112]	@ 0x70
3418578c:	e015      	b.n	341857ba <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
3418578e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185792:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34185796:	681b      	ldr	r3, [r3, #0]
34185798:	685b      	ldr	r3, [r3, #4]
3418579a:	2b02      	cmp	r3, #2
3418579c:	d10b      	bne.n	341857b6 <HAL_DCMIPP_CSI_SetConfig+0xba>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
3418579e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341857a2:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341857a6:	681b      	ldr	r3, [r3, #0]
341857a8:	681b      	ldr	r3, [r3, #0]
341857aa:	f443 1290 	orr.w	r2, r3, #1179648	@ 0x120000
341857ae:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341857b2:	671a      	str	r2, [r3, #112]	@ 0x70
341857b4:	e001      	b.n	341857ba <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else
  {
    return HAL_ERROR;
341857b6:	2301      	movs	r3, #1
341857b8:	e0fa      	b.n	341859b0 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  }

  /* Enable the CSI */
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
341857ba:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341857be:	681b      	ldr	r3, [r3, #0]
341857c0:	f043 0201 	orr.w	r2, r3, #1
341857c4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341857c8:	601a      	str	r2, [r3, #0]

  /* Enable some interrupts, not related to virtual channels - all error cases */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
341857ca:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341857ce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341857d2:	f043 43b0 	orr.w	r3, r3, #1476395008	@ 0x58000000
341857d6:	f443 1304 	orr.w	r3, r3, #2162688	@ 0x210000
341857da:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
341857de:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
                             DCMIPP_CSI_IT_SPKTERR | DCMIPP_CSI_IT_IDERR | \
                             DCMIPP_CSI_IT_SPKT);

  /* Enable D-PHY Interrupts */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
341857e2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341857e6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341857ea:	681b      	ldr	r3, [r3, #0]
341857ec:	681b      	ldr	r3, [r3, #0]
341857ee:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341857f2:	d11d      	bne.n	34185830 <HAL_DCMIPP_CSI_SetConfig+0x134>
  {
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
341857f4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341857f8:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341857fc:	681b      	ldr	r3, [r3, #0]
341857fe:	685b      	ldr	r3, [r3, #4]
34185800:	2b01      	cmp	r3, #1
34185802:	d10a      	bne.n	3418581a <HAL_DCMIPP_CSI_SetConfig+0x11e>
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34185804:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185808:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418580c:	f043 021f 	orr.w	r2, r3, #31
34185810:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185814:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
34185818:	e016      	b.n	34185848 <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_EESCDL0 | DCMIPP_CSI_IT_ESYNCESCDL0 |
                                      DCMIPP_CSI_IT_ECTRLDL0);
    }
    else
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
3418581a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418581e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34185822:	f443 52f8 	orr.w	r2, r3, #7936	@ 0x1f00
34185826:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418582a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
3418582e:	e00b      	b.n	34185848 <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_ECTRLDL1);
    }
  }
  else
  {
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34185830:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185834:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34185838:	f443 53f8 	orr.w	r3, r3, #7936	@ 0x1f00
3418583c:	f043 031f 	orr.w	r3, r3, #31
34185840:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34185844:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                    DCMIPP_CSI_IT_ECTRLDL0);
  }

  /* Start D-PHY Configuration */
  /* Stop the D-PHY */
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34185848:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418584c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185850:	681b      	ldr	r3, [r3, #0]
34185852:	f023 0302 	bic.w	r3, r3, #2
34185856:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3418585a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418585e:	6013      	str	r3, [r2, #0]

  /* Get the D-PHY enabledb but with all lanes disabled */
  CLEAR_REG(csi_instance-> PCR);
34185860:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185864:	2200      	movs	r2, #0
34185866:	605a      	str	r2, [r3, #4]

  /* Set the testclk (clock enable) on during 15ns */
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34185868:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418586c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185870:	691b      	ldr	r3, [r3, #16]
34185872:	f043 0301 	orr.w	r3, r3, #1
34185876:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3418587a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418587e:	6113      	str	r3, [r2, #16]

  HAL_Delay(1);
34185880:	2001      	movs	r0, #1
34185882:	f7ff fd71 	bl	34185368 <HAL_Delay>

  CLEAR_REG(csi_instance->PTCR0);
34185886:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418588a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418588e:	461a      	mov	r2, r3
34185890:	2300      	movs	r3, #0
34185892:	6113      	str	r3, [r2, #16]

  /* Set hsfreqrange */
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34185894:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185898:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418589c:	689b      	ldr	r3, [r3, #8]
3418589e:	f423 42fe 	bic.w	r2, r3, #32512	@ 0x7f00
341858a2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341858a6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341858aa:	681b      	ldr	r3, [r3, #0]
341858ac:	6899      	ldr	r1, [r3, #8]
341858ae:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341858b2:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
341858b6:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
341858ba:	021b      	lsls	r3, r3, #8
341858bc:	4313      	orrs	r3, r2
341858be:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
341858c2:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
341858c6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341858ca:	6093      	str	r3, [r2, #8]
             (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos));

  /* set reg @08 deskew_polarity_rw 1'b1 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
341858cc:	2338      	movs	r3, #56	@ 0x38
341858ce:	2208      	movs	r2, #8
341858d0:	2100      	movs	r1, #0
341858d2:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
341858d6:	f002 fdc2 	bl	3418845e <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
  /* This is because 13<= cfgclkfreqrange[5:0]<=38 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
341858da:	2311      	movs	r3, #17
341858dc:	22e4      	movs	r2, #228	@ 0xe4
341858de:	2100      	movs	r1, #0
341858e0:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
341858e4:	f002 fdbb 	bl	3418845e <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xe3 & reg @0xe2 value DLL target oscilation freq */
  /* Based on the table page 77, osc_freq_target */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
341858e8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341858ec:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341858f0:	681b      	ldr	r3, [r3, #0]
341858f2:	689b      	ldr	r3, [r3, #8]
341858f4:	f507 7202 	add.w	r2, r7, #520	@ 0x208
341858f8:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
341858fc:	00db      	lsls	r3, r3, #3
341858fe:	4413      	add	r3, r2
34185900:	685b      	ldr	r3, [r3, #4]
34185902:	0a1b      	lsrs	r3, r3, #8
34185904:	22e3      	movs	r2, #227	@ 0xe3
34185906:	2100      	movs	r1, #0
34185908:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
3418590c:	f002 fda7 	bl	3418845e <DCMIPP_CSI_WritePHYReg>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34185910:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185914:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34185918:	681b      	ldr	r3, [r3, #0]
3418591a:	689b      	ldr	r3, [r3, #8]
3418591c:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34185920:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34185924:	00db      	lsls	r3, r3, #3
34185926:	4413      	add	r3, r2
34185928:	685b      	ldr	r3, [r3, #4]
3418592a:	b2db      	uxtb	r3, r3
3418592c:	22e3      	movs	r2, #227	@ 0xe3
3418592e:	2100      	movs	r1, #0
34185930:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34185934:	f002 fd93 	bl	3418845e <DCMIPP_CSI_WritePHYReg>

  /* set basedir_0 to RX DLD 0 RX, 1 TX. Synopsys 1 RX 0 TX  + freq range */
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34185938:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418593c:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34185940:	681b      	ldr	r3, [r3, #0]
34185942:	689a      	ldr	r2, [r3, #8]
34185944:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185948:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
3418594c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
34185950:	021b      	lsls	r3, r3, #8
34185952:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34185956:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
3418595a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3418595e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34185962:	6093      	str	r3, [r2, #8]
            (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos) | CSI_PFCR_DLD);

  /* Enable the D-PHY_RX lane(s) etc */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34185964:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34185968:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418596c:	681b      	ldr	r3, [r3, #0]
3418596e:	681b      	ldr	r3, [r3, #0]
34185970:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34185974:	d104      	bne.n	34185980 <HAL_DCMIPP_CSI_SetConfig+0x284>
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34185976:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418597a:	2207      	movs	r2, #7
3418597c:	605a      	str	r2, [r3, #4]
3418597e:	e003      	b.n	34185988 <HAL_DCMIPP_CSI_SetConfig+0x28c>
  }
  else
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34185980:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34185984:	220f      	movs	r2, #15
34185986:	605a      	str	r2, [r3, #4]
  }


  /* Enable PHY, out of reset */
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34185988:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418598c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34185990:	681b      	ldr	r3, [r3, #0]
34185992:	f043 0302 	orr.w	r3, r3, #2
34185996:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3418599a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418599e:	6013      	str	r3, [r2, #0]

  /* Remove the force */
  CLEAR_REG(csi_instance->PMCR);
341859a0:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341859a4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341859a8:	461a      	mov	r2, r3
341859aa:	2300      	movs	r3, #0
341859ac:	6053      	str	r3, [r2, #4]

  return HAL_OK;
341859ae:	2300      	movs	r3, #0

}
341859b0:	4618      	mov	r0, r3
341859b2:	f507 7702 	add.w	r7, r7, #520	@ 0x208
341859b6:	46bd      	mov	sp, r7
341859b8:	bd80      	pop	{r7, pc}
341859ba:	bf00      	nop
341859bc:	58006000 	.word	0x58006000
341859c0:	341a5ad0 	.word	0x341a5ad0

341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
  *                         the CSI Pipe configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CSI_PIPE_ConfTypeDef *pCSI_PipeConfig)
{
341859c4:	b480      	push	{r7}
341859c6:	b087      	sub	sp, #28
341859c8:	af00      	add	r7, sp, #0
341859ca:	60f8      	str	r0, [r7, #12]
341859cc:	60b9      	str	r1, [r7, #8]
341859ce:	607a      	str	r2, [r7, #4]
  uint32_t pxfscr_reg = 0;
341859d0:	2300      	movs	r3, #0
341859d2:	617b      	str	r3, [r7, #20]
  HAL_DCMIPP_StateTypeDef state;

  /* Check the DCMIPP peripheral handle parameter and pCSI_Config parameter */
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
341859d4:	68fb      	ldr	r3, [r7, #12]
341859d6:	2b00      	cmp	r3, #0
341859d8:	d002      	beq.n	341859e0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
341859da:	687b      	ldr	r3, [r7, #4]
341859dc:	2b00      	cmp	r3, #0
341859de:	d101      	bne.n	341859e4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x20>
  {
    return HAL_ERROR;
341859e0:	2301      	movs	r3, #1
341859e2:	e087      	b.n	34185af4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
  /* Check the parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

  if (Pipe != DCMIPP_PIPE2)
341859e4:	68bb      	ldr	r3, [r7, #8]
341859e6:	2b02      	cmp	r3, #2
341859e8:	d003      	beq.n	341859f2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2e>
  {
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
341859ea:	687b      	ldr	r3, [r7, #4]
341859ec:	681b      	ldr	r3, [r3, #0]
341859ee:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
  {
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
  }

  state = hdcmipp->State;
341859f2:	68fb      	ldr	r3, [r7, #12]
341859f4:	791b      	ldrb	r3, [r3, #4]
341859f6:	74fb      	strb	r3, [r7, #19]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
341859f8:	7cfb      	ldrb	r3, [r7, #19]
341859fa:	2b01      	cmp	r3, #1
341859fc:	d002      	beq.n	34185a04 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x40>
341859fe:	7cfb      	ldrb	r3, [r7, #19]
34185a00:	2b02      	cmp	r3, #2
34185a02:	d173      	bne.n	34185aec <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
  {
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34185a04:	687b      	ldr	r3, [r7, #4]
34185a06:	681b      	ldr	r3, [r3, #0]
34185a08:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34185a0c:	d004      	beq.n	34185a18 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x54>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34185a0e:	687b      	ldr	r3, [r7, #4]
34185a10:	681b      	ldr	r3, [r3, #0]
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34185a12:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34185a16:	d104      	bne.n	34185a22 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34185a18:	68bb      	ldr	r3, [r7, #8]
34185a1a:	2b00      	cmp	r3, #0
34185a1c:	d001      	beq.n	34185a22 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
    {
      return HAL_ERROR;
34185a1e:	2301      	movs	r3, #1
34185a20:	e068      	b.n	34185af4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
    }

    /* Add Data Type Mode for the selected Pipe except Pipe2 */
    if (Pipe != DCMIPP_PIPE2)
34185a22:	68bb      	ldr	r3, [r7, #8]
34185a24:	2b02      	cmp	r3, #2
34185a26:	d004      	beq.n	34185a32 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x6e>
    {
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeMode);
34185a28:	687b      	ldr	r3, [r7, #4]
34185a2a:	681b      	ldr	r3, [r3, #0]
34185a2c:	697a      	ldr	r2, [r7, #20]
34185a2e:	4313      	orrs	r3, r2
34185a30:	617b      	str	r3, [r7, #20]
    }

    if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34185a32:	687b      	ldr	r3, [r7, #4]
34185a34:	681b      	ldr	r3, [r3, #0]
34185a36:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34185a3a:	d004      	beq.n	34185a46 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
    {
      /* Add Data Type IDA for the selected Pipe */
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34185a3c:	687b      	ldr	r3, [r7, #4]
34185a3e:	685b      	ldr	r3, [r3, #4]
34185a40:	697a      	ldr	r2, [r7, #20]
34185a42:	4313      	orrs	r3, r2
34185a44:	617b      	str	r3, [r7, #20]
    }

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34185a46:	687b      	ldr	r3, [r7, #4]
34185a48:	681b      	ldr	r3, [r3, #0]
34185a4a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34185a4e:	d004      	beq.n	34185a5a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34185a50:	687b      	ldr	r3, [r7, #4]
34185a52:	681b      	ldr	r3, [r3, #0]
34185a54:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34185a58:	d108      	bne.n	34185a6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
    {
      if (Pipe != DCMIPP_PIPE2)
34185a5a:	68bb      	ldr	r3, [r7, #8]
34185a5c:	2b02      	cmp	r3, #2
34185a5e:	d005      	beq.n	34185a6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
      {
        /* Add Data Type IDB for the selected Pipe except Pipe2 */
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34185a60:	687b      	ldr	r3, [r7, #4]
34185a62:	689b      	ldr	r3, [r3, #8]
34185a64:	021b      	lsls	r3, r3, #8
34185a66:	697a      	ldr	r2, [r7, #20]
34185a68:	4313      	orrs	r3, r2
34185a6a:	617b      	str	r3, [r7, #20]
      }
    }

    if (Pipe == DCMIPP_PIPE0)
34185a6c:	68bb      	ldr	r3, [r7, #8]
34185a6e:	2b00      	cmp	r3, #0
34185a70:	d10c      	bne.n	34185a8c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc8>
    {
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
34185a72:	68fb      	ldr	r3, [r7, #12]
34185a74:	681b      	ldr	r3, [r3, #0]
34185a76:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34185a7a:	4b21      	ldr	r3, [pc, #132]	@ (34185b00 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34185a7c:	4013      	ands	r3, r2
34185a7e:	68fa      	ldr	r2, [r7, #12]
34185a80:	6812      	ldr	r2, [r2, #0]
34185a82:	6979      	ldr	r1, [r7, #20]
34185a84:	430b      	orrs	r3, r1
34185a86:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
34185a8a:	e01b      	b.n	34185ac4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                 DCMIPP_P0FSCR_DTIDB, pxfscr_reg);
    }
    else if (Pipe == DCMIPP_PIPE1)
34185a8c:	68bb      	ldr	r3, [r7, #8]
34185a8e:	2b01      	cmp	r3, #1
34185a90:	d10c      	bne.n	34185aac <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe8>
    {
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34185a92:	68fb      	ldr	r3, [r7, #12]
34185a94:	681b      	ldr	r3, [r3, #0]
34185a96:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34185a9a:	4b19      	ldr	r3, [pc, #100]	@ (34185b00 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34185a9c:	4013      	ands	r3, r2
34185a9e:	68fa      	ldr	r2, [r7, #12]
34185aa0:	6812      	ldr	r2, [r2, #0]
34185aa2:	6979      	ldr	r1, [r7, #20]
34185aa4:	430b      	orrs	r3, r1
34185aa6:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
34185aaa:	e00b      	b.n	34185ac4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                                             DCMIPP_P1FSCR_DTMODE), pxfscr_reg);
    }
    else
    {
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
34185aac:	68fb      	ldr	r3, [r7, #12]
34185aae:	681b      	ldr	r3, [r3, #0]
34185ab0:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
34185ab4:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
34185ab8:	68fb      	ldr	r3, [r7, #12]
34185aba:	681b      	ldr	r3, [r3, #0]
34185abc:	697a      	ldr	r2, [r7, #20]
34185abe:	430a      	orrs	r2, r1
34185ac0:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }

    /* Disable Parallel interface */
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34185ac4:	68fb      	ldr	r3, [r7, #12]
34185ac6:	681b      	ldr	r3, [r3, #0]
34185ac8:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34185acc:	68fb      	ldr	r3, [r7, #12]
34185ace:	681b      	ldr	r3, [r3, #0]
34185ad0:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34185ad4:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Set CSI Input Selection  */
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34185ad8:	68fb      	ldr	r3, [r7, #12]
34185ada:	681b      	ldr	r3, [r3, #0]
34185adc:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
34185ae0:	68fb      	ldr	r3, [r7, #12]
34185ae2:	681b      	ldr	r3, [r3, #0]
34185ae4:	f042 0201 	orr.w	r2, r2, #1
34185ae8:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  }

  /* Update the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34185aec:	68fb      	ldr	r3, [r7, #12]
34185aee:	2202      	movs	r2, #2
34185af0:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34185af2:	2300      	movs	r3, #0
}
34185af4:	4618      	mov	r0, r3
34185af6:	371c      	adds	r7, #28
34185af8:	46bd      	mov	sp, r7
34185afa:	f85d 7b04 	ldr.w	r7, [sp], #4
34185afe:	4770      	bx	lr
34185b00:	fffcc0c0 	.word	0xfffcc0c0

34185b04 <HAL_DCMIPP_CSI_SetVCConfig>:
  * @param  DataTypeFormat Specifies the Data Type Format, can be a value from @ref DCMIPP_CSI_DataTypeFormat.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetVCConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel,
                                             uint32_t DataTypeFormat)
{
34185b04:	b480      	push	{r7}
34185b06:	b087      	sub	sp, #28
34185b08:	af00      	add	r7, sp, #0
34185b0a:	60f8      	str	r0, [r7, #12]
34185b0c:	60b9      	str	r1, [r7, #8]
34185b0e:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34185b10:	4b1c      	ldr	r3, [pc, #112]	@ (34185b84 <HAL_DCMIPP_CSI_SetVCConfig+0x80>)
34185b12:	617b      	str	r3, [r7, #20]

  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));

  /* Check pointer and input values validity */
  if (hdcmipp == NULL)
34185b14:	68fb      	ldr	r3, [r7, #12]
34185b16:	2b00      	cmp	r3, #0
34185b18:	d101      	bne.n	34185b1e <HAL_DCMIPP_CSI_SetVCConfig+0x1a>
  {
    return HAL_ERROR;
34185b1a:	2301      	movs	r3, #1
34185b1c:	e02c      	b.n	34185b78 <HAL_DCMIPP_CSI_SetVCConfig+0x74>
  }

  /* Set the common format for all data type for the selected virtual channel */
  switch (VirtualChannel)
34185b1e:	68bb      	ldr	r3, [r7, #8]
34185b20:	2b03      	cmp	r3, #3
34185b22:	d827      	bhi.n	34185b74 <HAL_DCMIPP_CSI_SetVCConfig+0x70>
34185b24:	a201      	add	r2, pc, #4	@ (adr r2, 34185b2c <HAL_DCMIPP_CSI_SetVCConfig+0x28>)
34185b26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34185b2a:	bf00      	nop
34185b2c:	34185b3d 	.word	0x34185b3d
34185b30:	34185b4b 	.word	0x34185b4b
34185b34:	34185b59 	.word	0x34185b59
34185b38:	34185b67 	.word	0x34185b67
  {
    case DCMIPP_VIRTUAL_CHANNEL0:
    {
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34185b3c:	687b      	ldr	r3, [r7, #4]
34185b3e:	021b      	lsls	r3, r3, #8
34185b40:	f043 0201 	orr.w	r2, r3, #1
34185b44:	697b      	ldr	r3, [r7, #20]
34185b46:	611a      	str	r2, [r3, #16]
      break;
34185b48:	e015      	b.n	34185b76 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL1:
    {
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
34185b4a:	687b      	ldr	r3, [r7, #4]
34185b4c:	021b      	lsls	r3, r3, #8
34185b4e:	f043 0201 	orr.w	r2, r3, #1
34185b52:	697b      	ldr	r3, [r7, #20]
34185b54:	621a      	str	r2, [r3, #32]
      break;
34185b56:	e00e      	b.n	34185b76 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL2:
    {
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34185b58:	687b      	ldr	r3, [r7, #4]
34185b5a:	021b      	lsls	r3, r3, #8
34185b5c:	f043 0201 	orr.w	r2, r3, #1
34185b60:	697b      	ldr	r3, [r7, #20]
34185b62:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
34185b64:	e007      	b.n	34185b76 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL3:
    {
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
34185b66:	687b      	ldr	r3, [r7, #4]
34185b68:	021b      	lsls	r3, r3, #8
34185b6a:	f043 0201 	orr.w	r2, r3, #1
34185b6e:	697b      	ldr	r3, [r7, #20]
34185b70:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
34185b72:	e000      	b.n	34185b76 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    default:
      break;
34185b74:	bf00      	nop
  }

  return HAL_OK;
34185b76:	2300      	movs	r3, #0
}
34185b78:	4618      	mov	r0, r3
34185b7a:	371c      	adds	r7, #28
34185b7c:	46bd      	mov	sp, r7
34185b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
34185b82:	4770      	bx	lr
34185b84:	58006000 	.word	0x58006000

34185b88 <HAL_DCMIPP_PIPE_SetConfig>:
  * @param  pPipeConfig pointer to pipe configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                            const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
34185b88:	b580      	push	{r7, lr}
34185b8a:	b086      	sub	sp, #24
34185b8c:	af00      	add	r7, sp, #0
34185b8e:	60f8      	str	r0, [r7, #12]
34185b90:	60b9      	str	r1, [r7, #8]
34185b92:	607a      	str	r2, [r7, #4]
  HAL_DCMIPP_PipeStateTypeDef pipe_state;

  /* Check the DCMIPP peripheral handle parameter and pPipeConfig parameter */
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34185b94:	68fb      	ldr	r3, [r7, #12]
34185b96:	2b00      	cmp	r3, #0
34185b98:	d002      	beq.n	34185ba0 <HAL_DCMIPP_PIPE_SetConfig+0x18>
34185b9a:	687b      	ldr	r3, [r7, #4]
34185b9c:	2b00      	cmp	r3, #0
34185b9e:	d101      	bne.n	34185ba4 <HAL_DCMIPP_PIPE_SetConfig+0x1c>
  {
    return HAL_ERROR;
34185ba0:	2301      	movs	r3, #1
34185ba2:	e02f      	b.n	34185c04 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  {
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
  }

  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
34185ba4:	68bb      	ldr	r3, [r7, #8]
34185ba6:	2b02      	cmp	r3, #2
34185ba8:	d105      	bne.n	34185bb6 <HAL_DCMIPP_PIPE_SetConfig+0x2e>
34185baa:	687b      	ldr	r3, [r7, #4]
34185bac:	689b      	ldr	r3, [r3, #8]
34185bae:	2b06      	cmp	r3, #6
34185bb0:	d901      	bls.n	34185bb6 <HAL_DCMIPP_PIPE_SetConfig+0x2e>
  {
    return HAL_ERROR;
34185bb2:	2301      	movs	r3, #1
34185bb4:	e026      	b.n	34185c04 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  }
  /* Get Pipe State */
  pipe_state = hdcmipp->PipeState[Pipe];
34185bb6:	68fa      	ldr	r2, [r7, #12]
34185bb8:	68bb      	ldr	r3, [r7, #8]
34185bba:	4413      	add	r3, r2
34185bbc:	3305      	adds	r3, #5
34185bbe:	781b      	ldrb	r3, [r3, #0]
34185bc0:	75fb      	strb	r3, [r7, #23]

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34185bc2:	68fb      	ldr	r3, [r7, #12]
34185bc4:	791b      	ldrb	r3, [r3, #4]
34185bc6:	b2db      	uxtb	r3, r3
34185bc8:	2b02      	cmp	r3, #2
34185bca:	d11a      	bne.n	34185c02 <HAL_DCMIPP_PIPE_SetConfig+0x7a>
  {
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
34185bcc:	7dfb      	ldrb	r3, [r7, #23]
34185bce:	2b00      	cmp	r3, #0
34185bd0:	d002      	beq.n	34185bd8 <HAL_DCMIPP_PIPE_SetConfig+0x50>
34185bd2:	7dfb      	ldrb	r3, [r7, #23]
34185bd4:	2b04      	cmp	r3, #4
34185bd6:	d112      	bne.n	34185bfe <HAL_DCMIPP_PIPE_SetConfig+0x76>
    {
      /* Update the DCMIPP PIPE state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34185bd8:	68fa      	ldr	r2, [r7, #12]
34185bda:	68bb      	ldr	r3, [r7, #8]
34185bdc:	4413      	add	r3, r2
34185bde:	3305      	adds	r3, #5
34185be0:	2202      	movs	r2, #2
34185be2:	701a      	strb	r2, [r3, #0]

      /* Initialize the DCMIPP Pipe registers */
      Pipe_Config(hdcmipp, Pipe, pPipeConfig);
34185be4:	687a      	ldr	r2, [r7, #4]
34185be6:	68b9      	ldr	r1, [r7, #8]
34185be8:	68f8      	ldr	r0, [r7, #12]
34185bea:	f002 fb99 	bl	34188320 <Pipe_Config>

      /* Update the DCMIPP pipe state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
34185bee:	68fa      	ldr	r2, [r7, #12]
34185bf0:	68bb      	ldr	r3, [r7, #8]
34185bf2:	4413      	add	r3, r2
34185bf4:	3305      	adds	r3, #5
34185bf6:	2201      	movs	r2, #1
34185bf8:	701a      	strb	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34185bfa:	2300      	movs	r3, #0
34185bfc:	e002      	b.n	34185c04 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
      return HAL_ERROR;
34185bfe:	2301      	movs	r3, #1
34185c00:	e000      	b.n	34185c04 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
    return HAL_ERROR;
34185c02:	2301      	movs	r3, #1
}
34185c04:	4618      	mov	r0, r3
34185c06:	3718      	adds	r7, #24
34185c08:	46bd      	mov	sp, r7
34185c0a:	bd80      	pop	{r7, pc}

34185c0c <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34185c0c:	b580      	push	{r7, lr}
34185c0e:	b084      	sub	sp, #16
34185c10:	af00      	add	r7, sp, #0
34185c12:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34185c14:	687b      	ldr	r3, [r7, #4]
34185c16:	681b      	ldr	r3, [r3, #0]
34185c18:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
34185c1c:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34185c1e:	687b      	ldr	r3, [r7, #4]
34185c20:	681b      	ldr	r3, [r3, #0]
34185c22:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34185c26:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34185c28:	68fb      	ldr	r3, [r7, #12]
34185c2a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34185c2e:	2b00      	cmp	r3, #0
34185c30:	d01e      	beq.n	34185c70 <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34185c32:	68bb      	ldr	r3, [r7, #8]
34185c34:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34185c38:	2b00      	cmp	r3, #0
34185c3a:	d019      	beq.n	34185c70 <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34185c3c:	687b      	ldr	r3, [r7, #4]
34185c3e:	681b      	ldr	r3, [r3, #0]
34185c40:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185c44:	687b      	ldr	r3, [r7, #4]
34185c46:	681b      	ldr	r3, [r3, #0]
34185c48:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34185c4c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34185c50:	687b      	ldr	r3, [r7, #4]
34185c52:	689b      	ldr	r3, [r3, #8]
34185c54:	f043 0204 	orr.w	r2, r3, #4
34185c58:	687b      	ldr	r3, [r7, #4]
34185c5a:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
34185c5c:	687b      	ldr	r3, [r7, #4]
34185c5e:	681b      	ldr	r3, [r3, #0]
34185c60:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34185c64:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34185c68:	2100      	movs	r1, #0
34185c6a:	6878      	ldr	r0, [r7, #4]
34185c6c:	f000 fe7d 	bl	3418696a <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34185c70:	68fb      	ldr	r3, [r7, #12]
34185c72:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34185c76:	2b00      	cmp	r3, #0
34185c78:	d00e      	beq.n	34185c98 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
34185c7a:	68bb      	ldr	r3, [r7, #8]
34185c7c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34185c80:	2b00      	cmp	r3, #0
34185c82:	d009      	beq.n	34185c98 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34185c84:	687b      	ldr	r3, [r7, #4]
34185c86:	681b      	ldr	r3, [r3, #0]
34185c88:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34185c8c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34185c90:	2100      	movs	r1, #0
34185c92:	6878      	ldr	r0, [r7, #4]
34185c94:	f000 fe53 	bl	3418693e <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34185c98:	68fb      	ldr	r3, [r7, #12]
34185c9a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34185c9e:	2b00      	cmp	r3, #0
34185ca0:	d023      	beq.n	34185cea <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34185ca2:	68bb      	ldr	r3, [r7, #8]
34185ca4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34185ca8:	2b00      	cmp	r3, #0
34185caa:	d01e      	beq.n	34185cea <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34185cac:	687b      	ldr	r3, [r7, #4]
34185cae:	681b      	ldr	r3, [r3, #0]
34185cb0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34185cb4:	f003 0304 	and.w	r3, r3, #4
34185cb8:	2b04      	cmp	r3, #4
34185cba:	d10c      	bne.n	34185cd6 <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34185cbc:	687b      	ldr	r3, [r7, #4]
34185cbe:	681b      	ldr	r3, [r3, #0]
34185cc0:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185cc4:	687b      	ldr	r3, [r7, #4]
34185cc6:	681b      	ldr	r3, [r3, #0]
34185cc8:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34185ccc:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34185cd0:	687b      	ldr	r3, [r7, #4]
34185cd2:	2201      	movs	r2, #1
34185cd4:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34185cd6:	687b      	ldr	r3, [r7, #4]
34185cd8:	681b      	ldr	r3, [r3, #0]
34185cda:	f44f 7200 	mov.w	r2, #512	@ 0x200
34185cde:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34185ce2:	2100      	movs	r1, #0
34185ce4:	6878      	ldr	r0, [r7, #4]
34185ce6:	f000 fe1f 	bl	34186928 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34185cea:	68fb      	ldr	r3, [r7, #12]
34185cec:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34185cf0:	2b00      	cmp	r3, #0
34185cf2:	d00e      	beq.n	34185d12 <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34185cf4:	68bb      	ldr	r3, [r7, #8]
34185cf6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34185cfa:	2b00      	cmp	r3, #0
34185cfc:	d009      	beq.n	34185d12 <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34185cfe:	687b      	ldr	r3, [r7, #4]
34185d00:	681b      	ldr	r3, [r3, #0]
34185d02:	f44f 7280 	mov.w	r2, #256	@ 0x100
34185d06:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34185d0a:	2100      	movs	r1, #0
34185d0c:	6878      	ldr	r0, [r7, #4]
34185d0e:	f000 fe21 	bl	34186954 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34185d12:	68fb      	ldr	r3, [r7, #12]
34185d14:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34185d18:	2b00      	cmp	r3, #0
34185d1a:	d021      	beq.n	34185d60 <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34185d1c:	68bb      	ldr	r3, [r7, #8]
34185d1e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34185d22:	2b00      	cmp	r3, #0
34185d24:	d01c      	beq.n	34185d60 <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34185d26:	687b      	ldr	r3, [r7, #4]
34185d28:	681b      	ldr	r3, [r3, #0]
34185d2a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185d2e:	687b      	ldr	r3, [r7, #4]
34185d30:	681b      	ldr	r3, [r3, #0]
34185d32:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34185d36:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34185d3a:	687b      	ldr	r3, [r7, #4]
34185d3c:	689b      	ldr	r3, [r3, #8]
34185d3e:	f043 0208 	orr.w	r2, r3, #8
34185d42:	687b      	ldr	r3, [r7, #4]
34185d44:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34185d46:	687b      	ldr	r3, [r7, #4]
34185d48:	681b      	ldr	r3, [r3, #0]
34185d4a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34185d4e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34185d52:	687b      	ldr	r3, [r7, #4]
34185d54:	2204      	movs	r2, #4
34185d56:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34185d58:	2100      	movs	r1, #0
34185d5a:	6878      	ldr	r0, [r7, #4]
34185d5c:	f000 fe10 	bl	34186980 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34185d60:	68fb      	ldr	r3, [r7, #12]
34185d62:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34185d66:	2b00      	cmp	r3, #0
34185d68:	d00e      	beq.n	34185d88 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34185d6a:	68bb      	ldr	r3, [r7, #8]
34185d6c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34185d70:	2b00      	cmp	r3, #0
34185d72:	d009      	beq.n	34185d88 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34185d74:	687b      	ldr	r3, [r7, #4]
34185d76:	681b      	ldr	r3, [r3, #0]
34185d78:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34185d7c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34185d80:	2101      	movs	r1, #1
34185d82:	6878      	ldr	r0, [r7, #4]
34185d84:	f000 fde6 	bl	34186954 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34185d88:	68fb      	ldr	r3, [r7, #12]
34185d8a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34185d8e:	2b00      	cmp	r3, #0
34185d90:	d00e      	beq.n	34185db0 <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34185d92:	68bb      	ldr	r3, [r7, #8]
34185d94:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34185d98:	2b00      	cmp	r3, #0
34185d9a:	d009      	beq.n	34185db0 <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34185d9c:	687b      	ldr	r3, [r7, #4]
34185d9e:	681b      	ldr	r3, [r3, #0]
34185da0:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34185da4:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34185da8:	2101      	movs	r1, #1
34185daa:	6878      	ldr	r0, [r7, #4]
34185dac:	f000 fdc7 	bl	3418693e <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34185db0:	68fb      	ldr	r3, [r7, #12]
34185db2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34185db6:	2b00      	cmp	r3, #0
34185db8:	d023      	beq.n	34185e02 <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34185dba:	68bb      	ldr	r3, [r7, #8]
34185dbc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34185dc0:	2b00      	cmp	r3, #0
34185dc2:	d01e      	beq.n	34185e02 <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34185dc4:	687b      	ldr	r3, [r7, #4]
34185dc6:	681b      	ldr	r3, [r3, #0]
34185dc8:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34185dcc:	f003 0304 	and.w	r3, r3, #4
34185dd0:	2b04      	cmp	r3, #4
34185dd2:	d10c      	bne.n	34185dee <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34185dd4:	687b      	ldr	r3, [r7, #4]
34185dd6:	681b      	ldr	r3, [r3, #0]
34185dd8:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185ddc:	687b      	ldr	r3, [r7, #4]
34185dde:	681b      	ldr	r3, [r3, #0]
34185de0:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34185de4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34185de8:	687b      	ldr	r3, [r7, #4]
34185dea:	2201      	movs	r2, #1
34185dec:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34185dee:	687b      	ldr	r3, [r7, #4]
34185df0:	681b      	ldr	r3, [r3, #0]
34185df2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34185df6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34185dfa:	2101      	movs	r1, #1
34185dfc:	6878      	ldr	r0, [r7, #4]
34185dfe:	f000 fd93 	bl	34186928 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
34185e02:	68fb      	ldr	r3, [r7, #12]
34185e04:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34185e08:	2b00      	cmp	r3, #0
34185e0a:	d021      	beq.n	34185e50 <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34185e0c:	68bb      	ldr	r3, [r7, #8]
34185e0e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34185e12:	2b00      	cmp	r3, #0
34185e14:	d01c      	beq.n	34185e50 <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34185e16:	687b      	ldr	r3, [r7, #4]
34185e18:	681b      	ldr	r3, [r3, #0]
34185e1a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185e1e:	687b      	ldr	r3, [r7, #4]
34185e20:	681b      	ldr	r3, [r3, #0]
34185e22:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34185e26:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34185e2a:	687b      	ldr	r3, [r7, #4]
34185e2c:	689b      	ldr	r3, [r3, #8]
34185e2e:	f043 0210 	orr.w	r2, r3, #16
34185e32:	687b      	ldr	r3, [r7, #4]
34185e34:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34185e36:	687b      	ldr	r3, [r7, #4]
34185e38:	681b      	ldr	r3, [r3, #0]
34185e3a:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34185e3e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34185e42:	687b      	ldr	r3, [r7, #4]
34185e44:	2204      	movs	r2, #4
34185e46:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34185e48:	2101      	movs	r1, #1
34185e4a:	6878      	ldr	r0, [r7, #4]
34185e4c:	f000 fd98 	bl	34186980 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34185e50:	68fb      	ldr	r3, [r7, #12]
34185e52:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34185e56:	2b00      	cmp	r3, #0
34185e58:	d00e      	beq.n	34185e78 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34185e5a:	68bb      	ldr	r3, [r7, #8]
34185e5c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34185e60:	2b00      	cmp	r3, #0
34185e62:	d009      	beq.n	34185e78 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34185e64:	687b      	ldr	r3, [r7, #4]
34185e66:	681b      	ldr	r3, [r3, #0]
34185e68:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34185e6c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34185e70:	2102      	movs	r1, #2
34185e72:	6878      	ldr	r0, [r7, #4]
34185e74:	f000 fd6e 	bl	34186954 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34185e78:	68fb      	ldr	r3, [r7, #12]
34185e7a:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34185e7e:	2b00      	cmp	r3, #0
34185e80:	d00e      	beq.n	34185ea0 <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34185e82:	68bb      	ldr	r3, [r7, #8]
34185e84:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34185e88:	2b00      	cmp	r3, #0
34185e8a:	d009      	beq.n	34185ea0 <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34185e8c:	687b      	ldr	r3, [r7, #4]
34185e8e:	681b      	ldr	r3, [r3, #0]
34185e90:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34185e94:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34185e98:	2102      	movs	r1, #2
34185e9a:	6878      	ldr	r0, [r7, #4]
34185e9c:	f000 fd4f 	bl	3418693e <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34185ea0:	68fb      	ldr	r3, [r7, #12]
34185ea2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34185ea6:	2b00      	cmp	r3, #0
34185ea8:	d023      	beq.n	34185ef2 <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34185eaa:	68bb      	ldr	r3, [r7, #8]
34185eac:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34185eb0:	2b00      	cmp	r3, #0
34185eb2:	d01e      	beq.n	34185ef2 <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34185eb4:	687b      	ldr	r3, [r7, #4]
34185eb6:	681b      	ldr	r3, [r3, #0]
34185eb8:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34185ebc:	f003 0304 	and.w	r3, r3, #4
34185ec0:	2b04      	cmp	r3, #4
34185ec2:	d10c      	bne.n	34185ede <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34185ec4:	687b      	ldr	r3, [r7, #4]
34185ec6:	681b      	ldr	r3, [r3, #0]
34185ec8:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185ecc:	687b      	ldr	r3, [r7, #4]
34185ece:	681b      	ldr	r3, [r3, #0]
34185ed0:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34185ed4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34185ed8:	687b      	ldr	r3, [r7, #4]
34185eda:	2201      	movs	r2, #1
34185edc:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34185ede:	687b      	ldr	r3, [r7, #4]
34185ee0:	681b      	ldr	r3, [r3, #0]
34185ee2:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34185ee6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34185eea:	2102      	movs	r1, #2
34185eec:	6878      	ldr	r0, [r7, #4]
34185eee:	f000 fd1b 	bl	34186928 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34185ef2:	68fb      	ldr	r3, [r7, #12]
34185ef4:	2b00      	cmp	r3, #0
34185ef6:	da1f      	bge.n	34185f38 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34185ef8:	68bb      	ldr	r3, [r7, #8]
34185efa:	2b00      	cmp	r3, #0
34185efc:	da1c      	bge.n	34185f38 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34185efe:	687b      	ldr	r3, [r7, #4]
34185f00:	681b      	ldr	r3, [r3, #0]
34185f02:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185f06:	687b      	ldr	r3, [r7, #4]
34185f08:	681b      	ldr	r3, [r3, #0]
34185f0a:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34185f0e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34185f12:	687b      	ldr	r3, [r7, #4]
34185f14:	689b      	ldr	r3, [r3, #8]
34185f16:	f043 0220 	orr.w	r2, r3, #32
34185f1a:	687b      	ldr	r3, [r7, #4]
34185f1c:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34185f1e:	687b      	ldr	r3, [r7, #4]
34185f20:	681b      	ldr	r3, [r3, #0]
34185f22:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34185f26:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34185f2a:	687b      	ldr	r3, [r7, #4]
34185f2c:	2204      	movs	r2, #4
34185f2e:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34185f30:	2102      	movs	r1, #2
34185f32:	6878      	ldr	r0, [r7, #4]
34185f34:	f000 fd24 	bl	34186980 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34185f38:	68fb      	ldr	r3, [r7, #12]
34185f3a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34185f3e:	2b00      	cmp	r3, #0
34185f40:	d01f      	beq.n	34185f82 <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34185f42:	68bb      	ldr	r3, [r7, #8]
34185f44:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34185f48:	2b00      	cmp	r3, #0
34185f4a:	d01a      	beq.n	34185f82 <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34185f4c:	687b      	ldr	r3, [r7, #4]
34185f4e:	681b      	ldr	r3, [r3, #0]
34185f50:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185f54:	687b      	ldr	r3, [r7, #4]
34185f56:	681b      	ldr	r3, [r3, #0]
34185f58:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34185f5c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34185f60:	687b      	ldr	r3, [r7, #4]
34185f62:	689b      	ldr	r3, [r3, #8]
34185f64:	f043 0202 	orr.w	r2, r3, #2
34185f68:	687b      	ldr	r3, [r7, #4]
34185f6a:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34185f6c:	687b      	ldr	r3, [r7, #4]
34185f6e:	681b      	ldr	r3, [r3, #0]
34185f70:	2240      	movs	r2, #64	@ 0x40
34185f72:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34185f76:	687b      	ldr	r3, [r7, #4]
34185f78:	2204      	movs	r2, #4
34185f7a:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34185f7c:	6878      	ldr	r0, [r7, #4]
34185f7e:	f000 fd0a 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34185f82:	68fb      	ldr	r3, [r7, #12]
34185f84:	f003 0320 	and.w	r3, r3, #32
34185f88:	2b00      	cmp	r3, #0
34185f8a:	d01f      	beq.n	34185fcc <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34185f8c:	68bb      	ldr	r3, [r7, #8]
34185f8e:	f003 0320 	and.w	r3, r3, #32
34185f92:	2b00      	cmp	r3, #0
34185f94:	d01a      	beq.n	34185fcc <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34185f96:	687b      	ldr	r3, [r7, #4]
34185f98:	681b      	ldr	r3, [r3, #0]
34185f9a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34185f9e:	687b      	ldr	r3, [r7, #4]
34185fa0:	681b      	ldr	r3, [r3, #0]
34185fa2:	f022 0220 	bic.w	r2, r2, #32
34185fa6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34185faa:	687b      	ldr	r3, [r7, #4]
34185fac:	689b      	ldr	r3, [r3, #8]
34185fae:	f043 0201 	orr.w	r2, r3, #1
34185fb2:	687b      	ldr	r3, [r7, #4]
34185fb4:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34185fb6:	687b      	ldr	r3, [r7, #4]
34185fb8:	681b      	ldr	r3, [r3, #0]
34185fba:	2220      	movs	r2, #32
34185fbc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34185fc0:	687b      	ldr	r3, [r7, #4]
34185fc2:	2204      	movs	r2, #4
34185fc4:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34185fc6:	6878      	ldr	r0, [r7, #4]
34185fc8:	f000 fce5 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34185fcc:	bf00      	nop
34185fce:	3710      	adds	r7, #16
34185fd0:	46bd      	mov	sp, r7
34185fd2:	bd80      	pop	{r7, pc}

34185fd4 <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34185fd4:	b580      	push	{r7, lr}
34185fd6:	b088      	sub	sp, #32
34185fd8:	af00      	add	r7, sp, #0
34185fda:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34185fdc:	4bb1      	ldr	r3, [pc, #708]	@ (341862a4 <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
34185fde:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34185fe0:	69fb      	ldr	r3, [r7, #28]
34185fe2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34185fe6:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34185fe8:	69fb      	ldr	r3, [r7, #28]
34185fea:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34185fee:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34185ff0:	69fb      	ldr	r3, [r7, #28]
34185ff2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34185ff6:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34185ff8:	69fb      	ldr	r3, [r7, #28]
34185ffa:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34185ffe:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34186000:	69bb      	ldr	r3, [r7, #24]
34186002:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34186006:	2b00      	cmp	r3, #0
34186008:	d014      	beq.n	34186034 <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
3418600a:	693b      	ldr	r3, [r7, #16]
3418600c:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34186010:	2b00      	cmp	r3, #0
34186012:	d00f      	beq.n	34186034 <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34186014:	69fb      	ldr	r3, [r7, #28]
34186016:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418601a:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
3418601e:	69fb      	ldr	r3, [r7, #28]
34186020:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34186024:	69fb      	ldr	r3, [r7, #28]
34186026:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
3418602a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
3418602e:	6878      	ldr	r0, [r7, #4]
34186030:	f000 fcc6 	bl	341869c0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34186034:	69bb      	ldr	r3, [r7, #24]
34186036:	f003 0308 	and.w	r3, r3, #8
3418603a:	2b00      	cmp	r3, #0
3418603c:	d01c      	beq.n	34186078 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
3418603e:	693b      	ldr	r3, [r7, #16]
34186040:	f003 0308 	and.w	r3, r3, #8
34186044:	2b00      	cmp	r3, #0
34186046:	d017      	beq.n	34186078 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186048:	687b      	ldr	r3, [r7, #4]
3418604a:	681b      	ldr	r3, [r3, #0]
3418604c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186050:	f003 0304 	and.w	r3, r3, #4
34186054:	2b04      	cmp	r3, #4
34186056:	d107      	bne.n	34186068 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
34186058:	69fb      	ldr	r3, [r7, #28]
3418605a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418605e:	f023 0208 	bic.w	r2, r3, #8
34186062:	69fb      	ldr	r3, [r7, #28]
34186064:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
34186068:	69fb      	ldr	r3, [r7, #28]
3418606a:	2208      	movs	r2, #8
3418606c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34186070:	2103      	movs	r1, #3
34186072:	6878      	ldr	r0, [r7, #4]
34186074:	f000 fcd9 	bl	34186a2a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
34186078:	69bb      	ldr	r3, [r7, #24]
3418607a:	f003 0304 	and.w	r3, r3, #4
3418607e:	2b00      	cmp	r3, #0
34186080:	d01c      	beq.n	341860bc <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
34186082:	693b      	ldr	r3, [r7, #16]
34186084:	f003 0304 	and.w	r3, r3, #4
34186088:	2b00      	cmp	r3, #0
3418608a:	d017      	beq.n	341860bc <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418608c:	687b      	ldr	r3, [r7, #4]
3418608e:	681b      	ldr	r3, [r3, #0]
34186090:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186094:	f003 0304 	and.w	r3, r3, #4
34186098:	2b04      	cmp	r3, #4
3418609a:	d107      	bne.n	341860ac <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
3418609c:	69fb      	ldr	r3, [r7, #28]
3418609e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341860a2:	f023 0204 	bic.w	r2, r3, #4
341860a6:	69fb      	ldr	r3, [r7, #28]
341860a8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
341860ac:	69fb      	ldr	r3, [r7, #28]
341860ae:	2204      	movs	r2, #4
341860b0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
341860b4:	2102      	movs	r1, #2
341860b6:	6878      	ldr	r0, [r7, #4]
341860b8:	f000 fcb7 	bl	34186a2a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
341860bc:	69bb      	ldr	r3, [r7, #24]
341860be:	f003 0302 	and.w	r3, r3, #2
341860c2:	2b00      	cmp	r3, #0
341860c4:	d01c      	beq.n	34186100 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
341860c6:	693b      	ldr	r3, [r7, #16]
341860c8:	f003 0302 	and.w	r3, r3, #2
341860cc:	2b00      	cmp	r3, #0
341860ce:	d017      	beq.n	34186100 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341860d0:	687b      	ldr	r3, [r7, #4]
341860d2:	681b      	ldr	r3, [r3, #0]
341860d4:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341860d8:	f003 0304 	and.w	r3, r3, #4
341860dc:	2b04      	cmp	r3, #4
341860de:	d107      	bne.n	341860f0 <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
341860e0:	69fb      	ldr	r3, [r7, #28]
341860e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341860e6:	f023 0202 	bic.w	r2, r3, #2
341860ea:	69fb      	ldr	r3, [r7, #28]
341860ec:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
341860f0:	69fb      	ldr	r3, [r7, #28]
341860f2:	2202      	movs	r2, #2
341860f4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
341860f8:	2101      	movs	r1, #1
341860fa:	6878      	ldr	r0, [r7, #4]
341860fc:	f000 fc95 	bl	34186a2a <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34186100:	69bb      	ldr	r3, [r7, #24]
34186102:	f003 0301 	and.w	r3, r3, #1
34186106:	2b00      	cmp	r3, #0
34186108:	d01c      	beq.n	34186144 <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
3418610a:	693b      	ldr	r3, [r7, #16]
3418610c:	f003 0301 	and.w	r3, r3, #1
34186110:	2b00      	cmp	r3, #0
34186112:	d017      	beq.n	34186144 <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186114:	687b      	ldr	r3, [r7, #4]
34186116:	681b      	ldr	r3, [r3, #0]
34186118:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418611c:	f003 0304 	and.w	r3, r3, #4
34186120:	2b04      	cmp	r3, #4
34186122:	d107      	bne.n	34186134 <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34186124:	69fb      	ldr	r3, [r7, #28]
34186126:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418612a:	f023 0201 	bic.w	r2, r3, #1
3418612e:	69fb      	ldr	r3, [r7, #28]
34186130:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34186134:	69fb      	ldr	r3, [r7, #28]
34186136:	2201      	movs	r2, #1
34186138:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
3418613c:	2100      	movs	r1, #0
3418613e:	6878      	ldr	r0, [r7, #4]
34186140:	f000 fc73 	bl	34186a2a <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34186144:	69bb      	ldr	r3, [r7, #24]
34186146:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3418614a:	2b00      	cmp	r3, #0
3418614c:	d01d      	beq.n	3418618a <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
3418614e:	693b      	ldr	r3, [r7, #16]
34186150:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34186154:	2b00      	cmp	r3, #0
34186156:	d018      	beq.n	3418618a <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186158:	687b      	ldr	r3, [r7, #4]
3418615a:	681b      	ldr	r3, [r3, #0]
3418615c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186160:	f003 0304 	and.w	r3, r3, #4
34186164:	2b04      	cmp	r3, #4
34186166:	d107      	bne.n	34186178 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
34186168:	69fb      	ldr	r3, [r7, #28]
3418616a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418616e:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
34186172:	69fb      	ldr	r3, [r7, #28]
34186174:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
34186178:	69fb      	ldr	r3, [r7, #28]
3418617a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3418617e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34186182:	2103      	movs	r1, #3
34186184:	6878      	ldr	r0, [r7, #4]
34186186:	f000 fc2f 	bl	341869e8 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
3418618a:	69bb      	ldr	r3, [r7, #24]
3418618c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34186190:	2b00      	cmp	r3, #0
34186192:	d01d      	beq.n	341861d0 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
34186194:	693b      	ldr	r3, [r7, #16]
34186196:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418619a:	2b00      	cmp	r3, #0
3418619c:	d018      	beq.n	341861d0 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418619e:	687b      	ldr	r3, [r7, #4]
341861a0:	681b      	ldr	r3, [r3, #0]
341861a2:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341861a6:	f003 0304 	and.w	r3, r3, #4
341861aa:	2b04      	cmp	r3, #4
341861ac:	d107      	bne.n	341861be <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
341861ae:	69fb      	ldr	r3, [r7, #28]
341861b0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341861b4:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
341861b8:	69fb      	ldr	r3, [r7, #28]
341861ba:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
341861be:	69fb      	ldr	r3, [r7, #28]
341861c0:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
341861c4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
341861c8:	2102      	movs	r1, #2
341861ca:	6878      	ldr	r0, [r7, #4]
341861cc:	f000 fc0c 	bl	341869e8 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
341861d0:	69bb      	ldr	r3, [r7, #24]
341861d2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
341861d6:	2b00      	cmp	r3, #0
341861d8:	d01d      	beq.n	34186216 <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
341861da:	693b      	ldr	r3, [r7, #16]
341861dc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
341861e0:	2b00      	cmp	r3, #0
341861e2:	d018      	beq.n	34186216 <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341861e4:	687b      	ldr	r3, [r7, #4]
341861e6:	681b      	ldr	r3, [r3, #0]
341861e8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341861ec:	f003 0304 	and.w	r3, r3, #4
341861f0:	2b04      	cmp	r3, #4
341861f2:	d107      	bne.n	34186204 <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
341861f4:	69fb      	ldr	r3, [r7, #28]
341861f6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341861fa:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
341861fe:	69fb      	ldr	r3, [r7, #28]
34186200:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34186204:	69fb      	ldr	r3, [r7, #28]
34186206:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3418620a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
3418620e:	2101      	movs	r1, #1
34186210:	6878      	ldr	r0, [r7, #4]
34186212:	f000 fbe9 	bl	341869e8 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34186216:	69bb      	ldr	r3, [r7, #24]
34186218:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3418621c:	2b00      	cmp	r3, #0
3418621e:	d01d      	beq.n	3418625c <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
34186220:	693b      	ldr	r3, [r7, #16]
34186222:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34186226:	2b00      	cmp	r3, #0
34186228:	d018      	beq.n	3418625c <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418622a:	687b      	ldr	r3, [r7, #4]
3418622c:	681b      	ldr	r3, [r3, #0]
3418622e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186232:	f003 0304 	and.w	r3, r3, #4
34186236:	2b04      	cmp	r3, #4
34186238:	d107      	bne.n	3418624a <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
3418623a:	69fb      	ldr	r3, [r7, #28]
3418623c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186240:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34186244:	69fb      	ldr	r3, [r7, #28]
34186246:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
3418624a:	69fb      	ldr	r3, [r7, #28]
3418624c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34186250:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34186254:	2100      	movs	r1, #0
34186256:	6878      	ldr	r0, [r7, #4]
34186258:	f000 fbc6 	bl	341869e8 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
3418625c:	69bb      	ldr	r3, [r7, #24]
3418625e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34186262:	2b00      	cmp	r3, #0
34186264:	d020      	beq.n	341862a8 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34186266:	693b      	ldr	r3, [r7, #16]
34186268:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418626c:	2b00      	cmp	r3, #0
3418626e:	d01b      	beq.n	341862a8 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186270:	687b      	ldr	r3, [r7, #4]
34186272:	681b      	ldr	r3, [r3, #0]
34186274:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186278:	f003 0304 	and.w	r3, r3, #4
3418627c:	2b04      	cmp	r3, #4
3418627e:	d107      	bne.n	34186290 <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34186280:	69fb      	ldr	r3, [r7, #28]
34186282:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186286:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
3418628a:	69fb      	ldr	r3, [r7, #28]
3418628c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34186290:	69fb      	ldr	r3, [r7, #28]
34186292:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34186296:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
3418629a:	2103      	movs	r1, #3
3418629c:	6878      	ldr	r0, [r7, #4]
3418629e:	f000 fbae 	bl	341869fe <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
341862a2:	e001      	b.n	341862a8 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
341862a4:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
341862a8:	69bb      	ldr	r3, [r7, #24]
341862aa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341862ae:	2b00      	cmp	r3, #0
341862b0:	d01d      	beq.n	341862ee <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
341862b2:	693b      	ldr	r3, [r7, #16]
341862b4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341862b8:	2b00      	cmp	r3, #0
341862ba:	d018      	beq.n	341862ee <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341862bc:	687b      	ldr	r3, [r7, #4]
341862be:	681b      	ldr	r3, [r3, #0]
341862c0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341862c4:	f003 0304 	and.w	r3, r3, #4
341862c8:	2b04      	cmp	r3, #4
341862ca:	d107      	bne.n	341862dc <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
341862cc:	69fb      	ldr	r3, [r7, #28]
341862ce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341862d2:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
341862d6:	69fb      	ldr	r3, [r7, #28]
341862d8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
341862dc:	69fb      	ldr	r3, [r7, #28]
341862de:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341862e2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
341862e6:	2102      	movs	r1, #2
341862e8:	6878      	ldr	r0, [r7, #4]
341862ea:	f000 fb88 	bl	341869fe <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
341862ee:	69bb      	ldr	r3, [r7, #24]
341862f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341862f4:	2b00      	cmp	r3, #0
341862f6:	d01d      	beq.n	34186334 <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
341862f8:	693b      	ldr	r3, [r7, #16]
341862fa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341862fe:	2b00      	cmp	r3, #0
34186300:	d018      	beq.n	34186334 <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186302:	687b      	ldr	r3, [r7, #4]
34186304:	681b      	ldr	r3, [r3, #0]
34186306:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418630a:	f003 0304 	and.w	r3, r3, #4
3418630e:	2b04      	cmp	r3, #4
34186310:	d107      	bne.n	34186322 <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
34186312:	69fb      	ldr	r3, [r7, #28]
34186314:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186318:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3418631c:	69fb      	ldr	r3, [r7, #28]
3418631e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
34186322:	69fb      	ldr	r3, [r7, #28]
34186324:	f44f 7200 	mov.w	r2, #512	@ 0x200
34186328:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
3418632c:	2101      	movs	r1, #1
3418632e:	6878      	ldr	r0, [r7, #4]
34186330:	f000 fb65 	bl	341869fe <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34186334:	69bb      	ldr	r3, [r7, #24]
34186336:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418633a:	2b00      	cmp	r3, #0
3418633c:	d01d      	beq.n	3418637a <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
3418633e:	693b      	ldr	r3, [r7, #16]
34186340:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34186344:	2b00      	cmp	r3, #0
34186346:	d018      	beq.n	3418637a <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186348:	687b      	ldr	r3, [r7, #4]
3418634a:	681b      	ldr	r3, [r3, #0]
3418634c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186350:	f003 0304 	and.w	r3, r3, #4
34186354:	2b04      	cmp	r3, #4
34186356:	d107      	bne.n	34186368 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
34186358:	69fb      	ldr	r3, [r7, #28]
3418635a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418635e:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34186362:	69fb      	ldr	r3, [r7, #28]
34186364:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
34186368:	69fb      	ldr	r3, [r7, #28]
3418636a:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418636e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34186372:	2100      	movs	r1, #0
34186374:	6878      	ldr	r0, [r7, #4]
34186376:	f000 fb42 	bl	341869fe <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
3418637a:	69bb      	ldr	r3, [r7, #24]
3418637c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34186380:	2b00      	cmp	r3, #0
34186382:	d01c      	beq.n	341863be <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
34186384:	693b      	ldr	r3, [r7, #16]
34186386:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418638a:	2b00      	cmp	r3, #0
3418638c:	d017      	beq.n	341863be <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418638e:	687b      	ldr	r3, [r7, #4]
34186390:	681b      	ldr	r3, [r3, #0]
34186392:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186396:	f003 0304 	and.w	r3, r3, #4
3418639a:	2b04      	cmp	r3, #4
3418639c:	d107      	bne.n	341863ae <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
3418639e:	69fb      	ldr	r3, [r7, #28]
341863a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341863a4:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
341863a8:	69fb      	ldr	r3, [r7, #28]
341863aa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
341863ae:	69fb      	ldr	r3, [r7, #28]
341863b0:	2280      	movs	r2, #128	@ 0x80
341863b2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
341863b6:	2103      	movs	r1, #3
341863b8:	6878      	ldr	r0, [r7, #4]
341863ba:	f000 fb2b 	bl	34186a14 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
341863be:	69bb      	ldr	r3, [r7, #24]
341863c0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341863c4:	2b00      	cmp	r3, #0
341863c6:	d01c      	beq.n	34186402 <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
341863c8:	693b      	ldr	r3, [r7, #16]
341863ca:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341863ce:	2b00      	cmp	r3, #0
341863d0:	d017      	beq.n	34186402 <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341863d2:	687b      	ldr	r3, [r7, #4]
341863d4:	681b      	ldr	r3, [r3, #0]
341863d6:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341863da:	f003 0304 	and.w	r3, r3, #4
341863de:	2b04      	cmp	r3, #4
341863e0:	d107      	bne.n	341863f2 <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
341863e2:	69fb      	ldr	r3, [r7, #28]
341863e4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341863e8:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
341863ec:	69fb      	ldr	r3, [r7, #28]
341863ee:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
341863f2:	69fb      	ldr	r3, [r7, #28]
341863f4:	2240      	movs	r2, #64	@ 0x40
341863f6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
341863fa:	2102      	movs	r1, #2
341863fc:	6878      	ldr	r0, [r7, #4]
341863fe:	f000 fb09 	bl	34186a14 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
34186402:	69bb      	ldr	r3, [r7, #24]
34186404:	f003 0320 	and.w	r3, r3, #32
34186408:	2b00      	cmp	r3, #0
3418640a:	d01c      	beq.n	34186446 <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
3418640c:	693b      	ldr	r3, [r7, #16]
3418640e:	f003 0320 	and.w	r3, r3, #32
34186412:	2b00      	cmp	r3, #0
34186414:	d017      	beq.n	34186446 <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186416:	687b      	ldr	r3, [r7, #4]
34186418:	681b      	ldr	r3, [r3, #0]
3418641a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418641e:	f003 0304 	and.w	r3, r3, #4
34186422:	2b04      	cmp	r3, #4
34186424:	d107      	bne.n	34186436 <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34186426:	69fb      	ldr	r3, [r7, #28]
34186428:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418642c:	f023 0220 	bic.w	r2, r3, #32
34186430:	69fb      	ldr	r3, [r7, #28]
34186432:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34186436:	69fb      	ldr	r3, [r7, #28]
34186438:	2220      	movs	r2, #32
3418643a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3418643e:	2101      	movs	r1, #1
34186440:	6878      	ldr	r0, [r7, #4]
34186442:	f000 fae7 	bl	34186a14 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34186446:	69bb      	ldr	r3, [r7, #24]
34186448:	f003 0310 	and.w	r3, r3, #16
3418644c:	2b00      	cmp	r3, #0
3418644e:	d01c      	beq.n	3418648a <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
34186450:	693b      	ldr	r3, [r7, #16]
34186452:	f003 0310 	and.w	r3, r3, #16
34186456:	2b00      	cmp	r3, #0
34186458:	d017      	beq.n	3418648a <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418645a:	687b      	ldr	r3, [r7, #4]
3418645c:	681b      	ldr	r3, [r3, #0]
3418645e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186462:	f003 0304 	and.w	r3, r3, #4
34186466:	2b04      	cmp	r3, #4
34186468:	d107      	bne.n	3418647a <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
3418646a:	69fb      	ldr	r3, [r7, #28]
3418646c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186470:	f023 0210 	bic.w	r2, r3, #16
34186474:	69fb      	ldr	r3, [r7, #28]
34186476:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
3418647a:	69fb      	ldr	r3, [r7, #28]
3418647c:	2210      	movs	r2, #16
3418647e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34186482:	2100      	movs	r1, #0
34186484:	6878      	ldr	r0, [r7, #4]
34186486:	f000 fac5 	bl	34186a14 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
3418648a:	69bb      	ldr	r3, [r7, #24]
3418648c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34186490:	2b00      	cmp	r3, #0
34186492:	d01a      	beq.n	341864ca <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
34186494:	693b      	ldr	r3, [r7, #16]
34186496:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418649a:	2b00      	cmp	r3, #0
3418649c:	d015      	beq.n	341864ca <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
3418649e:	69fb      	ldr	r3, [r7, #28]
341864a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341864a4:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
341864a8:	69fb      	ldr	r3, [r7, #28]
341864aa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
341864ae:	69fb      	ldr	r3, [r7, #28]
341864b0:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
341864b4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
341864b8:	687b      	ldr	r3, [r7, #4]
341864ba:	689b      	ldr	r3, [r3, #8]
341864bc:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
341864c0:	687b      	ldr	r3, [r7, #4]
341864c2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
341864c4:	6878      	ldr	r0, [r7, #4]
341864c6:	f000 fa66 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
341864ca:	69bb      	ldr	r3, [r7, #24]
341864cc:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
341864d0:	2b00      	cmp	r3, #0
341864d2:	d01a      	beq.n	3418650a <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
341864d4:	693b      	ldr	r3, [r7, #16]
341864d6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
341864da:	2b00      	cmp	r3, #0
341864dc:	d015      	beq.n	3418650a <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
341864de:	69fb      	ldr	r3, [r7, #28]
341864e0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341864e4:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
341864e8:	69fb      	ldr	r3, [r7, #28]
341864ea:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
341864ee:	69fb      	ldr	r3, [r7, #28]
341864f0:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
341864f4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
341864f8:	687b      	ldr	r3, [r7, #4]
341864fa:	689b      	ldr	r3, [r3, #8]
341864fc:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
34186500:	687b      	ldr	r3, [r7, #4]
34186502:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34186504:	6878      	ldr	r0, [r7, #4]
34186506:	f000 fa46 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
3418650a:	69bb      	ldr	r3, [r7, #24]
3418650c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34186510:	2b00      	cmp	r3, #0
34186512:	d01a      	beq.n	3418654a <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34186514:	693b      	ldr	r3, [r7, #16]
34186516:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3418651a:	2b00      	cmp	r3, #0
3418651c:	d015      	beq.n	3418654a <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
3418651e:	69fb      	ldr	r3, [r7, #28]
34186520:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186524:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34186528:	69fb      	ldr	r3, [r7, #28]
3418652a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
3418652e:	69fb      	ldr	r3, [r7, #28]
34186530:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34186534:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34186538:	687b      	ldr	r3, [r7, #4]
3418653a:	689b      	ldr	r3, [r3, #8]
3418653c:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34186540:	687b      	ldr	r3, [r7, #4]
34186542:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34186544:	6878      	ldr	r0, [r7, #4]
34186546:	f000 fa26 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
3418654a:	69bb      	ldr	r3, [r7, #24]
3418654c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34186550:	2b00      	cmp	r3, #0
34186552:	d01a      	beq.n	3418658a <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34186554:	693b      	ldr	r3, [r7, #16]
34186556:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418655a:	2b00      	cmp	r3, #0
3418655c:	d015      	beq.n	3418658a <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
3418655e:	69fb      	ldr	r3, [r7, #28]
34186560:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186564:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34186568:	69fb      	ldr	r3, [r7, #28]
3418656a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
3418656e:	69fb      	ldr	r3, [r7, #28]
34186570:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34186574:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34186578:	687b      	ldr	r3, [r7, #4]
3418657a:	689b      	ldr	r3, [r3, #8]
3418657c:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
34186580:	687b      	ldr	r3, [r7, #4]
34186582:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34186584:	6878      	ldr	r0, [r7, #4]
34186586:	f000 fa06 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
3418658a:	69bb      	ldr	r3, [r7, #24]
3418658c:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34186590:	2b00      	cmp	r3, #0
34186592:	d01a      	beq.n	341865ca <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34186594:	693b      	ldr	r3, [r7, #16]
34186596:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
3418659a:	2b00      	cmp	r3, #0
3418659c:	d015      	beq.n	341865ca <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
3418659e:	69fb      	ldr	r3, [r7, #28]
341865a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341865a4:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
341865a8:	69fb      	ldr	r3, [r7, #28]
341865aa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
341865ae:	69fb      	ldr	r3, [r7, #28]
341865b0:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
341865b4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
341865b8:	687b      	ldr	r3, [r7, #4]
341865ba:	689b      	ldr	r3, [r3, #8]
341865bc:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
341865c0:	687b      	ldr	r3, [r7, #4]
341865c2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
341865c4:	6878      	ldr	r0, [r7, #4]
341865c6:	f000 f9e6 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
341865ca:	69bb      	ldr	r3, [r7, #24]
341865cc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
341865d0:	2b00      	cmp	r3, #0
341865d2:	d01a      	beq.n	3418660a <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
341865d4:	693b      	ldr	r3, [r7, #16]
341865d6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
341865da:	2b00      	cmp	r3, #0
341865dc:	d015      	beq.n	3418660a <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
341865de:	69fb      	ldr	r3, [r7, #28]
341865e0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341865e4:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
341865e8:	69fb      	ldr	r3, [r7, #28]
341865ea:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
341865ee:	69fb      	ldr	r3, [r7, #28]
341865f0:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
341865f4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
341865f8:	687b      	ldr	r3, [r7, #4]
341865fa:	689b      	ldr	r3, [r3, #8]
341865fc:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
34186600:	687b      	ldr	r3, [r7, #4]
34186602:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34186604:	6878      	ldr	r0, [r7, #4]
34186606:	f000 f9c6 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
3418660a:	69bb      	ldr	r3, [r7, #24]
3418660c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34186610:	2b00      	cmp	r3, #0
34186612:	d01a      	beq.n	3418664a <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34186614:	693b      	ldr	r3, [r7, #16]
34186616:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418661a:	2b00      	cmp	r3, #0
3418661c:	d015      	beq.n	3418664a <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
3418661e:	69fb      	ldr	r3, [r7, #28]
34186620:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186624:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34186628:	69fb      	ldr	r3, [r7, #28]
3418662a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
3418662e:	69fb      	ldr	r3, [r7, #28]
34186630:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34186634:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34186638:	687b      	ldr	r3, [r7, #4]
3418663a:	689b      	ldr	r3, [r3, #8]
3418663c:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
34186640:	687b      	ldr	r3, [r7, #4]
34186642:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34186644:	6878      	ldr	r0, [r7, #4]
34186646:	f000 f9a6 	bl	34186996 <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
3418664a:	697b      	ldr	r3, [r7, #20]
3418664c:	f003 0301 	and.w	r3, r3, #1
34186650:	2b00      	cmp	r3, #0
34186652:	d01d      	beq.n	34186690 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34186654:	68fb      	ldr	r3, [r7, #12]
34186656:	f003 0301 	and.w	r3, r3, #1
3418665a:	2b00      	cmp	r3, #0
3418665c:	d018      	beq.n	34186690 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
3418665e:	69fb      	ldr	r3, [r7, #28]
34186660:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186664:	f023 0201 	bic.w	r2, r3, #1
34186668:	69fb      	ldr	r3, [r7, #28]
3418666a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
3418666e:	69fb      	ldr	r3, [r7, #28]
34186670:	2201      	movs	r2, #1
34186672:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34186676:	687b      	ldr	r3, [r7, #4]
34186678:	689b      	ldr	r3, [r3, #8]
3418667a:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
3418667e:	687b      	ldr	r3, [r7, #4]
34186680:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34186682:	687b      	ldr	r3, [r7, #4]
34186684:	2204      	movs	r2, #4
34186686:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34186688:	2101      	movs	r1, #1
3418668a:	6878      	ldr	r0, [r7, #4]
3418668c:	f000 f98d 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
34186690:	697b      	ldr	r3, [r7, #20]
34186692:	f003 0302 	and.w	r3, r3, #2
34186696:	2b00      	cmp	r3, #0
34186698:	d01d      	beq.n	341866d6 <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
3418669a:	68fb      	ldr	r3, [r7, #12]
3418669c:	f003 0302 	and.w	r3, r3, #2
341866a0:	2b00      	cmp	r3, #0
341866a2:	d018      	beq.n	341866d6 <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
341866a4:	69fb      	ldr	r3, [r7, #28]
341866a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341866aa:	f023 0202 	bic.w	r2, r3, #2
341866ae:	69fb      	ldr	r3, [r7, #28]
341866b0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
341866b4:	69fb      	ldr	r3, [r7, #28]
341866b6:	2202      	movs	r2, #2
341866b8:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
341866bc:	687b      	ldr	r3, [r7, #4]
341866be:	689b      	ldr	r3, [r3, #8]
341866c0:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
341866c4:	687b      	ldr	r3, [r7, #4]
341866c6:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
341866c8:	687b      	ldr	r3, [r7, #4]
341866ca:	2204      	movs	r2, #4
341866cc:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
341866ce:	2101      	movs	r1, #1
341866d0:	6878      	ldr	r0, [r7, #4]
341866d2:	f000 f96a 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
341866d6:	697b      	ldr	r3, [r7, #20]
341866d8:	f003 0304 	and.w	r3, r3, #4
341866dc:	2b00      	cmp	r3, #0
341866de:	d01a      	beq.n	34186716 <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
341866e0:	68fb      	ldr	r3, [r7, #12]
341866e2:	f003 0304 	and.w	r3, r3, #4
341866e6:	2b00      	cmp	r3, #0
341866e8:	d015      	beq.n	34186716 <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
341866ea:	69fb      	ldr	r3, [r7, #28]
341866ec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341866f0:	f023 0204 	bic.w	r2, r3, #4
341866f4:	69fb      	ldr	r3, [r7, #28]
341866f6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
341866fa:	69fb      	ldr	r3, [r7, #28]
341866fc:	2204      	movs	r2, #4
341866fe:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34186702:	687b      	ldr	r3, [r7, #4]
34186704:	689b      	ldr	r3, [r3, #8]
34186706:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
3418670a:	687b      	ldr	r3, [r7, #4]
3418670c:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418670e:	2101      	movs	r1, #1
34186710:	6878      	ldr	r0, [r7, #4]
34186712:	f000 f94a 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34186716:	697b      	ldr	r3, [r7, #20]
34186718:	f003 0308 	and.w	r3, r3, #8
3418671c:	2b00      	cmp	r3, #0
3418671e:	d01a      	beq.n	34186756 <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34186720:	68fb      	ldr	r3, [r7, #12]
34186722:	f003 0308 	and.w	r3, r3, #8
34186726:	2b00      	cmp	r3, #0
34186728:	d015      	beq.n	34186756 <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
3418672a:	69fb      	ldr	r3, [r7, #28]
3418672c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186730:	f023 0208 	bic.w	r2, r3, #8
34186734:	69fb      	ldr	r3, [r7, #28]
34186736:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
3418673a:	69fb      	ldr	r3, [r7, #28]
3418673c:	2208      	movs	r2, #8
3418673e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34186742:	687b      	ldr	r3, [r7, #4]
34186744:	689b      	ldr	r3, [r3, #8]
34186746:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
3418674a:	687b      	ldr	r3, [r7, #4]
3418674c:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418674e:	2101      	movs	r1, #1
34186750:	6878      	ldr	r0, [r7, #4]
34186752:	f000 f92a 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34186756:	697b      	ldr	r3, [r7, #20]
34186758:	f003 0310 	and.w	r3, r3, #16
3418675c:	2b00      	cmp	r3, #0
3418675e:	d01a      	beq.n	34186796 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34186760:	68fb      	ldr	r3, [r7, #12]
34186762:	f003 0310 	and.w	r3, r3, #16
34186766:	2b00      	cmp	r3, #0
34186768:	d015      	beq.n	34186796 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
3418676a:	69fb      	ldr	r3, [r7, #28]
3418676c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186770:	f023 0210 	bic.w	r2, r3, #16
34186774:	69fb      	ldr	r3, [r7, #28]
34186776:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
3418677a:	69fb      	ldr	r3, [r7, #28]
3418677c:	2210      	movs	r2, #16
3418677e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34186782:	687b      	ldr	r3, [r7, #4]
34186784:	689b      	ldr	r3, [r3, #8]
34186786:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
3418678a:	687b      	ldr	r3, [r7, #4]
3418678c:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418678e:	2101      	movs	r1, #1
34186790:	6878      	ldr	r0, [r7, #4]
34186792:	f000 f90a 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
34186796:	697b      	ldr	r3, [r7, #20]
34186798:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418679c:	2b00      	cmp	r3, #0
3418679e:	d01e      	beq.n	341867de <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
341867a0:	68fb      	ldr	r3, [r7, #12]
341867a2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341867a6:	2b00      	cmp	r3, #0
341867a8:	d019      	beq.n	341867de <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
341867aa:	69fb      	ldr	r3, [r7, #28]
341867ac:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341867b0:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
341867b4:	69fb      	ldr	r3, [r7, #28]
341867b6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
341867ba:	69fb      	ldr	r3, [r7, #28]
341867bc:	f44f 7280 	mov.w	r2, #256	@ 0x100
341867c0:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
341867c4:	687b      	ldr	r3, [r7, #4]
341867c6:	689b      	ldr	r3, [r3, #8]
341867c8:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
341867cc:	687b      	ldr	r3, [r7, #4]
341867ce:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
341867d0:	687b      	ldr	r3, [r7, #4]
341867d2:	2204      	movs	r2, #4
341867d4:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
341867d6:	2102      	movs	r1, #2
341867d8:	6878      	ldr	r0, [r7, #4]
341867da:	f000 f8e6 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
341867de:	697b      	ldr	r3, [r7, #20]
341867e0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341867e4:	2b00      	cmp	r3, #0
341867e6:	d01e      	beq.n	34186826 <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
341867e8:	68fb      	ldr	r3, [r7, #12]
341867ea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341867ee:	2b00      	cmp	r3, #0
341867f0:	d019      	beq.n	34186826 <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
341867f2:	69fb      	ldr	r3, [r7, #28]
341867f4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341867f8:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
341867fc:	69fb      	ldr	r3, [r7, #28]
341867fe:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
34186802:	69fb      	ldr	r3, [r7, #28]
34186804:	f44f 7200 	mov.w	r2, #512	@ 0x200
34186808:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
3418680c:	687b      	ldr	r3, [r7, #4]
3418680e:	689b      	ldr	r3, [r3, #8]
34186810:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34186814:	687b      	ldr	r3, [r7, #4]
34186816:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34186818:	687b      	ldr	r3, [r7, #4]
3418681a:	2204      	movs	r2, #4
3418681c:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
3418681e:	2102      	movs	r1, #2
34186820:	6878      	ldr	r0, [r7, #4]
34186822:	f000 f8c2 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34186826:	697b      	ldr	r3, [r7, #20]
34186828:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418682c:	2b00      	cmp	r3, #0
3418682e:	d01b      	beq.n	34186868 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34186830:	68fb      	ldr	r3, [r7, #12]
34186832:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34186836:	2b00      	cmp	r3, #0
34186838:	d016      	beq.n	34186868 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
3418683a:	69fb      	ldr	r3, [r7, #28]
3418683c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186840:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34186844:	69fb      	ldr	r3, [r7, #28]
34186846:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
3418684a:	69fb      	ldr	r3, [r7, #28]
3418684c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34186850:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34186854:	687b      	ldr	r3, [r7, #4]
34186856:	689b      	ldr	r3, [r3, #8]
34186858:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
3418685c:	687b      	ldr	r3, [r7, #4]
3418685e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34186860:	2102      	movs	r1, #2
34186862:	6878      	ldr	r0, [r7, #4]
34186864:	f000 f8a1 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34186868:	697b      	ldr	r3, [r7, #20]
3418686a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418686e:	2b00      	cmp	r3, #0
34186870:	d01b      	beq.n	341868aa <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34186872:	68fb      	ldr	r3, [r7, #12]
34186874:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34186878:	2b00      	cmp	r3, #0
3418687a:	d016      	beq.n	341868aa <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
3418687c:	69fb      	ldr	r3, [r7, #28]
3418687e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186882:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34186886:	69fb      	ldr	r3, [r7, #28]
34186888:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
3418688c:	69fb      	ldr	r3, [r7, #28]
3418688e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34186892:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34186896:	687b      	ldr	r3, [r7, #4]
34186898:	689b      	ldr	r3, [r3, #8]
3418689a:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
3418689e:	687b      	ldr	r3, [r7, #4]
341868a0:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
341868a2:	2102      	movs	r1, #2
341868a4:	6878      	ldr	r0, [r7, #4]
341868a6:	f000 f880 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
341868aa:	697b      	ldr	r3, [r7, #20]
341868ac:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341868b0:	2b00      	cmp	r3, #0
341868b2:	d01b      	beq.n	341868ec <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
341868b4:	68fb      	ldr	r3, [r7, #12]
341868b6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341868ba:	2b00      	cmp	r3, #0
341868bc:	d016      	beq.n	341868ec <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
341868be:	69fb      	ldr	r3, [r7, #28]
341868c0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341868c4:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
341868c8:	69fb      	ldr	r3, [r7, #28]
341868ca:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
341868ce:	69fb      	ldr	r3, [r7, #28]
341868d0:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
341868d4:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
341868d8:	687b      	ldr	r3, [r7, #4]
341868da:	689b      	ldr	r3, [r3, #8]
341868dc:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
341868e0:	687b      	ldr	r3, [r7, #4]
341868e2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
341868e4:	2102      	movs	r1, #2
341868e6:	6878      	ldr	r0, [r7, #4]
341868e8:	f000 f85f 	bl	341869aa <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
341868ec:	69bb      	ldr	r3, [r7, #24]
341868ee:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
341868f2:	2b00      	cmp	r3, #0
341868f4:	d014      	beq.n	34186920 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
341868f6:	693b      	ldr	r3, [r7, #16]
341868f8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
341868fc:	2b00      	cmp	r3, #0
341868fe:	d00f      	beq.n	34186920 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34186900:	69fb      	ldr	r3, [r7, #28]
34186902:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186906:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
3418690a:	69fb      	ldr	r3, [r7, #28]
3418690c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34186910:	69fb      	ldr	r3, [r7, #28]
34186912:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34186916:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
3418691a:	6878      	ldr	r0, [r7, #4]
3418691c:	f000 f85a 	bl	341869d4 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34186920:	bf00      	nop
34186922:	3720      	adds	r7, #32
34186924:	46bd      	mov	sp, r7
34186926:	bd80      	pop	{r7, pc}

34186928 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186928:	b480      	push	{r7}
3418692a:	b083      	sub	sp, #12
3418692c:	af00      	add	r7, sp, #0
3418692e:	6078      	str	r0, [r7, #4]
34186930:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_FrameEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34186932:	bf00      	nop
34186934:	370c      	adds	r7, #12
34186936:	46bd      	mov	sp, r7
34186938:	f85d 7b04 	ldr.w	r7, [sp], #4
3418693c:	4770      	bx	lr

3418693e <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418693e:	b480      	push	{r7}
34186940:	b083      	sub	sp, #12
34186942:	af00      	add	r7, sp, #0
34186944:	6078      	str	r0, [r7, #4]
34186946:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_VsyncEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34186948:	bf00      	nop
3418694a:	370c      	adds	r7, #12
3418694c:	46bd      	mov	sp, r7
3418694e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186952:	4770      	bx	lr

34186954 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186954:	b480      	push	{r7}
34186956:	b083      	sub	sp, #12
34186958:	af00      	add	r7, sp, #0
3418695a:	6078      	str	r0, [r7, #4]
3418695c:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
3418695e:	bf00      	nop
34186960:	370c      	adds	r7, #12
34186962:	46bd      	mov	sp, r7
34186964:	f85d 7b04 	ldr.w	r7, [sp], #4
34186968:	4770      	bx	lr

3418696a <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418696a:	b480      	push	{r7}
3418696c:	b083      	sub	sp, #12
3418696e:	af00      	add	r7, sp, #0
34186970:	6078      	str	r0, [r7, #4]
34186972:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34186974:	bf00      	nop
34186976:	370c      	adds	r7, #12
34186978:	46bd      	mov	sp, r7
3418697a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418697e:	4770      	bx	lr

34186980 <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186980:	b480      	push	{r7}
34186982:	b083      	sub	sp, #12
34186984:	af00      	add	r7, sp, #0
34186986:	6078      	str	r0, [r7, #4]
34186988:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
3418698a:	bf00      	nop
3418698c:	370c      	adds	r7, #12
3418698e:	46bd      	mov	sp, r7
34186990:	f85d 7b04 	ldr.w	r7, [sp], #4
34186994:	4770      	bx	lr

34186996 <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34186996:	b480      	push	{r7}
34186998:	b083      	sub	sp, #12
3418699a:	af00      	add	r7, sp, #0
3418699c:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
3418699e:	bf00      	nop
341869a0:	370c      	adds	r7, #12
341869a2:	46bd      	mov	sp, r7
341869a4:	f85d 7b04 	ldr.w	r7, [sp], #4
341869a8:	4770      	bx	lr

341869aa <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
341869aa:	b480      	push	{r7}
341869ac:	b083      	sub	sp, #12
341869ae:	af00      	add	r7, sp, #0
341869b0:	6078      	str	r0, [r7, #4]
341869b2:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
341869b4:	bf00      	nop
341869b6:	370c      	adds	r7, #12
341869b8:	46bd      	mov	sp, r7
341869ba:	f85d 7b04 	ldr.w	r7, [sp], #4
341869be:	4770      	bx	lr

341869c0 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
341869c0:	b480      	push	{r7}
341869c2:	b083      	sub	sp, #12
341869c4:	af00      	add	r7, sp, #0
341869c6:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
341869c8:	bf00      	nop
341869ca:	370c      	adds	r7, #12
341869cc:	46bd      	mov	sp, r7
341869ce:	f85d 7b04 	ldr.w	r7, [sp], #4
341869d2:	4770      	bx	lr

341869d4 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
341869d4:	b480      	push	{r7}
341869d6:	b083      	sub	sp, #12
341869d8:	af00      	add	r7, sp, #0
341869da:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
341869dc:	bf00      	nop
341869de:	370c      	adds	r7, #12
341869e0:	46bd      	mov	sp, r7
341869e2:	f85d 7b04 	ldr.w	r7, [sp], #4
341869e6:	4770      	bx	lr

341869e8 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
341869e8:	b480      	push	{r7}
341869ea:	b083      	sub	sp, #12
341869ec:	af00      	add	r7, sp, #0
341869ee:	6078      	str	r0, [r7, #4]
341869f0:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
341869f2:	bf00      	nop
341869f4:	370c      	adds	r7, #12
341869f6:	46bd      	mov	sp, r7
341869f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341869fc:	4770      	bx	lr

341869fe <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
341869fe:	b480      	push	{r7}
34186a00:	b083      	sub	sp, #12
34186a02:	af00      	add	r7, sp, #0
34186a04:	6078      	str	r0, [r7, #4]
34186a06:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34186a08:	bf00      	nop
34186a0a:	370c      	adds	r7, #12
34186a0c:	46bd      	mov	sp, r7
34186a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186a12:	4770      	bx	lr

34186a14 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
34186a14:	b480      	push	{r7}
34186a16:	b083      	sub	sp, #12
34186a18:	af00      	add	r7, sp, #0
34186a1a:	6078      	str	r0, [r7, #4]
34186a1c:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
34186a1e:	bf00      	nop
34186a20:	370c      	adds	r7, #12
34186a22:	46bd      	mov	sp, r7
34186a24:	f85d 7b04 	ldr.w	r7, [sp], #4
34186a28:	4770      	bx	lr

34186a2a <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
34186a2a:	b480      	push	{r7}
34186a2c:	b083      	sub	sp, #12
34186a2e:	af00      	add	r7, sp, #0
34186a30:	6078      	str	r0, [r7, #4]
34186a32:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
34186a34:	bf00      	nop
34186a36:	370c      	adds	r7, #12
34186a38:	46bd      	mov	sp, r7
34186a3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34186a3e:	4770      	bx	lr

34186a40 <HAL_DCMIPP_PIPE_SetCropConfig>:
  *                     the configuration information for Crop.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetCropConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CropConfTypeDef *pCropConfig)
{
34186a40:	b480      	push	{r7}
34186a42:	b087      	sub	sp, #28
34186a44:	af00      	add	r7, sp, #0
34186a46:	60f8      	str	r0, [r7, #12]
34186a48:	60b9      	str	r1, [r7, #8]
34186a4a:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34186a4c:	68fb      	ldr	r3, [r7, #12]
34186a4e:	2b00      	cmp	r3, #0
34186a50:	d002      	beq.n	34186a58 <HAL_DCMIPP_PIPE_SetCropConfig+0x18>
34186a52:	687b      	ldr	r3, [r7, #4]
34186a54:	2b00      	cmp	r3, #0
34186a56:	d101      	bne.n	34186a5c <HAL_DCMIPP_PIPE_SetCropConfig+0x1c>
  {
    return HAL_ERROR;
34186a58:	2301      	movs	r3, #1
34186a5a:	e090      	b.n	34186b7e <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186a5c:	68fb      	ldr	r3, [r7, #12]
34186a5e:	791b      	ldrb	r3, [r3, #4]
34186a60:	b2db      	uxtb	r3, r3
34186a62:	2b02      	cmp	r3, #2
34186a64:	f040 8088 	bne.w	34186b78 <HAL_DCMIPP_PIPE_SetCropConfig+0x138>
  {

    if (Pipe == DCMIPP_PIPE0)
34186a68:	68bb      	ldr	r3, [r7, #8]
34186a6a:	2b00      	cmp	r3, #0
34186a6c:	d136      	bne.n	34186adc <HAL_DCMIPP_PIPE_SetCropConfig+0x9c>
    {
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34186a6e:	68fb      	ldr	r3, [r7, #12]
34186a70:	681b      	ldr	r3, [r3, #0]
34186a72:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34186a76:	617b      	str	r3, [r7, #20]

      /* Verify for parallel mode with jpeg format , no Line Crop enable  */
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34186a78:	697b      	ldr	r3, [r7, #20]
34186a7a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34186a7e:	2b00      	cmp	r3, #0
34186a80:	d006      	beq.n	34186a90 <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
34186a82:	697b      	ldr	r3, [r7, #20]
34186a84:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34186a88:	2b00      	cmp	r3, #0
34186a8a:	d101      	bne.n	34186a90 <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
      {
        return HAL_ERROR;
34186a8c:	2301      	movs	r3, #1
34186a8e:	e076      	b.n	34186b7e <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
      }
      else
      {
        /* Set Cropping horizontal and vertical start for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34186a90:	68fb      	ldr	r3, [r7, #12]
34186a92:	681b      	ldr	r3, [r3, #0]
34186a94:	f8d3 3504 	ldr.w	r3, [r3, #1284]	@ 0x504
34186a98:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186a9c:	687b      	ldr	r3, [r7, #4]
34186a9e:	685a      	ldr	r2, [r3, #4]
34186aa0:	687b      	ldr	r3, [r7, #4]
34186aa2:	681b      	ldr	r3, [r3, #0]
34186aa4:	041b      	lsls	r3, r3, #16
34186aa6:	431a      	orrs	r2, r3
34186aa8:	68fb      	ldr	r3, [r7, #12]
34186aaa:	681b      	ldr	r3, [r3, #0]
34186aac:	430a      	orrs	r2, r1
34186aae:	f8c3 2504 	str.w	r2, [r3, #1284]	@ 0x504
                   (pCropConfig->HStart << DCMIPP_P0SCSTR_HSTART_Pos) |
                   (pCropConfig->VStart << DCMIPP_P0SCSTR_VSTART_Pos));

        /* Set Cropping horizontal and vertical width for Pipe0 */
        /* Set crop Area (Inner or outer) for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34186ab2:	68fb      	ldr	r3, [r7, #12]
34186ab4:	681b      	ldr	r3, [r3, #0]
34186ab6:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34186aba:	4b34      	ldr	r3, [pc, #208]	@ (34186b8c <HAL_DCMIPP_PIPE_SetCropConfig+0x14c>)
34186abc:	4013      	ands	r3, r2
34186abe:	687a      	ldr	r2, [r7, #4]
34186ac0:	68d1      	ldr	r1, [r2, #12]
34186ac2:	687a      	ldr	r2, [r7, #4]
34186ac4:	6892      	ldr	r2, [r2, #8]
34186ac6:	0412      	lsls	r2, r2, #16
34186ac8:	4311      	orrs	r1, r2
34186aca:	687a      	ldr	r2, [r7, #4]
34186acc:	6912      	ldr	r2, [r2, #16]
34186ace:	4311      	orrs	r1, r2
34186ad0:	68fa      	ldr	r2, [r7, #12]
34186ad2:	6812      	ldr	r2, [r2, #0]
34186ad4:	430b      	orrs	r3, r1
34186ad6:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
34186ada:	e04f      	b.n	34186b7c <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                   (pCropConfig->HSize << DCMIPP_P0SCSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P0SCSZR_VSIZE_Pos) |
                   (pCropConfig->PipeArea));
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34186adc:	68bb      	ldr	r3, [r7, #8]
34186ade:	2b01      	cmp	r3, #1
34186ae0:	d122      	bne.n	34186b28 <HAL_DCMIPP_PIPE_SetCropConfig+0xe8>
    {
      /* Set Cropping horizontal and vertical start for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34186ae2:	68fb      	ldr	r3, [r7, #12]
34186ae4:	681b      	ldr	r3, [r3, #0]
34186ae6:	f8d3 3904 	ldr.w	r3, [r3, #2308]	@ 0x904
34186aea:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186aee:	687b      	ldr	r3, [r7, #4]
34186af0:	685a      	ldr	r2, [r3, #4]
34186af2:	687b      	ldr	r3, [r7, #4]
34186af4:	681b      	ldr	r3, [r3, #0]
34186af6:	041b      	lsls	r3, r3, #16
34186af8:	431a      	orrs	r2, r3
34186afa:	68fb      	ldr	r3, [r7, #12]
34186afc:	681b      	ldr	r3, [r3, #0]
34186afe:	430a      	orrs	r2, r1
34186b00:	f8c3 2904 	str.w	r2, [r3, #2308]	@ 0x904
                 (pCropConfig->HStart << DCMIPP_P1CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P1CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34186b04:	68fb      	ldr	r3, [r7, #12]
34186b06:	681b      	ldr	r3, [r3, #0]
34186b08:	f8d3 3908 	ldr.w	r3, [r3, #2312]	@ 0x908
34186b0c:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186b10:	687b      	ldr	r3, [r7, #4]
34186b12:	68da      	ldr	r2, [r3, #12]
34186b14:	687b      	ldr	r3, [r7, #4]
34186b16:	689b      	ldr	r3, [r3, #8]
34186b18:	041b      	lsls	r3, r3, #16
34186b1a:	431a      	orrs	r2, r3
34186b1c:	68fb      	ldr	r3, [r7, #12]
34186b1e:	681b      	ldr	r3, [r3, #0]
34186b20:	430a      	orrs	r2, r1
34186b22:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34186b26:	e029      	b.n	34186b7c <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P1CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P1CRSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
34186b28:	68bb      	ldr	r3, [r7, #8]
34186b2a:	2b02      	cmp	r3, #2
34186b2c:	d122      	bne.n	34186b74 <HAL_DCMIPP_PIPE_SetCropConfig+0x134>
    {
      /* Set Cropping horizontal and vertical start for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
34186b2e:	68fb      	ldr	r3, [r7, #12]
34186b30:	681b      	ldr	r3, [r3, #0]
34186b32:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
34186b36:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186b3a:	687b      	ldr	r3, [r7, #4]
34186b3c:	685a      	ldr	r2, [r3, #4]
34186b3e:	687b      	ldr	r3, [r7, #4]
34186b40:	681b      	ldr	r3, [r3, #0]
34186b42:	041b      	lsls	r3, r3, #16
34186b44:	431a      	orrs	r2, r3
34186b46:	68fb      	ldr	r3, [r7, #12]
34186b48:	681b      	ldr	r3, [r3, #0]
34186b4a:	430a      	orrs	r2, r1
34186b4c:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
                 (pCropConfig->HStart << DCMIPP_P2CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P2CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
34186b50:	68fb      	ldr	r3, [r7, #12]
34186b52:	681b      	ldr	r3, [r3, #0]
34186b54:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	@ 0xd08
34186b58:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186b5c:	687b      	ldr	r3, [r7, #4]
34186b5e:	68da      	ldr	r2, [r3, #12]
34186b60:	687b      	ldr	r3, [r7, #4]
34186b62:	689b      	ldr	r3, [r3, #8]
34186b64:	041b      	lsls	r3, r3, #16
34186b66:	431a      	orrs	r2, r3
34186b68:	68fb      	ldr	r3, [r7, #12]
34186b6a:	681b      	ldr	r3, [r3, #0]
34186b6c:	430a      	orrs	r2, r1
34186b6e:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34186b72:	e003      	b.n	34186b7c <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P2CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P2CRSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
34186b74:	2301      	movs	r3, #1
34186b76:	e002      	b.n	34186b7e <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
    }
  }
  else
  {
    return HAL_ERROR;
34186b78:	2301      	movs	r3, #1
34186b7a:	e000      	b.n	34186b7e <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  }

  return HAL_OK;
34186b7c:	2300      	movs	r3, #0
}
34186b7e:	4618      	mov	r0, r3
34186b80:	371c      	adds	r7, #28
34186b82:	46bd      	mov	sp, r7
34186b84:	f85d 7b04 	ldr.w	r7, [sp], #4
34186b88:	4770      	bx	lr
34186b8a:	bf00      	nop
34186b8c:	b000f000 	.word	0xb000f000

34186b90 <HAL_DCMIPP_PIPE_EnableCrop>:
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @note   Cropping cannot be enabled in parallel mode with JPEG Format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186b90:	b480      	push	{r7}
34186b92:	b085      	sub	sp, #20
34186b94:	af00      	add	r7, sp, #0
34186b96:	6078      	str	r0, [r7, #4]
34186b98:	6039      	str	r1, [r7, #0]
  uint32_t tmp;

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34186b9a:	687b      	ldr	r3, [r7, #4]
34186b9c:	2b00      	cmp	r3, #0
34186b9e:	d101      	bne.n	34186ba4 <HAL_DCMIPP_PIPE_EnableCrop+0x14>
  {
    return HAL_ERROR;
34186ba0:	2301      	movs	r3, #1
34186ba2:	e04d      	b.n	34186c40 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186ba4:	687b      	ldr	r3, [r7, #4]
34186ba6:	791b      	ldrb	r3, [r3, #4]
34186ba8:	b2db      	uxtb	r3, r3
34186baa:	2b02      	cmp	r3, #2
34186bac:	d145      	bne.n	34186c3a <HAL_DCMIPP_PIPE_EnableCrop+0xaa>
  {
    if (Pipe == DCMIPP_PIPE0)
34186bae:	683b      	ldr	r3, [r7, #0]
34186bb0:	2b00      	cmp	r3, #0
34186bb2:	d11b      	bne.n	34186bec <HAL_DCMIPP_PIPE_EnableCrop+0x5c>
    {
      /* This bit must be kept cleared if the input format is JPEG */
      /* Verify for parallel mode with jpeg format , no Line Crop enable  */

      tmp = READ_REG(hdcmipp->Instance->PRCR);
34186bb4:	687b      	ldr	r3, [r7, #4]
34186bb6:	681b      	ldr	r3, [r3, #0]
34186bb8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34186bbc:	60fb      	str	r3, [r7, #12]

      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34186bbe:	68fb      	ldr	r3, [r7, #12]
34186bc0:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34186bc4:	2b00      	cmp	r3, #0
34186bc6:	d006      	beq.n	34186bd6 <HAL_DCMIPP_PIPE_EnableCrop+0x46>
34186bc8:	68fb      	ldr	r3, [r7, #12]
34186bca:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34186bce:	2b00      	cmp	r3, #0
34186bd0:	d101      	bne.n	34186bd6 <HAL_DCMIPP_PIPE_EnableCrop+0x46>
      {
        return HAL_ERROR;
34186bd2:	2301      	movs	r3, #1
34186bd4:	e034      	b.n	34186c40 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
      else
      {
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34186bd6:	687b      	ldr	r3, [r7, #4]
34186bd8:	681b      	ldr	r3, [r3, #0]
34186bda:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34186bde:	687b      	ldr	r3, [r7, #4]
34186be0:	681b      	ldr	r3, [r3, #0]
34186be2:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34186be6:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
34186bea:	e028      	b.n	34186c3e <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34186bec:	683b      	ldr	r3, [r7, #0]
34186bee:	2b01      	cmp	r3, #1
34186bf0:	d113      	bne.n	34186c1a <HAL_DCMIPP_PIPE_EnableCrop+0x8a>
    {
      /* Verify Crop line is disabled */
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34186bf2:	687b      	ldr	r3, [r7, #4]
34186bf4:	681b      	ldr	r3, [r3, #0]
34186bf6:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
34186bfa:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34186bfe:	d00a      	beq.n	34186c16 <HAL_DCMIPP_PIPE_EnableCrop+0x86>
      {
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34186c00:	687b      	ldr	r3, [r7, #4]
34186c02:	681b      	ldr	r3, [r3, #0]
34186c04:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34186c08:	687b      	ldr	r3, [r7, #4]
34186c0a:	681b      	ldr	r3, [r3, #0]
34186c0c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34186c10:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34186c14:	e013      	b.n	34186c3e <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
      else
      {
        return HAL_ERROR;
34186c16:	2301      	movs	r3, #1
34186c18:	e012      	b.n	34186c40 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
    }
    else if (Pipe == DCMIPP_PIPE2)
34186c1a:	683b      	ldr	r3, [r7, #0]
34186c1c:	2b02      	cmp	r3, #2
34186c1e:	d10a      	bne.n	34186c36 <HAL_DCMIPP_PIPE_EnableCrop+0xa6>
    {
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34186c20:	687b      	ldr	r3, [r7, #4]
34186c22:	681b      	ldr	r3, [r3, #0]
34186c24:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
34186c28:	687b      	ldr	r3, [r7, #4]
34186c2a:	681b      	ldr	r3, [r3, #0]
34186c2c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34186c30:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34186c34:	e003      	b.n	34186c3e <HAL_DCMIPP_PIPE_EnableCrop+0xae>
    }
    else
    {
      return HAL_ERROR;
34186c36:	2301      	movs	r3, #1
34186c38:	e002      	b.n	34186c40 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
    }
  }
  else
  {
    return HAL_ERROR;
34186c3a:	2301      	movs	r3, #1
34186c3c:	e000      	b.n	34186c40 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  return HAL_OK;
34186c3e:	2300      	movs	r3, #0
}
34186c40:	4618      	mov	r0, r3
34186c42:	3714      	adds	r7, #20
34186c44:	46bd      	mov	sp, r7
34186c46:	f85d 7b04 	ldr.w	r7, [sp], #4
34186c4a:	4770      	bx	lr

34186c4c <HAL_DCMIPP_PIPE_DisableCrop>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186c4c:	b480      	push	{r7}
34186c4e:	b083      	sub	sp, #12
34186c50:	af00      	add	r7, sp, #0
34186c52:	6078      	str	r0, [r7, #4]
34186c54:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34186c56:	687b      	ldr	r3, [r7, #4]
34186c58:	2b00      	cmp	r3, #0
34186c5a:	d101      	bne.n	34186c60 <HAL_DCMIPP_PIPE_DisableCrop+0x14>
  {
    return HAL_ERROR;
34186c5c:	2301      	movs	r3, #1
34186c5e:	e02c      	b.n	34186cba <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  if (Pipe == DCMIPP_PIPE0)
34186c60:	683b      	ldr	r3, [r7, #0]
34186c62:	2b00      	cmp	r3, #0
34186c64:	d10a      	bne.n	34186c7c <HAL_DCMIPP_PIPE_DisableCrop+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34186c66:	687b      	ldr	r3, [r7, #4]
34186c68:	681b      	ldr	r3, [r3, #0]
34186c6a:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34186c6e:	687b      	ldr	r3, [r7, #4]
34186c70:	681b      	ldr	r3, [r3, #0]
34186c72:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34186c76:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
34186c7a:	e01d      	b.n	34186cb8 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE1)
34186c7c:	683b      	ldr	r3, [r7, #0]
34186c7e:	2b01      	cmp	r3, #1
34186c80:	d10a      	bne.n	34186c98 <HAL_DCMIPP_PIPE_DisableCrop+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34186c82:	687b      	ldr	r3, [r7, #4]
34186c84:	681b      	ldr	r3, [r3, #0]
34186c86:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34186c8a:	687b      	ldr	r3, [r7, #4]
34186c8c:	681b      	ldr	r3, [r3, #0]
34186c8e:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34186c92:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34186c96:	e00f      	b.n	34186cb8 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE2)
34186c98:	683b      	ldr	r3, [r7, #0]
34186c9a:	2b02      	cmp	r3, #2
34186c9c:	d10a      	bne.n	34186cb4 <HAL_DCMIPP_PIPE_DisableCrop+0x68>
  {
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34186c9e:	687b      	ldr	r3, [r7, #4]
34186ca0:	681b      	ldr	r3, [r3, #0]
34186ca2:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
34186ca6:	687b      	ldr	r3, [r7, #4]
34186ca8:	681b      	ldr	r3, [r3, #0]
34186caa:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34186cae:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34186cb2:	e001      	b.n	34186cb8 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else
  {
    return HAL_ERROR;
34186cb4:	2301      	movs	r3, #1
34186cb6:	e000      	b.n	34186cba <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  return HAL_OK;
34186cb8:	2300      	movs	r3, #0
}
34186cba:	4618      	mov	r0, r3
34186cbc:	370c      	adds	r7, #12
34186cbe:	46bd      	mov	sp, r7
34186cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
34186cc4:	4770      	bx	lr

34186cc6 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                         const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
34186cc6:	b480      	push	{r7}
34186cc8:	b085      	sub	sp, #20
34186cca:	af00      	add	r7, sp, #0
34186ccc:	60f8      	str	r0, [r7, #12]
34186cce:	60b9      	str	r1, [r7, #8]
34186cd0:	607a      	str	r2, [r7, #4]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34186cd2:	68fb      	ldr	r3, [r7, #12]
34186cd4:	2b00      	cmp	r3, #0
34186cd6:	d002      	beq.n	34186cde <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x18>
34186cd8:	687b      	ldr	r3, [r7, #4]
34186cda:	2b00      	cmp	r3, #0
34186cdc:	d101      	bne.n	34186ce2 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x1c>
  {
    return HAL_ERROR;
34186cde:	2301      	movs	r3, #1
34186ce0:	e01c      	b.n	34186d1c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
  }

  /* Set Decimation Type , Vertical and Horizontal Ratio */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186ce2:	68fb      	ldr	r3, [r7, #12]
34186ce4:	791b      	ldrb	r3, [r3, #4]
34186ce6:	b2db      	uxtb	r3, r3
34186ce8:	2b02      	cmp	r3, #2
34186cea:	d116      	bne.n	34186d1a <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x54>
  {
    if (Pipe == DCMIPP_PIPE1)
34186cec:	68bb      	ldr	r3, [r7, #8]
34186cee:	2b01      	cmp	r3, #1
34186cf0:	d111      	bne.n	34186d16 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x50>
    {
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34186cf2:	68fb      	ldr	r3, [r7, #12]
34186cf4:	681b      	ldr	r3, [r3, #0]
34186cf6:	f8d3 3830 	ldr.w	r3, [r3, #2096]	@ 0x830
34186cfa:	f023 011e 	bic.w	r1, r3, #30
34186cfe:	687b      	ldr	r3, [r7, #4]
34186d00:	681a      	ldr	r2, [r3, #0]
34186d02:	687b      	ldr	r3, [r7, #4]
34186d04:	685b      	ldr	r3, [r3, #4]
34186d06:	431a      	orrs	r2, r3
34186d08:	68fb      	ldr	r3, [r7, #12]
34186d0a:	681b      	ldr	r3, [r3, #0]
34186d0c:	430a      	orrs	r2, r1
34186d0e:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  {
    return HAL_ERROR;
  }


  return HAL_OK;
34186d12:	2300      	movs	r3, #0
34186d14:	e002      	b.n	34186d1c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
      return HAL_ERROR;
34186d16:	2301      	movs	r3, #1
34186d18:	e000      	b.n	34186d1c <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
    return HAL_ERROR;
34186d1a:	2301      	movs	r3, #1
}
34186d1c:	4618      	mov	r0, r3
34186d1e:	3714      	adds	r7, #20
34186d20:	46bd      	mov	sp, r7
34186d22:	f85d 7b04 	ldr.w	r7, [sp], #4
34186d26:	4770      	bx	lr

34186d28 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186d28:	b480      	push	{r7}
34186d2a:	b083      	sub	sp, #12
34186d2c:	af00      	add	r7, sp, #0
34186d2e:	6078      	str	r0, [r7, #4]
34186d30:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34186d32:	687b      	ldr	r3, [r7, #4]
34186d34:	2b00      	cmp	r3, #0
34186d36:	d101      	bne.n	34186d3c <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
  {
    return HAL_ERROR;
34186d38:	2301      	movs	r3, #1
34186d3a:	e00f      	b.n	34186d5c <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
  }

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
34186d3c:	683b      	ldr	r3, [r7, #0]
34186d3e:	2b01      	cmp	r3, #1
34186d40:	d10b      	bne.n	34186d5a <HAL_DCMIPP_PIPE_EnableISPDecimation+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34186d42:	687b      	ldr	r3, [r7, #4]
34186d44:	681b      	ldr	r3, [r3, #0]
34186d46:	f8d3 2830 	ldr.w	r2, [r3, #2096]	@ 0x830
34186d4a:	687b      	ldr	r3, [r7, #4]
34186d4c:	681b      	ldr	r3, [r3, #0]
34186d4e:	f042 0201 	orr.w	r2, r2, #1
34186d52:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34186d56:	2300      	movs	r3, #0
34186d58:	e000      	b.n	34186d5c <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
    return HAL_ERROR;
34186d5a:	2301      	movs	r3, #1
}
34186d5c:	4618      	mov	r0, r3
34186d5e:	370c      	adds	r7, #12
34186d60:	46bd      	mov	sp, r7
34186d62:	f85d 7b04 	ldr.w	r7, [sp], #4
34186d66:	4770      	bx	lr

34186d68 <HAL_DCMIPP_PIPE_SetDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                      const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
34186d68:	b480      	push	{r7}
34186d6a:	b085      	sub	sp, #20
34186d6c:	af00      	add	r7, sp, #0
34186d6e:	60f8      	str	r0, [r7, #12]
34186d70:	60b9      	str	r1, [r7, #8]
34186d72:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if (hdcmipp == NULL)
34186d74:	68fb      	ldr	r3, [r7, #12]
34186d76:	2b00      	cmp	r3, #0
34186d78:	d101      	bne.n	34186d7e <HAL_DCMIPP_PIPE_SetDecimationConfig+0x16>
  {
    return HAL_ERROR;
34186d7a:	2301      	movs	r3, #1
34186d7c:	e031      	b.n	34186de2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186d7e:	68fb      	ldr	r3, [r7, #12]
34186d80:	791b      	ldrb	r3, [r3, #4]
34186d82:	b2db      	uxtb	r3, r3
34186d84:	2b02      	cmp	r3, #2
34186d86:	d129      	bne.n	34186ddc <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
  {
    /* Set Decimation Type , Vertical and Horizontal Ratio */
    if (Pipe == DCMIPP_PIPE1)
34186d88:	68bb      	ldr	r3, [r7, #8]
34186d8a:	2b01      	cmp	r3, #1
34186d8c:	d110      	bne.n	34186db0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x48>
    {
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
34186d8e:	68fb      	ldr	r3, [r7, #12]
34186d90:	681b      	ldr	r3, [r3, #0]
34186d92:	f8d3 390c 	ldr.w	r3, [r3, #2316]	@ 0x90c
34186d96:	f023 011e 	bic.w	r1, r3, #30
34186d9a:	687b      	ldr	r3, [r7, #4]
34186d9c:	681a      	ldr	r2, [r3, #0]
34186d9e:	687b      	ldr	r3, [r7, #4]
34186da0:	685b      	ldr	r3, [r3, #4]
34186da2:	431a      	orrs	r2, r3
34186da4:	68fb      	ldr	r3, [r7, #12]
34186da6:	681b      	ldr	r3, [r3, #0]
34186da8:	430a      	orrs	r2, r1
34186daa:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34186dae:	e017      	b.n	34186de0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else if (Pipe == DCMIPP_PIPE2)
34186db0:	68bb      	ldr	r3, [r7, #8]
34186db2:	2b02      	cmp	r3, #2
34186db4:	d110      	bne.n	34186dd8 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
    {
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
34186db6:	68fb      	ldr	r3, [r7, #12]
34186db8:	681b      	ldr	r3, [r3, #0]
34186dba:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
34186dbe:	f023 011e 	bic.w	r1, r3, #30
34186dc2:	687b      	ldr	r3, [r7, #4]
34186dc4:	681a      	ldr	r2, [r3, #0]
34186dc6:	687b      	ldr	r3, [r7, #4]
34186dc8:	685b      	ldr	r3, [r3, #4]
34186dca:	431a      	orrs	r2, r3
34186dcc:	68fb      	ldr	r3, [r7, #12]
34186dce:	681b      	ldr	r3, [r3, #0]
34186dd0:	430a      	orrs	r2, r1
34186dd2:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34186dd6:	e003      	b.n	34186de0 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else
    {
      return HAL_ERROR;
34186dd8:	2301      	movs	r3, #1
34186dda:	e002      	b.n	34186de2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
    }
  }
  else
  {
    return HAL_ERROR;
34186ddc:	2301      	movs	r3, #1
34186dde:	e000      	b.n	34186de2 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  }

  return HAL_OK;
34186de0:	2300      	movs	r3, #0
}
34186de2:	4618      	mov	r0, r3
34186de4:	3714      	adds	r7, #20
34186de6:	46bd      	mov	sp, r7
34186de8:	f85d 7b04 	ldr.w	r7, [sp], #4
34186dec:	4770      	bx	lr

34186dee <HAL_DCMIPP_PIPE_EnableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186dee:	b480      	push	{r7}
34186df0:	b083      	sub	sp, #12
34186df2:	af00      	add	r7, sp, #0
34186df4:	6078      	str	r0, [r7, #4]
34186df6:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34186df8:	687b      	ldr	r3, [r7, #4]
34186dfa:	2b00      	cmp	r3, #0
34186dfc:	d101      	bne.n	34186e02 <HAL_DCMIPP_PIPE_EnableDecimation+0x14>
  {
    return HAL_ERROR;
34186dfe:	2301      	movs	r3, #1
34186e00:	e01e      	b.n	34186e40 <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
34186e02:	683b      	ldr	r3, [r7, #0]
34186e04:	2b01      	cmp	r3, #1
34186e06:	d10a      	bne.n	34186e1e <HAL_DCMIPP_PIPE_EnableDecimation+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34186e08:	687b      	ldr	r3, [r7, #4]
34186e0a:	681b      	ldr	r3, [r3, #0]
34186e0c:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
34186e10:	687b      	ldr	r3, [r7, #4]
34186e12:	681b      	ldr	r3, [r3, #0]
34186e14:	f042 0201 	orr.w	r2, r2, #1
34186e18:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34186e1c:	e00f      	b.n	34186e3e <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34186e1e:	683b      	ldr	r3, [r7, #0]
34186e20:	2b02      	cmp	r3, #2
34186e22:	d10a      	bne.n	34186e3a <HAL_DCMIPP_PIPE_EnableDecimation+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34186e24:	687b      	ldr	r3, [r7, #4]
34186e26:	681b      	ldr	r3, [r3, #0]
34186e28:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
34186e2c:	687b      	ldr	r3, [r7, #4]
34186e2e:	681b      	ldr	r3, [r3, #0]
34186e30:	f042 0201 	orr.w	r2, r2, #1
34186e34:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34186e38:	e001      	b.n	34186e3e <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
34186e3a:	2301      	movs	r3, #1
34186e3c:	e000      	b.n	34186e40 <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  return HAL_OK;
34186e3e:	2300      	movs	r3, #0
}
34186e40:	4618      	mov	r0, r3
34186e42:	370c      	adds	r7, #12
34186e44:	46bd      	mov	sp, r7
34186e46:	f85d 7b04 	ldr.w	r7, [sp], #4
34186e4a:	4770      	bx	lr

34186e4c <HAL_DCMIPP_PIPE_DisableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186e4c:	b480      	push	{r7}
34186e4e:	b083      	sub	sp, #12
34186e50:	af00      	add	r7, sp, #0
34186e52:	6078      	str	r0, [r7, #4]
34186e54:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34186e56:	687b      	ldr	r3, [r7, #4]
34186e58:	2b00      	cmp	r3, #0
34186e5a:	d101      	bne.n	34186e60 <HAL_DCMIPP_PIPE_DisableDecimation+0x14>
  {
    return HAL_ERROR;
34186e5c:	2301      	movs	r3, #1
34186e5e:	e01e      	b.n	34186e9e <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
34186e60:	683b      	ldr	r3, [r7, #0]
34186e62:	2b01      	cmp	r3, #1
34186e64:	d10a      	bne.n	34186e7c <HAL_DCMIPP_PIPE_DisableDecimation+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34186e66:	687b      	ldr	r3, [r7, #4]
34186e68:	681b      	ldr	r3, [r3, #0]
34186e6a:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
34186e6e:	687b      	ldr	r3, [r7, #4]
34186e70:	681b      	ldr	r3, [r3, #0]
34186e72:	f022 0201 	bic.w	r2, r2, #1
34186e76:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34186e7a:	e00f      	b.n	34186e9c <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34186e7c:	683b      	ldr	r3, [r7, #0]
34186e7e:	2b02      	cmp	r3, #2
34186e80:	d10a      	bne.n	34186e98 <HAL_DCMIPP_PIPE_DisableDecimation+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34186e82:	687b      	ldr	r3, [r7, #4]
34186e84:	681b      	ldr	r3, [r3, #0]
34186e86:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
34186e8a:	687b      	ldr	r3, [r7, #4]
34186e8c:	681b      	ldr	r3, [r3, #0]
34186e8e:	f022 0201 	bic.w	r2, r2, #1
34186e92:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34186e96:	e001      	b.n	34186e9c <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
34186e98:	2301      	movs	r3, #1
34186e9a:	e000      	b.n	34186e9e <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  return HAL_OK;
34186e9c:	2300      	movs	r3, #0
}
34186e9e:	4618      	mov	r0, r3
34186ea0:	370c      	adds	r7, #12
34186ea2:	46bd      	mov	sp, r7
34186ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
34186ea8:	4770      	bx	lr

34186eaa <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
  * @param  pDownsizeConfig pointer to the DCMIPP_DownsizeTypeDef structure that contains Downsize information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDownsizeConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                    const DCMIPP_DownsizeTypeDef *pDownsizeConfig)
{
34186eaa:	b480      	push	{r7}
34186eac:	b085      	sub	sp, #20
34186eae:	af00      	add	r7, sp, #0
34186eb0:	60f8      	str	r0, [r7, #12]
34186eb2:	60b9      	str	r1, [r7, #8]
34186eb4:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
34186eb6:	68fb      	ldr	r3, [r7, #12]
34186eb8:	2b00      	cmp	r3, #0
34186eba:	d002      	beq.n	34186ec2 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x18>
34186ebc:	687b      	ldr	r3, [r7, #4]
34186ebe:	2b00      	cmp	r3, #0
34186ec0:	d101      	bne.n	34186ec6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x1c>
  {
    return HAL_ERROR;
34186ec2:	2301      	movs	r3, #1
34186ec4:	e069      	b.n	34186f9a <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186ec6:	68fb      	ldr	r3, [r7, #12]
34186ec8:	791b      	ldrb	r3, [r3, #4]
34186eca:	b2db      	uxtb	r3, r3
34186ecc:	2b02      	cmp	r3, #2
34186ece:	d161      	bne.n	34186f94 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xea>
  {
    if (Pipe == DCMIPP_PIPE1)
34186ed0:	68bb      	ldr	r3, [r7, #8]
34186ed2:	2b01      	cmp	r3, #1
34186ed4:	d12c      	bne.n	34186f30 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x86>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
34186ed6:	68fb      	ldr	r3, [r7, #12]
34186ed8:	681b      	ldr	r3, [r3, #0]
34186eda:	f8d3 3910 	ldr.w	r3, [r3, #2320]	@ 0x910
34186ede:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
34186ee2:	687b      	ldr	r3, [r7, #4]
34186ee4:	695a      	ldr	r2, [r3, #20]
34186ee6:	687b      	ldr	r3, [r7, #4]
34186ee8:	691b      	ldr	r3, [r3, #16]
34186eea:	041b      	lsls	r3, r3, #16
34186eec:	431a      	orrs	r2, r3
34186eee:	68fb      	ldr	r3, [r7, #12]
34186ef0:	681b      	ldr	r3, [r3, #0]
34186ef2:	430a      	orrs	r2, r1
34186ef4:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
                 ((pDownsizeConfig->HDivFactor << DCMIPP_P1DSCR_HDIV_Pos) | \
                  (pDownsizeConfig->VDivFactor << DCMIPP_P1DSCR_VDIV_Pos)));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
34186ef8:	687b      	ldr	r3, [r7, #4]
34186efa:	68d9      	ldr	r1, [r3, #12]
34186efc:	687b      	ldr	r3, [r7, #4]
34186efe:	689b      	ldr	r3, [r3, #8]
34186f00:	041a      	lsls	r2, r3, #16
34186f02:	68fb      	ldr	r3, [r7, #12]
34186f04:	681b      	ldr	r3, [r3, #0]
34186f06:	430a      	orrs	r2, r1
34186f08:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
                (pDownsizeConfig->VRatio << DCMIPP_P1DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
34186f0c:	68fb      	ldr	r3, [r7, #12]
34186f0e:	681b      	ldr	r3, [r3, #0]
34186f10:	f8d3 3918 	ldr.w	r3, [r3, #2328]	@ 0x918
34186f14:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186f18:	687b      	ldr	r3, [r7, #4]
34186f1a:	685a      	ldr	r2, [r3, #4]
34186f1c:	687b      	ldr	r3, [r7, #4]
34186f1e:	681b      	ldr	r3, [r3, #0]
34186f20:	041b      	lsls	r3, r3, #16
34186f22:	431a      	orrs	r2, r3
34186f24:	68fb      	ldr	r3, [r7, #12]
34186f26:	681b      	ldr	r3, [r3, #0]
34186f28:	430a      	orrs	r2, r1
34186f2a:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
34186f2e:	e033      	b.n	34186f98 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P1DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P1DSSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
34186f30:	68bb      	ldr	r3, [r7, #8]
34186f32:	2b02      	cmp	r3, #2
34186f34:	d12c      	bne.n	34186f90 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe6>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
34186f36:	68fb      	ldr	r3, [r7, #12]
34186f38:	681b      	ldr	r3, [r3, #0]
34186f3a:	f8d3 3d10 	ldr.w	r3, [r3, #3344]	@ 0xd10
34186f3e:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
34186f42:	687b      	ldr	r3, [r7, #4]
34186f44:	695a      	ldr	r2, [r3, #20]
34186f46:	687b      	ldr	r3, [r7, #4]
34186f48:	691b      	ldr	r3, [r3, #16]
34186f4a:	041b      	lsls	r3, r3, #16
34186f4c:	431a      	orrs	r2, r3
34186f4e:	68fb      	ldr	r3, [r7, #12]
34186f50:	681b      	ldr	r3, [r3, #0]
34186f52:	430a      	orrs	r2, r1
34186f54:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
                 (pDownsizeConfig->HDivFactor << DCMIPP_P2DSCR_HDIV_Pos) | \
                 (pDownsizeConfig->VDivFactor << DCMIPP_P2DSCR_VDIV_Pos));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
34186f58:	687b      	ldr	r3, [r7, #4]
34186f5a:	68d9      	ldr	r1, [r3, #12]
34186f5c:	687b      	ldr	r3, [r7, #4]
34186f5e:	689b      	ldr	r3, [r3, #8]
34186f60:	041a      	lsls	r2, r3, #16
34186f62:	68fb      	ldr	r3, [r7, #12]
34186f64:	681b      	ldr	r3, [r3, #0]
34186f66:	430a      	orrs	r2, r1
34186f68:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
                (pDownsizeConfig->VRatio << DCMIPP_P2DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
34186f6c:	68fb      	ldr	r3, [r7, #12]
34186f6e:	681b      	ldr	r3, [r3, #0]
34186f70:	f8d3 3d18 	ldr.w	r3, [r3, #3352]	@ 0xd18
34186f74:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34186f78:	687b      	ldr	r3, [r7, #4]
34186f7a:	685a      	ldr	r2, [r3, #4]
34186f7c:	687b      	ldr	r3, [r7, #4]
34186f7e:	681b      	ldr	r3, [r3, #0]
34186f80:	041b      	lsls	r3, r3, #16
34186f82:	431a      	orrs	r2, r3
34186f84:	68fb      	ldr	r3, [r7, #12]
34186f86:	681b      	ldr	r3, [r3, #0]
34186f88:	430a      	orrs	r2, r1
34186f8a:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
34186f8e:	e003      	b.n	34186f98 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P2DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P2DSSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
34186f90:	2301      	movs	r3, #1
34186f92:	e002      	b.n	34186f9a <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
    }
  }
  else
  {
    return HAL_ERROR;
34186f94:	2301      	movs	r3, #1
34186f96:	e000      	b.n	34186f9a <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  }

  return HAL_OK;
34186f98:	2300      	movs	r3, #0
}
34186f9a:	4618      	mov	r0, r3
34186f9c:	3714      	adds	r7, #20
34186f9e:	46bd      	mov	sp, r7
34186fa0:	f85d 7b04 	ldr.w	r7, [sp], #4
34186fa4:	4770      	bx	lr

34186fa6 <HAL_DCMIPP_PIPE_EnableDownsize>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDownsize(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34186fa6:	b480      	push	{r7}
34186fa8:	b083      	sub	sp, #12
34186faa:	af00      	add	r7, sp, #0
34186fac:	6078      	str	r0, [r7, #4]
34186fae:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34186fb0:	687b      	ldr	r3, [r7, #4]
34186fb2:	2b00      	cmp	r3, #0
34186fb4:	d101      	bne.n	34186fba <HAL_DCMIPP_PIPE_EnableDownsize+0x14>
  {
    return HAL_ERROR;
34186fb6:	2301      	movs	r3, #1
34186fb8:	e01e      	b.n	34186ff8 <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34186fba:	683b      	ldr	r3, [r7, #0]
34186fbc:	2b01      	cmp	r3, #1
34186fbe:	d10a      	bne.n	34186fd6 <HAL_DCMIPP_PIPE_EnableDownsize+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
34186fc0:	687b      	ldr	r3, [r7, #4]
34186fc2:	681b      	ldr	r3, [r3, #0]
34186fc4:	f8d3 2910 	ldr.w	r2, [r3, #2320]	@ 0x910
34186fc8:	687b      	ldr	r3, [r7, #4]
34186fca:	681b      	ldr	r3, [r3, #0]
34186fcc:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34186fd0:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
34186fd4:	e00f      	b.n	34186ff6 <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34186fd6:	683b      	ldr	r3, [r7, #0]
34186fd8:	2b02      	cmp	r3, #2
34186fda:	d10a      	bne.n	34186ff2 <HAL_DCMIPP_PIPE_EnableDownsize+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
34186fdc:	687b      	ldr	r3, [r7, #4]
34186fde:	681b      	ldr	r3, [r3, #0]
34186fe0:	f8d3 2d10 	ldr.w	r2, [r3, #3344]	@ 0xd10
34186fe4:	687b      	ldr	r3, [r7, #4]
34186fe6:	681b      	ldr	r3, [r3, #0]
34186fe8:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34186fec:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
34186ff0:	e001      	b.n	34186ff6 <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else
  {
    return HAL_ERROR;
34186ff2:	2301      	movs	r3, #1
34186ff4:	e000      	b.n	34186ff8 <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  return HAL_OK;
34186ff6:	2300      	movs	r3, #0
}
34186ff8:	4618      	mov	r0, r3
34186ffa:	370c      	adds	r7, #12
34186ffc:	46bd      	mov	sp, r7
34186ffe:	f85d 7b04 	ldr.w	r7, [sp], #4
34187002:	4770      	bx	lr

34187004 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187004:	b480      	push	{r7}
34187006:	b083      	sub	sp, #12
34187008:	af00      	add	r7, sp, #0
3418700a:	6078      	str	r0, [r7, #4]
3418700c:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
3418700e:	687b      	ldr	r3, [r7, #4]
34187010:	2b00      	cmp	r3, #0
34187012:	d101      	bne.n	34187018 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x14>
  {
    return HAL_ERROR;
34187014:	2301      	movs	r3, #1
34187016:	e01e      	b.n	34187056 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187018:	683b      	ldr	r3, [r7, #0]
3418701a:	2b01      	cmp	r3, #1
3418701c:	d10a      	bne.n	34187034 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
3418701e:	687b      	ldr	r3, [r7, #4]
34187020:	681b      	ldr	r3, [r3, #0]
34187022:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
34187026:	687b      	ldr	r3, [r7, #4]
34187028:	681b      	ldr	r3, [r3, #0]
3418702a:	f042 0201 	orr.w	r2, r2, #1
3418702e:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
34187032:	e00f      	b.n	34187054 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34187034:	683b      	ldr	r3, [r7, #0]
34187036:	2b02      	cmp	r3, #2
34187038:	d10a      	bne.n	34187050 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
3418703a:	687b      	ldr	r3, [r7, #4]
3418703c:	681b      	ldr	r3, [r3, #0]
3418703e:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
34187042:	687b      	ldr	r3, [r7, #4]
34187044:	681b      	ldr	r3, [r3, #0]
34187046:	f042 0201 	orr.w	r2, r2, #1
3418704a:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
3418704e:	e001      	b.n	34187054 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
34187050:	2301      	movs	r3, #1
34187052:	e000      	b.n	34187056 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  return HAL_OK;
34187054:	2300      	movs	r3, #0
}
34187056:	4618      	mov	r0, r3
34187058:	370c      	adds	r7, #12
3418705a:	46bd      	mov	sp, r7
3418705c:	f85d 7b04 	ldr.w	r7, [sp], #4
34187060:	4770      	bx	lr

34187062 <HAL_DCMIPP_PIPE_DisableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187062:	b480      	push	{r7}
34187064:	b083      	sub	sp, #12
34187066:	af00      	add	r7, sp, #0
34187068:	6078      	str	r0, [r7, #4]
3418706a:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
3418706c:	687b      	ldr	r3, [r7, #4]
3418706e:	2b00      	cmp	r3, #0
34187070:	d101      	bne.n	34187076 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x14>
  {
    return HAL_ERROR;
34187072:	2301      	movs	r3, #1
34187074:	e01e      	b.n	341870b4 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187076:	683b      	ldr	r3, [r7, #0]
34187078:	2b01      	cmp	r3, #1
3418707a:	d10a      	bne.n	34187092 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
3418707c:	687b      	ldr	r3, [r7, #4]
3418707e:	681b      	ldr	r3, [r3, #0]
34187080:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
34187084:	687b      	ldr	r3, [r7, #4]
34187086:	681b      	ldr	r3, [r3, #0]
34187088:	f022 0201 	bic.w	r2, r2, #1
3418708c:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
34187090:	e00f      	b.n	341870b2 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34187092:	683b      	ldr	r3, [r7, #0]
34187094:	2b02      	cmp	r3, #2
34187096:	d10a      	bne.n	341870ae <HAL_DCMIPP_PIPE_DisableGammaConversion+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34187098:	687b      	ldr	r3, [r7, #4]
3418709a:	681b      	ldr	r3, [r3, #0]
3418709c:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
341870a0:	687b      	ldr	r3, [r7, #4]
341870a2:	681b      	ldr	r3, [r3, #0]
341870a4:	f022 0201 	bic.w	r2, r2, #1
341870a8:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
341870ac:	e001      	b.n	341870b2 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
341870ae:	2301      	movs	r3, #1
341870b0:	e000      	b.n	341870b4 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  return HAL_OK;
341870b2:	2300      	movs	r3, #0
}
341870b4:	4618      	mov	r0, r3
341870b6:	370c      	adds	r7, #12
341870b8:	46bd      	mov	sp, r7
341870ba:	f85d 7b04 	ldr.w	r7, [sp], #4
341870be:	4770      	bx	lr

341870c0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledGammaConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341870c0:	b480      	push	{r7}
341870c2:	b083      	sub	sp, #12
341870c4:	af00      	add	r7, sp, #0
341870c6:	6078      	str	r0, [r7, #4]
341870c8:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341870ca:	683b      	ldr	r3, [r7, #0]
341870cc:	2b01      	cmp	r3, #1
341870ce:	d10b      	bne.n	341870e8 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
341870d0:	687b      	ldr	r3, [r7, #4]
341870d2:	681b      	ldr	r3, [r3, #0]
341870d4:	f8d3 3970 	ldr.w	r3, [r3, #2416]	@ 0x970
341870d8:	f003 0301 	and.w	r3, r3, #1
341870dc:	2b01      	cmp	r3, #1
341870de:	d101      	bne.n	341870e4 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x24>
341870e0:	2301      	movs	r3, #1
341870e2:	e011      	b.n	34187108 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
341870e4:	2300      	movs	r3, #0
341870e6:	e00f      	b.n	34187108 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else if (Pipe == DCMIPP_PIPE2)
341870e8:	683b      	ldr	r3, [r7, #0]
341870ea:	2b02      	cmp	r3, #2
341870ec:	d10b      	bne.n	34187106 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x46>
  {
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
341870ee:	687b      	ldr	r3, [r7, #4]
341870f0:	681b      	ldr	r3, [r3, #0]
341870f2:	f8d3 3d70 	ldr.w	r3, [r3, #3440]	@ 0xd70
341870f6:	f003 0301 	and.w	r3, r3, #1
341870fa:	2b01      	cmp	r3, #1
341870fc:	d101      	bne.n	34187102 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
341870fe:	2301      	movs	r3, #1
34187100:	e002      	b.n	34187108 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
34187102:	2300      	movs	r3, #0
34187104:	e000      	b.n	34187108 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else
  {
    /* State Disabled */
    return 0;
34187106:	2300      	movs	r3, #0
  }
}
34187108:	4618      	mov	r0, r3
3418710a:	370c      	adds	r7, #12
3418710c:	46bd      	mov	sp, r7
3418710e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187112:	4770      	bx	lr

34187114 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
  *         information.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_RawBayer2RGBConfTypeDef *pRawBayer2RGBConfig)
{
34187114:	b480      	push	{r7}
34187116:	b087      	sub	sp, #28
34187118:	af00      	add	r7, sp, #0
3418711a:	60f8      	str	r0, [r7, #12]
3418711c:	60b9      	str	r1, [r7, #8]
3418711e:	607a      	str	r2, [r7, #4]
  uint32_t p1dmcr_reg;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
34187120:	68fb      	ldr	r3, [r7, #12]
34187122:	2b00      	cmp	r3, #0
34187124:	d002      	beq.n	3418712c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x18>
34187126:	687b      	ldr	r3, [r7, #4]
34187128:	2b00      	cmp	r3, #0
3418712a:	d101      	bne.n	34187130 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x1c>
  {
    return HAL_ERROR;
3418712c:	2301      	movs	r3, #1
3418712e:	e024      	b.n	3418717a <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));

  if (Pipe == DCMIPP_PIPE1)
34187130:	68bb      	ldr	r3, [r7, #8]
34187132:	2b01      	cmp	r3, #1
34187134:	d120      	bne.n	34187178 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x64>
  {

    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34187136:	687b      	ldr	r3, [r7, #4]
34187138:	689a      	ldr	r2, [r3, #8]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
3418713a:	687b      	ldr	r3, [r7, #4]
3418713c:	68db      	ldr	r3, [r3, #12]
3418713e:	041b      	lsls	r3, r3, #16
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34187140:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34187142:	687b      	ldr	r3, [r7, #4]
34187144:	691b      	ldr	r3, [r3, #16]
34187146:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34187148:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
3418714a:	687b      	ldr	r3, [r7, #4]
3418714c:	681b      	ldr	r3, [r3, #0]
3418714e:	051b      	lsls	r3, r3, #20
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34187150:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
34187152:	687b      	ldr	r3, [r7, #4]
34187154:	685b      	ldr	r3, [r3, #4]
34187156:	061b      	lsls	r3, r3, #24
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34187158:	4313      	orrs	r3, r2
3418715a:	617b      	str	r3, [r7, #20]


    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
3418715c:	68fb      	ldr	r3, [r7, #12]
3418715e:	681b      	ldr	r3, [r3, #0]
34187160:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
34187164:	4b08      	ldr	r3, [pc, #32]	@ (34187188 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x74>)
34187166:	4013      	ands	r3, r2
34187168:	68fa      	ldr	r2, [r7, #12]
3418716a:	6812      	ldr	r2, [r2, #0]
3418716c:	6979      	ldr	r1, [r7, #20]
3418716e:	430b      	orrs	r3, r1
34187170:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187174:	2300      	movs	r3, #0
34187176:	e000      	b.n	3418717a <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
    return HAL_ERROR;
34187178:	2301      	movs	r3, #1
}
3418717a:	4618      	mov	r0, r3
3418717c:	371c      	adds	r7, #28
3418717e:	46bd      	mov	sp, r7
34187180:	f85d 7b04 	ldr.w	r7, [sp], #4
34187184:	4770      	bx	lr
34187186:	bf00      	nop
34187188:	8888fff9 	.word	0x8888fff9

3418718c <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418718c:	b480      	push	{r7}
3418718e:	b083      	sub	sp, #12
34187190:	af00      	add	r7, sp, #0
34187192:	6078      	str	r0, [r7, #4]
34187194:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34187196:	687b      	ldr	r3, [r7, #4]
34187198:	2b00      	cmp	r3, #0
3418719a:	d101      	bne.n	341871a0 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
3418719c:	2301      	movs	r3, #1
3418719e:	e00f      	b.n	341871c0 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341871a0:	683b      	ldr	r3, [r7, #0]
341871a2:	2b01      	cmp	r3, #1
341871a4:	d10b      	bne.n	341871be <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
341871a6:	687b      	ldr	r3, [r7, #4]
341871a8:	681b      	ldr	r3, [r3, #0]
341871aa:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
341871ae:	687b      	ldr	r3, [r7, #4]
341871b0:	681b      	ldr	r3, [r3, #0]
341871b2:	f042 0201 	orr.w	r2, r2, #1
341871b6:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341871ba:	2300      	movs	r3, #0
341871bc:	e000      	b.n	341871c0 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
341871be:	2301      	movs	r3, #1
}
341871c0:	4618      	mov	r0, r3
341871c2:	370c      	adds	r7, #12
341871c4:	46bd      	mov	sp, r7
341871c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341871ca:	4770      	bx	lr

341871cc <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341871cc:	b480      	push	{r7}
341871ce:	b083      	sub	sp, #12
341871d0:	af00      	add	r7, sp, #0
341871d2:	6078      	str	r0, [r7, #4]
341871d4:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341871d6:	687b      	ldr	r3, [r7, #4]
341871d8:	2b00      	cmp	r3, #0
341871da:	d101      	bne.n	341871e0 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
341871dc:	2301      	movs	r3, #1
341871de:	e00f      	b.n	34187200 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341871e0:	683b      	ldr	r3, [r7, #0]
341871e2:	2b01      	cmp	r3, #1
341871e4:	d10b      	bne.n	341871fe <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
341871e6:	687b      	ldr	r3, [r7, #4]
341871e8:	681b      	ldr	r3, [r3, #0]
341871ea:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
341871ee:	687b      	ldr	r3, [r7, #4]
341871f0:	681b      	ldr	r3, [r3, #0]
341871f2:	f022 0201 	bic.w	r2, r2, #1
341871f6:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341871fa:	2300      	movs	r3, #0
341871fc:	e000      	b.n	34187200 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
341871fe:	2301      	movs	r3, #1
}
34187200:	4618      	mov	r0, r3
34187202:	370c      	adds	r7, #12
34187204:	46bd      	mov	sp, r7
34187206:	f85d 7b04 	ldr.w	r7, [sp], #4
3418720a:	4770      	bx	lr

3418720c <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
  * @param  NbLastLines  number of valid image line to keep after the skipped first lines
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t NbFirstLines, uint32_t NbLastLines)
{
3418720c:	b480      	push	{r7}
3418720e:	b087      	sub	sp, #28
34187210:	af00      	add	r7, sp, #0
34187212:	60f8      	str	r0, [r7, #12]
34187214:	60b9      	str	r1, [r7, #8]
34187216:	607a      	str	r2, [r7, #4]
34187218:	603b      	str	r3, [r7, #0]
  uint32_t p1srcr_reg;

  /* Check handles validity */
  if (hdcmipp == NULL)
3418721a:	68fb      	ldr	r3, [r7, #12]
3418721c:	2b00      	cmp	r3, #0
3418721e:	d101      	bne.n	34187224 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x18>
  {
    return HAL_ERROR;
34187220:	2301      	movs	r3, #1
34187222:	e018      	b.n	34187256 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));

  if (Pipe == DCMIPP_PIPE1)
34187224:	68bb      	ldr	r3, [r7, #8]
34187226:	2b01      	cmp	r3, #1
34187228:	d114      	bne.n	34187254 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x48>
  {
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
3418722a:	687b      	ldr	r3, [r7, #4]
3418722c:	031b      	lsls	r3, r3, #12
3418722e:	683a      	ldr	r2, [r7, #0]
34187230:	4313      	orrs	r3, r2
34187232:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34187234:	68fb      	ldr	r3, [r7, #12]
34187236:	681b      	ldr	r3, [r3, #0]
34187238:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
3418723c:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34187240:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34187244:	68fa      	ldr	r2, [r7, #12]
34187246:	6812      	ldr	r2, [r2, #0]
34187248:	6979      	ldr	r1, [r7, #20]
3418724a:	430b      	orrs	r3, r1
3418724c:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187250:	2300      	movs	r3, #0
34187252:	e000      	b.n	34187256 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
    return HAL_ERROR;
34187254:	2301      	movs	r3, #1
}
34187256:	4618      	mov	r0, r3
34187258:	371c      	adds	r7, #28
3418725a:	46bd      	mov	sp, r7
3418725c:	f85d 7b04 	ldr.w	r7, [sp], #4
34187260:	4770      	bx	lr

34187262 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187262:	b480      	push	{r7}
34187264:	b083      	sub	sp, #12
34187266:	af00      	add	r7, sp, #0
34187268:	6078      	str	r0, [r7, #4]
3418726a:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
3418726c:	687b      	ldr	r3, [r7, #4]
3418726e:	2b00      	cmp	r3, #0
34187270:	d101      	bne.n	34187276 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
34187272:	2301      	movs	r3, #1
34187274:	e00f      	b.n	34187296 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
34187276:	683b      	ldr	r3, [r7, #0]
34187278:	2b01      	cmp	r3, #1
3418727a:	d10b      	bne.n	34187294 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
3418727c:	687b      	ldr	r3, [r7, #4]
3418727e:	681b      	ldr	r3, [r3, #0]
34187280:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34187284:	687b      	ldr	r3, [r7, #4]
34187286:	681b      	ldr	r3, [r3, #0]
34187288:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3418728c:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187290:	2300      	movs	r3, #0
34187292:	e000      	b.n	34187296 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
    return HAL_ERROR;
34187294:	2301      	movs	r3, #1
}
34187296:	4618      	mov	r0, r3
34187298:	370c      	adds	r7, #12
3418729a:	46bd      	mov	sp, r7
3418729c:	f85d 7b04 	ldr.w	r7, [sp], #4
341872a0:	4770      	bx	lr

341872a2 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341872a2:	b480      	push	{r7}
341872a4:	b083      	sub	sp, #12
341872a6:	af00      	add	r7, sp, #0
341872a8:	6078      	str	r0, [r7, #4]
341872aa:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341872ac:	687b      	ldr	r3, [r7, #4]
341872ae:	2b00      	cmp	r3, #0
341872b0:	d101      	bne.n	341872b6 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
341872b2:	2301      	movs	r3, #1
341872b4:	e00f      	b.n	341872d6 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
341872b6:	683b      	ldr	r3, [r7, #0]
341872b8:	2b01      	cmp	r3, #1
341872ba:	d10b      	bne.n	341872d4 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
341872bc:	687b      	ldr	r3, [r7, #4]
341872be:	681b      	ldr	r3, [r3, #0]
341872c0:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
341872c4:	687b      	ldr	r3, [r7, #4]
341872c6:	681b      	ldr	r3, [r3, #0]
341872c8:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
341872cc:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341872d0:	2300      	movs	r3, #0
341872d2:	e000      	b.n	341872d6 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
    return HAL_ERROR;
341872d4:	2301      	movs	r3, #1
}
341872d6:	4618      	mov	r0, r3
341872d8:	370c      	adds	r7, #12
341872da:	46bd      	mov	sp, r7
341872dc:	f85d 7b04 	ldr.w	r7, [sp], #4
341872e0:	4770      	bx	lr

341872e2 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
  * @param  Strength Specifies the removal strength, can be a value from @ref DCMIPP_Bad_Pixel_Removal_Strength
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              uint32_t Strength)
{
341872e2:	b480      	push	{r7}
341872e4:	b085      	sub	sp, #20
341872e6:	af00      	add	r7, sp, #0
341872e8:	60f8      	str	r0, [r7, #12]
341872ea:	60b9      	str	r1, [r7, #8]
341872ec:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if (hdcmipp == NULL)
341872ee:	68fb      	ldr	r3, [r7, #12]
341872f0:	2b00      	cmp	r3, #0
341872f2:	d101      	bne.n	341872f8 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x16>
  {
    return HAL_ERROR;
341872f4:	2301      	movs	r3, #1
341872f6:	e012      	b.n	3418731e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));

  if (Pipe == DCMIPP_PIPE1)
341872f8:	68bb      	ldr	r3, [r7, #8]
341872fa:	2b01      	cmp	r3, #1
341872fc:	d10e      	bne.n	3418731c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
341872fe:	68fb      	ldr	r3, [r7, #12]
34187300:	681b      	ldr	r3, [r3, #0]
34187302:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34187306:	f023 010e 	bic.w	r1, r3, #14
3418730a:	687b      	ldr	r3, [r7, #4]
3418730c:	005a      	lsls	r2, r3, #1
3418730e:	68fb      	ldr	r3, [r7, #12]
34187310:	681b      	ldr	r3, [r3, #0]
34187312:	430a      	orrs	r2, r1
34187314:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187318:	2300      	movs	r3, #0
3418731a:	e000      	b.n	3418731e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>
    return HAL_ERROR;
3418731c:	2301      	movs	r3, #1
}
3418731e:	4618      	mov	r0, r3
34187320:	3714      	adds	r7, #20
34187322:	46bd      	mov	sp, r7
34187324:	f85d 7b04 	ldr.w	r7, [sp], #4
34187328:	4770      	bx	lr

3418732a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418732a:	b480      	push	{r7}
3418732c:	b083      	sub	sp, #12
3418732e:	af00      	add	r7, sp, #0
34187330:	6078      	str	r0, [r7, #4]
34187332:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34187334:	687b      	ldr	r3, [r7, #4]
34187336:	2b00      	cmp	r3, #0
34187338:	d101      	bne.n	3418733e <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
3418733a:	2301      	movs	r3, #1
3418733c:	e00f      	b.n	3418735e <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
3418733e:	683b      	ldr	r3, [r7, #0]
34187340:	2b01      	cmp	r3, #1
34187342:	d10b      	bne.n	3418735c <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34187344:	687b      	ldr	r3, [r7, #4]
34187346:	681b      	ldr	r3, [r3, #0]
34187348:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
3418734c:	687b      	ldr	r3, [r7, #4]
3418734e:	681b      	ldr	r3, [r3, #0]
34187350:	f042 0201 	orr.w	r2, r2, #1
34187354:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187358:	2300      	movs	r3, #0
3418735a:	e000      	b.n	3418735e <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
3418735c:	2301      	movs	r3, #1
}
3418735e:	4618      	mov	r0, r3
34187360:	370c      	adds	r7, #12
34187362:	46bd      	mov	sp, r7
34187364:	f85d 7b04 	ldr.w	r7, [sp], #4
34187368:	4770      	bx	lr

3418736a <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418736a:	b480      	push	{r7}
3418736c:	b083      	sub	sp, #12
3418736e:	af00      	add	r7, sp, #0
34187370:	6078      	str	r0, [r7, #4]
34187372:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34187374:	687b      	ldr	r3, [r7, #4]
34187376:	2b00      	cmp	r3, #0
34187378:	d101      	bne.n	3418737e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
3418737a:	2301      	movs	r3, #1
3418737c:	e00f      	b.n	3418739e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
3418737e:	683b      	ldr	r3, [r7, #0]
34187380:	2b01      	cmp	r3, #1
34187382:	d10b      	bne.n	3418739c <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34187384:	687b      	ldr	r3, [r7, #4]
34187386:	681b      	ldr	r3, [r3, #0]
34187388:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
3418738c:	687b      	ldr	r3, [r7, #4]
3418738e:	681b      	ldr	r3, [r3, #0]
34187390:	f022 0201 	bic.w	r2, r2, #1
34187394:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187398:	2300      	movs	r3, #0
3418739a:	e000      	b.n	3418739e <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
3418739c:	2301      	movs	r3, #1
}
3418739e:	4618      	mov	r0, r3
341873a0:	370c      	adds	r7, #12
341873a2:	46bd      	mov	sp, r7
341873a4:	f85d 7b04 	ldr.w	r7, [sp], #4
341873a8:	4770      	bx	lr

341873aa <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval  The strength of the bad pixel removal process.
  */
uint32_t HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341873aa:	b480      	push	{r7}
341873ac:	b083      	sub	sp, #12
341873ae:	af00      	add	r7, sp, #0
341873b0:	6078      	str	r0, [r7, #4]
341873b2:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
341873b4:	687b      	ldr	r3, [r7, #4]
341873b6:	681b      	ldr	r3, [r3, #0]
341873b8:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
341873bc:	085b      	lsrs	r3, r3, #1
341873be:	f003 0307 	and.w	r3, r3, #7
}
341873c2:	4618      	mov	r0, r3
341873c4:	370c      	adds	r7, #12
341873c6:	46bd      	mov	sp, r7
341873c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341873cc:	4770      	bx	lr

341873ce <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341873ce:	b480      	push	{r7}
341873d0:	b083      	sub	sp, #12
341873d2:	af00      	add	r7, sp, #0
341873d4:	6078      	str	r0, [r7, #4]
341873d6:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341873d8:	683b      	ldr	r3, [r7, #0]
341873da:	2b01      	cmp	r3, #1
341873dc:	d10b      	bne.n	341873f6 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
341873de:	687b      	ldr	r3, [r7, #4]
341873e0:	681b      	ldr	r3, [r3, #0]
341873e2:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
341873e6:	f003 0301 	and.w	r3, r3, #1
341873ea:	2b01      	cmp	r3, #1
341873ec:	d101      	bne.n	341873f2 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x24>
341873ee:	2301      	movs	r3, #1
341873f0:	e002      	b.n	341873f8 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
341873f2:	2300      	movs	r3, #0
341873f4:	e000      	b.n	341873f8 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
341873f6:	2300      	movs	r3, #0
  }
}
341873f8:	4618      	mov	r0, r3
341873fa:	370c      	adds	r7, #12
341873fc:	46bd      	mov	sp, r7
341873fe:	f85d 7b04 	ldr.w	r7, [sp], #4
34187402:	4770      	bx	lr

34187404 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
  * @param  pCounter pointer receiving the number of corrected bad pixels
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t *pCounter)
{
34187404:	b480      	push	{r7}
34187406:	b085      	sub	sp, #20
34187408:	af00      	add	r7, sp, #0
3418740a:	60f8      	str	r0, [r7, #12]
3418740c:	60b9      	str	r1, [r7, #8]
3418740e:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
34187410:	68fb      	ldr	r3, [r7, #12]
34187412:	2b00      	cmp	r3, #0
34187414:	d002      	beq.n	3418741c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x18>
34187416:	687b      	ldr	r3, [r7, #4]
34187418:	2b00      	cmp	r3, #0
3418741a:	d101      	bne.n	34187420 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1c>
  {
    return HAL_ERROR;
3418741c:	2301      	movs	r3, #1
3418741e:	e00f      	b.n	34187440 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187420:	68fb      	ldr	r3, [r7, #12]
34187422:	791b      	ldrb	r3, [r3, #4]
34187424:	b2db      	uxtb	r3, r3
34187426:	2b02      	cmp	r3, #2
34187428:	d109      	bne.n	3418743e <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3a>
  {
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
3418742a:	68fb      	ldr	r3, [r7, #12]
3418742c:	681b      	ldr	r3, [r3, #0]
3418742e:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
34187432:	f3c3 020b 	ubfx	r2, r3, #0, #12
34187436:	687b      	ldr	r3, [r7, #4]
34187438:	601a      	str	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418743a:	2300      	movs	r3, #0
3418743c:	e000      	b.n	34187440 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>
    return HAL_ERROR;
3418743e:	2301      	movs	r3, #1
}
34187440:	4618      	mov	r0, r3
34187442:	3714      	adds	r7, #20
34187444:	46bd      	mov	sp, r7
34187446:	f85d 7b04 	ldr.w	r7, [sp], #4
3418744a:	4770      	bx	lr

3418744c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPColorConversionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              const DCMIPP_ColorConversionConfTypeDef
                                                              *pColorConversionConfig)
{
3418744c:	b480      	push	{r7}
3418744e:	b087      	sub	sp, #28
34187450:	af00      	add	r7, sp, #0
34187452:	60f8      	str	r0, [r7, #12]
34187454:	60b9      	str	r1, [r7, #8]
34187456:	607a      	str	r2, [r7, #4]
  uint32_t p1cccr_reg;
  uint16_t tmp1;
  uint16_t tmp2;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34187458:	68fb      	ldr	r3, [r7, #12]
3418745a:	2b00      	cmp	r3, #0
3418745c:	d002      	beq.n	34187464 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x18>
3418745e:	687b      	ldr	r3, [r7, #4]
34187460:	2b00      	cmp	r3, #0
34187462:	d101      	bne.n	34187468 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c>
  {
    return HAL_ERROR;
34187464:	2301      	movs	r3, #1
34187466:	e14b      	b.n	34187700 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));

  if (Pipe == DCMIPP_PIPE1)
34187468:	68bb      	ldr	r3, [r7, #8]
3418746a:	2b01      	cmp	r3, #1
3418746c:	f040 8147 	bne.w	341876fe <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b2>
  {
    /* Set Clamp and Type */
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
34187470:	687b      	ldr	r3, [r7, #4]
34187472:	781b      	ldrb	r3, [r3, #0]
34187474:	009b      	lsls	r3, r3, #2
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
34187476:	687a      	ldr	r2, [r7, #4]
34187478:	7852      	ldrb	r2, [r2, #1]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
3418747a:	4313      	orrs	r3, r2
3418747c:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
3418747e:	68fb      	ldr	r3, [r7, #12]
34187480:	681b      	ldr	r3, [r3, #0]
34187482:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
34187486:	f023 0106 	bic.w	r1, r3, #6
3418748a:	68fb      	ldr	r3, [r7, #12]
3418748c:	681b      	ldr	r3, [r3, #0]
3418748e:	697a      	ldr	r2, [r7, #20]
34187490:	430a      	orrs	r2, r1
34187492:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
34187496:	687b      	ldr	r3, [r7, #4]
34187498:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
3418749c:	2b00      	cmp	r3, #0
3418749e:	da07      	bge.n	341874b0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x64>
341874a0:	687b      	ldr	r3, [r7, #4]
341874a2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
341874a6:	b29b      	uxth	r3, r3
341874a8:	f3c3 030a 	ubfx	r3, r3, #0, #11
341874ac:	b29b      	uxth	r3, r3
341874ae:	e003      	b.n	341874b8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6c>
341874b0:	687b      	ldr	r3, [r7, #4]
341874b2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
341874b6:	b29b      	uxth	r3, r3
341874b8:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
341874ba:	687b      	ldr	r3, [r7, #4]
341874bc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
341874c0:	2b00      	cmp	r3, #0
341874c2:	da07      	bge.n	341874d4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x88>
341874c4:	687b      	ldr	r3, [r7, #4]
341874c6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
341874ca:	b29b      	uxth	r3, r3
341874cc:	f3c3 030a 	ubfx	r3, r3, #0, #11
341874d0:	b29b      	uxth	r3, r3
341874d2:	e003      	b.n	341874dc <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x90>
341874d4:	687b      	ldr	r3, [r7, #4]
341874d6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
341874da:	b29b      	uxth	r3, r3
341874dc:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
341874de:	68fb      	ldr	r3, [r7, #12]
341874e0:	681b      	ldr	r3, [r3, #0]
341874e2:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
341874e6:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
341874ea:	8a7a      	ldrh	r2, [r7, #18]
341874ec:	8a3b      	ldrh	r3, [r7, #16]
341874ee:	041b      	lsls	r3, r3, #16
341874f0:	431a      	orrs	r2, r3
341874f2:	68fb      	ldr	r3, [r7, #12]
341874f4:	681b      	ldr	r3, [r3, #0]
341874f6:	430a      	orrs	r2, r1
341874f8:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
               (((uint32_t)tmp1) << DCMIPP_P1CCRR1_RR_Pos) | (((uint32_t)tmp2) << DCMIPP_P1CCRR1_RG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
341874fc:	687b      	ldr	r3, [r7, #4]
341874fe:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
34187502:	2b00      	cmp	r3, #0
34187504:	da07      	bge.n	34187516 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xca>
34187506:	687b      	ldr	r3, [r7, #4]
34187508:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
3418750c:	b29b      	uxth	r3, r3
3418750e:	f3c3 030a 	ubfx	r3, r3, #0, #11
34187512:	b29b      	uxth	r3, r3
34187514:	e003      	b.n	3418751e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xd2>
34187516:	687b      	ldr	r3, [r7, #4]
34187518:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
3418751c:	b29b      	uxth	r3, r3
3418751e:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
34187520:	687b      	ldr	r3, [r7, #4]
34187522:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
34187526:	2b00      	cmp	r3, #0
34187528:	da07      	bge.n	3418753a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xee>
3418752a:	687b      	ldr	r3, [r7, #4]
3418752c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
34187530:	b29b      	uxth	r3, r3
34187532:	f3c3 0309 	ubfx	r3, r3, #0, #10
34187536:	b29b      	uxth	r3, r3
34187538:	e003      	b.n	34187542 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
3418753a:	687b      	ldr	r3, [r7, #4]
3418753c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
34187540:	b29b      	uxth	r3, r3
34187542:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
34187544:	68fb      	ldr	r3, [r7, #12]
34187546:	681b      	ldr	r3, [r3, #0]
34187548:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
3418754c:	4b6f      	ldr	r3, [pc, #444]	@ (3418770c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
3418754e:	4013      	ands	r3, r2
34187550:	8a79      	ldrh	r1, [r7, #18]
34187552:	8a3a      	ldrh	r2, [r7, #16]
34187554:	0412      	lsls	r2, r2, #16
34187556:	4311      	orrs	r1, r2
34187558:	68fa      	ldr	r2, [r7, #12]
3418755a:	6812      	ldr	r2, [r2, #0]
3418755c:	430b      	orrs	r3, r1
3418755e:	f8c2 3888 	str.w	r3, [r2, #2184]	@ 0x888
               ((uint32_t)tmp1 << DCMIPP_P1CCRR2_RB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCRR2_RA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
34187562:	687b      	ldr	r3, [r7, #4]
34187564:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
34187568:	2b00      	cmp	r3, #0
3418756a:	da07      	bge.n	3418757c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x130>
3418756c:	687b      	ldr	r3, [r7, #4]
3418756e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
34187572:	b29b      	uxth	r3, r3
34187574:	f3c3 030a 	ubfx	r3, r3, #0, #11
34187578:	b29b      	uxth	r3, r3
3418757a:	e003      	b.n	34187584 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x138>
3418757c:	687b      	ldr	r3, [r7, #4]
3418757e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
34187582:	b29b      	uxth	r3, r3
34187584:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
34187586:	687b      	ldr	r3, [r7, #4]
34187588:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
3418758c:	2b00      	cmp	r3, #0
3418758e:	da07      	bge.n	341875a0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x154>
34187590:	687b      	ldr	r3, [r7, #4]
34187592:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
34187596:	b29b      	uxth	r3, r3
34187598:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418759c:	b29b      	uxth	r3, r3
3418759e:	e003      	b.n	341875a8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x15c>
341875a0:	687b      	ldr	r3, [r7, #4]
341875a2:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
341875a6:	b29b      	uxth	r3, r3
341875a8:	823b      	strh	r3, [r7, #16]


    /* Set Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
341875aa:	68fb      	ldr	r3, [r7, #12]
341875ac:	681b      	ldr	r3, [r3, #0]
341875ae:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
341875b2:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
341875b6:	8a7b      	ldrh	r3, [r7, #18]
341875b8:	041a      	lsls	r2, r3, #16
341875ba:	8a3b      	ldrh	r3, [r7, #16]
341875bc:	431a      	orrs	r2, r3
341875be:	68fb      	ldr	r3, [r7, #12]
341875c0:	681b      	ldr	r3, [r3, #0]
341875c2:	430a      	orrs	r2, r1
341875c4:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
               ((uint32_t)tmp1 << DCMIPP_P1CCGR1_GG_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR1_GR_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
341875c8:	687b      	ldr	r3, [r7, #4]
341875ca:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
341875ce:	2b00      	cmp	r3, #0
341875d0:	da07      	bge.n	341875e2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x196>
341875d2:	687b      	ldr	r3, [r7, #4]
341875d4:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
341875d8:	b29b      	uxth	r3, r3
341875da:	f3c3 030a 	ubfx	r3, r3, #0, #11
341875de:	b29b      	uxth	r3, r3
341875e0:	e003      	b.n	341875ea <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x19e>
341875e2:	687b      	ldr	r3, [r7, #4]
341875e4:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
341875e8:	b29b      	uxth	r3, r3
341875ea:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
341875ec:	687b      	ldr	r3, [r7, #4]
341875ee:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
341875f2:	2b00      	cmp	r3, #0
341875f4:	da07      	bge.n	34187606 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1ba>
341875f6:	687b      	ldr	r3, [r7, #4]
341875f8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
341875fc:	b29b      	uxth	r3, r3
341875fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
34187602:	b29b      	uxth	r3, r3
34187604:	e003      	b.n	3418760e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c2>
34187606:	687b      	ldr	r3, [r7, #4]
34187608:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
3418760c:	b29b      	uxth	r3, r3
3418760e:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
34187610:	68fb      	ldr	r3, [r7, #12]
34187612:	681b      	ldr	r3, [r3, #0]
34187614:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
34187618:	4b3c      	ldr	r3, [pc, #240]	@ (3418770c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
3418761a:	4013      	ands	r3, r2
3418761c:	8a79      	ldrh	r1, [r7, #18]
3418761e:	8a3a      	ldrh	r2, [r7, #16]
34187620:	0412      	lsls	r2, r2, #16
34187622:	4311      	orrs	r1, r2
34187624:	68fa      	ldr	r2, [r7, #12]
34187626:	6812      	ldr	r2, [r2, #0]
34187628:	430b      	orrs	r3, r1
3418762a:	f8c2 3890 	str.w	r3, [r2, #2192]	@ 0x890
               ((uint32_t)tmp1 << DCMIPP_P1CCGR2_GB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR2_GA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3418762e:	687b      	ldr	r3, [r7, #4]
34187630:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
34187634:	2b00      	cmp	r3, #0
34187636:	da07      	bge.n	34187648 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1fc>
34187638:	687b      	ldr	r3, [r7, #4]
3418763a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
3418763e:	b29b      	uxth	r3, r3
34187640:	f3c3 030a 	ubfx	r3, r3, #0, #11
34187644:	b29b      	uxth	r3, r3
34187646:	e003      	b.n	34187650 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x204>
34187648:	687b      	ldr	r3, [r7, #4]
3418764a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
3418764e:	b29b      	uxth	r3, r3
34187650:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
34187652:	687b      	ldr	r3, [r7, #4]
34187654:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
34187658:	2b00      	cmp	r3, #0
3418765a:	da07      	bge.n	3418766c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x220>
3418765c:	687b      	ldr	r3, [r7, #4]
3418765e:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
34187662:	b29b      	uxth	r3, r3
34187664:	f3c3 030a 	ubfx	r3, r3, #0, #11
34187668:	b29b      	uxth	r3, r3
3418766a:	e003      	b.n	34187674 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x228>
3418766c:	687b      	ldr	r3, [r7, #4]
3418766e:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
34187672:	b29b      	uxth	r3, r3
34187674:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
34187676:	68fb      	ldr	r3, [r7, #12]
34187678:	681b      	ldr	r3, [r3, #0]
3418767a:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
3418767e:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
34187682:	8a7a      	ldrh	r2, [r7, #18]
34187684:	8a3b      	ldrh	r3, [r7, #16]
34187686:	041b      	lsls	r3, r3, #16
34187688:	431a      	orrs	r2, r3
3418768a:	68fb      	ldr	r3, [r7, #12]
3418768c:	681b      	ldr	r3, [r3, #0]
3418768e:	430a      	orrs	r2, r1
34187690:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
               ((uint32_t)tmp1 << DCMIPP_P1CCBR1_BR_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCBR1_BG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34187694:	687b      	ldr	r3, [r7, #4]
34187696:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
3418769a:	2b00      	cmp	r3, #0
3418769c:	da07      	bge.n	341876ae <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x262>
3418769e:	687b      	ldr	r3, [r7, #4]
341876a0:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
341876a4:	b29b      	uxth	r3, r3
341876a6:	f3c3 030a 	ubfx	r3, r3, #0, #11
341876aa:	b29b      	uxth	r3, r3
341876ac:	e003      	b.n	341876b6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x26a>
341876ae:	687b      	ldr	r3, [r7, #4]
341876b0:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
341876b4:	b29b      	uxth	r3, r3
341876b6:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
341876b8:	687b      	ldr	r3, [r7, #4]
341876ba:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
341876be:	2b00      	cmp	r3, #0
341876c0:	da07      	bge.n	341876d2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x286>
341876c2:	687b      	ldr	r3, [r7, #4]
341876c4:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
341876c8:	b29b      	uxth	r3, r3
341876ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
341876ce:	b29b      	uxth	r3, r3
341876d0:	e003      	b.n	341876da <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x28e>
341876d2:	687b      	ldr	r3, [r7, #4]
341876d4:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
341876d8:	b29b      	uxth	r3, r3
341876da:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
341876dc:	68fb      	ldr	r3, [r7, #12]
341876de:	681b      	ldr	r3, [r3, #0]
341876e0:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
341876e4:	4b09      	ldr	r3, [pc, #36]	@ (3418770c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
341876e6:	4013      	ands	r3, r2
341876e8:	8a79      	ldrh	r1, [r7, #18]
341876ea:	8a3a      	ldrh	r2, [r7, #16]
341876ec:	0412      	lsls	r2, r2, #16
341876ee:	4311      	orrs	r1, r2
341876f0:	68fa      	ldr	r2, [r7, #12]
341876f2:	6812      	ldr	r2, [r2, #0]
341876f4:	430b      	orrs	r3, r1
341876f6:	f8c2 3898 	str.w	r3, [r2, #2200]	@ 0x898
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341876fa:	2300      	movs	r3, #0
341876fc:	e000      	b.n	34187700 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
    return HAL_ERROR;
341876fe:	2301      	movs	r3, #1
}
34187700:	4618      	mov	r0, r3
34187702:	371c      	adds	r7, #28
34187704:	46bd      	mov	sp, r7
34187706:	f85d 7b04 	ldr.w	r7, [sp], #4
3418770a:	4770      	bx	lr
3418770c:	fc00f800 	.word	0xfc00f800

34187710 <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187710:	b480      	push	{r7}
34187712:	b083      	sub	sp, #12
34187714:	af00      	add	r7, sp, #0
34187716:	6078      	str	r0, [r7, #4]
34187718:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3418771a:	687b      	ldr	r3, [r7, #4]
3418771c:	2b00      	cmp	r3, #0
3418771e:	d101      	bne.n	34187724 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
  {
    return HAL_ERROR;
34187720:	2301      	movs	r3, #1
34187722:	e00f      	b.n	34187744 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187724:	683b      	ldr	r3, [r7, #0]
34187726:	2b01      	cmp	r3, #1
34187728:	d10b      	bne.n	34187742 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
3418772a:	687b      	ldr	r3, [r7, #4]
3418772c:	681b      	ldr	r3, [r3, #0]
3418772e:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
34187732:	687b      	ldr	r3, [r7, #4]
34187734:	681b      	ldr	r3, [r3, #0]
34187736:	f042 0201 	orr.w	r2, r2, #1
3418773a:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418773e:	2300      	movs	r3, #0
34187740:	e000      	b.n	34187744 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
    return HAL_ERROR;
34187742:	2301      	movs	r3, #1
}
34187744:	4618      	mov	r0, r3
34187746:	370c      	adds	r7, #12
34187748:	46bd      	mov	sp, r7
3418774a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418774e:	4770      	bx	lr

34187750 <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187750:	b480      	push	{r7}
34187752:	b083      	sub	sp, #12
34187754:	af00      	add	r7, sp, #0
34187756:	6078      	str	r0, [r7, #4]
34187758:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3418775a:	687b      	ldr	r3, [r7, #4]
3418775c:	2b00      	cmp	r3, #0
3418775e:	d101      	bne.n	34187764 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
  {
    return HAL_ERROR;
34187760:	2301      	movs	r3, #1
34187762:	e00f      	b.n	34187784 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187764:	683b      	ldr	r3, [r7, #0]
34187766:	2b01      	cmp	r3, #1
34187768:	d10b      	bne.n	34187782 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
3418776a:	687b      	ldr	r3, [r7, #4]
3418776c:	681b      	ldr	r3, [r3, #0]
3418776e:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
34187772:	687b      	ldr	r3, [r7, #4]
34187774:	681b      	ldr	r3, [r3, #0]
34187776:	f022 0201 	bic.w	r2, r2, #1
3418777a:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418777e:	2300      	movs	r3, #0
34187780:	e000      	b.n	34187784 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
    return HAL_ERROR;
34187782:	2301      	movs	r3, #1
}
34187784:	4618      	mov	r0, r3
34187786:	370c      	adds	r7, #12
34187788:	46bd      	mov	sp, r7
3418778a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418778e:	4770      	bx	lr

34187790 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                    const DCMIPP_BlackLevelConfTypeDef
                                                                    *pBlackLevelConfig)
{
34187790:	b480      	push	{r7}
34187792:	b085      	sub	sp, #20
34187794:	af00      	add	r7, sp, #0
34187796:	60f8      	str	r0, [r7, #12]
34187798:	60b9      	str	r1, [r7, #8]
3418779a:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
3418779c:	68fb      	ldr	r3, [r7, #12]
3418779e:	2b00      	cmp	r3, #0
341877a0:	d002      	beq.n	341877a8 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x18>
341877a2:	687b      	ldr	r3, [r7, #4]
341877a4:	2b00      	cmp	r3, #0
341877a6:	d101      	bne.n	341877ac <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1c>
  {
    return HAL_ERROR;
341877a8:	2301      	movs	r3, #1
341877aa:	e01a      	b.n	341877e2 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341877ac:	68bb      	ldr	r3, [r7, #8]
341877ae:	2b01      	cmp	r3, #1
341877b0:	d116      	bne.n	341877e0 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x50>
  {
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
341877b2:	68fb      	ldr	r3, [r7, #12]
341877b4:	681b      	ldr	r3, [r3, #0]
341877b6:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
341877ba:	b2d9      	uxtb	r1, r3
341877bc:	687b      	ldr	r3, [r7, #4]
341877be:	781b      	ldrb	r3, [r3, #0]
341877c0:	061a      	lsls	r2, r3, #24
341877c2:	687b      	ldr	r3, [r7, #4]
341877c4:	785b      	ldrb	r3, [r3, #1]
341877c6:	041b      	lsls	r3, r3, #16
341877c8:	431a      	orrs	r2, r3
341877ca:	687b      	ldr	r3, [r7, #4]
341877cc:	789b      	ldrb	r3, [r3, #2]
341877ce:	021b      	lsls	r3, r3, #8
341877d0:	431a      	orrs	r2, r3
341877d2:	68fb      	ldr	r3, [r7, #12]
341877d4:	681b      	ldr	r3, [r3, #0]
341877d6:	430a      	orrs	r2, r1
341877d8:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341877dc:	2300      	movs	r3, #0
341877de:	e000      	b.n	341877e2 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
    return HAL_ERROR;
341877e0:	2301      	movs	r3, #1
}
341877e2:	4618      	mov	r0, r3
341877e4:	3714      	adds	r7, #20
341877e6:	46bd      	mov	sp, r7
341877e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341877ec:	4770      	bx	lr

341877ee <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341877ee:	b480      	push	{r7}
341877f0:	b083      	sub	sp, #12
341877f2:	af00      	add	r7, sp, #0
341877f4:	6078      	str	r0, [r7, #4]
341877f6:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
341877f8:	687b      	ldr	r3, [r7, #4]
341877fa:	2b00      	cmp	r3, #0
341877fc:	d101      	bne.n	34187802 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
341877fe:	2301      	movs	r3, #1
34187800:	e00f      	b.n	34187822 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187802:	683b      	ldr	r3, [r7, #0]
34187804:	2b01      	cmp	r3, #1
34187806:	d10b      	bne.n	34187820 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34187808:	687b      	ldr	r3, [r7, #4]
3418780a:	681b      	ldr	r3, [r3, #0]
3418780c:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
34187810:	687b      	ldr	r3, [r7, #4]
34187812:	681b      	ldr	r3, [r3, #0]
34187814:	f042 0201 	orr.w	r2, r2, #1
34187818:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418781c:	2300      	movs	r3, #0
3418781e:	e000      	b.n	34187822 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
34187820:	2301      	movs	r3, #1
}
34187822:	4618      	mov	r0, r3
34187824:	370c      	adds	r7, #12
34187826:	46bd      	mov	sp, r7
34187828:	f85d 7b04 	ldr.w	r7, [sp], #4
3418782c:	4770      	bx	lr

3418782e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418782e:	b480      	push	{r7}
34187830:	b083      	sub	sp, #12
34187832:	af00      	add	r7, sp, #0
34187834:	6078      	str	r0, [r7, #4]
34187836:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187838:	687b      	ldr	r3, [r7, #4]
3418783a:	2b00      	cmp	r3, #0
3418783c:	d101      	bne.n	34187842 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
3418783e:	2301      	movs	r3, #1
34187840:	e00f      	b.n	34187862 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187842:	683b      	ldr	r3, [r7, #0]
34187844:	2b01      	cmp	r3, #1
34187846:	d10b      	bne.n	34187860 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34187848:	687b      	ldr	r3, [r7, #4]
3418784a:	681b      	ldr	r3, [r3, #0]
3418784c:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
34187850:	687b      	ldr	r3, [r7, #4]
34187852:	681b      	ldr	r3, [r3, #0]
34187854:	f022 0201 	bic.w	r2, r2, #1
34187858:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418785c:	2300      	movs	r3, #0
3418785e:	e000      	b.n	34187862 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
34187860:	2301      	movs	r3, #1
}
34187862:	4618      	mov	r0, r3
34187864:	370c      	adds	r7, #12
34187866:	46bd      	mov	sp, r7
34187868:	f85d 7b04 	ldr.w	r7, [sp], #4
3418786c:	4770      	bx	lr

3418786e <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>:
  *                            filled with the black level calibration configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       DCMIPP_BlackLevelConfTypeDef *pBlackLevelConfig)
{
3418786e:	b480      	push	{r7}
34187870:	b087      	sub	sp, #28
34187872:	af00      	add	r7, sp, #0
34187874:	60f8      	str	r0, [r7, #12]
34187876:	60b9      	str	r1, [r7, #8]
34187878:	607a      	str	r2, [r7, #4]
  uint32_t p1blccr_reg;
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
3418787a:	68bb      	ldr	r3, [r7, #8]
3418787c:	2b01      	cmp	r3, #1
3418787e:	d113      	bne.n	341878a8 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0x3a>
  {
    p1blccr_reg = READ_REG(hdcmipp->Instance->P1BLCCR);
34187880:	68fb      	ldr	r3, [r7, #12]
34187882:	681b      	ldr	r3, [r3, #0]
34187884:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
34187888:	617b      	str	r3, [r7, #20]
    pBlackLevelConfig->BlueCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCB) >> DCMIPP_P1BLCCR_BLCB_Pos);
3418788a:	697b      	ldr	r3, [r7, #20]
3418788c:	0a1b      	lsrs	r3, r3, #8
3418788e:	b2da      	uxtb	r2, r3
34187890:	687b      	ldr	r3, [r7, #4]
34187892:	709a      	strb	r2, [r3, #2]
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
34187894:	697b      	ldr	r3, [r7, #20]
34187896:	0c1b      	lsrs	r3, r3, #16
34187898:	b2da      	uxtb	r2, r3
3418789a:	687b      	ldr	r3, [r7, #4]
3418789c:	705a      	strb	r2, [r3, #1]
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
3418789e:	697b      	ldr	r3, [r7, #20]
341878a0:	0e1b      	lsrs	r3, r3, #24
341878a2:	b2da      	uxtb	r2, r3
341878a4:	687b      	ldr	r3, [r7, #4]
341878a6:	701a      	strb	r2, [r3, #0]
  }
}
341878a8:	bf00      	nop
341878aa:	371c      	adds	r7, #28
341878ac:	46bd      	mov	sp, r7
341878ae:	f85d 7b04 	ldr.w	r7, [sp], #4
341878b2:	4770      	bx	lr

341878b4 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341878b4:	b480      	push	{r7}
341878b6:	b083      	sub	sp, #12
341878b8:	af00      	add	r7, sp, #0
341878ba:	6078      	str	r0, [r7, #4]
341878bc:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341878be:	683b      	ldr	r3, [r7, #0]
341878c0:	2b01      	cmp	r3, #1
341878c2:	d10b      	bne.n	341878dc <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE) == DCMIPP_P1BLCCR_ENABLE) ? 1U : 0U);
341878c4:	687b      	ldr	r3, [r7, #4]
341878c6:	681b      	ldr	r3, [r3, #0]
341878c8:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
341878cc:	f003 0301 	and.w	r3, r3, #1
341878d0:	2b01      	cmp	r3, #1
341878d2:	d101      	bne.n	341878d8 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x24>
341878d4:	2301      	movs	r3, #1
341878d6:	e002      	b.n	341878de <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x2a>
341878d8:	2300      	movs	r3, #0
341878da:	e000      	b.n	341878de <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
341878dc:	2300      	movs	r3, #0
  }
}
341878de:	4618      	mov	r0, r3
341878e0:	370c      	adds	r7, #12
341878e2:	46bd      	mov	sp, r7
341878e4:	f85d 7b04 	ldr.w	r7, [sp], #4
341878e8:	4770      	bx	lr

341878ea <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                  uint8_t ModuleID, const
                                                                  DCMIPP_StatisticExtractionConfTypeDef
                                                                  *pStatisticExtractionConfig)
{
341878ea:	b480      	push	{r7}
341878ec:	b087      	sub	sp, #28
341878ee:	af00      	add	r7, sp, #0
341878f0:	60f8      	str	r0, [r7, #12]
341878f2:	60b9      	str	r1, [r7, #8]
341878f4:	603b      	str	r3, [r7, #0]
341878f6:	4613      	mov	r3, r2
341878f8:	71fb      	strb	r3, [r7, #7]
  uint32_t p1stxcr_reg;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
341878fa:	68fb      	ldr	r3, [r7, #12]
341878fc:	2b00      	cmp	r3, #0
341878fe:	d002      	beq.n	34187906 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x1c>
34187900:	683b      	ldr	r3, [r7, #0]
34187902:	2b00      	cmp	r3, #0
34187904:	d101      	bne.n	3418790a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x20>
  {
    return HAL_ERROR;
34187906:	2301      	movs	r3, #1
34187908:	e03b      	b.n	34187982 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));

  if (Pipe == DCMIPP_PIPE1)
3418790a:	68bb      	ldr	r3, [r7, #8]
3418790c:	2b01      	cmp	r3, #1
3418790e:	d135      	bne.n	3418797c <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x92>
  {
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34187910:	683b      	ldr	r3, [r7, #0]
34187912:	681a      	ldr	r2, [r3, #0]
34187914:	683b      	ldr	r3, [r7, #0]
34187916:	685b      	ldr	r3, [r3, #4]
34187918:	431a      	orrs	r2, r3
                  (pStatisticExtractionConfig->Bins);
3418791a:	683b      	ldr	r3, [r7, #0]
3418791c:	689b      	ldr	r3, [r3, #8]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
3418791e:	4313      	orrs	r3, r2
34187920:	617b      	str	r3, [r7, #20]

    switch (ModuleID)
34187922:	79fb      	ldrb	r3, [r7, #7]
34187924:	2b01      	cmp	r3, #1
34187926:	d002      	beq.n	3418792e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x44>
34187928:	2b02      	cmp	r3, #2
3418792a:	d00d      	beq.n	34187948 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x5e>
3418792c:	e019      	b.n	34187962 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x78>
    {
      case DCMIPP_STATEXT_MODULE1:
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
3418792e:	68fb      	ldr	r3, [r7, #12]
34187930:	681b      	ldr	r3, [r3, #0]
34187932:	f8d3 3850 	ldr.w	r3, [r3, #2128]	@ 0x850
34187936:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
3418793a:	68fb      	ldr	r3, [r7, #12]
3418793c:	681b      	ldr	r3, [r3, #0]
3418793e:	697a      	ldr	r2, [r7, #20]
34187940:	430a      	orrs	r2, r1
34187942:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
                   DCMIPP_P1ST1CR_MODE, p1stxcr_reg);
        break;
34187946:	e01b      	b.n	34187980 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      case DCMIPP_STATEXT_MODULE2:
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34187948:	68fb      	ldr	r3, [r7, #12]
3418794a:	681b      	ldr	r3, [r3, #0]
3418794c:	f8d3 3854 	ldr.w	r3, [r3, #2132]	@ 0x854
34187950:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34187954:	68fb      	ldr	r3, [r7, #12]
34187956:	681b      	ldr	r3, [r3, #0]
34187958:	697a      	ldr	r2, [r7, #20]
3418795a:	430a      	orrs	r2, r1
3418795c:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
                   DCMIPP_P1ST2CR_MODE, p1stxcr_reg);
        break;
34187960:	e00e      	b.n	34187980 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34187962:	68fb      	ldr	r3, [r7, #12]
34187964:	681b      	ldr	r3, [r3, #0]
34187966:	f8d3 3858 	ldr.w	r3, [r3, #2136]	@ 0x858
3418796a:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
3418796e:	68fb      	ldr	r3, [r7, #12]
34187970:	681b      	ldr	r3, [r3, #0]
34187972:	697a      	ldr	r2, [r7, #20]
34187974:	430a      	orrs	r2, r1
34187976:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
                   DCMIPP_P1ST3CR_MODE, p1stxcr_reg);
        break;
3418797a:	e001      	b.n	34187980 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
    }
  }
  else
  {
    return HAL_ERROR;
3418797c:	2301      	movs	r3, #1
3418797e:	e000      	b.n	34187982 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  }

  return HAL_OK;
34187980:	2300      	movs	r3, #0
}
34187982:	4618      	mov	r0, r3
34187984:	371c      	adds	r7, #28
34187986:	46bd      	mov	sp, r7
34187988:	f85d 7b04 	ldr.w	r7, [sp], #4
3418798c:	4770      	bx	lr

3418798e <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                      const DCMIPP_StatisticExtractionAreaConfTypeDef
                                                                      *pStatisticExtractionAreaConfig)
{
3418798e:	b480      	push	{r7}
34187990:	b085      	sub	sp, #20
34187992:	af00      	add	r7, sp, #0
34187994:	60f8      	str	r0, [r7, #12]
34187996:	60b9      	str	r1, [r7, #8]
34187998:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
3418799a:	68fb      	ldr	r3, [r7, #12]
3418799c:	2b00      	cmp	r3, #0
3418799e:	d002      	beq.n	341879a6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x18>
341879a0:	687b      	ldr	r3, [r7, #4]
341879a2:	2b00      	cmp	r3, #0
341879a4:	d101      	bne.n	341879aa <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x1c>
  {
    return HAL_ERROR;
341879a6:	2301      	movs	r3, #1
341879a8:	e027      	b.n	341879fa <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));

  if (Pipe == DCMIPP_PIPE1)
341879aa:	68bb      	ldr	r3, [r7, #8]
341879ac:	2b01      	cmp	r3, #1
341879ae:	d123      	bne.n	341879f8 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6a>
  {
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
341879b0:	68fb      	ldr	r3, [r7, #12]
341879b2:	681b      	ldr	r3, [r3, #0]
341879b4:	f8d3 385c 	ldr.w	r3, [r3, #2140]	@ 0x85c
341879b8:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
341879bc:	687b      	ldr	r3, [r7, #4]
341879be:	685a      	ldr	r2, [r3, #4]
341879c0:	687b      	ldr	r3, [r7, #4]
341879c2:	681b      	ldr	r3, [r3, #0]
341879c4:	041b      	lsls	r3, r3, #16
341879c6:	431a      	orrs	r2, r3
341879c8:	68fb      	ldr	r3, [r7, #12]
341879ca:	681b      	ldr	r3, [r3, #0]
341879cc:	430a      	orrs	r2, r1
341879ce:	f8c3 285c 	str.w	r2, [r3, #2140]	@ 0x85c
               (pStatisticExtractionAreaConfig->HStart << DCMIPP_P1STSTR_HSTART_Pos) | \
               (pStatisticExtractionAreaConfig->VStart << DCMIPP_P1STSTR_VSTART_Pos));

    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
341879d2:	68fb      	ldr	r3, [r7, #12]
341879d4:	681b      	ldr	r3, [r3, #0]
341879d6:	f8d3 3860 	ldr.w	r3, [r3, #2144]	@ 0x860
341879da:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
341879de:	687b      	ldr	r3, [r7, #4]
341879e0:	68da      	ldr	r2, [r3, #12]
341879e2:	687b      	ldr	r3, [r7, #4]
341879e4:	689b      	ldr	r3, [r3, #8]
341879e6:	041b      	lsls	r3, r3, #16
341879e8:	431a      	orrs	r2, r3
341879ea:	68fb      	ldr	r3, [r7, #12]
341879ec:	681b      	ldr	r3, [r3, #0]
341879ee:	430a      	orrs	r2, r1
341879f0:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341879f4:	2300      	movs	r3, #0
341879f6:	e000      	b.n	341879fa <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
    return HAL_ERROR;
341879f8:	2301      	movs	r3, #1
}
341879fa:	4618      	mov	r0, r3
341879fc:	3714      	adds	r7, #20
341879fe:	46bd      	mov	sp, r7
34187a00:	f85d 7b04 	ldr.w	r7, [sp], #4
34187a04:	4770      	bx	lr

34187a06 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
  * @param  ModuleID  Specifies the Module ID, can be a value from @ref DCMIPP_Statistics_Extraction_Module_ID.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint8_t ModuleID)
{
34187a06:	b480      	push	{r7}
34187a08:	b085      	sub	sp, #20
34187a0a:	af00      	add	r7, sp, #0
34187a0c:	60f8      	str	r0, [r7, #12]
34187a0e:	60b9      	str	r1, [r7, #8]
34187a10:	4613      	mov	r3, r2
34187a12:	71fb      	strb	r3, [r7, #7]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187a14:	68fb      	ldr	r3, [r7, #12]
34187a16:	2b00      	cmp	r3, #0
34187a18:	d101      	bne.n	34187a1e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x18>
  {
    return HAL_ERROR;
34187a1a:	2301      	movs	r3, #1
34187a1c:	e02c      	b.n	34187a78 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34187a1e:	68bb      	ldr	r3, [r7, #8]
34187a20:	2b01      	cmp	r3, #1
34187a22:	d126      	bne.n	34187a72 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>
  {
    switch (ModuleID)
34187a24:	79fb      	ldrb	r3, [r7, #7]
34187a26:	2b01      	cmp	r3, #1
34187a28:	d002      	beq.n	34187a30 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2a>
34187a2a:	2b02      	cmp	r3, #2
34187a2c:	d00b      	beq.n	34187a46 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34187a2e:	e015      	b.n	34187a5c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x56>
    {
      case DCMIPP_STATEXT_MODULE1:
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34187a30:	68fb      	ldr	r3, [r7, #12]
34187a32:	681b      	ldr	r3, [r3, #0]
34187a34:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34187a38:	68fb      	ldr	r3, [r7, #12]
34187a3a:	681b      	ldr	r3, [r3, #0]
34187a3c:	f042 0201 	orr.w	r2, r2, #1
34187a40:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
        break;
34187a44:	e017      	b.n	34187a76 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      case DCMIPP_STATEXT_MODULE2:
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
34187a46:	68fb      	ldr	r3, [r7, #12]
34187a48:	681b      	ldr	r3, [r3, #0]
34187a4a:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34187a4e:	68fb      	ldr	r3, [r7, #12]
34187a50:	681b      	ldr	r3, [r3, #0]
34187a52:	f042 0201 	orr.w	r2, r2, #1
34187a56:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
34187a5a:	e00c      	b.n	34187a76 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34187a5c:	68fb      	ldr	r3, [r7, #12]
34187a5e:	681b      	ldr	r3, [r3, #0]
34187a60:	f8d3 2858 	ldr.w	r2, [r3, #2136]	@ 0x858
34187a64:	68fb      	ldr	r3, [r7, #12]
34187a66:	681b      	ldr	r3, [r3, #0]
34187a68:	f042 0201 	orr.w	r2, r2, #1
34187a6c:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
        break;
34187a70:	e001      	b.n	34187a76 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
    }
  }
  else
  {
    return HAL_ERROR;
34187a72:	2301      	movs	r3, #1
34187a74:	e000      	b.n	34187a78 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>
  }

  return HAL_OK;
34187a76:	2300      	movs	r3, #0
}
34187a78:	4618      	mov	r0, r3
34187a7a:	3714      	adds	r7, #20
34187a7c:	46bd      	mov	sp, r7
34187a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187a82:	4770      	bx	lr

34187a84 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187a84:	b480      	push	{r7}
34187a86:	b083      	sub	sp, #12
34187a88:	af00      	add	r7, sp, #0
34187a8a:	6078      	str	r0, [r7, #4]
34187a8c:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187a8e:	687b      	ldr	r3, [r7, #4]
34187a90:	2b00      	cmp	r3, #0
34187a92:	d101      	bne.n	34187a98 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
  {
    return HAL_ERROR;
34187a94:	2301      	movs	r3, #1
34187a96:	e00f      	b.n	34187ab8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187a98:	683b      	ldr	r3, [r7, #0]
34187a9a:	2b01      	cmp	r3, #1
34187a9c:	d10b      	bne.n	34187ab6 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x32>
  {
    /* Crop line enable */
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34187a9e:	687b      	ldr	r3, [r7, #4]
34187aa0:	681b      	ldr	r3, [r3, #0]
34187aa2:	f8d3 2860 	ldr.w	r2, [r3, #2144]	@ 0x860
34187aa6:	687b      	ldr	r3, [r7, #4]
34187aa8:	681b      	ldr	r3, [r3, #0]
34187aaa:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34187aae:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187ab2:	2300      	movs	r3, #0
34187ab4:	e000      	b.n	34187ab8 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
    return HAL_ERROR;
34187ab6:	2301      	movs	r3, #1
}
34187ab8:	4618      	mov	r0, r3
34187aba:	370c      	adds	r7, #12
34187abc:	46bd      	mov	sp, r7
34187abe:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ac2:	4770      	bx	lr

34187ac4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
  * @param  pExposureConfig pointer to the DCMIPP_ExposureConfTypeDef structure that contains the exposure information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPExposureConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       const DCMIPP_ExposureConfTypeDef *pExposureConfig)
{
34187ac4:	b480      	push	{r7}
34187ac6:	b085      	sub	sp, #20
34187ac8:	af00      	add	r7, sp, #0
34187aca:	60f8      	str	r0, [r7, #12]
34187acc:	60b9      	str	r1, [r7, #8]
34187ace:	607a      	str	r2, [r7, #4]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34187ad0:	68fb      	ldr	r3, [r7, #12]
34187ad2:	2b00      	cmp	r3, #0
34187ad4:	d002      	beq.n	34187adc <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x18>
34187ad6:	687b      	ldr	r3, [r7, #4]
34187ad8:	2b00      	cmp	r3, #0
34187ada:	d101      	bne.n	34187ae0 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x1c>
  {
    return HAL_ERROR;
34187adc:	2301      	movs	r3, #1
34187ade:	e02d      	b.n	34187b3c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));

  if (Pipe == DCMIPP_PIPE1)
34187ae0:	68bb      	ldr	r3, [r7, #8]
34187ae2:	2b01      	cmp	r3, #1
34187ae4:	d129      	bne.n	34187b3a <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x76>
  {
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
34187ae6:	68fb      	ldr	r3, [r7, #12]
34187ae8:	681b      	ldr	r3, [r3, #0]
34187aea:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
34187aee:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
34187af2:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
34187af6:	687a      	ldr	r2, [r7, #4]
34187af8:	7812      	ldrb	r2, [r2, #0]
34187afa:	0711      	lsls	r1, r2, #28
34187afc:	687a      	ldr	r2, [r7, #4]
34187afe:	7852      	ldrb	r2, [r2, #1]
34187b00:	0512      	lsls	r2, r2, #20
34187b02:	4311      	orrs	r1, r2
34187b04:	68fa      	ldr	r2, [r7, #12]
34187b06:	6812      	ldr	r2, [r2, #0]
34187b08:	430b      	orrs	r3, r1
34187b0a:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
               (((uint32_t)pExposureConfig->ShiftRed << DCMIPP_P1EXCR1_SHFR_Pos) | \
                ((uint32_t)pExposureConfig->MultiplierRed << DCMIPP_P1EXCR1_MULTR_Pos)));

    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34187b0e:	687b      	ldr	r3, [r7, #4]
34187b10:	789b      	ldrb	r3, [r3, #2]
34187b12:	071a      	lsls	r2, r3, #28
34187b14:	687b      	ldr	r3, [r7, #4]
34187b16:	78db      	ldrb	r3, [r3, #3]
34187b18:	051b      	lsls	r3, r3, #20
34187b1a:	431a      	orrs	r2, r3
34187b1c:	687b      	ldr	r3, [r7, #4]
34187b1e:	791b      	ldrb	r3, [r3, #4]
34187b20:	031b      	lsls	r3, r3, #12
34187b22:	ea42 0103 	orr.w	r1, r2, r3
34187b26:	687b      	ldr	r3, [r7, #4]
34187b28:	795b      	ldrb	r3, [r3, #5]
34187b2a:	011a      	lsls	r2, r3, #4
34187b2c:	68fb      	ldr	r3, [r7, #12]
34187b2e:	681b      	ldr	r3, [r3, #0]
34187b30:	430a      	orrs	r2, r1
34187b32:	f8c3 2848 	str.w	r2, [r3, #2120]	@ 0x848
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187b36:	2300      	movs	r3, #0
34187b38:	e000      	b.n	34187b3c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
    return HAL_ERROR;
34187b3a:	2301      	movs	r3, #1
}
34187b3c:	4618      	mov	r0, r3
34187b3e:	3714      	adds	r7, #20
34187b40:	46bd      	mov	sp, r7
34187b42:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b46:	4770      	bx	lr

34187b48 <HAL_DCMIPP_PIPE_EnableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187b48:	b480      	push	{r7}
34187b4a:	b083      	sub	sp, #12
34187b4c:	af00      	add	r7, sp, #0
34187b4e:	6078      	str	r0, [r7, #4]
34187b50:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187b52:	687b      	ldr	r3, [r7, #4]
34187b54:	2b00      	cmp	r3, #0
34187b56:	d101      	bne.n	34187b5c <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
  {
    return HAL_ERROR;
34187b58:	2301      	movs	r3, #1
34187b5a:	e00f      	b.n	34187b7c <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187b5c:	683b      	ldr	r3, [r7, #0]
34187b5e:	2b01      	cmp	r3, #1
34187b60:	d10b      	bne.n	34187b7a <HAL_DCMIPP_PIPE_EnableISPExposure+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34187b62:	687b      	ldr	r3, [r7, #4]
34187b64:	681b      	ldr	r3, [r3, #0]
34187b66:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
34187b6a:	687b      	ldr	r3, [r7, #4]
34187b6c:	681b      	ldr	r3, [r3, #0]
34187b6e:	f042 0201 	orr.w	r2, r2, #1
34187b72:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187b76:	2300      	movs	r3, #0
34187b78:	e000      	b.n	34187b7c <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
    return HAL_ERROR;
34187b7a:	2301      	movs	r3, #1
}
34187b7c:	4618      	mov	r0, r3
34187b7e:	370c      	adds	r7, #12
34187b80:	46bd      	mov	sp, r7
34187b82:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b86:	4770      	bx	lr

34187b88 <HAL_DCMIPP_PIPE_DisableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187b88:	b480      	push	{r7}
34187b8a:	b083      	sub	sp, #12
34187b8c:	af00      	add	r7, sp, #0
34187b8e:	6078      	str	r0, [r7, #4]
34187b90:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187b92:	687b      	ldr	r3, [r7, #4]
34187b94:	2b00      	cmp	r3, #0
34187b96:	d101      	bne.n	34187b9c <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
  {
    return HAL_ERROR;
34187b98:	2301      	movs	r3, #1
34187b9a:	e00f      	b.n	34187bbc <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187b9c:	683b      	ldr	r3, [r7, #0]
34187b9e:	2b01      	cmp	r3, #1
34187ba0:	d10b      	bne.n	34187bba <HAL_DCMIPP_PIPE_DisableISPExposure+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34187ba2:	687b      	ldr	r3, [r7, #4]
34187ba4:	681b      	ldr	r3, [r3, #0]
34187ba6:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
34187baa:	687b      	ldr	r3, [r7, #4]
34187bac:	681b      	ldr	r3, [r3, #0]
34187bae:	f022 0201 	bic.w	r2, r2, #1
34187bb2:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187bb6:	2300      	movs	r3, #0
34187bb8:	e000      	b.n	34187bbc <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
    return HAL_ERROR;
34187bba:	2301      	movs	r3, #1
}
34187bbc:	4618      	mov	r0, r3
34187bbe:	370c      	adds	r7, #12
34187bc0:	46bd      	mov	sp, r7
34187bc2:	f85d 7b04 	ldr.w	r7, [sp], #4
34187bc6:	4770      	bx	lr

34187bc8 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
  * @param  pContrastConfig pointer to the DCMIPP_ContrastConfTypeDef structure that contains contrast information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_ContrastConfTypeDef *pContrastConfig)
{
34187bc8:	b480      	push	{r7}
34187bca:	b085      	sub	sp, #20
34187bcc:	af00      	add	r7, sp, #0
34187bce:	60f8      	str	r0, [r7, #12]
34187bd0:	60b9      	str	r1, [r7, #8]
34187bd2:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34187bd4:	68fb      	ldr	r3, [r7, #12]
34187bd6:	2b00      	cmp	r3, #0
34187bd8:	d002      	beq.n	34187be0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x18>
34187bda:	687b      	ldr	r3, [r7, #4]
34187bdc:	2b00      	cmp	r3, #0
34187bde:	d101      	bne.n	34187be4 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x1c>
  {
    return HAL_ERROR;
34187be0:	2301      	movs	r3, #1
34187be2:	e03b      	b.n	34187c5c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));

  if (Pipe == DCMIPP_PIPE1)
34187be4:	68bb      	ldr	r3, [r7, #8]
34187be6:	2b01      	cmp	r3, #1
34187be8:	d137      	bne.n	34187c5a <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x92>
  {

    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34187bea:	68fb      	ldr	r3, [r7, #12]
34187bec:	681b      	ldr	r3, [r3, #0]
34187bee:	f8d3 38a0 	ldr.w	r3, [r3, #2208]	@ 0x8a0
34187bf2:	f423 41fc 	bic.w	r1, r3, #32256	@ 0x7e00
34187bf6:	687b      	ldr	r3, [r7, #4]
34187bf8:	781b      	ldrb	r3, [r3, #0]
34187bfa:	025a      	lsls	r2, r3, #9
34187bfc:	68fb      	ldr	r3, [r7, #12]
34187bfe:	681b      	ldr	r3, [r3, #0]
34187c00:	430a      	orrs	r2, r1
34187c02:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
               (uint32_t)pContrastConfig->LUM_0 << DCMIPP_P1CTCR1_LUM0_Pos);

    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
34187c06:	687b      	ldr	r3, [r7, #4]
34187c08:	785b      	ldrb	r3, [r3, #1]
34187c0a:	065a      	lsls	r2, r3, #25
34187c0c:	687b      	ldr	r3, [r7, #4]
34187c0e:	789b      	ldrb	r3, [r3, #2]
34187c10:	045b      	lsls	r3, r3, #17
34187c12:	431a      	orrs	r2, r3
34187c14:	687b      	ldr	r3, [r7, #4]
34187c16:	78db      	ldrb	r3, [r3, #3]
34187c18:	025b      	lsls	r3, r3, #9
34187c1a:	ea42 0103 	orr.w	r1, r2, r3
34187c1e:	687b      	ldr	r3, [r7, #4]
34187c20:	791b      	ldrb	r3, [r3, #4]
34187c22:	005a      	lsls	r2, r3, #1
34187c24:	68fb      	ldr	r3, [r7, #12]
34187c26:	681b      	ldr	r3, [r3, #0]
34187c28:	430a      	orrs	r2, r1
34187c2a:	f8c3 28a4 	str.w	r2, [r3, #2212]	@ 0x8a4
                                           ((uint32_t)pContrastConfig->LUM_64 << DCMIPP_P1CTCR2_LUM2_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_96 << DCMIPP_P1CTCR2_LUM3_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_128 << DCMIPP_P1CTCR2_LUM4_Pos)));

    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34187c2e:	687b      	ldr	r3, [r7, #4]
34187c30:	795b      	ldrb	r3, [r3, #5]
34187c32:	065a      	lsls	r2, r3, #25
34187c34:	687b      	ldr	r3, [r7, #4]
34187c36:	799b      	ldrb	r3, [r3, #6]
34187c38:	045b      	lsls	r3, r3, #17
34187c3a:	431a      	orrs	r2, r3
34187c3c:	687b      	ldr	r3, [r7, #4]
34187c3e:	79db      	ldrb	r3, [r3, #7]
34187c40:	025b      	lsls	r3, r3, #9
34187c42:	ea42 0103 	orr.w	r1, r2, r3
34187c46:	687b      	ldr	r3, [r7, #4]
34187c48:	7a1b      	ldrb	r3, [r3, #8]
34187c4a:	005a      	lsls	r2, r3, #1
34187c4c:	68fb      	ldr	r3, [r7, #12]
34187c4e:	681b      	ldr	r3, [r3, #0]
34187c50:	430a      	orrs	r2, r1
34187c52:	f8c3 28a8 	str.w	r2, [r3, #2216]	@ 0x8a8
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187c56:	2300      	movs	r3, #0
34187c58:	e000      	b.n	34187c5c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
    return HAL_ERROR;
34187c5a:	2301      	movs	r3, #1
}
34187c5c:	4618      	mov	r0, r3
34187c5e:	3714      	adds	r7, #20
34187c60:	46bd      	mov	sp, r7
34187c62:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c66:	4770      	bx	lr

34187c68 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187c68:	b480      	push	{r7}
34187c6a:	b083      	sub	sp, #12
34187c6c:	af00      	add	r7, sp, #0
34187c6e:	6078      	str	r0, [r7, #4]
34187c70:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187c72:	687b      	ldr	r3, [r7, #4]
34187c74:	2b00      	cmp	r3, #0
34187c76:	d101      	bne.n	34187c7c <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
34187c78:	2301      	movs	r3, #1
34187c7a:	e00f      	b.n	34187c9c <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187c7c:	683b      	ldr	r3, [r7, #0]
34187c7e:	2b01      	cmp	r3, #1
34187c80:	d10b      	bne.n	34187c9a <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34187c82:	687b      	ldr	r3, [r7, #4]
34187c84:	681b      	ldr	r3, [r3, #0]
34187c86:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
34187c8a:	687b      	ldr	r3, [r7, #4]
34187c8c:	681b      	ldr	r3, [r3, #0]
34187c8e:	f042 0201 	orr.w	r2, r2, #1
34187c92:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187c96:	2300      	movs	r3, #0
34187c98:	e000      	b.n	34187c9c <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
    return HAL_ERROR;
34187c9a:	2301      	movs	r3, #1
}
34187c9c:	4618      	mov	r0, r3
34187c9e:	370c      	adds	r7, #12
34187ca0:	46bd      	mov	sp, r7
34187ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ca6:	4770      	bx	lr

34187ca8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187ca8:	b480      	push	{r7}
34187caa:	b083      	sub	sp, #12
34187cac:	af00      	add	r7, sp, #0
34187cae:	6078      	str	r0, [r7, #4]
34187cb0:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187cb2:	687b      	ldr	r3, [r7, #4]
34187cb4:	2b00      	cmp	r3, #0
34187cb6:	d101      	bne.n	34187cbc <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
34187cb8:	2301      	movs	r3, #1
34187cba:	e00f      	b.n	34187cdc <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187cbc:	683b      	ldr	r3, [r7, #0]
34187cbe:	2b01      	cmp	r3, #1
34187cc0:	d10b      	bne.n	34187cda <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34187cc2:	687b      	ldr	r3, [r7, #4]
34187cc4:	681b      	ldr	r3, [r3, #0]
34187cc6:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
34187cca:	687b      	ldr	r3, [r7, #4]
34187ccc:	681b      	ldr	r3, [r3, #0]
34187cce:	f022 0201 	bic.w	r2, r2, #1
34187cd2:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187cd6:	2300      	movs	r3, #0
34187cd8:	e000      	b.n	34187cdc <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
    return HAL_ERROR;
34187cda:	2301      	movs	r3, #1
}
34187cdc:	4618      	mov	r0, r3
34187cde:	370c      	adds	r7, #12
34187ce0:	46bd      	mov	sp, r7
34187ce2:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ce6:	4770      	bx	lr

34187ce8 <HAL_DCMIPP_PIPE_SetPitch>:
  * @param  Pipe       Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  LinePitch  the new Pitch value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPitch(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t LinePitch)
{
34187ce8:	b480      	push	{r7}
34187cea:	b085      	sub	sp, #20
34187cec:	af00      	add	r7, sp, #0
34187cee:	60f8      	str	r0, [r7, #12]
34187cf0:	60b9      	str	r1, [r7, #8]
34187cf2:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
34187cf4:	68fb      	ldr	r3, [r7, #12]
34187cf6:	2b00      	cmp	r3, #0
34187cf8:	d101      	bne.n	34187cfe <HAL_DCMIPP_PIPE_SetPitch+0x16>
  {
    return HAL_ERROR;
34187cfa:	2301      	movs	r3, #1
34187cfc:	e026      	b.n	34187d4c <HAL_DCMIPP_PIPE_SetPitch+0x64>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34187cfe:	68bb      	ldr	r3, [r7, #8]
34187d00:	2b01      	cmp	r3, #1
34187d02:	d10e      	bne.n	34187d22 <HAL_DCMIPP_PIPE_SetPitch+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
34187d04:	68fb      	ldr	r3, [r7, #12]
34187d06:	681b      	ldr	r3, [r3, #0]
34187d08:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
34187d0c:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34187d10:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34187d14:	68fa      	ldr	r2, [r7, #12]
34187d16:	6812      	ldr	r2, [r2, #0]
34187d18:	6879      	ldr	r1, [r7, #4]
34187d1a:	430b      	orrs	r3, r1
34187d1c:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
34187d20:	e013      	b.n	34187d4a <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else if (Pipe == DCMIPP_PIPE2)
34187d22:	68bb      	ldr	r3, [r7, #8]
34187d24:	2b02      	cmp	r3, #2
34187d26:	d10e      	bne.n	34187d46 <HAL_DCMIPP_PIPE_SetPitch+0x5e>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34187d28:	68fb      	ldr	r3, [r7, #12]
34187d2a:	681b      	ldr	r3, [r3, #0]
34187d2c:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
34187d30:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34187d34:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34187d38:	68fa      	ldr	r2, [r7, #12]
34187d3a:	6812      	ldr	r2, [r2, #0]
34187d3c:	6879      	ldr	r1, [r7, #4]
34187d3e:	430b      	orrs	r3, r1
34187d40:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
34187d44:	e001      	b.n	34187d4a <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else
  {
    return HAL_ERROR;
34187d46:	2301      	movs	r3, #1
34187d48:	e000      	b.n	34187d4c <HAL_DCMIPP_PIPE_SetPitch+0x64>
  }

  return HAL_OK;
34187d4a:	2300      	movs	r3, #0
}
34187d4c:	4618      	mov	r0, r3
34187d4e:	3714      	adds	r7, #20
34187d50:	46bd      	mov	sp, r7
34187d52:	f85d 7b04 	ldr.w	r7, [sp], #4
34187d56:	4770      	bx	lr

34187d58 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
  * @param  PixelPackerFormat the new Pixel Packer Format value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPixelPackerFormat(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       uint32_t PixelPackerFormat)
{
34187d58:	b480      	push	{r7}
34187d5a:	b085      	sub	sp, #20
34187d5c:	af00      	add	r7, sp, #0
34187d5e:	60f8      	str	r0, [r7, #12]
34187d60:	60b9      	str	r1, [r7, #8]
34187d62:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
34187d64:	68fb      	ldr	r3, [r7, #12]
34187d66:	2b00      	cmp	r3, #0
34187d68:	d101      	bne.n	34187d6e <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x16>
  {
    return HAL_ERROR;
34187d6a:	2301      	movs	r3, #1
34187d6c:	e022      	b.n	34187db4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34187d6e:	68bb      	ldr	r3, [r7, #8]
34187d70:	2b01      	cmp	r3, #1
34187d72:	d10c      	bne.n	34187d8e <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x36>
  {
    /* Configure the pixel packer */
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
34187d74:	68fb      	ldr	r3, [r7, #12]
34187d76:	681b      	ldr	r3, [r3, #0]
34187d78:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34187d7c:	f023 010f 	bic.w	r1, r3, #15
34187d80:	68fb      	ldr	r3, [r7, #12]
34187d82:	681b      	ldr	r3, [r3, #0]
34187d84:	687a      	ldr	r2, [r7, #4]
34187d86:	430a      	orrs	r2, r1
34187d88:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34187d8c:	e011      	b.n	34187db2 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else if (Pipe == DCMIPP_PIPE2)
34187d8e:	68bb      	ldr	r3, [r7, #8]
34187d90:	2b02      	cmp	r3, #2
34187d92:	d10c      	bne.n	34187dae <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x56>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
34187d94:	68fb      	ldr	r3, [r7, #12]
34187d96:	681b      	ldr	r3, [r3, #0]
34187d98:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
34187d9c:	f023 010f 	bic.w	r1, r3, #15
34187da0:	68fb      	ldr	r3, [r7, #12]
34187da2:	681b      	ldr	r3, [r3, #0]
34187da4:	687a      	ldr	r2, [r7, #4]
34187da6:	430a      	orrs	r2, r1
34187da8:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34187dac:	e001      	b.n	34187db2 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else
  {
    return HAL_ERROR;
34187dae:	2301      	movs	r3, #1
34187db0:	e000      	b.n	34187db4 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  }

  return HAL_OK;
34187db2:	2300      	movs	r3, #0
}
34187db4:	4618      	mov	r0, r3
34187db6:	3714      	adds	r7, #20
34187db8:	46bd      	mov	sp, r7
34187dba:	f85d 7b04 	ldr.w	r7, [sp], #4
34187dbe:	4770      	bx	lr

34187dc0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187dc0:	b480      	push	{r7}
34187dc2:	b083      	sub	sp, #12
34187dc4:	af00      	add	r7, sp, #0
34187dc6:	6078      	str	r0, [r7, #4]
34187dc8:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
34187dca:	687b      	ldr	r3, [r7, #4]
34187dcc:	2b00      	cmp	r3, #0
34187dce:	d101      	bne.n	34187dd4 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
34187dd0:	2301      	movs	r3, #1
34187dd2:	e023      	b.n	34187e1c <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187dd4:	687b      	ldr	r3, [r7, #4]
34187dd6:	791b      	ldrb	r3, [r3, #4]
34187dd8:	b2db      	uxtb	r3, r3
34187dda:	2b02      	cmp	r3, #2
34187ddc:	d11d      	bne.n	34187e1a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
34187dde:	683b      	ldr	r3, [r7, #0]
34187de0:	2b01      	cmp	r3, #1
34187de2:	d10a      	bne.n	34187dfa <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x3a>
    {
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34187de4:	687b      	ldr	r3, [r7, #4]
34187de6:	681b      	ldr	r3, [r3, #0]
34187de8:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34187dec:	687b      	ldr	r3, [r7, #4]
34187dee:	681b      	ldr	r3, [r3, #0]
34187df0:	f042 0210 	orr.w	r2, r2, #16
34187df4:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34187df8:	e00f      	b.n	34187e1a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
34187dfa:	683b      	ldr	r3, [r7, #0]
34187dfc:	2b02      	cmp	r3, #2
34187dfe:	d10a      	bne.n	34187e16 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x56>
    {
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34187e00:	687b      	ldr	r3, [r7, #4]
34187e02:	681b      	ldr	r3, [r3, #0]
34187e04:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
34187e08:	687b      	ldr	r3, [r7, #4]
34187e0a:	681b      	ldr	r3, [r3, #0]
34187e0c:	f042 0210 	orr.w	r2, r2, #16
34187e10:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34187e14:	e001      	b.n	34187e1a <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
34187e16:	2301      	movs	r3, #1
34187e18:	e000      	b.n	34187e1c <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
34187e1a:	2300      	movs	r3, #0
}
34187e1c:	4618      	mov	r0, r3
34187e1e:	370c      	adds	r7, #12
34187e20:	46bd      	mov	sp, r7
34187e22:	f85d 7b04 	ldr.w	r7, [sp], #4
34187e26:	4770      	bx	lr

34187e28 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187e28:	b480      	push	{r7}
34187e2a:	b083      	sub	sp, #12
34187e2c:	af00      	add	r7, sp, #0
34187e2e:	6078      	str	r0, [r7, #4]
34187e30:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
34187e32:	687b      	ldr	r3, [r7, #4]
34187e34:	2b00      	cmp	r3, #0
34187e36:	d101      	bne.n	34187e3c <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
34187e38:	2301      	movs	r3, #1
34187e3a:	e023      	b.n	34187e84 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187e3c:	687b      	ldr	r3, [r7, #4]
34187e3e:	791b      	ldrb	r3, [r3, #4]
34187e40:	b2db      	uxtb	r3, r3
34187e42:	2b02      	cmp	r3, #2
34187e44:	d11d      	bne.n	34187e82 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
34187e46:	683b      	ldr	r3, [r7, #0]
34187e48:	2b01      	cmp	r3, #1
34187e4a:	d10a      	bne.n	34187e62 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x3a>
    {
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34187e4c:	687b      	ldr	r3, [r7, #4]
34187e4e:	681b      	ldr	r3, [r3, #0]
34187e50:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34187e54:	687b      	ldr	r3, [r7, #4]
34187e56:	681b      	ldr	r3, [r3, #0]
34187e58:	f022 0210 	bic.w	r2, r2, #16
34187e5c:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34187e60:	e00f      	b.n	34187e82 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
34187e62:	683b      	ldr	r3, [r7, #0]
34187e64:	2b02      	cmp	r3, #2
34187e66:	d10a      	bne.n	34187e7e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x56>
    {
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34187e68:	687b      	ldr	r3, [r7, #4]
34187e6a:	681b      	ldr	r3, [r3, #0]
34187e6c:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
34187e70:	687b      	ldr	r3, [r7, #4]
34187e72:	681b      	ldr	r3, [r3, #0]
34187e74:	f022 0210 	bic.w	r2, r2, #16
34187e78:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34187e7c:	e001      	b.n	34187e82 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
34187e7e:	2301      	movs	r3, #1
34187e80:	e000      	b.n	34187e84 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
34187e82:	2300      	movs	r3, #0
}
34187e84:	4618      	mov	r0, r3
34187e86:	370c      	adds	r7, #12
34187e88:	46bd      	mov	sp, r7
34187e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34187e8e:	4770      	bx	lr

34187e90 <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_CSI_EnableShare(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187e90:	b480      	push	{r7}
34187e92:	b085      	sub	sp, #20
34187e94:	af00      	add	r7, sp, #0
34187e96:	6078      	str	r0, [r7, #4]
34187e98:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  uint32_t tmp1;
  uint32_t tmp2;

  if (Pipe == DCMIPP_PIPE2)
34187e9a:	683b      	ldr	r3, [r7, #0]
34187e9c:	2b02      	cmp	r3, #2
34187e9e:	d11d      	bne.n	34187edc <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4c>
  {
    /* check that Pipe1 and pipe2 are disabled */
    tmp1 = hdcmipp->Instance->P2FSCR;
34187ea0:	687b      	ldr	r3, [r7, #4]
34187ea2:	681b      	ldr	r3, [r3, #0]
34187ea4:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
34187ea8:	60fb      	str	r3, [r7, #12]
    tmp2 = hdcmipp->Instance->P1FSCR;
34187eaa:	687b      	ldr	r3, [r7, #4]
34187eac:	681b      	ldr	r3, [r3, #0]
34187eae:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
34187eb2:	60bb      	str	r3, [r7, #8]
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
34187eb4:	68fb      	ldr	r3, [r7, #12]
34187eb6:	2b00      	cmp	r3, #0
34187eb8:	db02      	blt.n	34187ec0 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x30>
34187eba:	68bb      	ldr	r3, [r7, #8]
34187ebc:	2b00      	cmp	r3, #0
34187ebe:	da01      	bge.n	34187ec4 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>
    {
      return HAL_ERROR;
34187ec0:	2301      	movs	r3, #1
34187ec2:	e00c      	b.n	34187ede <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    }
    else
    {
      /* Pipe2 receives the same data as Pipe1 */
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34187ec4:	687b      	ldr	r3, [r7, #4]
34187ec6:	681b      	ldr	r3, [r3, #0]
34187ec8:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34187ecc:	687b      	ldr	r3, [r7, #4]
34187ece:	681b      	ldr	r3, [r3, #0]
34187ed0:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34187ed4:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187ed8:	2300      	movs	r3, #0
34187eda:	e000      	b.n	34187ede <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    return HAL_ERROR;
34187edc:	2301      	movs	r3, #1
}
34187ede:	4618      	mov	r0, r3
34187ee0:	3714      	adds	r7, #20
34187ee2:	46bd      	mov	sp, r7
34187ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ee8:	4770      	bx	lr

34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
  * @param  pCounter pointer to receive the accumulated value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                     uint8_t ModuleID, uint32_t *pCounter)
{
34187eea:	b480      	push	{r7}
34187eec:	b085      	sub	sp, #20
34187eee:	af00      	add	r7, sp, #0
34187ef0:	60f8      	str	r0, [r7, #12]
34187ef2:	60b9      	str	r1, [r7, #8]
34187ef4:	603b      	str	r3, [r7, #0]
34187ef6:	4613      	mov	r3, r2
34187ef8:	71fb      	strb	r3, [r7, #7]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
34187efa:	68fb      	ldr	r3, [r7, #12]
34187efc:	2b00      	cmp	r3, #0
34187efe:	d002      	beq.n	34187f06 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x1c>
34187f00:	683b      	ldr	r3, [r7, #0]
34187f02:	2b00      	cmp	r3, #0
34187f04:	d101      	bne.n	34187f0a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x20>
  {
    return HAL_ERROR;
34187f06:	2301      	movs	r3, #1
34187f08:	e02b      	b.n	34187f62 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34187f0a:	68bb      	ldr	r3, [r7, #8]
34187f0c:	2b01      	cmp	r3, #1
34187f0e:	d124      	bne.n	34187f5a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x70>
  {
    switch (ModuleID)
34187f10:	79fb      	ldrb	r3, [r7, #7]
34187f12:	2b03      	cmp	r3, #3
34187f14:	d018      	beq.n	34187f48 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5e>
34187f16:	2b03      	cmp	r3, #3
34187f18:	dc21      	bgt.n	34187f5e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
34187f1a:	2b01      	cmp	r3, #1
34187f1c:	d002      	beq.n	34187f24 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
34187f1e:	2b02      	cmp	r3, #2
34187f20:	d009      	beq.n	34187f36 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        break;
      case DCMIPP_STATEXT_MODULE3:
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
        break;
      default:
        break;
34187f22:	e01c      	b.n	34187f5e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34187f24:	68fb      	ldr	r3, [r7, #12]
34187f26:	681b      	ldr	r3, [r3, #0]
34187f28:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
34187f2c:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34187f30:	683b      	ldr	r3, [r7, #0]
34187f32:	601a      	str	r2, [r3, #0]
        break;
34187f34:	e014      	b.n	34187f60 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34187f36:	68fb      	ldr	r3, [r7, #12]
34187f38:	681b      	ldr	r3, [r3, #0]
34187f3a:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
34187f3e:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34187f42:	683b      	ldr	r3, [r7, #0]
34187f44:	601a      	str	r2, [r3, #0]
        break;
34187f46:	e00b      	b.n	34187f60 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34187f48:	68fb      	ldr	r3, [r7, #12]
34187f4a:	681b      	ldr	r3, [r3, #0]
34187f4c:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
34187f50:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34187f54:	683b      	ldr	r3, [r7, #0]
34187f56:	601a      	str	r2, [r3, #0]
        break;
34187f58:	e002      	b.n	34187f60 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
    }
  }
  else
  {
    return HAL_ERROR;
34187f5a:	2301      	movs	r3, #1
34187f5c:	e001      	b.n	34187f62 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>
        break;
34187f5e:	bf00      	nop
  }

  return HAL_OK;
34187f60:	2300      	movs	r3, #0
}
34187f62:	4618      	mov	r0, r3
34187f64:	3714      	adds	r7, #20
34187f66:	46bd      	mov	sp, r7
34187f68:	f85d 7b04 	ldr.w	r7, [sp], #4
34187f6c:	4770      	bx	lr

34187f6e <HAL_DCMIPP_PIPE_GetISPExposureConfig>:
  *                         filled with the exposure configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPExposureConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                          DCMIPP_ExposureConfTypeDef *pExposureConfig)
{
34187f6e:	b480      	push	{r7}
34187f70:	b087      	sub	sp, #28
34187f72:	af00      	add	r7, sp, #0
34187f74:	60f8      	str	r0, [r7, #12]
34187f76:	60b9      	str	r1, [r7, #8]
34187f78:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187f7a:	68bb      	ldr	r3, [r7, #8]
34187f7c:	2b01      	cmp	r3, #1
34187f7e:	d130      	bne.n	34187fe2 <HAL_DCMIPP_PIPE_GetISPExposureConfig+0x74>
  {
    tmp = READ_REG(hdcmipp->Instance->P1EXCR2);
34187f80:	68fb      	ldr	r3, [r7, #12]
34187f82:	681b      	ldr	r3, [r3, #0]
34187f84:	f8d3 3848 	ldr.w	r3, [r3, #2120]	@ 0x848
34187f88:	617b      	str	r3, [r7, #20]

    pExposureConfig->MultiplierBlue  = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTB) >> DCMIPP_P1EXCR2_MULTB_Pos);
34187f8a:	697b      	ldr	r3, [r7, #20]
34187f8c:	091b      	lsrs	r3, r3, #4
34187f8e:	b2da      	uxtb	r2, r3
34187f90:	687b      	ldr	r3, [r7, #4]
34187f92:	715a      	strb	r2, [r3, #5]
    pExposureConfig->ShiftBlue       = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFB) >> DCMIPP_P1EXCR2_SHFB_Pos);
34187f94:	697b      	ldr	r3, [r7, #20]
34187f96:	0b1b      	lsrs	r3, r3, #12
34187f98:	b2db      	uxtb	r3, r3
34187f9a:	f003 0307 	and.w	r3, r3, #7
34187f9e:	b2da      	uxtb	r2, r3
34187fa0:	687b      	ldr	r3, [r7, #4]
34187fa2:	711a      	strb	r2, [r3, #4]
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
34187fa4:	697b      	ldr	r3, [r7, #20]
34187fa6:	0f1b      	lsrs	r3, r3, #28
34187fa8:	b2db      	uxtb	r3, r3
34187faa:	f003 0307 	and.w	r3, r3, #7
34187fae:	b2da      	uxtb	r2, r3
34187fb0:	687b      	ldr	r3, [r7, #4]
34187fb2:	709a      	strb	r2, [r3, #2]
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
34187fb4:	697b      	ldr	r3, [r7, #20]
34187fb6:	0d1b      	lsrs	r3, r3, #20
34187fb8:	b2da      	uxtb	r2, r3
34187fba:	687b      	ldr	r3, [r7, #4]
34187fbc:	70da      	strb	r2, [r3, #3]

    tmp = READ_REG(hdcmipp->Instance->P1EXCR1);
34187fbe:	68fb      	ldr	r3, [r7, #12]
34187fc0:	681b      	ldr	r3, [r3, #0]
34187fc2:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
34187fc6:	617b      	str	r3, [r7, #20]

    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
34187fc8:	697b      	ldr	r3, [r7, #20]
34187fca:	0d1b      	lsrs	r3, r3, #20
34187fcc:	b2da      	uxtb	r2, r3
34187fce:	687b      	ldr	r3, [r7, #4]
34187fd0:	705a      	strb	r2, [r3, #1]
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
34187fd2:	697b      	ldr	r3, [r7, #20]
34187fd4:	0f1b      	lsrs	r3, r3, #28
34187fd6:	b2db      	uxtb	r3, r3
34187fd8:	f003 0307 	and.w	r3, r3, #7
34187fdc:	b2da      	uxtb	r2, r3
34187fde:	687b      	ldr	r3, [r7, #4]
34187fe0:	701a      	strb	r2, [r3, #0]
  }
}
34187fe2:	bf00      	nop
34187fe4:	371c      	adds	r7, #28
34187fe6:	46bd      	mov	sp, r7
34187fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
34187fec:	4770      	bx	lr

34187fee <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  *                                 filled with the color conversion configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPColorConversionConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                 DCMIPP_ColorConversionConfTypeDef *pColorConversionConfig)
{
34187fee:	b480      	push	{r7}
34187ff0:	b087      	sub	sp, #28
34187ff2:	af00      	add	r7, sp, #0
34187ff4:	60f8      	str	r0, [r7, #12]
34187ff6:	60b9      	str	r1, [r7, #8]
34187ff8:	607a      	str	r2, [r7, #4]
  uint16_t tmp;

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34187ffa:	68bb      	ldr	r3, [r7, #8]
34187ffc:	2b01      	cmp	r3, #1
34187ffe:	f040 8146 	bne.w	3418828e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x2a0>
  {
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34188002:	68fb      	ldr	r3, [r7, #12]
34188004:	681b      	ldr	r3, [r3, #0]
34188006:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
3418800a:	82fb      	strh	r3, [r7, #22]

    UNUSED(tmp);

    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
                                                 ? ENABLE : DISABLE;
3418800c:	8afb      	ldrh	r3, [r7, #22]
3418800e:	089b      	lsrs	r3, r3, #2
34188010:	b2db      	uxtb	r3, r3
34188012:	f003 0301 	and.w	r3, r3, #1
34188016:	b2da      	uxtb	r2, r3
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34188018:	687b      	ldr	r3, [r7, #4]
3418801a:	701a      	strb	r2, [r3, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
3418801c:	8afb      	ldrh	r3, [r7, #22]
3418801e:	b2db      	uxtb	r3, r3
34188020:	f003 0302 	and.w	r3, r3, #2
34188024:	b2da      	uxtb	r2, r3
34188026:	687b      	ldr	r3, [r7, #4]
34188028:	705a      	strb	r2, [r3, #1]

    /* Get Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
3418802a:	68fb      	ldr	r3, [r7, #12]
3418802c:	681b      	ldr	r3, [r3, #0]
3418802e:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
34188032:	0c1b      	lsrs	r3, r3, #16
34188034:	b29b      	uxth	r3, r3
34188036:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418803a:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
3418803c:	8afb      	ldrh	r3, [r7, #22]
3418803e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34188042:	2b00      	cmp	r3, #0
34188044:	d007      	beq.n	34188056 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x68>
34188046:	8afb      	ldrh	r3, [r7, #22]
34188048:	ea6f 5343 	mvn.w	r3, r3, lsl #21
3418804c:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34188050:	b29b      	uxth	r3, r3
34188052:	b21b      	sxth	r3, r3
34188054:	e001      	b.n	3418805a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x6c>
34188056:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418805a:	687a      	ldr	r2, [r7, #4]
3418805c:	8093      	strh	r3, [r2, #4]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
3418805e:	68fb      	ldr	r3, [r7, #12]
34188060:	681b      	ldr	r3, [r3, #0]
34188062:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
34188066:	b29b      	uxth	r3, r3
34188068:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418806c:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
3418806e:	8afb      	ldrh	r3, [r7, #22]
34188070:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34188074:	2b00      	cmp	r3, #0
34188076:	d007      	beq.n	34188088 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9a>
34188078:	8afb      	ldrh	r3, [r7, #22]
3418807a:	ea6f 5343 	mvn.w	r3, r3, lsl #21
3418807e:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34188082:	b29b      	uxth	r3, r3
34188084:	b21b      	sxth	r3, r3
34188086:	e001      	b.n	3418808c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9e>
34188088:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418808c:	687a      	ldr	r2, [r7, #4]
3418808e:	8053      	strh	r3, [r2, #2]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34188090:	68fb      	ldr	r3, [r7, #12]
34188092:	681b      	ldr	r3, [r3, #0]
34188094:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
34188098:	0c1b      	lsrs	r3, r3, #16
3418809a:	b29b      	uxth	r3, r3
3418809c:	f3c3 0309 	ubfx	r3, r3, #0, #10
341880a0:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
341880a2:	8afb      	ldrh	r3, [r7, #22]
341880a4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341880a8:	2b00      	cmp	r3, #0
341880aa:	d007      	beq.n	341880bc <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xce>
341880ac:	8afb      	ldrh	r3, [r7, #22]
341880ae:	ea6f 5383 	mvn.w	r3, r3, lsl #22
341880b2:	ea6f 5393 	mvn.w	r3, r3, lsr #22
341880b6:	b29b      	uxth	r3, r3
341880b8:	b21b      	sxth	r3, r3
341880ba:	e001      	b.n	341880c0 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xd2>
341880bc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341880c0:	687a      	ldr	r2, [r7, #4]
341880c2:	8113      	strh	r3, [r2, #8]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
341880c4:	68fb      	ldr	r3, [r7, #12]
341880c6:	681b      	ldr	r3, [r3, #0]
341880c8:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
341880cc:	b29b      	uxth	r3, r3
341880ce:	f3c3 030a 	ubfx	r3, r3, #0, #11
341880d2:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
341880d4:	8afb      	ldrh	r3, [r7, #22]
341880d6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341880da:	2b00      	cmp	r3, #0
341880dc:	d007      	beq.n	341880ee <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x100>
341880de:	8afb      	ldrh	r3, [r7, #22]
341880e0:	ea6f 5343 	mvn.w	r3, r3, lsl #21
341880e4:	ea6f 5353 	mvn.w	r3, r3, lsr #21
341880e8:	b29b      	uxth	r3, r3
341880ea:	b21b      	sxth	r3, r3
341880ec:	e001      	b.n	341880f2 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x104>
341880ee:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341880f2:	687a      	ldr	r2, [r7, #4]
341880f4:	80d3      	strh	r3, [r2, #6]

    /* Get Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
341880f6:	68fb      	ldr	r3, [r7, #12]
341880f8:	681b      	ldr	r3, [r3, #0]
341880fa:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
341880fe:	0c1b      	lsrs	r3, r3, #16
34188100:	b29b      	uxth	r3, r3
34188102:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188106:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34188108:	8afb      	ldrh	r3, [r7, #22]
3418810a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418810e:	2b00      	cmp	r3, #0
34188110:	d007      	beq.n	34188122 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x134>
34188112:	8afb      	ldrh	r3, [r7, #22]
34188114:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34188118:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418811c:	b29b      	uxth	r3, r3
3418811e:	b21b      	sxth	r3, r3
34188120:	e001      	b.n	34188126 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>
34188122:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34188126:	687a      	ldr	r2, [r7, #4]
34188128:	8193      	strh	r3, [r2, #12]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
3418812a:	68fb      	ldr	r3, [r7, #12]
3418812c:	681b      	ldr	r3, [r3, #0]
3418812e:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
34188132:	b29b      	uxth	r3, r3
34188134:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188138:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
3418813a:	8afb      	ldrh	r3, [r7, #22]
3418813c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34188140:	2b00      	cmp	r3, #0
34188142:	d007      	beq.n	34188154 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x166>
34188144:	8afb      	ldrh	r3, [r7, #22]
34188146:	ea6f 5343 	mvn.w	r3, r3, lsl #21
3418814a:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418814e:	b29b      	uxth	r3, r3
34188150:	b21b      	sxth	r3, r3
34188152:	e001      	b.n	34188158 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x16a>
34188154:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34188158:	687a      	ldr	r2, [r7, #4]
3418815a:	8153      	strh	r3, [r2, #10]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
3418815c:	68fb      	ldr	r3, [r7, #12]
3418815e:	681b      	ldr	r3, [r3, #0]
34188160:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
34188164:	0c1b      	lsrs	r3, r3, #16
34188166:	b29b      	uxth	r3, r3
34188168:	f3c3 0309 	ubfx	r3, r3, #0, #10
3418816c:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
3418816e:	8afb      	ldrh	r3, [r7, #22]
34188170:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34188174:	2b00      	cmp	r3, #0
34188176:	d007      	beq.n	34188188 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19a>
34188178:	8afb      	ldrh	r3, [r7, #22]
3418817a:	ea6f 5383 	mvn.w	r3, r3, lsl #22
3418817e:	ea6f 5393 	mvn.w	r3, r3, lsr #22
34188182:	b29b      	uxth	r3, r3
34188184:	b21b      	sxth	r3, r3
34188186:	e001      	b.n	3418818c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19e>
34188188:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418818c:	687a      	ldr	r2, [r7, #4]
3418818e:	8213      	strh	r3, [r2, #16]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34188190:	68fb      	ldr	r3, [r7, #12]
34188192:	681b      	ldr	r3, [r3, #0]
34188194:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
34188198:	b29b      	uxth	r3, r3
3418819a:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418819e:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
341881a0:	8afb      	ldrh	r3, [r7, #22]
341881a2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341881a6:	2b00      	cmp	r3, #0
341881a8:	d007      	beq.n	341881ba <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1cc>
341881aa:	8afb      	ldrh	r3, [r7, #22]
341881ac:	ea6f 5343 	mvn.w	r3, r3, lsl #21
341881b0:	ea6f 5353 	mvn.w	r3, r3, lsr #21
341881b4:	b29b      	uxth	r3, r3
341881b6:	b21b      	sxth	r3, r3
341881b8:	e001      	b.n	341881be <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1d0>
341881ba:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341881be:	687a      	ldr	r2, [r7, #4]
341881c0:	81d3      	strh	r3, [r2, #14]

    /* Get Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
341881c2:	68fb      	ldr	r3, [r7, #12]
341881c4:	681b      	ldr	r3, [r3, #0]
341881c6:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
341881ca:	0c1b      	lsrs	r3, r3, #16
341881cc:	b29b      	uxth	r3, r3
341881ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
341881d2:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
341881d4:	8afb      	ldrh	r3, [r7, #22]
341881d6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341881da:	2b00      	cmp	r3, #0
341881dc:	d007      	beq.n	341881ee <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x200>
341881de:	8afb      	ldrh	r3, [r7, #22]
341881e0:	ea6f 5383 	mvn.w	r3, r3, lsl #22
341881e4:	ea6f 5393 	mvn.w	r3, r3, lsr #22
341881e8:	b29b      	uxth	r3, r3
341881ea:	b21b      	sxth	r3, r3
341881ec:	e001      	b.n	341881f2 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x204>
341881ee:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341881f2:	687a      	ldr	r2, [r7, #4]
341881f4:	8313      	strh	r3, [r2, #24]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
341881f6:	68fb      	ldr	r3, [r7, #12]
341881f8:	681b      	ldr	r3, [r3, #0]
341881fa:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
341881fe:	b29b      	uxth	r3, r3
34188200:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188204:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34188206:	8afb      	ldrh	r3, [r7, #22]
34188208:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418820c:	2b00      	cmp	r3, #0
3418820e:	d007      	beq.n	34188220 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x232>
34188210:	8afb      	ldrh	r3, [r7, #22]
34188212:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34188216:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418821a:	b29b      	uxth	r3, r3
3418821c:	b21b      	sxth	r3, r3
3418821e:	e001      	b.n	34188224 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x236>
34188220:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34188224:	687a      	ldr	r2, [r7, #4]
34188226:	82d3      	strh	r3, [r2, #22]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34188228:	68fb      	ldr	r3, [r7, #12]
3418822a:	681b      	ldr	r3, [r3, #0]
3418822c:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
34188230:	0c1b      	lsrs	r3, r3, #16
34188232:	b29b      	uxth	r3, r3
34188234:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188238:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
3418823a:	8afb      	ldrh	r3, [r7, #22]
3418823c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34188240:	2b00      	cmp	r3, #0
34188242:	d007      	beq.n	34188254 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x266>
34188244:	8afb      	ldrh	r3, [r7, #22]
34188246:	ea6f 5343 	mvn.w	r3, r3, lsl #21
3418824a:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418824e:	b29b      	uxth	r3, r3
34188250:	b21b      	sxth	r3, r3
34188252:	e001      	b.n	34188258 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x26a>
34188254:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34188258:	687a      	ldr	r2, [r7, #4]
3418825a:	8293      	strh	r3, [r2, #20]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
3418825c:	68fb      	ldr	r3, [r7, #12]
3418825e:	681b      	ldr	r3, [r3, #0]
34188260:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
34188264:	b29b      	uxth	r3, r3
34188266:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418826a:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
3418826c:	8afb      	ldrh	r3, [r7, #22]
3418826e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34188272:	2b00      	cmp	r3, #0
34188274:	d007      	beq.n	34188286 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x298>
34188276:	8afb      	ldrh	r3, [r7, #22]
34188278:	ea6f 5343 	mvn.w	r3, r3, lsl #21
3418827c:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34188280:	b29b      	uxth	r3, r3
34188282:	b21b      	sxth	r3, r3
34188284:	e001      	b.n	3418828a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x29c>
34188286:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418828a:	687a      	ldr	r2, [r7, #4]
3418828c:	8253      	strh	r3, [r2, #18]
  }
}
3418828e:	bf00      	nop
34188290:	371c      	adds	r7, #28
34188292:	46bd      	mov	sp, r7
34188294:	f85d 7b04 	ldr.w	r7, [sp], #4
34188298:	4770      	bx	lr

3418829a <HAL_DCMIPP_PIPE_IsEnabledISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPExposure(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418829a:	b480      	push	{r7}
3418829c:	b083      	sub	sp, #12
3418829e:	af00      	add	r7, sp, #0
341882a0:	6078      	str	r0, [r7, #4]
341882a2:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341882a4:	683b      	ldr	r3, [r7, #0]
341882a6:	2b01      	cmp	r3, #1
341882a8:	d10b      	bne.n	341882c2 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE) == DCMIPP_P1EXCR1_ENABLE) ? 1U : 0U);
341882aa:	687b      	ldr	r3, [r7, #4]
341882ac:	681b      	ldr	r3, [r3, #0]
341882ae:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
341882b2:	f003 0301 	and.w	r3, r3, #1
341882b6:	2b01      	cmp	r3, #1
341882b8:	d101      	bne.n	341882be <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x24>
341882ba:	2301      	movs	r3, #1
341882bc:	e002      	b.n	341882c4 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x2a>
341882be:	2300      	movs	r3, #0
341882c0:	e000      	b.n	341882c4 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
341882c2:	2300      	movs	r3, #0
  }
}
341882c4:	4618      	mov	r0, r3
341882c6:	370c      	adds	r7, #12
341882c8:	46bd      	mov	sp, r7
341882ca:	f85d 7b04 	ldr.w	r7, [sp], #4
341882ce:	4770      	bx	lr

341882d0 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Pipe to be checked
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341882d0:	b480      	push	{r7}
341882d2:	b083      	sub	sp, #12
341882d4:	af00      	add	r7, sp, #0
341882d6:	6078      	str	r0, [r7, #4]
341882d8:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341882da:	683b      	ldr	r3, [r7, #0]
341882dc:	2b01      	cmp	r3, #1
341882de:	d10b      	bne.n	341882f8 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
341882e0:	687b      	ldr	r3, [r7, #4]
341882e2:	681b      	ldr	r3, [r3, #0]
341882e4:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
341882e8:	f003 0301 	and.w	r3, r3, #1
341882ec:	2b01      	cmp	r3, #1
341882ee:	d101      	bne.n	341882f4 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x24>
341882f0:	2301      	movs	r3, #1
341882f2:	e002      	b.n	341882fa <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
341882f4:	2300      	movs	r3, #0
341882f6:	e000      	b.n	341882fa <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
341882f8:	2300      	movs	r3, #0
  }
}
341882fa:	4618      	mov	r0, r3
341882fc:	370c      	adds	r7, #12
341882fe:	46bd      	mov	sp, r7
34188300:	f85d 7b04 	ldr.w	r7, [sp], #4
34188304:	4770      	bx	lr

34188306 <HAL_DCMIPP_GetState>:
  * @brief  Return the DCMIPP state
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL state
  */
HAL_DCMIPP_StateTypeDef HAL_DCMIPP_GetState(const DCMIPP_HandleTypeDef *hdcmipp)
{
34188306:	b480      	push	{r7}
34188308:	b083      	sub	sp, #12
3418830a:	af00      	add	r7, sp, #0
3418830c:	6078      	str	r0, [r7, #4]
  return hdcmipp->State;
3418830e:	687b      	ldr	r3, [r7, #4]
34188310:	791b      	ldrb	r3, [r3, #4]
34188312:	b2db      	uxtb	r3, r3
}
34188314:	4618      	mov	r0, r3
34188316:	370c      	adds	r7, #12
34188318:	46bd      	mov	sp, r7
3418831a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418831e:	4770      	bx	lr

34188320 <Pipe_Config>:
  * @param  pPipeConfig pointer to the DCMIPP_PipeConfTypeDef structure that contains
  *                     the configuration information for the pipe.
  * @retval None
  */
static void Pipe_Config(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
34188320:	b480      	push	{r7}
34188322:	b085      	sub	sp, #20
34188324:	af00      	add	r7, sp, #0
34188326:	60f8      	str	r0, [r7, #12]
34188328:	60b9      	str	r1, [r7, #8]
3418832a:	607a      	str	r2, [r7, #4]
  if (Pipe == DCMIPP_PIPE0)
3418832c:	68bb      	ldr	r3, [r7, #8]
3418832e:	2b00      	cmp	r3, #0
34188330:	d10d      	bne.n	3418834e <Pipe_Config+0x2e>
  {
    /* Configure Pipe0 */
    /* Configure Frame Rate */
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34188332:	68fb      	ldr	r3, [r7, #12]
34188334:	681b      	ldr	r3, [r3, #0]
34188336:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418833a:	f023 0103 	bic.w	r1, r3, #3
3418833e:	687b      	ldr	r3, [r7, #4]
34188340:	681a      	ldr	r2, [r3, #0]
34188342:	68fb      	ldr	r3, [r7, #12]
34188344:	681b      	ldr	r3, [r3, #0]
34188346:	430a      	orrs	r2, r1
34188348:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Configure Pixel Pipe Pitch */
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
               pPipeConfig->PixelPipePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
  }
}
3418834c:	e081      	b.n	34188452 <Pipe_Config+0x132>
  else if (Pipe == DCMIPP_PIPE1)
3418834e:	68bb      	ldr	r3, [r7, #8]
34188350:	2b01      	cmp	r3, #1
34188352:	d155      	bne.n	34188400 <Pipe_Config+0xe0>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34188354:	68fb      	ldr	r3, [r7, #12]
34188356:	681b      	ldr	r3, [r3, #0]
34188358:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
3418835c:	f023 0103 	bic.w	r1, r3, #3
34188360:	687b      	ldr	r3, [r7, #4]
34188362:	681a      	ldr	r2, [r3, #0]
34188364:	68fb      	ldr	r3, [r7, #12]
34188366:	681b      	ldr	r3, [r3, #0]
34188368:	430a      	orrs	r2, r1
3418836a:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
3418836e:	68fb      	ldr	r3, [r7, #12]
34188370:	681b      	ldr	r3, [r3, #0]
34188372:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34188376:	f023 010f 	bic.w	r1, r3, #15
3418837a:	687b      	ldr	r3, [r7, #4]
3418837c:	689a      	ldr	r2, [r3, #8]
3418837e:	68fb      	ldr	r3, [r7, #12]
34188380:	681b      	ldr	r3, [r3, #0]
34188382:	430a      	orrs	r2, r1
34188384:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34188388:	68fb      	ldr	r3, [r7, #12]
3418838a:	681b      	ldr	r3, [r3, #0]
3418838c:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
34188390:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34188394:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34188398:	687a      	ldr	r2, [r7, #4]
3418839a:	6851      	ldr	r1, [r2, #4]
3418839c:	68fa      	ldr	r2, [r7, #12]
3418839e:	6812      	ldr	r2, [r2, #0]
341883a0:	430b      	orrs	r3, r1
341883a2:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
341883a6:	687b      	ldr	r3, [r7, #4]
341883a8:	689b      	ldr	r3, [r3, #8]
341883aa:	2b07      	cmp	r3, #7
341883ac:	d003      	beq.n	341883b6 <Pipe_Config+0x96>
        (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_2))
341883ae:	687b      	ldr	r3, [r7, #4]
341883b0:	689b      	ldr	r3, [r3, #8]
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
341883b2:	2b08      	cmp	r3, #8
341883b4:	d10f      	bne.n	341883d6 <Pipe_Config+0xb6>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
341883b6:	68fb      	ldr	r3, [r7, #12]
341883b8:	681b      	ldr	r3, [r3, #0]
341883ba:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
341883be:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
341883c2:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341883c6:	687a      	ldr	r2, [r7, #4]
341883c8:	6851      	ldr	r1, [r2, #4]
341883ca:	68fa      	ldr	r2, [r7, #12]
341883cc:	6812      	ldr	r2, [r2, #0]
341883ce:	430b      	orrs	r3, r1
341883d0:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
341883d4:	e03d      	b.n	34188452 <Pipe_Config+0x132>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
341883d6:	687b      	ldr	r3, [r7, #4]
341883d8:	689b      	ldr	r3, [r3, #8]
341883da:	2b09      	cmp	r3, #9
341883dc:	d139      	bne.n	34188452 <Pipe_Config+0x132>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
341883de:	68fb      	ldr	r3, [r7, #12]
341883e0:	681b      	ldr	r3, [r3, #0]
341883e2:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
341883e6:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
341883ea:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341883ee:	687a      	ldr	r2, [r7, #4]
341883f0:	6852      	ldr	r2, [r2, #4]
341883f2:	0851      	lsrs	r1, r2, #1
341883f4:	68fa      	ldr	r2, [r7, #12]
341883f6:	6812      	ldr	r2, [r2, #0]
341883f8:	430b      	orrs	r3, r1
341883fa:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
341883fe:	e028      	b.n	34188452 <Pipe_Config+0x132>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
34188400:	68fb      	ldr	r3, [r7, #12]
34188402:	681b      	ldr	r3, [r3, #0]
34188404:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34188408:	f023 0103 	bic.w	r1, r3, #3
3418840c:	687b      	ldr	r3, [r7, #4]
3418840e:	681a      	ldr	r2, [r3, #0]
34188410:	68fb      	ldr	r3, [r7, #12]
34188412:	681b      	ldr	r3, [r3, #0]
34188414:	430a      	orrs	r2, r1
34188416:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
3418841a:	68fb      	ldr	r3, [r7, #12]
3418841c:	681b      	ldr	r3, [r3, #0]
3418841e:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
34188422:	f023 010f 	bic.w	r1, r3, #15
34188426:	687b      	ldr	r3, [r7, #4]
34188428:	689a      	ldr	r2, [r3, #8]
3418842a:	68fb      	ldr	r3, [r7, #12]
3418842c:	681b      	ldr	r3, [r3, #0]
3418842e:	430a      	orrs	r2, r1
34188430:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34188434:	68fb      	ldr	r3, [r7, #12]
34188436:	681b      	ldr	r3, [r3, #0]
34188438:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
3418843c:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34188440:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34188444:	687a      	ldr	r2, [r7, #4]
34188446:	6851      	ldr	r1, [r2, #4]
34188448:	68fa      	ldr	r2, [r7, #12]
3418844a:	6812      	ldr	r2, [r2, #0]
3418844c:	430b      	orrs	r3, r1
3418844e:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
}
34188452:	bf00      	nop
34188454:	3714      	adds	r7, #20
34188456:	46bd      	mov	sp, r7
34188458:	f85d 7b04 	ldr.w	r7, [sp], #4
3418845c:	4770      	bx	lr

3418845e <DCMIPP_CSI_WritePHYReg>:
  * @param  reg_lsb specifies the testcode LSB in testdin
  * @param  val     specifies the page offset in testdin
  * @retval None
  */
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
{
3418845e:	b480      	push	{r7}
34188460:	b085      	sub	sp, #20
34188462:	af00      	add	r7, sp, #0
34188464:	60f8      	str	r0, [r7, #12]
34188466:	60b9      	str	r1, [r7, #8]
34188468:	607a      	str	r2, [r7, #4]
3418846a:	603b      	str	r3, [r7, #0]
  /* Based on sequence described at section 5.2.3.2 of DesignWave document */
  /* For writing the 4-bit testcode MSBs */
  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
3418846c:	68fb      	ldr	r3, [r7, #12]
3418846e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188472:	695b      	ldr	r3, [r3, #20]
34188474:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34188478:	68fa      	ldr	r2, [r7, #12]
3418847a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418847e:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34188480:	68fb      	ldr	r3, [r7, #12]
34188482:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188486:	691b      	ldr	r3, [r3, #16]
34188488:	f043 0301 	orr.w	r3, r3, #1
3418848c:	68fa      	ldr	r2, [r7, #12]
3418848e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34188492:	6113      	str	r3, [r2, #16]

  /* Place 0x00 in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34188494:	68fb      	ldr	r3, [r7, #12]
34188496:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418849a:	695b      	ldr	r3, [r3, #20]
3418849c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341884a0:	68fa      	ldr	r2, [r7, #12]
341884a2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341884a6:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
341884a8:	68fb      	ldr	r3, [r7, #12]
341884aa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884ae:	461a      	mov	r2, r3
341884b0:	2300      	movs	r3, #0
341884b2:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
341884b4:	68fb      	ldr	r3, [r7, #12]
341884b6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884ba:	461a      	mov	r2, r3
341884bc:	2300      	movs	r3, #0
341884be:	6153      	str	r3, [r2, #20]

  /* Place the 8-bit word corresponding to the testcode MSBs in testdin */
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
341884c0:	68fb      	ldr	r3, [r7, #12]
341884c2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884c6:	695a      	ldr	r2, [r3, #20]
341884c8:	68bb      	ldr	r3, [r7, #8]
341884ca:	b2db      	uxtb	r3, r3
341884cc:	4313      	orrs	r3, r2
341884ce:	68fa      	ldr	r2, [r7, #12]
341884d0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341884d4:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
341884d6:	68fb      	ldr	r3, [r7, #12]
341884d8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884dc:	691b      	ldr	r3, [r3, #16]
341884de:	f043 0301 	orr.w	r3, r3, #1
341884e2:	68fa      	ldr	r2, [r7, #12]
341884e4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341884e8:	6113      	str	r3, [r2, #16]

  /* For writing the 8-bit testcode LSBs */
  /* Set testclk to low */
  CLEAR_REG(hcsi->PTCR0);
341884ea:	68fb      	ldr	r3, [r7, #12]
341884ec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884f0:	461a      	mov	r2, r3
341884f2:	2300      	movs	r3, #0
341884f4:	6113      	str	r3, [r2, #16]

  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
341884f6:	68fb      	ldr	r3, [r7, #12]
341884f8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341884fc:	695b      	ldr	r3, [r3, #20]
341884fe:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34188502:	68fa      	ldr	r2, [r7, #12]
34188504:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34188508:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
3418850a:	68fb      	ldr	r3, [r7, #12]
3418850c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188510:	691b      	ldr	r3, [r3, #16]
34188512:	f043 0301 	orr.w	r3, r3, #1
34188516:	68fa      	ldr	r2, [r7, #12]
34188518:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418851c:	6113      	str	r3, [r2, #16]

  /* Place the 8-bit word test data in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
3418851e:	68fb      	ldr	r3, [r7, #12]
34188520:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188524:	695a      	ldr	r2, [r3, #20]
34188526:	687b      	ldr	r3, [r7, #4]
34188528:	b2db      	uxtb	r3, r3
3418852a:	4313      	orrs	r3, r2
3418852c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34188530:	68fa      	ldr	r2, [r7, #12]
34188532:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34188536:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
34188538:	68fb      	ldr	r3, [r7, #12]
3418853a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418853e:	461a      	mov	r2, r3
34188540:	2300      	movs	r3, #0
34188542:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
34188544:	68fb      	ldr	r3, [r7, #12]
34188546:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418854a:	461a      	mov	r2, r3
3418854c:	2300      	movs	r3, #0
3418854e:	6153      	str	r3, [r2, #20]

  /* For writing the data */
  /* Place the 8-bit word corresponding to the page offset in testdin */
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
34188550:	68fb      	ldr	r3, [r7, #12]
34188552:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188556:	695a      	ldr	r2, [r3, #20]
34188558:	683b      	ldr	r3, [r7, #0]
3418855a:	b2db      	uxtb	r3, r3
3418855c:	4313      	orrs	r3, r2
3418855e:	68fa      	ldr	r2, [r7, #12]
34188560:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34188564:	6153      	str	r3, [r2, #20]

  /* Set testclk to high (test data is programmed internally */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34188566:	68fb      	ldr	r3, [r7, #12]
34188568:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418856c:	691b      	ldr	r3, [r3, #16]
3418856e:	f043 0301 	orr.w	r3, r3, #1
34188572:	68fa      	ldr	r2, [r7, #12]
34188574:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34188578:	6113      	str	r3, [r2, #16]

  /* Finish by setting testclk to low */
  CLEAR_REG(hcsi->PTCR0);
3418857a:	68fb      	ldr	r3, [r7, #12]
3418857c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34188580:	461a      	mov	r2, r3
34188582:	2300      	movs	r3, #0
34188584:	6113      	str	r3, [r2, #16]
}
34188586:	bf00      	nop
34188588:	3714      	adds	r7, #20
3418858a:	46bd      	mov	sp, r7
3418858c:	f85d 7b04 	ldr.w	r7, [sp], #4
34188590:	4770      	bx	lr

34188592 <HAL_DMA_Abort>:
  *         is suspended while a data transfer is on-going, the current data will be transferred and the channel will be
  *         effectively suspended only after the transfer of any on-going data is finished.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *const hdma)
{
34188592:	b580      	push	{r7, lr}
34188594:	b084      	sub	sp, #16
34188596:	af00      	add	r7, sp, #0
34188598:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart =  HAL_GetTick();
3418859a:	f7fc fed9 	bl	34185350 <HAL_GetTick>
3418859e:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
341885a0:	687b      	ldr	r3, [r7, #4]
341885a2:	2b00      	cmp	r3, #0
341885a4:	d101      	bne.n	341885aa <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
341885a6:	2301      	movs	r3, #1
341885a8:	e06b      	b.n	34188682 <HAL_DMA_Abort+0xf0>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
341885aa:	687b      	ldr	r3, [r7, #4]
341885ac:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
341885b0:	b2db      	uxtb	r3, r3
341885b2:	2b02      	cmp	r3, #2
341885b4:	d008      	beq.n	341885c8 <HAL_DMA_Abort+0x36>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
341885b6:	687b      	ldr	r3, [r7, #4]
341885b8:	2220      	movs	r2, #32
341885ba:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
341885bc:	687b      	ldr	r3, [r7, #4]
341885be:	2200      	movs	r2, #0
341885c0:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    return HAL_ERROR;
341885c4:	2301      	movs	r3, #1
341885c6:	e05c      	b.n	34188682 <HAL_DMA_Abort+0xf0>
  }
  else
  {
    /* Suspend the channel */
    hdma->Instance->CCR |= DMA_CCR_SUSP;
341885c8:	687b      	ldr	r3, [r7, #4]
341885ca:	681b      	ldr	r3, [r3, #0]
341885cc:	695a      	ldr	r2, [r3, #20]
341885ce:	687b      	ldr	r3, [r7, #4]
341885d0:	681b      	ldr	r3, [r3, #0]
341885d2:	f042 0204 	orr.w	r2, r2, #4
341885d6:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_SUSPEND;
341885d8:	687b      	ldr	r3, [r7, #4]
341885da:	2205      	movs	r2, #5
341885dc:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check if the DMA Channel is suspended */
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
341885e0:	e020      	b.n	34188624 <HAL_DMA_Abort+0x92>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
341885e2:	f7fc feb5 	bl	34185350 <HAL_GetTick>
341885e6:	4602      	mov	r2, r0
341885e8:	68fb      	ldr	r3, [r7, #12]
341885ea:	1ad3      	subs	r3, r2, r3
341885ec:	2b05      	cmp	r3, #5
341885ee:	d919      	bls.n	34188624 <HAL_DMA_Abort+0x92>
      {
        /* Update the DMA channel error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
341885f0:	687b      	ldr	r3, [r7, #4]
341885f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341885f4:	f043 0210 	orr.w	r2, r3, #16
341885f8:	687b      	ldr	r3, [r7, #4]
341885fa:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_ERROR;
341885fc:	687b      	ldr	r3, [r7, #4]
341885fe:	2203      	movs	r2, #3
34188600:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
34188604:	687b      	ldr	r3, [r7, #4]
34188606:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34188608:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418860c:	2b00      	cmp	r3, #0
3418860e:	d003      	beq.n	34188618 <HAL_DMA_Abort+0x86>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34188610:	687b      	ldr	r3, [r7, #4]
34188612:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34188614:	2201      	movs	r2, #1
34188616:	731a      	strb	r2, [r3, #12]
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
34188618:	687b      	ldr	r3, [r7, #4]
3418861a:	2200      	movs	r2, #0
3418861c:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        return HAL_ERROR;
34188620:	2301      	movs	r3, #1
34188622:	e02e      	b.n	34188682 <HAL_DMA_Abort+0xf0>
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
34188624:	687b      	ldr	r3, [r7, #4]
34188626:	681b      	ldr	r3, [r3, #0]
34188628:	691b      	ldr	r3, [r3, #16]
3418862a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418862e:	2b00      	cmp	r3, #0
34188630:	d0d7      	beq.n	341885e2 <HAL_DMA_Abort+0x50>
      }
    }

    /* Reset the channel */
    hdma->Instance->CCR |= DMA_CCR_RESET;
34188632:	687b      	ldr	r3, [r7, #4]
34188634:	681b      	ldr	r3, [r3, #0]
34188636:	695a      	ldr	r2, [r3, #20]
34188638:	687b      	ldr	r3, [r7, #4]
3418863a:	681b      	ldr	r3, [r3, #0]
3418863c:	f042 0202 	orr.w	r2, r2, #2
34188640:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
34188642:	687b      	ldr	r3, [r7, #4]
34188644:	2204      	movs	r2, #4
34188646:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Clear all status flags */
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
3418864a:	687b      	ldr	r3, [r7, #4]
3418864c:	681b      	ldr	r3, [r3, #0]
3418864e:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
34188652:	60da      	str	r2, [r3, #12]
                                DMA_FLAG_TO));

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
34188654:	687b      	ldr	r3, [r7, #4]
34188656:	2201      	movs	r2, #1
34188658:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
3418865c:	687b      	ldr	r3, [r7, #4]
3418865e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34188660:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34188664:	2b00      	cmp	r3, #0
34188666:	d007      	beq.n	34188678 <HAL_DMA_Abort+0xe6>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34188668:	687b      	ldr	r3, [r7, #4]
3418866a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418866c:	2201      	movs	r2, #1
3418866e:	731a      	strb	r2, [r3, #12]

      /* Clear remaining data size to ensure loading linked-list from memory next start */
      hdma->Instance->CBR1 = 0U;
34188670:	687b      	ldr	r3, [r7, #4]
34188672:	681b      	ldr	r3, [r3, #0]
34188674:	2200      	movs	r2, #0
34188676:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
34188678:	687b      	ldr	r3, [r7, #4]
3418867a:	2200      	movs	r2, #0
3418867c:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
  }

  return HAL_OK;
34188680:	2300      	movs	r3, #0
}
34188682:	4618      	mov	r0, r3
34188684:	3710      	adds	r7, #16
34188686:	46bd      	mov	sp, r7
34188688:	bd80      	pop	{r7, pc}
	...

3418868c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
3418868c:	b480      	push	{r7}
3418868e:	b087      	sub	sp, #28
34188690:	af00      	add	r7, sp, #0
34188692:	6078      	str	r0, [r7, #4]
34188694:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34188696:	2300      	movs	r3, #0
34188698:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3418869a:	e180      	b.n	3418899e <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
3418869c:	683b      	ldr	r3, [r7, #0]
3418869e:	681a      	ldr	r2, [r3, #0]
341886a0:	2101      	movs	r1, #1
341886a2:	697b      	ldr	r3, [r7, #20]
341886a4:	fa01 f303 	lsl.w	r3, r1, r3
341886a8:	4013      	ands	r3, r2
341886aa:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
341886ac:	68fb      	ldr	r3, [r7, #12]
341886ae:	2b00      	cmp	r3, #0
341886b0:	f000 8172 	beq.w	34188998 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
341886b4:	683b      	ldr	r3, [r7, #0]
341886b6:	685b      	ldr	r3, [r3, #4]
341886b8:	f003 0303 	and.w	r3, r3, #3
341886bc:	2b01      	cmp	r3, #1
341886be:	d005      	beq.n	341886cc <HAL_GPIO_Init+0x40>
341886c0:	683b      	ldr	r3, [r7, #0]
341886c2:	685b      	ldr	r3, [r3, #4]
341886c4:	f003 0303 	and.w	r3, r3, #3
341886c8:	2b02      	cmp	r3, #2
341886ca:	d130      	bne.n	3418872e <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
341886cc:	687b      	ldr	r3, [r7, #4]
341886ce:	689b      	ldr	r3, [r3, #8]
341886d0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
341886d2:	697b      	ldr	r3, [r7, #20]
341886d4:	005b      	lsls	r3, r3, #1
341886d6:	2203      	movs	r2, #3
341886d8:	fa02 f303 	lsl.w	r3, r2, r3
341886dc:	43db      	mvns	r3, r3
341886de:	693a      	ldr	r2, [r7, #16]
341886e0:	4013      	ands	r3, r2
341886e2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
341886e4:	683b      	ldr	r3, [r7, #0]
341886e6:	68da      	ldr	r2, [r3, #12]
341886e8:	697b      	ldr	r3, [r7, #20]
341886ea:	005b      	lsls	r3, r3, #1
341886ec:	fa02 f303 	lsl.w	r3, r2, r3
341886f0:	693a      	ldr	r2, [r7, #16]
341886f2:	4313      	orrs	r3, r2
341886f4:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
341886f6:	687b      	ldr	r3, [r7, #4]
341886f8:	693a      	ldr	r2, [r7, #16]
341886fa:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
341886fc:	687b      	ldr	r3, [r7, #4]
341886fe:	685b      	ldr	r3, [r3, #4]
34188700:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34188702:	2201      	movs	r2, #1
34188704:	697b      	ldr	r3, [r7, #20]
34188706:	fa02 f303 	lsl.w	r3, r2, r3
3418870a:	43db      	mvns	r3, r3
3418870c:	693a      	ldr	r2, [r7, #16]
3418870e:	4013      	ands	r3, r2
34188710:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34188712:	683b      	ldr	r3, [r7, #0]
34188714:	685b      	ldr	r3, [r3, #4]
34188716:	091b      	lsrs	r3, r3, #4
34188718:	f003 0201 	and.w	r2, r3, #1
3418871c:	697b      	ldr	r3, [r7, #20]
3418871e:	fa02 f303 	lsl.w	r3, r2, r3
34188722:	693a      	ldr	r2, [r7, #16]
34188724:	4313      	orrs	r3, r2
34188726:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34188728:	687b      	ldr	r3, [r7, #4]
3418872a:	693a      	ldr	r2, [r7, #16]
3418872c:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3418872e:	683b      	ldr	r3, [r7, #0]
34188730:	685b      	ldr	r3, [r3, #4]
34188732:	f003 0303 	and.w	r3, r3, #3
34188736:	2b03      	cmp	r3, #3
34188738:	d109      	bne.n	3418874e <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3418873a:	683b      	ldr	r3, [r7, #0]
3418873c:	685b      	ldr	r3, [r3, #4]
3418873e:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34188742:	2b03      	cmp	r3, #3
34188744:	d11b      	bne.n	3418877e <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34188746:	683b      	ldr	r3, [r7, #0]
34188748:	689b      	ldr	r3, [r3, #8]
3418874a:	2b01      	cmp	r3, #1
3418874c:	d017      	beq.n	3418877e <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
3418874e:	687b      	ldr	r3, [r7, #4]
34188750:	68db      	ldr	r3, [r3, #12]
34188752:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34188754:	697b      	ldr	r3, [r7, #20]
34188756:	005b      	lsls	r3, r3, #1
34188758:	2203      	movs	r2, #3
3418875a:	fa02 f303 	lsl.w	r3, r2, r3
3418875e:	43db      	mvns	r3, r3
34188760:	693a      	ldr	r2, [r7, #16]
34188762:	4013      	ands	r3, r2
34188764:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34188766:	683b      	ldr	r3, [r7, #0]
34188768:	689a      	ldr	r2, [r3, #8]
3418876a:	697b      	ldr	r3, [r7, #20]
3418876c:	005b      	lsls	r3, r3, #1
3418876e:	fa02 f303 	lsl.w	r3, r2, r3
34188772:	693a      	ldr	r2, [r7, #16]
34188774:	4313      	orrs	r3, r2
34188776:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34188778:	687b      	ldr	r3, [r7, #4]
3418877a:	693a      	ldr	r2, [r7, #16]
3418877c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
3418877e:	683b      	ldr	r3, [r7, #0]
34188780:	685b      	ldr	r3, [r3, #4]
34188782:	f003 0303 	and.w	r3, r3, #3
34188786:	2b02      	cmp	r3, #2
34188788:	d123      	bne.n	341887d2 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
3418878a:	697b      	ldr	r3, [r7, #20]
3418878c:	08da      	lsrs	r2, r3, #3
3418878e:	687b      	ldr	r3, [r7, #4]
34188790:	3208      	adds	r2, #8
34188792:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34188796:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34188798:	697b      	ldr	r3, [r7, #20]
3418879a:	f003 0307 	and.w	r3, r3, #7
3418879e:	009b      	lsls	r3, r3, #2
341887a0:	220f      	movs	r2, #15
341887a2:	fa02 f303 	lsl.w	r3, r2, r3
341887a6:	43db      	mvns	r3, r3
341887a8:	693a      	ldr	r2, [r7, #16]
341887aa:	4013      	ands	r3, r2
341887ac:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
341887ae:	683b      	ldr	r3, [r7, #0]
341887b0:	691a      	ldr	r2, [r3, #16]
341887b2:	697b      	ldr	r3, [r7, #20]
341887b4:	f003 0307 	and.w	r3, r3, #7
341887b8:	009b      	lsls	r3, r3, #2
341887ba:	fa02 f303 	lsl.w	r3, r2, r3
341887be:	693a      	ldr	r2, [r7, #16]
341887c0:	4313      	orrs	r3, r2
341887c2:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
341887c4:	697b      	ldr	r3, [r7, #20]
341887c6:	08da      	lsrs	r2, r3, #3
341887c8:	687b      	ldr	r3, [r7, #4]
341887ca:	3208      	adds	r2, #8
341887cc:	6939      	ldr	r1, [r7, #16]
341887ce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
341887d2:	687b      	ldr	r3, [r7, #4]
341887d4:	681b      	ldr	r3, [r3, #0]
341887d6:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
341887d8:	697b      	ldr	r3, [r7, #20]
341887da:	005b      	lsls	r3, r3, #1
341887dc:	2203      	movs	r2, #3
341887de:	fa02 f303 	lsl.w	r3, r2, r3
341887e2:	43db      	mvns	r3, r3
341887e4:	693a      	ldr	r2, [r7, #16]
341887e6:	4013      	ands	r3, r2
341887e8:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
341887ea:	683b      	ldr	r3, [r7, #0]
341887ec:	685b      	ldr	r3, [r3, #4]
341887ee:	f003 0203 	and.w	r2, r3, #3
341887f2:	697b      	ldr	r3, [r7, #20]
341887f4:	005b      	lsls	r3, r3, #1
341887f6:	fa02 f303 	lsl.w	r3, r2, r3
341887fa:	693a      	ldr	r2, [r7, #16]
341887fc:	4313      	orrs	r3, r2
341887fe:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34188800:	687b      	ldr	r3, [r7, #4]
34188802:	693a      	ldr	r2, [r7, #16]
34188804:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34188806:	683b      	ldr	r3, [r7, #0]
34188808:	685b      	ldr	r3, [r3, #4]
3418880a:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
3418880e:	2b00      	cmp	r3, #0
34188810:	f000 80c2 	beq.w	34188998 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34188814:	4a69      	ldr	r2, [pc, #420]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188816:	697b      	ldr	r3, [r7, #20]
34188818:	089b      	lsrs	r3, r3, #2
3418881a:	3318      	adds	r3, #24
3418881c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34188820:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34188822:	697b      	ldr	r3, [r7, #20]
34188824:	f003 0303 	and.w	r3, r3, #3
34188828:	00db      	lsls	r3, r3, #3
3418882a:	220f      	movs	r2, #15
3418882c:	fa02 f303 	lsl.w	r3, r2, r3
34188830:	43db      	mvns	r3, r3
34188832:	693a      	ldr	r2, [r7, #16]
34188834:	4013      	ands	r3, r2
34188836:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34188838:	687b      	ldr	r3, [r7, #4]
3418883a:	4a61      	ldr	r2, [pc, #388]	@ (341889c0 <HAL_GPIO_Init+0x334>)
3418883c:	4293      	cmp	r3, r2
3418883e:	d043      	beq.n	341888c8 <HAL_GPIO_Init+0x23c>
34188840:	687b      	ldr	r3, [r7, #4]
34188842:	4a60      	ldr	r2, [pc, #384]	@ (341889c4 <HAL_GPIO_Init+0x338>)
34188844:	4293      	cmp	r3, r2
34188846:	d03d      	beq.n	341888c4 <HAL_GPIO_Init+0x238>
34188848:	687b      	ldr	r3, [r7, #4]
3418884a:	4a5f      	ldr	r2, [pc, #380]	@ (341889c8 <HAL_GPIO_Init+0x33c>)
3418884c:	4293      	cmp	r3, r2
3418884e:	d037      	beq.n	341888c0 <HAL_GPIO_Init+0x234>
34188850:	687b      	ldr	r3, [r7, #4]
34188852:	4a5e      	ldr	r2, [pc, #376]	@ (341889cc <HAL_GPIO_Init+0x340>)
34188854:	4293      	cmp	r3, r2
34188856:	d031      	beq.n	341888bc <HAL_GPIO_Init+0x230>
34188858:	687b      	ldr	r3, [r7, #4]
3418885a:	4a5d      	ldr	r2, [pc, #372]	@ (341889d0 <HAL_GPIO_Init+0x344>)
3418885c:	4293      	cmp	r3, r2
3418885e:	d02b      	beq.n	341888b8 <HAL_GPIO_Init+0x22c>
34188860:	687b      	ldr	r3, [r7, #4]
34188862:	4a5c      	ldr	r2, [pc, #368]	@ (341889d4 <HAL_GPIO_Init+0x348>)
34188864:	4293      	cmp	r3, r2
34188866:	d025      	beq.n	341888b4 <HAL_GPIO_Init+0x228>
34188868:	687b      	ldr	r3, [r7, #4]
3418886a:	4a5b      	ldr	r2, [pc, #364]	@ (341889d8 <HAL_GPIO_Init+0x34c>)
3418886c:	4293      	cmp	r3, r2
3418886e:	d01f      	beq.n	341888b0 <HAL_GPIO_Init+0x224>
34188870:	687b      	ldr	r3, [r7, #4]
34188872:	4a5a      	ldr	r2, [pc, #360]	@ (341889dc <HAL_GPIO_Init+0x350>)
34188874:	4293      	cmp	r3, r2
34188876:	d019      	beq.n	341888ac <HAL_GPIO_Init+0x220>
34188878:	687b      	ldr	r3, [r7, #4]
3418887a:	4a59      	ldr	r2, [pc, #356]	@ (341889e0 <HAL_GPIO_Init+0x354>)
3418887c:	4293      	cmp	r3, r2
3418887e:	d013      	beq.n	341888a8 <HAL_GPIO_Init+0x21c>
34188880:	687b      	ldr	r3, [r7, #4]
34188882:	4a58      	ldr	r2, [pc, #352]	@ (341889e4 <HAL_GPIO_Init+0x358>)
34188884:	4293      	cmp	r3, r2
34188886:	d00d      	beq.n	341888a4 <HAL_GPIO_Init+0x218>
34188888:	687b      	ldr	r3, [r7, #4]
3418888a:	4a57      	ldr	r2, [pc, #348]	@ (341889e8 <HAL_GPIO_Init+0x35c>)
3418888c:	4293      	cmp	r3, r2
3418888e:	d007      	beq.n	341888a0 <HAL_GPIO_Init+0x214>
34188890:	687b      	ldr	r3, [r7, #4]
34188892:	4a56      	ldr	r2, [pc, #344]	@ (341889ec <HAL_GPIO_Init+0x360>)
34188894:	4293      	cmp	r3, r2
34188896:	d101      	bne.n	3418889c <HAL_GPIO_Init+0x210>
34188898:	230b      	movs	r3, #11
3418889a:	e016      	b.n	341888ca <HAL_GPIO_Init+0x23e>
3418889c:	2310      	movs	r3, #16
3418889e:	e014      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888a0:	230a      	movs	r3, #10
341888a2:	e012      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888a4:	2309      	movs	r3, #9
341888a6:	e010      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888a8:	2308      	movs	r3, #8
341888aa:	e00e      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888ac:	2307      	movs	r3, #7
341888ae:	e00c      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888b0:	2306      	movs	r3, #6
341888b2:	e00a      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888b4:	2305      	movs	r3, #5
341888b6:	e008      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888b8:	2304      	movs	r3, #4
341888ba:	e006      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888bc:	2303      	movs	r3, #3
341888be:	e004      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888c0:	2302      	movs	r3, #2
341888c2:	e002      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888c4:	2301      	movs	r3, #1
341888c6:	e000      	b.n	341888ca <HAL_GPIO_Init+0x23e>
341888c8:	2300      	movs	r3, #0
341888ca:	697a      	ldr	r2, [r7, #20]
341888cc:	f002 0203 	and.w	r2, r2, #3
341888d0:	00d2      	lsls	r2, r2, #3
341888d2:	4093      	lsls	r3, r2
341888d4:	693a      	ldr	r2, [r7, #16]
341888d6:	4313      	orrs	r3, r2
341888d8:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
341888da:	4938      	ldr	r1, [pc, #224]	@ (341889bc <HAL_GPIO_Init+0x330>)
341888dc:	697b      	ldr	r3, [r7, #20]
341888de:	089b      	lsrs	r3, r3, #2
341888e0:	3318      	adds	r3, #24
341888e2:	693a      	ldr	r2, [r7, #16]
341888e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
341888e8:	4b34      	ldr	r3, [pc, #208]	@ (341889bc <HAL_GPIO_Init+0x330>)
341888ea:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341888ee:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
341888f0:	68fb      	ldr	r3, [r7, #12]
341888f2:	43db      	mvns	r3, r3
341888f4:	693a      	ldr	r2, [r7, #16]
341888f6:	4013      	ands	r3, r2
341888f8:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
341888fa:	683b      	ldr	r3, [r7, #0]
341888fc:	685b      	ldr	r3, [r3, #4]
341888fe:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34188902:	2b00      	cmp	r3, #0
34188904:	d003      	beq.n	3418890e <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
34188906:	693a      	ldr	r2, [r7, #16]
34188908:	68fb      	ldr	r3, [r7, #12]
3418890a:	4313      	orrs	r3, r2
3418890c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
3418890e:	4a2b      	ldr	r2, [pc, #172]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188910:	693b      	ldr	r3, [r7, #16]
34188912:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34188916:	4b29      	ldr	r3, [pc, #164]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188918:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418891c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418891e:	68fb      	ldr	r3, [r7, #12]
34188920:	43db      	mvns	r3, r3
34188922:	693a      	ldr	r2, [r7, #16]
34188924:	4013      	ands	r3, r2
34188926:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34188928:	683b      	ldr	r3, [r7, #0]
3418892a:	685b      	ldr	r3, [r3, #4]
3418892c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34188930:	2b00      	cmp	r3, #0
34188932:	d003      	beq.n	3418893c <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
34188934:	693a      	ldr	r2, [r7, #16]
34188936:	68fb      	ldr	r3, [r7, #12]
34188938:	4313      	orrs	r3, r2
3418893a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
3418893c:	4a1f      	ldr	r2, [pc, #124]	@ (341889bc <HAL_GPIO_Init+0x330>)
3418893e:	693b      	ldr	r3, [r7, #16]
34188940:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34188944:	4b1d      	ldr	r3, [pc, #116]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188946:	681b      	ldr	r3, [r3, #0]
34188948:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418894a:	68fb      	ldr	r3, [r7, #12]
3418894c:	43db      	mvns	r3, r3
3418894e:	693a      	ldr	r2, [r7, #16]
34188950:	4013      	ands	r3, r2
34188952:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34188954:	683b      	ldr	r3, [r7, #0]
34188956:	685b      	ldr	r3, [r3, #4]
34188958:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3418895c:	2b00      	cmp	r3, #0
3418895e:	d003      	beq.n	34188968 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34188960:	693a      	ldr	r2, [r7, #16]
34188962:	68fb      	ldr	r3, [r7, #12]
34188964:	4313      	orrs	r3, r2
34188966:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34188968:	4a14      	ldr	r2, [pc, #80]	@ (341889bc <HAL_GPIO_Init+0x330>)
3418896a:	693b      	ldr	r3, [r7, #16]
3418896c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
3418896e:	4b13      	ldr	r3, [pc, #76]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188970:	685b      	ldr	r3, [r3, #4]
34188972:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34188974:	68fb      	ldr	r3, [r7, #12]
34188976:	43db      	mvns	r3, r3
34188978:	693a      	ldr	r2, [r7, #16]
3418897a:	4013      	ands	r3, r2
3418897c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
3418897e:	683b      	ldr	r3, [r7, #0]
34188980:	685b      	ldr	r3, [r3, #4]
34188982:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34188986:	2b00      	cmp	r3, #0
34188988:	d003      	beq.n	34188992 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
3418898a:	693a      	ldr	r2, [r7, #16]
3418898c:	68fb      	ldr	r3, [r7, #12]
3418898e:	4313      	orrs	r3, r2
34188990:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34188992:	4a0a      	ldr	r2, [pc, #40]	@ (341889bc <HAL_GPIO_Init+0x330>)
34188994:	693b      	ldr	r3, [r7, #16]
34188996:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34188998:	697b      	ldr	r3, [r7, #20]
3418899a:	3301      	adds	r3, #1
3418899c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3418899e:	683b      	ldr	r3, [r7, #0]
341889a0:	681a      	ldr	r2, [r3, #0]
341889a2:	697b      	ldr	r3, [r7, #20]
341889a4:	fa22 f303 	lsr.w	r3, r2, r3
341889a8:	2b00      	cmp	r3, #0
341889aa:	f47f ae77 	bne.w	3418869c <HAL_GPIO_Init+0x10>
  }
}
341889ae:	bf00      	nop
341889b0:	bf00      	nop
341889b2:	371c      	adds	r7, #28
341889b4:	46bd      	mov	sp, r7
341889b6:	f85d 7b04 	ldr.w	r7, [sp], #4
341889ba:	4770      	bx	lr
341889bc:	56025000 	.word	0x56025000
341889c0:	56020000 	.word	0x56020000
341889c4:	56020400 	.word	0x56020400
341889c8:	56020800 	.word	0x56020800
341889cc:	56020c00 	.word	0x56020c00
341889d0:	56021000 	.word	0x56021000
341889d4:	56021400 	.word	0x56021400
341889d8:	56021800 	.word	0x56021800
341889dc:	56021c00 	.word	0x56021c00
341889e0:	56023400 	.word	0x56023400
341889e4:	56023800 	.word	0x56023800
341889e8:	56023c00 	.word	0x56023c00
341889ec:	56024000 	.word	0x56024000

341889f0 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
341889f0:	b480      	push	{r7}
341889f2:	b087      	sub	sp, #28
341889f4:	af00      	add	r7, sp, #0
341889f6:	6078      	str	r0, [r7, #4]
341889f8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
341889fa:	2300      	movs	r3, #0
341889fc:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
341889fe:	e10f      	b.n	34188c20 <HAL_GPIO_DeInit+0x230>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
34188a00:	2201      	movs	r2, #1
34188a02:	697b      	ldr	r3, [r7, #20]
34188a04:	fa02 f303 	lsl.w	r3, r2, r3
34188a08:	683a      	ldr	r2, [r7, #0]
34188a0a:	4013      	ands	r3, r2
34188a0c:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
34188a0e:	693b      	ldr	r3, [r7, #16]
34188a10:	2b00      	cmp	r3, #0
34188a12:	f000 8102 	beq.w	34188c1a <HAL_GPIO_DeInit+0x22a>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
34188a16:	4a89      	ldr	r2, [pc, #548]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188a18:	697b      	ldr	r3, [r7, #20]
34188a1a:	089b      	lsrs	r3, r3, #2
34188a1c:	3318      	adds	r3, #24
34188a1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34188a22:	60fb      	str	r3, [r7, #12]
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34188a24:	697b      	ldr	r3, [r7, #20]
34188a26:	f003 0303 	and.w	r3, r3, #3
34188a2a:	00db      	lsls	r3, r3, #3
34188a2c:	220f      	movs	r2, #15
34188a2e:	fa02 f303 	lsl.w	r3, r2, r3
34188a32:	68fa      	ldr	r2, [r7, #12]
34188a34:	4013      	ands	r3, r2
34188a36:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
34188a38:	687b      	ldr	r3, [r7, #4]
34188a3a:	4a81      	ldr	r2, [pc, #516]	@ (34188c40 <HAL_GPIO_DeInit+0x250>)
34188a3c:	4293      	cmp	r3, r2
34188a3e:	d043      	beq.n	34188ac8 <HAL_GPIO_DeInit+0xd8>
34188a40:	687b      	ldr	r3, [r7, #4]
34188a42:	4a80      	ldr	r2, [pc, #512]	@ (34188c44 <HAL_GPIO_DeInit+0x254>)
34188a44:	4293      	cmp	r3, r2
34188a46:	d03d      	beq.n	34188ac4 <HAL_GPIO_DeInit+0xd4>
34188a48:	687b      	ldr	r3, [r7, #4]
34188a4a:	4a7f      	ldr	r2, [pc, #508]	@ (34188c48 <HAL_GPIO_DeInit+0x258>)
34188a4c:	4293      	cmp	r3, r2
34188a4e:	d037      	beq.n	34188ac0 <HAL_GPIO_DeInit+0xd0>
34188a50:	687b      	ldr	r3, [r7, #4]
34188a52:	4a7e      	ldr	r2, [pc, #504]	@ (34188c4c <HAL_GPIO_DeInit+0x25c>)
34188a54:	4293      	cmp	r3, r2
34188a56:	d031      	beq.n	34188abc <HAL_GPIO_DeInit+0xcc>
34188a58:	687b      	ldr	r3, [r7, #4]
34188a5a:	4a7d      	ldr	r2, [pc, #500]	@ (34188c50 <HAL_GPIO_DeInit+0x260>)
34188a5c:	4293      	cmp	r3, r2
34188a5e:	d02b      	beq.n	34188ab8 <HAL_GPIO_DeInit+0xc8>
34188a60:	687b      	ldr	r3, [r7, #4]
34188a62:	4a7c      	ldr	r2, [pc, #496]	@ (34188c54 <HAL_GPIO_DeInit+0x264>)
34188a64:	4293      	cmp	r3, r2
34188a66:	d025      	beq.n	34188ab4 <HAL_GPIO_DeInit+0xc4>
34188a68:	687b      	ldr	r3, [r7, #4]
34188a6a:	4a7b      	ldr	r2, [pc, #492]	@ (34188c58 <HAL_GPIO_DeInit+0x268>)
34188a6c:	4293      	cmp	r3, r2
34188a6e:	d01f      	beq.n	34188ab0 <HAL_GPIO_DeInit+0xc0>
34188a70:	687b      	ldr	r3, [r7, #4]
34188a72:	4a7a      	ldr	r2, [pc, #488]	@ (34188c5c <HAL_GPIO_DeInit+0x26c>)
34188a74:	4293      	cmp	r3, r2
34188a76:	d019      	beq.n	34188aac <HAL_GPIO_DeInit+0xbc>
34188a78:	687b      	ldr	r3, [r7, #4]
34188a7a:	4a79      	ldr	r2, [pc, #484]	@ (34188c60 <HAL_GPIO_DeInit+0x270>)
34188a7c:	4293      	cmp	r3, r2
34188a7e:	d013      	beq.n	34188aa8 <HAL_GPIO_DeInit+0xb8>
34188a80:	687b      	ldr	r3, [r7, #4]
34188a82:	4a78      	ldr	r2, [pc, #480]	@ (34188c64 <HAL_GPIO_DeInit+0x274>)
34188a84:	4293      	cmp	r3, r2
34188a86:	d00d      	beq.n	34188aa4 <HAL_GPIO_DeInit+0xb4>
34188a88:	687b      	ldr	r3, [r7, #4]
34188a8a:	4a77      	ldr	r2, [pc, #476]	@ (34188c68 <HAL_GPIO_DeInit+0x278>)
34188a8c:	4293      	cmp	r3, r2
34188a8e:	d007      	beq.n	34188aa0 <HAL_GPIO_DeInit+0xb0>
34188a90:	687b      	ldr	r3, [r7, #4]
34188a92:	4a76      	ldr	r2, [pc, #472]	@ (34188c6c <HAL_GPIO_DeInit+0x27c>)
34188a94:	4293      	cmp	r3, r2
34188a96:	d101      	bne.n	34188a9c <HAL_GPIO_DeInit+0xac>
34188a98:	230b      	movs	r3, #11
34188a9a:	e016      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188a9c:	2310      	movs	r3, #16
34188a9e:	e014      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188aa0:	230a      	movs	r3, #10
34188aa2:	e012      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188aa4:	2309      	movs	r3, #9
34188aa6:	e010      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188aa8:	2308      	movs	r3, #8
34188aaa:	e00e      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188aac:	2307      	movs	r3, #7
34188aae:	e00c      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ab0:	2306      	movs	r3, #6
34188ab2:	e00a      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ab4:	2305      	movs	r3, #5
34188ab6:	e008      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ab8:	2304      	movs	r3, #4
34188aba:	e006      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188abc:	2303      	movs	r3, #3
34188abe:	e004      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ac0:	2302      	movs	r3, #2
34188ac2:	e002      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ac4:	2301      	movs	r3, #1
34188ac6:	e000      	b.n	34188aca <HAL_GPIO_DeInit+0xda>
34188ac8:	2300      	movs	r3, #0
34188aca:	697a      	ldr	r2, [r7, #20]
34188acc:	f002 0203 	and.w	r2, r2, #3
34188ad0:	00d2      	lsls	r2, r2, #3
34188ad2:	4093      	lsls	r3, r2
34188ad4:	68fa      	ldr	r2, [r7, #12]
34188ad6:	429a      	cmp	r2, r3
34188ad8:	d136      	bne.n	34188b48 <HAL_GPIO_DeInit+0x158>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
34188ada:	4b58      	ldr	r3, [pc, #352]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188adc:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34188ae0:	693b      	ldr	r3, [r7, #16]
34188ae2:	43db      	mvns	r3, r3
34188ae4:	4955      	ldr	r1, [pc, #340]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188ae6:	4013      	ands	r3, r2
34188ae8:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
34188aec:	4b53      	ldr	r3, [pc, #332]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188aee:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
34188af2:	693b      	ldr	r3, [r7, #16]
34188af4:	43db      	mvns	r3, r3
34188af6:	4951      	ldr	r1, [pc, #324]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188af8:	4013      	ands	r3, r2
34188afa:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
34188afe:	4b4f      	ldr	r3, [pc, #316]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b00:	681a      	ldr	r2, [r3, #0]
34188b02:	693b      	ldr	r3, [r7, #16]
34188b04:	43db      	mvns	r3, r3
34188b06:	494d      	ldr	r1, [pc, #308]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b08:	4013      	ands	r3, r2
34188b0a:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
34188b0c:	4b4b      	ldr	r3, [pc, #300]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b0e:	685a      	ldr	r2, [r3, #4]
34188b10:	693b      	ldr	r3, [r7, #16]
34188b12:	43db      	mvns	r3, r3
34188b14:	4949      	ldr	r1, [pc, #292]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b16:	4013      	ands	r3, r2
34188b18:	604b      	str	r3, [r1, #4]

        tmp = 0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos);
34188b1a:	697b      	ldr	r3, [r7, #20]
34188b1c:	f003 0303 	and.w	r3, r3, #3
34188b20:	00db      	lsls	r3, r3, #3
34188b22:	220f      	movs	r2, #15
34188b24:	fa02 f303 	lsl.w	r3, r2, r3
34188b28:	60fb      	str	r3, [r7, #12]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
34188b2a:	4a44      	ldr	r2, [pc, #272]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b2c:	697b      	ldr	r3, [r7, #20]
34188b2e:	089b      	lsrs	r3, r3, #2
34188b30:	3318      	adds	r3, #24
34188b32:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
34188b36:	68fb      	ldr	r3, [r7, #12]
34188b38:	43da      	mvns	r2, r3
34188b3a:	4840      	ldr	r0, [pc, #256]	@ (34188c3c <HAL_GPIO_DeInit+0x24c>)
34188b3c:	697b      	ldr	r3, [r7, #20]
34188b3e:	089b      	lsrs	r3, r3, #2
34188b40:	400a      	ands	r2, r1
34188b42:	3318      	adds	r3, #24
34188b44:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34188b48:	687b      	ldr	r3, [r7, #4]
34188b4a:	681a      	ldr	r2, [r3, #0]
34188b4c:	697b      	ldr	r3, [r7, #20]
34188b4e:	005b      	lsls	r3, r3, #1
34188b50:	2103      	movs	r1, #3
34188b52:	fa01 f303 	lsl.w	r3, r1, r3
34188b56:	431a      	orrs	r2, r3
34188b58:	687b      	ldr	r3, [r7, #4]
34188b5a:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
34188b5c:	697b      	ldr	r3, [r7, #20]
34188b5e:	08da      	lsrs	r2, r3, #3
34188b60:	687b      	ldr	r3, [r7, #4]
34188b62:	3208      	adds	r2, #8
34188b64:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34188b68:	697b      	ldr	r3, [r7, #20]
34188b6a:	f003 0307 	and.w	r3, r3, #7
34188b6e:	009b      	lsls	r3, r3, #2
34188b70:	220f      	movs	r2, #15
34188b72:	fa02 f303 	lsl.w	r3, r2, r3
34188b76:	43db      	mvns	r3, r3
34188b78:	697a      	ldr	r2, [r7, #20]
34188b7a:	08d2      	lsrs	r2, r2, #3
34188b7c:	4019      	ands	r1, r3
34188b7e:	687b      	ldr	r3, [r7, #4]
34188b80:	3208      	adds	r2, #8
34188b82:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34188b86:	687b      	ldr	r3, [r7, #4]
34188b88:	689a      	ldr	r2, [r3, #8]
34188b8a:	697b      	ldr	r3, [r7, #20]
34188b8c:	005b      	lsls	r3, r3, #1
34188b8e:	2103      	movs	r1, #3
34188b90:	fa01 f303 	lsl.w	r3, r1, r3
34188b94:	43db      	mvns	r3, r3
34188b96:	401a      	ands	r2, r3
34188b98:	687b      	ldr	r3, [r7, #4]
34188b9a:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
34188b9c:	687b      	ldr	r3, [r7, #4]
34188b9e:	685a      	ldr	r2, [r3, #4]
34188ba0:	2101      	movs	r1, #1
34188ba2:	697b      	ldr	r3, [r7, #20]
34188ba4:	fa01 f303 	lsl.w	r3, r1, r3
34188ba8:	43db      	mvns	r3, r3
34188baa:	401a      	ands	r2, r3
34188bac:	687b      	ldr	r3, [r7, #4]
34188bae:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34188bb0:	687b      	ldr	r3, [r7, #4]
34188bb2:	68da      	ldr	r2, [r3, #12]
34188bb4:	697b      	ldr	r3, [r7, #20]
34188bb6:	005b      	lsls	r3, r3, #1
34188bb8:	2103      	movs	r1, #3
34188bba:	fa01 f303 	lsl.w	r3, r1, r3
34188bbe:	43db      	mvns	r3, r3
34188bc0:	401a      	ands	r2, r3
34188bc2:	687b      	ldr	r3, [r7, #4]
34188bc4:	60da      	str	r2, [r3, #12]

      /* Reset delay settings for the current IO */
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
34188bc6:	697b      	ldr	r3, [r7, #20]
34188bc8:	08da      	lsrs	r2, r3, #3
34188bca:	687b      	ldr	r3, [r7, #4]
34188bcc:	3210      	adds	r2, #16
34188bce:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34188bd2:	697b      	ldr	r3, [r7, #20]
34188bd4:	f003 0307 	and.w	r3, r3, #7
34188bd8:	009b      	lsls	r3, r3, #2
34188bda:	220f      	movs	r2, #15
34188bdc:	fa02 f303 	lsl.w	r3, r2, r3
34188be0:	43db      	mvns	r3, r3
34188be2:	697a      	ldr	r2, [r7, #20]
34188be4:	08d2      	lsrs	r2, r2, #3
34188be6:	4019      	ands	r1, r3
34188be8:	687b      	ldr	r3, [r7, #4]
34188bea:	3210      	adds	r2, #16
34188bec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Reset control settings for the current IO */
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
34188bf0:	697b      	ldr	r3, [r7, #20]
34188bf2:	08da      	lsrs	r2, r3, #3
34188bf4:	687b      	ldr	r3, [r7, #4]
34188bf6:	3212      	adds	r2, #18
34188bf8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
34188bfc:	697b      	ldr	r3, [r7, #20]
34188bfe:	f003 0307 	and.w	r3, r3, #7
34188c02:	009b      	lsls	r3, r3, #2
34188c04:	220f      	movs	r2, #15
34188c06:	fa02 f303 	lsl.w	r3, r2, r3
34188c0a:	43db      	mvns	r3, r3
34188c0c:	697a      	ldr	r2, [r7, #20]
34188c0e:	08d2      	lsrs	r2, r2, #3
34188c10:	4019      	ands	r1, r3
34188c12:	687b      	ldr	r3, [r7, #4]
34188c14:	3212      	adds	r2, #18
34188c16:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    position++;
34188c1a:	697b      	ldr	r3, [r7, #20]
34188c1c:	3301      	adds	r3, #1
34188c1e:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00u)
34188c20:	683a      	ldr	r2, [r7, #0]
34188c22:	697b      	ldr	r3, [r7, #20]
34188c24:	fa22 f303 	lsr.w	r3, r2, r3
34188c28:	2b00      	cmp	r3, #0
34188c2a:	f47f aee9 	bne.w	34188a00 <HAL_GPIO_DeInit+0x10>
  }
}
34188c2e:	bf00      	nop
34188c30:	bf00      	nop
34188c32:	371c      	adds	r7, #28
34188c34:	46bd      	mov	sp, r7
34188c36:	f85d 7b04 	ldr.w	r7, [sp], #4
34188c3a:	4770      	bx	lr
34188c3c:	56025000 	.word	0x56025000
34188c40:	56020000 	.word	0x56020000
34188c44:	56020400 	.word	0x56020400
34188c48:	56020800 	.word	0x56020800
34188c4c:	56020c00 	.word	0x56020c00
34188c50:	56021000 	.word	0x56021000
34188c54:	56021400 	.word	0x56021400
34188c58:	56021800 	.word	0x56021800
34188c5c:	56021c00 	.word	0x56021c00
34188c60:	56023400 	.word	0x56023400
34188c64:	56023800 	.word	0x56023800
34188c68:	56023c00 	.word	0x56023c00
34188c6c:	56024000 	.word	0x56024000

34188c70 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34188c70:	b480      	push	{r7}
34188c72:	b083      	sub	sp, #12
34188c74:	af00      	add	r7, sp, #0
34188c76:	6078      	str	r0, [r7, #4]
34188c78:	460b      	mov	r3, r1
34188c7a:	807b      	strh	r3, [r7, #2]
34188c7c:	4613      	mov	r3, r2
34188c7e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34188c80:	787b      	ldrb	r3, [r7, #1]
34188c82:	2b00      	cmp	r3, #0
34188c84:	d003      	beq.n	34188c8e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34188c86:	887a      	ldrh	r2, [r7, #2]
34188c88:	687b      	ldr	r3, [r7, #4]
34188c8a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34188c8c:	e002      	b.n	34188c94 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34188c8e:	887a      	ldrh	r2, [r7, #2]
34188c90:	687b      	ldr	r3, [r7, #4]
34188c92:	629a      	str	r2, [r3, #40]	@ 0x28
}
34188c94:	bf00      	nop
34188c96:	370c      	adds	r7, #12
34188c98:	46bd      	mov	sp, r7
34188c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34188c9e:	4770      	bx	lr

34188ca0 <HAL_GPIO_ConfigPinAttributes>:
  *            @arg @ref GPIO_PIN_SEC          Secure-only access
  *            @arg @ref GPIO_PIN_NSEC         Secure/Non-secure access
  * @retval None.
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
34188ca0:	b480      	push	{r7}
34188ca2:	b087      	sub	sp, #28
34188ca4:	af00      	add	r7, sp, #0
34188ca6:	60f8      	str	r0, [r7, #12]
34188ca8:	460b      	mov	r3, r1
34188caa:	607a      	str	r2, [r7, #4]
34188cac:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

#if defined CPU_IN_SECURE_STATE
  /* Configure the port pins */
  sec = GPIOx->SECCFGR;
34188cae:	68fb      	ldr	r3, [r7, #12]
34188cb0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34188cb2:	617b      	str	r3, [r7, #20]
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
34188cb4:	687a      	ldr	r2, [r7, #4]
34188cb6:	f240 1301 	movw	r3, #257	@ 0x101
34188cba:	4013      	ands	r3, r2
34188cbc:	f240 1201 	movw	r2, #257	@ 0x101
34188cc0:	4293      	cmp	r3, r2
34188cc2:	d104      	bne.n	34188cce <HAL_GPIO_ConfigPinAttributes+0x2e>
  {
    sec |= (uint32_t)GPIO_Pin;
34188cc4:	897b      	ldrh	r3, [r7, #10]
34188cc6:	697a      	ldr	r2, [r7, #20]
34188cc8:	4313      	orrs	r3, r2
34188cca:	617b      	str	r3, [r7, #20]
34188ccc:	e009      	b.n	34188ce2 <HAL_GPIO_ConfigPinAttributes+0x42>
  }
  else if ((PinAttributes & GPIO_PIN_NSEC) == GPIO_PIN_NSEC)
34188cce:	687b      	ldr	r3, [r7, #4]
34188cd0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34188cd4:	2b00      	cmp	r3, #0
34188cd6:	d004      	beq.n	34188ce2 <HAL_GPIO_ConfigPinAttributes+0x42>
  {
    sec &= ~((uint32_t)GPIO_Pin);
34188cd8:	897b      	ldrh	r3, [r7, #10]
34188cda:	43db      	mvns	r3, r3
34188cdc:	697a      	ldr	r2, [r7, #20]
34188cde:	4013      	ands	r3, r2
34188ce0:	617b      	str	r3, [r7, #20]
  }
  else
  {
    /* do nothing */
  }
  GPIOx->SECCFGR = sec;
34188ce2:	68fb      	ldr	r3, [r7, #12]
34188ce4:	697a      	ldr	r2, [r7, #20]
34188ce6:	631a      	str	r2, [r3, #48]	@ 0x30
#endif /* CPU_IN_SECURE_STATE */

  priv = GPIOx->PRIVCFGR;
34188ce8:	68fb      	ldr	r3, [r7, #12]
34188cea:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34188cec:	613b      	str	r3, [r7, #16]
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
34188cee:	687a      	ldr	r2, [r7, #4]
34188cf0:	f240 2302 	movw	r3, #514	@ 0x202
34188cf4:	4013      	ands	r3, r2
34188cf6:	f240 2202 	movw	r2, #514	@ 0x202
34188cfa:	4293      	cmp	r3, r2
34188cfc:	d104      	bne.n	34188d08 <HAL_GPIO_ConfigPinAttributes+0x68>
  {
    priv |= (uint32_t)GPIO_Pin;
34188cfe:	897b      	ldrh	r3, [r7, #10]
34188d00:	693a      	ldr	r2, [r7, #16]
34188d02:	4313      	orrs	r3, r2
34188d04:	613b      	str	r3, [r7, #16]
34188d06:	e009      	b.n	34188d1c <HAL_GPIO_ConfigPinAttributes+0x7c>
  }
  else if ((PinAttributes & GPIO_PIN_NPRIV) == GPIO_PIN_NPRIV)
34188d08:	687b      	ldr	r3, [r7, #4]
34188d0a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34188d0e:	2b00      	cmp	r3, #0
34188d10:	d004      	beq.n	34188d1c <HAL_GPIO_ConfigPinAttributes+0x7c>
  {
    priv &= ~((uint32_t)GPIO_Pin);
34188d12:	897b      	ldrh	r3, [r7, #10]
34188d14:	43db      	mvns	r3, r3
34188d16:	693a      	ldr	r2, [r7, #16]
34188d18:	4013      	ands	r3, r2
34188d1a:	613b      	str	r3, [r7, #16]
  else
  {
    /* do nothing */
  }

  GPIOx->PRIVCFGR = priv;
34188d1c:	68fb      	ldr	r3, [r7, #12]
34188d1e:	693a      	ldr	r2, [r7, #16]
34188d20:	635a      	str	r2, [r3, #52]	@ 0x34
}
34188d22:	bf00      	nop
34188d24:	371c      	adds	r7, #28
34188d26:	46bd      	mov	sp, r7
34188d28:	f85d 7b04 	ldr.w	r7, [sp], #4
34188d2c:	4770      	bx	lr

34188d2e <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
34188d2e:	b580      	push	{r7, lr}
34188d30:	b082      	sub	sp, #8
34188d32:	af00      	add	r7, sp, #0
34188d34:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
34188d36:	687b      	ldr	r3, [r7, #4]
34188d38:	2b00      	cmp	r3, #0
34188d3a:	d101      	bne.n	34188d40 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
34188d3c:	2301      	movs	r3, #1
34188d3e:	e08d      	b.n	34188e5c <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
34188d40:	687b      	ldr	r3, [r7, #4]
34188d42:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34188d46:	b2db      	uxtb	r3, r3
34188d48:	2b00      	cmp	r3, #0
34188d4a:	d106      	bne.n	34188d5a <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
34188d4c:	687b      	ldr	r3, [r7, #4]
34188d4e:	2200      	movs	r2, #0
34188d50:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
34188d54:	6878      	ldr	r0, [r7, #4]
34188d56:	f7f9 facd 	bl	341822f4 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
34188d5a:	687b      	ldr	r3, [r7, #4]
34188d5c:	2224      	movs	r2, #36	@ 0x24
34188d5e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
34188d62:	687b      	ldr	r3, [r7, #4]
34188d64:	681b      	ldr	r3, [r3, #0]
34188d66:	681a      	ldr	r2, [r3, #0]
34188d68:	687b      	ldr	r3, [r7, #4]
34188d6a:	681b      	ldr	r3, [r3, #0]
34188d6c:	f022 0201 	bic.w	r2, r2, #1
34188d70:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34188d72:	687b      	ldr	r3, [r7, #4]
34188d74:	685a      	ldr	r2, [r3, #4]
34188d76:	687b      	ldr	r3, [r7, #4]
34188d78:	681b      	ldr	r3, [r3, #0]
34188d7a:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
34188d7e:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
34188d80:	687b      	ldr	r3, [r7, #4]
34188d82:	681b      	ldr	r3, [r3, #0]
34188d84:	689a      	ldr	r2, [r3, #8]
34188d86:	687b      	ldr	r3, [r7, #4]
34188d88:	681b      	ldr	r3, [r3, #0]
34188d8a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34188d8e:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34188d90:	687b      	ldr	r3, [r7, #4]
34188d92:	68db      	ldr	r3, [r3, #12]
34188d94:	2b01      	cmp	r3, #1
34188d96:	d107      	bne.n	34188da8 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34188d98:	687b      	ldr	r3, [r7, #4]
34188d9a:	689a      	ldr	r2, [r3, #8]
34188d9c:	687b      	ldr	r3, [r7, #4]
34188d9e:	681b      	ldr	r3, [r3, #0]
34188da0:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34188da4:	609a      	str	r2, [r3, #8]
34188da6:	e006      	b.n	34188db6 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34188da8:	687b      	ldr	r3, [r7, #4]
34188daa:	689a      	ldr	r2, [r3, #8]
34188dac:	687b      	ldr	r3, [r7, #4]
34188dae:	681b      	ldr	r3, [r3, #0]
34188db0:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
34188db4:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34188db6:	687b      	ldr	r3, [r7, #4]
34188db8:	68db      	ldr	r3, [r3, #12]
34188dba:	2b02      	cmp	r3, #2
34188dbc:	d108      	bne.n	34188dd0 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34188dbe:	687b      	ldr	r3, [r7, #4]
34188dc0:	681b      	ldr	r3, [r3, #0]
34188dc2:	685a      	ldr	r2, [r3, #4]
34188dc4:	687b      	ldr	r3, [r7, #4]
34188dc6:	681b      	ldr	r3, [r3, #0]
34188dc8:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
34188dcc:	605a      	str	r2, [r3, #4]
34188dce:	e007      	b.n	34188de0 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34188dd0:	687b      	ldr	r3, [r7, #4]
34188dd2:	681b      	ldr	r3, [r3, #0]
34188dd4:	685a      	ldr	r2, [r3, #4]
34188dd6:	687b      	ldr	r3, [r7, #4]
34188dd8:	681b      	ldr	r3, [r3, #0]
34188dda:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
34188dde:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
34188de0:	687b      	ldr	r3, [r7, #4]
34188de2:	681b      	ldr	r3, [r3, #0]
34188de4:	685b      	ldr	r3, [r3, #4]
34188de6:	687a      	ldr	r2, [r7, #4]
34188de8:	6812      	ldr	r2, [r2, #0]
34188dea:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
34188dee:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34188df2:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
34188df4:	687b      	ldr	r3, [r7, #4]
34188df6:	681b      	ldr	r3, [r3, #0]
34188df8:	68da      	ldr	r2, [r3, #12]
34188dfa:	687b      	ldr	r3, [r7, #4]
34188dfc:	681b      	ldr	r3, [r3, #0]
34188dfe:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34188e02:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
34188e04:	687b      	ldr	r3, [r7, #4]
34188e06:	691a      	ldr	r2, [r3, #16]
34188e08:	687b      	ldr	r3, [r7, #4]
34188e0a:	695b      	ldr	r3, [r3, #20]
34188e0c:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
34188e10:	687b      	ldr	r3, [r7, #4]
34188e12:	699b      	ldr	r3, [r3, #24]
34188e14:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
34188e16:	687b      	ldr	r3, [r7, #4]
34188e18:	681b      	ldr	r3, [r3, #0]
34188e1a:	430a      	orrs	r2, r1
34188e1c:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
34188e1e:	687b      	ldr	r3, [r7, #4]
34188e20:	69d9      	ldr	r1, [r3, #28]
34188e22:	687b      	ldr	r3, [r7, #4]
34188e24:	6a1a      	ldr	r2, [r3, #32]
34188e26:	687b      	ldr	r3, [r7, #4]
34188e28:	681b      	ldr	r3, [r3, #0]
34188e2a:	430a      	orrs	r2, r1
34188e2c:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
34188e2e:	687b      	ldr	r3, [r7, #4]
34188e30:	681b      	ldr	r3, [r3, #0]
34188e32:	681a      	ldr	r2, [r3, #0]
34188e34:	687b      	ldr	r3, [r7, #4]
34188e36:	681b      	ldr	r3, [r3, #0]
34188e38:	f042 0201 	orr.w	r2, r2, #1
34188e3c:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34188e3e:	687b      	ldr	r3, [r7, #4]
34188e40:	2200      	movs	r2, #0
34188e42:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
34188e44:	687b      	ldr	r3, [r7, #4]
34188e46:	2220      	movs	r2, #32
34188e48:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34188e4c:	687b      	ldr	r3, [r7, #4]
34188e4e:	2200      	movs	r2, #0
34188e50:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34188e52:	687b      	ldr	r3, [r7, #4]
34188e54:	2200      	movs	r2, #0
34188e56:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
34188e5a:	2300      	movs	r3, #0
}
34188e5c:	4618      	mov	r0, r3
34188e5e:	3708      	adds	r7, #8
34188e60:	46bd      	mov	sp, r7
34188e62:	bd80      	pop	{r7, pc}

34188e64 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
34188e64:	b580      	push	{r7, lr}
34188e66:	b082      	sub	sp, #8
34188e68:	af00      	add	r7, sp, #0
34188e6a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
34188e6c:	687b      	ldr	r3, [r7, #4]
34188e6e:	2b00      	cmp	r3, #0
34188e70:	d101      	bne.n	34188e76 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
34188e72:	2301      	movs	r3, #1
34188e74:	e021      	b.n	34188eba <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
34188e76:	687b      	ldr	r3, [r7, #4]
34188e78:	2224      	movs	r2, #36	@ 0x24
34188e7a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
34188e7e:	687b      	ldr	r3, [r7, #4]
34188e80:	681b      	ldr	r3, [r3, #0]
34188e82:	681a      	ldr	r2, [r3, #0]
34188e84:	687b      	ldr	r3, [r7, #4]
34188e86:	681b      	ldr	r3, [r3, #0]
34188e88:	f022 0201 	bic.w	r2, r2, #1
34188e8c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
34188e8e:	6878      	ldr	r0, [r7, #4]
34188e90:	f7f9 fab2 	bl	341823f8 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34188e94:	687b      	ldr	r3, [r7, #4]
34188e96:	2200      	movs	r2, #0
34188e98:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
34188e9a:	687b      	ldr	r3, [r7, #4]
34188e9c:	2200      	movs	r2, #0
34188e9e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34188ea2:	687b      	ldr	r3, [r7, #4]
34188ea4:	2200      	movs	r2, #0
34188ea6:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34188ea8:	687b      	ldr	r3, [r7, #4]
34188eaa:	2200      	movs	r2, #0
34188eac:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
34188eb0:	687b      	ldr	r3, [r7, #4]
34188eb2:	2200      	movs	r2, #0
34188eb4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34188eb8:	2300      	movs	r3, #0
}
34188eba:	4618      	mov	r0, r3
34188ebc:	3708      	adds	r7, #8
34188ebe:	46bd      	mov	sp, r7
34188ec0:	bd80      	pop	{r7, pc}
	...

34188ec4 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
34188ec4:	b580      	push	{r7, lr}
34188ec6:	b088      	sub	sp, #32
34188ec8:	af02      	add	r7, sp, #8
34188eca:	60f8      	str	r0, [r7, #12]
34188ecc:	4608      	mov	r0, r1
34188ece:	4611      	mov	r1, r2
34188ed0:	461a      	mov	r2, r3
34188ed2:	4603      	mov	r3, r0
34188ed4:	817b      	strh	r3, [r7, #10]
34188ed6:	460b      	mov	r3, r1
34188ed8:	813b      	strh	r3, [r7, #8]
34188eda:	4613      	mov	r3, r2
34188edc:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
34188ede:	68fb      	ldr	r3, [r7, #12]
34188ee0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34188ee4:	b2db      	uxtb	r3, r3
34188ee6:	2b20      	cmp	r3, #32
34188ee8:	f040 80f9 	bne.w	341890de <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
34188eec:	6a3b      	ldr	r3, [r7, #32]
34188eee:	2b00      	cmp	r3, #0
34188ef0:	d002      	beq.n	34188ef8 <HAL_I2C_Mem_Write+0x34>
34188ef2:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
34188ef4:	2b00      	cmp	r3, #0
34188ef6:	d105      	bne.n	34188f04 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34188ef8:	68fb      	ldr	r3, [r7, #12]
34188efa:	f44f 7200 	mov.w	r2, #512	@ 0x200
34188efe:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
34188f00:	2301      	movs	r3, #1
34188f02:	e0ed      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34188f04:	68fb      	ldr	r3, [r7, #12]
34188f06:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34188f0a:	2b01      	cmp	r3, #1
34188f0c:	d101      	bne.n	34188f12 <HAL_I2C_Mem_Write+0x4e>
34188f0e:	2302      	movs	r3, #2
34188f10:	e0e6      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
34188f12:	68fb      	ldr	r3, [r7, #12]
34188f14:	2201      	movs	r2, #1
34188f16:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
34188f1a:	f7fc fa19 	bl	34185350 <HAL_GetTick>
34188f1e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34188f20:	697b      	ldr	r3, [r7, #20]
34188f22:	9300      	str	r3, [sp, #0]
34188f24:	2319      	movs	r3, #25
34188f26:	2201      	movs	r2, #1
34188f28:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34188f2c:	68f8      	ldr	r0, [r7, #12]
34188f2e:	f000 fadd 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
34188f32:	4603      	mov	r3, r0
34188f34:	2b00      	cmp	r3, #0
34188f36:	d001      	beq.n	34188f3c <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
34188f38:	2301      	movs	r3, #1
34188f3a:	e0d1      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
34188f3c:	68fb      	ldr	r3, [r7, #12]
34188f3e:	2221      	movs	r2, #33	@ 0x21
34188f40:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
34188f44:	68fb      	ldr	r3, [r7, #12]
34188f46:	2240      	movs	r2, #64	@ 0x40
34188f48:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34188f4c:	68fb      	ldr	r3, [r7, #12]
34188f4e:	2200      	movs	r2, #0
34188f50:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
34188f52:	68fb      	ldr	r3, [r7, #12]
34188f54:	6a3a      	ldr	r2, [r7, #32]
34188f56:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
34188f58:	68fb      	ldr	r3, [r7, #12]
34188f5a:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
34188f5c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
34188f5e:	68fb      	ldr	r3, [r7, #12]
34188f60:	2200      	movs	r2, #0
34188f62:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
34188f64:	88f8      	ldrh	r0, [r7, #6]
34188f66:	893a      	ldrh	r2, [r7, #8]
34188f68:	8979      	ldrh	r1, [r7, #10]
34188f6a:	697b      	ldr	r3, [r7, #20]
34188f6c:	9301      	str	r3, [sp, #4]
34188f6e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34188f70:	9300      	str	r3, [sp, #0]
34188f72:	4603      	mov	r3, r0
34188f74:	68f8      	ldr	r0, [r7, #12]
34188f76:	f000 f9ed 	bl	34189354 <I2C_RequestMemoryWrite>
34188f7a:	4603      	mov	r3, r0
34188f7c:	2b00      	cmp	r3, #0
34188f7e:	d005      	beq.n	34188f8c <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
34188f80:	68fb      	ldr	r3, [r7, #12]
34188f82:	2200      	movs	r2, #0
34188f84:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
34188f88:	2301      	movs	r3, #1
34188f8a:	e0a9      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34188f8c:	68fb      	ldr	r3, [r7, #12]
34188f8e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34188f90:	b29b      	uxth	r3, r3
34188f92:	2bff      	cmp	r3, #255	@ 0xff
34188f94:	d90e      	bls.n	34188fb4 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
34188f96:	68fb      	ldr	r3, [r7, #12]
34188f98:	22ff      	movs	r2, #255	@ 0xff
34188f9a:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
34188f9c:	68fb      	ldr	r3, [r7, #12]
34188f9e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34188fa0:	b2da      	uxtb	r2, r3
34188fa2:	8979      	ldrh	r1, [r7, #10]
34188fa4:	2300      	movs	r3, #0
34188fa6:	9300      	str	r3, [sp, #0]
34188fa8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34188fac:	68f8      	ldr	r0, [r7, #12]
34188fae:	f000 fc61 	bl	34189874 <I2C_TransferConfig>
34188fb2:	e00f      	b.n	34188fd4 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
34188fb4:	68fb      	ldr	r3, [r7, #12]
34188fb6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34188fb8:	b29a      	uxth	r2, r3
34188fba:	68fb      	ldr	r3, [r7, #12]
34188fbc:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
34188fbe:	68fb      	ldr	r3, [r7, #12]
34188fc0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34188fc2:	b2da      	uxtb	r2, r3
34188fc4:	8979      	ldrh	r1, [r7, #10]
34188fc6:	2300      	movs	r3, #0
34188fc8:	9300      	str	r3, [sp, #0]
34188fca:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34188fce:	68f8      	ldr	r0, [r7, #12]
34188fd0:	f000 fc50 	bl	34189874 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34188fd4:	697a      	ldr	r2, [r7, #20]
34188fd6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34188fd8:	68f8      	ldr	r0, [r7, #12]
34188fda:	f000 fae0 	bl	3418959e <I2C_WaitOnTXISFlagUntilTimeout>
34188fde:	4603      	mov	r3, r0
34188fe0:	2b00      	cmp	r3, #0
34188fe2:	d001      	beq.n	34188fe8 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
34188fe4:	2301      	movs	r3, #1
34188fe6:	e07b      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34188fe8:	68fb      	ldr	r3, [r7, #12]
34188fea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34188fec:	781a      	ldrb	r2, [r3, #0]
34188fee:	68fb      	ldr	r3, [r7, #12]
34188ff0:	681b      	ldr	r3, [r3, #0]
34188ff2:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34188ff4:	68fb      	ldr	r3, [r7, #12]
34188ff6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34188ff8:	1c5a      	adds	r2, r3, #1
34188ffa:	68fb      	ldr	r3, [r7, #12]
34188ffc:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
34188ffe:	68fb      	ldr	r3, [r7, #12]
34189000:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34189002:	b29b      	uxth	r3, r3
34189004:	3b01      	subs	r3, #1
34189006:	b29a      	uxth	r2, r3
34189008:	68fb      	ldr	r3, [r7, #12]
3418900a:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
3418900c:	68fb      	ldr	r3, [r7, #12]
3418900e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189010:	3b01      	subs	r3, #1
34189012:	b29a      	uxth	r2, r3
34189014:	68fb      	ldr	r3, [r7, #12]
34189016:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34189018:	68fb      	ldr	r3, [r7, #12]
3418901a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418901c:	b29b      	uxth	r3, r3
3418901e:	2b00      	cmp	r3, #0
34189020:	d034      	beq.n	3418908c <HAL_I2C_Mem_Write+0x1c8>
34189022:	68fb      	ldr	r3, [r7, #12]
34189024:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189026:	2b00      	cmp	r3, #0
34189028:	d130      	bne.n	3418908c <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3418902a:	697b      	ldr	r3, [r7, #20]
3418902c:	9300      	str	r3, [sp, #0]
3418902e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34189030:	2200      	movs	r2, #0
34189032:	2180      	movs	r1, #128	@ 0x80
34189034:	68f8      	ldr	r0, [r7, #12]
34189036:	f000 fa59 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
3418903a:	4603      	mov	r3, r0
3418903c:	2b00      	cmp	r3, #0
3418903e:	d001      	beq.n	34189044 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
34189040:	2301      	movs	r3, #1
34189042:	e04d      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34189044:	68fb      	ldr	r3, [r7, #12]
34189046:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34189048:	b29b      	uxth	r3, r3
3418904a:	2bff      	cmp	r3, #255	@ 0xff
3418904c:	d90e      	bls.n	3418906c <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3418904e:	68fb      	ldr	r3, [r7, #12]
34189050:	22ff      	movs	r2, #255	@ 0xff
34189052:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
34189054:	68fb      	ldr	r3, [r7, #12]
34189056:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189058:	b2da      	uxtb	r2, r3
3418905a:	8979      	ldrh	r1, [r7, #10]
3418905c:	2300      	movs	r3, #0
3418905e:	9300      	str	r3, [sp, #0]
34189060:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34189064:	68f8      	ldr	r0, [r7, #12]
34189066:	f000 fc05 	bl	34189874 <I2C_TransferConfig>
3418906a:	e00f      	b.n	3418908c <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3418906c:	68fb      	ldr	r3, [r7, #12]
3418906e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34189070:	b29a      	uxth	r2, r3
34189072:	68fb      	ldr	r3, [r7, #12]
34189074:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
34189076:	68fb      	ldr	r3, [r7, #12]
34189078:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418907a:	b2da      	uxtb	r2, r3
3418907c:	8979      	ldrh	r1, [r7, #10]
3418907e:	2300      	movs	r3, #0
34189080:	9300      	str	r3, [sp, #0]
34189082:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34189086:	68f8      	ldr	r0, [r7, #12]
34189088:	f000 fbf4 	bl	34189874 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
3418908c:	68fb      	ldr	r3, [r7, #12]
3418908e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34189090:	b29b      	uxth	r3, r3
34189092:	2b00      	cmp	r3, #0
34189094:	d19e      	bne.n	34188fd4 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
34189096:	697a      	ldr	r2, [r7, #20]
34189098:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418909a:	68f8      	ldr	r0, [r7, #12]
3418909c:	f000 fac6 	bl	3418962c <I2C_WaitOnSTOPFlagUntilTimeout>
341890a0:	4603      	mov	r3, r0
341890a2:	2b00      	cmp	r3, #0
341890a4:	d001      	beq.n	341890aa <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
341890a6:	2301      	movs	r3, #1
341890a8:	e01a      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
341890aa:	68fb      	ldr	r3, [r7, #12]
341890ac:	681b      	ldr	r3, [r3, #0]
341890ae:	2220      	movs	r2, #32
341890b0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
341890b2:	68fb      	ldr	r3, [r7, #12]
341890b4:	681b      	ldr	r3, [r3, #0]
341890b6:	6859      	ldr	r1, [r3, #4]
341890b8:	68fb      	ldr	r3, [r7, #12]
341890ba:	681a      	ldr	r2, [r3, #0]
341890bc:	4b0a      	ldr	r3, [pc, #40]	@ (341890e8 <HAL_I2C_Mem_Write+0x224>)
341890be:	400b      	ands	r3, r1
341890c0:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
341890c2:	68fb      	ldr	r3, [r7, #12]
341890c4:	2220      	movs	r2, #32
341890c6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
341890ca:	68fb      	ldr	r3, [r7, #12]
341890cc:	2200      	movs	r2, #0
341890ce:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
341890d2:	68fb      	ldr	r3, [r7, #12]
341890d4:	2200      	movs	r2, #0
341890d6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
341890da:	2300      	movs	r3, #0
341890dc:	e000      	b.n	341890e0 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
341890de:	2302      	movs	r3, #2
  }
}
341890e0:	4618      	mov	r0, r3
341890e2:	3718      	adds	r7, #24
341890e4:	46bd      	mov	sp, r7
341890e6:	bd80      	pop	{r7, pc}
341890e8:	fe00e800 	.word	0xfe00e800

341890ec <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
341890ec:	b580      	push	{r7, lr}
341890ee:	b088      	sub	sp, #32
341890f0:	af02      	add	r7, sp, #8
341890f2:	60f8      	str	r0, [r7, #12]
341890f4:	4608      	mov	r0, r1
341890f6:	4611      	mov	r1, r2
341890f8:	461a      	mov	r2, r3
341890fa:	4603      	mov	r3, r0
341890fc:	817b      	strh	r3, [r7, #10]
341890fe:	460b      	mov	r3, r1
34189100:	813b      	strh	r3, [r7, #8]
34189102:	4613      	mov	r3, r2
34189104:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
34189106:	68fb      	ldr	r3, [r7, #12]
34189108:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418910c:	b2db      	uxtb	r3, r3
3418910e:	2b20      	cmp	r3, #32
34189110:	f040 80fd 	bne.w	3418930e <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
34189114:	6a3b      	ldr	r3, [r7, #32]
34189116:	2b00      	cmp	r3, #0
34189118:	d002      	beq.n	34189120 <HAL_I2C_Mem_Read+0x34>
3418911a:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
3418911c:	2b00      	cmp	r3, #0
3418911e:	d105      	bne.n	3418912c <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
34189120:	68fb      	ldr	r3, [r7, #12]
34189122:	f44f 7200 	mov.w	r2, #512	@ 0x200
34189126:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
34189128:	2301      	movs	r3, #1
3418912a:	e0f1      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
3418912c:	68fb      	ldr	r3, [r7, #12]
3418912e:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34189132:	2b01      	cmp	r3, #1
34189134:	d101      	bne.n	3418913a <HAL_I2C_Mem_Read+0x4e>
34189136:	2302      	movs	r3, #2
34189138:	e0ea      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
3418913a:	68fb      	ldr	r3, [r7, #12]
3418913c:	2201      	movs	r2, #1
3418913e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
34189142:	f7fc f905 	bl	34185350 <HAL_GetTick>
34189146:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
34189148:	697b      	ldr	r3, [r7, #20]
3418914a:	9300      	str	r3, [sp, #0]
3418914c:	2319      	movs	r3, #25
3418914e:	2201      	movs	r2, #1
34189150:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34189154:	68f8      	ldr	r0, [r7, #12]
34189156:	f000 f9c9 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
3418915a:	4603      	mov	r3, r0
3418915c:	2b00      	cmp	r3, #0
3418915e:	d001      	beq.n	34189164 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
34189160:	2301      	movs	r3, #1
34189162:	e0d5      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
34189164:	68fb      	ldr	r3, [r7, #12]
34189166:	2222      	movs	r2, #34	@ 0x22
34189168:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3418916c:	68fb      	ldr	r3, [r7, #12]
3418916e:	2240      	movs	r2, #64	@ 0x40
34189170:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34189174:	68fb      	ldr	r3, [r7, #12]
34189176:	2200      	movs	r2, #0
34189178:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3418917a:	68fb      	ldr	r3, [r7, #12]
3418917c:	6a3a      	ldr	r2, [r7, #32]
3418917e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
34189180:	68fb      	ldr	r3, [r7, #12]
34189182:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
34189184:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
34189186:	68fb      	ldr	r3, [r7, #12]
34189188:	2200      	movs	r2, #0
3418918a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3418918c:	88f8      	ldrh	r0, [r7, #6]
3418918e:	893a      	ldrh	r2, [r7, #8]
34189190:	8979      	ldrh	r1, [r7, #10]
34189192:	697b      	ldr	r3, [r7, #20]
34189194:	9301      	str	r3, [sp, #4]
34189196:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34189198:	9300      	str	r3, [sp, #0]
3418919a:	4603      	mov	r3, r0
3418919c:	68f8      	ldr	r0, [r7, #12]
3418919e:	f000 f92d 	bl	341893fc <I2C_RequestMemoryRead>
341891a2:	4603      	mov	r3, r0
341891a4:	2b00      	cmp	r3, #0
341891a6:	d005      	beq.n	341891b4 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
341891a8:	68fb      	ldr	r3, [r7, #12]
341891aa:	2200      	movs	r2, #0
341891ac:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
341891b0:	2301      	movs	r3, #1
341891b2:	e0ad      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
341891b4:	68fb      	ldr	r3, [r7, #12]
341891b6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341891b8:	b29b      	uxth	r3, r3
341891ba:	2bff      	cmp	r3, #255	@ 0xff
341891bc:	d90e      	bls.n	341891dc <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
341891be:	68fb      	ldr	r3, [r7, #12]
341891c0:	22ff      	movs	r2, #255	@ 0xff
341891c2:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
341891c4:	68fb      	ldr	r3, [r7, #12]
341891c6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341891c8:	b2da      	uxtb	r2, r3
341891ca:	8979      	ldrh	r1, [r7, #10]
341891cc:	4b52      	ldr	r3, [pc, #328]	@ (34189318 <HAL_I2C_Mem_Read+0x22c>)
341891ce:	9300      	str	r3, [sp, #0]
341891d0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341891d4:	68f8      	ldr	r0, [r7, #12]
341891d6:	f000 fb4d 	bl	34189874 <I2C_TransferConfig>
341891da:	e00f      	b.n	341891fc <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
341891dc:	68fb      	ldr	r3, [r7, #12]
341891de:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341891e0:	b29a      	uxth	r2, r3
341891e2:	68fb      	ldr	r3, [r7, #12]
341891e4:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
341891e6:	68fb      	ldr	r3, [r7, #12]
341891e8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341891ea:	b2da      	uxtb	r2, r3
341891ec:	8979      	ldrh	r1, [r7, #10]
341891ee:	4b4a      	ldr	r3, [pc, #296]	@ (34189318 <HAL_I2C_Mem_Read+0x22c>)
341891f0:	9300      	str	r3, [sp, #0]
341891f2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341891f6:	68f8      	ldr	r0, [r7, #12]
341891f8:	f000 fb3c 	bl	34189874 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
341891fc:	697b      	ldr	r3, [r7, #20]
341891fe:	9300      	str	r3, [sp, #0]
34189200:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34189202:	2200      	movs	r2, #0
34189204:	2104      	movs	r1, #4
34189206:	68f8      	ldr	r0, [r7, #12]
34189208:	f000 f970 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
3418920c:	4603      	mov	r3, r0
3418920e:	2b00      	cmp	r3, #0
34189210:	d001      	beq.n	34189216 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
34189212:	2301      	movs	r3, #1
34189214:	e07c      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34189216:	68fb      	ldr	r3, [r7, #12]
34189218:	681b      	ldr	r3, [r3, #0]
3418921a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3418921c:	68fb      	ldr	r3, [r7, #12]
3418921e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189220:	b2d2      	uxtb	r2, r2
34189222:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34189224:	68fb      	ldr	r3, [r7, #12]
34189226:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189228:	1c5a      	adds	r2, r3, #1
3418922a:	68fb      	ldr	r3, [r7, #12]
3418922c:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
3418922e:	68fb      	ldr	r3, [r7, #12]
34189230:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189232:	3b01      	subs	r3, #1
34189234:	b29a      	uxth	r2, r3
34189236:	68fb      	ldr	r3, [r7, #12]
34189238:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
3418923a:	68fb      	ldr	r3, [r7, #12]
3418923c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418923e:	b29b      	uxth	r3, r3
34189240:	3b01      	subs	r3, #1
34189242:	b29a      	uxth	r2, r3
34189244:	68fb      	ldr	r3, [r7, #12]
34189246:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34189248:	68fb      	ldr	r3, [r7, #12]
3418924a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418924c:	b29b      	uxth	r3, r3
3418924e:	2b00      	cmp	r3, #0
34189250:	d034      	beq.n	341892bc <HAL_I2C_Mem_Read+0x1d0>
34189252:	68fb      	ldr	r3, [r7, #12]
34189254:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189256:	2b00      	cmp	r3, #0
34189258:	d130      	bne.n	341892bc <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3418925a:	697b      	ldr	r3, [r7, #20]
3418925c:	9300      	str	r3, [sp, #0]
3418925e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34189260:	2200      	movs	r2, #0
34189262:	2180      	movs	r1, #128	@ 0x80
34189264:	68f8      	ldr	r0, [r7, #12]
34189266:	f000 f941 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
3418926a:	4603      	mov	r3, r0
3418926c:	2b00      	cmp	r3, #0
3418926e:	d001      	beq.n	34189274 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
34189270:	2301      	movs	r3, #1
34189272:	e04d      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
34189274:	68fb      	ldr	r3, [r7, #12]
34189276:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34189278:	b29b      	uxth	r3, r3
3418927a:	2bff      	cmp	r3, #255	@ 0xff
3418927c:	d90e      	bls.n	3418929c <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3418927e:	68fb      	ldr	r3, [r7, #12]
34189280:	22ff      	movs	r2, #255	@ 0xff
34189282:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
34189284:	68fb      	ldr	r3, [r7, #12]
34189286:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34189288:	b2da      	uxtb	r2, r3
3418928a:	8979      	ldrh	r1, [r7, #10]
3418928c:	2300      	movs	r3, #0
3418928e:	9300      	str	r3, [sp, #0]
34189290:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34189294:	68f8      	ldr	r0, [r7, #12]
34189296:	f000 faed 	bl	34189874 <I2C_TransferConfig>
3418929a:	e00f      	b.n	341892bc <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3418929c:	68fb      	ldr	r3, [r7, #12]
3418929e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341892a0:	b29a      	uxth	r2, r3
341892a2:	68fb      	ldr	r3, [r7, #12]
341892a4:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
341892a6:	68fb      	ldr	r3, [r7, #12]
341892a8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341892aa:	b2da      	uxtb	r2, r3
341892ac:	8979      	ldrh	r1, [r7, #10]
341892ae:	2300      	movs	r3, #0
341892b0:	9300      	str	r3, [sp, #0]
341892b2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341892b6:	68f8      	ldr	r0, [r7, #12]
341892b8:	f000 fadc 	bl	34189874 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
341892bc:	68fb      	ldr	r3, [r7, #12]
341892be:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
341892c0:	b29b      	uxth	r3, r3
341892c2:	2b00      	cmp	r3, #0
341892c4:	d19a      	bne.n	341891fc <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
341892c6:	697a      	ldr	r2, [r7, #20]
341892c8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341892ca:	68f8      	ldr	r0, [r7, #12]
341892cc:	f000 f9ae 	bl	3418962c <I2C_WaitOnSTOPFlagUntilTimeout>
341892d0:	4603      	mov	r3, r0
341892d2:	2b00      	cmp	r3, #0
341892d4:	d001      	beq.n	341892da <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
341892d6:	2301      	movs	r3, #1
341892d8:	e01a      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
341892da:	68fb      	ldr	r3, [r7, #12]
341892dc:	681b      	ldr	r3, [r3, #0]
341892de:	2220      	movs	r2, #32
341892e0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
341892e2:	68fb      	ldr	r3, [r7, #12]
341892e4:	681b      	ldr	r3, [r3, #0]
341892e6:	6859      	ldr	r1, [r3, #4]
341892e8:	68fb      	ldr	r3, [r7, #12]
341892ea:	681a      	ldr	r2, [r3, #0]
341892ec:	4b0b      	ldr	r3, [pc, #44]	@ (3418931c <HAL_I2C_Mem_Read+0x230>)
341892ee:	400b      	ands	r3, r1
341892f0:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
341892f2:	68fb      	ldr	r3, [r7, #12]
341892f4:	2220      	movs	r2, #32
341892f6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
341892fa:	68fb      	ldr	r3, [r7, #12]
341892fc:	2200      	movs	r2, #0
341892fe:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34189302:	68fb      	ldr	r3, [r7, #12]
34189304:	2200      	movs	r2, #0
34189306:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418930a:	2300      	movs	r3, #0
3418930c:	e000      	b.n	34189310 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
3418930e:	2302      	movs	r3, #2
  }
}
34189310:	4618      	mov	r0, r3
34189312:	3718      	adds	r7, #24
34189314:	46bd      	mov	sp, r7
34189316:	bd80      	pop	{r7, pc}
34189318:	80002400 	.word	0x80002400
3418931c:	fe00e800 	.word	0xfe00e800

34189320 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(const I2C_HandleTypeDef *hi2c)
{
34189320:	b480      	push	{r7}
34189322:	b083      	sub	sp, #12
34189324:	af00      	add	r7, sp, #0
34189326:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
34189328:	687b      	ldr	r3, [r7, #4]
3418932a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418932e:	b2db      	uxtb	r3, r3
}
34189330:	4618      	mov	r0, r3
34189332:	370c      	adds	r7, #12
34189334:	46bd      	mov	sp, r7
34189336:	f85d 7b04 	ldr.w	r7, [sp], #4
3418933a:	4770      	bx	lr

3418933c <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(const I2C_HandleTypeDef *hi2c)
{
3418933c:	b480      	push	{r7}
3418933e:	b083      	sub	sp, #12
34189340:	af00      	add	r7, sp, #0
34189342:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
34189344:	687b      	ldr	r3, [r7, #4]
34189346:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
}
34189348:	4618      	mov	r0, r3
3418934a:	370c      	adds	r7, #12
3418934c:	46bd      	mov	sp, r7
3418934e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189352:	4770      	bx	lr

34189354 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
34189354:	b580      	push	{r7, lr}
34189356:	b086      	sub	sp, #24
34189358:	af02      	add	r7, sp, #8
3418935a:	60f8      	str	r0, [r7, #12]
3418935c:	4608      	mov	r0, r1
3418935e:	4611      	mov	r1, r2
34189360:	461a      	mov	r2, r3
34189362:	4603      	mov	r3, r0
34189364:	817b      	strh	r3, [r7, #10]
34189366:	460b      	mov	r3, r1
34189368:	813b      	strh	r3, [r7, #8]
3418936a:	4613      	mov	r3, r2
3418936c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3418936e:	88fb      	ldrh	r3, [r7, #6]
34189370:	b2da      	uxtb	r2, r3
34189372:	8979      	ldrh	r1, [r7, #10]
34189374:	4b20      	ldr	r3, [pc, #128]	@ (341893f8 <I2C_RequestMemoryWrite+0xa4>)
34189376:	9300      	str	r3, [sp, #0]
34189378:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418937c:	68f8      	ldr	r0, [r7, #12]
3418937e:	f000 fa79 	bl	34189874 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34189382:	69fa      	ldr	r2, [r7, #28]
34189384:	69b9      	ldr	r1, [r7, #24]
34189386:	68f8      	ldr	r0, [r7, #12]
34189388:	f000 f909 	bl	3418959e <I2C_WaitOnTXISFlagUntilTimeout>
3418938c:	4603      	mov	r3, r0
3418938e:	2b00      	cmp	r3, #0
34189390:	d001      	beq.n	34189396 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
34189392:	2301      	movs	r3, #1
34189394:	e02c      	b.n	341893f0 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
34189396:	88fb      	ldrh	r3, [r7, #6]
34189398:	2b01      	cmp	r3, #1
3418939a:	d105      	bne.n	341893a8 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3418939c:	893b      	ldrh	r3, [r7, #8]
3418939e:	b2da      	uxtb	r2, r3
341893a0:	68fb      	ldr	r3, [r7, #12]
341893a2:	681b      	ldr	r3, [r3, #0]
341893a4:	629a      	str	r2, [r3, #40]	@ 0x28
341893a6:	e015      	b.n	341893d4 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
341893a8:	893b      	ldrh	r3, [r7, #8]
341893aa:	0a1b      	lsrs	r3, r3, #8
341893ac:	b29b      	uxth	r3, r3
341893ae:	b2da      	uxtb	r2, r3
341893b0:	68fb      	ldr	r3, [r7, #12]
341893b2:	681b      	ldr	r3, [r3, #0]
341893b4:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
341893b6:	69fa      	ldr	r2, [r7, #28]
341893b8:	69b9      	ldr	r1, [r7, #24]
341893ba:	68f8      	ldr	r0, [r7, #12]
341893bc:	f000 f8ef 	bl	3418959e <I2C_WaitOnTXISFlagUntilTimeout>
341893c0:	4603      	mov	r3, r0
341893c2:	2b00      	cmp	r3, #0
341893c4:	d001      	beq.n	341893ca <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
341893c6:	2301      	movs	r3, #1
341893c8:	e012      	b.n	341893f0 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
341893ca:	893b      	ldrh	r3, [r7, #8]
341893cc:	b2da      	uxtb	r2, r3
341893ce:	68fb      	ldr	r3, [r7, #12]
341893d0:	681b      	ldr	r3, [r3, #0]
341893d2:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
341893d4:	69fb      	ldr	r3, [r7, #28]
341893d6:	9300      	str	r3, [sp, #0]
341893d8:	69bb      	ldr	r3, [r7, #24]
341893da:	2200      	movs	r2, #0
341893dc:	2180      	movs	r1, #128	@ 0x80
341893de:	68f8      	ldr	r0, [r7, #12]
341893e0:	f000 f884 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
341893e4:	4603      	mov	r3, r0
341893e6:	2b00      	cmp	r3, #0
341893e8:	d001      	beq.n	341893ee <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
341893ea:	2301      	movs	r3, #1
341893ec:	e000      	b.n	341893f0 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
341893ee:	2300      	movs	r3, #0
}
341893f0:	4618      	mov	r0, r3
341893f2:	3710      	adds	r7, #16
341893f4:	46bd      	mov	sp, r7
341893f6:	bd80      	pop	{r7, pc}
341893f8:	80002000 	.word	0x80002000

341893fc <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
341893fc:	b580      	push	{r7, lr}
341893fe:	b086      	sub	sp, #24
34189400:	af02      	add	r7, sp, #8
34189402:	60f8      	str	r0, [r7, #12]
34189404:	4608      	mov	r0, r1
34189406:	4611      	mov	r1, r2
34189408:	461a      	mov	r2, r3
3418940a:	4603      	mov	r3, r0
3418940c:	817b      	strh	r3, [r7, #10]
3418940e:	460b      	mov	r3, r1
34189410:	813b      	strh	r3, [r7, #8]
34189412:	4613      	mov	r3, r2
34189414:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
34189416:	88fb      	ldrh	r3, [r7, #6]
34189418:	b2da      	uxtb	r2, r3
3418941a:	8979      	ldrh	r1, [r7, #10]
3418941c:	4b20      	ldr	r3, [pc, #128]	@ (341894a0 <I2C_RequestMemoryRead+0xa4>)
3418941e:	9300      	str	r3, [sp, #0]
34189420:	2300      	movs	r3, #0
34189422:	68f8      	ldr	r0, [r7, #12]
34189424:	f000 fa26 	bl	34189874 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
34189428:	69fa      	ldr	r2, [r7, #28]
3418942a:	69b9      	ldr	r1, [r7, #24]
3418942c:	68f8      	ldr	r0, [r7, #12]
3418942e:	f000 f8b6 	bl	3418959e <I2C_WaitOnTXISFlagUntilTimeout>
34189432:	4603      	mov	r3, r0
34189434:	2b00      	cmp	r3, #0
34189436:	d001      	beq.n	3418943c <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
34189438:	2301      	movs	r3, #1
3418943a:	e02c      	b.n	34189496 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3418943c:	88fb      	ldrh	r3, [r7, #6]
3418943e:	2b01      	cmp	r3, #1
34189440:	d105      	bne.n	3418944e <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34189442:	893b      	ldrh	r3, [r7, #8]
34189444:	b2da      	uxtb	r2, r3
34189446:	68fb      	ldr	r3, [r7, #12]
34189448:	681b      	ldr	r3, [r3, #0]
3418944a:	629a      	str	r2, [r3, #40]	@ 0x28
3418944c:	e015      	b.n	3418947a <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3418944e:	893b      	ldrh	r3, [r7, #8]
34189450:	0a1b      	lsrs	r3, r3, #8
34189452:	b29b      	uxth	r3, r3
34189454:	b2da      	uxtb	r2, r3
34189456:	68fb      	ldr	r3, [r7, #12]
34189458:	681b      	ldr	r3, [r3, #0]
3418945a:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3418945c:	69fa      	ldr	r2, [r7, #28]
3418945e:	69b9      	ldr	r1, [r7, #24]
34189460:	68f8      	ldr	r0, [r7, #12]
34189462:	f000 f89c 	bl	3418959e <I2C_WaitOnTXISFlagUntilTimeout>
34189466:	4603      	mov	r3, r0
34189468:	2b00      	cmp	r3, #0
3418946a:	d001      	beq.n	34189470 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
3418946c:	2301      	movs	r3, #1
3418946e:	e012      	b.n	34189496 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
34189470:	893b      	ldrh	r3, [r7, #8]
34189472:	b2da      	uxtb	r2, r3
34189474:	68fb      	ldr	r3, [r7, #12]
34189476:	681b      	ldr	r3, [r3, #0]
34189478:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
3418947a:	69fb      	ldr	r3, [r7, #28]
3418947c:	9300      	str	r3, [sp, #0]
3418947e:	69bb      	ldr	r3, [r7, #24]
34189480:	2200      	movs	r2, #0
34189482:	2140      	movs	r1, #64	@ 0x40
34189484:	68f8      	ldr	r0, [r7, #12]
34189486:	f000 f831 	bl	341894ec <I2C_WaitOnFlagUntilTimeout>
3418948a:	4603      	mov	r3, r0
3418948c:	2b00      	cmp	r3, #0
3418948e:	d001      	beq.n	34189494 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
34189490:	2301      	movs	r3, #1
34189492:	e000      	b.n	34189496 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
34189494:	2300      	movs	r3, #0
}
34189496:	4618      	mov	r0, r3
34189498:	3710      	adds	r7, #16
3418949a:	46bd      	mov	sp, r7
3418949c:	bd80      	pop	{r7, pc}
3418949e:	bf00      	nop
341894a0:	80002000 	.word	0x80002000

341894a4 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
341894a4:	b480      	push	{r7}
341894a6:	b083      	sub	sp, #12
341894a8:	af00      	add	r7, sp, #0
341894aa:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
341894ac:	687b      	ldr	r3, [r7, #4]
341894ae:	681b      	ldr	r3, [r3, #0]
341894b0:	699b      	ldr	r3, [r3, #24]
341894b2:	f003 0302 	and.w	r3, r3, #2
341894b6:	2b02      	cmp	r3, #2
341894b8:	d103      	bne.n	341894c2 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
341894ba:	687b      	ldr	r3, [r7, #4]
341894bc:	681b      	ldr	r3, [r3, #0]
341894be:	2200      	movs	r2, #0
341894c0:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
341894c2:	687b      	ldr	r3, [r7, #4]
341894c4:	681b      	ldr	r3, [r3, #0]
341894c6:	699b      	ldr	r3, [r3, #24]
341894c8:	f003 0301 	and.w	r3, r3, #1
341894cc:	2b01      	cmp	r3, #1
341894ce:	d007      	beq.n	341894e0 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
341894d0:	687b      	ldr	r3, [r7, #4]
341894d2:	681b      	ldr	r3, [r3, #0]
341894d4:	699a      	ldr	r2, [r3, #24]
341894d6:	687b      	ldr	r3, [r7, #4]
341894d8:	681b      	ldr	r3, [r3, #0]
341894da:	f042 0201 	orr.w	r2, r2, #1
341894de:	619a      	str	r2, [r3, #24]
  }
}
341894e0:	bf00      	nop
341894e2:	370c      	adds	r7, #12
341894e4:	46bd      	mov	sp, r7
341894e6:	f85d 7b04 	ldr.w	r7, [sp], #4
341894ea:	4770      	bx	lr

341894ec <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
341894ec:	b580      	push	{r7, lr}
341894ee:	b084      	sub	sp, #16
341894f0:	af00      	add	r7, sp, #0
341894f2:	60f8      	str	r0, [r7, #12]
341894f4:	60b9      	str	r1, [r7, #8]
341894f6:	603b      	str	r3, [r7, #0]
341894f8:	4613      	mov	r3, r2
341894fa:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
341894fc:	e03b      	b.n	34189576 <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
341894fe:	69ba      	ldr	r2, [r7, #24]
34189500:	6839      	ldr	r1, [r7, #0]
34189502:	68f8      	ldr	r0, [r7, #12]
34189504:	f000 f8d6 	bl	341896b4 <I2C_IsErrorOccurred>
34189508:	4603      	mov	r3, r0
3418950a:	2b00      	cmp	r3, #0
3418950c:	d001      	beq.n	34189512 <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
3418950e:	2301      	movs	r3, #1
34189510:	e041      	b.n	34189596 <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34189512:	683b      	ldr	r3, [r7, #0]
34189514:	f1b3 3fff 	cmp.w	r3, #4294967295
34189518:	d02d      	beq.n	34189576 <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3418951a:	f7fb ff19 	bl	34185350 <HAL_GetTick>
3418951e:	4602      	mov	r2, r0
34189520:	69bb      	ldr	r3, [r7, #24]
34189522:	1ad3      	subs	r3, r2, r3
34189524:	683a      	ldr	r2, [r7, #0]
34189526:	429a      	cmp	r2, r3
34189528:	d302      	bcc.n	34189530 <I2C_WaitOnFlagUntilTimeout+0x44>
3418952a:	683b      	ldr	r3, [r7, #0]
3418952c:	2b00      	cmp	r3, #0
3418952e:	d122      	bne.n	34189576 <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34189530:	68fb      	ldr	r3, [r7, #12]
34189532:	681b      	ldr	r3, [r3, #0]
34189534:	699a      	ldr	r2, [r3, #24]
34189536:	68bb      	ldr	r3, [r7, #8]
34189538:	4013      	ands	r3, r2
3418953a:	68ba      	ldr	r2, [r7, #8]
3418953c:	429a      	cmp	r2, r3
3418953e:	bf0c      	ite	eq
34189540:	2301      	moveq	r3, #1
34189542:	2300      	movne	r3, #0
34189544:	b2db      	uxtb	r3, r3
34189546:	461a      	mov	r2, r3
34189548:	79fb      	ldrb	r3, [r7, #7]
3418954a:	429a      	cmp	r2, r3
3418954c:	d113      	bne.n	34189576 <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3418954e:	68fb      	ldr	r3, [r7, #12]
34189550:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34189552:	f043 0220 	orr.w	r2, r3, #32
34189556:	68fb      	ldr	r3, [r7, #12]
34189558:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3418955a:	68fb      	ldr	r3, [r7, #12]
3418955c:	2220      	movs	r2, #32
3418955e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34189562:	68fb      	ldr	r3, [r7, #12]
34189564:	2200      	movs	r2, #0
34189566:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3418956a:	68fb      	ldr	r3, [r7, #12]
3418956c:	2200      	movs	r2, #0
3418956e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
34189572:	2301      	movs	r3, #1
34189574:	e00f      	b.n	34189596 <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
34189576:	68fb      	ldr	r3, [r7, #12]
34189578:	681b      	ldr	r3, [r3, #0]
3418957a:	699a      	ldr	r2, [r3, #24]
3418957c:	68bb      	ldr	r3, [r7, #8]
3418957e:	4013      	ands	r3, r2
34189580:	68ba      	ldr	r2, [r7, #8]
34189582:	429a      	cmp	r2, r3
34189584:	bf0c      	ite	eq
34189586:	2301      	moveq	r3, #1
34189588:	2300      	movne	r3, #0
3418958a:	b2db      	uxtb	r3, r3
3418958c:	461a      	mov	r2, r3
3418958e:	79fb      	ldrb	r3, [r7, #7]
34189590:	429a      	cmp	r2, r3
34189592:	d0b4      	beq.n	341894fe <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
34189594:	2300      	movs	r3, #0
}
34189596:	4618      	mov	r0, r3
34189598:	3710      	adds	r7, #16
3418959a:	46bd      	mov	sp, r7
3418959c:	bd80      	pop	{r7, pc}

3418959e <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3418959e:	b580      	push	{r7, lr}
341895a0:	b084      	sub	sp, #16
341895a2:	af00      	add	r7, sp, #0
341895a4:	60f8      	str	r0, [r7, #12]
341895a6:	60b9      	str	r1, [r7, #8]
341895a8:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
341895aa:	e033      	b.n	34189614 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
341895ac:	687a      	ldr	r2, [r7, #4]
341895ae:	68b9      	ldr	r1, [r7, #8]
341895b0:	68f8      	ldr	r0, [r7, #12]
341895b2:	f000 f87f 	bl	341896b4 <I2C_IsErrorOccurred>
341895b6:	4603      	mov	r3, r0
341895b8:	2b00      	cmp	r3, #0
341895ba:	d001      	beq.n	341895c0 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
341895bc:	2301      	movs	r3, #1
341895be:	e031      	b.n	34189624 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
341895c0:	68bb      	ldr	r3, [r7, #8]
341895c2:	f1b3 3fff 	cmp.w	r3, #4294967295
341895c6:	d025      	beq.n	34189614 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
341895c8:	f7fb fec2 	bl	34185350 <HAL_GetTick>
341895cc:	4602      	mov	r2, r0
341895ce:	687b      	ldr	r3, [r7, #4]
341895d0:	1ad3      	subs	r3, r2, r3
341895d2:	68ba      	ldr	r2, [r7, #8]
341895d4:	429a      	cmp	r2, r3
341895d6:	d302      	bcc.n	341895de <I2C_WaitOnTXISFlagUntilTimeout+0x40>
341895d8:	68bb      	ldr	r3, [r7, #8]
341895da:	2b00      	cmp	r3, #0
341895dc:	d11a      	bne.n	34189614 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
341895de:	68fb      	ldr	r3, [r7, #12]
341895e0:	681b      	ldr	r3, [r3, #0]
341895e2:	699b      	ldr	r3, [r3, #24]
341895e4:	f003 0302 	and.w	r3, r3, #2
341895e8:	2b02      	cmp	r3, #2
341895ea:	d013      	beq.n	34189614 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
341895ec:	68fb      	ldr	r3, [r7, #12]
341895ee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341895f0:	f043 0220 	orr.w	r2, r3, #32
341895f4:	68fb      	ldr	r3, [r7, #12]
341895f6:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
341895f8:	68fb      	ldr	r3, [r7, #12]
341895fa:	2220      	movs	r2, #32
341895fc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
34189600:	68fb      	ldr	r3, [r7, #12]
34189602:	2200      	movs	r2, #0
34189604:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
34189608:	68fb      	ldr	r3, [r7, #12]
3418960a:	2200      	movs	r2, #0
3418960c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
34189610:	2301      	movs	r3, #1
34189612:	e007      	b.n	34189624 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
34189614:	68fb      	ldr	r3, [r7, #12]
34189616:	681b      	ldr	r3, [r3, #0]
34189618:	699b      	ldr	r3, [r3, #24]
3418961a:	f003 0302 	and.w	r3, r3, #2
3418961e:	2b02      	cmp	r3, #2
34189620:	d1c4      	bne.n	341895ac <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
34189622:	2300      	movs	r3, #0
}
34189624:	4618      	mov	r0, r3
34189626:	3710      	adds	r7, #16
34189628:	46bd      	mov	sp, r7
3418962a:	bd80      	pop	{r7, pc}

3418962c <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3418962c:	b580      	push	{r7, lr}
3418962e:	b084      	sub	sp, #16
34189630:	af00      	add	r7, sp, #0
34189632:	60f8      	str	r0, [r7, #12]
34189634:	60b9      	str	r1, [r7, #8]
34189636:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34189638:	e02f      	b.n	3418969a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3418963a:	687a      	ldr	r2, [r7, #4]
3418963c:	68b9      	ldr	r1, [r7, #8]
3418963e:	68f8      	ldr	r0, [r7, #12]
34189640:	f000 f838 	bl	341896b4 <I2C_IsErrorOccurred>
34189644:	4603      	mov	r3, r0
34189646:	2b00      	cmp	r3, #0
34189648:	d001      	beq.n	3418964e <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
3418964a:	2301      	movs	r3, #1
3418964c:	e02d      	b.n	341896aa <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3418964e:	f7fb fe7f 	bl	34185350 <HAL_GetTick>
34189652:	4602      	mov	r2, r0
34189654:	687b      	ldr	r3, [r7, #4]
34189656:	1ad3      	subs	r3, r2, r3
34189658:	68ba      	ldr	r2, [r7, #8]
3418965a:	429a      	cmp	r2, r3
3418965c:	d302      	bcc.n	34189664 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
3418965e:	68bb      	ldr	r3, [r7, #8]
34189660:	2b00      	cmp	r3, #0
34189662:	d11a      	bne.n	3418969a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34189664:	68fb      	ldr	r3, [r7, #12]
34189666:	681b      	ldr	r3, [r3, #0]
34189668:	699b      	ldr	r3, [r3, #24]
3418966a:	f003 0320 	and.w	r3, r3, #32
3418966e:	2b20      	cmp	r3, #32
34189670:	d013      	beq.n	3418969a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
34189672:	68fb      	ldr	r3, [r7, #12]
34189674:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34189676:	f043 0220 	orr.w	r2, r3, #32
3418967a:	68fb      	ldr	r3, [r7, #12]
3418967c:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
3418967e:	68fb      	ldr	r3, [r7, #12]
34189680:	2220      	movs	r2, #32
34189682:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
34189686:	68fb      	ldr	r3, [r7, #12]
34189688:	2200      	movs	r2, #0
3418968a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
3418968e:	68fb      	ldr	r3, [r7, #12]
34189690:	2200      	movs	r2, #0
34189692:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
34189696:	2301      	movs	r3, #1
34189698:	e007      	b.n	341896aa <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418969a:	68fb      	ldr	r3, [r7, #12]
3418969c:	681b      	ldr	r3, [r3, #0]
3418969e:	699b      	ldr	r3, [r3, #24]
341896a0:	f003 0320 	and.w	r3, r3, #32
341896a4:	2b20      	cmp	r3, #32
341896a6:	d1c8      	bne.n	3418963a <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
341896a8:	2300      	movs	r3, #0
}
341896aa:	4618      	mov	r0, r3
341896ac:	3710      	adds	r7, #16
341896ae:	46bd      	mov	sp, r7
341896b0:	bd80      	pop	{r7, pc}
	...

341896b4 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
341896b4:	b580      	push	{r7, lr}
341896b6:	b08a      	sub	sp, #40	@ 0x28
341896b8:	af00      	add	r7, sp, #0
341896ba:	60f8      	str	r0, [r7, #12]
341896bc:	60b9      	str	r1, [r7, #8]
341896be:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
341896c0:	2300      	movs	r3, #0
341896c2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
341896c6:	68fb      	ldr	r3, [r7, #12]
341896c8:	681b      	ldr	r3, [r3, #0]
341896ca:	699b      	ldr	r3, [r3, #24]
341896cc:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
341896ce:	2300      	movs	r3, #0
341896d0:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
341896d2:	687b      	ldr	r3, [r7, #4]
341896d4:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
341896d6:	69bb      	ldr	r3, [r7, #24]
341896d8:	f003 0310 	and.w	r3, r3, #16
341896dc:	2b00      	cmp	r3, #0
341896de:	d068      	beq.n	341897b2 <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
341896e0:	68fb      	ldr	r3, [r7, #12]
341896e2:	681b      	ldr	r3, [r3, #0]
341896e4:	2210      	movs	r2, #16
341896e6:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
341896e8:	e049      	b.n	3418977e <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
341896ea:	68bb      	ldr	r3, [r7, #8]
341896ec:	f1b3 3fff 	cmp.w	r3, #4294967295
341896f0:	d045      	beq.n	3418977e <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
341896f2:	f7fb fe2d 	bl	34185350 <HAL_GetTick>
341896f6:	4602      	mov	r2, r0
341896f8:	69fb      	ldr	r3, [r7, #28]
341896fa:	1ad3      	subs	r3, r2, r3
341896fc:	68ba      	ldr	r2, [r7, #8]
341896fe:	429a      	cmp	r2, r3
34189700:	d302      	bcc.n	34189708 <I2C_IsErrorOccurred+0x54>
34189702:	68bb      	ldr	r3, [r7, #8]
34189704:	2b00      	cmp	r3, #0
34189706:	d13a      	bne.n	3418977e <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
34189708:	68fb      	ldr	r3, [r7, #12]
3418970a:	681b      	ldr	r3, [r3, #0]
3418970c:	685b      	ldr	r3, [r3, #4]
3418970e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34189712:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
34189714:	68fb      	ldr	r3, [r7, #12]
34189716:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
3418971a:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
3418971c:	68fb      	ldr	r3, [r7, #12]
3418971e:	681b      	ldr	r3, [r3, #0]
34189720:	699b      	ldr	r3, [r3, #24]
34189722:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34189726:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3418972a:	d121      	bne.n	34189770 <I2C_IsErrorOccurred+0xbc>
3418972c:	697b      	ldr	r3, [r7, #20]
3418972e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34189732:	d01d      	beq.n	34189770 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
34189734:	7cfb      	ldrb	r3, [r7, #19]
34189736:	2b20      	cmp	r3, #32
34189738:	d01a      	beq.n	34189770 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
3418973a:	68fb      	ldr	r3, [r7, #12]
3418973c:	681b      	ldr	r3, [r3, #0]
3418973e:	685a      	ldr	r2, [r3, #4]
34189740:	68fb      	ldr	r3, [r7, #12]
34189742:	681b      	ldr	r3, [r3, #0]
34189744:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34189748:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
3418974a:	f7fb fe01 	bl	34185350 <HAL_GetTick>
3418974e:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34189750:	e00e      	b.n	34189770 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
34189752:	f7fb fdfd 	bl	34185350 <HAL_GetTick>
34189756:	4602      	mov	r2, r0
34189758:	69fb      	ldr	r3, [r7, #28]
3418975a:	1ad3      	subs	r3, r2, r3
3418975c:	2b19      	cmp	r3, #25
3418975e:	d907      	bls.n	34189770 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
34189760:	6a3b      	ldr	r3, [r7, #32]
34189762:	f043 0320 	orr.w	r3, r3, #32
34189766:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
34189768:	2301      	movs	r3, #1
3418976a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
3418976e:	e006      	b.n	3418977e <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
34189770:	68fb      	ldr	r3, [r7, #12]
34189772:	681b      	ldr	r3, [r3, #0]
34189774:	699b      	ldr	r3, [r3, #24]
34189776:	f003 0320 	and.w	r3, r3, #32
3418977a:	2b20      	cmp	r3, #32
3418977c:	d1e9      	bne.n	34189752 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
3418977e:	68fb      	ldr	r3, [r7, #12]
34189780:	681b      	ldr	r3, [r3, #0]
34189782:	699b      	ldr	r3, [r3, #24]
34189784:	f003 0320 	and.w	r3, r3, #32
34189788:	2b20      	cmp	r3, #32
3418978a:	d003      	beq.n	34189794 <I2C_IsErrorOccurred+0xe0>
3418978c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34189790:	2b00      	cmp	r3, #0
34189792:	d0aa      	beq.n	341896ea <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
34189794:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34189798:	2b00      	cmp	r3, #0
3418979a:	d103      	bne.n	341897a4 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3418979c:	68fb      	ldr	r3, [r7, #12]
3418979e:	681b      	ldr	r3, [r3, #0]
341897a0:	2220      	movs	r2, #32
341897a2:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
341897a4:	6a3b      	ldr	r3, [r7, #32]
341897a6:	f043 0304 	orr.w	r3, r3, #4
341897aa:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
341897ac:	2301      	movs	r3, #1
341897ae:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
341897b2:	68fb      	ldr	r3, [r7, #12]
341897b4:	681b      	ldr	r3, [r3, #0]
341897b6:	699b      	ldr	r3, [r3, #24]
341897b8:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
341897ba:	69bb      	ldr	r3, [r7, #24]
341897bc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341897c0:	2b00      	cmp	r3, #0
341897c2:	d00b      	beq.n	341897dc <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
341897c4:	6a3b      	ldr	r3, [r7, #32]
341897c6:	f043 0301 	orr.w	r3, r3, #1
341897ca:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
341897cc:	68fb      	ldr	r3, [r7, #12]
341897ce:	681b      	ldr	r3, [r3, #0]
341897d0:	f44f 7280 	mov.w	r2, #256	@ 0x100
341897d4:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
341897d6:	2301      	movs	r3, #1
341897d8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
341897dc:	69bb      	ldr	r3, [r7, #24]
341897de:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341897e2:	2b00      	cmp	r3, #0
341897e4:	d00b      	beq.n	341897fe <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
341897e6:	6a3b      	ldr	r3, [r7, #32]
341897e8:	f043 0308 	orr.w	r3, r3, #8
341897ec:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
341897ee:	68fb      	ldr	r3, [r7, #12]
341897f0:	681b      	ldr	r3, [r3, #0]
341897f2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341897f6:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
341897f8:	2301      	movs	r3, #1
341897fa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
341897fe:	69bb      	ldr	r3, [r7, #24]
34189800:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34189804:	2b00      	cmp	r3, #0
34189806:	d00b      	beq.n	34189820 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
34189808:	6a3b      	ldr	r3, [r7, #32]
3418980a:	f043 0302 	orr.w	r3, r3, #2
3418980e:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34189810:	68fb      	ldr	r3, [r7, #12]
34189812:	681b      	ldr	r3, [r3, #0]
34189814:	f44f 7200 	mov.w	r2, #512	@ 0x200
34189818:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3418981a:	2301      	movs	r3, #1
3418981c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
34189820:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34189824:	2b00      	cmp	r3, #0
34189826:	d01c      	beq.n	34189862 <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34189828:	68f8      	ldr	r0, [r7, #12]
3418982a:	f7ff fe3b 	bl	341894a4 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3418982e:	68fb      	ldr	r3, [r7, #12]
34189830:	681b      	ldr	r3, [r3, #0]
34189832:	6859      	ldr	r1, [r3, #4]
34189834:	68fb      	ldr	r3, [r7, #12]
34189836:	681a      	ldr	r2, [r3, #0]
34189838:	4b0d      	ldr	r3, [pc, #52]	@ (34189870 <I2C_IsErrorOccurred+0x1bc>)
3418983a:	400b      	ands	r3, r1
3418983c:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
3418983e:	68fb      	ldr	r3, [r7, #12]
34189840:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
34189842:	6a3b      	ldr	r3, [r7, #32]
34189844:	431a      	orrs	r2, r3
34189846:	68fb      	ldr	r3, [r7, #12]
34189848:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
3418984a:	68fb      	ldr	r3, [r7, #12]
3418984c:	2220      	movs	r2, #32
3418984e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
34189852:	68fb      	ldr	r3, [r7, #12]
34189854:	2200      	movs	r2, #0
34189856:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418985a:	68fb      	ldr	r3, [r7, #12]
3418985c:	2200      	movs	r2, #0
3418985e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
34189862:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
34189866:	4618      	mov	r0, r3
34189868:	3728      	adds	r7, #40	@ 0x28
3418986a:	46bd      	mov	sp, r7
3418986c:	bd80      	pop	{r7, pc}
3418986e:	bf00      	nop
34189870:	fe00e800 	.word	0xfe00e800

34189874 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
34189874:	b480      	push	{r7}
34189876:	b087      	sub	sp, #28
34189878:	af00      	add	r7, sp, #0
3418987a:	60f8      	str	r0, [r7, #12]
3418987c:	607b      	str	r3, [r7, #4]
3418987e:	460b      	mov	r3, r1
34189880:	817b      	strh	r3, [r7, #10]
34189882:	4613      	mov	r3, r2
34189884:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34189886:	897b      	ldrh	r3, [r7, #10]
34189888:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3418988c:	7a7b      	ldrb	r3, [r7, #9]
3418988e:	041b      	lsls	r3, r3, #16
34189890:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34189894:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34189896:	687b      	ldr	r3, [r7, #4]
34189898:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418989a:	6a3b      	ldr	r3, [r7, #32]
3418989c:	4313      	orrs	r3, r2
3418989e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341898a2:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
341898a4:	68fb      	ldr	r3, [r7, #12]
341898a6:	681b      	ldr	r3, [r3, #0]
341898a8:	685a      	ldr	r2, [r3, #4]
341898aa:	6a3b      	ldr	r3, [r7, #32]
341898ac:	0d5b      	lsrs	r3, r3, #21
341898ae:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
341898b2:	4b08      	ldr	r3, [pc, #32]	@ (341898d4 <I2C_TransferConfig+0x60>)
341898b4:	430b      	orrs	r3, r1
341898b6:	43db      	mvns	r3, r3
341898b8:	ea02 0103 	and.w	r1, r2, r3
341898bc:	68fb      	ldr	r3, [r7, #12]
341898be:	681b      	ldr	r3, [r3, #0]
341898c0:	697a      	ldr	r2, [r7, #20]
341898c2:	430a      	orrs	r2, r1
341898c4:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
341898c6:	bf00      	nop
341898c8:	371c      	adds	r7, #28
341898ca:	46bd      	mov	sp, r7
341898cc:	f85d 7b04 	ldr.w	r7, [sp], #4
341898d0:	4770      	bx	lr
341898d2:	bf00      	nop
341898d4:	03ff63ff 	.word	0x03ff63ff

341898d8 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
341898d8:	b480      	push	{r7}
341898da:	b083      	sub	sp, #12
341898dc:	af00      	add	r7, sp, #0
341898de:	6078      	str	r0, [r7, #4]
341898e0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
341898e2:	687b      	ldr	r3, [r7, #4]
341898e4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341898e8:	b2db      	uxtb	r3, r3
341898ea:	2b20      	cmp	r3, #32
341898ec:	d138      	bne.n	34189960 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
341898ee:	687b      	ldr	r3, [r7, #4]
341898f0:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341898f4:	2b01      	cmp	r3, #1
341898f6:	d101      	bne.n	341898fc <HAL_I2CEx_ConfigAnalogFilter+0x24>
341898f8:	2302      	movs	r3, #2
341898fa:	e032      	b.n	34189962 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
341898fc:	687b      	ldr	r3, [r7, #4]
341898fe:	2201      	movs	r2, #1
34189900:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34189904:	687b      	ldr	r3, [r7, #4]
34189906:	2224      	movs	r2, #36	@ 0x24
34189908:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3418990c:	687b      	ldr	r3, [r7, #4]
3418990e:	681b      	ldr	r3, [r3, #0]
34189910:	681a      	ldr	r2, [r3, #0]
34189912:	687b      	ldr	r3, [r7, #4]
34189914:	681b      	ldr	r3, [r3, #0]
34189916:	f022 0201 	bic.w	r2, r2, #1
3418991a:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
3418991c:	687b      	ldr	r3, [r7, #4]
3418991e:	681b      	ldr	r3, [r3, #0]
34189920:	681a      	ldr	r2, [r3, #0]
34189922:	687b      	ldr	r3, [r7, #4]
34189924:	681b      	ldr	r3, [r3, #0]
34189926:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
3418992a:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
3418992c:	687b      	ldr	r3, [r7, #4]
3418992e:	681b      	ldr	r3, [r3, #0]
34189930:	6819      	ldr	r1, [r3, #0]
34189932:	687b      	ldr	r3, [r7, #4]
34189934:	681b      	ldr	r3, [r3, #0]
34189936:	683a      	ldr	r2, [r7, #0]
34189938:	430a      	orrs	r2, r1
3418993a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
3418993c:	687b      	ldr	r3, [r7, #4]
3418993e:	681b      	ldr	r3, [r3, #0]
34189940:	681a      	ldr	r2, [r3, #0]
34189942:	687b      	ldr	r3, [r7, #4]
34189944:	681b      	ldr	r3, [r3, #0]
34189946:	f042 0201 	orr.w	r2, r2, #1
3418994a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
3418994c:	687b      	ldr	r3, [r7, #4]
3418994e:	2220      	movs	r2, #32
34189950:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34189954:	687b      	ldr	r3, [r7, #4]
34189956:	2200      	movs	r2, #0
34189958:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418995c:	2300      	movs	r3, #0
3418995e:	e000      	b.n	34189962 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
34189960:	2302      	movs	r3, #2
  }
}
34189962:	4618      	mov	r0, r3
34189964:	370c      	adds	r7, #12
34189966:	46bd      	mov	sp, r7
34189968:	f85d 7b04 	ldr.w	r7, [sp], #4
3418996c:	4770      	bx	lr

3418996e <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
3418996e:	b480      	push	{r7}
34189970:	b085      	sub	sp, #20
34189972:	af00      	add	r7, sp, #0
34189974:	6078      	str	r0, [r7, #4]
34189976:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34189978:	687b      	ldr	r3, [r7, #4]
3418997a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418997e:	b2db      	uxtb	r3, r3
34189980:	2b20      	cmp	r3, #32
34189982:	d139      	bne.n	341899f8 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34189984:	687b      	ldr	r3, [r7, #4]
34189986:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418998a:	2b01      	cmp	r3, #1
3418998c:	d101      	bne.n	34189992 <HAL_I2CEx_ConfigDigitalFilter+0x24>
3418998e:	2302      	movs	r3, #2
34189990:	e033      	b.n	341899fa <HAL_I2CEx_ConfigDigitalFilter+0x8c>
34189992:	687b      	ldr	r3, [r7, #4]
34189994:	2201      	movs	r2, #1
34189996:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
3418999a:	687b      	ldr	r3, [r7, #4]
3418999c:	2224      	movs	r2, #36	@ 0x24
3418999e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
341899a2:	687b      	ldr	r3, [r7, #4]
341899a4:	681b      	ldr	r3, [r3, #0]
341899a6:	681a      	ldr	r2, [r3, #0]
341899a8:	687b      	ldr	r3, [r7, #4]
341899aa:	681b      	ldr	r3, [r3, #0]
341899ac:	f022 0201 	bic.w	r2, r2, #1
341899b0:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
341899b2:	687b      	ldr	r3, [r7, #4]
341899b4:	681b      	ldr	r3, [r3, #0]
341899b6:	681b      	ldr	r3, [r3, #0]
341899b8:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
341899ba:	68fb      	ldr	r3, [r7, #12]
341899bc:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
341899c0:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
341899c2:	683b      	ldr	r3, [r7, #0]
341899c4:	021b      	lsls	r3, r3, #8
341899c6:	68fa      	ldr	r2, [r7, #12]
341899c8:	4313      	orrs	r3, r2
341899ca:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
341899cc:	687b      	ldr	r3, [r7, #4]
341899ce:	681b      	ldr	r3, [r3, #0]
341899d0:	68fa      	ldr	r2, [r7, #12]
341899d2:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
341899d4:	687b      	ldr	r3, [r7, #4]
341899d6:	681b      	ldr	r3, [r3, #0]
341899d8:	681a      	ldr	r2, [r3, #0]
341899da:	687b      	ldr	r3, [r7, #4]
341899dc:	681b      	ldr	r3, [r3, #0]
341899de:	f042 0201 	orr.w	r2, r2, #1
341899e2:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
341899e4:	687b      	ldr	r3, [r7, #4]
341899e6:	2220      	movs	r2, #32
341899e8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
341899ec:	687b      	ldr	r3, [r7, #4]
341899ee:	2200      	movs	r2, #0
341899f0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
341899f4:	2300      	movs	r3, #0
341899f6:	e000      	b.n	341899fa <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
341899f8:	2302      	movs	r3, #2
  }
}
341899fa:	4618      	mov	r0, r3
341899fc:	3714      	adds	r7, #20
341899fe:	46bd      	mov	sp, r7
34189a00:	f85d 7b04 	ldr.w	r7, [sp], #4
34189a04:	4770      	bx	lr

34189a06 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
34189a06:	b580      	push	{r7, lr}
34189a08:	b084      	sub	sp, #16
34189a0a:	af00      	add	r7, sp, #0
34189a0c:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
34189a0e:	687b      	ldr	r3, [r7, #4]
34189a10:	2b00      	cmp	r3, #0
34189a12:	d101      	bne.n	34189a18 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
34189a14:	2301      	movs	r3, #1
34189a16:	e09d      	b.n	34189b54 <HAL_LTDC_Init+0x14e>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34189a18:	687b      	ldr	r3, [r7, #4]
34189a1a:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
34189a1e:	b2db      	uxtb	r3, r3
34189a20:	2b00      	cmp	r3, #0
34189a22:	d106      	bne.n	34189a32 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
34189a24:	687b      	ldr	r3, [r7, #4]
34189a26:	2200      	movs	r2, #0
34189a28:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
34189a2c:	6878      	ldr	r0, [r7, #4]
34189a2e:	f7f8 fdf7 	bl	34182620 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34189a32:	687b      	ldr	r3, [r7, #4]
34189a34:	2202      	movs	r2, #2
34189a36:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34189a3a:	687b      	ldr	r3, [r7, #4]
34189a3c:	681b      	ldr	r3, [r3, #0]
34189a3e:	699a      	ldr	r2, [r3, #24]
34189a40:	687b      	ldr	r3, [r7, #4]
34189a42:	681b      	ldr	r3, [r3, #0]
34189a44:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34189a48:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34189a4a:	687b      	ldr	r3, [r7, #4]
34189a4c:	681b      	ldr	r3, [r3, #0]
34189a4e:	6999      	ldr	r1, [r3, #24]
34189a50:	687b      	ldr	r3, [r7, #4]
34189a52:	685a      	ldr	r2, [r3, #4]
34189a54:	687b      	ldr	r3, [r7, #4]
34189a56:	689b      	ldr	r3, [r3, #8]
34189a58:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34189a5a:	687b      	ldr	r3, [r7, #4]
34189a5c:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34189a5e:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34189a60:	687b      	ldr	r3, [r7, #4]
34189a62:	691b      	ldr	r3, [r3, #16]
34189a64:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34189a66:	687b      	ldr	r3, [r7, #4]
34189a68:	681b      	ldr	r3, [r3, #0]
34189a6a:	430a      	orrs	r2, r1
34189a6c:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
34189a6e:	687b      	ldr	r3, [r7, #4]
34189a70:	695b      	ldr	r3, [r3, #20]
34189a72:	041b      	lsls	r3, r3, #16
34189a74:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34189a76:	687b      	ldr	r3, [r7, #4]
34189a78:	6999      	ldr	r1, [r3, #24]
34189a7a:	687b      	ldr	r3, [r7, #4]
34189a7c:	681b      	ldr	r3, [r3, #0]
34189a7e:	68fa      	ldr	r2, [r7, #12]
34189a80:	430a      	orrs	r2, r1
34189a82:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
34189a84:	687b      	ldr	r3, [r7, #4]
34189a86:	69db      	ldr	r3, [r3, #28]
34189a88:	041b      	lsls	r3, r3, #16
34189a8a:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34189a8c:	687b      	ldr	r3, [r7, #4]
34189a8e:	6a19      	ldr	r1, [r3, #32]
34189a90:	687b      	ldr	r3, [r7, #4]
34189a92:	681b      	ldr	r3, [r3, #0]
34189a94:	68fa      	ldr	r2, [r7, #12]
34189a96:	430a      	orrs	r2, r1
34189a98:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
34189a9a:	687b      	ldr	r3, [r7, #4]
34189a9c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189a9e:	041b      	lsls	r3, r3, #16
34189aa0:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34189aa2:	687b      	ldr	r3, [r7, #4]
34189aa4:	6a99      	ldr	r1, [r3, #40]	@ 0x28
34189aa6:	687b      	ldr	r3, [r7, #4]
34189aa8:	681b      	ldr	r3, [r3, #0]
34189aaa:	68fa      	ldr	r2, [r7, #12]
34189aac:	430a      	orrs	r2, r1
34189aae:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
34189ab0:	687b      	ldr	r3, [r7, #4]
34189ab2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34189ab4:	041b      	lsls	r3, r3, #16
34189ab6:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34189ab8:	687b      	ldr	r3, [r7, #4]
34189aba:	6b19      	ldr	r1, [r3, #48]	@ 0x30
34189abc:	687b      	ldr	r3, [r7, #4]
34189abe:	681b      	ldr	r3, [r3, #0]
34189ac0:	68fa      	ldr	r2, [r7, #12]
34189ac2:	430a      	orrs	r2, r1
34189ac4:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34189ac6:	687b      	ldr	r3, [r7, #4]
34189ac8:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34189acc:	021b      	lsls	r3, r3, #8
34189ace:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34189ad0:	687b      	ldr	r3, [r7, #4]
34189ad2:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34189ad6:	041b      	lsls	r3, r3, #16
34189ad8:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34189ada:	687b      	ldr	r3, [r7, #4]
34189adc:	681b      	ldr	r3, [r3, #0]
34189ade:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34189ae0:	687b      	ldr	r3, [r7, #4]
34189ae2:	681b      	ldr	r3, [r3, #0]
34189ae4:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
34189ae8:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34189aea:	687b      	ldr	r3, [r7, #4]
34189aec:	681b      	ldr	r3, [r3, #0]
34189aee:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34189af0:	68ba      	ldr	r2, [r7, #8]
34189af2:	68fb      	ldr	r3, [r7, #12]
34189af4:	4313      	orrs	r3, r2
34189af6:	687a      	ldr	r2, [r7, #4]
34189af8:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
34189afc:	431a      	orrs	r2, r3
34189afe:	687b      	ldr	r3, [r7, #4]
34189b00:	681b      	ldr	r3, [r3, #0]
34189b02:	430a      	orrs	r2, r1
34189b04:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34189b06:	687b      	ldr	r3, [r7, #4]
34189b08:	681b      	ldr	r3, [r3, #0]
34189b0a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189b0e:	461a      	mov	r2, r3
34189b10:	2304      	movs	r3, #4
34189b12:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34189b14:	687b      	ldr	r3, [r7, #4]
34189b16:	681b      	ldr	r3, [r3, #0]
34189b18:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34189b1c:	461a      	mov	r2, r3
34189b1e:	2304      	movs	r3, #4
34189b20:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34189b22:	687b      	ldr	r3, [r7, #4]
34189b24:	681b      	ldr	r3, [r3, #0]
34189b26:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34189b28:	687b      	ldr	r3, [r7, #4]
34189b2a:	681b      	ldr	r3, [r3, #0]
34189b2c:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34189b30:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
34189b32:	687b      	ldr	r3, [r7, #4]
34189b34:	681b      	ldr	r3, [r3, #0]
34189b36:	699a      	ldr	r2, [r3, #24]
34189b38:	687b      	ldr	r3, [r7, #4]
34189b3a:	681b      	ldr	r3, [r3, #0]
34189b3c:	f042 0201 	orr.w	r2, r2, #1
34189b40:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34189b42:	687b      	ldr	r3, [r7, #4]
34189b44:	2200      	movs	r2, #0
34189b46:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
34189b4a:	687b      	ldr	r3, [r7, #4]
34189b4c:	2201      	movs	r2, #1
34189b4e:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
34189b52:	2300      	movs	r3, #0
}
34189b54:	4618      	mov	r0, r3
34189b56:	3710      	adds	r7, #16
34189b58:	46bd      	mov	sp, r7
34189b5a:	bd80      	pop	{r7, pc}

34189b5c <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
34189b5c:	b5b0      	push	{r4, r5, r7, lr}
34189b5e:	b086      	sub	sp, #24
34189b60:	af02      	add	r7, sp, #8
34189b62:	60f8      	str	r0, [r7, #12]
34189b64:	60b9      	str	r1, [r7, #8]
34189b66:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
34189b68:	68fb      	ldr	r3, [r7, #12]
34189b6a:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
34189b6e:	2b01      	cmp	r3, #1
34189b70:	d101      	bne.n	34189b76 <HAL_LTDC_ConfigLayer+0x1a>
34189b72:	2302      	movs	r3, #2
34189b74:	e052      	b.n	34189c1c <HAL_LTDC_ConfigLayer+0xc0>
34189b76:	68fb      	ldr	r3, [r7, #12]
34189b78:	2201      	movs	r2, #1
34189b7a:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34189b7e:	68fb      	ldr	r3, [r7, #12]
34189b80:	2202      	movs	r2, #2
34189b82:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34189b86:	68fa      	ldr	r2, [r7, #12]
34189b88:	687b      	ldr	r3, [r7, #4]
34189b8a:	2134      	movs	r1, #52	@ 0x34
34189b8c:	fb01 f303 	mul.w	r3, r1, r3
34189b90:	4413      	add	r3, r2
34189b92:	f103 0238 	add.w	r2, r3, #56	@ 0x38
34189b96:	68bb      	ldr	r3, [r7, #8]
34189b98:	4614      	mov	r4, r2
34189b9a:	461d      	mov	r5, r3
34189b9c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34189b9e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34189ba0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34189ba2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34189ba4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34189ba6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34189ba8:	682b      	ldr	r3, [r5, #0]
34189baa:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34189bac:	6879      	ldr	r1, [r7, #4]
34189bae:	68f8      	ldr	r0, [r7, #12]
34189bb0:	f001 faf6 	bl	3418b1a0 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34189bb4:	6879      	ldr	r1, [r7, #4]
34189bb6:	68f8      	ldr	r0, [r7, #12]
34189bb8:	f001 fa48 	bl	3418b04c <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34189bbc:	68fb      	ldr	r3, [r7, #12]
34189bbe:	681b      	ldr	r3, [r3, #0]
34189bc0:	461a      	mov	r2, r3
34189bc2:	687b      	ldr	r3, [r7, #4]
34189bc4:	021b      	lsls	r3, r3, #8
34189bc6:	4413      	add	r3, r2
34189bc8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189bcc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34189bce:	68fa      	ldr	r2, [r7, #12]
34189bd0:	6812      	ldr	r2, [r2, #0]
34189bd2:	4611      	mov	r1, r2
34189bd4:	687a      	ldr	r2, [r7, #4]
34189bd6:	0212      	lsls	r2, r2, #8
34189bd8:	440a      	add	r2, r1
34189bda:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34189bde:	f023 0308 	bic.w	r3, r3, #8
34189be2:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34189be4:	687b      	ldr	r3, [r7, #4]
34189be6:	9300      	str	r3, [sp, #0]
34189be8:	2303      	movs	r3, #3
34189bea:	2200      	movs	r2, #0
34189bec:	2100      	movs	r1, #0
34189bee:	68f8      	ldr	r0, [r7, #12]
34189bf0:	f000 fba0 	bl	3418a334 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34189bf4:	68fb      	ldr	r3, [r7, #12]
34189bf6:	681b      	ldr	r3, [r3, #0]
34189bf8:	461a      	mov	r2, r3
34189bfa:	687b      	ldr	r3, [r7, #4]
34189bfc:	021b      	lsls	r3, r3, #8
34189bfe:	4413      	add	r3, r2
34189c00:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189c04:	461a      	mov	r2, r3
34189c06:	2305      	movs	r3, #5
34189c08:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
34189c0a:	68fb      	ldr	r3, [r7, #12]
34189c0c:	2201      	movs	r2, #1
34189c0e:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
34189c12:	68fb      	ldr	r3, [r7, #12]
34189c14:	2200      	movs	r2, #0
34189c16:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
34189c1a:	2300      	movs	r3, #0
}
34189c1c:	4618      	mov	r0, r3
34189c1e:	3710      	adds	r7, #16
34189c20:	46bd      	mov	sp, r7
34189c22:	bdb0      	pop	{r4, r5, r7, pc}

34189c24 <HAL_LTDC_SetAddress>:
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
34189c24:	b580      	push	{r7, lr}
34189c26:	b08a      	sub	sp, #40	@ 0x28
34189c28:	af02      	add	r7, sp, #8
34189c2a:	60f8      	str	r0, [r7, #12]
34189c2c:	60b9      	str	r1, [r7, #8]
34189c2e:	607a      	str	r2, [r7, #4]
  uint32_t aux0Addr = 0U;
34189c30:	2300      	movs	r3, #0
34189c32:	61fb      	str	r3, [r7, #28]
  uint32_t aux1Addr = 0U;
34189c34:	2300      	movs	r3, #0
34189c36:	61bb      	str	r3, [r7, #24]
  uint32_t mirror = 0U;
34189c38:	2300      	movs	r3, #0
34189c3a:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Process locked */
  __HAL_LOCK(hltdc);
34189c3c:	68fb      	ldr	r3, [r7, #12]
34189c3e:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
34189c42:	2b01      	cmp	r3, #1
34189c44:	d101      	bne.n	34189c4a <HAL_LTDC_SetAddress+0x26>
34189c46:	2302      	movs	r3, #2
34189c48:	e039      	b.n	34189cbe <HAL_LTDC_SetAddress+0x9a>
34189c4a:	68fb      	ldr	r3, [r7, #12]
34189c4c:	2201      	movs	r2, #1
34189c4e:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34189c52:	68fb      	ldr	r3, [r7, #12]
34189c54:	2202      	movs	r2, #2
34189c56:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Get previous user configuration */
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
34189c5a:	f107 0018 	add.w	r0, r7, #24
34189c5e:	f107 021c 	add.w	r2, r7, #28
34189c62:	f107 0114 	add.w	r1, r7, #20
34189c66:	687b      	ldr	r3, [r7, #4]
34189c68:	9300      	str	r3, [sp, #0]
34189c6a:	4603      	mov	r3, r0
34189c6c:	68f8      	ldr	r0, [r7, #12]
34189c6e:	f000 f82a 	bl	34189cc6 <LTDC_RetrieveUserConfig>

  /* Reconfigure the Address */
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
34189c72:	68fa      	ldr	r2, [r7, #12]
34189c74:	687b      	ldr	r3, [r7, #4]
34189c76:	2134      	movs	r1, #52	@ 0x34
34189c78:	fb01 f303 	mul.w	r3, r1, r3
34189c7c:	4413      	add	r3, r2
34189c7e:	335c      	adds	r3, #92	@ 0x5c
34189c80:	68ba      	ldr	r2, [r7, #8]
34189c82:	601a      	str	r2, [r3, #0]

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, 0U, 0U, mirror, LayerIdx);
34189c84:	697a      	ldr	r2, [r7, #20]
34189c86:	687b      	ldr	r3, [r7, #4]
34189c88:	9300      	str	r3, [sp, #0]
34189c8a:	4613      	mov	r3, r2
34189c8c:	2200      	movs	r2, #0
34189c8e:	2100      	movs	r1, #0
34189c90:	68f8      	ldr	r0, [r7, #12]
34189c92:	f000 fb4f 	bl	3418a334 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34189c96:	68fb      	ldr	r3, [r7, #12]
34189c98:	681b      	ldr	r3, [r3, #0]
34189c9a:	461a      	mov	r2, r3
34189c9c:	687b      	ldr	r3, [r7, #4]
34189c9e:	021b      	lsls	r3, r3, #8
34189ca0:	4413      	add	r3, r2
34189ca2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189ca6:	461a      	mov	r2, r3
34189ca8:	2305      	movs	r3, #5
34189caa:	6093      	str	r3, [r2, #8]

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
34189cac:	68fb      	ldr	r3, [r7, #12]
34189cae:	2201      	movs	r2, #1
34189cb0:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
34189cb4:	68fb      	ldr	r3, [r7, #12]
34189cb6:	2200      	movs	r2, #0
34189cb8:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
34189cbc:	2300      	movs	r3, #0
}
34189cbe:	4618      	mov	r0, r3
34189cc0:	3720      	adds	r7, #32
34189cc2:	46bd      	mov	sp, r7
34189cc4:	bd80      	pop	{r7, pc}

34189cc6 <LTDC_RetrieveUserConfig>:
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
  */
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
                                    uint32_t *Aux1Addr, uint32_t LayerIdx)
{
34189cc6:	b4b0      	push	{r4, r5, r7}
34189cc8:	b089      	sub	sp, #36	@ 0x24
34189cca:	af00      	add	r7, sp, #0
34189ccc:	60f8      	str	r0, [r7, #12]
34189cce:	60b9      	str	r1, [r7, #8]
34189cd0:	607a      	str	r2, [r7, #4]
34189cd2:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
34189cd4:	68fb      	ldr	r3, [r7, #12]
34189cd6:	681b      	ldr	r3, [r3, #0]
34189cd8:	461a      	mov	r2, r3
34189cda:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189cdc:	021b      	lsls	r3, r3, #8
34189cde:	4413      	add	r3, r2
34189ce0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189ce4:	68db      	ldr	r3, [r3, #12]
34189ce6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34189cea:	61bb      	str	r3, [r7, #24]
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
34189cec:	68fb      	ldr	r3, [r7, #12]
34189cee:	681b      	ldr	r3, [r3, #0]
34189cf0:	461a      	mov	r2, r3
34189cf2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189cf4:	021b      	lsls	r3, r3, #8
34189cf6:	4413      	add	r3, r2
34189cf8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189cfc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34189cfe:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34189d02:	617b      	str	r3, [r7, #20]

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34189d04:	68fa      	ldr	r2, [r7, #12]
34189d06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189d08:	2134      	movs	r1, #52	@ 0x34
34189d0a:	fb01 f303 	mul.w	r3, r1, r3
34189d0e:	4413      	add	r3, r2
34189d10:	3348      	adds	r3, #72	@ 0x48
34189d12:	681b      	ldr	r3, [r3, #0]
34189d14:	2b03      	cmp	r3, #3
34189d16:	d821      	bhi.n	34189d5c <LTDC_RetrieveUserConfig+0x96>
34189d18:	e025      	b.n	34189d66 <LTDC_RetrieveUserConfig+0xa0>
34189d1a:	3b04      	subs	r3, #4
34189d1c:	2201      	movs	r2, #1
34189d1e:	fa02 f303 	lsl.w	r3, r2, r3
34189d22:	f240 229b 	movw	r2, #667	@ 0x29b
34189d26:	401a      	ands	r2, r3
34189d28:	2a00      	cmp	r2, #0
34189d2a:	bf14      	ite	ne
34189d2c:	2201      	movne	r2, #1
34189d2e:	2200      	moveq	r2, #0
34189d30:	b2d2      	uxtb	r2, r2
34189d32:	2a00      	cmp	r2, #0
34189d34:	d11d      	bne.n	34189d72 <LTDC_RetrieveUserConfig+0xac>
34189d36:	f403 7280 	and.w	r2, r3, #256	@ 0x100
34189d3a:	2a00      	cmp	r2, #0
34189d3c:	bf14      	ite	ne
34189d3e:	2201      	movne	r2, #1
34189d40:	2200      	moveq	r2, #0
34189d42:	b2d2      	uxtb	r2, r2
34189d44:	2a00      	cmp	r2, #0
34189d46:	d117      	bne.n	34189d78 <LTDC_RetrieveUserConfig+0xb2>
34189d48:	f003 0304 	and.w	r3, r3, #4
34189d4c:	2b00      	cmp	r3, #0
34189d4e:	bf14      	ite	ne
34189d50:	2301      	movne	r3, #1
34189d52:	2300      	moveq	r3, #0
34189d54:	b2db      	uxtb	r3, r3
34189d56:	2b00      	cmp	r3, #0
34189d58:	d108      	bne.n	34189d6c <LTDC_RetrieveUserConfig+0xa6>
34189d5a:	e01b      	b.n	34189d94 <LTDC_RetrieveUserConfig+0xce>
34189d5c:	2b0d      	cmp	r3, #13
34189d5e:	d819      	bhi.n	34189d94 <LTDC_RetrieveUserConfig+0xce>
34189d60:	2b04      	cmp	r3, #4
34189d62:	d2da      	bcs.n	34189d1a <LTDC_RetrieveUserConfig+0x54>
34189d64:	e016      	b.n	34189d94 <LTDC_RetrieveUserConfig+0xce>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34189d66:	2304      	movs	r3, #4
34189d68:	61fb      	str	r3, [r7, #28]
      break;
34189d6a:	e016      	b.n	34189d9a <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
34189d6c:	2303      	movs	r3, #3
34189d6e:	61fb      	str	r3, [r7, #28]
      break;
34189d70:	e013      	b.n	34189d9a <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
34189d72:	2302      	movs	r3, #2
34189d74:	61fb      	str	r3, [r7, #28]
      break;
34189d76:	e010      	b.n	34189d9a <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
34189d78:	68fb      	ldr	r3, [r7, #12]
34189d7a:	681b      	ldr	r3, [r3, #0]
34189d7c:	461a      	mov	r2, r3
34189d7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189d80:	021b      	lsls	r3, r3, #8
34189d82:	4413      	add	r3, r2
34189d84:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189d88:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34189d8a:	0c9b      	lsrs	r3, r3, #18
34189d8c:	f003 0307 	and.w	r3, r3, #7
34189d90:	61fb      	str	r3, [r7, #28]
      break;
34189d92:	e002      	b.n	34189d9a <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
34189d94:	2301      	movs	r3, #1
34189d96:	61fb      	str	r3, [r7, #28]
      break;
34189d98:	bf00      	nop
  }

  if ((pitchSign == 0U) && (hmirror == 0U))
34189d9a:	697b      	ldr	r3, [r7, #20]
34189d9c:	2b00      	cmp	r3, #0
34189d9e:	d12d      	bne.n	34189dfc <LTDC_RetrieveUserConfig+0x136>
34189da0:	69bb      	ldr	r3, [r7, #24]
34189da2:	2b00      	cmp	r3, #0
34189da4:	d12a      	bne.n	34189dfc <LTDC_RetrieveUserConfig+0x136>
  {
    *Mirror = LTDC_MIRROR_NONE;
34189da6:	68bb      	ldr	r3, [r7, #8]
34189da8:	2203      	movs	r2, #3
34189daa:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
34189dac:	68fb      	ldr	r3, [r7, #12]
34189dae:	681b      	ldr	r3, [r3, #0]
34189db0:	461a      	mov	r2, r3
34189db2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189db4:	021b      	lsls	r3, r3, #8
34189db6:	4413      	add	r3, r2
34189db8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189dbc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34189dbe:	68f9      	ldr	r1, [r7, #12]
34189dc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189dc2:	2034      	movs	r0, #52	@ 0x34
34189dc4:	fb00 f303 	mul.w	r3, r0, r3
34189dc8:	440b      	add	r3, r1
34189dca:	335c      	adds	r3, #92	@ 0x5c
34189dcc:	601a      	str	r2, [r3, #0]
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
34189dce:	68fb      	ldr	r3, [r7, #12]
34189dd0:	681b      	ldr	r3, [r3, #0]
34189dd2:	461a      	mov	r2, r3
34189dd4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189dd6:	021b      	lsls	r3, r3, #8
34189dd8:	4413      	add	r3, r2
34189dda:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189dde:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34189de0:	687b      	ldr	r3, [r7, #4]
34189de2:	601a      	str	r2, [r3, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
34189de4:	68fb      	ldr	r3, [r7, #12]
34189de6:	681b      	ldr	r3, [r3, #0]
34189de8:	461a      	mov	r2, r3
34189dea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189dec:	021b      	lsls	r3, r3, #8
34189dee:	4413      	add	r3, r2
34189df0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189df4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
34189df6:	683b      	ldr	r3, [r7, #0]
34189df8:	601a      	str	r2, [r3, #0]
34189dfa:	e296      	b.n	3418a32a <LTDC_RetrieveUserConfig+0x664>
  }
  else if ((pitchSign == 0U) && (hmirror == LTDC_LxCR_HMEN))
34189dfc:	697b      	ldr	r3, [r7, #20]
34189dfe:	2b00      	cmp	r3, #0
34189e00:	f040 80a8 	bne.w	34189f54 <LTDC_RetrieveUserConfig+0x28e>
34189e04:	69bb      	ldr	r3, [r7, #24]
34189e06:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34189e0a:	f040 80a3 	bne.w	34189f54 <LTDC_RetrieveUserConfig+0x28e>
  {
    *Mirror = LTDC_MIRROR_HORIZONTAL;
34189e0e:	68bb      	ldr	r3, [r7, #8]
34189e10:	2200      	movs	r2, #0
34189e12:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34189e14:	68fb      	ldr	r3, [r7, #12]
34189e16:	681b      	ldr	r3, [r3, #0]
34189e18:	461a      	mov	r2, r3
34189e1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e1c:	021b      	lsls	r3, r3, #8
34189e1e:	4413      	add	r3, r2
34189e20:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189e24:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189e26:	68f9      	ldr	r1, [r7, #12]
34189e28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e2a:	2034      	movs	r0, #52	@ 0x34
34189e2c:	fb00 f303 	mul.w	r3, r0, r3
34189e30:	440b      	add	r3, r1
34189e32:	333c      	adds	r3, #60	@ 0x3c
34189e34:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34189e36:	68f8      	ldr	r0, [r7, #12]
34189e38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e3a:	2434      	movs	r4, #52	@ 0x34
34189e3c:	fb04 f303 	mul.w	r3, r4, r3
34189e40:	4403      	add	r3, r0
34189e42:	3338      	adds	r3, #56	@ 0x38
34189e44:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189e46:	1acb      	subs	r3, r1, r3
34189e48:	69f9      	ldr	r1, [r7, #28]
34189e4a:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34189e4e:	1ad3      	subs	r3, r2, r3
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34189e50:	1c5a      	adds	r2, r3, #1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34189e52:	68f9      	ldr	r1, [r7, #12]
34189e54:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e56:	2034      	movs	r0, #52	@ 0x34
34189e58:	fb00 f303 	mul.w	r3, r0, r3
34189e5c:	440b      	add	r3, r1
34189e5e:	335c      	adds	r3, #92	@ 0x5c
34189e60:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34189e62:	68fa      	ldr	r2, [r7, #12]
34189e64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e66:	2134      	movs	r1, #52	@ 0x34
34189e68:	fb01 f303 	mul.w	r3, r1, r3
34189e6c:	4413      	add	r3, r2
34189e6e:	3348      	adds	r3, #72	@ 0x48
34189e70:	681b      	ldr	r3, [r3, #0]
34189e72:	f240 120d 	movw	r2, #269	@ 0x10d
34189e76:	4293      	cmp	r3, r2
34189e78:	d004      	beq.n	34189e84 <LTDC_RetrieveUserConfig+0x1be>
34189e7a:	f240 220d 	movw	r2, #525	@ 0x20d
34189e7e:	4293      	cmp	r3, r2
34189e80:	d022      	beq.n	34189ec8 <LTDC_RetrieveUserConfig+0x202>
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
        break;
      default:
        /* Nothing to do */
        break;
34189e82:	e066      	b.n	34189f52 <LTDC_RetrieveUserConfig+0x28c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189e84:	68fb      	ldr	r3, [r7, #12]
34189e86:	681b      	ldr	r3, [r3, #0]
34189e88:	461a      	mov	r2, r3
34189e8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e8c:	021b      	lsls	r3, r3, #8
34189e8e:	4413      	add	r3, r2
34189e90:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189e94:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                    (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189e96:	68f9      	ldr	r1, [r7, #12]
34189e98:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189e9a:	2034      	movs	r0, #52	@ 0x34
34189e9c:	fb00 f303 	mul.w	r3, r0, r3
34189ea0:	440b      	add	r3, r1
34189ea2:	333c      	adds	r3, #60	@ 0x3c
34189ea4:	6819      	ldr	r1, [r3, #0]
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34189ea6:	68f8      	ldr	r0, [r7, #12]
34189ea8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189eaa:	2434      	movs	r4, #52	@ 0x34
34189eac:	fb04 f303 	mul.w	r3, r4, r3
34189eb0:	4403      	add	r3, r0
34189eb2:	3338      	adds	r3, #56	@ 0x38
34189eb4:	681b      	ldr	r3, [r3, #0]
                    (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189eb6:	1acb      	subs	r3, r1, r3
34189eb8:	69f9      	ldr	r1, [r7, #28]
34189eba:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189ebe:	1ad3      	subs	r3, r2, r3
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
34189ec0:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189ec2:	687b      	ldr	r3, [r7, #4]
34189ec4:	601a      	str	r2, [r3, #0]
        break;
34189ec6:	e044      	b.n	34189f52 <LTDC_RetrieveUserConfig+0x28c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189ec8:	68fb      	ldr	r3, [r7, #12]
34189eca:	681b      	ldr	r3, [r3, #0]
34189ecc:	461a      	mov	r2, r3
34189ece:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189ed0:	021b      	lsls	r3, r3, #8
34189ed2:	4413      	add	r3, r2
34189ed4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189ed8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189eda:	68f9      	ldr	r1, [r7, #12]
34189edc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189ede:	2034      	movs	r0, #52	@ 0x34
34189ee0:	fb00 f303 	mul.w	r3, r0, r3
34189ee4:	440b      	add	r3, r1
34189ee6:	333c      	adds	r3, #60	@ 0x3c
34189ee8:	6819      	ldr	r1, [r3, #0]
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189eea:	68f8      	ldr	r0, [r7, #12]
34189eec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189eee:	2434      	movs	r4, #52	@ 0x34
34189ef0:	fb04 f303 	mul.w	r3, r4, r3
34189ef4:	4403      	add	r3, r0
34189ef6:	3338      	adds	r3, #56	@ 0x38
34189ef8:	681b      	ldr	r3, [r3, #0]
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189efa:	1acb      	subs	r3, r1, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189efc:	085b      	lsrs	r3, r3, #1
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189efe:	69f9      	ldr	r1, [r7, #28]
34189f00:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189f04:	1ad3      	subs	r3, r2, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189f06:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
34189f08:	687b      	ldr	r3, [r7, #4]
34189f0a:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34189f0c:	68fb      	ldr	r3, [r7, #12]
34189f0e:	681b      	ldr	r3, [r3, #0]
34189f10:	461a      	mov	r2, r3
34189f12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f14:	021b      	lsls	r3, r3, #8
34189f16:	4413      	add	r3, r2
34189f18:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189f1c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189f1e:	68f9      	ldr	r1, [r7, #12]
34189f20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f22:	2034      	movs	r0, #52	@ 0x34
34189f24:	fb00 f303 	mul.w	r3, r0, r3
34189f28:	440b      	add	r3, r1
34189f2a:	333c      	adds	r3, #60	@ 0x3c
34189f2c:	6819      	ldr	r1, [r3, #0]
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189f2e:	68f8      	ldr	r0, [r7, #12]
34189f30:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f32:	2434      	movs	r4, #52	@ 0x34
34189f34:	fb04 f303 	mul.w	r3, r4, r3
34189f38:	4403      	add	r3, r0
34189f3a:	3338      	adds	r3, #56	@ 0x38
34189f3c:	681b      	ldr	r3, [r3, #0]
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189f3e:	1acb      	subs	r3, r1, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189f40:	085b      	lsrs	r3, r3, #1
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189f42:	69f9      	ldr	r1, [r7, #28]
34189f44:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34189f48:	1ad3      	subs	r3, r2, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
34189f4a:	1c5a      	adds	r2, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
34189f4c:	683b      	ldr	r3, [r7, #0]
34189f4e:	601a      	str	r2, [r3, #0]
        break;
34189f50:	bf00      	nop
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34189f52:	e1ea      	b.n	3418a32a <LTDC_RetrieveUserConfig+0x664>
    }

  }
  else if ((pitchSign != 0U) && (hmirror == 0U))
34189f54:	697b      	ldr	r3, [r7, #20]
34189f56:	2b00      	cmp	r3, #0
34189f58:	f000 80f6 	beq.w	3418a148 <LTDC_RetrieveUserConfig+0x482>
34189f5c:	69bb      	ldr	r3, [r7, #24]
34189f5e:	2b00      	cmp	r3, #0
34189f60:	f040 80f2 	bne.w	3418a148 <LTDC_RetrieveUserConfig+0x482>
  {
    *Mirror = LTDC_MIRROR_VERTICAL;
34189f64:	68bb      	ldr	r3, [r7, #8]
34189f66:	2201      	movs	r2, #1
34189f68:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34189f6a:	68fb      	ldr	r3, [r7, #12]
34189f6c:	681b      	ldr	r3, [r3, #0]
34189f6e:	461a      	mov	r2, r3
34189f70:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f72:	021b      	lsls	r3, r3, #8
34189f74:	4413      	add	r3, r2
34189f76:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34189f7a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189f7c:	68f9      	ldr	r1, [r7, #12]
34189f7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f80:	2034      	movs	r0, #52	@ 0x34
34189f82:	fb00 f303 	mul.w	r3, r0, r3
34189f86:	440b      	add	r3, r1
34189f88:	333c      	adds	r3, #60	@ 0x3c
34189f8a:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
34189f8c:	68f8      	ldr	r0, [r7, #12]
34189f8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189f90:	2434      	movs	r4, #52	@ 0x34
34189f92:	fb04 f303 	mul.w	r3, r4, r3
34189f96:	4403      	add	r3, r0
34189f98:	3338      	adds	r3, #56	@ 0x38
34189f9a:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
34189f9c:	1acb      	subs	r3, r1, r3
34189f9e:	69f9      	ldr	r1, [r7, #28]
34189fa0:	fb01 f303 	mul.w	r3, r1, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34189fa4:	68f8      	ldr	r0, [r7, #12]
34189fa6:	6b39      	ldr	r1, [r7, #48]	@ 0x30
34189fa8:	2434      	movs	r4, #52	@ 0x34
34189faa:	fb04 f101 	mul.w	r1, r4, r1
34189fae:	4401      	add	r1, r0
34189fb0:	3144      	adds	r1, #68	@ 0x44
34189fb2:	6808      	ldr	r0, [r1, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34189fb4:	68fc      	ldr	r4, [r7, #12]
34189fb6:	6b39      	ldr	r1, [r7, #48]	@ 0x30
34189fb8:	2534      	movs	r5, #52	@ 0x34
34189fba:	fb05 f101 	mul.w	r1, r5, r1
34189fbe:	4421      	add	r1, r4
34189fc0:	3140      	adds	r1, #64	@ 0x40
34189fc2:	6809      	ldr	r1, [r1, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
34189fc4:	1a41      	subs	r1, r0, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34189fc6:	3901      	subs	r1, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
34189fc8:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
34189fcc:	1ad2      	subs	r2, r2, r3
34189fce:	68f9      	ldr	r1, [r7, #12]
34189fd0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189fd2:	2034      	movs	r0, #52	@ 0x34
34189fd4:	fb00 f303 	mul.w	r3, r0, r3
34189fd8:	440b      	add	r3, r1
34189fda:	335c      	adds	r3, #92	@ 0x5c
34189fdc:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34189fde:	68fa      	ldr	r2, [r7, #12]
34189fe0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34189fe2:	2134      	movs	r1, #52	@ 0x34
34189fe4:	fb01 f303 	mul.w	r3, r1, r3
34189fe8:	4413      	add	r3, r2
34189fea:	3348      	adds	r3, #72	@ 0x48
34189fec:	681b      	ldr	r3, [r3, #0]
34189fee:	f240 120d 	movw	r2, #269	@ 0x10d
34189ff2:	4293      	cmp	r3, r2
34189ff4:	d004      	beq.n	3418a000 <LTDC_RetrieveUserConfig+0x33a>
34189ff6:	f240 220d 	movw	r2, #525	@ 0x20d
34189ffa:	4293      	cmp	r3, r2
34189ffc:	d036      	beq.n	3418a06c <LTDC_RetrieveUserConfig+0x3a6>
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
        break;
      default:
        /* Nothing to do */
        break;
34189ffe:	e0a2      	b.n	3418a146 <LTDC_RetrieveUserConfig+0x480>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a000:	68fb      	ldr	r3, [r7, #12]
3418a002:	681b      	ldr	r3, [r3, #0]
3418a004:	461a      	mov	r2, r3
3418a006:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a008:	021b      	lsls	r3, r3, #8
3418a00a:	4413      	add	r3, r2
3418a00c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a010:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a012:	68f9      	ldr	r1, [r7, #12]
3418a014:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a016:	2034      	movs	r0, #52	@ 0x34
3418a018:	fb00 f303 	mul.w	r3, r0, r3
3418a01c:	440b      	add	r3, r1
3418a01e:	333c      	adds	r3, #60	@ 0x3c
3418a020:	6819      	ldr	r1, [r3, #0]
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a022:	68f8      	ldr	r0, [r7, #12]
3418a024:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a026:	2434      	movs	r4, #52	@ 0x34
3418a028:	fb04 f303 	mul.w	r3, r4, r3
3418a02c:	4403      	add	r3, r0
3418a02e:	3338      	adds	r3, #56	@ 0x38
3418a030:	681b      	ldr	r3, [r3, #0]
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a032:	1acb      	subs	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a034:	69f9      	ldr	r1, [r7, #28]
3418a036:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a03a:	68f8      	ldr	r0, [r7, #12]
3418a03c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a03e:	2434      	movs	r4, #52	@ 0x34
3418a040:	fb04 f101 	mul.w	r1, r4, r1
3418a044:	4401      	add	r1, r0
3418a046:	3144      	adds	r1, #68	@ 0x44
3418a048:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a04a:	68fc      	ldr	r4, [r7, #12]
3418a04c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a04e:	2534      	movs	r5, #52	@ 0x34
3418a050:	fb05 f101 	mul.w	r1, r5, r1
3418a054:	4421      	add	r1, r4
3418a056:	3140      	adds	r1, #64	@ 0x40
3418a058:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a05a:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a05c:	0849      	lsrs	r1, r1, #1
3418a05e:	3901      	subs	r1, #1
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a060:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a064:	1ad2      	subs	r2, r2, r3
3418a066:	687b      	ldr	r3, [r7, #4]
3418a068:	601a      	str	r2, [r3, #0]
        break;
3418a06a:	e06c      	b.n	3418a146 <LTDC_RetrieveUserConfig+0x480>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a06c:	68fb      	ldr	r3, [r7, #12]
3418a06e:	681b      	ldr	r3, [r3, #0]
3418a070:	461a      	mov	r2, r3
3418a072:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a074:	021b      	lsls	r3, r3, #8
3418a076:	4413      	add	r3, r2
3418a078:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a07c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a07e:	68f9      	ldr	r1, [r7, #12]
3418a080:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a082:	2034      	movs	r0, #52	@ 0x34
3418a084:	fb00 f303 	mul.w	r3, r0, r3
3418a088:	440b      	add	r3, r1
3418a08a:	333c      	adds	r3, #60	@ 0x3c
3418a08c:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a08e:	68f8      	ldr	r0, [r7, #12]
3418a090:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a092:	2434      	movs	r4, #52	@ 0x34
3418a094:	fb04 f303 	mul.w	r3, r4, r3
3418a098:	4403      	add	r3, r0
3418a09a:	3338      	adds	r3, #56	@ 0x38
3418a09c:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a09e:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a0a0:	085b      	lsrs	r3, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a0a2:	69f9      	ldr	r1, [r7, #28]
3418a0a4:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a0a8:	68f8      	ldr	r0, [r7, #12]
3418a0aa:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a0ac:	2434      	movs	r4, #52	@ 0x34
3418a0ae:	fb04 f101 	mul.w	r1, r4, r1
3418a0b2:	4401      	add	r1, r0
3418a0b4:	3144      	adds	r1, #68	@ 0x44
3418a0b6:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a0b8:	68fc      	ldr	r4, [r7, #12]
3418a0ba:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a0bc:	2534      	movs	r5, #52	@ 0x34
3418a0be:	fb05 f101 	mul.w	r1, r5, r1
3418a0c2:	4421      	add	r1, r4
3418a0c4:	3140      	adds	r1, #64	@ 0x40
3418a0c6:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a0c8:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a0ca:	0849      	lsrs	r1, r1, #1
3418a0cc:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a0ce:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a0d2:	1ad2      	subs	r2, r2, r3
3418a0d4:	687b      	ldr	r3, [r7, #4]
3418a0d6:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a0d8:	68fb      	ldr	r3, [r7, #12]
3418a0da:	681b      	ldr	r3, [r3, #0]
3418a0dc:	461a      	mov	r2, r3
3418a0de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a0e0:	021b      	lsls	r3, r3, #8
3418a0e2:	4413      	add	r3, r2
3418a0e4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a0e8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a0ea:	68f9      	ldr	r1, [r7, #12]
3418a0ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a0ee:	2034      	movs	r0, #52	@ 0x34
3418a0f0:	fb00 f303 	mul.w	r3, r0, r3
3418a0f4:	440b      	add	r3, r1
3418a0f6:	333c      	adds	r3, #60	@ 0x3c
3418a0f8:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a0fa:	68f8      	ldr	r0, [r7, #12]
3418a0fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a0fe:	2434      	movs	r4, #52	@ 0x34
3418a100:	fb04 f303 	mul.w	r3, r4, r3
3418a104:	4403      	add	r3, r0
3418a106:	3338      	adds	r3, #56	@ 0x38
3418a108:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a10a:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a10c:	085b      	lsrs	r3, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a10e:	69f9      	ldr	r1, [r7, #28]
3418a110:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a114:	68f8      	ldr	r0, [r7, #12]
3418a116:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a118:	2434      	movs	r4, #52	@ 0x34
3418a11a:	fb04 f101 	mul.w	r1, r4, r1
3418a11e:	4401      	add	r1, r0
3418a120:	3144      	adds	r1, #68	@ 0x44
3418a122:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a124:	68fc      	ldr	r4, [r7, #12]
3418a126:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a128:	2534      	movs	r5, #52	@ 0x34
3418a12a:	fb05 f101 	mul.w	r1, r5, r1
3418a12e:	4421      	add	r1, r4
3418a130:	3140      	adds	r1, #64	@ 0x40
3418a132:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a134:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418a136:	0849      	lsrs	r1, r1, #1
3418a138:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a13a:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a13e:	1ad2      	subs	r2, r2, r3
3418a140:	683b      	ldr	r3, [r7, #0]
3418a142:	601a      	str	r2, [r3, #0]
        break;
3418a144:	bf00      	nop
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a146:	e0f0      	b.n	3418a32a <LTDC_RetrieveUserConfig+0x664>
    }
  }

  else
  {
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
3418a148:	68bb      	ldr	r3, [r7, #8]
3418a14a:	2202      	movs	r2, #2
3418a14c:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3418a14e:	68fb      	ldr	r3, [r7, #12]
3418a150:	681b      	ldr	r3, [r3, #0]
3418a152:	461a      	mov	r2, r3
3418a154:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a156:	021b      	lsls	r3, r3, #8
3418a158:	4413      	add	r3, r2
3418a15a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a15e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a160:	68f9      	ldr	r1, [r7, #12]
3418a162:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a164:	2034      	movs	r0, #52	@ 0x34
3418a166:	fb00 f303 	mul.w	r3, r0, r3
3418a16a:	440b      	add	r3, r1
3418a16c:	333c      	adds	r3, #60	@ 0x3c
3418a16e:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a170:	68f8      	ldr	r0, [r7, #12]
3418a172:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a174:	2434      	movs	r4, #52	@ 0x34
3418a176:	fb04 f303 	mul.w	r3, r4, r3
3418a17a:	4403      	add	r3, r0
3418a17c:	3338      	adds	r3, #56	@ 0x38
3418a17e:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a180:	1acb      	subs	r3, r1, r3
3418a182:	69f9      	ldr	r1, [r7, #28]
3418a184:	fb01 f303 	mul.w	r3, r1, r3
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a188:	68f8      	ldr	r0, [r7, #12]
3418a18a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a18c:	2434      	movs	r4, #52	@ 0x34
3418a18e:	fb04 f101 	mul.w	r1, r4, r1
3418a192:	4401      	add	r1, r0
3418a194:	3144      	adds	r1, #68	@ 0x44
3418a196:	6808      	ldr	r0, [r1, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
3418a198:	68fc      	ldr	r4, [r7, #12]
3418a19a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a19c:	2534      	movs	r5, #52	@ 0x34
3418a19e:	fb05 f101 	mul.w	r1, r5, r1
3418a1a2:	4421      	add	r1, r4
3418a1a4:	3140      	adds	r1, #64	@ 0x40
3418a1a6:	6809      	ldr	r1, [r1, #0]
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a1a8:	1a41      	subs	r1, r0, r1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a1aa:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3418a1ae:	1ad3      	subs	r3, r2, r3
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
3418a1b0:	1c5a      	adds	r2, r3, #1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3418a1b2:	68f9      	ldr	r1, [r7, #12]
3418a1b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a1b6:	2034      	movs	r0, #52	@ 0x34
3418a1b8:	fb00 f303 	mul.w	r3, r0, r3
3418a1bc:	440b      	add	r3, r1
3418a1be:	335c      	adds	r3, #92	@ 0x5c
3418a1c0:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a1c2:	68fa      	ldr	r2, [r7, #12]
3418a1c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a1c6:	2134      	movs	r1, #52	@ 0x34
3418a1c8:	fb01 f303 	mul.w	r3, r1, r3
3418a1cc:	4413      	add	r3, r2
3418a1ce:	3348      	adds	r3, #72	@ 0x48
3418a1d0:	681b      	ldr	r3, [r3, #0]
3418a1d2:	f240 120d 	movw	r2, #269	@ 0x10d
3418a1d6:	4293      	cmp	r3, r2
3418a1d8:	d004      	beq.n	3418a1e4 <LTDC_RetrieveUserConfig+0x51e>
3418a1da:	f240 220d 	movw	r2, #525	@ 0x20d
3418a1de:	4293      	cmp	r3, r2
3418a1e0:	d036      	beq.n	3418a250 <LTDC_RetrieveUserConfig+0x58a>
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
        break;
      default:
        /* Nothing to do */
        break;
3418a1e2:	e0a2      	b.n	3418a32a <LTDC_RetrieveUserConfig+0x664>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a1e4:	68fb      	ldr	r3, [r7, #12]
3418a1e6:	681b      	ldr	r3, [r3, #0]
3418a1e8:	461a      	mov	r2, r3
3418a1ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a1ec:	021b      	lsls	r3, r3, #8
3418a1ee:	4413      	add	r3, r2
3418a1f0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a1f4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a1f6:	68f9      	ldr	r1, [r7, #12]
3418a1f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a1fa:	2034      	movs	r0, #52	@ 0x34
3418a1fc:	fb00 f303 	mul.w	r3, r0, r3
3418a200:	440b      	add	r3, r1
3418a202:	333c      	adds	r3, #60	@ 0x3c
3418a204:	6819      	ldr	r1, [r3, #0]
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a206:	68f8      	ldr	r0, [r7, #12]
3418a208:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a20a:	2434      	movs	r4, #52	@ 0x34
3418a20c:	fb04 f303 	mul.w	r3, r4, r3
3418a210:	4403      	add	r3, r0
3418a212:	3338      	adds	r3, #56	@ 0x38
3418a214:	681b      	ldr	r3, [r3, #0]
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a216:	1acb      	subs	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a218:	69f9      	ldr	r1, [r7, #28]
3418a21a:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a21e:	68f8      	ldr	r0, [r7, #12]
3418a220:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a222:	2434      	movs	r4, #52	@ 0x34
3418a224:	fb04 f101 	mul.w	r1, r4, r1
3418a228:	4401      	add	r1, r0
3418a22a:	3144      	adds	r1, #68	@ 0x44
3418a22c:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a22e:	68fc      	ldr	r4, [r7, #12]
3418a230:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a232:	2534      	movs	r5, #52	@ 0x34
3418a234:	fb05 f101 	mul.w	r1, r5, r1
3418a238:	4421      	add	r1, r4
3418a23a:	3140      	adds	r1, #64	@ 0x40
3418a23c:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a23e:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a240:	0849      	lsrs	r1, r1, #1
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3418a242:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a246:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a248:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a24a:	687b      	ldr	r3, [r7, #4]
3418a24c:	601a      	str	r2, [r3, #0]
        break;
3418a24e:	e06c      	b.n	3418a32a <LTDC_RetrieveUserConfig+0x664>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a250:	68fb      	ldr	r3, [r7, #12]
3418a252:	681b      	ldr	r3, [r3, #0]
3418a254:	461a      	mov	r2, r3
3418a256:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a258:	021b      	lsls	r3, r3, #8
3418a25a:	4413      	add	r3, r2
3418a25c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a260:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a262:	68f9      	ldr	r1, [r7, #12]
3418a264:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a266:	2034      	movs	r0, #52	@ 0x34
3418a268:	fb00 f303 	mul.w	r3, r0, r3
3418a26c:	440b      	add	r3, r1
3418a26e:	333c      	adds	r3, #60	@ 0x3c
3418a270:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a272:	68f8      	ldr	r0, [r7, #12]
3418a274:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a276:	2434      	movs	r4, #52	@ 0x34
3418a278:	fb04 f303 	mul.w	r3, r4, r3
3418a27c:	4403      	add	r3, r0
3418a27e:	3338      	adds	r3, #56	@ 0x38
3418a280:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a282:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a284:	085b      	lsrs	r3, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a286:	69f9      	ldr	r1, [r7, #28]
3418a288:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a28c:	68f8      	ldr	r0, [r7, #12]
3418a28e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a290:	2434      	movs	r4, #52	@ 0x34
3418a292:	fb04 f101 	mul.w	r1, r4, r1
3418a296:	4401      	add	r1, r0
3418a298:	3144      	adds	r1, #68	@ 0x44
3418a29a:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a29c:	68fc      	ldr	r4, [r7, #12]
3418a29e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a2a0:	2534      	movs	r5, #52	@ 0x34
3418a2a2:	fb05 f101 	mul.w	r1, r5, r1
3418a2a6:	4421      	add	r1, r4
3418a2a8:	3140      	adds	r1, #64	@ 0x40
3418a2aa:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a2ac:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a2ae:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a2b0:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a2b4:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a2b6:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3418a2b8:	687b      	ldr	r3, [r7, #4]
3418a2ba:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a2bc:	68fb      	ldr	r3, [r7, #12]
3418a2be:	681b      	ldr	r3, [r3, #0]
3418a2c0:	461a      	mov	r2, r3
3418a2c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a2c4:	021b      	lsls	r3, r3, #8
3418a2c6:	4413      	add	r3, r2
3418a2c8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a2cc:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a2ce:	68f9      	ldr	r1, [r7, #12]
3418a2d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a2d2:	2034      	movs	r0, #52	@ 0x34
3418a2d4:	fb00 f303 	mul.w	r3, r0, r3
3418a2d8:	440b      	add	r3, r1
3418a2da:	333c      	adds	r3, #60	@ 0x3c
3418a2dc:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a2de:	68f8      	ldr	r0, [r7, #12]
3418a2e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a2e2:	2434      	movs	r4, #52	@ 0x34
3418a2e4:	fb04 f303 	mul.w	r3, r4, r3
3418a2e8:	4403      	add	r3, r0
3418a2ea:	3338      	adds	r3, #56	@ 0x38
3418a2ec:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3418a2ee:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a2f0:	085b      	lsrs	r3, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a2f2:	69f9      	ldr	r1, [r7, #28]
3418a2f4:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a2f8:	68f8      	ldr	r0, [r7, #12]
3418a2fa:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a2fc:	2434      	movs	r4, #52	@ 0x34
3418a2fe:	fb04 f101 	mul.w	r1, r4, r1
3418a302:	4401      	add	r1, r0
3418a304:	3144      	adds	r1, #68	@ 0x44
3418a306:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a308:	68fc      	ldr	r4, [r7, #12]
3418a30a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3418a30c:	2534      	movs	r5, #52	@ 0x34
3418a30e:	fb05 f101 	mul.w	r1, r5, r1
3418a312:	4421      	add	r1, r4
3418a314:	3140      	adds	r1, #64	@ 0x40
3418a316:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418a318:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a31a:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3418a31c:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a320:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3418a322:	1c5a      	adds	r2, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3418a324:	683b      	ldr	r3, [r7, #0]
3418a326:	601a      	str	r2, [r3, #0]
        break;
3418a328:	bf00      	nop
    }
  }
}
3418a32a:	bf00      	nop
3418a32c:	3724      	adds	r7, #36	@ 0x24
3418a32e:	46bd      	mov	sp, r7
3418a330:	bcb0      	pop	{r4, r5, r7}
3418a332:	4770      	bx	lr

3418a334 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
3418a334:	b4b0      	push	{r4, r5, r7}
3418a336:	b087      	sub	sp, #28
3418a338:	af00      	add	r7, sp, #0
3418a33a:	60f8      	str	r0, [r7, #12]
3418a33c:	60b9      	str	r1, [r7, #8]
3418a33e:	607a      	str	r2, [r7, #4]
3418a340:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3418a342:	68fb      	ldr	r3, [r7, #12]
3418a344:	681b      	ldr	r3, [r3, #0]
3418a346:	461a      	mov	r2, r3
3418a348:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a34a:	021b      	lsls	r3, r3, #8
3418a34c:	4413      	add	r3, r2
3418a34e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a352:	4618      	mov	r0, r3
3418a354:	68fa      	ldr	r2, [r7, #12]
3418a356:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a358:	2134      	movs	r1, #52	@ 0x34
3418a35a:	fb01 f303 	mul.w	r3, r1, r3
3418a35e:	4413      	add	r3, r2
3418a360:	3364      	adds	r3, #100	@ 0x64
3418a362:	681b      	ldr	r3, [r3, #0]
3418a364:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a366:	68fa      	ldr	r2, [r7, #12]
3418a368:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a36a:	2134      	movs	r1, #52	@ 0x34
3418a36c:	fb01 f303 	mul.w	r3, r1, r3
3418a370:	4413      	add	r3, r2
3418a372:	3348      	adds	r3, #72	@ 0x48
3418a374:	681b      	ldr	r3, [r3, #0]
3418a376:	2b03      	cmp	r3, #3
3418a378:	d821      	bhi.n	3418a3be <LTDC_SetConfig+0x8a>
3418a37a:	e025      	b.n	3418a3c8 <LTDC_SetConfig+0x94>
3418a37c:	3b04      	subs	r3, #4
3418a37e:	2201      	movs	r2, #1
3418a380:	fa02 f303 	lsl.w	r3, r2, r3
3418a384:	f240 229b 	movw	r2, #667	@ 0x29b
3418a388:	401a      	ands	r2, r3
3418a38a:	2a00      	cmp	r2, #0
3418a38c:	bf14      	ite	ne
3418a38e:	2201      	movne	r2, #1
3418a390:	2200      	moveq	r2, #0
3418a392:	b2d2      	uxtb	r2, r2
3418a394:	2a00      	cmp	r2, #0
3418a396:	d11d      	bne.n	3418a3d4 <LTDC_SetConfig+0xa0>
3418a398:	f403 7280 	and.w	r2, r3, #256	@ 0x100
3418a39c:	2a00      	cmp	r2, #0
3418a39e:	bf14      	ite	ne
3418a3a0:	2201      	movne	r2, #1
3418a3a2:	2200      	moveq	r2, #0
3418a3a4:	b2d2      	uxtb	r2, r2
3418a3a6:	2a00      	cmp	r2, #0
3418a3a8:	d117      	bne.n	3418a3da <LTDC_SetConfig+0xa6>
3418a3aa:	f003 0304 	and.w	r3, r3, #4
3418a3ae:	2b00      	cmp	r3, #0
3418a3b0:	bf14      	ite	ne
3418a3b2:	2301      	movne	r3, #1
3418a3b4:	2300      	moveq	r3, #0
3418a3b6:	b2db      	uxtb	r3, r3
3418a3b8:	2b00      	cmp	r3, #0
3418a3ba:	d108      	bne.n	3418a3ce <LTDC_SetConfig+0x9a>
3418a3bc:	e01b      	b.n	3418a3f6 <LTDC_SetConfig+0xc2>
3418a3be:	2b0d      	cmp	r3, #13
3418a3c0:	d819      	bhi.n	3418a3f6 <LTDC_SetConfig+0xc2>
3418a3c2:	2b04      	cmp	r3, #4
3418a3c4:	d2da      	bcs.n	3418a37c <LTDC_SetConfig+0x48>
3418a3c6:	e016      	b.n	3418a3f6 <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3418a3c8:	2304      	movs	r3, #4
3418a3ca:	617b      	str	r3, [r7, #20]
      break;
3418a3cc:	e016      	b.n	3418a3fc <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
3418a3ce:	2303      	movs	r3, #3
3418a3d0:	617b      	str	r3, [r7, #20]
      break;
3418a3d2:	e013      	b.n	3418a3fc <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3418a3d4:	2302      	movs	r3, #2
3418a3d6:	617b      	str	r3, [r7, #20]
      break;
3418a3d8:	e010      	b.n	3418a3fc <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
3418a3da:	68fb      	ldr	r3, [r7, #12]
3418a3dc:	681b      	ldr	r3, [r3, #0]
3418a3de:	461a      	mov	r2, r3
3418a3e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a3e2:	021b      	lsls	r3, r3, #8
3418a3e4:	4413      	add	r3, r2
3418a3e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a3ea:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3418a3ec:	0c9b      	lsrs	r3, r3, #18
3418a3ee:	f003 0307 	and.w	r3, r3, #7
3418a3f2:	617b      	str	r3, [r7, #20]
      break;
3418a3f4:	e002      	b.n	3418a3fc <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3418a3f6:	2301      	movs	r3, #1
3418a3f8:	617b      	str	r3, [r7, #20]
      break;
3418a3fa:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3418a3fc:	68fa      	ldr	r2, [r7, #12]
3418a3fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a400:	2134      	movs	r1, #52	@ 0x34
3418a402:	fb01 f303 	mul.w	r3, r1, r3
3418a406:	4413      	add	r3, r2
3418a408:	333c      	adds	r3, #60	@ 0x3c
3418a40a:	681a      	ldr	r2, [r3, #0]
3418a40c:	68fb      	ldr	r3, [r7, #12]
3418a40e:	681b      	ldr	r3, [r3, #0]
3418a410:	68db      	ldr	r3, [r3, #12]
3418a412:	0c1b      	lsrs	r3, r3, #16
3418a414:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418a418:	4413      	add	r3, r2
3418a41a:	041b      	lsls	r3, r3, #16
3418a41c:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418a41e:	68fa      	ldr	r2, [r7, #12]
3418a420:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a422:	2134      	movs	r1, #52	@ 0x34
3418a424:	fb01 f303 	mul.w	r3, r1, r3
3418a428:	4413      	add	r3, r2
3418a42a:	3338      	adds	r3, #56	@ 0x38
3418a42c:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418a42e:	68fb      	ldr	r3, [r7, #12]
3418a430:	681b      	ldr	r3, [r3, #0]
3418a432:	68db      	ldr	r3, [r3, #12]
3418a434:	0c1b      	lsrs	r3, r3, #16
3418a436:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418a43a:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418a43c:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418a43e:	68fb      	ldr	r3, [r7, #12]
3418a440:	681b      	ldr	r3, [r3, #0]
3418a442:	4619      	mov	r1, r3
3418a444:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a446:	021b      	lsls	r3, r3, #8
3418a448:	440b      	add	r3, r1
3418a44a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a44e:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418a450:	693b      	ldr	r3, [r7, #16]
3418a452:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418a454:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3418a456:	68fa      	ldr	r2, [r7, #12]
3418a458:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a45a:	2134      	movs	r1, #52	@ 0x34
3418a45c:	fb01 f303 	mul.w	r3, r1, r3
3418a460:	4413      	add	r3, r2
3418a462:	3344      	adds	r3, #68	@ 0x44
3418a464:	681a      	ldr	r2, [r3, #0]
3418a466:	68fb      	ldr	r3, [r7, #12]
3418a468:	681b      	ldr	r3, [r3, #0]
3418a46a:	68db      	ldr	r3, [r3, #12]
3418a46c:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418a470:	4413      	add	r3, r2
3418a472:	041b      	lsls	r3, r3, #16
3418a474:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418a476:	68fa      	ldr	r2, [r7, #12]
3418a478:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a47a:	2134      	movs	r1, #52	@ 0x34
3418a47c:	fb01 f303 	mul.w	r3, r1, r3
3418a480:	4413      	add	r3, r2
3418a482:	3340      	adds	r3, #64	@ 0x40
3418a484:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418a486:	68fb      	ldr	r3, [r7, #12]
3418a488:	681b      	ldr	r3, [r3, #0]
3418a48a:	68db      	ldr	r3, [r3, #12]
3418a48c:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418a490:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418a492:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418a494:	68fb      	ldr	r3, [r7, #12]
3418a496:	681b      	ldr	r3, [r3, #0]
3418a498:	4619      	mov	r1, r3
3418a49a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a49c:	021b      	lsls	r3, r3, #8
3418a49e:	440b      	add	r3, r1
3418a4a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a4a4:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418a4a6:	693b      	ldr	r3, [r7, #16]
3418a4a8:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418a4aa:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
3418a4ac:	683b      	ldr	r3, [r7, #0]
3418a4ae:	2b03      	cmp	r3, #3
3418a4b0:	f040 80fb 	bne.w	3418a6aa <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3418a4b4:	68fb      	ldr	r3, [r7, #12]
3418a4b6:	681b      	ldr	r3, [r3, #0]
3418a4b8:	461a      	mov	r2, r3
3418a4ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a4bc:	021b      	lsls	r3, r3, #8
3418a4be:	4413      	add	r3, r2
3418a4c0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a4c4:	4618      	mov	r0, r3
3418a4c6:	68fa      	ldr	r2, [r7, #12]
3418a4c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a4ca:	2134      	movs	r1, #52	@ 0x34
3418a4cc:	fb01 f303 	mul.w	r3, r1, r3
3418a4d0:	4413      	add	r3, r2
3418a4d2:	335c      	adds	r3, #92	@ 0x5c
3418a4d4:	681b      	ldr	r3, [r3, #0]
3418a4d6:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a4d8:	68fa      	ldr	r2, [r7, #12]
3418a4da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a4dc:	2134      	movs	r1, #52	@ 0x34
3418a4de:	fb01 f303 	mul.w	r3, r1, r3
3418a4e2:	4413      	add	r3, r2
3418a4e4:	3348      	adds	r3, #72	@ 0x48
3418a4e6:	681b      	ldr	r3, [r3, #0]
3418a4e8:	f240 120d 	movw	r2, #269	@ 0x10d
3418a4ec:	4293      	cmp	r3, r2
3418a4ee:	d004      	beq.n	3418a4fa <LTDC_SetConfig+0x1c6>
3418a4f0:	f240 220d 	movw	r2, #525	@ 0x20d
3418a4f4:	4293      	cmp	r3, r2
3418a4f6:	d043      	beq.n	3418a580 <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
3418a4f8:	e092      	b.n	3418a620 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3418a4fa:	68fb      	ldr	r3, [r7, #12]
3418a4fc:	681b      	ldr	r3, [r3, #0]
3418a4fe:	461a      	mov	r2, r3
3418a500:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a502:	021b      	lsls	r3, r3, #8
3418a504:	4413      	add	r3, r2
3418a506:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a50a:	461a      	mov	r2, r3
3418a50c:	68bb      	ldr	r3, [r7, #8]
3418a50e:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418a510:	68fa      	ldr	r2, [r7, #12]
3418a512:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a514:	2134      	movs	r1, #52	@ 0x34
3418a516:	fb01 f303 	mul.w	r3, r1, r3
3418a51a:	4413      	add	r3, r2
3418a51c:	3360      	adds	r3, #96	@ 0x60
3418a51e:	681b      	ldr	r3, [r3, #0]
3418a520:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a522:	68f9      	ldr	r1, [r7, #12]
3418a524:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a526:	2034      	movs	r0, #52	@ 0x34
3418a528:	fb00 f303 	mul.w	r3, r0, r3
3418a52c:	440b      	add	r3, r1
3418a52e:	333c      	adds	r3, #60	@ 0x3c
3418a530:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418a532:	68f8      	ldr	r0, [r7, #12]
3418a534:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a536:	2434      	movs	r4, #52	@ 0x34
3418a538:	fb04 f303 	mul.w	r3, r4, r3
3418a53c:	4403      	add	r3, r0
3418a53e:	3338      	adds	r3, #56	@ 0x38
3418a540:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a542:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418a544:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418a546:	68f9      	ldr	r1, [r7, #12]
3418a548:	6809      	ldr	r1, [r1, #0]
3418a54a:	4608      	mov	r0, r1
3418a54c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a54e:	0209      	lsls	r1, r1, #8
3418a550:	4401      	add	r1, r0
3418a552:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a556:	4313      	orrs	r3, r2
3418a558:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3418a55a:	68fa      	ldr	r2, [r7, #12]
3418a55c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a55e:	2134      	movs	r1, #52	@ 0x34
3418a560:	fb01 f303 	mul.w	r3, r1, r3
3418a564:	4413      	add	r3, r2
3418a566:	3364      	adds	r3, #100	@ 0x64
3418a568:	681b      	ldr	r3, [r3, #0]
3418a56a:	68fa      	ldr	r2, [r7, #12]
3418a56c:	6812      	ldr	r2, [r2, #0]
3418a56e:	4611      	mov	r1, r2
3418a570:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a572:	0212      	lsls	r2, r2, #8
3418a574:	440a      	add	r2, r1
3418a576:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a57a:	085b      	lsrs	r3, r3, #1
3418a57c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418a57e:	e04f      	b.n	3418a620 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3418a580:	68fb      	ldr	r3, [r7, #12]
3418a582:	681b      	ldr	r3, [r3, #0]
3418a584:	461a      	mov	r2, r3
3418a586:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a588:	021b      	lsls	r3, r3, #8
3418a58a:	4413      	add	r3, r2
3418a58c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a590:	461a      	mov	r2, r3
3418a592:	68bb      	ldr	r3, [r7, #8]
3418a594:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
3418a596:	68fb      	ldr	r3, [r7, #12]
3418a598:	681b      	ldr	r3, [r3, #0]
3418a59a:	461a      	mov	r2, r3
3418a59c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a59e:	021b      	lsls	r3, r3, #8
3418a5a0:	4413      	add	r3, r2
3418a5a2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a5a6:	461a      	mov	r2, r3
3418a5a8:	687b      	ldr	r3, [r7, #4]
3418a5aa:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418a5ac:	68fa      	ldr	r2, [r7, #12]
3418a5ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a5b0:	2134      	movs	r1, #52	@ 0x34
3418a5b2:	fb01 f303 	mul.w	r3, r1, r3
3418a5b6:	4413      	add	r3, r2
3418a5b8:	3360      	adds	r3, #96	@ 0x60
3418a5ba:	681b      	ldr	r3, [r3, #0]
3418a5bc:	085b      	lsrs	r3, r3, #1
3418a5be:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a5c0:	68f9      	ldr	r1, [r7, #12]
3418a5c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a5c4:	2034      	movs	r0, #52	@ 0x34
3418a5c6:	fb00 f303 	mul.w	r3, r0, r3
3418a5ca:	440b      	add	r3, r1
3418a5cc:	333c      	adds	r3, #60	@ 0x3c
3418a5ce:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418a5d0:	68f8      	ldr	r0, [r7, #12]
3418a5d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a5d4:	2434      	movs	r4, #52	@ 0x34
3418a5d6:	fb04 f303 	mul.w	r3, r4, r3
3418a5da:	4403      	add	r3, r0
3418a5dc:	3338      	adds	r3, #56	@ 0x38
3418a5de:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a5e0:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418a5e2:	085b      	lsrs	r3, r3, #1
3418a5e4:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418a5e6:	68f9      	ldr	r1, [r7, #12]
3418a5e8:	6809      	ldr	r1, [r1, #0]
3418a5ea:	4608      	mov	r0, r1
3418a5ec:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a5ee:	0209      	lsls	r1, r1, #8
3418a5f0:	4401      	add	r1, r0
3418a5f2:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a5f6:	4313      	orrs	r3, r2
3418a5f8:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3418a5fa:	68fa      	ldr	r2, [r7, #12]
3418a5fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a5fe:	2134      	movs	r1, #52	@ 0x34
3418a600:	fb01 f303 	mul.w	r3, r1, r3
3418a604:	4413      	add	r3, r2
3418a606:	3364      	adds	r3, #100	@ 0x64
3418a608:	681b      	ldr	r3, [r3, #0]
3418a60a:	68fa      	ldr	r2, [r7, #12]
3418a60c:	6812      	ldr	r2, [r2, #0]
3418a60e:	4611      	mov	r1, r2
3418a610:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a612:	0212      	lsls	r2, r2, #8
3418a614:	440a      	add	r2, r1
3418a616:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a61a:	085b      	lsrs	r3, r3, #1
3418a61c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418a61e:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418a620:	68fa      	ldr	r2, [r7, #12]
3418a622:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a624:	2134      	movs	r1, #52	@ 0x34
3418a626:	fb01 f303 	mul.w	r3, r1, r3
3418a62a:	4413      	add	r3, r2
3418a62c:	3360      	adds	r3, #96	@ 0x60
3418a62e:	681b      	ldr	r3, [r3, #0]
3418a630:	697a      	ldr	r2, [r7, #20]
3418a632:	fb02 f303 	mul.w	r3, r2, r3
3418a636:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
3418a638:	68f9      	ldr	r1, [r7, #12]
3418a63a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a63c:	2034      	movs	r0, #52	@ 0x34
3418a63e:	fb00 f303 	mul.w	r3, r0, r3
3418a642:	440b      	add	r3, r1
3418a644:	333c      	adds	r3, #60	@ 0x3c
3418a646:	6819      	ldr	r1, [r3, #0]
3418a648:	68f8      	ldr	r0, [r7, #12]
3418a64a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a64c:	2434      	movs	r4, #52	@ 0x34
3418a64e:	fb04 f303 	mul.w	r3, r4, r3
3418a652:	4403      	add	r3, r0
3418a654:	3338      	adds	r3, #56	@ 0x38
3418a656:	681b      	ldr	r3, [r3, #0]
3418a658:	1acb      	subs	r3, r1, r3
3418a65a:	6979      	ldr	r1, [r7, #20]
3418a65c:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
3418a660:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418a662:	68f9      	ldr	r1, [r7, #12]
3418a664:	6809      	ldr	r1, [r1, #0]
3418a666:	4608      	mov	r0, r1
3418a668:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a66a:	0209      	lsls	r1, r1, #8
3418a66c:	4401      	add	r1, r0
3418a66e:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a672:	4313      	orrs	r3, r2
3418a674:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3418a676:	68fb      	ldr	r3, [r7, #12]
3418a678:	681b      	ldr	r3, [r3, #0]
3418a67a:	461a      	mov	r2, r3
3418a67c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a67e:	021b      	lsls	r3, r3, #8
3418a680:	4413      	add	r3, r2
3418a682:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a686:	68db      	ldr	r3, [r3, #12]
3418a688:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3418a68c:	f023 0301 	bic.w	r3, r3, #1
3418a690:	68fa      	ldr	r2, [r7, #12]
3418a692:	6812      	ldr	r2, [r2, #0]
3418a694:	4611      	mov	r1, r2
3418a696:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a698:	0212      	lsls	r2, r2, #8
3418a69a:	440a      	add	r2, r1
3418a69c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a6a0:	f043 0301 	orr.w	r3, r3, #1
3418a6a4:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
3418a6a6:	f000 bccc 	b.w	3418b042 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
3418a6aa:	683b      	ldr	r3, [r7, #0]
3418a6ac:	2b00      	cmp	r3, #0
3418a6ae:	f040 814e 	bne.w	3418a94e <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418a6b2:	68fa      	ldr	r2, [r7, #12]
3418a6b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a6b6:	2134      	movs	r1, #52	@ 0x34
3418a6b8:	fb01 f303 	mul.w	r3, r1, r3
3418a6bc:	4413      	add	r3, r2
3418a6be:	335c      	adds	r3, #92	@ 0x5c
3418a6c0:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a6c2:	68f9      	ldr	r1, [r7, #12]
3418a6c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a6c6:	2034      	movs	r0, #52	@ 0x34
3418a6c8:	fb00 f303 	mul.w	r3, r0, r3
3418a6cc:	440b      	add	r3, r1
3418a6ce:	333c      	adds	r3, #60	@ 0x3c
3418a6d0:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418a6d2:	68f8      	ldr	r0, [r7, #12]
3418a6d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a6d6:	2434      	movs	r4, #52	@ 0x34
3418a6d8:	fb04 f303 	mul.w	r3, r4, r3
3418a6dc:	4403      	add	r3, r0
3418a6de:	3338      	adds	r3, #56	@ 0x38
3418a6e0:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a6e2:	1acb      	subs	r3, r1, r3
3418a6e4:	6979      	ldr	r1, [r7, #20]
3418a6e6:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418a6ea:	4413      	add	r3, r2
3418a6ec:	68fa      	ldr	r2, [r7, #12]
3418a6ee:	6812      	ldr	r2, [r2, #0]
3418a6f0:	4611      	mov	r1, r2
3418a6f2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a6f4:	0212      	lsls	r2, r2, #8
3418a6f6:	440a      	add	r2, r1
3418a6f8:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418a6fc:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418a6fe:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a700:	68fa      	ldr	r2, [r7, #12]
3418a702:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a704:	2134      	movs	r1, #52	@ 0x34
3418a706:	fb01 f303 	mul.w	r3, r1, r3
3418a70a:	4413      	add	r3, r2
3418a70c:	3348      	adds	r3, #72	@ 0x48
3418a70e:	681b      	ldr	r3, [r3, #0]
3418a710:	f240 120d 	movw	r2, #269	@ 0x10d
3418a714:	4293      	cmp	r3, r2
3418a716:	d004      	beq.n	3418a722 <LTDC_SetConfig+0x3ee>
3418a718:	f240 220d 	movw	r2, #525	@ 0x20d
3418a71c:	4293      	cmp	r3, r2
3418a71e:	d058      	beq.n	3418a7d2 <LTDC_SetConfig+0x49e>
        break;
3418a720:	e0d3      	b.n	3418a8ca <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a722:	68fa      	ldr	r2, [r7, #12]
3418a724:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a726:	2134      	movs	r1, #52	@ 0x34
3418a728:	fb01 f303 	mul.w	r3, r1, r3
3418a72c:	4413      	add	r3, r2
3418a72e:	333c      	adds	r3, #60	@ 0x3c
3418a730:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418a732:	68f9      	ldr	r1, [r7, #12]
3418a734:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a736:	2034      	movs	r0, #52	@ 0x34
3418a738:	fb00 f303 	mul.w	r3, r0, r3
3418a73c:	440b      	add	r3, r1
3418a73e:	3338      	adds	r3, #56	@ 0x38
3418a740:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a742:	1ad3      	subs	r3, r2, r3
3418a744:	697a      	ldr	r2, [r7, #20]
3418a746:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418a74a:	68bb      	ldr	r3, [r7, #8]
3418a74c:	4413      	add	r3, r2
3418a74e:	68fa      	ldr	r2, [r7, #12]
3418a750:	6812      	ldr	r2, [r2, #0]
3418a752:	4611      	mov	r1, r2
3418a754:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a756:	0212      	lsls	r2, r2, #8
3418a758:	440a      	add	r2, r1
3418a75a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418a75e:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418a760:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418a762:	68fa      	ldr	r2, [r7, #12]
3418a764:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a766:	2134      	movs	r1, #52	@ 0x34
3418a768:	fb01 f303 	mul.w	r3, r1, r3
3418a76c:	4413      	add	r3, r2
3418a76e:	3360      	adds	r3, #96	@ 0x60
3418a770:	681b      	ldr	r3, [r3, #0]
3418a772:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
3418a774:	68f9      	ldr	r1, [r7, #12]
3418a776:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a778:	2034      	movs	r0, #52	@ 0x34
3418a77a:	fb00 f303 	mul.w	r3, r0, r3
3418a77e:	440b      	add	r3, r1
3418a780:	333c      	adds	r3, #60	@ 0x3c
3418a782:	6819      	ldr	r1, [r3, #0]
3418a784:	68f8      	ldr	r0, [r7, #12]
3418a786:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a788:	2434      	movs	r4, #52	@ 0x34
3418a78a:	fb04 f303 	mul.w	r3, r4, r3
3418a78e:	4403      	add	r3, r0
3418a790:	3338      	adds	r3, #56	@ 0x38
3418a792:	681b      	ldr	r3, [r3, #0]
3418a794:	1acb      	subs	r3, r1, r3
3418a796:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418a798:	68f9      	ldr	r1, [r7, #12]
3418a79a:	6809      	ldr	r1, [r1, #0]
3418a79c:	4608      	mov	r0, r1
3418a79e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a7a0:	0209      	lsls	r1, r1, #8
3418a7a2:	4401      	add	r1, r0
3418a7a4:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a7a8:	4313      	orrs	r3, r2
3418a7aa:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
3418a7ac:	68fa      	ldr	r2, [r7, #12]
3418a7ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a7b0:	2134      	movs	r1, #52	@ 0x34
3418a7b2:	fb01 f303 	mul.w	r3, r1, r3
3418a7b6:	4413      	add	r3, r2
3418a7b8:	3364      	adds	r3, #100	@ 0x64
3418a7ba:	681b      	ldr	r3, [r3, #0]
3418a7bc:	68fa      	ldr	r2, [r7, #12]
3418a7be:	6812      	ldr	r2, [r2, #0]
3418a7c0:	4611      	mov	r1, r2
3418a7c2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a7c4:	0212      	lsls	r2, r2, #8
3418a7c6:	440a      	add	r2, r1
3418a7c8:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a7cc:	085b      	lsrs	r3, r3, #1
3418a7ce:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418a7d0:	e07b      	b.n	3418a8ca <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a7d2:	68fa      	ldr	r2, [r7, #12]
3418a7d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a7d6:	2134      	movs	r1, #52	@ 0x34
3418a7d8:	fb01 f303 	mul.w	r3, r1, r3
3418a7dc:	4413      	add	r3, r2
3418a7de:	333c      	adds	r3, #60	@ 0x3c
3418a7e0:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a7e2:	68f9      	ldr	r1, [r7, #12]
3418a7e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a7e6:	2034      	movs	r0, #52	@ 0x34
3418a7e8:	fb00 f303 	mul.w	r3, r0, r3
3418a7ec:	440b      	add	r3, r1
3418a7ee:	3338      	adds	r3, #56	@ 0x38
3418a7f0:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a7f2:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a7f4:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a7f6:	697a      	ldr	r2, [r7, #20]
3418a7f8:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418a7fc:	68bb      	ldr	r3, [r7, #8]
3418a7fe:	4413      	add	r3, r2
3418a800:	68fa      	ldr	r2, [r7, #12]
3418a802:	6812      	ldr	r2, [r2, #0]
3418a804:	4611      	mov	r1, r2
3418a806:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a808:	0212      	lsls	r2, r2, #8
3418a80a:	440a      	add	r2, r1
3418a80c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a810:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418a812:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a814:	68fa      	ldr	r2, [r7, #12]
3418a816:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a818:	2134      	movs	r1, #52	@ 0x34
3418a81a:	fb01 f303 	mul.w	r3, r1, r3
3418a81e:	4413      	add	r3, r2
3418a820:	333c      	adds	r3, #60	@ 0x3c
3418a822:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a824:	68f9      	ldr	r1, [r7, #12]
3418a826:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a828:	2034      	movs	r0, #52	@ 0x34
3418a82a:	fb00 f303 	mul.w	r3, r0, r3
3418a82e:	440b      	add	r3, r1
3418a830:	3338      	adds	r3, #56	@ 0x38
3418a832:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a834:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a836:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a838:	697a      	ldr	r2, [r7, #20]
3418a83a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418a83e:	687b      	ldr	r3, [r7, #4]
3418a840:	4413      	add	r3, r2
3418a842:	68fa      	ldr	r2, [r7, #12]
3418a844:	6812      	ldr	r2, [r2, #0]
3418a846:	4611      	mov	r1, r2
3418a848:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a84a:	0212      	lsls	r2, r2, #8
3418a84c:	440a      	add	r2, r1
3418a84e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418a852:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418a854:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418a856:	68fa      	ldr	r2, [r7, #12]
3418a858:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a85a:	2134      	movs	r1, #52	@ 0x34
3418a85c:	fb01 f303 	mul.w	r3, r1, r3
3418a860:	4413      	add	r3, r2
3418a862:	3360      	adds	r3, #96	@ 0x60
3418a864:	681b      	ldr	r3, [r3, #0]
3418a866:	085b      	lsrs	r3, r3, #1
3418a868:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a86a:	68f9      	ldr	r1, [r7, #12]
3418a86c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a86e:	2034      	movs	r0, #52	@ 0x34
3418a870:	fb00 f303 	mul.w	r3, r0, r3
3418a874:	440b      	add	r3, r1
3418a876:	333c      	adds	r3, #60	@ 0x3c
3418a878:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418a87a:	68f8      	ldr	r0, [r7, #12]
3418a87c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a87e:	2434      	movs	r4, #52	@ 0x34
3418a880:	fb04 f303 	mul.w	r3, r4, r3
3418a884:	4403      	add	r3, r0
3418a886:	3338      	adds	r3, #56	@ 0x38
3418a888:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a88a:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418a88c:	085b      	lsrs	r3, r3, #1
3418a88e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418a890:	68f9      	ldr	r1, [r7, #12]
3418a892:	6809      	ldr	r1, [r1, #0]
3418a894:	4608      	mov	r0, r1
3418a896:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a898:	0209      	lsls	r1, r1, #8
3418a89a:	4401      	add	r1, r0
3418a89c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a8a0:	4313      	orrs	r3, r2
3418a8a2:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418a8a4:	68fa      	ldr	r2, [r7, #12]
3418a8a6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a8a8:	2134      	movs	r1, #52	@ 0x34
3418a8aa:	fb01 f303 	mul.w	r3, r1, r3
3418a8ae:	4413      	add	r3, r2
3418a8b0:	3364      	adds	r3, #100	@ 0x64
3418a8b2:	681b      	ldr	r3, [r3, #0]
3418a8b4:	68fa      	ldr	r2, [r7, #12]
3418a8b6:	6812      	ldr	r2, [r2, #0]
3418a8b8:	4611      	mov	r1, r2
3418a8ba:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a8bc:	0212      	lsls	r2, r2, #8
3418a8be:	440a      	add	r2, r1
3418a8c0:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a8c4:	085b      	lsrs	r3, r3, #1
3418a8c6:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418a8c8:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418a8ca:	68fa      	ldr	r2, [r7, #12]
3418a8cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a8ce:	2134      	movs	r1, #52	@ 0x34
3418a8d0:	fb01 f303 	mul.w	r3, r1, r3
3418a8d4:	4413      	add	r3, r2
3418a8d6:	3360      	adds	r3, #96	@ 0x60
3418a8d8:	681b      	ldr	r3, [r3, #0]
3418a8da:	697a      	ldr	r2, [r7, #20]
3418a8dc:	fb02 f303 	mul.w	r3, r2, r3
3418a8e0:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a8e2:	68f9      	ldr	r1, [r7, #12]
3418a8e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a8e6:	2034      	movs	r0, #52	@ 0x34
3418a8e8:	fb00 f303 	mul.w	r3, r0, r3
3418a8ec:	440b      	add	r3, r1
3418a8ee:	333c      	adds	r3, #60	@ 0x3c
3418a8f0:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418a8f2:	68f8      	ldr	r0, [r7, #12]
3418a8f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a8f6:	2434      	movs	r4, #52	@ 0x34
3418a8f8:	fb04 f303 	mul.w	r3, r4, r3
3418a8fc:	4403      	add	r3, r0
3418a8fe:	3338      	adds	r3, #56	@ 0x38
3418a900:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a902:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418a904:	6979      	ldr	r1, [r7, #20]
3418a906:	fb01 f303 	mul.w	r3, r1, r3
3418a90a:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418a90c:	68f9      	ldr	r1, [r7, #12]
3418a90e:	6809      	ldr	r1, [r1, #0]
3418a910:	4608      	mov	r0, r1
3418a912:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a914:	0209      	lsls	r1, r1, #8
3418a916:	4401      	add	r1, r0
3418a918:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a91c:	4313      	orrs	r3, r2
3418a91e:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3418a920:	68fb      	ldr	r3, [r7, #12]
3418a922:	681b      	ldr	r3, [r3, #0]
3418a924:	461a      	mov	r2, r3
3418a926:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a928:	021b      	lsls	r3, r3, #8
3418a92a:	4413      	add	r3, r2
3418a92c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418a930:	68db      	ldr	r3, [r3, #12]
3418a932:	68fa      	ldr	r2, [r7, #12]
3418a934:	6812      	ldr	r2, [r2, #0]
3418a936:	4611      	mov	r1, r2
3418a938:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418a93a:	0212      	lsls	r2, r2, #8
3418a93c:	440a      	add	r2, r1
3418a93e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418a942:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418a946:	f043 0301 	orr.w	r3, r3, #1
3418a94a:	60d3      	str	r3, [r2, #12]
}
3418a94c:	e379      	b.n	3418b042 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3418a94e:	683b      	ldr	r3, [r7, #0]
3418a950:	2b01      	cmp	r3, #1
3418a952:	f040 81b4 	bne.w	3418acbe <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418a956:	68fa      	ldr	r2, [r7, #12]
3418a958:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a95a:	2134      	movs	r1, #52	@ 0x34
3418a95c:	fb01 f303 	mul.w	r3, r1, r3
3418a960:	4413      	add	r3, r2
3418a962:	335c      	adds	r3, #92	@ 0x5c
3418a964:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a966:	68f9      	ldr	r1, [r7, #12]
3418a968:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a96a:	2034      	movs	r0, #52	@ 0x34
3418a96c:	fb00 f303 	mul.w	r3, r0, r3
3418a970:	440b      	add	r3, r1
3418a972:	333c      	adds	r3, #60	@ 0x3c
3418a974:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418a976:	68f8      	ldr	r0, [r7, #12]
3418a978:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a97a:	2434      	movs	r4, #52	@ 0x34
3418a97c:	fb04 f303 	mul.w	r3, r4, r3
3418a980:	4403      	add	r3, r0
3418a982:	3338      	adds	r3, #56	@ 0x38
3418a984:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a986:	1acb      	subs	r3, r1, r3
3418a988:	6979      	ldr	r1, [r7, #20]
3418a98a:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418a98e:	68f8      	ldr	r0, [r7, #12]
3418a990:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a992:	2434      	movs	r4, #52	@ 0x34
3418a994:	fb04 f101 	mul.w	r1, r4, r1
3418a998:	4401      	add	r1, r0
3418a99a:	3144      	adds	r1, #68	@ 0x44
3418a99c:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3418a99e:	68fc      	ldr	r4, [r7, #12]
3418a9a0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a9a2:	2534      	movs	r5, #52	@ 0x34
3418a9a4:	fb05 f101 	mul.w	r1, r5, r1
3418a9a8:	4421      	add	r1, r4
3418a9aa:	3140      	adds	r1, #64	@ 0x40
3418a9ac:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418a9ae:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3418a9b0:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418a9b2:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418a9b6:	68f9      	ldr	r1, [r7, #12]
3418a9b8:	6809      	ldr	r1, [r1, #0]
3418a9ba:	4608      	mov	r0, r1
3418a9bc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418a9be:	0209      	lsls	r1, r1, #8
3418a9c0:	4401      	add	r1, r0
3418a9c2:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418a9c6:	4413      	add	r3, r2
3418a9c8:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418a9ca:	68fa      	ldr	r2, [r7, #12]
3418a9cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a9ce:	2134      	movs	r1, #52	@ 0x34
3418a9d0:	fb01 f303 	mul.w	r3, r1, r3
3418a9d4:	4413      	add	r3, r2
3418a9d6:	3348      	adds	r3, #72	@ 0x48
3418a9d8:	681b      	ldr	r3, [r3, #0]
3418a9da:	f240 120d 	movw	r2, #269	@ 0x10d
3418a9de:	4293      	cmp	r3, r2
3418a9e0:	d004      	beq.n	3418a9ec <LTDC_SetConfig+0x6b8>
3418a9e2:	f240 220d 	movw	r2, #525	@ 0x20d
3418a9e6:	4293      	cmp	r3, r2
3418a9e8:	d075      	beq.n	3418aad6 <LTDC_SetConfig+0x7a2>
        break;
3418a9ea:	e122      	b.n	3418ac32 <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418a9ec:	68fa      	ldr	r2, [r7, #12]
3418a9ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418a9f0:	2134      	movs	r1, #52	@ 0x34
3418a9f2:	fb01 f303 	mul.w	r3, r1, r3
3418a9f6:	4413      	add	r3, r2
3418a9f8:	333c      	adds	r3, #60	@ 0x3c
3418a9fa:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418a9fc:	68f9      	ldr	r1, [r7, #12]
3418a9fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa00:	2034      	movs	r0, #52	@ 0x34
3418aa02:	fb00 f303 	mul.w	r3, r0, r3
3418aa06:	440b      	add	r3, r1
3418aa08:	3338      	adds	r3, #56	@ 0x38
3418aa0a:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aa0c:	1ad3      	subs	r3, r2, r3
3418aa0e:	697a      	ldr	r2, [r7, #20]
3418aa10:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418aa14:	68f9      	ldr	r1, [r7, #12]
3418aa16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418aa18:	2034      	movs	r0, #52	@ 0x34
3418aa1a:	fb00 f202 	mul.w	r2, r0, r2
3418aa1e:	440a      	add	r2, r1
3418aa20:	3244      	adds	r2, #68	@ 0x44
3418aa22:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418aa24:	68f8      	ldr	r0, [r7, #12]
3418aa26:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418aa28:	2434      	movs	r4, #52	@ 0x34
3418aa2a:	fb04 f202 	mul.w	r2, r4, r2
3418aa2e:	4402      	add	r2, r0
3418aa30:	3240      	adds	r2, #64	@ 0x40
3418aa32:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418aa34:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418aa36:	0852      	lsrs	r2, r2, #1
3418aa38:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418aa3a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418aa3e:	68fb      	ldr	r3, [r7, #12]
3418aa40:	681b      	ldr	r3, [r3, #0]
3418aa42:	4619      	mov	r1, r3
3418aa44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa46:	021b      	lsls	r3, r3, #8
3418aa48:	440b      	add	r3, r1
3418aa4a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418aa4e:	4619      	mov	r1, r3
3418aa50:	68bb      	ldr	r3, [r7, #8]
3418aa52:	4413      	add	r3, r2
3418aa54:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418aa56:	68fa      	ldr	r2, [r7, #12]
3418aa58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa5a:	2134      	movs	r1, #52	@ 0x34
3418aa5c:	fb01 f303 	mul.w	r3, r1, r3
3418aa60:	4413      	add	r3, r2
3418aa62:	3360      	adds	r3, #96	@ 0x60
3418aa64:	681b      	ldr	r3, [r3, #0]
3418aa66:	697a      	ldr	r2, [r7, #20]
3418aa68:	fb02 f303 	mul.w	r3, r2, r3
3418aa6c:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418aa70:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aa72:	68f9      	ldr	r1, [r7, #12]
3418aa74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa76:	2034      	movs	r0, #52	@ 0x34
3418aa78:	fb00 f303 	mul.w	r3, r0, r3
3418aa7c:	440b      	add	r3, r1
3418aa7e:	333c      	adds	r3, #60	@ 0x3c
3418aa80:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3418aa82:	68f8      	ldr	r0, [r7, #12]
3418aa84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa86:	2434      	movs	r4, #52	@ 0x34
3418aa88:	fb04 f303 	mul.w	r3, r4, r3
3418aa8c:	4403      	add	r3, r0
3418aa8e:	3338      	adds	r3, #56	@ 0x38
3418aa90:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aa92:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3418aa94:	6979      	ldr	r1, [r7, #20]
3418aa96:	fb01 f303 	mul.w	r3, r1, r3
3418aa9a:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418aa9c:	68f9      	ldr	r1, [r7, #12]
3418aa9e:	6809      	ldr	r1, [r1, #0]
3418aaa0:	4608      	mov	r0, r1
3418aaa2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418aaa4:	0209      	lsls	r1, r1, #8
3418aaa6:	4401      	add	r1, r0
3418aaa8:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418aaac:	4313      	orrs	r3, r2
3418aaae:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418aab0:	68fa      	ldr	r2, [r7, #12]
3418aab2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aab4:	2134      	movs	r1, #52	@ 0x34
3418aab6:	fb01 f303 	mul.w	r3, r1, r3
3418aaba:	4413      	add	r3, r2
3418aabc:	3364      	adds	r3, #100	@ 0x64
3418aabe:	681b      	ldr	r3, [r3, #0]
3418aac0:	68fa      	ldr	r2, [r7, #12]
3418aac2:	6812      	ldr	r2, [r2, #0]
3418aac4:	4611      	mov	r1, r2
3418aac6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418aac8:	0212      	lsls	r2, r2, #8
3418aaca:	440a      	add	r2, r1
3418aacc:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418aad0:	085b      	lsrs	r3, r3, #1
3418aad2:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418aad4:	e0ad      	b.n	3418ac32 <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aad6:	68fa      	ldr	r2, [r7, #12]
3418aad8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aada:	2134      	movs	r1, #52	@ 0x34
3418aadc:	fb01 f303 	mul.w	r3, r1, r3
3418aae0:	4413      	add	r3, r2
3418aae2:	333c      	adds	r3, #60	@ 0x3c
3418aae4:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418aae6:	68f9      	ldr	r1, [r7, #12]
3418aae8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aaea:	2034      	movs	r0, #52	@ 0x34
3418aaec:	fb00 f303 	mul.w	r3, r0, r3
3418aaf0:	440b      	add	r3, r1
3418aaf2:	3338      	adds	r3, #56	@ 0x38
3418aaf4:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aaf6:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418aaf8:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aafa:	697a      	ldr	r2, [r7, #20]
3418aafc:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ab00:	68f9      	ldr	r1, [r7, #12]
3418ab02:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ab04:	2034      	movs	r0, #52	@ 0x34
3418ab06:	fb00 f202 	mul.w	r2, r0, r2
3418ab0a:	440a      	add	r2, r1
3418ab0c:	3244      	adds	r2, #68	@ 0x44
3418ab0e:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418ab10:	68f8      	ldr	r0, [r7, #12]
3418ab12:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ab14:	2434      	movs	r4, #52	@ 0x34
3418ab16:	fb04 f202 	mul.w	r2, r4, r2
3418ab1a:	4402      	add	r2, r0
3418ab1c:	3240      	adds	r2, #64	@ 0x40
3418ab1e:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ab20:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418ab22:	0852      	lsrs	r2, r2, #1
3418ab24:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ab26:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418ab2a:	68fb      	ldr	r3, [r7, #12]
3418ab2c:	681b      	ldr	r3, [r3, #0]
3418ab2e:	4619      	mov	r1, r3
3418ab30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ab32:	021b      	lsls	r3, r3, #8
3418ab34:	440b      	add	r3, r1
3418ab36:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418ab3a:	4619      	mov	r1, r3
3418ab3c:	68bb      	ldr	r3, [r7, #8]
3418ab3e:	4413      	add	r3, r2
3418ab40:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ab42:	68fa      	ldr	r2, [r7, #12]
3418ab44:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ab46:	2134      	movs	r1, #52	@ 0x34
3418ab48:	fb01 f303 	mul.w	r3, r1, r3
3418ab4c:	4413      	add	r3, r2
3418ab4e:	333c      	adds	r3, #60	@ 0x3c
3418ab50:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ab52:	68f9      	ldr	r1, [r7, #12]
3418ab54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ab56:	2034      	movs	r0, #52	@ 0x34
3418ab58:	fb00 f303 	mul.w	r3, r0, r3
3418ab5c:	440b      	add	r3, r1
3418ab5e:	3338      	adds	r3, #56	@ 0x38
3418ab60:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ab62:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ab64:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ab66:	697a      	ldr	r2, [r7, #20]
3418ab68:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ab6c:	68f9      	ldr	r1, [r7, #12]
3418ab6e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ab70:	2034      	movs	r0, #52	@ 0x34
3418ab72:	fb00 f202 	mul.w	r2, r0, r2
3418ab76:	440a      	add	r2, r1
3418ab78:	3244      	adds	r2, #68	@ 0x44
3418ab7a:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418ab7c:	68f8      	ldr	r0, [r7, #12]
3418ab7e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ab80:	2434      	movs	r4, #52	@ 0x34
3418ab82:	fb04 f202 	mul.w	r2, r4, r2
3418ab86:	4402      	add	r2, r0
3418ab88:	3240      	adds	r2, #64	@ 0x40
3418ab8a:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ab8c:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418ab8e:	0852      	lsrs	r2, r2, #1
3418ab90:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ab92:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418ab96:	68fb      	ldr	r3, [r7, #12]
3418ab98:	681b      	ldr	r3, [r3, #0]
3418ab9a:	4619      	mov	r1, r3
3418ab9c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ab9e:	021b      	lsls	r3, r3, #8
3418aba0:	440b      	add	r3, r1
3418aba2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418aba6:	4619      	mov	r1, r3
3418aba8:	687b      	ldr	r3, [r7, #4]
3418abaa:	4413      	add	r3, r2
3418abac:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418abae:	68fa      	ldr	r2, [r7, #12]
3418abb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418abb2:	2134      	movs	r1, #52	@ 0x34
3418abb4:	fb01 f303 	mul.w	r3, r1, r3
3418abb8:	4413      	add	r3, r2
3418abba:	3360      	adds	r3, #96	@ 0x60
3418abbc:	681b      	ldr	r3, [r3, #0]
3418abbe:	085b      	lsrs	r3, r3, #1
3418abc0:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418abc4:	697a      	ldr	r2, [r7, #20]
3418abc6:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
3418abca:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418abcc:	68f9      	ldr	r1, [r7, #12]
3418abce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418abd0:	2034      	movs	r0, #52	@ 0x34
3418abd2:	fb00 f303 	mul.w	r3, r0, r3
3418abd6:	440b      	add	r3, r1
3418abd8:	333c      	adds	r3, #60	@ 0x3c
3418abda:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418abdc:	68f8      	ldr	r0, [r7, #12]
3418abde:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418abe0:	2434      	movs	r4, #52	@ 0x34
3418abe2:	fb04 f303 	mul.w	r3, r4, r3
3418abe6:	4403      	add	r3, r0
3418abe8:	3338      	adds	r3, #56	@ 0x38
3418abea:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418abec:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418abee:	085b      	lsrs	r3, r3, #1
3418abf0:	6979      	ldr	r1, [r7, #20]
3418abf2:	fb01 f303 	mul.w	r3, r1, r3
3418abf6:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418abf8:	68f9      	ldr	r1, [r7, #12]
3418abfa:	6809      	ldr	r1, [r1, #0]
3418abfc:	4608      	mov	r0, r1
3418abfe:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ac00:	0209      	lsls	r1, r1, #8
3418ac02:	4401      	add	r1, r0
3418ac04:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
3418ac08:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418ac0a:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418ac0c:	68fa      	ldr	r2, [r7, #12]
3418ac0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac10:	2134      	movs	r1, #52	@ 0x34
3418ac12:	fb01 f303 	mul.w	r3, r1, r3
3418ac16:	4413      	add	r3, r2
3418ac18:	3364      	adds	r3, #100	@ 0x64
3418ac1a:	681b      	ldr	r3, [r3, #0]
3418ac1c:	68fa      	ldr	r2, [r7, #12]
3418ac1e:	6812      	ldr	r2, [r2, #0]
3418ac20:	4611      	mov	r1, r2
3418ac22:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ac24:	0212      	lsls	r2, r2, #8
3418ac26:	440a      	add	r2, r1
3418ac28:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418ac2c:	085b      	lsrs	r3, r3, #1
3418ac2e:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418ac30:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418ac32:	68fa      	ldr	r2, [r7, #12]
3418ac34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac36:	2134      	movs	r1, #52	@ 0x34
3418ac38:	fb01 f303 	mul.w	r3, r1, r3
3418ac3c:	4413      	add	r3, r2
3418ac3e:	3360      	adds	r3, #96	@ 0x60
3418ac40:	681b      	ldr	r3, [r3, #0]
3418ac42:	697a      	ldr	r2, [r7, #20]
3418ac44:	fb02 f303 	mul.w	r3, r2, r3
3418ac48:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418ac4c:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ac4e:	68f9      	ldr	r1, [r7, #12]
3418ac50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac52:	2034      	movs	r0, #52	@ 0x34
3418ac54:	fb00 f303 	mul.w	r3, r0, r3
3418ac58:	440b      	add	r3, r1
3418ac5a:	333c      	adds	r3, #60	@ 0x3c
3418ac5c:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418ac5e:	68f8      	ldr	r0, [r7, #12]
3418ac60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac62:	2434      	movs	r4, #52	@ 0x34
3418ac64:	fb04 f303 	mul.w	r3, r4, r3
3418ac68:	4403      	add	r3, r0
3418ac6a:	3338      	adds	r3, #56	@ 0x38
3418ac6c:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ac6e:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418ac70:	6979      	ldr	r1, [r7, #20]
3418ac72:	fb01 f303 	mul.w	r3, r1, r3
3418ac76:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418ac78:	68f9      	ldr	r1, [r7, #12]
3418ac7a:	6809      	ldr	r1, [r1, #0]
3418ac7c:	4608      	mov	r0, r1
3418ac7e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ac80:	0209      	lsls	r1, r1, #8
3418ac82:	4401      	add	r1, r0
3418ac84:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418ac88:	4313      	orrs	r3, r2
3418ac8a:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3418ac8c:	68fb      	ldr	r3, [r7, #12]
3418ac8e:	681b      	ldr	r3, [r3, #0]
3418ac90:	461a      	mov	r2, r3
3418ac92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac94:	021b      	lsls	r3, r3, #8
3418ac96:	4413      	add	r3, r2
3418ac98:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418ac9c:	68db      	ldr	r3, [r3, #12]
3418ac9e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3418aca2:	f023 0301 	bic.w	r3, r3, #1
3418aca6:	68fa      	ldr	r2, [r7, #12]
3418aca8:	6812      	ldr	r2, [r2, #0]
3418acaa:	4611      	mov	r1, r2
3418acac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418acae:	0212      	lsls	r2, r2, #8
3418acb0:	440a      	add	r2, r1
3418acb2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418acb6:	f043 0301 	orr.w	r3, r3, #1
3418acba:	60d3      	str	r3, [r2, #12]
}
3418acbc:	e1c1      	b.n	3418b042 <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418acbe:	68fa      	ldr	r2, [r7, #12]
3418acc0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418acc2:	2134      	movs	r1, #52	@ 0x34
3418acc4:	fb01 f303 	mul.w	r3, r1, r3
3418acc8:	4413      	add	r3, r2
3418acca:	335c      	adds	r3, #92	@ 0x5c
3418accc:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418acce:	68f9      	ldr	r1, [r7, #12]
3418acd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418acd2:	2034      	movs	r0, #52	@ 0x34
3418acd4:	fb00 f303 	mul.w	r3, r0, r3
3418acd8:	440b      	add	r3, r1
3418acda:	333c      	adds	r3, #60	@ 0x3c
3418acdc:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418acde:	68f8      	ldr	r0, [r7, #12]
3418ace0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ace2:	2434      	movs	r4, #52	@ 0x34
3418ace4:	fb04 f303 	mul.w	r3, r4, r3
3418ace8:	4403      	add	r3, r0
3418acea:	3338      	adds	r3, #56	@ 0x38
3418acec:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418acee:	1acb      	subs	r3, r1, r3
3418acf0:	6979      	ldr	r1, [r7, #20]
3418acf2:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418acf6:	68f8      	ldr	r0, [r7, #12]
3418acf8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418acfa:	2434      	movs	r4, #52	@ 0x34
3418acfc:	fb04 f101 	mul.w	r1, r4, r1
3418ad00:	4401      	add	r1, r0
3418ad02:	3144      	adds	r1, #68	@ 0x44
3418ad04:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3418ad06:	68fc      	ldr	r4, [r7, #12]
3418ad08:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ad0a:	2534      	movs	r5, #52	@ 0x34
3418ad0c:	fb05 f101 	mul.w	r1, r5, r1
3418ad10:	4421      	add	r1, r4
3418ad12:	3140      	adds	r1, #64	@ 0x40
3418ad14:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418ad16:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418ad18:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418ad1c:	4413      	add	r3, r2
3418ad1e:	68fa      	ldr	r2, [r7, #12]
3418ad20:	6812      	ldr	r2, [r2, #0]
3418ad22:	4611      	mov	r1, r2
3418ad24:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ad26:	0212      	lsls	r2, r2, #8
3418ad28:	440a      	add	r2, r1
3418ad2a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3418ad2e:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418ad30:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418ad32:	68fa      	ldr	r2, [r7, #12]
3418ad34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ad36:	2134      	movs	r1, #52	@ 0x34
3418ad38:	fb01 f303 	mul.w	r3, r1, r3
3418ad3c:	4413      	add	r3, r2
3418ad3e:	3348      	adds	r3, #72	@ 0x48
3418ad40:	681b      	ldr	r3, [r3, #0]
3418ad42:	f240 120d 	movw	r2, #269	@ 0x10d
3418ad46:	4293      	cmp	r3, r2
3418ad48:	d004      	beq.n	3418ad54 <LTDC_SetConfig+0xa20>
3418ad4a:	f240 220d 	movw	r2, #525	@ 0x20d
3418ad4e:	4293      	cmp	r3, r2
3418ad50:	d074      	beq.n	3418ae3c <LTDC_SetConfig+0xb08>
        break;
3418ad52:	e133      	b.n	3418afbc <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ad54:	68fa      	ldr	r2, [r7, #12]
3418ad56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ad58:	2134      	movs	r1, #52	@ 0x34
3418ad5a:	fb01 f303 	mul.w	r3, r1, r3
3418ad5e:	4413      	add	r3, r2
3418ad60:	333c      	adds	r3, #60	@ 0x3c
3418ad62:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418ad64:	68f9      	ldr	r1, [r7, #12]
3418ad66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ad68:	2034      	movs	r0, #52	@ 0x34
3418ad6a:	fb00 f303 	mul.w	r3, r0, r3
3418ad6e:	440b      	add	r3, r1
3418ad70:	3338      	adds	r3, #56	@ 0x38
3418ad72:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ad74:	1ad3      	subs	r3, r2, r3
3418ad76:	697a      	ldr	r2, [r7, #20]
3418ad78:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ad7c:	68f9      	ldr	r1, [r7, #12]
3418ad7e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ad80:	2034      	movs	r0, #52	@ 0x34
3418ad82:	fb00 f202 	mul.w	r2, r0, r2
3418ad86:	440a      	add	r2, r1
3418ad88:	3244      	adds	r2, #68	@ 0x44
3418ad8a:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418ad8c:	68f8      	ldr	r0, [r7, #12]
3418ad8e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ad90:	2434      	movs	r4, #52	@ 0x34
3418ad92:	fb04 f202 	mul.w	r2, r4, r2
3418ad96:	4402      	add	r2, r0
3418ad98:	3240      	adds	r2, #64	@ 0x40
3418ad9a:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ad9c:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418ad9e:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418ada0:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418ada4:	68bb      	ldr	r3, [r7, #8]
3418ada6:	4413      	add	r3, r2
3418ada8:	68fa      	ldr	r2, [r7, #12]
3418adaa:	6812      	ldr	r2, [r2, #0]
3418adac:	4611      	mov	r1, r2
3418adae:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418adb0:	0212      	lsls	r2, r2, #8
3418adb2:	440a      	add	r2, r1
3418adb4:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418adb8:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418adba:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418adbc:	68fa      	ldr	r2, [r7, #12]
3418adbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418adc0:	2134      	movs	r1, #52	@ 0x34
3418adc2:	fb01 f303 	mul.w	r3, r1, r3
3418adc6:	4413      	add	r3, r2
3418adc8:	3360      	adds	r3, #96	@ 0x60
3418adca:	681b      	ldr	r3, [r3, #0]
3418adcc:	697a      	ldr	r2, [r7, #20]
3418adce:	fb02 f303 	mul.w	r3, r2, r3
3418add2:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418add6:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418add8:	68f9      	ldr	r1, [r7, #12]
3418adda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418addc:	2034      	movs	r0, #52	@ 0x34
3418adde:	fb00 f303 	mul.w	r3, r0, r3
3418ade2:	440b      	add	r3, r1
3418ade4:	333c      	adds	r3, #60	@ 0x3c
3418ade6:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3418ade8:	68f8      	ldr	r0, [r7, #12]
3418adea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418adec:	2434      	movs	r4, #52	@ 0x34
3418adee:	fb04 f303 	mul.w	r3, r4, r3
3418adf2:	4403      	add	r3, r0
3418adf4:	3338      	adds	r3, #56	@ 0x38
3418adf6:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418adf8:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3418adfa:	6979      	ldr	r1, [r7, #20]
3418adfc:	fb01 f303 	mul.w	r3, r1, r3
3418ae00:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418ae02:	68f9      	ldr	r1, [r7, #12]
3418ae04:	6809      	ldr	r1, [r1, #0]
3418ae06:	4608      	mov	r0, r1
3418ae08:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ae0a:	0209      	lsls	r1, r1, #8
3418ae0c:	4401      	add	r1, r0
3418ae0e:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418ae12:	4313      	orrs	r3, r2
3418ae14:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418ae16:	68fa      	ldr	r2, [r7, #12]
3418ae18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ae1a:	2134      	movs	r1, #52	@ 0x34
3418ae1c:	fb01 f303 	mul.w	r3, r1, r3
3418ae20:	4413      	add	r3, r2
3418ae22:	3364      	adds	r3, #100	@ 0x64
3418ae24:	681b      	ldr	r3, [r3, #0]
3418ae26:	68fa      	ldr	r2, [r7, #12]
3418ae28:	6812      	ldr	r2, [r2, #0]
3418ae2a:	4611      	mov	r1, r2
3418ae2c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ae2e:	0212      	lsls	r2, r2, #8
3418ae30:	440a      	add	r2, r1
3418ae32:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418ae36:	085b      	lsrs	r3, r3, #1
3418ae38:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418ae3a:	e0bf      	b.n	3418afbc <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ae3c:	68fa      	ldr	r2, [r7, #12]
3418ae3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ae40:	2134      	movs	r1, #52	@ 0x34
3418ae42:	fb01 f303 	mul.w	r3, r1, r3
3418ae46:	4413      	add	r3, r2
3418ae48:	333c      	adds	r3, #60	@ 0x3c
3418ae4a:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ae4c:	68f9      	ldr	r1, [r7, #12]
3418ae4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ae50:	2034      	movs	r0, #52	@ 0x34
3418ae52:	fb00 f303 	mul.w	r3, r0, r3
3418ae56:	440b      	add	r3, r1
3418ae58:	3338      	adds	r3, #56	@ 0x38
3418ae5a:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ae5c:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ae5e:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ae60:	697a      	ldr	r2, [r7, #20]
3418ae62:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ae66:	68f9      	ldr	r1, [r7, #12]
3418ae68:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ae6a:	2034      	movs	r0, #52	@ 0x34
3418ae6c:	fb00 f202 	mul.w	r2, r0, r2
3418ae70:	440a      	add	r2, r1
3418ae72:	3244      	adds	r2, #68	@ 0x44
3418ae74:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418ae76:	68f8      	ldr	r0, [r7, #12]
3418ae78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ae7a:	2434      	movs	r4, #52	@ 0x34
3418ae7c:	fb04 f202 	mul.w	r2, r4, r2
3418ae80:	4402      	add	r2, r0
3418ae82:	3240      	adds	r2, #64	@ 0x40
3418ae84:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418ae86:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418ae88:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418ae8a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418ae8e:	68bb      	ldr	r3, [r7, #8]
3418ae90:	4413      	add	r3, r2
3418ae92:	68fa      	ldr	r2, [r7, #12]
3418ae94:	6812      	ldr	r2, [r2, #0]
3418ae96:	4611      	mov	r1, r2
3418ae98:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ae9a:	0212      	lsls	r2, r2, #8
3418ae9c:	440a      	add	r2, r1
3418ae9e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418aea2:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418aea4:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aea6:	68fa      	ldr	r2, [r7, #12]
3418aea8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aeaa:	2134      	movs	r1, #52	@ 0x34
3418aeac:	fb01 f303 	mul.w	r3, r1, r3
3418aeb0:	4413      	add	r3, r2
3418aeb2:	333c      	adds	r3, #60	@ 0x3c
3418aeb4:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418aeb6:	68f9      	ldr	r1, [r7, #12]
3418aeb8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aeba:	2034      	movs	r0, #52	@ 0x34
3418aebc:	fb00 f303 	mul.w	r3, r0, r3
3418aec0:	440b      	add	r3, r1
3418aec2:	3338      	adds	r3, #56	@ 0x38
3418aec4:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aec6:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418aec8:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aeca:	697a      	ldr	r2, [r7, #20]
3418aecc:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418aed0:	68f9      	ldr	r1, [r7, #12]
3418aed2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418aed4:	2034      	movs	r0, #52	@ 0x34
3418aed6:	fb00 f202 	mul.w	r2, r0, r2
3418aeda:	440a      	add	r2, r1
3418aedc:	3244      	adds	r2, #68	@ 0x44
3418aede:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418aee0:	68f8      	ldr	r0, [r7, #12]
3418aee2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418aee4:	2434      	movs	r4, #52	@ 0x34
3418aee6:	fb04 f202 	mul.w	r2, r4, r2
3418aeea:	4402      	add	r2, r0
3418aeec:	3240      	adds	r2, #64	@ 0x40
3418aeee:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418aef0:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418aef2:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418aef4:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418aef8:	687b      	ldr	r3, [r7, #4]
3418aefa:	4413      	add	r3, r2
3418aefc:	68fa      	ldr	r2, [r7, #12]
3418aefe:	6812      	ldr	r2, [r2, #0]
3418af00:	4611      	mov	r1, r2
3418af02:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418af04:	0212      	lsls	r2, r2, #8
3418af06:	440a      	add	r2, r1
3418af08:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418af0c:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418af0e:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418af10:	68fa      	ldr	r2, [r7, #12]
3418af12:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418af14:	2134      	movs	r1, #52	@ 0x34
3418af16:	fb01 f303 	mul.w	r3, r1, r3
3418af1a:	4413      	add	r3, r2
3418af1c:	3360      	adds	r3, #96	@ 0x60
3418af1e:	681b      	ldr	r3, [r3, #0]
3418af20:	085b      	lsrs	r3, r3, #1
3418af22:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418af26:	697a      	ldr	r2, [r7, #20]
3418af28:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
3418af2c:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418af2e:	68f9      	ldr	r1, [r7, #12]
3418af30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418af32:	2034      	movs	r0, #52	@ 0x34
3418af34:	fb00 f303 	mul.w	r3, r0, r3
3418af38:	440b      	add	r3, r1
3418af3a:	333c      	adds	r3, #60	@ 0x3c
3418af3c:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418af3e:	68f8      	ldr	r0, [r7, #12]
3418af40:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418af42:	2434      	movs	r4, #52	@ 0x34
3418af44:	fb04 f303 	mul.w	r3, r4, r3
3418af48:	4403      	add	r3, r0
3418af4a:	3338      	adds	r3, #56	@ 0x38
3418af4c:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418af4e:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418af50:	085b      	lsrs	r3, r3, #1
3418af52:	6979      	ldr	r1, [r7, #20]
3418af54:	fb01 f303 	mul.w	r3, r1, r3
3418af58:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418af5a:	68f9      	ldr	r1, [r7, #12]
3418af5c:	6809      	ldr	r1, [r1, #0]
3418af5e:	4608      	mov	r0, r1
3418af60:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418af62:	0209      	lsls	r1, r1, #8
3418af64:	4401      	add	r1, r0
3418af66:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
3418af6a:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418af6c:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
3418af6e:	68fb      	ldr	r3, [r7, #12]
3418af70:	681b      	ldr	r3, [r3, #0]
3418af72:	461a      	mov	r2, r3
3418af74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418af76:	021b      	lsls	r3, r3, #8
3418af78:	4413      	add	r3, r2
3418af7a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418af7e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418af80:	68fa      	ldr	r2, [r7, #12]
3418af82:	6812      	ldr	r2, [r2, #0]
3418af84:	4611      	mov	r1, r2
3418af86:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418af88:	0212      	lsls	r2, r2, #8
3418af8a:	440a      	add	r2, r1
3418af8c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418af90:	0c1b      	lsrs	r3, r3, #16
3418af92:	041b      	lsls	r3, r3, #16
3418af94:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418af96:	68fa      	ldr	r2, [r7, #12]
3418af98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418af9a:	2134      	movs	r1, #52	@ 0x34
3418af9c:	fb01 f303 	mul.w	r3, r1, r3
3418afa0:	4413      	add	r3, r2
3418afa2:	3364      	adds	r3, #100	@ 0x64
3418afa4:	681b      	ldr	r3, [r3, #0]
3418afa6:	68fa      	ldr	r2, [r7, #12]
3418afa8:	6812      	ldr	r2, [r2, #0]
3418afaa:	4611      	mov	r1, r2
3418afac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418afae:	0212      	lsls	r2, r2, #8
3418afb0:	440a      	add	r2, r1
3418afb2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418afb6:	085b      	lsrs	r3, r3, #1
3418afb8:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418afba:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418afbc:	68fa      	ldr	r2, [r7, #12]
3418afbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418afc0:	2134      	movs	r1, #52	@ 0x34
3418afc2:	fb01 f303 	mul.w	r3, r1, r3
3418afc6:	4413      	add	r3, r2
3418afc8:	3360      	adds	r3, #96	@ 0x60
3418afca:	681b      	ldr	r3, [r3, #0]
3418afcc:	697a      	ldr	r2, [r7, #20]
3418afce:	fb02 f303 	mul.w	r3, r2, r3
3418afd2:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418afd6:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418afd8:	68f9      	ldr	r1, [r7, #12]
3418afda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418afdc:	2034      	movs	r0, #52	@ 0x34
3418afde:	fb00 f303 	mul.w	r3, r0, r3
3418afe2:	440b      	add	r3, r1
3418afe4:	333c      	adds	r3, #60	@ 0x3c
3418afe6:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418afe8:	68f8      	ldr	r0, [r7, #12]
3418afea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418afec:	2434      	movs	r4, #52	@ 0x34
3418afee:	fb04 f303 	mul.w	r3, r4, r3
3418aff2:	4403      	add	r3, r0
3418aff4:	3338      	adds	r3, #56	@ 0x38
3418aff6:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418aff8:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418affa:	6979      	ldr	r1, [r7, #20]
3418affc:	fb01 f303 	mul.w	r3, r1, r3
3418b000:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418b002:	68f9      	ldr	r1, [r7, #12]
3418b004:	6809      	ldr	r1, [r1, #0]
3418b006:	4608      	mov	r0, r1
3418b008:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418b00a:	0209      	lsls	r1, r1, #8
3418b00c:	4401      	add	r1, r0
3418b00e:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418b012:	4313      	orrs	r3, r2
3418b014:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3418b016:	68fb      	ldr	r3, [r7, #12]
3418b018:	681b      	ldr	r3, [r3, #0]
3418b01a:	461a      	mov	r2, r3
3418b01c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b01e:	021b      	lsls	r3, r3, #8
3418b020:	4413      	add	r3, r2
3418b022:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b026:	68db      	ldr	r3, [r3, #12]
3418b028:	68fa      	ldr	r2, [r7, #12]
3418b02a:	6812      	ldr	r2, [r2, #0]
3418b02c:	4611      	mov	r1, r2
3418b02e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418b030:	0212      	lsls	r2, r2, #8
3418b032:	440a      	add	r2, r1
3418b034:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418b038:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418b03c:	f043 0301 	orr.w	r3, r3, #1
3418b040:	60d3      	str	r3, [r2, #12]
}
3418b042:	bf00      	nop
3418b044:	371c      	adds	r7, #28
3418b046:	46bd      	mov	sp, r7
3418b048:	bcb0      	pop	{r4, r5, r7}
3418b04a:	4770      	bx	lr

3418b04c <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3418b04c:	b480      	push	{r7}
3418b04e:	b087      	sub	sp, #28
3418b050:	af00      	add	r7, sp, #0
3418b052:	6078      	str	r0, [r7, #4]
3418b054:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
3418b056:	687a      	ldr	r2, [r7, #4]
3418b058:	683b      	ldr	r3, [r7, #0]
3418b05a:	2134      	movs	r1, #52	@ 0x34
3418b05c:	fb01 f303 	mul.w	r3, r1, r3
3418b060:	4413      	add	r3, r2
3418b062:	3369      	adds	r3, #105	@ 0x69
3418b064:	781b      	ldrb	r3, [r3, #0]
3418b066:	021b      	lsls	r3, r3, #8
3418b068:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
3418b06a:	687a      	ldr	r2, [r7, #4]
3418b06c:	683b      	ldr	r3, [r7, #0]
3418b06e:	2134      	movs	r1, #52	@ 0x34
3418b070:	fb01 f303 	mul.w	r3, r1, r3
3418b074:	4413      	add	r3, r2
3418b076:	336a      	adds	r3, #106	@ 0x6a
3418b078:	781b      	ldrb	r3, [r3, #0]
3418b07a:	041b      	lsls	r3, r3, #16
3418b07c:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
3418b07e:	687a      	ldr	r2, [r7, #4]
3418b080:	683b      	ldr	r3, [r7, #0]
3418b082:	2134      	movs	r1, #52	@ 0x34
3418b084:	fb01 f303 	mul.w	r3, r1, r3
3418b088:	4413      	add	r3, r2
3418b08a:	3350      	adds	r3, #80	@ 0x50
3418b08c:	681b      	ldr	r3, [r3, #0]
3418b08e:	061b      	lsls	r3, r3, #24
3418b090:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3418b092:	687a      	ldr	r2, [r7, #4]
3418b094:	683b      	ldr	r3, [r7, #0]
3418b096:	2134      	movs	r1, #52	@ 0x34
3418b098:	fb01 f303 	mul.w	r3, r1, r3
3418b09c:	4413      	add	r3, r2
3418b09e:	3368      	adds	r3, #104	@ 0x68
3418b0a0:	781b      	ldrb	r3, [r3, #0]
3418b0a2:	461a      	mov	r2, r3
3418b0a4:	697b      	ldr	r3, [r7, #20]
3418b0a6:	431a      	orrs	r2, r3
3418b0a8:	693b      	ldr	r3, [r7, #16]
3418b0aa:	431a      	orrs	r2, r3
3418b0ac:	687b      	ldr	r3, [r7, #4]
3418b0ae:	681b      	ldr	r3, [r3, #0]
3418b0b0:	4619      	mov	r1, r3
3418b0b2:	683b      	ldr	r3, [r7, #0]
3418b0b4:	021b      	lsls	r3, r3, #8
3418b0b6:	440b      	add	r3, r1
3418b0b8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b0bc:	4619      	mov	r1, r3
3418b0be:	68fb      	ldr	r3, [r7, #12]
3418b0c0:	4313      	orrs	r3, r2
3418b0c2:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3418b0c4:	687b      	ldr	r3, [r7, #4]
3418b0c6:	681b      	ldr	r3, [r3, #0]
3418b0c8:	461a      	mov	r2, r3
3418b0ca:	683b      	ldr	r3, [r7, #0]
3418b0cc:	021b      	lsls	r3, r3, #8
3418b0ce:	4413      	add	r3, r2
3418b0d0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b0d4:	6a1b      	ldr	r3, [r3, #32]
3418b0d6:	687a      	ldr	r2, [r7, #4]
3418b0d8:	6812      	ldr	r2, [r2, #0]
3418b0da:	4611      	mov	r1, r2
3418b0dc:	683a      	ldr	r2, [r7, #0]
3418b0de:	0212      	lsls	r2, r2, #8
3418b0e0:	440a      	add	r2, r1
3418b0e2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418b0e6:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3418b0ea:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
3418b0ec:	687b      	ldr	r3, [r7, #4]
3418b0ee:	681b      	ldr	r3, [r3, #0]
3418b0f0:	461a      	mov	r2, r3
3418b0f2:	683b      	ldr	r3, [r7, #0]
3418b0f4:	021b      	lsls	r3, r3, #8
3418b0f6:	4413      	add	r3, r2
3418b0f8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b0fc:	4618      	mov	r0, r3
3418b0fe:	687a      	ldr	r2, [r7, #4]
3418b100:	683b      	ldr	r3, [r7, #0]
3418b102:	2134      	movs	r1, #52	@ 0x34
3418b104:	fb01 f303 	mul.w	r3, r1, r3
3418b108:	4413      	add	r3, r2
3418b10a:	334c      	adds	r3, #76	@ 0x4c
3418b10c:	681b      	ldr	r3, [r3, #0]
3418b10e:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
3418b110:	687b      	ldr	r3, [r7, #4]
3418b112:	681b      	ldr	r3, [r3, #0]
3418b114:	461a      	mov	r2, r3
3418b116:	683b      	ldr	r3, [r7, #0]
3418b118:	021b      	lsls	r3, r3, #8
3418b11a:	4413      	add	r3, r2
3418b11c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b120:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418b122:	687b      	ldr	r3, [r7, #4]
3418b124:	681b      	ldr	r3, [r3, #0]
3418b126:	4619      	mov	r1, r3
3418b128:	683b      	ldr	r3, [r7, #0]
3418b12a:	021b      	lsls	r3, r3, #8
3418b12c:	440b      	add	r3, r1
3418b12e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b132:	4619      	mov	r1, r3
3418b134:	4b19      	ldr	r3, [pc, #100]	@ (3418b19c <LTDC_SetCompositionConfig+0x150>)
3418b136:	4013      	ands	r3, r2
3418b138:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3418b13a:	687b      	ldr	r3, [r7, #4]
3418b13c:	681b      	ldr	r3, [r3, #0]
3418b13e:	461a      	mov	r2, r3
3418b140:	683b      	ldr	r3, [r7, #0]
3418b142:	021b      	lsls	r3, r3, #8
3418b144:	4413      	add	r3, r2
3418b146:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b14a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418b14c:	0c1b      	lsrs	r3, r3, #16
3418b14e:	041b      	lsls	r3, r3, #16
3418b150:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418b154:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418b156:	687a      	ldr	r2, [r7, #4]
3418b158:	683b      	ldr	r3, [r7, #0]
3418b15a:	2134      	movs	r1, #52	@ 0x34
3418b15c:	fb01 f303 	mul.w	r3, r1, r3
3418b160:	4413      	add	r3, r2
3418b162:	3354      	adds	r3, #84	@ 0x54
3418b164:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3418b166:	6879      	ldr	r1, [r7, #4]
3418b168:	683b      	ldr	r3, [r7, #0]
3418b16a:	2034      	movs	r0, #52	@ 0x34
3418b16c:	fb00 f303 	mul.w	r3, r0, r3
3418b170:	440b      	add	r3, r1
3418b172:	3358      	adds	r3, #88	@ 0x58
3418b174:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418b176:	431a      	orrs	r2, r3
3418b178:	687b      	ldr	r3, [r7, #4]
3418b17a:	681b      	ldr	r3, [r3, #0]
3418b17c:	4619      	mov	r1, r3
3418b17e:	683b      	ldr	r3, [r7, #0]
3418b180:	021b      	lsls	r3, r3, #8
3418b182:	440b      	add	r3, r1
3418b184:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b188:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3418b18a:	697b      	ldr	r3, [r7, #20]
3418b18c:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418b18e:	628b      	str	r3, [r1, #40]	@ 0x28
}
3418b190:	bf00      	nop
3418b192:	371c      	adds	r7, #28
3418b194:	46bd      	mov	sp, r7
3418b196:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b19a:	4770      	bx	lr
3418b19c:	fffef8f8 	.word	0xfffef8f8

3418b1a0 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3418b1a0:	b480      	push	{r7}
3418b1a2:	b08d      	sub	sp, #52	@ 0x34
3418b1a4:	af00      	add	r7, sp, #0
3418b1a6:	6078      	str	r0, [r7, #4]
3418b1a8:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
3418b1aa:	2300      	movs	r3, #0
3418b1ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
3418b1ae:	2300      	movs	r3, #0
3418b1b0:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
3418b1b2:	2300      	movs	r3, #0
3418b1b4:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
3418b1b6:	2300      	movs	r3, #0
3418b1b8:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
3418b1ba:	2300      	movs	r3, #0
3418b1bc:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
3418b1be:	2300      	movs	r3, #0
3418b1c0:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
3418b1c2:	2300      	movs	r3, #0
3418b1c4:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
3418b1c6:	2300      	movs	r3, #0
3418b1c8:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
3418b1ca:	2300      	movs	r3, #0
3418b1cc:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418b1ce:	687a      	ldr	r2, [r7, #4]
3418b1d0:	683b      	ldr	r3, [r7, #0]
3418b1d2:	2134      	movs	r1, #52	@ 0x34
3418b1d4:	fb01 f303 	mul.w	r3, r1, r3
3418b1d8:	4413      	add	r3, r2
3418b1da:	3348      	adds	r3, #72	@ 0x48
3418b1dc:	681b      	ldr	r3, [r3, #0]
3418b1de:	3b07      	subs	r3, #7
3418b1e0:	2b04      	cmp	r3, #4
3418b1e2:	d86c      	bhi.n	3418b2be <LTDC_SetPredefFormat+0x11e>
3418b1e4:	a201      	add	r2, pc, #4	@ (adr r2, 3418b1ec <LTDC_SetPredefFormat+0x4c>)
3418b1e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3418b1ea:	bf00      	nop
3418b1ec:	3418b201 	.word	0x3418b201
3418b1f0:	3418b227 	.word	0x3418b227
3418b1f4:	3418b24d 	.word	0x3418b24d
3418b1f8:	3418b273 	.word	0x3418b273
3418b1fc:	3418b299 	.word	0x3418b299
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
3418b200:	2302      	movs	r3, #2
3418b202:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
3418b204:	2301      	movs	r3, #1
3418b206:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
3418b208:	230f      	movs	r3, #15
3418b20a:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
3418b20c:	2305      	movs	r3, #5
3418b20e:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
3418b210:	230a      	movs	r3, #10
3418b212:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
3418b214:	2305      	movs	r3, #5
3418b216:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
3418b218:	2305      	movs	r3, #5
3418b21a:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
3418b21c:	2305      	movs	r3, #5
3418b21e:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418b220:	2300      	movs	r3, #0
3418b222:	617b      	str	r3, [r7, #20]
      break;
3418b224:	e04c      	b.n	3418b2c0 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
3418b226:	2302      	movs	r3, #2
3418b228:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3418b22a:	2304      	movs	r3, #4
3418b22c:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
3418b22e:	230c      	movs	r3, #12
3418b230:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3418b232:	2304      	movs	r3, #4
3418b234:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
3418b236:	2308      	movs	r3, #8
3418b238:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3418b23a:	2304      	movs	r3, #4
3418b23c:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
3418b23e:	2304      	movs	r3, #4
3418b240:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3418b242:	2304      	movs	r3, #4
3418b244:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418b246:	2300      	movs	r3, #0
3418b248:	617b      	str	r3, [r7, #20]
      break;
3418b24a:	e039      	b.n	3418b2c0 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
3418b24c:	2301      	movs	r3, #1
3418b24e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
3418b250:	2300      	movs	r3, #0
3418b252:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
3418b254:	2300      	movs	r3, #0
3418b256:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3418b258:	2308      	movs	r3, #8
3418b25a:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418b25c:	2300      	movs	r3, #0
3418b25e:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3418b260:	2308      	movs	r3, #8
3418b262:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418b264:	2300      	movs	r3, #0
3418b266:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3418b268:	2308      	movs	r3, #8
3418b26a:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418b26c:	2300      	movs	r3, #0
3418b26e:	617b      	str	r3, [r7, #20]
      break;
3418b270:	e026      	b.n	3418b2c0 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
3418b272:	2301      	movs	r3, #1
3418b274:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3418b276:	2304      	movs	r3, #4
3418b278:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
3418b27a:	2304      	movs	r3, #4
3418b27c:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3418b27e:	2304      	movs	r3, #4
3418b280:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418b282:	2300      	movs	r3, #0
3418b284:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3418b286:	2304      	movs	r3, #4
3418b288:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418b28a:	2300      	movs	r3, #0
3418b28c:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3418b28e:	2304      	movs	r3, #4
3418b290:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418b292:	2300      	movs	r3, #0
3418b294:	617b      	str	r3, [r7, #20]
      break;
3418b296:	e013      	b.n	3418b2c0 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
3418b298:	2302      	movs	r3, #2
3418b29a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
3418b29c:	2308      	movs	r3, #8
3418b29e:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
3418b2a0:	2308      	movs	r3, #8
3418b2a2:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3418b2a4:	2308      	movs	r3, #8
3418b2a6:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418b2a8:	2300      	movs	r3, #0
3418b2aa:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3418b2ac:	2308      	movs	r3, #8
3418b2ae:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418b2b0:	2300      	movs	r3, #0
3418b2b2:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3418b2b4:	2308      	movs	r3, #8
3418b2b6:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418b2b8:	2300      	movs	r3, #0
3418b2ba:	617b      	str	r3, [r7, #20]
      break;
3418b2bc:	e000      	b.n	3418b2c0 <LTDC_SetPredefFormat+0x120>
    default:
      break;
3418b2be:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418b2c0:	687a      	ldr	r2, [r7, #4]
3418b2c2:	683b      	ldr	r3, [r7, #0]
3418b2c4:	2134      	movs	r1, #52	@ 0x34
3418b2c6:	fb01 f303 	mul.w	r3, r1, r3
3418b2ca:	4413      	add	r3, r2
3418b2cc:	3348      	adds	r3, #72	@ 0x48
3418b2ce:	681b      	ldr	r3, [r3, #0]
3418b2d0:	2b06      	cmp	r3, #6
3418b2d2:	d903      	bls.n	3418b2dc <LTDC_SetPredefFormat+0x13c>
3418b2d4:	3b07      	subs	r3, #7
3418b2d6:	2b04      	cmp	r3, #4
3418b2d8:	d860      	bhi.n	3418b39c <LTDC_SetPredefFormat+0x1fc>
3418b2da:	e028      	b.n	3418b32e <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3418b2dc:	687b      	ldr	r3, [r7, #4]
3418b2de:	681b      	ldr	r3, [r3, #0]
3418b2e0:	461a      	mov	r2, r3
3418b2e2:	683b      	ldr	r3, [r7, #0]
3418b2e4:	021b      	lsls	r3, r3, #8
3418b2e6:	4413      	add	r3, r2
3418b2e8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b2ec:	4618      	mov	r0, r3
3418b2ee:	687a      	ldr	r2, [r7, #4]
3418b2f0:	683b      	ldr	r3, [r7, #0]
3418b2f2:	2134      	movs	r1, #52	@ 0x34
3418b2f4:	fb01 f303 	mul.w	r3, r1, r3
3418b2f8:	4413      	add	r3, r2
3418b2fa:	3348      	adds	r3, #72	@ 0x48
3418b2fc:	681b      	ldr	r3, [r3, #0]
3418b2fe:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
3418b300:	687b      	ldr	r3, [r7, #4]
3418b302:	681b      	ldr	r3, [r3, #0]
3418b304:	461a      	mov	r2, r3
3418b306:	683b      	ldr	r3, [r7, #0]
3418b308:	021b      	lsls	r3, r3, #8
3418b30a:	4413      	add	r3, r2
3418b30c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b310:	461a      	mov	r2, r3
3418b312:	2300      	movs	r3, #0
3418b314:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
3418b316:	687b      	ldr	r3, [r7, #4]
3418b318:	681b      	ldr	r3, [r3, #0]
3418b31a:	461a      	mov	r2, r3
3418b31c:	683b      	ldr	r3, [r7, #0]
3418b31e:	021b      	lsls	r3, r3, #8
3418b320:	4413      	add	r3, r2
3418b322:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b326:	461a      	mov	r2, r3
3418b328:	2300      	movs	r3, #0
3418b32a:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
3418b32c:	e037      	b.n	3418b39e <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
3418b32e:	687b      	ldr	r3, [r7, #4]
3418b330:	681b      	ldr	r3, [r3, #0]
3418b332:	461a      	mov	r2, r3
3418b334:	683b      	ldr	r3, [r7, #0]
3418b336:	021b      	lsls	r3, r3, #8
3418b338:	4413      	add	r3, r2
3418b33a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b33e:	461a      	mov	r2, r3
3418b340:	2307      	movs	r3, #7
3418b342:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418b344:	6a3b      	ldr	r3, [r7, #32]
3418b346:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3418b348:	69fb      	ldr	r3, [r7, #28]
3418b34a:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418b34c:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3418b34e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b350:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3418b352:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418b354:	687b      	ldr	r3, [r7, #4]
3418b356:	681b      	ldr	r3, [r3, #0]
3418b358:	4619      	mov	r1, r3
3418b35a:	683b      	ldr	r3, [r7, #0]
3418b35c:	021b      	lsls	r3, r3, #8
3418b35e:	440b      	add	r3, r1
3418b360:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b364:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3418b366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418b368:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418b36a:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418b36c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418b36e:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3418b370:	69bb      	ldr	r3, [r7, #24]
3418b372:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418b374:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3418b376:	697b      	ldr	r3, [r7, #20]
3418b378:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3418b37a:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3418b37c:	693b      	ldr	r3, [r7, #16]
3418b37e:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3418b380:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418b382:	687b      	ldr	r3, [r7, #4]
3418b384:	681b      	ldr	r3, [r3, #0]
3418b386:	4619      	mov	r1, r3
3418b388:	683b      	ldr	r3, [r7, #0]
3418b38a:	021b      	lsls	r3, r3, #8
3418b38c:	440b      	add	r3, r1
3418b38e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b392:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3418b394:	68fb      	ldr	r3, [r7, #12]
3418b396:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418b398:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
3418b39a:	e000      	b.n	3418b39e <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
3418b39c:	bf00      	nop
  }
}
3418b39e:	bf00      	nop
3418b3a0:	3734      	adds	r7, #52	@ 0x34
3418b3a2:	46bd      	mov	sp, r7
3418b3a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b3a8:	4770      	bx	lr
3418b3aa:	bf00      	nop

3418b3ac <HAL_PWR_ConfigAttributes>:
  * @param  Attributes : Specifies the available attribute(s).
  *                      This parameter can be one of PWR_ATTRIBUTES.
  * @retval None.
  */
void HAL_PWR_ConfigAttributes(uint32_t Item, uint32_t Attributes)
{
3418b3ac:	b480      	push	{r7}
3418b3ae:	b083      	sub	sp, #12
3418b3b0:	af00      	add	r7, sp, #0
3418b3b2:	6078      	str	r0, [r7, #4]
3418b3b4:	6039      	str	r1, [r7, #0]
  assert_param(IS_PWR_ITEMS_ATTRIBUTES(Item));
  assert_param(IS_PWR_ATTRIBUTES(Attributes));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Secure item management (TZEN = 1) */
  if ((Attributes & PWR_ITEM_ATTR_SEC_PRIV_MASK) == PWR_ITEM_ATTR_SEC_PRIV_MASK)
3418b3b6:	683b      	ldr	r3, [r7, #0]
3418b3b8:	f003 0320 	and.w	r3, r3, #32
3418b3bc:	2b00      	cmp	r3, #0
3418b3be:	d01f      	beq.n	3418b400 <HAL_PWR_ConfigAttributes+0x54>
  {
    /* Privilege item management */
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
3418b3c0:	683b      	ldr	r3, [r7, #0]
3418b3c2:	f003 0322 	and.w	r3, r3, #34	@ 0x22
3418b3c6:	2b22      	cmp	r3, #34	@ 0x22
3418b3c8:	d10c      	bne.n	3418b3e4 <HAL_PWR_ConfigAttributes+0x38>
    {
      SET_BIT(PWR_S->SECCFGR, Item);
3418b3ca:	4b21      	ldr	r3, [pc, #132]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3cc:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418b3ce:	4920      	ldr	r1, [pc, #128]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3d0:	687b      	ldr	r3, [r7, #4]
3418b3d2:	4313      	orrs	r3, r2
3418b3d4:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3418b3d6:	4b1e      	ldr	r3, [pc, #120]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3d8:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418b3da:	491d      	ldr	r1, [pc, #116]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3dc:	687b      	ldr	r3, [r7, #4]
3418b3de:	4313      	orrs	r3, r2
3418b3e0:	674b      	str	r3, [r1, #116]	@ 0x74
    {
      CLEAR_BIT(PWR->PRIVCFGR, Item);
    }
  }
#endif /* __ARM_FEATURE_CMSE */
}
3418b3e2:	e02e      	b.n	3418b442 <HAL_PWR_ConfigAttributes+0x96>
      SET_BIT(PWR_S->SECCFGR, Item);
3418b3e4:	4b1a      	ldr	r3, [pc, #104]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3e6:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418b3e8:	4919      	ldr	r1, [pc, #100]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3ea:	687b      	ldr	r3, [r7, #4]
3418b3ec:	4313      	orrs	r3, r2
3418b3ee:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3418b3f0:	4b17      	ldr	r3, [pc, #92]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3f2:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418b3f4:	687b      	ldr	r3, [r7, #4]
3418b3f6:	43db      	mvns	r3, r3
3418b3f8:	4915      	ldr	r1, [pc, #84]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b3fa:	4013      	ands	r3, r2
3418b3fc:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418b3fe:	e020      	b.n	3418b442 <HAL_PWR_ConfigAttributes+0x96>
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
3418b400:	683b      	ldr	r3, [r7, #0]
3418b402:	f003 0311 	and.w	r3, r3, #17
3418b406:	2b11      	cmp	r3, #17
3418b408:	d10d      	bne.n	3418b426 <HAL_PWR_ConfigAttributes+0x7a>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3418b40a:	4b11      	ldr	r3, [pc, #68]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b40c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418b40e:	687b      	ldr	r3, [r7, #4]
3418b410:	43db      	mvns	r3, r3
3418b412:	490f      	ldr	r1, [pc, #60]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b414:	4013      	ands	r3, r2
3418b416:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3418b418:	4b0d      	ldr	r3, [pc, #52]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b41a:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418b41c:	490c      	ldr	r1, [pc, #48]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b41e:	687b      	ldr	r3, [r7, #4]
3418b420:	4313      	orrs	r3, r2
3418b422:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418b424:	e00d      	b.n	3418b442 <HAL_PWR_ConfigAttributes+0x96>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3418b426:	4b0a      	ldr	r3, [pc, #40]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b428:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418b42a:	687b      	ldr	r3, [r7, #4]
3418b42c:	43db      	mvns	r3, r3
3418b42e:	4908      	ldr	r1, [pc, #32]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b430:	4013      	ands	r3, r2
3418b432:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3418b434:	4b06      	ldr	r3, [pc, #24]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b436:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418b438:	687b      	ldr	r3, [r7, #4]
3418b43a:	43db      	mvns	r3, r3
3418b43c:	4904      	ldr	r1, [pc, #16]	@ (3418b450 <HAL_PWR_ConfigAttributes+0xa4>)
3418b43e:	4013      	ands	r3, r2
3418b440:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418b442:	bf00      	nop
3418b444:	370c      	adds	r7, #12
3418b446:	46bd      	mov	sp, r7
3418b448:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b44c:	4770      	bx	lr
3418b44e:	bf00      	nop
3418b450:	56024800 	.word	0x56024800

3418b454 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
3418b454:	b580      	push	{r7, lr}
3418b456:	b084      	sub	sp, #16
3418b458:	af00      	add	r7, sp, #0
3418b45a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
3418b45c:	4b10      	ldr	r3, [pc, #64]	@ (3418b4a0 <HAL_PWREx_ConfigSupply+0x4c>)
3418b45e:	681b      	ldr	r3, [r3, #0]
3418b460:	f023 0204 	bic.w	r2, r3, #4
3418b464:	490e      	ldr	r1, [pc, #56]	@ (3418b4a0 <HAL_PWREx_ConfigSupply+0x4c>)
3418b466:	687b      	ldr	r3, [r7, #4]
3418b468:	4313      	orrs	r3, r2
3418b46a:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
3418b46c:	f7f9 ff70 	bl	34185350 <HAL_GetTick>
3418b470:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3418b472:	e009      	b.n	3418b488 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
3418b474:	f7f9 ff6c 	bl	34185350 <HAL_GetTick>
3418b478:	4602      	mov	r2, r0
3418b47a:	68fb      	ldr	r3, [r7, #12]
3418b47c:	1ad3      	subs	r3, r2, r3
3418b47e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
3418b482:	d901      	bls.n	3418b488 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
3418b484:	2301      	movs	r3, #1
3418b486:	e006      	b.n	3418b496 <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3418b488:	4b05      	ldr	r3, [pc, #20]	@ (3418b4a0 <HAL_PWREx_ConfigSupply+0x4c>)
3418b48a:	6a1b      	ldr	r3, [r3, #32]
3418b48c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418b490:	2b00      	cmp	r3, #0
3418b492:	d0ef      	beq.n	3418b474 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
3418b494:	2300      	movs	r3, #0
}
3418b496:	4618      	mov	r0, r3
3418b498:	3710      	adds	r7, #16
3418b49a:	46bd      	mov	sp, r7
3418b49c:	bd80      	pop	{r7, pc}
3418b49e:	bf00      	nop
3418b4a0:	56024800 	.word	0x56024800

3418b4a4 <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
3418b4a4:	b480      	push	{r7}
3418b4a6:	b083      	sub	sp, #12
3418b4a8:	af00      	add	r7, sp, #0
3418b4aa:	6078      	str	r0, [r7, #4]
3418b4ac:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));

  switch (VddIOPort)
3418b4ae:	687b      	ldr	r3, [r7, #4]
3418b4b0:	2b04      	cmp	r3, #4
3418b4b2:	d83f      	bhi.n	3418b534 <HAL_PWREx_ConfigVddIORange+0x90>
3418b4b4:	a201      	add	r2, pc, #4	@ (adr r2, 3418b4bc <HAL_PWREx_ConfigVddIORange+0x18>)
3418b4b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3418b4ba:	bf00      	nop
3418b4bc:	3418b4d1 	.word	0x3418b4d1
3418b4c0:	3418b4e5 	.word	0x3418b4e5
3418b4c4:	3418b4f9 	.word	0x3418b4f9
3418b4c8:	3418b50d 	.word	0x3418b50d
3418b4cc:	3418b521 	.word	0x3418b521
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
3418b4d0:	4b1c      	ldr	r3, [pc, #112]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b4d2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418b4d4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418b4d8:	683b      	ldr	r3, [r7, #0]
3418b4da:	061b      	lsls	r3, r3, #24
3418b4dc:	4919      	ldr	r1, [pc, #100]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b4de:	4313      	orrs	r3, r2
3418b4e0:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418b4e2:	e028      	b.n	3418b536 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
3418b4e4:	4b17      	ldr	r3, [pc, #92]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b4e6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418b4e8:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
3418b4ec:	683b      	ldr	r3, [r7, #0]
3418b4ee:	065b      	lsls	r3, r3, #25
3418b4f0:	4914      	ldr	r1, [pc, #80]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b4f2:	4313      	orrs	r3, r2
3418b4f4:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418b4f6:	e01e      	b.n	3418b536 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3418b4f8:	4b12      	ldr	r3, [pc, #72]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b4fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418b4fc:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3418b500:	683b      	ldr	r3, [r7, #0]
3418b502:	069b      	lsls	r3, r3, #26
3418b504:	490f      	ldr	r1, [pc, #60]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b506:	4313      	orrs	r3, r2
3418b508:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418b50a:	e014      	b.n	3418b536 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
3418b50c:	4b0d      	ldr	r3, [pc, #52]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b50e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418b510:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418b514:	683b      	ldr	r3, [r7, #0]
3418b516:	061b      	lsls	r3, r3, #24
3418b518:	490a      	ldr	r1, [pc, #40]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b51a:	4313      	orrs	r3, r2
3418b51c:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
3418b51e:	e00a      	b.n	3418b536 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3418b520:	4b08      	ldr	r3, [pc, #32]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b522:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418b524:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418b528:	683b      	ldr	r3, [r7, #0]
3418b52a:	061b      	lsls	r3, r3, #24
3418b52c:	4905      	ldr	r1, [pc, #20]	@ (3418b544 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418b52e:	4313      	orrs	r3, r2
3418b530:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
3418b532:	e000      	b.n	3418b536 <HAL_PWREx_ConfigVddIORange+0x92>

    default:
      break;
3418b534:	bf00      	nop
  }
}
3418b536:	bf00      	nop
3418b538:	370c      	adds	r7, #12
3418b53a:	46bd      	mov	sp, r7
3418b53c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b540:	4770      	bx	lr
3418b542:	bf00      	nop
3418b544:	56024800 	.word	0x56024800

3418b548 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
3418b548:	b480      	push	{r7}
3418b54a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
3418b54c:	4b05      	ldr	r3, [pc, #20]	@ (3418b564 <HAL_PWREx_EnableVddIO2+0x1c>)
3418b54e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418b550:	4a04      	ldr	r2, [pc, #16]	@ (3418b564 <HAL_PWREx_EnableVddIO2+0x1c>)
3418b552:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418b556:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3418b558:	bf00      	nop
3418b55a:	46bd      	mov	sp, r7
3418b55c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b560:	4770      	bx	lr
3418b562:	bf00      	nop
3418b564:	56024800 	.word	0x56024800

3418b568 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
3418b568:	b480      	push	{r7}
3418b56a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
3418b56c:	4b05      	ldr	r3, [pc, #20]	@ (3418b584 <HAL_PWREx_EnableVddIO3+0x1c>)
3418b56e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418b570:	4a04      	ldr	r2, [pc, #16]	@ (3418b584 <HAL_PWREx_EnableVddIO3+0x1c>)
3418b572:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3418b576:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3418b578:	bf00      	nop
3418b57a:	46bd      	mov	sp, r7
3418b57c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b580:	4770      	bx	lr
3418b582:	bf00      	nop
3418b584:	56024800 	.word	0x56024800

3418b588 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
3418b588:	b480      	push	{r7}
3418b58a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
3418b58c:	4b05      	ldr	r3, [pc, #20]	@ (3418b5a4 <HAL_PWREx_EnableVddIO4+0x1c>)
3418b58e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418b590:	4a04      	ldr	r2, [pc, #16]	@ (3418b5a4 <HAL_PWREx_EnableVddIO4+0x1c>)
3418b592:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418b596:	6353      	str	r3, [r2, #52]	@ 0x34
}
3418b598:	bf00      	nop
3418b59a:	46bd      	mov	sp, r7
3418b59c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b5a0:	4770      	bx	lr
3418b5a2:	bf00      	nop
3418b5a4:	56024800 	.word	0x56024800

3418b5a8 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
3418b5a8:	b480      	push	{r7}
3418b5aa:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
3418b5ac:	4b05      	ldr	r3, [pc, #20]	@ (3418b5c4 <HAL_PWREx_EnableVddIO5+0x1c>)
3418b5ae:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418b5b0:	4a04      	ldr	r2, [pc, #16]	@ (3418b5c4 <HAL_PWREx_EnableVddIO5+0x1c>)
3418b5b2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418b5b6:	6393      	str	r3, [r2, #56]	@ 0x38
}
3418b5b8:	bf00      	nop
3418b5ba:	46bd      	mov	sp, r7
3418b5bc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b5c0:	4770      	bx	lr
3418b5c2:	bf00      	nop
3418b5c4:	56024800 	.word	0x56024800

3418b5c8 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
3418b5c8:	b480      	push	{r7}
3418b5ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3418b5cc:	4b06      	ldr	r3, [pc, #24]	@ (3418b5e8 <LL_RCC_HSE_IsReady+0x20>)
3418b5ce:	685b      	ldr	r3, [r3, #4]
3418b5d0:	f003 0310 	and.w	r3, r3, #16
3418b5d4:	2b00      	cmp	r3, #0
3418b5d6:	d001      	beq.n	3418b5dc <LL_RCC_HSE_IsReady+0x14>
3418b5d8:	2301      	movs	r3, #1
3418b5da:	e000      	b.n	3418b5de <LL_RCC_HSE_IsReady+0x16>
3418b5dc:	2300      	movs	r3, #0
}
3418b5de:	4618      	mov	r0, r3
3418b5e0:	46bd      	mov	sp, r7
3418b5e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b5e6:	4770      	bx	lr
3418b5e8:	56028000 	.word	0x56028000

3418b5ec <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
3418b5ec:	b480      	push	{r7}
3418b5ee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3418b5f0:	4b04      	ldr	r3, [pc, #16]	@ (3418b604 <LL_RCC_HSI_Enable+0x18>)
3418b5f2:	2208      	movs	r2, #8
3418b5f4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418b5f8:	bf00      	nop
3418b5fa:	46bd      	mov	sp, r7
3418b5fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b600:	4770      	bx	lr
3418b602:	bf00      	nop
3418b604:	56028000 	.word	0x56028000

3418b608 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
3418b608:	b480      	push	{r7}
3418b60a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
3418b60c:	4b05      	ldr	r3, [pc, #20]	@ (3418b624 <LL_RCC_HSI_Disable+0x1c>)
3418b60e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418b612:	461a      	mov	r2, r3
3418b614:	2308      	movs	r3, #8
3418b616:	6013      	str	r3, [r2, #0]
}
3418b618:	bf00      	nop
3418b61a:	46bd      	mov	sp, r7
3418b61c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b620:	4770      	bx	lr
3418b622:	bf00      	nop
3418b624:	56028000 	.word	0x56028000

3418b628 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
3418b628:	b480      	push	{r7}
3418b62a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418b62c:	4b06      	ldr	r3, [pc, #24]	@ (3418b648 <LL_RCC_HSI_IsReady+0x20>)
3418b62e:	685b      	ldr	r3, [r3, #4]
3418b630:	f003 0308 	and.w	r3, r3, #8
3418b634:	2b00      	cmp	r3, #0
3418b636:	d001      	beq.n	3418b63c <LL_RCC_HSI_IsReady+0x14>
3418b638:	2301      	movs	r3, #1
3418b63a:	e000      	b.n	3418b63e <LL_RCC_HSI_IsReady+0x16>
3418b63c:	2300      	movs	r3, #0
}
3418b63e:	4618      	mov	r0, r3
3418b640:	46bd      	mov	sp, r7
3418b642:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b646:	4770      	bx	lr
3418b648:	56028000 	.word	0x56028000

3418b64c <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
3418b64c:	b480      	push	{r7}
3418b64e:	b083      	sub	sp, #12
3418b650:	af00      	add	r7, sp, #0
3418b652:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
3418b654:	4b06      	ldr	r3, [pc, #24]	@ (3418b670 <LL_RCC_HSI_SetDivider+0x24>)
3418b656:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418b658:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
3418b65c:	4904      	ldr	r1, [pc, #16]	@ (3418b670 <LL_RCC_HSI_SetDivider+0x24>)
3418b65e:	687b      	ldr	r3, [r7, #4]
3418b660:	4313      	orrs	r3, r2
3418b662:	648b      	str	r3, [r1, #72]	@ 0x48
}
3418b664:	bf00      	nop
3418b666:	370c      	adds	r7, #12
3418b668:	46bd      	mov	sp, r7
3418b66a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b66e:	4770      	bx	lr
3418b670:	56028000 	.word	0x56028000

3418b674 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
3418b674:	b480      	push	{r7}
3418b676:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418b678:	4b04      	ldr	r3, [pc, #16]	@ (3418b68c <LL_RCC_HSI_GetDivider+0x18>)
3418b67a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418b67c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418b680:	4618      	mov	r0, r3
3418b682:	46bd      	mov	sp, r7
3418b684:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b688:	4770      	bx	lr
3418b68a:	bf00      	nop
3418b68c:	56028000 	.word	0x56028000

3418b690 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
3418b690:	b480      	push	{r7}
3418b692:	b083      	sub	sp, #12
3418b694:	af00      	add	r7, sp, #0
3418b696:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
3418b698:	4b07      	ldr	r3, [pc, #28]	@ (3418b6b8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3418b69a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418b69c:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
3418b6a0:	687b      	ldr	r3, [r7, #4]
3418b6a2:	041b      	lsls	r3, r3, #16
3418b6a4:	4904      	ldr	r1, [pc, #16]	@ (3418b6b8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3418b6a6:	4313      	orrs	r3, r2
3418b6a8:	648b      	str	r3, [r1, #72]	@ 0x48
}
3418b6aa:	bf00      	nop
3418b6ac:	370c      	adds	r7, #12
3418b6ae:	46bd      	mov	sp, r7
3418b6b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b6b4:	4770      	bx	lr
3418b6b6:	bf00      	nop
3418b6b8:	56028000 	.word	0x56028000

3418b6bc <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
3418b6bc:	b480      	push	{r7}
3418b6be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3418b6c0:	4b04      	ldr	r3, [pc, #16]	@ (3418b6d4 <LL_RCC_MSI_Enable+0x18>)
3418b6c2:	2204      	movs	r2, #4
3418b6c4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418b6c8:	bf00      	nop
3418b6ca:	46bd      	mov	sp, r7
3418b6cc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b6d0:	4770      	bx	lr
3418b6d2:	bf00      	nop
3418b6d4:	56028000 	.word	0x56028000

3418b6d8 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
3418b6d8:	b480      	push	{r7}
3418b6da:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
3418b6dc:	4b05      	ldr	r3, [pc, #20]	@ (3418b6f4 <LL_RCC_MSI_Disable+0x1c>)
3418b6de:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418b6e2:	461a      	mov	r2, r3
3418b6e4:	2304      	movs	r3, #4
3418b6e6:	6013      	str	r3, [r2, #0]
}
3418b6e8:	bf00      	nop
3418b6ea:	46bd      	mov	sp, r7
3418b6ec:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b6f0:	4770      	bx	lr
3418b6f2:	bf00      	nop
3418b6f4:	56028000 	.word	0x56028000

3418b6f8 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
3418b6f8:	b480      	push	{r7}
3418b6fa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3418b6fc:	4b06      	ldr	r3, [pc, #24]	@ (3418b718 <LL_RCC_MSI_IsReady+0x20>)
3418b6fe:	685b      	ldr	r3, [r3, #4]
3418b700:	f003 0304 	and.w	r3, r3, #4
3418b704:	2b00      	cmp	r3, #0
3418b706:	d001      	beq.n	3418b70c <LL_RCC_MSI_IsReady+0x14>
3418b708:	2301      	movs	r3, #1
3418b70a:	e000      	b.n	3418b70e <LL_RCC_MSI_IsReady+0x16>
3418b70c:	2300      	movs	r3, #0
}
3418b70e:	4618      	mov	r0, r3
3418b710:	46bd      	mov	sp, r7
3418b712:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b716:	4770      	bx	lr
3418b718:	56028000 	.word	0x56028000

3418b71c <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
3418b71c:	b480      	push	{r7}
3418b71e:	b083      	sub	sp, #12
3418b720:	af00      	add	r7, sp, #0
3418b722:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3418b724:	4b06      	ldr	r3, [pc, #24]	@ (3418b740 <LL_RCC_MSI_SetFrequency+0x24>)
3418b726:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b728:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3418b72c:	4904      	ldr	r1, [pc, #16]	@ (3418b740 <LL_RCC_MSI_SetFrequency+0x24>)
3418b72e:	687b      	ldr	r3, [r7, #4]
3418b730:	4313      	orrs	r3, r2
3418b732:	644b      	str	r3, [r1, #68]	@ 0x44
}
3418b734:	bf00      	nop
3418b736:	370c      	adds	r7, #12
3418b738:	46bd      	mov	sp, r7
3418b73a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b73e:	4770      	bx	lr
3418b740:	56028000 	.word	0x56028000

3418b744 <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
3418b744:	b480      	push	{r7}
3418b746:	b083      	sub	sp, #12
3418b748:	af00      	add	r7, sp, #0
3418b74a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
3418b74c:	4b07      	ldr	r3, [pc, #28]	@ (3418b76c <LL_RCC_MSI_SetCalibTrimming+0x28>)
3418b74e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b750:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
3418b754:	687b      	ldr	r3, [r7, #4]
3418b756:	041b      	lsls	r3, r3, #16
3418b758:	4904      	ldr	r1, [pc, #16]	@ (3418b76c <LL_RCC_MSI_SetCalibTrimming+0x28>)
3418b75a:	4313      	orrs	r3, r2
3418b75c:	644b      	str	r3, [r1, #68]	@ 0x44
}
3418b75e:	bf00      	nop
3418b760:	370c      	adds	r7, #12
3418b762:	46bd      	mov	sp, r7
3418b764:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b768:	4770      	bx	lr
3418b76a:	bf00      	nop
3418b76c:	56028000 	.word	0x56028000

3418b770 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
3418b770:	b480      	push	{r7}
3418b772:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418b774:	4b06      	ldr	r3, [pc, #24]	@ (3418b790 <LL_RCC_LSE_IsReady+0x20>)
3418b776:	685b      	ldr	r3, [r3, #4]
3418b778:	f003 0302 	and.w	r3, r3, #2
3418b77c:	2b00      	cmp	r3, #0
3418b77e:	d001      	beq.n	3418b784 <LL_RCC_LSE_IsReady+0x14>
3418b780:	2301      	movs	r3, #1
3418b782:	e000      	b.n	3418b786 <LL_RCC_LSE_IsReady+0x16>
3418b784:	2300      	movs	r3, #0
}
3418b786:	4618      	mov	r0, r3
3418b788:	46bd      	mov	sp, r7
3418b78a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b78e:	4770      	bx	lr
3418b790:	56028000 	.word	0x56028000

3418b794 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
3418b794:	b480      	push	{r7}
3418b796:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
3418b798:	4b04      	ldr	r3, [pc, #16]	@ (3418b7ac <LL_RCC_LSI_Enable+0x18>)
3418b79a:	2201      	movs	r2, #1
3418b79c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418b7a0:	bf00      	nop
3418b7a2:	46bd      	mov	sp, r7
3418b7a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b7a8:	4770      	bx	lr
3418b7aa:	bf00      	nop
3418b7ac:	56028000 	.word	0x56028000

3418b7b0 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
3418b7b0:	b480      	push	{r7}
3418b7b2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3418b7b4:	4b05      	ldr	r3, [pc, #20]	@ (3418b7cc <LL_RCC_LSI_Disable+0x1c>)
3418b7b6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418b7ba:	461a      	mov	r2, r3
3418b7bc:	2301      	movs	r3, #1
3418b7be:	6013      	str	r3, [r2, #0]
}
3418b7c0:	bf00      	nop
3418b7c2:	46bd      	mov	sp, r7
3418b7c4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b7c8:	4770      	bx	lr
3418b7ca:	bf00      	nop
3418b7cc:	56028000 	.word	0x56028000

3418b7d0 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
3418b7d0:	b480      	push	{r7}
3418b7d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418b7d4:	4b04      	ldr	r3, [pc, #16]	@ (3418b7e8 <LL_RCC_LSI_IsReady+0x18>)
3418b7d6:	685b      	ldr	r3, [r3, #4]
3418b7d8:	f003 0301 	and.w	r3, r3, #1
}
3418b7dc:	4618      	mov	r0, r3
3418b7de:	46bd      	mov	sp, r7
3418b7e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b7e4:	4770      	bx	lr
3418b7e6:	bf00      	nop
3418b7e8:	56028000 	.word	0x56028000

3418b7ec <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
3418b7ec:	b480      	push	{r7}
3418b7ee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3418b7f0:	4b04      	ldr	r3, [pc, #16]	@ (3418b804 <LL_RCC_GetCpuClkSource+0x18>)
3418b7f2:	6a1b      	ldr	r3, [r3, #32]
3418b7f4:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3418b7f8:	4618      	mov	r0, r3
3418b7fa:	46bd      	mov	sp, r7
3418b7fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b800:	4770      	bx	lr
3418b802:	bf00      	nop
3418b804:	56028000 	.word	0x56028000

3418b808 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
3418b808:	b480      	push	{r7}
3418b80a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3418b80c:	4b04      	ldr	r3, [pc, #16]	@ (3418b820 <LL_RCC_GetSysClkSource+0x18>)
3418b80e:	6a1b      	ldr	r3, [r3, #32]
3418b810:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418b814:	4618      	mov	r0, r3
3418b816:	46bd      	mov	sp, r7
3418b818:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b81c:	4770      	bx	lr
3418b81e:	bf00      	nop
3418b820:	56028000 	.word	0x56028000

3418b824 <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_AHB_DIV_32
  *         @arg @ref LL_RCC_AHB_DIV_64
  *         @arg @ref LL_RCC_AHB_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
3418b824:	b480      	push	{r7}
3418b826:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3418b828:	4b04      	ldr	r3, [pc, #16]	@ (3418b83c <LL_RCC_GetAHBPrescaler+0x18>)
3418b82a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418b82c:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3418b830:	4618      	mov	r0, r3
3418b832:	46bd      	mov	sp, r7
3418b834:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b838:	4770      	bx	lr
3418b83a:	bf00      	nop
3418b83c:	56028000 	.word	0x56028000

3418b840 <LL_RCC_GetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_32
  *         @arg @ref LL_RCC_APB1_DIV_64
  *         @arg @ref LL_RCC_APB1_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
3418b840:	b480      	push	{r7}
3418b842:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418b844:	4b04      	ldr	r3, [pc, #16]	@ (3418b858 <LL_RCC_GetAPB1Prescaler+0x18>)
3418b846:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418b848:	f003 0307 	and.w	r3, r3, #7
}
3418b84c:	4618      	mov	r0, r3
3418b84e:	46bd      	mov	sp, r7
3418b850:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b854:	4770      	bx	lr
3418b856:	bf00      	nop
3418b858:	56028000 	.word	0x56028000

3418b85c <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
3418b85c:	b480      	push	{r7}
3418b85e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3418b860:	4b04      	ldr	r3, [pc, #16]	@ (3418b874 <LL_RCC_PLL1_GetSource+0x18>)
3418b862:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418b866:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418b86a:	4618      	mov	r0, r3
3418b86c:	46bd      	mov	sp, r7
3418b86e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b872:	4770      	bx	lr
3418b874:	56028000 	.word	0x56028000

3418b878 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
3418b878:	b480      	push	{r7}
3418b87a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3418b87c:	4b07      	ldr	r3, [pc, #28]	@ (3418b89c <LL_RCC_PLL1_IsReady+0x24>)
3418b87e:	685b      	ldr	r3, [r3, #4]
3418b880:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418b884:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418b888:	d101      	bne.n	3418b88e <LL_RCC_PLL1_IsReady+0x16>
3418b88a:	2301      	movs	r3, #1
3418b88c:	e000      	b.n	3418b890 <LL_RCC_PLL1_IsReady+0x18>
3418b88e:	2300      	movs	r3, #0
}
3418b890:	4618      	mov	r0, r3
3418b892:	46bd      	mov	sp, r7
3418b894:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b898:	4770      	bx	lr
3418b89a:	bf00      	nop
3418b89c:	56028000 	.word	0x56028000

3418b8a0 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
3418b8a0:	b480      	push	{r7}
3418b8a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3418b8a4:	4b07      	ldr	r3, [pc, #28]	@ (3418b8c4 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3418b8a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418b8aa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418b8ae:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418b8b2:	d101      	bne.n	3418b8b8 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3418b8b4:	2301      	movs	r3, #1
3418b8b6:	e000      	b.n	3418b8ba <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3418b8b8:	2300      	movs	r3, #0
}
3418b8ba:	4618      	mov	r0, r3
3418b8bc:	46bd      	mov	sp, r7
3418b8be:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b8c2:	4770      	bx	lr
3418b8c4:	56028000 	.word	0x56028000

3418b8c8 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
3418b8c8:	b480      	push	{r7}
3418b8ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418b8cc:	4b04      	ldr	r3, [pc, #16]	@ (3418b8e0 <LL_RCC_PLL2_GetSource+0x18>)
3418b8ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418b8d2:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418b8d6:	4618      	mov	r0, r3
3418b8d8:	46bd      	mov	sp, r7
3418b8da:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b8de:	4770      	bx	lr
3418b8e0:	56028000 	.word	0x56028000

3418b8e4 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
3418b8e4:	b480      	push	{r7}
3418b8e6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3418b8e8:	4b07      	ldr	r3, [pc, #28]	@ (3418b908 <LL_RCC_PLL2_IsReady+0x24>)
3418b8ea:	685b      	ldr	r3, [r3, #4]
3418b8ec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418b8f0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418b8f4:	d101      	bne.n	3418b8fa <LL_RCC_PLL2_IsReady+0x16>
3418b8f6:	2301      	movs	r3, #1
3418b8f8:	e000      	b.n	3418b8fc <LL_RCC_PLL2_IsReady+0x18>
3418b8fa:	2300      	movs	r3, #0
}
3418b8fc:	4618      	mov	r0, r3
3418b8fe:	46bd      	mov	sp, r7
3418b900:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b904:	4770      	bx	lr
3418b906:	bf00      	nop
3418b908:	56028000 	.word	0x56028000

3418b90c <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
3418b90c:	b480      	push	{r7}
3418b90e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3418b910:	4b07      	ldr	r3, [pc, #28]	@ (3418b930 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418b912:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418b916:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418b91a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418b91e:	d101      	bne.n	3418b924 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3418b920:	2301      	movs	r3, #1
3418b922:	e000      	b.n	3418b926 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418b924:	2300      	movs	r3, #0
}
3418b926:	4618      	mov	r0, r3
3418b928:	46bd      	mov	sp, r7
3418b92a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b92e:	4770      	bx	lr
3418b930:	56028000 	.word	0x56028000

3418b934 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3418b934:	b480      	push	{r7}
3418b936:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3418b938:	4b04      	ldr	r3, [pc, #16]	@ (3418b94c <LL_RCC_PLL3_GetSource+0x18>)
3418b93a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418b93e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418b942:	4618      	mov	r0, r3
3418b944:	46bd      	mov	sp, r7
3418b946:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b94a:	4770      	bx	lr
3418b94c:	56028000 	.word	0x56028000

3418b950 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
3418b950:	b480      	push	{r7}
3418b952:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418b954:	4b07      	ldr	r3, [pc, #28]	@ (3418b974 <LL_RCC_PLL3_IsReady+0x24>)
3418b956:	685b      	ldr	r3, [r3, #4]
3418b958:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418b95c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3418b960:	d101      	bne.n	3418b966 <LL_RCC_PLL3_IsReady+0x16>
3418b962:	2301      	movs	r3, #1
3418b964:	e000      	b.n	3418b968 <LL_RCC_PLL3_IsReady+0x18>
3418b966:	2300      	movs	r3, #0
}
3418b968:	4618      	mov	r0, r3
3418b96a:	46bd      	mov	sp, r7
3418b96c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b970:	4770      	bx	lr
3418b972:	bf00      	nop
3418b974:	56028000 	.word	0x56028000

3418b978 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
3418b978:	b480      	push	{r7}
3418b97a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3418b97c:	4b07      	ldr	r3, [pc, #28]	@ (3418b99c <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3418b97e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418b982:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418b986:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418b98a:	d101      	bne.n	3418b990 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3418b98c:	2301      	movs	r3, #1
3418b98e:	e000      	b.n	3418b992 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3418b990:	2300      	movs	r3, #0
}
3418b992:	4618      	mov	r0, r3
3418b994:	46bd      	mov	sp, r7
3418b996:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b99a:	4770      	bx	lr
3418b99c:	56028000 	.word	0x56028000

3418b9a0 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
3418b9a0:	b480      	push	{r7}
3418b9a2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3418b9a4:	4b04      	ldr	r3, [pc, #16]	@ (3418b9b8 <LL_RCC_PLL4_GetSource+0x18>)
3418b9a6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418b9aa:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418b9ae:	4618      	mov	r0, r3
3418b9b0:	46bd      	mov	sp, r7
3418b9b2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b9b6:	4770      	bx	lr
3418b9b8:	56028000 	.word	0x56028000

3418b9bc <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
3418b9bc:	b480      	push	{r7}
3418b9be:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418b9c0:	4b07      	ldr	r3, [pc, #28]	@ (3418b9e0 <LL_RCC_PLL4_IsReady+0x24>)
3418b9c2:	685b      	ldr	r3, [r3, #4]
3418b9c4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418b9c8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418b9cc:	d101      	bne.n	3418b9d2 <LL_RCC_PLL4_IsReady+0x16>
3418b9ce:	2301      	movs	r3, #1
3418b9d0:	e000      	b.n	3418b9d4 <LL_RCC_PLL4_IsReady+0x18>
3418b9d2:	2300      	movs	r3, #0
}
3418b9d4:	4618      	mov	r0, r3
3418b9d6:	46bd      	mov	sp, r7
3418b9d8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b9dc:	4770      	bx	lr
3418b9de:	bf00      	nop
3418b9e0:	56028000 	.word	0x56028000

3418b9e4 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
3418b9e4:	b480      	push	{r7}
3418b9e6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3418b9e8:	4b07      	ldr	r3, [pc, #28]	@ (3418ba08 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3418b9ea:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418b9ee:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418b9f2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418b9f6:	d101      	bne.n	3418b9fc <LL_RCC_PLL4_IsEnabledBypass+0x18>
3418b9f8:	2301      	movs	r3, #1
3418b9fa:	e000      	b.n	3418b9fe <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3418b9fc:	2300      	movs	r3, #0
}
3418b9fe:	4618      	mov	r0, r3
3418ba00:	46bd      	mov	sp, r7
3418ba02:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba06:	4770      	bx	lr
3418ba08:	56028000 	.word	0x56028000

3418ba0c <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
3418ba0c:	b480      	push	{r7}
3418ba0e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
3418ba10:	4b04      	ldr	r3, [pc, #16]	@ (3418ba24 <LL_RCC_IC1_Enable+0x18>)
3418ba12:	2201      	movs	r2, #1
3418ba14:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418ba18:	bf00      	nop
3418ba1a:	46bd      	mov	sp, r7
3418ba1c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba20:	4770      	bx	lr
3418ba22:	bf00      	nop
3418ba24:	56028000 	.word	0x56028000

3418ba28 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
3418ba28:	b480      	push	{r7}
3418ba2a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3418ba2c:	4b04      	ldr	r3, [pc, #16]	@ (3418ba40 <LL_RCC_IC1_GetSource+0x18>)
3418ba2e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418ba32:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ba36:	4618      	mov	r0, r3
3418ba38:	46bd      	mov	sp, r7
3418ba3a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba3e:	4770      	bx	lr
3418ba40:	56028000 	.word	0x56028000

3418ba44 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3418ba44:	b480      	push	{r7}
3418ba46:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3418ba48:	4b05      	ldr	r3, [pc, #20]	@ (3418ba60 <LL_RCC_IC1_GetDivider+0x1c>)
3418ba4a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418ba4e:	0c1b      	lsrs	r3, r3, #16
3418ba50:	b2db      	uxtb	r3, r3
3418ba52:	3301      	adds	r3, #1
}
3418ba54:	4618      	mov	r0, r3
3418ba56:	46bd      	mov	sp, r7
3418ba58:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba5c:	4770      	bx	lr
3418ba5e:	bf00      	nop
3418ba60:	56028000 	.word	0x56028000

3418ba64 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3418ba64:	b480      	push	{r7}
3418ba66:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3418ba68:	4b04      	ldr	r3, [pc, #16]	@ (3418ba7c <LL_RCC_IC2_GetSource+0x18>)
3418ba6a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ba6e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ba72:	4618      	mov	r0, r3
3418ba74:	46bd      	mov	sp, r7
3418ba76:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba7a:	4770      	bx	lr
3418ba7c:	56028000 	.word	0x56028000

3418ba80 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
3418ba80:	b480      	push	{r7}
3418ba82:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3418ba84:	4b05      	ldr	r3, [pc, #20]	@ (3418ba9c <LL_RCC_IC2_GetDivider+0x1c>)
3418ba86:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ba8a:	0c1b      	lsrs	r3, r3, #16
3418ba8c:	b2db      	uxtb	r3, r3
3418ba8e:	3301      	adds	r3, #1
}
3418ba90:	4618      	mov	r0, r3
3418ba92:	46bd      	mov	sp, r7
3418ba94:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ba98:	4770      	bx	lr
3418ba9a:	bf00      	nop
3418ba9c:	56028000 	.word	0x56028000

3418baa0 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
3418baa0:	b480      	push	{r7}
3418baa2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3418baa4:	4b04      	ldr	r3, [pc, #16]	@ (3418bab8 <LL_RCC_IC6_GetSource+0x18>)
3418baa6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418baaa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418baae:	4618      	mov	r0, r3
3418bab0:	46bd      	mov	sp, r7
3418bab2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418bab6:	4770      	bx	lr
3418bab8:	56028000 	.word	0x56028000

3418babc <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
3418babc:	b480      	push	{r7}
3418babe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3418bac0:	4b04      	ldr	r3, [pc, #16]	@ (3418bad4 <LL_RCC_IC11_GetSource+0x18>)
3418bac2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418bac6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418baca:	4618      	mov	r0, r3
3418bacc:	46bd      	mov	sp, r7
3418bace:	f85d 7b04 	ldr.w	r7, [sp], #4
3418bad2:	4770      	bx	lr
3418bad4:	56028000 	.word	0x56028000

3418bad8 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
3418bad8:	b580      	push	{r7, lr}
3418bada:	b0a2      	sub	sp, #136	@ 0x88
3418badc:	af00      	add	r7, sp, #0
3418bade:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
3418bae0:	687b      	ldr	r3, [r7, #4]
3418bae2:	2b00      	cmp	r3, #0
3418bae4:	d101      	bne.n	3418baea <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
3418bae6:	2301      	movs	r3, #1
3418bae8:	e3d1      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
3418baea:	f7ff fe7f 	bl	3418b7ec <LL_RCC_GetCpuClkSource>
3418baee:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
3418baf2:	f7ff fe89 	bl	3418b808 <LL_RCC_GetSysClkSource>
3418baf6:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
3418bafa:	f7ff feaf 	bl	3418b85c <LL_RCC_PLL1_GetSource>
3418bafe:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
3418bb00:	f7ff fee2 	bl	3418b8c8 <LL_RCC_PLL2_GetSource>
3418bb04:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
3418bb06:	f7ff ff15 	bl	3418b934 <LL_RCC_PLL3_GetSource>
3418bb0a:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
3418bb0c:	f7ff ff48 	bl	3418b9a0 <LL_RCC_PLL4_GetSource>
3418bb10:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3418bb12:	4b91      	ldr	r3, [pc, #580]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bb14:	685b      	ldr	r3, [r3, #4]
3418bb16:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
3418bb18:	687b      	ldr	r3, [r7, #4]
3418bb1a:	681b      	ldr	r3, [r3, #0]
3418bb1c:	f003 0301 	and.w	r3, r3, #1
3418bb20:	2b00      	cmp	r3, #0
3418bb22:	f000 80a8 	beq.w	3418bc76 <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3418bb26:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418bb2a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418bb2e:	d028      	beq.n	3418bb82 <HAL_RCC_OscConfig+0xaa>
3418bb30:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418bb34:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418bb38:	d023      	beq.n	3418bb82 <HAL_RCC_OscConfig+0xaa>
3418bb3a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418bb3c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418bb40:	d104      	bne.n	3418bb4c <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418bb42:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bb44:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418bb48:	2b00      	cmp	r3, #0
3418bb4a:	d11a      	bne.n	3418bb82 <HAL_RCC_OscConfig+0xaa>
3418bb4c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418bb4e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418bb52:	d104      	bne.n	3418bb5e <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418bb54:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bb56:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418bb5a:	2b00      	cmp	r3, #0
3418bb5c:	d111      	bne.n	3418bb82 <HAL_RCC_OscConfig+0xaa>
3418bb5e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418bb60:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418bb64:	d104      	bne.n	3418bb70 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418bb66:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bb68:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418bb6c:	2b00      	cmp	r3, #0
3418bb6e:	d108      	bne.n	3418bb82 <HAL_RCC_OscConfig+0xaa>
3418bb70:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418bb72:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418bb76:	d10a      	bne.n	3418bb8e <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418bb78:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bb7a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418bb7e:	2b00      	cmp	r3, #0
3418bb80:	d005      	beq.n	3418bb8e <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3418bb82:	687b      	ldr	r3, [r7, #4]
3418bb84:	685b      	ldr	r3, [r3, #4]
3418bb86:	2b00      	cmp	r3, #0
3418bb88:	d175      	bne.n	3418bc76 <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
3418bb8a:	2301      	movs	r3, #1
3418bb8c:	e37f      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3418bb8e:	687b      	ldr	r3, [r7, #4]
3418bb90:	685b      	ldr	r3, [r3, #4]
3418bb92:	2b10      	cmp	r3, #16
3418bb94:	d104      	bne.n	3418bba0 <HAL_RCC_OscConfig+0xc8>
3418bb96:	4b70      	ldr	r3, [pc, #448]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bb98:	2210      	movs	r2, #16
3418bb9a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bb9e:	e043      	b.n	3418bc28 <HAL_RCC_OscConfig+0x150>
3418bba0:	687b      	ldr	r3, [r7, #4]
3418bba2:	685b      	ldr	r3, [r3, #4]
3418bba4:	2b00      	cmp	r3, #0
3418bba6:	d10c      	bne.n	3418bbc2 <HAL_RCC_OscConfig+0xea>
3418bba8:	4b6b      	ldr	r3, [pc, #428]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbaa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418bbae:	461a      	mov	r2, r3
3418bbb0:	2310      	movs	r3, #16
3418bbb2:	6013      	str	r3, [r2, #0]
3418bbb4:	4b68      	ldr	r3, [pc, #416]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbb6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418bbb8:	4a67      	ldr	r2, [pc, #412]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbba:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418bbbe:	6553      	str	r3, [r2, #84]	@ 0x54
3418bbc0:	e032      	b.n	3418bc28 <HAL_RCC_OscConfig+0x150>
3418bbc2:	687b      	ldr	r3, [r7, #4]
3418bbc4:	685b      	ldr	r3, [r3, #4]
3418bbc6:	f248 0210 	movw	r2, #32784	@ 0x8010
3418bbca:	4293      	cmp	r3, r2
3418bbcc:	d110      	bne.n	3418bbf0 <HAL_RCC_OscConfig+0x118>
3418bbce:	4b62      	ldr	r3, [pc, #392]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbd0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418bbd2:	4a61      	ldr	r2, [pc, #388]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbd4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418bbd8:	6553      	str	r3, [r2, #84]	@ 0x54
3418bbda:	4b5f      	ldr	r3, [pc, #380]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbdc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418bbde:	4a5e      	ldr	r2, [pc, #376]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbe0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418bbe4:	6553      	str	r3, [r2, #84]	@ 0x54
3418bbe6:	4b5c      	ldr	r3, [pc, #368]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbe8:	2210      	movs	r2, #16
3418bbea:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bbee:	e01b      	b.n	3418bc28 <HAL_RCC_OscConfig+0x150>
3418bbf0:	687b      	ldr	r3, [r7, #4]
3418bbf2:	685b      	ldr	r3, [r3, #4]
3418bbf4:	4a59      	ldr	r2, [pc, #356]	@ (3418bd5c <HAL_RCC_OscConfig+0x284>)
3418bbf6:	4293      	cmp	r3, r2
3418bbf8:	d10a      	bne.n	3418bc10 <HAL_RCC_OscConfig+0x138>
3418bbfa:	4b57      	ldr	r3, [pc, #348]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bbfc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418bbfe:	4a56      	ldr	r2, [pc, #344]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc00:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
3418bc04:	6553      	str	r3, [r2, #84]	@ 0x54
3418bc06:	4b54      	ldr	r3, [pc, #336]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc08:	2210      	movs	r2, #16
3418bc0a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bc0e:	e00b      	b.n	3418bc28 <HAL_RCC_OscConfig+0x150>
3418bc10:	4b51      	ldr	r3, [pc, #324]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc12:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418bc16:	461a      	mov	r2, r3
3418bc18:	2310      	movs	r3, #16
3418bc1a:	6013      	str	r3, [r2, #0]
3418bc1c:	4b4e      	ldr	r3, [pc, #312]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc1e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418bc20:	4a4d      	ldr	r2, [pc, #308]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc22:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418bc26:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418bc28:	f7f9 fb92 	bl	34185350 <HAL_GetTick>
3418bc2c:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3418bc2e:	687b      	ldr	r3, [r7, #4]
3418bc30:	685b      	ldr	r3, [r3, #4]
3418bc32:	2b00      	cmp	r3, #0
3418bc34:	d019      	beq.n	3418bc6a <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418bc36:	e008      	b.n	3418bc4a <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3418bc38:	f7f9 fb8a 	bl	34185350 <HAL_GetTick>
3418bc3c:	4602      	mov	r2, r0
3418bc3e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bc40:	1ad3      	subs	r3, r2, r3
3418bc42:	2b64      	cmp	r3, #100	@ 0x64
3418bc44:	d901      	bls.n	3418bc4a <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
3418bc46:	2303      	movs	r3, #3
3418bc48:	e321      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418bc4a:	4b43      	ldr	r3, [pc, #268]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc4c:	685b      	ldr	r3, [r3, #4]
3418bc4e:	f003 0310 	and.w	r3, r3, #16
3418bc52:	2b00      	cmp	r3, #0
3418bc54:	d0f0      	beq.n	3418bc38 <HAL_RCC_OscConfig+0x160>
3418bc56:	e00e      	b.n	3418bc76 <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3418bc58:	f7f9 fb7a 	bl	34185350 <HAL_GetTick>
3418bc5c:	4602      	mov	r2, r0
3418bc5e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bc60:	1ad3      	subs	r3, r2, r3
3418bc62:	2b64      	cmp	r3, #100	@ 0x64
3418bc64:	d901      	bls.n	3418bc6a <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
3418bc66:	2303      	movs	r3, #3
3418bc68:	e311      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
3418bc6a:	4b3b      	ldr	r3, [pc, #236]	@ (3418bd58 <HAL_RCC_OscConfig+0x280>)
3418bc6c:	685b      	ldr	r3, [r3, #4]
3418bc6e:	f003 0310 	and.w	r3, r3, #16
3418bc72:	2b00      	cmp	r3, #0
3418bc74:	d1f0      	bne.n	3418bc58 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3418bc76:	687b      	ldr	r3, [r7, #4]
3418bc78:	681b      	ldr	r3, [r3, #0]
3418bc7a:	f003 0302 	and.w	r3, r3, #2
3418bc7e:	2b00      	cmp	r3, #0
3418bc80:	d073      	beq.n	3418bd6a <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3418bc82:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418bc86:	2b00      	cmp	r3, #0
3418bc88:	d023      	beq.n	3418bcd2 <HAL_RCC_OscConfig+0x1fa>
3418bc8a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418bc8e:	2b00      	cmp	r3, #0
3418bc90:	d01f      	beq.n	3418bcd2 <HAL_RCC_OscConfig+0x1fa>
3418bc92:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418bc94:	2b00      	cmp	r3, #0
3418bc96:	d104      	bne.n	3418bca2 <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418bc98:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bc9a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418bc9e:	2b00      	cmp	r3, #0
3418bca0:	d117      	bne.n	3418bcd2 <HAL_RCC_OscConfig+0x1fa>
3418bca2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418bca4:	2b00      	cmp	r3, #0
3418bca6:	d104      	bne.n	3418bcb2 <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418bca8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bcaa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418bcae:	2b00      	cmp	r3, #0
3418bcb0:	d10f      	bne.n	3418bcd2 <HAL_RCC_OscConfig+0x1fa>
3418bcb2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418bcb4:	2b00      	cmp	r3, #0
3418bcb6:	d104      	bne.n	3418bcc2 <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418bcb8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bcba:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418bcbe:	2b00      	cmp	r3, #0
3418bcc0:	d107      	bne.n	3418bcd2 <HAL_RCC_OscConfig+0x1fa>
3418bcc2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418bcc4:	2b00      	cmp	r3, #0
3418bcc6:	d115      	bne.n	3418bcf4 <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418bcc8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bcca:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418bcce:	2b00      	cmp	r3, #0
3418bcd0:	d010      	beq.n	3418bcf4 <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418bcd2:	687b      	ldr	r3, [r7, #4]
3418bcd4:	68db      	ldr	r3, [r3, #12]
3418bcd6:	2b00      	cmp	r3, #0
3418bcd8:	d101      	bne.n	3418bcde <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
3418bcda:	2301      	movs	r3, #1
3418bcdc:	e2d7      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418bcde:	687b      	ldr	r3, [r7, #4]
3418bce0:	691b      	ldr	r3, [r3, #16]
3418bce2:	4618      	mov	r0, r3
3418bce4:	f7ff fcb2 	bl	3418b64c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418bce8:	687b      	ldr	r3, [r7, #4]
3418bcea:	695b      	ldr	r3, [r3, #20]
3418bcec:	4618      	mov	r0, r3
3418bcee:	f7ff fccf 	bl	3418b690 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418bcf2:	e03a      	b.n	3418bd6a <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
3418bcf4:	687b      	ldr	r3, [r7, #4]
3418bcf6:	68db      	ldr	r3, [r3, #12]
3418bcf8:	2b00      	cmp	r3, #0
3418bcfa:	d01e      	beq.n	3418bd3a <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3418bcfc:	f7ff fc76 	bl	3418b5ec <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418bd00:	f7f9 fb26 	bl	34185350 <HAL_GetTick>
3418bd04:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3418bd06:	e008      	b.n	3418bd1a <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418bd08:	f7f9 fb22 	bl	34185350 <HAL_GetTick>
3418bd0c:	4602      	mov	r2, r0
3418bd0e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bd10:	1ad3      	subs	r3, r2, r3
3418bd12:	2b01      	cmp	r3, #1
3418bd14:	d901      	bls.n	3418bd1a <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3418bd16:	2303      	movs	r3, #3
3418bd18:	e2b9      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
3418bd1a:	f7ff fc85 	bl	3418b628 <LL_RCC_HSI_IsReady>
3418bd1e:	4603      	mov	r3, r0
3418bd20:	2b00      	cmp	r3, #0
3418bd22:	d0f1      	beq.n	3418bd08 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418bd24:	687b      	ldr	r3, [r7, #4]
3418bd26:	691b      	ldr	r3, [r3, #16]
3418bd28:	4618      	mov	r0, r3
3418bd2a:	f7ff fc8f 	bl	3418b64c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418bd2e:	687b      	ldr	r3, [r7, #4]
3418bd30:	695b      	ldr	r3, [r3, #20]
3418bd32:	4618      	mov	r0, r3
3418bd34:	f7ff fcac 	bl	3418b690 <LL_RCC_HSI_SetCalibTrimming>
3418bd38:	e017      	b.n	3418bd6a <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3418bd3a:	f7ff fc65 	bl	3418b608 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418bd3e:	f7f9 fb07 	bl	34185350 <HAL_GetTick>
3418bd42:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3418bd44:	e00c      	b.n	3418bd60 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418bd46:	f7f9 fb03 	bl	34185350 <HAL_GetTick>
3418bd4a:	4602      	mov	r2, r0
3418bd4c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bd4e:	1ad3      	subs	r3, r2, r3
3418bd50:	2b01      	cmp	r3, #1
3418bd52:	d905      	bls.n	3418bd60 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3418bd54:	2303      	movs	r3, #3
3418bd56:	e29a      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
3418bd58:	56028000 	.word	0x56028000
3418bd5c:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
3418bd60:	f7ff fc62 	bl	3418b628 <LL_RCC_HSI_IsReady>
3418bd64:	4603      	mov	r3, r0
3418bd66:	2b00      	cmp	r3, #0
3418bd68:	d1ed      	bne.n	3418bd46 <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
3418bd6a:	687b      	ldr	r3, [r7, #4]
3418bd6c:	681b      	ldr	r3, [r3, #0]
3418bd6e:	f003 0310 	and.w	r3, r3, #16
3418bd72:	2b00      	cmp	r3, #0
3418bd74:	d070      	beq.n	3418be58 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3418bd76:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418bd7a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418bd7e:	d028      	beq.n	3418bdd2 <HAL_RCC_OscConfig+0x2fa>
3418bd80:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418bd84:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418bd88:	d023      	beq.n	3418bdd2 <HAL_RCC_OscConfig+0x2fa>
3418bd8a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418bd8c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418bd90:	d104      	bne.n	3418bd9c <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418bd92:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bd94:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418bd98:	2b00      	cmp	r3, #0
3418bd9a:	d11a      	bne.n	3418bdd2 <HAL_RCC_OscConfig+0x2fa>
3418bd9c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418bd9e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418bda2:	d104      	bne.n	3418bdae <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418bda4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bda6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418bdaa:	2b00      	cmp	r3, #0
3418bdac:	d111      	bne.n	3418bdd2 <HAL_RCC_OscConfig+0x2fa>
3418bdae:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418bdb0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418bdb4:	d104      	bne.n	3418bdc0 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418bdb6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bdb8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418bdbc:	2b00      	cmp	r3, #0
3418bdbe:	d108      	bne.n	3418bdd2 <HAL_RCC_OscConfig+0x2fa>
3418bdc0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418bdc2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418bdc6:	d110      	bne.n	3418bdea <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418bdc8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418bdca:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418bdce:	2b00      	cmp	r3, #0
3418bdd0:	d00b      	beq.n	3418bdea <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418bdd2:	687b      	ldr	r3, [r7, #4]
3418bdd4:	69db      	ldr	r3, [r3, #28]
3418bdd6:	2b00      	cmp	r3, #0
3418bdd8:	d101      	bne.n	3418bdde <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
3418bdda:	2301      	movs	r3, #1
3418bddc:	e257      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418bdde:	687b      	ldr	r3, [r7, #4]
3418bde0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418bde2:	4618      	mov	r0, r3
3418bde4:	f7ff fcae 	bl	3418b744 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418bde8:	e036      	b.n	3418be58 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3418bdea:	687b      	ldr	r3, [r7, #4]
3418bdec:	69db      	ldr	r3, [r3, #28]
3418bdee:	2b00      	cmp	r3, #0
3418bdf0:	d01e      	beq.n	3418be30 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
3418bdf2:	687b      	ldr	r3, [r7, #4]
3418bdf4:	6a1b      	ldr	r3, [r3, #32]
3418bdf6:	4618      	mov	r0, r3
3418bdf8:	f7ff fc90 	bl	3418b71c <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3418bdfc:	f7ff fc5e 	bl	3418b6bc <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418be00:	f7f9 faa6 	bl	34185350 <HAL_GetTick>
3418be04:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3418be06:	e008      	b.n	3418be1a <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418be08:	f7f9 faa2 	bl	34185350 <HAL_GetTick>
3418be0c:	4602      	mov	r2, r0
3418be0e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418be10:	1ad3      	subs	r3, r2, r3
3418be12:	2b01      	cmp	r3, #1
3418be14:	d901      	bls.n	3418be1a <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
3418be16:	2303      	movs	r3, #3
3418be18:	e239      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
3418be1a:	f7ff fc6d 	bl	3418b6f8 <LL_RCC_MSI_IsReady>
3418be1e:	4603      	mov	r3, r0
3418be20:	2b00      	cmp	r3, #0
3418be22:	d0f1      	beq.n	3418be08 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418be24:	687b      	ldr	r3, [r7, #4]
3418be26:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418be28:	4618      	mov	r0, r3
3418be2a:	f7ff fc8b 	bl	3418b744 <LL_RCC_MSI_SetCalibTrimming>
3418be2e:	e013      	b.n	3418be58 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3418be30:	f7ff fc52 	bl	3418b6d8 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418be34:	f7f9 fa8c 	bl	34185350 <HAL_GetTick>
3418be38:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3418be3a:	e008      	b.n	3418be4e <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418be3c:	f7f9 fa88 	bl	34185350 <HAL_GetTick>
3418be40:	4602      	mov	r2, r0
3418be42:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418be44:	1ad3      	subs	r3, r2, r3
3418be46:	2b01      	cmp	r3, #1
3418be48:	d901      	bls.n	3418be4e <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
3418be4a:	2303      	movs	r3, #3
3418be4c:	e21f      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
3418be4e:	f7ff fc53 	bl	3418b6f8 <LL_RCC_MSI_IsReady>
3418be52:	4603      	mov	r3, r0
3418be54:	2b00      	cmp	r3, #0
3418be56:	d1f1      	bne.n	3418be3c <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
3418be58:	687b      	ldr	r3, [r7, #4]
3418be5a:	681b      	ldr	r3, [r3, #0]
3418be5c:	f003 0308 	and.w	r3, r3, #8
3418be60:	2b00      	cmp	r3, #0
3418be62:	d02c      	beq.n	3418bebe <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3418be64:	687b      	ldr	r3, [r7, #4]
3418be66:	699b      	ldr	r3, [r3, #24]
3418be68:	2b00      	cmp	r3, #0
3418be6a:	d014      	beq.n	3418be96 <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
3418be6c:	f7ff fc92 	bl	3418b794 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418be70:	f7f9 fa6e 	bl	34185350 <HAL_GetTick>
3418be74:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3418be76:	e008      	b.n	3418be8a <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418be78:	f7f9 fa6a 	bl	34185350 <HAL_GetTick>
3418be7c:	4602      	mov	r2, r0
3418be7e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418be80:	1ad3      	subs	r3, r2, r3
3418be82:	2b01      	cmp	r3, #1
3418be84:	d901      	bls.n	3418be8a <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
3418be86:	2303      	movs	r3, #3
3418be88:	e201      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
3418be8a:	f7ff fca1 	bl	3418b7d0 <LL_RCC_LSI_IsReady>
3418be8e:	4603      	mov	r3, r0
3418be90:	2b00      	cmp	r3, #0
3418be92:	d0f1      	beq.n	3418be78 <HAL_RCC_OscConfig+0x3a0>
3418be94:	e013      	b.n	3418bebe <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3418be96:	f7ff fc8b 	bl	3418b7b0 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418be9a:	f7f9 fa59 	bl	34185350 <HAL_GetTick>
3418be9e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
3418bea0:	e008      	b.n	3418beb4 <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418bea2:	f7f9 fa55 	bl	34185350 <HAL_GetTick>
3418bea6:	4602      	mov	r2, r0
3418bea8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418beaa:	1ad3      	subs	r3, r2, r3
3418beac:	2b01      	cmp	r3, #1
3418beae:	d901      	bls.n	3418beb4 <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
3418beb0:	2303      	movs	r3, #3
3418beb2:	e1ec      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
3418beb4:	f7ff fc8c 	bl	3418b7d0 <LL_RCC_LSI_IsReady>
3418beb8:	4603      	mov	r3, r0
3418beba:	2b00      	cmp	r3, #0
3418bebc:	d1f1      	bne.n	3418bea2 <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3418bebe:	687b      	ldr	r3, [r7, #4]
3418bec0:	681b      	ldr	r3, [r3, #0]
3418bec2:	f003 0304 	and.w	r3, r3, #4
3418bec6:	2b00      	cmp	r3, #0
3418bec8:	f000 808c 	beq.w	3418bfe4 <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3418becc:	687b      	ldr	r3, [r7, #4]
3418bece:	689b      	ldr	r3, [r3, #8]
3418bed0:	2b02      	cmp	r3, #2
3418bed2:	d104      	bne.n	3418bede <HAL_RCC_OscConfig+0x406>
3418bed4:	4b96      	ldr	r3, [pc, #600]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bed6:	2202      	movs	r2, #2
3418bed8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bedc:	e055      	b.n	3418bf8a <HAL_RCC_OscConfig+0x4b2>
3418bede:	687b      	ldr	r3, [r7, #4]
3418bee0:	689b      	ldr	r3, [r3, #8]
3418bee2:	2b00      	cmp	r3, #0
3418bee4:	d112      	bne.n	3418bf0c <HAL_RCC_OscConfig+0x434>
3418bee6:	4b92      	ldr	r3, [pc, #584]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bee8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418beec:	461a      	mov	r2, r3
3418beee:	2302      	movs	r3, #2
3418bef0:	6013      	str	r3, [r2, #0]
3418bef2:	4b8f      	ldr	r3, [pc, #572]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bef4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bef6:	4a8e      	ldr	r2, [pc, #568]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bef8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418befc:	6413      	str	r3, [r2, #64]	@ 0x40
3418befe:	4b8c      	ldr	r3, [pc, #560]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf00:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf02:	4a8b      	ldr	r2, [pc, #556]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf04:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418bf08:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf0a:	e03e      	b.n	3418bf8a <HAL_RCC_OscConfig+0x4b2>
3418bf0c:	687b      	ldr	r3, [r7, #4]
3418bf0e:	689b      	ldr	r3, [r3, #8]
3418bf10:	f248 0202 	movw	r2, #32770	@ 0x8002
3418bf14:	4293      	cmp	r3, r2
3418bf16:	d110      	bne.n	3418bf3a <HAL_RCC_OscConfig+0x462>
3418bf18:	4b85      	ldr	r3, [pc, #532]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf1a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf1c:	4a84      	ldr	r2, [pc, #528]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf1e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418bf22:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf24:	4b82      	ldr	r3, [pc, #520]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf26:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf28:	4a81      	ldr	r2, [pc, #516]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf2a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418bf2e:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf30:	4b7f      	ldr	r3, [pc, #508]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf32:	2202      	movs	r2, #2
3418bf34:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bf38:	e027      	b.n	3418bf8a <HAL_RCC_OscConfig+0x4b2>
3418bf3a:	687b      	ldr	r3, [r7, #4]
3418bf3c:	689b      	ldr	r3, [r3, #8]
3418bf3e:	4a7d      	ldr	r2, [pc, #500]	@ (3418c134 <HAL_RCC_OscConfig+0x65c>)
3418bf40:	4293      	cmp	r3, r2
3418bf42:	d110      	bne.n	3418bf66 <HAL_RCC_OscConfig+0x48e>
3418bf44:	4b7a      	ldr	r3, [pc, #488]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf46:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf48:	4a79      	ldr	r2, [pc, #484]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf4a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418bf4e:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf50:	4b77      	ldr	r3, [pc, #476]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf52:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf54:	4a76      	ldr	r2, [pc, #472]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf56:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418bf5a:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf5c:	4b74      	ldr	r3, [pc, #464]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf5e:	2202      	movs	r2, #2
3418bf60:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418bf64:	e011      	b.n	3418bf8a <HAL_RCC_OscConfig+0x4b2>
3418bf66:	4b72      	ldr	r3, [pc, #456]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf68:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418bf6c:	461a      	mov	r2, r3
3418bf6e:	2302      	movs	r3, #2
3418bf70:	6013      	str	r3, [r2, #0]
3418bf72:	4b6f      	ldr	r3, [pc, #444]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf74:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf76:	4a6e      	ldr	r2, [pc, #440]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf78:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418bf7c:	6413      	str	r3, [r2, #64]	@ 0x40
3418bf7e:	4b6c      	ldr	r3, [pc, #432]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf80:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418bf82:	4a6b      	ldr	r2, [pc, #428]	@ (3418c130 <HAL_RCC_OscConfig+0x658>)
3418bf84:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418bf88:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3418bf8a:	687b      	ldr	r3, [r7, #4]
3418bf8c:	689b      	ldr	r3, [r3, #8]
3418bf8e:	2b00      	cmp	r3, #0
3418bf90:	d014      	beq.n	3418bfbc <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418bf92:	f7f9 f9dd 	bl	34185350 <HAL_GetTick>
3418bf96:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
3418bf98:	e00a      	b.n	3418bfb0 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418bf9a:	f7f9 f9d9 	bl	34185350 <HAL_GetTick>
3418bf9e:	4602      	mov	r2, r0
3418bfa0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bfa2:	1ad3      	subs	r3, r2, r3
3418bfa4:	f241 3288 	movw	r2, #5000	@ 0x1388
3418bfa8:	4293      	cmp	r3, r2
3418bfaa:	d901      	bls.n	3418bfb0 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
3418bfac:	2303      	movs	r3, #3
3418bfae:	e16e      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
3418bfb0:	f7ff fbde 	bl	3418b770 <LL_RCC_LSE_IsReady>
3418bfb4:	4603      	mov	r3, r0
3418bfb6:	2b00      	cmp	r3, #0
3418bfb8:	d0ef      	beq.n	3418bf9a <HAL_RCC_OscConfig+0x4c2>
3418bfba:	e013      	b.n	3418bfe4 <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418bfbc:	f7f9 f9c8 	bl	34185350 <HAL_GetTick>
3418bfc0:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
3418bfc2:	e00a      	b.n	3418bfda <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418bfc4:	f7f9 f9c4 	bl	34185350 <HAL_GetTick>
3418bfc8:	4602      	mov	r2, r0
3418bfca:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418bfcc:	1ad3      	subs	r3, r2, r3
3418bfce:	f241 3288 	movw	r2, #5000	@ 0x1388
3418bfd2:	4293      	cmp	r3, r2
3418bfd4:	d901      	bls.n	3418bfda <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
3418bfd6:	2303      	movs	r3, #3
3418bfd8:	e159      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
3418bfda:	f7ff fbc9 	bl	3418b770 <LL_RCC_LSE_IsReady>
3418bfde:	4603      	mov	r3, r0
3418bfe0:	2b00      	cmp	r3, #0
3418bfe2:	d1ef      	bne.n	3418bfc4 <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3418bfe4:	687b      	ldr	r3, [r7, #4]
3418bfe6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418bfe8:	2b00      	cmp	r3, #0
3418bfea:	d04c      	beq.n	3418c086 <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3418bfec:	687b      	ldr	r3, [r7, #4]
3418bfee:	3328      	adds	r3, #40	@ 0x28
3418bff0:	4619      	mov	r1, r3
3418bff2:	2000      	movs	r0, #0
3418bff4:	f000 fe4c 	bl	3418cc90 <RCC_PLL_IsNewConfig>
3418bff8:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3418bffa:	f7ff fc3d 	bl	3418b878 <LL_RCC_PLL1_IsReady>
3418bffe:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
3418c000:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3418c002:	2b01      	cmp	r3, #1
3418c004:	d130      	bne.n	3418c068 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418c006:	f7ff fd0f 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c00a:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418c00c:	f7ff fd2a 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c010:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418c012:	f7ff fd45 	bl	3418baa0 <LL_RCC_IC6_GetSource>
3418c016:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418c018:	f7ff fd50 	bl	3418babc <LL_RCC_IC11_GetSource>
3418c01c:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3418c01e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418c022:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c026:	d104      	bne.n	3418c032 <HAL_RCC_OscConfig+0x55a>
3418c028:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3418c02a:	2b00      	cmp	r3, #0
3418c02c:	d101      	bne.n	3418c032 <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
3418c02e:	2301      	movs	r3, #1
3418c030:	e12d      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418c032:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418c036:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c03a:	d10a      	bne.n	3418c052 <HAL_RCC_OscConfig+0x57a>
3418c03c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3418c03e:	2b00      	cmp	r3, #0
3418c040:	d005      	beq.n	3418c04e <HAL_RCC_OscConfig+0x576>
3418c042:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3418c044:	2b00      	cmp	r3, #0
3418c046:	d002      	beq.n	3418c04e <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418c048:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3418c04a:	2b00      	cmp	r3, #0
3418c04c:	d101      	bne.n	3418c052 <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
3418c04e:	2301      	movs	r3, #1
3418c050:	e11d      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3418c052:	687b      	ldr	r3, [r7, #4]
3418c054:	3328      	adds	r3, #40	@ 0x28
3418c056:	4619      	mov	r1, r3
3418c058:	2000      	movs	r0, #0
3418c05a:	f000 fcbd 	bl	3418c9d8 <RCC_PLL_Config>
3418c05e:	4603      	mov	r3, r0
3418c060:	2b00      	cmp	r3, #0
3418c062:	d010      	beq.n	3418c086 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418c064:	2301      	movs	r3, #1
3418c066:	e112      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3418c068:	687b      	ldr	r3, [r7, #4]
3418c06a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418c06c:	2b02      	cmp	r3, #2
3418c06e:	d10a      	bne.n	3418c086 <HAL_RCC_OscConfig+0x5ae>
3418c070:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3418c072:	2b00      	cmp	r3, #0
3418c074:	d107      	bne.n	3418c086 <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3418c076:	2000      	movs	r0, #0
3418c078:	f000 fdde 	bl	3418cc38 <RCC_PLL_Enable>
3418c07c:	4603      	mov	r3, r0
3418c07e:	2b00      	cmp	r3, #0
3418c080:	d001      	beq.n	3418c086 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418c082:	2301      	movs	r3, #1
3418c084:	e103      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3418c086:	687b      	ldr	r3, [r7, #4]
3418c088:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418c08a:	2b00      	cmp	r3, #0
3418c08c:	d054      	beq.n	3418c138 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3418c08e:	687b      	ldr	r3, [r7, #4]
3418c090:	3344      	adds	r3, #68	@ 0x44
3418c092:	4619      	mov	r1, r3
3418c094:	2001      	movs	r0, #1
3418c096:	f000 fdfb 	bl	3418cc90 <RCC_PLL_IsNewConfig>
3418c09a:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3418c09c:	f7ff fc22 	bl	3418b8e4 <LL_RCC_PLL2_IsReady>
3418c0a0:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
3418c0a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3418c0a4:	2b01      	cmp	r3, #1
3418c0a6:	d134      	bne.n	3418c112 <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418c0a8:	f7ff fcbe 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c0ac:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418c0ae:	f7ff fcd9 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c0b2:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418c0b4:	f7ff fcf4 	bl	3418baa0 <LL_RCC_IC6_GetSource>
3418c0b8:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418c0ba:	f7ff fcff 	bl	3418babc <LL_RCC_IC11_GetSource>
3418c0be:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3418c0c0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418c0c4:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c0c8:	d105      	bne.n	3418c0d6 <HAL_RCC_OscConfig+0x5fe>
3418c0ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3418c0cc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c0d0:	d101      	bne.n	3418c0d6 <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
3418c0d2:	2301      	movs	r3, #1
3418c0d4:	e0db      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418c0d6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418c0da:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c0de:	d10d      	bne.n	3418c0fc <HAL_RCC_OscConfig+0x624>
3418c0e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3418c0e2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c0e6:	d007      	beq.n	3418c0f8 <HAL_RCC_OscConfig+0x620>
3418c0e8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418c0ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c0ee:	d003      	beq.n	3418c0f8 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418c0f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418c0f2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c0f6:	d101      	bne.n	3418c0fc <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
3418c0f8:	2301      	movs	r3, #1
3418c0fa:	e0c8      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3418c0fc:	687b      	ldr	r3, [r7, #4]
3418c0fe:	3344      	adds	r3, #68	@ 0x44
3418c100:	4619      	mov	r1, r3
3418c102:	2001      	movs	r0, #1
3418c104:	f000 fc68 	bl	3418c9d8 <RCC_PLL_Config>
3418c108:	4603      	mov	r3, r0
3418c10a:	2b00      	cmp	r3, #0
3418c10c:	d014      	beq.n	3418c138 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418c10e:	2301      	movs	r3, #1
3418c110:	e0bd      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3418c112:	687b      	ldr	r3, [r7, #4]
3418c114:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418c116:	2b02      	cmp	r3, #2
3418c118:	d10e      	bne.n	3418c138 <HAL_RCC_OscConfig+0x660>
3418c11a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418c11c:	2b00      	cmp	r3, #0
3418c11e:	d10b      	bne.n	3418c138 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3418c120:	2001      	movs	r0, #1
3418c122:	f000 fd89 	bl	3418cc38 <RCC_PLL_Enable>
3418c126:	4603      	mov	r3, r0
3418c128:	2b00      	cmp	r3, #0
3418c12a:	d005      	beq.n	3418c138 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418c12c:	2301      	movs	r3, #1
3418c12e:	e0ae      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
3418c130:	56028000 	.word	0x56028000
3418c134:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
3418c138:	687b      	ldr	r3, [r7, #4]
3418c13a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418c13c:	2b00      	cmp	r3, #0
3418c13e:	d050      	beq.n	3418c1e2 <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3418c140:	687b      	ldr	r3, [r7, #4]
3418c142:	3360      	adds	r3, #96	@ 0x60
3418c144:	4619      	mov	r1, r3
3418c146:	2002      	movs	r0, #2
3418c148:	f000 fda2 	bl	3418cc90 <RCC_PLL_IsNewConfig>
3418c14c:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3418c14e:	f7ff fb93 	bl	3418b878 <LL_RCC_PLL1_IsReady>
3418c152:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3418c154:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418c156:	2b01      	cmp	r3, #1
3418c158:	d134      	bne.n	3418c1c4 <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418c15a:	f7ff fc65 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c15e:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418c160:	f7ff fc80 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c164:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418c166:	f7ff fc9b 	bl	3418baa0 <LL_RCC_IC6_GetSource>
3418c16a:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418c16c:	f7ff fca6 	bl	3418babc <LL_RCC_IC11_GetSource>
3418c170:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3418c172:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418c176:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c17a:	d105      	bne.n	3418c188 <HAL_RCC_OscConfig+0x6b0>
3418c17c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418c17e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c182:	d101      	bne.n	3418c188 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
3418c184:	2301      	movs	r3, #1
3418c186:	e082      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418c188:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418c18c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c190:	d10d      	bne.n	3418c1ae <HAL_RCC_OscConfig+0x6d6>
3418c192:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c194:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c198:	d007      	beq.n	3418c1aa <HAL_RCC_OscConfig+0x6d2>
3418c19a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418c19c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c1a0:	d003      	beq.n	3418c1aa <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418c1a2:	6a3b      	ldr	r3, [r7, #32]
3418c1a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c1a8:	d101      	bne.n	3418c1ae <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3418c1aa:	2301      	movs	r3, #1
3418c1ac:	e06f      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3418c1ae:	687b      	ldr	r3, [r7, #4]
3418c1b0:	3360      	adds	r3, #96	@ 0x60
3418c1b2:	4619      	mov	r1, r3
3418c1b4:	2002      	movs	r0, #2
3418c1b6:	f000 fc0f 	bl	3418c9d8 <RCC_PLL_Config>
3418c1ba:	4603      	mov	r3, r0
3418c1bc:	2b00      	cmp	r3, #0
3418c1be:	d010      	beq.n	3418c1e2 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418c1c0:	2301      	movs	r3, #1
3418c1c2:	e064      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3418c1c4:	687b      	ldr	r3, [r7, #4]
3418c1c6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418c1c8:	2b02      	cmp	r3, #2
3418c1ca:	d10a      	bne.n	3418c1e2 <HAL_RCC_OscConfig+0x70a>
3418c1cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418c1ce:	2b00      	cmp	r3, #0
3418c1d0:	d107      	bne.n	3418c1e2 <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3418c1d2:	2002      	movs	r0, #2
3418c1d4:	f000 fd30 	bl	3418cc38 <RCC_PLL_Enable>
3418c1d8:	4603      	mov	r3, r0
3418c1da:	2b00      	cmp	r3, #0
3418c1dc:	d001      	beq.n	3418c1e2 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418c1de:	2301      	movs	r3, #1
3418c1e0:	e055      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
3418c1e2:	687b      	ldr	r3, [r7, #4]
3418c1e4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418c1e6:	2b00      	cmp	r3, #0
3418c1e8:	d050      	beq.n	3418c28c <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3418c1ea:	687b      	ldr	r3, [r7, #4]
3418c1ec:	337c      	adds	r3, #124	@ 0x7c
3418c1ee:	4619      	mov	r1, r3
3418c1f0:	2003      	movs	r0, #3
3418c1f2:	f000 fd4d 	bl	3418cc90 <RCC_PLL_IsNewConfig>
3418c1f6:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
3418c1f8:	f7ff fbe0 	bl	3418b9bc <LL_RCC_PLL4_IsReady>
3418c1fc:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
3418c1fe:	69fb      	ldr	r3, [r7, #28]
3418c200:	2b01      	cmp	r3, #1
3418c202:	d134      	bne.n	3418c26e <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418c204:	f7ff fc10 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c208:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418c20a:	f7ff fc2b 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c20e:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418c210:	f7ff fc46 	bl	3418baa0 <LL_RCC_IC6_GetSource>
3418c214:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418c216:	f7ff fc51 	bl	3418babc <LL_RCC_IC11_GetSource>
3418c21a:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3418c21c:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418c220:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c224:	d105      	bne.n	3418c232 <HAL_RCC_OscConfig+0x75a>
3418c226:	697b      	ldr	r3, [r7, #20]
3418c228:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c22c:	d101      	bne.n	3418c232 <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
3418c22e:	2301      	movs	r3, #1
3418c230:	e02d      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418c232:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418c236:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c23a:	d10d      	bne.n	3418c258 <HAL_RCC_OscConfig+0x780>
3418c23c:	693b      	ldr	r3, [r7, #16]
3418c23e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c242:	d007      	beq.n	3418c254 <HAL_RCC_OscConfig+0x77c>
3418c244:	68fb      	ldr	r3, [r7, #12]
3418c246:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c24a:	d003      	beq.n	3418c254 <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418c24c:	68bb      	ldr	r3, [r7, #8]
3418c24e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c252:	d101      	bne.n	3418c258 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3418c254:	2301      	movs	r3, #1
3418c256:	e01a      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3418c258:	687b      	ldr	r3, [r7, #4]
3418c25a:	337c      	adds	r3, #124	@ 0x7c
3418c25c:	4619      	mov	r1, r3
3418c25e:	2003      	movs	r0, #3
3418c260:	f000 fbba 	bl	3418c9d8 <RCC_PLL_Config>
3418c264:	4603      	mov	r3, r0
3418c266:	2b00      	cmp	r3, #0
3418c268:	d010      	beq.n	3418c28c <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418c26a:	2301      	movs	r3, #1
3418c26c:	e00f      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3418c26e:	687b      	ldr	r3, [r7, #4]
3418c270:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418c272:	2b02      	cmp	r3, #2
3418c274:	d10a      	bne.n	3418c28c <HAL_RCC_OscConfig+0x7b4>
3418c276:	69bb      	ldr	r3, [r7, #24]
3418c278:	2b00      	cmp	r3, #0
3418c27a:	d107      	bne.n	3418c28c <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3418c27c:	2003      	movs	r0, #3
3418c27e:	f000 fcdb 	bl	3418cc38 <RCC_PLL_Enable>
3418c282:	4603      	mov	r3, r0
3418c284:	2b00      	cmp	r3, #0
3418c286:	d001      	beq.n	3418c28c <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418c288:	2301      	movs	r3, #1
3418c28a:	e000      	b.n	3418c28e <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
3418c28c:	2300      	movs	r3, #0
}
3418c28e:	4618      	mov	r0, r3
3418c290:	3788      	adds	r7, #136	@ 0x88
3418c292:	46bd      	mov	sp, r7
3418c294:	bd80      	pop	{r7, pc}
3418c296:	bf00      	nop

3418c298 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418c298:	b580      	push	{r7, lr}
3418c29a:	b084      	sub	sp, #16
3418c29c:	af00      	add	r7, sp, #0
3418c29e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3418c2a0:	687b      	ldr	r3, [r7, #4]
3418c2a2:	2b00      	cmp	r3, #0
3418c2a4:	d101      	bne.n	3418c2aa <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
3418c2a6:	2301      	movs	r3, #1
3418c2a8:	e1f2      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418c2aa:	687b      	ldr	r3, [r7, #4]
3418c2ac:	681b      	ldr	r3, [r3, #0]
3418c2ae:	f003 0308 	and.w	r3, r3, #8
3418c2b2:	2b00      	cmp	r3, #0
3418c2b4:	d010      	beq.n	3418c2d8 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418c2b6:	687b      	ldr	r3, [r7, #4]
3418c2b8:	691a      	ldr	r2, [r3, #16]
3418c2ba:	4ba3      	ldr	r3, [pc, #652]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c2bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c2be:	f003 0307 	and.w	r3, r3, #7
3418c2c2:	429a      	cmp	r2, r3
3418c2c4:	d908      	bls.n	3418c2d8 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418c2c6:	4ba0      	ldr	r3, [pc, #640]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c2c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c2ca:	f023 0207 	bic.w	r2, r3, #7
3418c2ce:	687b      	ldr	r3, [r7, #4]
3418c2d0:	691b      	ldr	r3, [r3, #16]
3418c2d2:	499d      	ldr	r1, [pc, #628]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c2d4:	4313      	orrs	r3, r2
3418c2d6:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418c2d8:	687b      	ldr	r3, [r7, #4]
3418c2da:	681b      	ldr	r3, [r3, #0]
3418c2dc:	f003 0310 	and.w	r3, r3, #16
3418c2e0:	2b00      	cmp	r3, #0
3418c2e2:	d010      	beq.n	3418c306 <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418c2e4:	687b      	ldr	r3, [r7, #4]
3418c2e6:	695a      	ldr	r2, [r3, #20]
3418c2e8:	4b97      	ldr	r3, [pc, #604]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c2ea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c2ec:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418c2f0:	429a      	cmp	r2, r3
3418c2f2:	d908      	bls.n	3418c306 <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418c2f4:	4b94      	ldr	r3, [pc, #592]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c2f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c2f8:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418c2fc:	687b      	ldr	r3, [r7, #4]
3418c2fe:	695b      	ldr	r3, [r3, #20]
3418c300:	4991      	ldr	r1, [pc, #580]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c302:	4313      	orrs	r3, r2
3418c304:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418c306:	687b      	ldr	r3, [r7, #4]
3418c308:	681b      	ldr	r3, [r3, #0]
3418c30a:	f003 0320 	and.w	r3, r3, #32
3418c30e:	2b00      	cmp	r3, #0
3418c310:	d010      	beq.n	3418c334 <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418c312:	687b      	ldr	r3, [r7, #4]
3418c314:	699a      	ldr	r2, [r3, #24]
3418c316:	4b8c      	ldr	r3, [pc, #560]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c318:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c31a:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418c31e:	429a      	cmp	r2, r3
3418c320:	d908      	bls.n	3418c334 <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418c322:	4b89      	ldr	r3, [pc, #548]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c324:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c326:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418c32a:	687b      	ldr	r3, [r7, #4]
3418c32c:	699b      	ldr	r3, [r3, #24]
3418c32e:	4986      	ldr	r1, [pc, #536]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c330:	4313      	orrs	r3, r2
3418c332:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418c334:	687b      	ldr	r3, [r7, #4]
3418c336:	681b      	ldr	r3, [r3, #0]
3418c338:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418c33c:	2b00      	cmp	r3, #0
3418c33e:	d010      	beq.n	3418c362 <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418c340:	687b      	ldr	r3, [r7, #4]
3418c342:	69da      	ldr	r2, [r3, #28]
3418c344:	4b80      	ldr	r3, [pc, #512]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c346:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c348:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418c34c:	429a      	cmp	r2, r3
3418c34e:	d908      	bls.n	3418c362 <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418c350:	4b7d      	ldr	r3, [pc, #500]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c352:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c354:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418c358:	687b      	ldr	r3, [r7, #4]
3418c35a:	69db      	ldr	r3, [r3, #28]
3418c35c:	497a      	ldr	r1, [pc, #488]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c35e:	4313      	orrs	r3, r2
3418c360:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418c362:	687b      	ldr	r3, [r7, #4]
3418c364:	681b      	ldr	r3, [r3, #0]
3418c366:	f003 0304 	and.w	r3, r3, #4
3418c36a:	2b00      	cmp	r3, #0
3418c36c:	d010      	beq.n	3418c390 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418c36e:	687b      	ldr	r3, [r7, #4]
3418c370:	68da      	ldr	r2, [r3, #12]
3418c372:	4b75      	ldr	r3, [pc, #468]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c374:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c376:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418c37a:	429a      	cmp	r2, r3
3418c37c:	d908      	bls.n	3418c390 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418c37e:	4b72      	ldr	r3, [pc, #456]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c380:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c382:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418c386:	687b      	ldr	r3, [r7, #4]
3418c388:	68db      	ldr	r3, [r3, #12]
3418c38a:	496f      	ldr	r1, [pc, #444]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c38c:	4313      	orrs	r3, r2
3418c38e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3418c390:	687b      	ldr	r3, [r7, #4]
3418c392:	681b      	ldr	r3, [r3, #0]
3418c394:	f003 0301 	and.w	r3, r3, #1
3418c398:	2b00      	cmp	r3, #0
3418c39a:	d063      	beq.n	3418c464 <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3418c39c:	687b      	ldr	r3, [r7, #4]
3418c39e:	685b      	ldr	r3, [r3, #4]
3418c3a0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418c3a4:	d106      	bne.n	3418c3b4 <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418c3a6:	f7ff f90f 	bl	3418b5c8 <LL_RCC_HSE_IsReady>
3418c3aa:	4603      	mov	r3, r0
3418c3ac:	2b00      	cmp	r3, #0
3418c3ae:	d134      	bne.n	3418c41a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418c3b0:	2301      	movs	r3, #1
3418c3b2:	e16d      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3418c3b4:	687b      	ldr	r3, [r7, #4]
3418c3b6:	685b      	ldr	r3, [r3, #4]
3418c3b8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418c3bc:	d11a      	bne.n	3418c3f4 <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3418c3be:	f7ff fb33 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c3c2:	4602      	mov	r2, r0
3418c3c4:	687b      	ldr	r3, [r7, #4]
3418c3c6:	6a1b      	ldr	r3, [r3, #32]
3418c3c8:	4619      	mov	r1, r3
3418c3ca:	4610      	mov	r0, r2
3418c3cc:	f000 fd14 	bl	3418cdf8 <RCC_IC_CheckPLLSources>
3418c3d0:	4603      	mov	r3, r0
3418c3d2:	2b01      	cmp	r3, #1
3418c3d4:	d001      	beq.n	3418c3da <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
3418c3d6:	2301      	movs	r3, #1
3418c3d8:	e15a      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3418c3da:	687b      	ldr	r3, [r7, #4]
3418c3dc:	6a1a      	ldr	r2, [r3, #32]
3418c3de:	687b      	ldr	r3, [r7, #4]
3418c3e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c3e2:	3b01      	subs	r3, #1
3418c3e4:	041b      	lsls	r3, r3, #16
3418c3e6:	4958      	ldr	r1, [pc, #352]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c3e8:	4313      	orrs	r3, r2
3418c3ea:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
3418c3ee:	f7ff fb0d 	bl	3418ba0c <LL_RCC_IC1_Enable>
3418c3f2:	e012      	b.n	3418c41a <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3418c3f4:	687b      	ldr	r3, [r7, #4]
3418c3f6:	685b      	ldr	r3, [r3, #4]
3418c3f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418c3fc:	d106      	bne.n	3418c40c <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418c3fe:	f7ff f97b 	bl	3418b6f8 <LL_RCC_MSI_IsReady>
3418c402:	4603      	mov	r3, r0
3418c404:	2b00      	cmp	r3, #0
3418c406:	d108      	bne.n	3418c41a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418c408:	2301      	movs	r3, #1
3418c40a:	e141      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418c40c:	f7ff f90c 	bl	3418b628 <LL_RCC_HSI_IsReady>
3418c410:	4603      	mov	r3, r0
3418c412:	2b00      	cmp	r3, #0
3418c414:	d101      	bne.n	3418c41a <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418c416:	2301      	movs	r3, #1
3418c418:	e13a      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3418c41a:	4b4b      	ldr	r3, [pc, #300]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c41c:	6a1b      	ldr	r3, [r3, #32]
3418c41e:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3418c422:	687b      	ldr	r3, [r7, #4]
3418c424:	685b      	ldr	r3, [r3, #4]
3418c426:	4948      	ldr	r1, [pc, #288]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c428:	4313      	orrs	r3, r2
3418c42a:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418c42c:	f7f8 ff90 	bl	34185350 <HAL_GetTick>
3418c430:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418c432:	e00a      	b.n	3418c44a <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418c434:	f7f8 ff8c 	bl	34185350 <HAL_GetTick>
3418c438:	4602      	mov	r2, r0
3418c43a:	68fb      	ldr	r3, [r7, #12]
3418c43c:	1ad3      	subs	r3, r2, r3
3418c43e:	f241 3288 	movw	r2, #5000	@ 0x1388
3418c442:	4293      	cmp	r3, r2
3418c444:	d901      	bls.n	3418c44a <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
3418c446:	2303      	movs	r3, #3
3418c448:	e122      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418c44a:	f7ff f9cf 	bl	3418b7ec <LL_RCC_GetCpuClkSource>
3418c44e:	4602      	mov	r2, r0
3418c450:	687b      	ldr	r3, [r7, #4]
3418c452:	685b      	ldr	r3, [r3, #4]
3418c454:	011b      	lsls	r3, r3, #4
3418c456:	429a      	cmp	r2, r3
3418c458:	d1ec      	bne.n	3418c434 <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3418c45a:	f000 f921 	bl	3418c6a0 <HAL_RCC_GetCpuClockFreq>
3418c45e:	4603      	mov	r3, r0
3418c460:	4a3a      	ldr	r2, [pc, #232]	@ (3418c54c <HAL_RCC_ClockConfig+0x2b4>)
3418c462:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3418c464:	687b      	ldr	r3, [r7, #4]
3418c466:	681b      	ldr	r3, [r3, #0]
3418c468:	f003 0302 	and.w	r3, r3, #2
3418c46c:	2b00      	cmp	r3, #0
3418c46e:	f000 8096 	beq.w	3418c59e <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3418c472:	687b      	ldr	r3, [r7, #4]
3418c474:	689b      	ldr	r3, [r3, #8]
3418c476:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418c47a:	d106      	bne.n	3418c48a <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418c47c:	f7ff f8a4 	bl	3418b5c8 <LL_RCC_HSE_IsReady>
3418c480:	4603      	mov	r3, r0
3418c482:	2b00      	cmp	r3, #0
3418c484:	d16b      	bne.n	3418c55e <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418c486:	2301      	movs	r3, #1
3418c488:	e102      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3418c48a:	687b      	ldr	r3, [r7, #4]
3418c48c:	689b      	ldr	r3, [r3, #8]
3418c48e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418c492:	d14d      	bne.n	3418c530 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3418c494:	f7ff fae6 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c498:	4602      	mov	r2, r0
3418c49a:	687b      	ldr	r3, [r7, #4]
3418c49c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418c49e:	4619      	mov	r1, r3
3418c4a0:	4610      	mov	r0, r2
3418c4a2:	f000 fca9 	bl	3418cdf8 <RCC_IC_CheckPLLSources>
3418c4a6:	4603      	mov	r3, r0
3418c4a8:	2b01      	cmp	r3, #1
3418c4aa:	d001      	beq.n	3418c4b0 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
3418c4ac:	2301      	movs	r3, #1
3418c4ae:	e0ef      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3418c4b0:	f7ff faf6 	bl	3418baa0 <LL_RCC_IC6_GetSource>
3418c4b4:	4602      	mov	r2, r0
3418c4b6:	687b      	ldr	r3, [r7, #4]
3418c4b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3418c4ba:	4619      	mov	r1, r3
3418c4bc:	4610      	mov	r0, r2
3418c4be:	f000 fc9b 	bl	3418cdf8 <RCC_IC_CheckPLLSources>
3418c4c2:	4603      	mov	r3, r0
3418c4c4:	2b01      	cmp	r3, #1
3418c4c6:	d001      	beq.n	3418c4cc <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
3418c4c8:	2301      	movs	r3, #1
3418c4ca:	e0e1      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3418c4cc:	f7ff faf6 	bl	3418babc <LL_RCC_IC11_GetSource>
3418c4d0:	4602      	mov	r2, r0
3418c4d2:	687b      	ldr	r3, [r7, #4]
3418c4d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418c4d6:	4619      	mov	r1, r3
3418c4d8:	4610      	mov	r0, r2
3418c4da:	f000 fc8d 	bl	3418cdf8 <RCC_IC_CheckPLLSources>
3418c4de:	4603      	mov	r3, r0
3418c4e0:	2b01      	cmp	r3, #1
3418c4e2:	d001      	beq.n	3418c4e8 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
3418c4e4:	2301      	movs	r3, #1
3418c4e6:	e0d3      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3418c4e8:	687b      	ldr	r3, [r7, #4]
3418c4ea:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418c4ec:	687b      	ldr	r3, [r7, #4]
3418c4ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418c4f0:	3b01      	subs	r3, #1
3418c4f2:	041b      	lsls	r3, r3, #16
3418c4f4:	4914      	ldr	r1, [pc, #80]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c4f6:	4313      	orrs	r3, r2
3418c4f8:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3418c4fc:	687b      	ldr	r3, [r7, #4]
3418c4fe:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3418c500:	687b      	ldr	r3, [r7, #4]
3418c502:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418c504:	3b01      	subs	r3, #1
3418c506:	041b      	lsls	r3, r3, #16
3418c508:	490f      	ldr	r1, [pc, #60]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c50a:	4313      	orrs	r3, r2
3418c50c:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3418c510:	687b      	ldr	r3, [r7, #4]
3418c512:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418c514:	687b      	ldr	r3, [r7, #4]
3418c516:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c518:	3b01      	subs	r3, #1
3418c51a:	041b      	lsls	r3, r3, #16
3418c51c:	490a      	ldr	r1, [pc, #40]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c51e:	4313      	orrs	r3, r2
3418c520:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3418c524:	4b08      	ldr	r3, [pc, #32]	@ (3418c548 <HAL_RCC_ClockConfig+0x2b0>)
3418c526:	f240 4222 	movw	r2, #1058	@ 0x422
3418c52a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
3418c52e:	e016      	b.n	3418c55e <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3418c530:	687b      	ldr	r3, [r7, #4]
3418c532:	689b      	ldr	r3, [r3, #8]
3418c534:	2b00      	cmp	r3, #0
3418c536:	d10b      	bne.n	3418c550 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418c538:	f7ff f876 	bl	3418b628 <LL_RCC_HSI_IsReady>
3418c53c:	4603      	mov	r3, r0
3418c53e:	2b00      	cmp	r3, #0
3418c540:	d10d      	bne.n	3418c55e <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418c542:	2301      	movs	r3, #1
3418c544:	e0a4      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
3418c546:	bf00      	nop
3418c548:	56028000 	.word	0x56028000
3418c54c:	341c0024 	.word	0x341c0024
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418c550:	f7ff f8d2 	bl	3418b6f8 <LL_RCC_MSI_IsReady>
3418c554:	4603      	mov	r3, r0
3418c556:	2b00      	cmp	r3, #0
3418c558:	d101      	bne.n	3418c55e <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418c55a:	2301      	movs	r3, #1
3418c55c:	e098      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3418c55e:	4b4e      	ldr	r3, [pc, #312]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c560:	6a1b      	ldr	r3, [r3, #32]
3418c562:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418c566:	687b      	ldr	r3, [r7, #4]
3418c568:	689b      	ldr	r3, [r3, #8]
3418c56a:	494b      	ldr	r1, [pc, #300]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c56c:	4313      	orrs	r3, r2
3418c56e:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418c570:	f7f8 feee 	bl	34185350 <HAL_GetTick>
3418c574:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418c576:	e00a      	b.n	3418c58e <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418c578:	f7f8 feea 	bl	34185350 <HAL_GetTick>
3418c57c:	4602      	mov	r2, r0
3418c57e:	68fb      	ldr	r3, [r7, #12]
3418c580:	1ad3      	subs	r3, r2, r3
3418c582:	f241 3288 	movw	r2, #5000	@ 0x1388
3418c586:	4293      	cmp	r3, r2
3418c588:	d901      	bls.n	3418c58e <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
3418c58a:	2303      	movs	r3, #3
3418c58c:	e080      	b.n	3418c690 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418c58e:	f7ff f93b 	bl	3418b808 <LL_RCC_GetSysClkSource>
3418c592:	4602      	mov	r2, r0
3418c594:	687b      	ldr	r3, [r7, #4]
3418c596:	689b      	ldr	r3, [r3, #8]
3418c598:	011b      	lsls	r3, r3, #4
3418c59a:	429a      	cmp	r2, r3
3418c59c:	d1ec      	bne.n	3418c578 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418c59e:	687b      	ldr	r3, [r7, #4]
3418c5a0:	681b      	ldr	r3, [r3, #0]
3418c5a2:	f003 0304 	and.w	r3, r3, #4
3418c5a6:	2b00      	cmp	r3, #0
3418c5a8:	d010      	beq.n	3418c5cc <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418c5aa:	687b      	ldr	r3, [r7, #4]
3418c5ac:	68da      	ldr	r2, [r3, #12]
3418c5ae:	4b3a      	ldr	r3, [pc, #232]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c5b2:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418c5b6:	429a      	cmp	r2, r3
3418c5b8:	d208      	bcs.n	3418c5cc <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418c5ba:	4b37      	ldr	r3, [pc, #220]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c5be:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418c5c2:	687b      	ldr	r3, [r7, #4]
3418c5c4:	68db      	ldr	r3, [r3, #12]
3418c5c6:	4934      	ldr	r1, [pc, #208]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5c8:	4313      	orrs	r3, r2
3418c5ca:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418c5cc:	687b      	ldr	r3, [r7, #4]
3418c5ce:	681b      	ldr	r3, [r3, #0]
3418c5d0:	f003 0308 	and.w	r3, r3, #8
3418c5d4:	2b00      	cmp	r3, #0
3418c5d6:	d010      	beq.n	3418c5fa <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418c5d8:	687b      	ldr	r3, [r7, #4]
3418c5da:	691a      	ldr	r2, [r3, #16]
3418c5dc:	4b2e      	ldr	r3, [pc, #184]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c5e0:	f003 0307 	and.w	r3, r3, #7
3418c5e4:	429a      	cmp	r2, r3
3418c5e6:	d208      	bcs.n	3418c5fa <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418c5e8:	4b2b      	ldr	r3, [pc, #172]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5ea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c5ec:	f023 0207 	bic.w	r2, r3, #7
3418c5f0:	687b      	ldr	r3, [r7, #4]
3418c5f2:	691b      	ldr	r3, [r3, #16]
3418c5f4:	4928      	ldr	r1, [pc, #160]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c5f6:	4313      	orrs	r3, r2
3418c5f8:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418c5fa:	687b      	ldr	r3, [r7, #4]
3418c5fc:	681b      	ldr	r3, [r3, #0]
3418c5fe:	f003 0310 	and.w	r3, r3, #16
3418c602:	2b00      	cmp	r3, #0
3418c604:	d010      	beq.n	3418c628 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418c606:	687b      	ldr	r3, [r7, #4]
3418c608:	695a      	ldr	r2, [r3, #20]
3418c60a:	4b23      	ldr	r3, [pc, #140]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c60c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c60e:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418c612:	429a      	cmp	r2, r3
3418c614:	d208      	bcs.n	3418c628 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418c616:	4b20      	ldr	r3, [pc, #128]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c618:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c61a:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418c61e:	687b      	ldr	r3, [r7, #4]
3418c620:	695b      	ldr	r3, [r3, #20]
3418c622:	491d      	ldr	r1, [pc, #116]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c624:	4313      	orrs	r3, r2
3418c626:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418c628:	687b      	ldr	r3, [r7, #4]
3418c62a:	681b      	ldr	r3, [r3, #0]
3418c62c:	f003 0320 	and.w	r3, r3, #32
3418c630:	2b00      	cmp	r3, #0
3418c632:	d010      	beq.n	3418c656 <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418c634:	687b      	ldr	r3, [r7, #4]
3418c636:	699a      	ldr	r2, [r3, #24]
3418c638:	4b17      	ldr	r3, [pc, #92]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c63a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c63c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418c640:	429a      	cmp	r2, r3
3418c642:	d208      	bcs.n	3418c656 <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418c644:	4b14      	ldr	r3, [pc, #80]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c646:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c648:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418c64c:	687b      	ldr	r3, [r7, #4]
3418c64e:	699b      	ldr	r3, [r3, #24]
3418c650:	4911      	ldr	r1, [pc, #68]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c652:	4313      	orrs	r3, r2
3418c654:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418c656:	687b      	ldr	r3, [r7, #4]
3418c658:	681b      	ldr	r3, [r3, #0]
3418c65a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418c65e:	2b00      	cmp	r3, #0
3418c660:	d010      	beq.n	3418c684 <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418c662:	687b      	ldr	r3, [r7, #4]
3418c664:	69da      	ldr	r2, [r3, #28]
3418c666:	4b0c      	ldr	r3, [pc, #48]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c668:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c66a:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418c66e:	429a      	cmp	r2, r3
3418c670:	d208      	bcs.n	3418c684 <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418c672:	4b09      	ldr	r3, [pc, #36]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c674:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c676:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418c67a:	687b      	ldr	r3, [r7, #4]
3418c67c:	69db      	ldr	r3, [r3, #28]
3418c67e:	4906      	ldr	r1, [pc, #24]	@ (3418c698 <HAL_RCC_ClockConfig+0x400>)
3418c680:	4313      	orrs	r3, r2
3418c682:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3418c684:	4b05      	ldr	r3, [pc, #20]	@ (3418c69c <HAL_RCC_ClockConfig+0x404>)
3418c686:	681b      	ldr	r3, [r3, #0]
3418c688:	4618      	mov	r0, r3
3418c68a:	f7f8 fe17 	bl	341852bc <HAL_InitTick>
3418c68e:	4603      	mov	r3, r0
}
3418c690:	4618      	mov	r0, r3
3418c692:	3710      	adds	r7, #16
3418c694:	46bd      	mov	sp, r7
3418c696:	bd80      	pop	{r7, pc}
3418c698:	56028000 	.word	0x56028000
3418c69c:	341c0028 	.word	0x341c0028

3418c6a0 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
3418c6a0:	b580      	push	{r7, lr}
3418c6a2:	b082      	sub	sp, #8
3418c6a4:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3418c6a6:	2300      	movs	r3, #0
3418c6a8:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3418c6aa:	f7ff f89f 	bl	3418b7ec <LL_RCC_GetCpuClkSource>
3418c6ae:	4603      	mov	r3, r0
3418c6b0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c6b4:	d026      	beq.n	3418c704 <HAL_RCC_GetCpuClockFreq+0x64>
3418c6b6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418c6ba:	d861      	bhi.n	3418c780 <HAL_RCC_GetCpuClockFreq+0xe0>
3418c6bc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418c6c0:	d01d      	beq.n	3418c6fe <HAL_RCC_GetCpuClockFreq+0x5e>
3418c6c2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418c6c6:	d85b      	bhi.n	3418c780 <HAL_RCC_GetCpuClockFreq+0xe0>
3418c6c8:	2b00      	cmp	r3, #0
3418c6ca:	d003      	beq.n	3418c6d4 <HAL_RCC_GetCpuClockFreq+0x34>
3418c6cc:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418c6d0:	d009      	beq.n	3418c6e6 <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418c6d2:	e055      	b.n	3418c780 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418c6d4:	f7fe ffce 	bl	3418b674 <LL_RCC_HSI_GetDivider>
3418c6d8:	4603      	mov	r3, r0
3418c6da:	09db      	lsrs	r3, r3, #7
3418c6dc:	4a2b      	ldr	r2, [pc, #172]	@ (3418c78c <HAL_RCC_GetCpuClockFreq+0xec>)
3418c6de:	fa22 f303 	lsr.w	r3, r2, r3
3418c6e2:	607b      	str	r3, [r7, #4]
      break;
3418c6e4:	e04d      	b.n	3418c782 <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = RCC_GET_MSI_FREQUENCY();
3418c6e6:	4b2a      	ldr	r3, [pc, #168]	@ (3418c790 <HAL_RCC_GetCpuClockFreq+0xf0>)
3418c6e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418c6ea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418c6ee:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418c6f2:	d101      	bne.n	3418c6f8 <HAL_RCC_GetCpuClockFreq+0x58>
3418c6f4:	4b27      	ldr	r3, [pc, #156]	@ (3418c794 <HAL_RCC_GetCpuClockFreq+0xf4>)
3418c6f6:	e000      	b.n	3418c6fa <HAL_RCC_GetCpuClockFreq+0x5a>
3418c6f8:	4b27      	ldr	r3, [pc, #156]	@ (3418c798 <HAL_RCC_GetCpuClockFreq+0xf8>)
3418c6fa:	607b      	str	r3, [r7, #4]
      break;
3418c6fc:	e041      	b.n	3418c782 <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = HSE_VALUE;
3418c6fe:	4b27      	ldr	r3, [pc, #156]	@ (3418c79c <HAL_RCC_GetCpuClockFreq+0xfc>)
3418c700:	607b      	str	r3, [r7, #4]
      break;
3418c702:	e03e      	b.n	3418c782 <HAL_RCC_GetCpuClockFreq+0xe2>
      ic_divider = LL_RCC_IC1_GetDivider();
3418c704:	f7ff f99e 	bl	3418ba44 <LL_RCC_IC1_GetDivider>
3418c708:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
3418c70a:	f7ff f98d 	bl	3418ba28 <LL_RCC_IC1_GetSource>
3418c70e:	4603      	mov	r3, r0
3418c710:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c714:	d029      	beq.n	3418c76a <HAL_RCC_GetCpuClockFreq+0xca>
3418c716:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c71a:	d82f      	bhi.n	3418c77c <HAL_RCC_GetCpuClockFreq+0xdc>
3418c71c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c720:	d01a      	beq.n	3418c758 <HAL_RCC_GetCpuClockFreq+0xb8>
3418c722:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c726:	d829      	bhi.n	3418c77c <HAL_RCC_GetCpuClockFreq+0xdc>
3418c728:	2b00      	cmp	r3, #0
3418c72a:	d003      	beq.n	3418c734 <HAL_RCC_GetCpuClockFreq+0x94>
3418c72c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c730:	d009      	beq.n	3418c746 <HAL_RCC_GetCpuClockFreq+0xa6>
          break;
3418c732:	e023      	b.n	3418c77c <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418c734:	f004 fed4 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3418c738:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418c73a:	687a      	ldr	r2, [r7, #4]
3418c73c:	683b      	ldr	r3, [r7, #0]
3418c73e:	fbb2 f3f3 	udiv	r3, r2, r3
3418c742:	607b      	str	r3, [r7, #4]
          break;
3418c744:	e01b      	b.n	3418c77e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418c746:	f004 ff11 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3418c74a:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418c74c:	687a      	ldr	r2, [r7, #4]
3418c74e:	683b      	ldr	r3, [r7, #0]
3418c750:	fbb2 f3f3 	udiv	r3, r2, r3
3418c754:	607b      	str	r3, [r7, #4]
          break;
3418c756:	e012      	b.n	3418c77e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418c758:	f004 ff4e 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3418c75c:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418c75e:	687a      	ldr	r2, [r7, #4]
3418c760:	683b      	ldr	r3, [r7, #0]
3418c762:	fbb2 f3f3 	udiv	r3, r2, r3
3418c766:	607b      	str	r3, [r7, #4]
          break;
3418c768:	e009      	b.n	3418c77e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418c76a:	f004 ff8b 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3418c76e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418c770:	687a      	ldr	r2, [r7, #4]
3418c772:	683b      	ldr	r3, [r7, #0]
3418c774:	fbb2 f3f3 	udiv	r3, r2, r3
3418c778:	607b      	str	r3, [r7, #4]
          break;
3418c77a:	e000      	b.n	3418c77e <HAL_RCC_GetCpuClockFreq+0xde>
          break;
3418c77c:	bf00      	nop
      break;
3418c77e:	e000      	b.n	3418c782 <HAL_RCC_GetCpuClockFreq+0xe2>
      break;
3418c780:	bf00      	nop
  }

  return frequency;
3418c782:	687b      	ldr	r3, [r7, #4]
}
3418c784:	4618      	mov	r0, r3
3418c786:	3708      	adds	r7, #8
3418c788:	46bd      	mov	sp, r7
3418c78a:	bd80      	pop	{r7, pc}
3418c78c:	03d09000 	.word	0x03d09000
3418c790:	56028000 	.word	0x56028000
3418c794:	00f42400 	.word	0x00f42400
3418c798:	003d0900 	.word	0x003d0900
3418c79c:	02dc6c00 	.word	0x02dc6c00

3418c7a0 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
3418c7a0:	b598      	push	{r3, r4, r7, lr}
3418c7a2:	af00      	add	r7, sp, #0
  return RCC_GetSysClockFreq(LL_RCC_IC2_GetSource(), LL_RCC_IC2_GetDivider());
3418c7a4:	f7ff f95e 	bl	3418ba64 <LL_RCC_IC2_GetSource>
3418c7a8:	4604      	mov	r4, r0
3418c7aa:	f7ff f969 	bl	3418ba80 <LL_RCC_IC2_GetDivider>
3418c7ae:	4603      	mov	r3, r0
3418c7b0:	4619      	mov	r1, r3
3418c7b2:	4620      	mov	r0, r4
3418c7b4:	f000 f88e 	bl	3418c8d4 <RCC_GetSysClockFreq>
3418c7b8:	4603      	mov	r3, r0
}
3418c7ba:	4618      	mov	r0, r3
3418c7bc:	bd98      	pop	{r3, r4, r7, pc}

3418c7be <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
3418c7be:	b598      	push	{r3, r4, r7, lr}
3418c7c0:	af00      	add	r7, sp, #0
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3418c7c2:	f7ff ffed 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3418c7c6:	4604      	mov	r4, r0
3418c7c8:	f7ff f82c 	bl	3418b824 <LL_RCC_GetAHBPrescaler>
3418c7cc:	4603      	mov	r3, r0
3418c7ce:	0d1b      	lsrs	r3, r3, #20
3418c7d0:	f003 0307 	and.w	r3, r3, #7
3418c7d4:	40dc      	lsrs	r4, r3
3418c7d6:	f7ff f833 	bl	3418b840 <LL_RCC_GetAPB1Prescaler>
3418c7da:	4603      	mov	r3, r0
3418c7dc:	f003 0307 	and.w	r3, r3, #7
3418c7e0:	fa24 f303 	lsr.w	r3, r4, r3
                                LL_RCC_GetAPB1Prescaler());
}
3418c7e4:	4618      	mov	r0, r3
3418c7e6:	bd98      	pop	{r3, r4, r7, pc}

3418c7e8 <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418c7e8:	b480      	push	{r7}
3418c7ea:	b085      	sub	sp, #20
3418c7ec:	af00      	add	r7, sp, #0
3418c7ee:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
3418c7f0:	687b      	ldr	r3, [r7, #4]
3418c7f2:	227f      	movs	r2, #127	@ 0x7f
3418c7f4:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
3418c7f6:	4b36      	ldr	r3, [pc, #216]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c7f8:	6a1b      	ldr	r3, [r3, #32]
3418c7fa:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
3418c7fc:	68fb      	ldr	r3, [r7, #12]
3418c7fe:	091b      	lsrs	r3, r3, #4
3418c800:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
3418c804:	687b      	ldr	r3, [r7, #4]
3418c806:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
3418c808:	68fb      	ldr	r3, [r7, #12]
3418c80a:	091b      	lsrs	r3, r3, #4
3418c80c:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
3418c810:	687b      	ldr	r3, [r7, #4]
3418c812:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
3418c814:	4b2e      	ldr	r3, [pc, #184]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c816:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418c818:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
3418c81a:	68fb      	ldr	r3, [r7, #12]
3418c81c:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
3418c820:	687b      	ldr	r3, [r7, #4]
3418c822:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
3418c824:	68fb      	ldr	r3, [r7, #12]
3418c826:	f003 0207 	and.w	r2, r3, #7
3418c82a:	687b      	ldr	r3, [r7, #4]
3418c82c:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
3418c82e:	68fb      	ldr	r3, [r7, #12]
3418c830:	f003 0270 	and.w	r2, r3, #112	@ 0x70
3418c834:	687b      	ldr	r3, [r7, #4]
3418c836:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
3418c838:	68fb      	ldr	r3, [r7, #12]
3418c83a:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
3418c83e:	687b      	ldr	r3, [r7, #4]
3418c840:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
3418c842:	68fb      	ldr	r3, [r7, #12]
3418c844:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
3418c848:	687b      	ldr	r3, [r7, #4]
3418c84a:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
3418c84c:	4b20      	ldr	r3, [pc, #128]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c84e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418c852:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
3418c854:	68fb      	ldr	r3, [r7, #12]
3418c856:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418c85a:	687b      	ldr	r3, [r7, #4]
3418c85c:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
3418c85e:	68fb      	ldr	r3, [r7, #12]
3418c860:	0c1b      	lsrs	r3, r3, #16
3418c862:	b2db      	uxtb	r3, r3
3418c864:	1c5a      	adds	r2, r3, #1
3418c866:	687b      	ldr	r3, [r7, #4]
3418c868:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
3418c86a:	4b19      	ldr	r3, [pc, #100]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c86c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418c870:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
3418c872:	68fb      	ldr	r3, [r7, #12]
3418c874:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418c878:	687b      	ldr	r3, [r7, #4]
3418c87a:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
3418c87c:	68fb      	ldr	r3, [r7, #12]
3418c87e:	0c1b      	lsrs	r3, r3, #16
3418c880:	b2db      	uxtb	r3, r3
3418c882:	1c5a      	adds	r2, r3, #1
3418c884:	687b      	ldr	r3, [r7, #4]
3418c886:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
3418c888:	4b11      	ldr	r3, [pc, #68]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c88a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418c88e:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
3418c890:	68fb      	ldr	r3, [r7, #12]
3418c892:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418c896:	687b      	ldr	r3, [r7, #4]
3418c898:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
3418c89a:	68fb      	ldr	r3, [r7, #12]
3418c89c:	0c1b      	lsrs	r3, r3, #16
3418c89e:	b2db      	uxtb	r3, r3
3418c8a0:	1c5a      	adds	r2, r3, #1
3418c8a2:	687b      	ldr	r3, [r7, #4]
3418c8a4:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
3418c8a6:	4b0a      	ldr	r3, [pc, #40]	@ (3418c8d0 <HAL_RCC_GetClockConfig+0xe8>)
3418c8a8:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418c8ac:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
3418c8ae:	68fb      	ldr	r3, [r7, #12]
3418c8b0:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418c8b4:	687b      	ldr	r3, [r7, #4]
3418c8b6:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
3418c8b8:	68fb      	ldr	r3, [r7, #12]
3418c8ba:	0c1b      	lsrs	r3, r3, #16
3418c8bc:	b2db      	uxtb	r3, r3
3418c8be:	1c5a      	adds	r2, r3, #1
3418c8c0:	687b      	ldr	r3, [r7, #4]
3418c8c2:	63da      	str	r2, [r3, #60]	@ 0x3c
}
3418c8c4:	bf00      	nop
3418c8c6:	3714      	adds	r7, #20
3418c8c8:	46bd      	mov	sp, r7
3418c8ca:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c8ce:	4770      	bx	lr
3418c8d0:	56028000 	.word	0x56028000

3418c8d4 <RCC_GetSysClockFreq>:
  * @param  icx_divider The intermediate clock divider
  *
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreq(uint32_t icx_source, uint32_t icx_divider)
{
3418c8d4:	b580      	push	{r7, lr}
3418c8d6:	b084      	sub	sp, #16
3418c8d8:	af00      	add	r7, sp, #0
3418c8da:	6078      	str	r0, [r7, #4]
3418c8dc:	6039      	str	r1, [r7, #0]
  uint32_t frequency = 0U;
3418c8de:	2300      	movs	r3, #0
3418c8e0:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3418c8e2:	f7fe ff91 	bl	3418b808 <LL_RCC_GetSysClkSource>
3418c8e6:	4603      	mov	r3, r0
3418c8e8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c8ec:	d026      	beq.n	3418c93c <RCC_GetSysClockFreq+0x68>
3418c8ee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c8f2:	d861      	bhi.n	3418c9b8 <RCC_GetSysClockFreq+0xe4>
3418c8f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c8f8:	d01d      	beq.n	3418c936 <RCC_GetSysClockFreq+0x62>
3418c8fa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c8fe:	d85b      	bhi.n	3418c9b8 <RCC_GetSysClockFreq+0xe4>
3418c900:	2b00      	cmp	r3, #0
3418c902:	d003      	beq.n	3418c90c <RCC_GetSysClockFreq+0x38>
3418c904:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c908:	d009      	beq.n	3418c91e <RCC_GetSysClockFreq+0x4a>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418c90a:	e055      	b.n	3418c9b8 <RCC_GetSysClockFreq+0xe4>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418c90c:	f7fe feb2 	bl	3418b674 <LL_RCC_HSI_GetDivider>
3418c910:	4603      	mov	r3, r0
3418c912:	09db      	lsrs	r3, r3, #7
3418c914:	4a2b      	ldr	r2, [pc, #172]	@ (3418c9c4 <RCC_GetSysClockFreq+0xf0>)
3418c916:	fa22 f303 	lsr.w	r3, r2, r3
3418c91a:	60fb      	str	r3, [r7, #12]
      break;
3418c91c:	e04d      	b.n	3418c9ba <RCC_GetSysClockFreq+0xe6>
      frequency = RCC_GET_MSI_FREQUENCY();
3418c91e:	4b2a      	ldr	r3, [pc, #168]	@ (3418c9c8 <RCC_GetSysClockFreq+0xf4>)
3418c920:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418c922:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418c926:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418c92a:	d101      	bne.n	3418c930 <RCC_GetSysClockFreq+0x5c>
3418c92c:	4b27      	ldr	r3, [pc, #156]	@ (3418c9cc <RCC_GetSysClockFreq+0xf8>)
3418c92e:	e000      	b.n	3418c932 <RCC_GetSysClockFreq+0x5e>
3418c930:	4b27      	ldr	r3, [pc, #156]	@ (3418c9d0 <RCC_GetSysClockFreq+0xfc>)
3418c932:	60fb      	str	r3, [r7, #12]
      break;
3418c934:	e041      	b.n	3418c9ba <RCC_GetSysClockFreq+0xe6>
      frequency = HSE_VALUE;
3418c936:	4b27      	ldr	r3, [pc, #156]	@ (3418c9d4 <RCC_GetSysClockFreq+0x100>)
3418c938:	60fb      	str	r3, [r7, #12]
      break;
3418c93a:	e03e      	b.n	3418c9ba <RCC_GetSysClockFreq+0xe6>
      switch (icx_source)
3418c93c:	687b      	ldr	r3, [r7, #4]
3418c93e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c942:	d02e      	beq.n	3418c9a2 <RCC_GetSysClockFreq+0xce>
3418c944:	687b      	ldr	r3, [r7, #4]
3418c946:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418c94a:	d833      	bhi.n	3418c9b4 <RCC_GetSysClockFreq+0xe0>
3418c94c:	687b      	ldr	r3, [r7, #4]
3418c94e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c952:	d01d      	beq.n	3418c990 <RCC_GetSysClockFreq+0xbc>
3418c954:	687b      	ldr	r3, [r7, #4]
3418c956:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418c95a:	d82b      	bhi.n	3418c9b4 <RCC_GetSysClockFreq+0xe0>
3418c95c:	687b      	ldr	r3, [r7, #4]
3418c95e:	2b00      	cmp	r3, #0
3418c960:	d004      	beq.n	3418c96c <RCC_GetSysClockFreq+0x98>
3418c962:	687b      	ldr	r3, [r7, #4]
3418c964:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418c968:	d009      	beq.n	3418c97e <RCC_GetSysClockFreq+0xaa>
          break;
3418c96a:	e023      	b.n	3418c9b4 <RCC_GetSysClockFreq+0xe0>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418c96c:	f004 fdb8 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3418c970:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418c972:	68fa      	ldr	r2, [r7, #12]
3418c974:	683b      	ldr	r3, [r7, #0]
3418c976:	fbb2 f3f3 	udiv	r3, r2, r3
3418c97a:	60fb      	str	r3, [r7, #12]
          break;
3418c97c:	e01b      	b.n	3418c9b6 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418c97e:	f004 fdf5 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3418c982:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418c984:	68fa      	ldr	r2, [r7, #12]
3418c986:	683b      	ldr	r3, [r7, #0]
3418c988:	fbb2 f3f3 	udiv	r3, r2, r3
3418c98c:	60fb      	str	r3, [r7, #12]
          break;
3418c98e:	e012      	b.n	3418c9b6 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418c990:	f004 fe32 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3418c994:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418c996:	68fa      	ldr	r2, [r7, #12]
3418c998:	683b      	ldr	r3, [r7, #0]
3418c99a:	fbb2 f3f3 	udiv	r3, r2, r3
3418c99e:	60fb      	str	r3, [r7, #12]
          break;
3418c9a0:	e009      	b.n	3418c9b6 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418c9a2:	f004 fe6f 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3418c9a6:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418c9a8:	68fa      	ldr	r2, [r7, #12]
3418c9aa:	683b      	ldr	r3, [r7, #0]
3418c9ac:	fbb2 f3f3 	udiv	r3, r2, r3
3418c9b0:	60fb      	str	r3, [r7, #12]
          break;
3418c9b2:	e000      	b.n	3418c9b6 <RCC_GetSysClockFreq+0xe2>
          break;
3418c9b4:	bf00      	nop
      break;
3418c9b6:	e000      	b.n	3418c9ba <RCC_GetSysClockFreq+0xe6>
      break;
3418c9b8:	bf00      	nop
  }

  return frequency;
3418c9ba:	68fb      	ldr	r3, [r7, #12]
}
3418c9bc:	4618      	mov	r0, r3
3418c9be:	3710      	adds	r7, #16
3418c9c0:	46bd      	mov	sp, r7
3418c9c2:	bd80      	pop	{r7, pc}
3418c9c4:	03d09000 	.word	0x03d09000
3418c9c8:	56028000 	.word	0x56028000
3418c9cc:	00f42400 	.word	0x00f42400
3418c9d0:	003d0900 	.word	0x003d0900
3418c9d4:	02dc6c00 	.word	0x02dc6c00

3418c9d8 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418c9d8:	b580      	push	{r7, lr}
3418c9da:	b088      	sub	sp, #32
3418c9dc:	af00      	add	r7, sp, #0
3418c9de:	6078      	str	r0, [r7, #4]
3418c9e0:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3418c9e2:	2300      	movs	r3, #0
3418c9e4:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418c9e6:	687b      	ldr	r3, [r7, #4]
3418c9e8:	011a      	lsls	r2, r3, #4
3418c9ea:	4b8e      	ldr	r3, [pc, #568]	@ (3418cc24 <RCC_PLL_Config+0x24c>)
3418c9ec:	4413      	add	r3, r2
3418c9ee:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418c9f0:	687b      	ldr	r3, [r7, #4]
3418c9f2:	011a      	lsls	r2, r3, #4
3418c9f4:	4b8c      	ldr	r3, [pc, #560]	@ (3418cc28 <RCC_PLL_Config+0x250>)
3418c9f6:	4413      	add	r3, r2
3418c9f8:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418c9fa:	687b      	ldr	r3, [r7, #4]
3418c9fc:	011a      	lsls	r2, r3, #4
3418c9fe:	4b8b      	ldr	r3, [pc, #556]	@ (3418cc2c <RCC_PLL_Config+0x254>)
3418ca00:	4413      	add	r3, r2
3418ca02:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3418ca04:	683b      	ldr	r3, [r7, #0]
3418ca06:	681b      	ldr	r3, [r3, #0]
3418ca08:	2b02      	cmp	r3, #2
3418ca0a:	f040 8091 	bne.w	3418cb30 <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418ca0e:	4a88      	ldr	r2, [pc, #544]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418ca10:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ca14:	687b      	ldr	r3, [r7, #4]
3418ca16:	fa01 f303 	lsl.w	r3, r1, r3
3418ca1a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418ca1e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418ca20:	f7f8 fc96 	bl	34185350 <HAL_GetTick>
3418ca24:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ca26:	e008      	b.n	3418ca3a <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418ca28:	f7f8 fc92 	bl	34185350 <HAL_GetTick>
3418ca2c:	4602      	mov	r2, r0
3418ca2e:	68fb      	ldr	r3, [r7, #12]
3418ca30:	1ad3      	subs	r3, r2, r3
3418ca32:	2b01      	cmp	r3, #1
3418ca34:	d901      	bls.n	3418ca3a <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
3418ca36:	2303      	movs	r3, #3
3418ca38:	e0f0      	b.n	3418cc1c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ca3a:	4b7d      	ldr	r3, [pc, #500]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418ca3c:	685a      	ldr	r2, [r3, #4]
3418ca3e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ca42:	687b      	ldr	r3, [r7, #4]
3418ca44:	fa01 f303 	lsl.w	r3, r1, r3
3418ca48:	401a      	ands	r2, r3
3418ca4a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ca4e:	687b      	ldr	r3, [r7, #4]
3418ca50:	fa01 f303 	lsl.w	r3, r1, r3
3418ca54:	429a      	cmp	r2, r3
3418ca56:	d0e7      	beq.n	3418ca28 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3418ca58:	693b      	ldr	r3, [r7, #16]
3418ca5a:	681b      	ldr	r3, [r3, #0]
3418ca5c:	f043 0204 	orr.w	r2, r3, #4
3418ca60:	693b      	ldr	r3, [r7, #16]
3418ca62:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418ca64:	69bb      	ldr	r3, [r7, #24]
3418ca66:	681b      	ldr	r3, [r3, #0]
3418ca68:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418ca6c:	69bb      	ldr	r3, [r7, #24]
3418ca6e:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3418ca70:	69bb      	ldr	r3, [r7, #24]
3418ca72:	681a      	ldr	r2, [r3, #0]
3418ca74:	4b6f      	ldr	r3, [pc, #444]	@ (3418cc34 <RCC_PLL_Config+0x25c>)
3418ca76:	4013      	ands	r3, r2
3418ca78:	683a      	ldr	r2, [r7, #0]
3418ca7a:	6851      	ldr	r1, [r2, #4]
3418ca7c:	683a      	ldr	r2, [r7, #0]
3418ca7e:	6892      	ldr	r2, [r2, #8]
3418ca80:	0512      	lsls	r2, r2, #20
3418ca82:	4311      	orrs	r1, r2
3418ca84:	683a      	ldr	r2, [r7, #0]
3418ca86:	6912      	ldr	r2, [r2, #16]
3418ca88:	0212      	lsls	r2, r2, #8
3418ca8a:	430a      	orrs	r2, r1
3418ca8c:	431a      	orrs	r2, r3
3418ca8e:	69bb      	ldr	r3, [r7, #24]
3418ca90:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3418ca92:	693b      	ldr	r3, [r7, #16]
3418ca94:	681b      	ldr	r3, [r3, #0]
3418ca96:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3418ca9a:	683b      	ldr	r3, [r7, #0]
3418ca9c:	695b      	ldr	r3, [r3, #20]
3418ca9e:	06d9      	lsls	r1, r3, #27
3418caa0:	683b      	ldr	r3, [r7, #0]
3418caa2:	699b      	ldr	r3, [r3, #24]
3418caa4:	061b      	lsls	r3, r3, #24
3418caa6:	430b      	orrs	r3, r1
3418caa8:	431a      	orrs	r2, r3
3418caaa:	693b      	ldr	r3, [r7, #16]
3418caac:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3418caae:	697b      	ldr	r3, [r7, #20]
3418cab0:	681b      	ldr	r3, [r3, #0]
3418cab2:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3418cab6:	683b      	ldr	r3, [r7, #0]
3418cab8:	68db      	ldr	r3, [r3, #12]
3418caba:	431a      	orrs	r2, r3
3418cabc:	697b      	ldr	r3, [r7, #20]
3418cabe:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3418cac0:	693b      	ldr	r3, [r7, #16]
3418cac2:	681b      	ldr	r3, [r3, #0]
3418cac4:	f023 0208 	bic.w	r2, r3, #8
3418cac8:	693b      	ldr	r3, [r7, #16]
3418caca:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
3418cacc:	683b      	ldr	r3, [r7, #0]
3418cace:	68db      	ldr	r3, [r3, #12]
3418cad0:	2b00      	cmp	r3, #0
3418cad2:	d005      	beq.n	3418cae0 <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3418cad4:	693b      	ldr	r3, [r7, #16]
3418cad6:	681b      	ldr	r3, [r3, #0]
3418cad8:	f043 020a 	orr.w	r2, r3, #10
3418cadc:	693b      	ldr	r3, [r7, #16]
3418cade:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3418cae0:	693b      	ldr	r3, [r7, #16]
3418cae2:	681b      	ldr	r3, [r3, #0]
3418cae4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3418cae8:	f043 0301 	orr.w	r3, r3, #1
3418caec:	693a      	ldr	r2, [r7, #16]
3418caee:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418caf0:	4a4f      	ldr	r2, [pc, #316]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418caf2:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418caf6:	687b      	ldr	r3, [r7, #4]
3418caf8:	fa01 f303 	lsl.w	r3, r1, r3
3418cafc:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418cb00:	f7f8 fc26 	bl	34185350 <HAL_GetTick>
3418cb04:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418cb06:	e008      	b.n	3418cb1a <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418cb08:	f7f8 fc22 	bl	34185350 <HAL_GetTick>
3418cb0c:	4602      	mov	r2, r0
3418cb0e:	68fb      	ldr	r3, [r7, #12]
3418cb10:	1ad3      	subs	r3, r2, r3
3418cb12:	2b01      	cmp	r3, #1
3418cb14:	d901      	bls.n	3418cb1a <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
3418cb16:	2303      	movs	r3, #3
3418cb18:	e080      	b.n	3418cc1c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418cb1a:	4b45      	ldr	r3, [pc, #276]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418cb1c:	685a      	ldr	r2, [r3, #4]
3418cb1e:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cb22:	687b      	ldr	r3, [r7, #4]
3418cb24:	fa01 f303 	lsl.w	r3, r1, r3
3418cb28:	4013      	ands	r3, r2
3418cb2a:	2b00      	cmp	r3, #0
3418cb2c:	d0ec      	beq.n	3418cb08 <RCC_PLL_Config+0x130>
3418cb2e:	e074      	b.n	3418cc1a <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3418cb30:	683b      	ldr	r3, [r7, #0]
3418cb32:	681b      	ldr	r3, [r3, #0]
3418cb34:	2b03      	cmp	r3, #3
3418cb36:	d13b      	bne.n	3418cbb0 <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3418cb38:	683b      	ldr	r3, [r7, #0]
3418cb3a:	685b      	ldr	r3, [r3, #4]
3418cb3c:	4618      	mov	r0, r3
3418cb3e:	f000 f921 	bl	3418cd84 <RCC_PLL_Source_IsReady>
3418cb42:	4603      	mov	r3, r0
3418cb44:	2b01      	cmp	r3, #1
3418cb46:	d130      	bne.n	3418cbaa <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418cb48:	4a39      	ldr	r2, [pc, #228]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418cb4a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cb4e:	687b      	ldr	r3, [r7, #4]
3418cb50:	fa01 f303 	lsl.w	r3, r1, r3
3418cb54:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418cb58:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418cb5a:	f7f8 fbf9 	bl	34185350 <HAL_GetTick>
3418cb5e:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418cb60:	e008      	b.n	3418cb74 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418cb62:	f7f8 fbf5 	bl	34185350 <HAL_GetTick>
3418cb66:	4602      	mov	r2, r0
3418cb68:	68fb      	ldr	r3, [r7, #12]
3418cb6a:	1ad3      	subs	r3, r2, r3
3418cb6c:	2b01      	cmp	r3, #1
3418cb6e:	d901      	bls.n	3418cb74 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
3418cb70:	2303      	movs	r3, #3
3418cb72:	e053      	b.n	3418cc1c <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418cb74:	4b2e      	ldr	r3, [pc, #184]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418cb76:	685a      	ldr	r2, [r3, #4]
3418cb78:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cb7c:	687b      	ldr	r3, [r7, #4]
3418cb7e:	fa01 f303 	lsl.w	r3, r1, r3
3418cb82:	401a      	ands	r2, r3
3418cb84:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cb88:	687b      	ldr	r3, [r7, #4]
3418cb8a:	fa01 f303 	lsl.w	r3, r1, r3
3418cb8e:	429a      	cmp	r2, r3
3418cb90:	d0e7      	beq.n	3418cb62 <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3418cb92:	69bb      	ldr	r3, [r7, #24]
3418cb94:	681b      	ldr	r3, [r3, #0]
3418cb96:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3418cb9a:	683b      	ldr	r3, [r7, #0]
3418cb9c:	685b      	ldr	r3, [r3, #4]
3418cb9e:	4313      	orrs	r3, r2
3418cba0:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418cba4:	69bb      	ldr	r3, [r7, #24]
3418cba6:	601a      	str	r2, [r3, #0]
3418cba8:	e037      	b.n	3418cc1a <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3418cbaa:	2301      	movs	r3, #1
3418cbac:	77fb      	strb	r3, [r7, #31]
3418cbae:	e034      	b.n	3418cc1a <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3418cbb0:	683b      	ldr	r3, [r7, #0]
3418cbb2:	681b      	ldr	r3, [r3, #0]
3418cbb4:	2b01      	cmp	r3, #1
3418cbb6:	d130      	bne.n	3418cc1a <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3418cbb8:	693b      	ldr	r3, [r7, #16]
3418cbba:	681b      	ldr	r3, [r3, #0]
3418cbbc:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3418cbc0:	693b      	ldr	r3, [r7, #16]
3418cbc2:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418cbc4:	4a1a      	ldr	r2, [pc, #104]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418cbc6:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cbca:	687b      	ldr	r3, [r7, #4]
3418cbcc:	fa01 f303 	lsl.w	r3, r1, r3
3418cbd0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418cbd4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418cbd6:	f7f8 fbbb 	bl	34185350 <HAL_GetTick>
3418cbda:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418cbdc:	e008      	b.n	3418cbf0 <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418cbde:	f7f8 fbb7 	bl	34185350 <HAL_GetTick>
3418cbe2:	4602      	mov	r2, r0
3418cbe4:	68fb      	ldr	r3, [r7, #12]
3418cbe6:	1ad3      	subs	r3, r2, r3
3418cbe8:	2b01      	cmp	r3, #1
3418cbea:	d901      	bls.n	3418cbf0 <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
3418cbec:	2303      	movs	r3, #3
3418cbee:	e015      	b.n	3418cc1c <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418cbf0:	4b0f      	ldr	r3, [pc, #60]	@ (3418cc30 <RCC_PLL_Config+0x258>)
3418cbf2:	685a      	ldr	r2, [r3, #4]
3418cbf4:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cbf8:	687b      	ldr	r3, [r7, #4]
3418cbfa:	fa01 f303 	lsl.w	r3, r1, r3
3418cbfe:	401a      	ands	r2, r3
3418cc00:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cc04:	687b      	ldr	r3, [r7, #4]
3418cc06:	fa01 f303 	lsl.w	r3, r1, r3
3418cc0a:	429a      	cmp	r2, r3
3418cc0c:	d0e7      	beq.n	3418cbde <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418cc0e:	69bb      	ldr	r3, [r7, #24]
3418cc10:	681b      	ldr	r3, [r3, #0]
3418cc12:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418cc16:	69bb      	ldr	r3, [r7, #24]
3418cc18:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3418cc1a:	7ffb      	ldrb	r3, [r7, #31]
}
3418cc1c:	4618      	mov	r0, r3
3418cc1e:	3720      	adds	r7, #32
3418cc20:	46bd      	mov	sp, r7
3418cc22:	bd80      	pop	{r7, pc}
3418cc24:	56028080 	.word	0x56028080
3418cc28:	56028084 	.word	0x56028084
3418cc2c:	56028088 	.word	0x56028088
3418cc30:	56028000 	.word	0x56028000
3418cc34:	8c0000ff 	.word	0x8c0000ff

3418cc38 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
3418cc38:	b580      	push	{r7, lr}
3418cc3a:	b084      	sub	sp, #16
3418cc3c:	af00      	add	r7, sp, #0
3418cc3e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
3418cc40:	2300      	movs	r3, #0
3418cc42:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418cc44:	4a11      	ldr	r2, [pc, #68]	@ (3418cc8c <RCC_PLL_Enable+0x54>)
3418cc46:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cc4a:	687b      	ldr	r3, [r7, #4]
3418cc4c:	fa01 f303 	lsl.w	r3, r1, r3
3418cc50:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
3418cc54:	f7f8 fb7c 	bl	34185350 <HAL_GetTick>
3418cc58:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418cc5a:	e008      	b.n	3418cc6e <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418cc5c:	f7f8 fb78 	bl	34185350 <HAL_GetTick>
3418cc60:	4602      	mov	r2, r0
3418cc62:	68bb      	ldr	r3, [r7, #8]
3418cc64:	1ad3      	subs	r3, r2, r3
3418cc66:	2b01      	cmp	r3, #1
3418cc68:	d901      	bls.n	3418cc6e <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3418cc6a:	2303      	movs	r3, #3
3418cc6c:	e00a      	b.n	3418cc84 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418cc6e:	4b07      	ldr	r3, [pc, #28]	@ (3418cc8c <RCC_PLL_Enable+0x54>)
3418cc70:	685a      	ldr	r2, [r3, #4]
3418cc72:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cc76:	687b      	ldr	r3, [r7, #4]
3418cc78:	fa01 f303 	lsl.w	r3, r1, r3
3418cc7c:	4013      	ands	r3, r2
3418cc7e:	2b00      	cmp	r3, #0
3418cc80:	d0ec      	beq.n	3418cc5c <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3418cc82:	7bfb      	ldrb	r3, [r7, #15]
}
3418cc84:	4618      	mov	r0, r3
3418cc86:	3710      	adds	r7, #16
3418cc88:	46bd      	mov	sp, r7
3418cc8a:	bd80      	pop	{r7, pc}
3418cc8c:	56028000 	.word	0x56028000

3418cc90 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418cc90:	b480      	push	{r7}
3418cc92:	b089      	sub	sp, #36	@ 0x24
3418cc94:	af00      	add	r7, sp, #0
3418cc96:	6078      	str	r0, [r7, #4]
3418cc98:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3418cc9a:	2300      	movs	r3, #0
3418cc9c:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418cc9e:	687b      	ldr	r3, [r7, #4]
3418cca0:	011a      	lsls	r2, r3, #4
3418cca2:	4b34      	ldr	r3, [pc, #208]	@ (3418cd74 <RCC_PLL_IsNewConfig+0xe4>)
3418cca4:	4413      	add	r3, r2
3418cca6:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418cca8:	687b      	ldr	r3, [r7, #4]
3418ccaa:	011a      	lsls	r2, r3, #4
3418ccac:	4b32      	ldr	r3, [pc, #200]	@ (3418cd78 <RCC_PLL_IsNewConfig+0xe8>)
3418ccae:	4413      	add	r3, r2
3418ccb0:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418ccb2:	687b      	ldr	r3, [r7, #4]
3418ccb4:	011a      	lsls	r2, r3, #4
3418ccb6:	4b31      	ldr	r3, [pc, #196]	@ (3418cd7c <RCC_PLL_IsNewConfig+0xec>)
3418ccb8:	4413      	add	r3, r2
3418ccba:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418ccbc:	697b      	ldr	r3, [r7, #20]
3418ccbe:	681b      	ldr	r3, [r3, #0]
3418ccc0:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3418ccc4:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
3418ccc8:	683a      	ldr	r2, [r7, #0]
3418ccca:	6851      	ldr	r1, [r2, #4]
3418cccc:	683a      	ldr	r2, [r7, #0]
3418ccce:	6892      	ldr	r2, [r2, #8]
3418ccd0:	0512      	lsls	r2, r2, #20
3418ccd2:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3418ccd4:	683a      	ldr	r2, [r7, #0]
3418ccd6:	6912      	ldr	r2, [r2, #16]
3418ccd8:	0212      	lsls	r2, r2, #8
3418ccda:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418ccdc:	4293      	cmp	r3, r2
3418ccde:	d002      	beq.n	3418cce6 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3418cce0:	2301      	movs	r3, #1
3418cce2:	61fb      	str	r3, [r7, #28]
3418cce4:	e03e      	b.n	3418cd64 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418cce6:	693b      	ldr	r3, [r7, #16]
3418cce8:	681b      	ldr	r3, [r3, #0]
3418ccea:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3418ccee:	683b      	ldr	r3, [r7, #0]
3418ccf0:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418ccf2:	429a      	cmp	r2, r3
3418ccf4:	d002      	beq.n	3418ccfc <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3418ccf6:	2301      	movs	r3, #1
3418ccf8:	61fb      	str	r3, [r7, #28]
3418ccfa:	e033      	b.n	3418cd64 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418ccfc:	68fb      	ldr	r3, [r7, #12]
3418ccfe:	681b      	ldr	r3, [r3, #0]
3418cd00:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3418cd04:	683b      	ldr	r3, [r7, #0]
3418cd06:	695b      	ldr	r3, [r3, #20]
3418cd08:	06d9      	lsls	r1, r3, #27
3418cd0a:	683b      	ldr	r3, [r7, #0]
3418cd0c:	699b      	ldr	r3, [r3, #24]
3418cd0e:	061b      	lsls	r3, r3, #24
3418cd10:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418cd12:	429a      	cmp	r2, r3
3418cd14:	d002      	beq.n	3418cd1c <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
3418cd16:	2301      	movs	r3, #1
3418cd18:	61fb      	str	r3, [r7, #28]
3418cd1a:	e023      	b.n	3418cd64 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418cd1c:	4b18      	ldr	r3, [pc, #96]	@ (3418cd80 <RCC_PLL_IsNewConfig+0xf0>)
3418cd1e:	685a      	ldr	r2, [r3, #4]
3418cd20:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cd24:	687b      	ldr	r3, [r7, #4]
3418cd26:	fa01 f303 	lsl.w	r3, r1, r3
3418cd2a:	401a      	ands	r2, r3
3418cd2c:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418cd30:	687b      	ldr	r3, [r7, #4]
3418cd32:	fa01 f303 	lsl.w	r3, r1, r3
3418cd36:	429a      	cmp	r2, r3
3418cd38:	d102      	bne.n	3418cd40 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3418cd3a:	2302      	movs	r3, #2
3418cd3c:	61bb      	str	r3, [r7, #24]
3418cd3e:	e00a      	b.n	3418cd56 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
3418cd40:	697b      	ldr	r3, [r7, #20]
3418cd42:	681b      	ldr	r3, [r3, #0]
3418cd44:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418cd48:	2b00      	cmp	r3, #0
3418cd4a:	d002      	beq.n	3418cd52 <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3418cd4c:	2303      	movs	r3, #3
3418cd4e:	61bb      	str	r3, [r7, #24]
3418cd50:	e001      	b.n	3418cd56 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3418cd52:	2301      	movs	r3, #1
3418cd54:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3418cd56:	683b      	ldr	r3, [r7, #0]
3418cd58:	681b      	ldr	r3, [r3, #0]
3418cd5a:	69ba      	ldr	r2, [r7, #24]
3418cd5c:	429a      	cmp	r2, r3
3418cd5e:	d001      	beq.n	3418cd64 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3418cd60:	2301      	movs	r3, #1
3418cd62:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3418cd64:	69fb      	ldr	r3, [r7, #28]
}
3418cd66:	4618      	mov	r0, r3
3418cd68:	3724      	adds	r7, #36	@ 0x24
3418cd6a:	46bd      	mov	sp, r7
3418cd6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cd70:	4770      	bx	lr
3418cd72:	bf00      	nop
3418cd74:	56028080 	.word	0x56028080
3418cd78:	56028084 	.word	0x56028084
3418cd7c:	56028088 	.word	0x56028088
3418cd80:	56028000 	.word	0x56028000

3418cd84 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3418cd84:	b580      	push	{r7, lr}
3418cd86:	b084      	sub	sp, #16
3418cd88:	af00      	add	r7, sp, #0
3418cd8a:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3418cd8c:	2301      	movs	r3, #1
3418cd8e:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3418cd90:	687b      	ldr	r3, [r7, #4]
3418cd92:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cd96:	d01b      	beq.n	3418cdd0 <RCC_PLL_Source_IsReady+0x4c>
3418cd98:	687b      	ldr	r3, [r7, #4]
3418cd9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cd9e:	d81f      	bhi.n	3418cde0 <RCC_PLL_Source_IsReady+0x5c>
3418cda0:	687b      	ldr	r3, [r7, #4]
3418cda2:	2b00      	cmp	r3, #0
3418cda4:	d004      	beq.n	3418cdb0 <RCC_PLL_Source_IsReady+0x2c>
3418cda6:	687b      	ldr	r3, [r7, #4]
3418cda8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418cdac:	d008      	beq.n	3418cdc0 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3418cdae:	e017      	b.n	3418cde0 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3418cdb0:	f7fe fc3a 	bl	3418b628 <LL_RCC_HSI_IsReady>
3418cdb4:	4603      	mov	r3, r0
3418cdb6:	2b00      	cmp	r3, #0
3418cdb8:	d114      	bne.n	3418cde4 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3418cdba:	2300      	movs	r3, #0
3418cdbc:	60fb      	str	r3, [r7, #12]
      break;
3418cdbe:	e011      	b.n	3418cde4 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3418cdc0:	f7fe fc9a 	bl	3418b6f8 <LL_RCC_MSI_IsReady>
3418cdc4:	4603      	mov	r3, r0
3418cdc6:	2b00      	cmp	r3, #0
3418cdc8:	d10e      	bne.n	3418cde8 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3418cdca:	2300      	movs	r3, #0
3418cdcc:	60fb      	str	r3, [r7, #12]
      break;
3418cdce:	e00b      	b.n	3418cde8 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3418cdd0:	f7fe fbfa 	bl	3418b5c8 <LL_RCC_HSE_IsReady>
3418cdd4:	4603      	mov	r3, r0
3418cdd6:	2b00      	cmp	r3, #0
3418cdd8:	d108      	bne.n	3418cdec <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3418cdda:	2300      	movs	r3, #0
3418cddc:	60fb      	str	r3, [r7, #12]
      break;
3418cdde:	e005      	b.n	3418cdec <RCC_PLL_Source_IsReady+0x68>
      break;
3418cde0:	bf00      	nop
3418cde2:	e004      	b.n	3418cdee <RCC_PLL_Source_IsReady+0x6a>
      break;
3418cde4:	bf00      	nop
3418cde6:	e002      	b.n	3418cdee <RCC_PLL_Source_IsReady+0x6a>
      break;
3418cde8:	bf00      	nop
3418cdea:	e000      	b.n	3418cdee <RCC_PLL_Source_IsReady+0x6a>
      break;
3418cdec:	bf00      	nop
  }

  return ret;
3418cdee:	68fb      	ldr	r3, [r7, #12]
}
3418cdf0:	4618      	mov	r0, r3
3418cdf2:	3710      	adds	r7, #16
3418cdf4:	46bd      	mov	sp, r7
3418cdf6:	bd80      	pop	{r7, pc}

3418cdf8 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
3418cdf8:	b580      	push	{r7, lr}
3418cdfa:	b084      	sub	sp, #16
3418cdfc:	af00      	add	r7, sp, #0
3418cdfe:	6078      	str	r0, [r7, #4]
3418ce00:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
3418ce02:	2301      	movs	r3, #1
3418ce04:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
3418ce06:	687b      	ldr	r3, [r7, #4]
3418ce08:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ce0c:	d03a      	beq.n	3418ce84 <RCC_IC_CheckPLLSources+0x8c>
3418ce0e:	687b      	ldr	r3, [r7, #4]
3418ce10:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ce14:	d843      	bhi.n	3418ce9e <RCC_IC_CheckPLLSources+0xa6>
3418ce16:	687b      	ldr	r3, [r7, #4]
3418ce18:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ce1c:	d025      	beq.n	3418ce6a <RCC_IC_CheckPLLSources+0x72>
3418ce1e:	687b      	ldr	r3, [r7, #4]
3418ce20:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ce24:	d83b      	bhi.n	3418ce9e <RCC_IC_CheckPLLSources+0xa6>
3418ce26:	687b      	ldr	r3, [r7, #4]
3418ce28:	2b00      	cmp	r3, #0
3418ce2a:	d004      	beq.n	3418ce36 <RCC_IC_CheckPLLSources+0x3e>
3418ce2c:	687b      	ldr	r3, [r7, #4]
3418ce2e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418ce32:	d00d      	beq.n	3418ce50 <RCC_IC_CheckPLLSources+0x58>
3418ce34:	e033      	b.n	3418ce9e <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418ce36:	f7fe fd1f 	bl	3418b878 <LL_RCC_PLL1_IsReady>
3418ce3a:	4603      	mov	r3, r0
3418ce3c:	2b00      	cmp	r3, #0
3418ce3e:	d131      	bne.n	3418cea4 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418ce40:	f7fe fd2e 	bl	3418b8a0 <LL_RCC_PLL1_IsEnabledBypass>
3418ce44:	4603      	mov	r3, r0
3418ce46:	2b00      	cmp	r3, #0
3418ce48:	d12c      	bne.n	3418cea4 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3418ce4a:	2300      	movs	r3, #0
3418ce4c:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418ce4e:	e029      	b.n	3418cea4 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418ce50:	f7fe fd48 	bl	3418b8e4 <LL_RCC_PLL2_IsReady>
3418ce54:	4603      	mov	r3, r0
3418ce56:	2b00      	cmp	r3, #0
3418ce58:	d126      	bne.n	3418cea8 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418ce5a:	f7fe fd57 	bl	3418b90c <LL_RCC_PLL2_IsEnabledBypass>
3418ce5e:	4603      	mov	r3, r0
3418ce60:	2b00      	cmp	r3, #0
3418ce62:	d121      	bne.n	3418cea8 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3418ce64:	2300      	movs	r3, #0
3418ce66:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418ce68:	e01e      	b.n	3418cea8 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418ce6a:	f7fe fd71 	bl	3418b950 <LL_RCC_PLL3_IsReady>
3418ce6e:	4603      	mov	r3, r0
3418ce70:	2b00      	cmp	r3, #0
3418ce72:	d11b      	bne.n	3418ceac <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418ce74:	f7fe fd80 	bl	3418b978 <LL_RCC_PLL3_IsEnabledBypass>
3418ce78:	4603      	mov	r3, r0
3418ce7a:	2b00      	cmp	r3, #0
3418ce7c:	d116      	bne.n	3418ceac <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3418ce7e:	2300      	movs	r3, #0
3418ce80:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418ce82:	e013      	b.n	3418ceac <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418ce84:	f7fe fd9a 	bl	3418b9bc <LL_RCC_PLL4_IsReady>
3418ce88:	4603      	mov	r3, r0
3418ce8a:	2b00      	cmp	r3, #0
3418ce8c:	d110      	bne.n	3418ceb0 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418ce8e:	f7fe fda9 	bl	3418b9e4 <LL_RCC_PLL4_IsEnabledBypass>
3418ce92:	4603      	mov	r3, r0
3418ce94:	2b00      	cmp	r3, #0
3418ce96:	d10b      	bne.n	3418ceb0 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
3418ce98:	2300      	movs	r3, #0
3418ce9a:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418ce9c:	e008      	b.n	3418ceb0 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3418ce9e:	2300      	movs	r3, #0
3418cea0:	60fb      	str	r3, [r7, #12]
      break;
3418cea2:	e006      	b.n	3418ceb2 <RCC_IC_CheckPLLSources+0xba>
      break;
3418cea4:	bf00      	nop
3418cea6:	e004      	b.n	3418ceb2 <RCC_IC_CheckPLLSources+0xba>
      break;
3418cea8:	bf00      	nop
3418ceaa:	e002      	b.n	3418ceb2 <RCC_IC_CheckPLLSources+0xba>
      break;
3418ceac:	bf00      	nop
3418ceae:	e000      	b.n	3418ceb2 <RCC_IC_CheckPLLSources+0xba>
      break;
3418ceb0:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3418ceb2:	683b      	ldr	r3, [r7, #0]
3418ceb4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418ceb8:	d03a      	beq.n	3418cf30 <RCC_IC_CheckPLLSources+0x138>
3418ceba:	683b      	ldr	r3, [r7, #0]
3418cebc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418cec0:	d843      	bhi.n	3418cf4a <RCC_IC_CheckPLLSources+0x152>
3418cec2:	683b      	ldr	r3, [r7, #0]
3418cec4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cec8:	d025      	beq.n	3418cf16 <RCC_IC_CheckPLLSources+0x11e>
3418ceca:	683b      	ldr	r3, [r7, #0]
3418cecc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ced0:	d83b      	bhi.n	3418cf4a <RCC_IC_CheckPLLSources+0x152>
3418ced2:	683b      	ldr	r3, [r7, #0]
3418ced4:	2b00      	cmp	r3, #0
3418ced6:	d004      	beq.n	3418cee2 <RCC_IC_CheckPLLSources+0xea>
3418ced8:	683b      	ldr	r3, [r7, #0]
3418ceda:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418cede:	d00d      	beq.n	3418cefc <RCC_IC_CheckPLLSources+0x104>
3418cee0:	e033      	b.n	3418cf4a <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418cee2:	f7fe fcc9 	bl	3418b878 <LL_RCC_PLL1_IsReady>
3418cee6:	4603      	mov	r3, r0
3418cee8:	2b00      	cmp	r3, #0
3418ceea:	d131      	bne.n	3418cf50 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418ceec:	f7fe fcd8 	bl	3418b8a0 <LL_RCC_PLL1_IsEnabledBypass>
3418cef0:	4603      	mov	r3, r0
3418cef2:	2b00      	cmp	r3, #0
3418cef4:	d12c      	bne.n	3418cf50 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3418cef6:	2300      	movs	r3, #0
3418cef8:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418cefa:	e029      	b.n	3418cf50 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418cefc:	f7fe fcf2 	bl	3418b8e4 <LL_RCC_PLL2_IsReady>
3418cf00:	4603      	mov	r3, r0
3418cf02:	2b00      	cmp	r3, #0
3418cf04:	d126      	bne.n	3418cf54 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418cf06:	f7fe fd01 	bl	3418b90c <LL_RCC_PLL2_IsEnabledBypass>
3418cf0a:	4603      	mov	r3, r0
3418cf0c:	2b00      	cmp	r3, #0
3418cf0e:	d121      	bne.n	3418cf54 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
3418cf10:	2300      	movs	r3, #0
3418cf12:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418cf14:	e01e      	b.n	3418cf54 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418cf16:	f7fe fd1b 	bl	3418b950 <LL_RCC_PLL3_IsReady>
3418cf1a:	4603      	mov	r3, r0
3418cf1c:	2b00      	cmp	r3, #0
3418cf1e:	d11b      	bne.n	3418cf58 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418cf20:	f7fe fd2a 	bl	3418b978 <LL_RCC_PLL3_IsEnabledBypass>
3418cf24:	4603      	mov	r3, r0
3418cf26:	2b00      	cmp	r3, #0
3418cf28:	d116      	bne.n	3418cf58 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3418cf2a:	2300      	movs	r3, #0
3418cf2c:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418cf2e:	e013      	b.n	3418cf58 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418cf30:	f7fe fd44 	bl	3418b9bc <LL_RCC_PLL4_IsReady>
3418cf34:	4603      	mov	r3, r0
3418cf36:	2b00      	cmp	r3, #0
3418cf38:	d110      	bne.n	3418cf5c <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418cf3a:	f7fe fd53 	bl	3418b9e4 <LL_RCC_PLL4_IsEnabledBypass>
3418cf3e:	4603      	mov	r3, r0
3418cf40:	2b00      	cmp	r3, #0
3418cf42:	d10b      	bne.n	3418cf5c <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
3418cf44:	2300      	movs	r3, #0
3418cf46:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418cf48:	e008      	b.n	3418cf5c <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3418cf4a:	2300      	movs	r3, #0
3418cf4c:	60fb      	str	r3, [r7, #12]
      break;
3418cf4e:	e006      	b.n	3418cf5e <RCC_IC_CheckPLLSources+0x166>
      break;
3418cf50:	bf00      	nop
3418cf52:	e004      	b.n	3418cf5e <RCC_IC_CheckPLLSources+0x166>
      break;
3418cf54:	bf00      	nop
3418cf56:	e002      	b.n	3418cf5e <RCC_IC_CheckPLLSources+0x166>
      break;
3418cf58:	bf00      	nop
3418cf5a:	e000      	b.n	3418cf5e <RCC_IC_CheckPLLSources+0x166>
      break;
3418cf5c:	bf00      	nop
  }

  return ret;
3418cf5e:	68fb      	ldr	r3, [r7, #12]
}
3418cf60:	4618      	mov	r0, r3
3418cf62:	3710      	adds	r7, #16
3418cf64:	46bd      	mov	sp, r7
3418cf66:	bd80      	pop	{r7, pc}

3418cf68 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
3418cf68:	b480      	push	{r7}
3418cf6a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418cf6c:	4b05      	ldr	r3, [pc, #20]	@ (3418cf84 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418cf6e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf70:	4a04      	ldr	r2, [pc, #16]	@ (3418cf84 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418cf72:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3418cf76:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418cf78:	bf00      	nop
3418cf7a:	46bd      	mov	sp, r7
3418cf7c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cf80:	4770      	bx	lr
3418cf82:	bf00      	nop
3418cf84:	56028000 	.word	0x56028000

3418cf88 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
3418cf88:	b480      	push	{r7}
3418cf8a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418cf8c:	4b05      	ldr	r3, [pc, #20]	@ (3418cfa4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418cf8e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf90:	4a04      	ldr	r2, [pc, #16]	@ (3418cfa4 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418cf92:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3418cf96:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418cf98:	bf00      	nop
3418cf9a:	46bd      	mov	sp, r7
3418cf9c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cfa0:	4770      	bx	lr
3418cfa2:	bf00      	nop
3418cfa4:	56028000 	.word	0x56028000

3418cfa8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
3418cfa8:	b480      	push	{r7}
3418cfaa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3418cfac:	4b06      	ldr	r3, [pc, #24]	@ (3418cfc8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
3418cfae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cfb0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418cfb4:	2b40      	cmp	r3, #64	@ 0x40
3418cfb6:	d101      	bne.n	3418cfbc <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
3418cfb8:	2301      	movs	r3, #1
3418cfba:	e000      	b.n	3418cfbe <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
3418cfbc:	2300      	movs	r3, #0
}
3418cfbe:	4618      	mov	r0, r3
3418cfc0:	46bd      	mov	sp, r7
3418cfc2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cfc6:	4770      	bx	lr
3418cfc8:	56028000 	.word	0x56028000

3418cfcc <LL_RCC_HSE_IsReady>:
{
3418cfcc:	b480      	push	{r7}
3418cfce:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3418cfd0:	4b06      	ldr	r3, [pc, #24]	@ (3418cfec <LL_RCC_HSE_IsReady+0x20>)
3418cfd2:	685b      	ldr	r3, [r3, #4]
3418cfd4:	f003 0310 	and.w	r3, r3, #16
3418cfd8:	2b00      	cmp	r3, #0
3418cfda:	d001      	beq.n	3418cfe0 <LL_RCC_HSE_IsReady+0x14>
3418cfdc:	2301      	movs	r3, #1
3418cfde:	e000      	b.n	3418cfe2 <LL_RCC_HSE_IsReady+0x16>
3418cfe0:	2300      	movs	r3, #0
}
3418cfe2:	4618      	mov	r0, r3
3418cfe4:	46bd      	mov	sp, r7
3418cfe6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cfea:	4770      	bx	lr
3418cfec:	56028000 	.word	0x56028000

3418cff0 <LL_RCC_HSI_IsReady>:
{
3418cff0:	b480      	push	{r7}
3418cff2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418cff4:	4b06      	ldr	r3, [pc, #24]	@ (3418d010 <LL_RCC_HSI_IsReady+0x20>)
3418cff6:	685b      	ldr	r3, [r3, #4]
3418cff8:	f003 0308 	and.w	r3, r3, #8
3418cffc:	2b00      	cmp	r3, #0
3418cffe:	d001      	beq.n	3418d004 <LL_RCC_HSI_IsReady+0x14>
3418d000:	2301      	movs	r3, #1
3418d002:	e000      	b.n	3418d006 <LL_RCC_HSI_IsReady+0x16>
3418d004:	2300      	movs	r3, #0
}
3418d006:	4618      	mov	r0, r3
3418d008:	46bd      	mov	sp, r7
3418d00a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d00e:	4770      	bx	lr
3418d010:	56028000 	.word	0x56028000

3418d014 <LL_RCC_HSI_GetDivider>:
{
3418d014:	b480      	push	{r7}
3418d016:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418d018:	4b04      	ldr	r3, [pc, #16]	@ (3418d02c <LL_RCC_HSI_GetDivider+0x18>)
3418d01a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418d01c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418d020:	4618      	mov	r0, r3
3418d022:	46bd      	mov	sp, r7
3418d024:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d028:	4770      	bx	lr
3418d02a:	bf00      	nop
3418d02c:	56028000 	.word	0x56028000

3418d030 <LL_RCC_MSI_IsReady>:
{
3418d030:	b480      	push	{r7}
3418d032:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3418d034:	4b06      	ldr	r3, [pc, #24]	@ (3418d050 <LL_RCC_MSI_IsReady+0x20>)
3418d036:	685b      	ldr	r3, [r3, #4]
3418d038:	f003 0304 	and.w	r3, r3, #4
3418d03c:	2b00      	cmp	r3, #0
3418d03e:	d001      	beq.n	3418d044 <LL_RCC_MSI_IsReady+0x14>
3418d040:	2301      	movs	r3, #1
3418d042:	e000      	b.n	3418d046 <LL_RCC_MSI_IsReady+0x16>
3418d044:	2300      	movs	r3, #0
}
3418d046:	4618      	mov	r0, r3
3418d048:	46bd      	mov	sp, r7
3418d04a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d04e:	4770      	bx	lr
3418d050:	56028000 	.word	0x56028000

3418d054 <LL_RCC_MSI_GetFrequency>:
{
3418d054:	b480      	push	{r7}
3418d056:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3418d058:	4b04      	ldr	r3, [pc, #16]	@ (3418d06c <LL_RCC_MSI_GetFrequency+0x18>)
3418d05a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418d05c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3418d060:	4618      	mov	r0, r3
3418d062:	46bd      	mov	sp, r7
3418d064:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d068:	4770      	bx	lr
3418d06a:	bf00      	nop
3418d06c:	56028000 	.word	0x56028000

3418d070 <LL_RCC_LSE_IsReady>:
{
3418d070:	b480      	push	{r7}
3418d072:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418d074:	4b06      	ldr	r3, [pc, #24]	@ (3418d090 <LL_RCC_LSE_IsReady+0x20>)
3418d076:	685b      	ldr	r3, [r3, #4]
3418d078:	f003 0302 	and.w	r3, r3, #2
3418d07c:	2b00      	cmp	r3, #0
3418d07e:	d001      	beq.n	3418d084 <LL_RCC_LSE_IsReady+0x14>
3418d080:	2301      	movs	r3, #1
3418d082:	e000      	b.n	3418d086 <LL_RCC_LSE_IsReady+0x16>
3418d084:	2300      	movs	r3, #0
}
3418d086:	4618      	mov	r0, r3
3418d088:	46bd      	mov	sp, r7
3418d08a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d08e:	4770      	bx	lr
3418d090:	56028000 	.word	0x56028000

3418d094 <LL_RCC_LSI_IsReady>:
{
3418d094:	b480      	push	{r7}
3418d096:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418d098:	4b04      	ldr	r3, [pc, #16]	@ (3418d0ac <LL_RCC_LSI_IsReady+0x18>)
3418d09a:	685b      	ldr	r3, [r3, #4]
3418d09c:	f003 0301 	and.w	r3, r3, #1
}
3418d0a0:	4618      	mov	r0, r3
3418d0a2:	46bd      	mov	sp, r7
3418d0a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d0a8:	4770      	bx	lr
3418d0aa:	bf00      	nop
3418d0ac:	56028000 	.word	0x56028000

3418d0b0 <LL_RCC_GetAHBPrescaler>:
{
3418d0b0:	b480      	push	{r7}
3418d0b2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3418d0b4:	4b04      	ldr	r3, [pc, #16]	@ (3418d0c8 <LL_RCC_GetAHBPrescaler+0x18>)
3418d0b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d0b8:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3418d0bc:	4618      	mov	r0, r3
3418d0be:	46bd      	mov	sp, r7
3418d0c0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d0c4:	4770      	bx	lr
3418d0c6:	bf00      	nop
3418d0c8:	56028000 	.word	0x56028000

3418d0cc <LL_RCC_GetAPB1Prescaler>:
{
3418d0cc:	b480      	push	{r7}
3418d0ce:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418d0d0:	4b04      	ldr	r3, [pc, #16]	@ (3418d0e4 <LL_RCC_GetAPB1Prescaler+0x18>)
3418d0d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d0d4:	f003 0307 	and.w	r3, r3, #7
}
3418d0d8:	4618      	mov	r0, r3
3418d0da:	46bd      	mov	sp, r7
3418d0dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d0e0:	4770      	bx	lr
3418d0e2:	bf00      	nop
3418d0e4:	56028000 	.word	0x56028000

3418d0e8 <LL_RCC_GetAPB2Prescaler>:
{
3418d0e8:	b480      	push	{r7}
3418d0ea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418d0ec:	4b04      	ldr	r3, [pc, #16]	@ (3418d100 <LL_RCC_GetAPB2Prescaler+0x18>)
3418d0ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d0f0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3418d0f4:	4618      	mov	r0, r3
3418d0f6:	46bd      	mov	sp, r7
3418d0f8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d0fc:	4770      	bx	lr
3418d0fe:	bf00      	nop
3418d100:	56028000 	.word	0x56028000

3418d104 <LL_RCC_GetAPB4Prescaler>:
{
3418d104:	b480      	push	{r7}
3418d106:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3418d108:	4b04      	ldr	r3, [pc, #16]	@ (3418d11c <LL_RCC_GetAPB4Prescaler+0x18>)
3418d10a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d10c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
3418d110:	4618      	mov	r0, r3
3418d112:	46bd      	mov	sp, r7
3418d114:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d118:	4770      	bx	lr
3418d11a:	bf00      	nop
3418d11c:	56028000 	.word	0x56028000

3418d120 <LL_RCC_GetAPB5Prescaler>:
{
3418d120:	b480      	push	{r7}
3418d122:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3418d124:	4b04      	ldr	r3, [pc, #16]	@ (3418d138 <LL_RCC_GetAPB5Prescaler+0x18>)
3418d126:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d128:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3418d12c:	4618      	mov	r0, r3
3418d12e:	46bd      	mov	sp, r7
3418d130:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d134:	4770      	bx	lr
3418d136:	bf00      	nop
3418d138:	56028000 	.word	0x56028000

3418d13c <LL_RCC_SetClockSource>:
{
3418d13c:	b480      	push	{r7}
3418d13e:	b085      	sub	sp, #20
3418d140:	af00      	add	r7, sp, #0
3418d142:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3418d144:	687b      	ldr	r3, [r7, #4]
3418d146:	b2da      	uxtb	r2, r3
3418d148:	4b10      	ldr	r3, [pc, #64]	@ (3418d18c <LL_RCC_SetClockSource+0x50>)
3418d14a:	4413      	add	r3, r2
3418d14c:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3418d14e:	68fb      	ldr	r3, [r7, #12]
3418d150:	681a      	ldr	r2, [r3, #0]
3418d152:	687b      	ldr	r3, [r7, #4]
3418d154:	0e19      	lsrs	r1, r3, #24
3418d156:	687b      	ldr	r3, [r7, #4]
3418d158:	0a1b      	lsrs	r3, r3, #8
3418d15a:	f003 031f 	and.w	r3, r3, #31
3418d15e:	fa01 f303 	lsl.w	r3, r1, r3
3418d162:	43db      	mvns	r3, r3
3418d164:	401a      	ands	r2, r3
3418d166:	687b      	ldr	r3, [r7, #4]
3418d168:	0c1b      	lsrs	r3, r3, #16
3418d16a:	b2d9      	uxtb	r1, r3
3418d16c:	687b      	ldr	r3, [r7, #4]
3418d16e:	0a1b      	lsrs	r3, r3, #8
3418d170:	f003 031f 	and.w	r3, r3, #31
3418d174:	fa01 f303 	lsl.w	r3, r1, r3
3418d178:	431a      	orrs	r2, r3
3418d17a:	68fb      	ldr	r3, [r7, #12]
3418d17c:	601a      	str	r2, [r3, #0]
}
3418d17e:	bf00      	nop
3418d180:	3714      	adds	r7, #20
3418d182:	46bd      	mov	sp, r7
3418d184:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d188:	4770      	bx	lr
3418d18a:	bf00      	nop
3418d18c:	56028144 	.word	0x56028144

3418d190 <LL_RCC_GetADCPrescaler>:
{
3418d190:	b480      	push	{r7}
3418d192:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3418d194:	4b04      	ldr	r3, [pc, #16]	@ (3418d1a8 <LL_RCC_GetADCPrescaler+0x18>)
3418d196:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d19a:	0a1b      	lsrs	r3, r3, #8
3418d19c:	b2db      	uxtb	r3, r3
}
3418d19e:	4618      	mov	r0, r3
3418d1a0:	46bd      	mov	sp, r7
3418d1a2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d1a6:	4770      	bx	lr
3418d1a8:	56028000 	.word	0x56028000

3418d1ac <LL_RCC_SetADFClockSource>:
{
3418d1ac:	b480      	push	{r7}
3418d1ae:	b083      	sub	sp, #12
3418d1b0:	af00      	add	r7, sp, #0
3418d1b2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3418d1b4:	4b07      	ldr	r3, [pc, #28]	@ (3418d1d4 <LL_RCC_SetADFClockSource+0x28>)
3418d1b6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d1ba:	f023 0207 	bic.w	r2, r3, #7
3418d1be:	4905      	ldr	r1, [pc, #20]	@ (3418d1d4 <LL_RCC_SetADFClockSource+0x28>)
3418d1c0:	687b      	ldr	r3, [r7, #4]
3418d1c2:	4313      	orrs	r3, r2
3418d1c4:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3418d1c8:	bf00      	nop
3418d1ca:	370c      	adds	r7, #12
3418d1cc:	46bd      	mov	sp, r7
3418d1ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d1d2:	4770      	bx	lr
3418d1d4:	56028000 	.word	0x56028000

3418d1d8 <LL_RCC_SetCLKPClockSource>:
{
3418d1d8:	b480      	push	{r7}
3418d1da:	b083      	sub	sp, #12
3418d1dc:	af00      	add	r7, sp, #0
3418d1de:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3418d1e0:	4b07      	ldr	r3, [pc, #28]	@ (3418d200 <LL_RCC_SetCLKPClockSource+0x28>)
3418d1e2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d1e6:	f023 0207 	bic.w	r2, r3, #7
3418d1ea:	4905      	ldr	r1, [pc, #20]	@ (3418d200 <LL_RCC_SetCLKPClockSource+0x28>)
3418d1ec:	687b      	ldr	r3, [r7, #4]
3418d1ee:	4313      	orrs	r3, r2
3418d1f0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418d1f4:	bf00      	nop
3418d1f6:	370c      	adds	r7, #12
3418d1f8:	46bd      	mov	sp, r7
3418d1fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d1fe:	4770      	bx	lr
3418d200:	56028000 	.word	0x56028000

3418d204 <LL_RCC_SetDCMIPPClockSource>:
{
3418d204:	b480      	push	{r7}
3418d206:	b083      	sub	sp, #12
3418d208:	af00      	add	r7, sp, #0
3418d20a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3418d20c:	4b07      	ldr	r3, [pc, #28]	@ (3418d22c <LL_RCC_SetDCMIPPClockSource+0x28>)
3418d20e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d212:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
3418d216:	4905      	ldr	r1, [pc, #20]	@ (3418d22c <LL_RCC_SetDCMIPPClockSource+0x28>)
3418d218:	687b      	ldr	r3, [r7, #4]
3418d21a:	4313      	orrs	r3, r2
3418d21c:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3418d220:	bf00      	nop
3418d222:	370c      	adds	r7, #12
3418d224:	46bd      	mov	sp, r7
3418d226:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d22a:	4770      	bx	lr
3418d22c:	56028000 	.word	0x56028000

3418d230 <LL_RCC_SetETHClockSource>:
{
3418d230:	b480      	push	{r7}
3418d232:	b083      	sub	sp, #12
3418d234:	af00      	add	r7, sp, #0
3418d236:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3418d238:	4b07      	ldr	r3, [pc, #28]	@ (3418d258 <LL_RCC_SetETHClockSource+0x28>)
3418d23a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d23e:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3418d242:	4905      	ldr	r1, [pc, #20]	@ (3418d258 <LL_RCC_SetETHClockSource+0x28>)
3418d244:	687b      	ldr	r3, [r7, #4]
3418d246:	4313      	orrs	r3, r2
3418d248:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418d24c:	bf00      	nop
3418d24e:	370c      	adds	r7, #12
3418d250:	46bd      	mov	sp, r7
3418d252:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d256:	4770      	bx	lr
3418d258:	56028000 	.word	0x56028000

3418d25c <LL_RCC_SetETHPHYInterface>:
{
3418d25c:	b480      	push	{r7}
3418d25e:	b083      	sub	sp, #12
3418d260:	af00      	add	r7, sp, #0
3418d262:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3418d264:	4b07      	ldr	r3, [pc, #28]	@ (3418d284 <LL_RCC_SetETHPHYInterface+0x28>)
3418d266:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d26a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418d26e:	4905      	ldr	r1, [pc, #20]	@ (3418d284 <LL_RCC_SetETHPHYInterface+0x28>)
3418d270:	687b      	ldr	r3, [r7, #4]
3418d272:	4313      	orrs	r3, r2
3418d274:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418d278:	bf00      	nop
3418d27a:	370c      	adds	r7, #12
3418d27c:	46bd      	mov	sp, r7
3418d27e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d282:	4770      	bx	lr
3418d284:	56028000 	.word	0x56028000

3418d288 <LL_RCC_GetETH1PTPDivider>:
{
3418d288:	b480      	push	{r7}
3418d28a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3418d28c:	4b04      	ldr	r3, [pc, #16]	@ (3418d2a0 <LL_RCC_GetETH1PTPDivider+0x18>)
3418d28e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d292:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
3418d296:	4618      	mov	r0, r3
3418d298:	46bd      	mov	sp, r7
3418d29a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d29e:	4770      	bx	lr
3418d2a0:	56028000 	.word	0x56028000

3418d2a4 <LL_RCC_SetETHREFRXClockSource>:
{
3418d2a4:	b480      	push	{r7}
3418d2a6:	b083      	sub	sp, #12
3418d2a8:	af00      	add	r7, sp, #0
3418d2aa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3418d2ac:	4b07      	ldr	r3, [pc, #28]	@ (3418d2cc <LL_RCC_SetETHREFRXClockSource+0x28>)
3418d2ae:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d2b2:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
3418d2b6:	4905      	ldr	r1, [pc, #20]	@ (3418d2cc <LL_RCC_SetETHREFRXClockSource+0x28>)
3418d2b8:	687b      	ldr	r3, [r7, #4]
3418d2ba:	4313      	orrs	r3, r2
3418d2bc:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418d2c0:	bf00      	nop
3418d2c2:	370c      	adds	r7, #12
3418d2c4:	46bd      	mov	sp, r7
3418d2c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d2ca:	4770      	bx	lr
3418d2cc:	56028000 	.word	0x56028000

3418d2d0 <LL_RCC_SetETHREFTXClockSource>:
{
3418d2d0:	b480      	push	{r7}
3418d2d2:	b083      	sub	sp, #12
3418d2d4:	af00      	add	r7, sp, #0
3418d2d6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3418d2d8:	4b07      	ldr	r3, [pc, #28]	@ (3418d2f8 <LL_RCC_SetETHREFTXClockSource+0x28>)
3418d2da:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d2de:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418d2e2:	4905      	ldr	r1, [pc, #20]	@ (3418d2f8 <LL_RCC_SetETHREFTXClockSource+0x28>)
3418d2e4:	687b      	ldr	r3, [r7, #4]
3418d2e6:	4313      	orrs	r3, r2
3418d2e8:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418d2ec:	bf00      	nop
3418d2ee:	370c      	adds	r7, #12
3418d2f0:	46bd      	mov	sp, r7
3418d2f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d2f6:	4770      	bx	lr
3418d2f8:	56028000 	.word	0x56028000

3418d2fc <LL_RCC_SetFDCANClockSource>:
{
3418d2fc:	b480      	push	{r7}
3418d2fe:	b083      	sub	sp, #12
3418d300:	af00      	add	r7, sp, #0
3418d302:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3418d304:	4b07      	ldr	r3, [pc, #28]	@ (3418d324 <LL_RCC_SetFDCANClockSource+0x28>)
3418d306:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418d30a:	f023 0203 	bic.w	r2, r3, #3
3418d30e:	4905      	ldr	r1, [pc, #20]	@ (3418d324 <LL_RCC_SetFDCANClockSource+0x28>)
3418d310:	687b      	ldr	r3, [r7, #4]
3418d312:	4313      	orrs	r3, r2
3418d314:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3418d318:	bf00      	nop
3418d31a:	370c      	adds	r7, #12
3418d31c:	46bd      	mov	sp, r7
3418d31e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d322:	4770      	bx	lr
3418d324:	56028000 	.word	0x56028000

3418d328 <LL_RCC_SetFMCClockSource>:
{
3418d328:	b480      	push	{r7}
3418d32a:	b083      	sub	sp, #12
3418d32c:	af00      	add	r7, sp, #0
3418d32e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3418d330:	4b07      	ldr	r3, [pc, #28]	@ (3418d350 <LL_RCC_SetFMCClockSource+0x28>)
3418d332:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418d336:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3418d33a:	4905      	ldr	r1, [pc, #20]	@ (3418d350 <LL_RCC_SetFMCClockSource+0x28>)
3418d33c:	687b      	ldr	r3, [r7, #4]
3418d33e:	4313      	orrs	r3, r2
3418d340:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3418d344:	bf00      	nop
3418d346:	370c      	adds	r7, #12
3418d348:	46bd      	mov	sp, r7
3418d34a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d34e:	4770      	bx	lr
3418d350:	56028000 	.word	0x56028000

3418d354 <LL_RCC_SetI2CClockSource>:
{
3418d354:	b580      	push	{r7, lr}
3418d356:	b082      	sub	sp, #8
3418d358:	af00      	add	r7, sp, #0
3418d35a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d35c:	6878      	ldr	r0, [r7, #4]
3418d35e:	f7ff feed 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d362:	bf00      	nop
3418d364:	3708      	adds	r7, #8
3418d366:	46bd      	mov	sp, r7
3418d368:	bd80      	pop	{r7, pc}

3418d36a <LL_RCC_SetI3CClockSource>:
{
3418d36a:	b580      	push	{r7, lr}
3418d36c:	b082      	sub	sp, #8
3418d36e:	af00      	add	r7, sp, #0
3418d370:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d372:	6878      	ldr	r0, [r7, #4]
3418d374:	f7ff fee2 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d378:	bf00      	nop
3418d37a:	3708      	adds	r7, #8
3418d37c:	46bd      	mov	sp, r7
3418d37e:	bd80      	pop	{r7, pc}

3418d380 <LL_RCC_SetLPTIMClockSource>:
{
3418d380:	b580      	push	{r7, lr}
3418d382:	b082      	sub	sp, #8
3418d384:	af00      	add	r7, sp, #0
3418d386:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d388:	6878      	ldr	r0, [r7, #4]
3418d38a:	f7ff fed7 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d38e:	bf00      	nop
3418d390:	3708      	adds	r7, #8
3418d392:	46bd      	mov	sp, r7
3418d394:	bd80      	pop	{r7, pc}
	...

3418d398 <LL_RCC_SetLPUARTClockSource>:
{
3418d398:	b480      	push	{r7}
3418d39a:	b083      	sub	sp, #12
3418d39c:	af00      	add	r7, sp, #0
3418d39e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3418d3a0:	4b07      	ldr	r3, [pc, #28]	@ (3418d3c0 <LL_RCC_SetLPUARTClockSource+0x28>)
3418d3a2:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3418d3a6:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3418d3aa:	4905      	ldr	r1, [pc, #20]	@ (3418d3c0 <LL_RCC_SetLPUARTClockSource+0x28>)
3418d3ac:	687b      	ldr	r3, [r7, #4]
3418d3ae:	4313      	orrs	r3, r2
3418d3b0:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
3418d3b4:	bf00      	nop
3418d3b6:	370c      	adds	r7, #12
3418d3b8:	46bd      	mov	sp, r7
3418d3ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d3be:	4770      	bx	lr
3418d3c0:	56028000 	.word	0x56028000

3418d3c4 <LL_RCC_SetLTDCClockSource>:
{
3418d3c4:	b480      	push	{r7}
3418d3c6:	b083      	sub	sp, #12
3418d3c8:	af00      	add	r7, sp, #0
3418d3ca:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3418d3cc:	4b07      	ldr	r3, [pc, #28]	@ (3418d3ec <LL_RCC_SetLTDCClockSource+0x28>)
3418d3ce:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3418d3d2:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418d3d6:	4905      	ldr	r1, [pc, #20]	@ (3418d3ec <LL_RCC_SetLTDCClockSource+0x28>)
3418d3d8:	687b      	ldr	r3, [r7, #4]
3418d3da:	4313      	orrs	r3, r2
3418d3dc:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
3418d3e0:	bf00      	nop
3418d3e2:	370c      	adds	r7, #12
3418d3e4:	46bd      	mov	sp, r7
3418d3e6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d3ea:	4770      	bx	lr
3418d3ec:	56028000 	.word	0x56028000

3418d3f0 <LL_RCC_SetMDFClockSource>:
{
3418d3f0:	b480      	push	{r7}
3418d3f2:	b083      	sub	sp, #12
3418d3f4:	af00      	add	r7, sp, #0
3418d3f6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3418d3f8:	4b07      	ldr	r3, [pc, #28]	@ (3418d418 <LL_RCC_SetMDFClockSource+0x28>)
3418d3fa:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3418d3fe:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418d402:	4905      	ldr	r1, [pc, #20]	@ (3418d418 <LL_RCC_SetMDFClockSource+0x28>)
3418d404:	687b      	ldr	r3, [r7, #4]
3418d406:	4313      	orrs	r3, r2
3418d408:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
3418d40c:	bf00      	nop
3418d40e:	370c      	adds	r7, #12
3418d410:	46bd      	mov	sp, r7
3418d412:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d416:	4770      	bx	lr
3418d418:	56028000 	.word	0x56028000

3418d41c <LL_RCC_SetOTGPHYClockSource>:
{
3418d41c:	b580      	push	{r7, lr}
3418d41e:	b082      	sub	sp, #8
3418d420:	af00      	add	r7, sp, #0
3418d422:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d424:	6878      	ldr	r0, [r7, #4]
3418d426:	f7ff fe89 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d42a:	bf00      	nop
3418d42c:	3708      	adds	r7, #8
3418d42e:	46bd      	mov	sp, r7
3418d430:	bd80      	pop	{r7, pc}

3418d432 <LL_RCC_SetOTGPHYCKREFClockSource>:
{
3418d432:	b580      	push	{r7, lr}
3418d434:	b082      	sub	sp, #8
3418d436:	af00      	add	r7, sp, #0
3418d438:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d43a:	6878      	ldr	r0, [r7, #4]
3418d43c:	f7ff fe7e 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d440:	bf00      	nop
3418d442:	3708      	adds	r7, #8
3418d444:	46bd      	mov	sp, r7
3418d446:	bd80      	pop	{r7, pc}

3418d448 <LL_RCC_SetPSSIClockSource>:
{
3418d448:	b480      	push	{r7}
3418d44a:	b083      	sub	sp, #12
3418d44c:	af00      	add	r7, sp, #0
3418d44e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3418d450:	4b07      	ldr	r3, [pc, #28]	@ (3418d470 <LL_RCC_SetPSSIClockSource+0x28>)
3418d452:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d456:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3418d45a:	4905      	ldr	r1, [pc, #20]	@ (3418d470 <LL_RCC_SetPSSIClockSource+0x28>)
3418d45c:	687b      	ldr	r3, [r7, #4]
3418d45e:	4313      	orrs	r3, r2
3418d460:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418d464:	bf00      	nop
3418d466:	370c      	adds	r7, #12
3418d468:	46bd      	mov	sp, r7
3418d46a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d46e:	4770      	bx	lr
3418d470:	56028000 	.word	0x56028000

3418d474 <LL_RCC_SetSAIClockSource>:
{
3418d474:	b580      	push	{r7, lr}
3418d476:	b082      	sub	sp, #8
3418d478:	af00      	add	r7, sp, #0
3418d47a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d47c:	6878      	ldr	r0, [r7, #4]
3418d47e:	f7ff fe5d 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d482:	bf00      	nop
3418d484:	3708      	adds	r7, #8
3418d486:	46bd      	mov	sp, r7
3418d488:	bd80      	pop	{r7, pc}

3418d48a <LL_RCC_SetSDMMCClockSource>:
{
3418d48a:	b580      	push	{r7, lr}
3418d48c:	b082      	sub	sp, #8
3418d48e:	af00      	add	r7, sp, #0
3418d490:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d492:	6878      	ldr	r0, [r7, #4]
3418d494:	f7ff fe52 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d498:	bf00      	nop
3418d49a:	3708      	adds	r7, #8
3418d49c:	46bd      	mov	sp, r7
3418d49e:	bd80      	pop	{r7, pc}

3418d4a0 <LL_RCC_SetSPDIFRXClockSource>:
{
3418d4a0:	b480      	push	{r7}
3418d4a2:	b083      	sub	sp, #12
3418d4a4:	af00      	add	r7, sp, #0
3418d4a6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3418d4a8:	4b07      	ldr	r3, [pc, #28]	@ (3418d4c8 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3418d4aa:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3418d4ae:	f023 0207 	bic.w	r2, r3, #7
3418d4b2:	4905      	ldr	r1, [pc, #20]	@ (3418d4c8 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3418d4b4:	687b      	ldr	r3, [r7, #4]
3418d4b6:	4313      	orrs	r3, r2
3418d4b8:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
3418d4bc:	bf00      	nop
3418d4be:	370c      	adds	r7, #12
3418d4c0:	46bd      	mov	sp, r7
3418d4c2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d4c6:	4770      	bx	lr
3418d4c8:	56028000 	.word	0x56028000

3418d4cc <LL_RCC_SetSPIClockSource>:
{
3418d4cc:	b580      	push	{r7, lr}
3418d4ce:	b082      	sub	sp, #8
3418d4d0:	af00      	add	r7, sp, #0
3418d4d2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d4d4:	6878      	ldr	r0, [r7, #4]
3418d4d6:	f7ff fe31 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d4da:	bf00      	nop
3418d4dc:	3708      	adds	r7, #8
3418d4de:	46bd      	mov	sp, r7
3418d4e0:	bd80      	pop	{r7, pc}

3418d4e2 <LL_RCC_SetUSARTClockSource>:
{
3418d4e2:	b580      	push	{r7, lr}
3418d4e4:	b082      	sub	sp, #8
3418d4e6:	af00      	add	r7, sp, #0
3418d4e8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d4ea:	6878      	ldr	r0, [r7, #4]
3418d4ec:	f7ff fe26 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d4f0:	bf00      	nop
3418d4f2:	3708      	adds	r7, #8
3418d4f4:	46bd      	mov	sp, r7
3418d4f6:	bd80      	pop	{r7, pc}

3418d4f8 <LL_RCC_SetXSPIClockSource>:
{
3418d4f8:	b580      	push	{r7, lr}
3418d4fa:	b082      	sub	sp, #8
3418d4fc:	af00      	add	r7, sp, #0
3418d4fe:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418d500:	6878      	ldr	r0, [r7, #4]
3418d502:	f7ff fe1b 	bl	3418d13c <LL_RCC_SetClockSource>
}
3418d506:	bf00      	nop
3418d508:	3708      	adds	r7, #8
3418d50a:	46bd      	mov	sp, r7
3418d50c:	bd80      	pop	{r7, pc}
	...

3418d510 <LL_RCC_GetClockSource>:
{
3418d510:	b480      	push	{r7}
3418d512:	b085      	sub	sp, #20
3418d514:	af00      	add	r7, sp, #0
3418d516:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3418d518:	687b      	ldr	r3, [r7, #4]
3418d51a:	b2da      	uxtb	r2, r3
3418d51c:	4b0e      	ldr	r3, [pc, #56]	@ (3418d558 <LL_RCC_GetClockSource+0x48>)
3418d51e:	4413      	add	r3, r2
3418d520:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3418d522:	68fb      	ldr	r3, [r7, #12]
3418d524:	681a      	ldr	r2, [r3, #0]
3418d526:	687b      	ldr	r3, [r7, #4]
3418d528:	0e19      	lsrs	r1, r3, #24
3418d52a:	687b      	ldr	r3, [r7, #4]
3418d52c:	0a1b      	lsrs	r3, r3, #8
3418d52e:	f003 031f 	and.w	r3, r3, #31
3418d532:	fa01 f303 	lsl.w	r3, r1, r3
3418d536:	401a      	ands	r2, r3
3418d538:	687b      	ldr	r3, [r7, #4]
3418d53a:	0a1b      	lsrs	r3, r3, #8
3418d53c:	f003 031f 	and.w	r3, r3, #31
3418d540:	fa22 f303 	lsr.w	r3, r2, r3
3418d544:	041a      	lsls	r2, r3, #16
3418d546:	687b      	ldr	r3, [r7, #4]
3418d548:	4313      	orrs	r3, r2
}
3418d54a:	4618      	mov	r0, r3
3418d54c:	3714      	adds	r7, #20
3418d54e:	46bd      	mov	sp, r7
3418d550:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d554:	4770      	bx	lr
3418d556:	bf00      	nop
3418d558:	56028144 	.word	0x56028144

3418d55c <LL_RCC_GetADCClockSource>:
{
3418d55c:	b480      	push	{r7}
3418d55e:	b083      	sub	sp, #12
3418d560:	af00      	add	r7, sp, #0
3418d562:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3418d564:	4b05      	ldr	r3, [pc, #20]	@ (3418d57c <LL_RCC_GetADCClockSource+0x20>)
3418d566:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d56a:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3418d56e:	4618      	mov	r0, r3
3418d570:	370c      	adds	r7, #12
3418d572:	46bd      	mov	sp, r7
3418d574:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d578:	4770      	bx	lr
3418d57a:	bf00      	nop
3418d57c:	56028000 	.word	0x56028000

3418d580 <LL_RCC_GetADFClockSource>:
{
3418d580:	b480      	push	{r7}
3418d582:	b083      	sub	sp, #12
3418d584:	af00      	add	r7, sp, #0
3418d586:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3418d588:	4b05      	ldr	r3, [pc, #20]	@ (3418d5a0 <LL_RCC_GetADFClockSource+0x20>)
3418d58a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d58e:	f003 0307 	and.w	r3, r3, #7
}
3418d592:	4618      	mov	r0, r3
3418d594:	370c      	adds	r7, #12
3418d596:	46bd      	mov	sp, r7
3418d598:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d59c:	4770      	bx	lr
3418d59e:	bf00      	nop
3418d5a0:	56028000 	.word	0x56028000

3418d5a4 <LL_RCC_GetCLKPClockSource>:
{
3418d5a4:	b480      	push	{r7}
3418d5a6:	b083      	sub	sp, #12
3418d5a8:	af00      	add	r7, sp, #0
3418d5aa:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3418d5ac:	4b05      	ldr	r3, [pc, #20]	@ (3418d5c4 <LL_RCC_GetCLKPClockSource+0x20>)
3418d5ae:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d5b2:	f003 0307 	and.w	r3, r3, #7
}
3418d5b6:	4618      	mov	r0, r3
3418d5b8:	370c      	adds	r7, #12
3418d5ba:	46bd      	mov	sp, r7
3418d5bc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d5c0:	4770      	bx	lr
3418d5c2:	bf00      	nop
3418d5c4:	56028000 	.word	0x56028000

3418d5c8 <LL_RCC_GetDCMIPPClockSource>:
{
3418d5c8:	b480      	push	{r7}
3418d5ca:	b083      	sub	sp, #12
3418d5cc:	af00      	add	r7, sp, #0
3418d5ce:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3418d5d0:	4b05      	ldr	r3, [pc, #20]	@ (3418d5e8 <LL_RCC_GetDCMIPPClockSource+0x20>)
3418d5d2:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418d5d6:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3418d5da:	4618      	mov	r0, r3
3418d5dc:	370c      	adds	r7, #12
3418d5de:	46bd      	mov	sp, r7
3418d5e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d5e4:	4770      	bx	lr
3418d5e6:	bf00      	nop
3418d5e8:	56028000 	.word	0x56028000

3418d5ec <LL_RCC_GetETHClockSource>:
{
3418d5ec:	b480      	push	{r7}
3418d5ee:	b083      	sub	sp, #12
3418d5f0:	af00      	add	r7, sp, #0
3418d5f2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3418d5f4:	4b05      	ldr	r3, [pc, #20]	@ (3418d60c <LL_RCC_GetETHClockSource+0x20>)
3418d5f6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d5fa:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
3418d5fe:	4618      	mov	r0, r3
3418d600:	370c      	adds	r7, #12
3418d602:	46bd      	mov	sp, r7
3418d604:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d608:	4770      	bx	lr
3418d60a:	bf00      	nop
3418d60c:	56028000 	.word	0x56028000

3418d610 <LL_RCC_GetETHPTPClockSource>:
{
3418d610:	b480      	push	{r7}
3418d612:	b083      	sub	sp, #12
3418d614:	af00      	add	r7, sp, #0
3418d616:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3418d618:	4b05      	ldr	r3, [pc, #20]	@ (3418d630 <LL_RCC_GetETHPTPClockSource+0x20>)
3418d61a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418d61e:	f003 0303 	and.w	r3, r3, #3
}
3418d622:	4618      	mov	r0, r3
3418d624:	370c      	adds	r7, #12
3418d626:	46bd      	mov	sp, r7
3418d628:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d62c:	4770      	bx	lr
3418d62e:	bf00      	nop
3418d630:	56028000 	.word	0x56028000

3418d634 <LL_RCC_GetFDCANClockSource>:
{
3418d634:	b480      	push	{r7}
3418d636:	b083      	sub	sp, #12
3418d638:	af00      	add	r7, sp, #0
3418d63a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3418d63c:	4b05      	ldr	r3, [pc, #20]	@ (3418d654 <LL_RCC_GetFDCANClockSource+0x20>)
3418d63e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418d642:	f003 0303 	and.w	r3, r3, #3
}
3418d646:	4618      	mov	r0, r3
3418d648:	370c      	adds	r7, #12
3418d64a:	46bd      	mov	sp, r7
3418d64c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d650:	4770      	bx	lr
3418d652:	bf00      	nop
3418d654:	56028000 	.word	0x56028000

3418d658 <LL_RCC_GetFMCClockSource>:
{
3418d658:	b480      	push	{r7}
3418d65a:	b083      	sub	sp, #12
3418d65c:	af00      	add	r7, sp, #0
3418d65e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3418d660:	4b05      	ldr	r3, [pc, #20]	@ (3418d678 <LL_RCC_GetFMCClockSource+0x20>)
3418d662:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418d666:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3418d66a:	4618      	mov	r0, r3
3418d66c:	370c      	adds	r7, #12
3418d66e:	46bd      	mov	sp, r7
3418d670:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d674:	4770      	bx	lr
3418d676:	bf00      	nop
3418d678:	56028000 	.word	0x56028000

3418d67c <LL_RCC_GetI2CClockSource>:
{
3418d67c:	b580      	push	{r7, lr}
3418d67e:	b082      	sub	sp, #8
3418d680:	af00      	add	r7, sp, #0
3418d682:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d684:	6878      	ldr	r0, [r7, #4]
3418d686:	f7ff ff43 	bl	3418d510 <LL_RCC_GetClockSource>
3418d68a:	4603      	mov	r3, r0
}
3418d68c:	4618      	mov	r0, r3
3418d68e:	3708      	adds	r7, #8
3418d690:	46bd      	mov	sp, r7
3418d692:	bd80      	pop	{r7, pc}

3418d694 <LL_RCC_GetI3CClockSource>:
{
3418d694:	b580      	push	{r7, lr}
3418d696:	b082      	sub	sp, #8
3418d698:	af00      	add	r7, sp, #0
3418d69a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d69c:	6878      	ldr	r0, [r7, #4]
3418d69e:	f7ff ff37 	bl	3418d510 <LL_RCC_GetClockSource>
3418d6a2:	4603      	mov	r3, r0
}
3418d6a4:	4618      	mov	r0, r3
3418d6a6:	3708      	adds	r7, #8
3418d6a8:	46bd      	mov	sp, r7
3418d6aa:	bd80      	pop	{r7, pc}

3418d6ac <LL_RCC_GetLPTIMClockSource>:
{
3418d6ac:	b580      	push	{r7, lr}
3418d6ae:	b082      	sub	sp, #8
3418d6b0:	af00      	add	r7, sp, #0
3418d6b2:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d6b4:	6878      	ldr	r0, [r7, #4]
3418d6b6:	f7ff ff2b 	bl	3418d510 <LL_RCC_GetClockSource>
3418d6ba:	4603      	mov	r3, r0
}
3418d6bc:	4618      	mov	r0, r3
3418d6be:	3708      	adds	r7, #8
3418d6c0:	46bd      	mov	sp, r7
3418d6c2:	bd80      	pop	{r7, pc}

3418d6c4 <LL_RCC_GetLPUARTClockSource>:
{
3418d6c4:	b480      	push	{r7}
3418d6c6:	b083      	sub	sp, #12
3418d6c8:	af00      	add	r7, sp, #0
3418d6ca:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3418d6cc:	4b05      	ldr	r3, [pc, #20]	@ (3418d6e4 <LL_RCC_GetLPUARTClockSource+0x20>)
3418d6ce:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3418d6d2:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
3418d6d6:	4618      	mov	r0, r3
3418d6d8:	370c      	adds	r7, #12
3418d6da:	46bd      	mov	sp, r7
3418d6dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d6e0:	4770      	bx	lr
3418d6e2:	bf00      	nop
3418d6e4:	56028000 	.word	0x56028000

3418d6e8 <LL_RCC_GetLTDCClockSource>:
{
3418d6e8:	b480      	push	{r7}
3418d6ea:	b083      	sub	sp, #12
3418d6ec:	af00      	add	r7, sp, #0
3418d6ee:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3418d6f0:	4b05      	ldr	r3, [pc, #20]	@ (3418d708 <LL_RCC_GetLTDCClockSource+0x20>)
3418d6f2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3418d6f6:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
3418d6fa:	4618      	mov	r0, r3
3418d6fc:	370c      	adds	r7, #12
3418d6fe:	46bd      	mov	sp, r7
3418d700:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d704:	4770      	bx	lr
3418d706:	bf00      	nop
3418d708:	56028000 	.word	0x56028000

3418d70c <LL_RCC_GetMDFClockSource>:
{
3418d70c:	b480      	push	{r7}
3418d70e:	b083      	sub	sp, #12
3418d710:	af00      	add	r7, sp, #0
3418d712:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3418d714:	4b05      	ldr	r3, [pc, #20]	@ (3418d72c <LL_RCC_GetMDFClockSource+0x20>)
3418d716:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3418d71a:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3418d71e:	4618      	mov	r0, r3
3418d720:	370c      	adds	r7, #12
3418d722:	46bd      	mov	sp, r7
3418d724:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d728:	4770      	bx	lr
3418d72a:	bf00      	nop
3418d72c:	56028000 	.word	0x56028000

3418d730 <LL_RCC_GetPSSIClockSource>:
{
3418d730:	b480      	push	{r7}
3418d732:	b083      	sub	sp, #12
3418d734:	af00      	add	r7, sp, #0
3418d736:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3418d738:	4b05      	ldr	r3, [pc, #20]	@ (3418d750 <LL_RCC_GetPSSIClockSource+0x20>)
3418d73a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d73e:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3418d742:	4618      	mov	r0, r3
3418d744:	370c      	adds	r7, #12
3418d746:	46bd      	mov	sp, r7
3418d748:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d74c:	4770      	bx	lr
3418d74e:	bf00      	nop
3418d750:	56028000 	.word	0x56028000

3418d754 <LL_RCC_GetSAIClockSource>:
{
3418d754:	b580      	push	{r7, lr}
3418d756:	b082      	sub	sp, #8
3418d758:	af00      	add	r7, sp, #0
3418d75a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d75c:	6878      	ldr	r0, [r7, #4]
3418d75e:	f7ff fed7 	bl	3418d510 <LL_RCC_GetClockSource>
3418d762:	4603      	mov	r3, r0
}
3418d764:	4618      	mov	r0, r3
3418d766:	3708      	adds	r7, #8
3418d768:	46bd      	mov	sp, r7
3418d76a:	bd80      	pop	{r7, pc}

3418d76c <LL_RCC_GetSDMMCClockSource>:
{
3418d76c:	b580      	push	{r7, lr}
3418d76e:	b082      	sub	sp, #8
3418d770:	af00      	add	r7, sp, #0
3418d772:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d774:	6878      	ldr	r0, [r7, #4]
3418d776:	f7ff fecb 	bl	3418d510 <LL_RCC_GetClockSource>
3418d77a:	4603      	mov	r3, r0
}
3418d77c:	4618      	mov	r0, r3
3418d77e:	3708      	adds	r7, #8
3418d780:	46bd      	mov	sp, r7
3418d782:	bd80      	pop	{r7, pc}

3418d784 <LL_RCC_GetSPDIFRXClockSource>:
{
3418d784:	b480      	push	{r7}
3418d786:	b083      	sub	sp, #12
3418d788:	af00      	add	r7, sp, #0
3418d78a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3418d78c:	4b05      	ldr	r3, [pc, #20]	@ (3418d7a4 <LL_RCC_GetSPDIFRXClockSource+0x20>)
3418d78e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3418d792:	f003 0307 	and.w	r3, r3, #7
}
3418d796:	4618      	mov	r0, r3
3418d798:	370c      	adds	r7, #12
3418d79a:	46bd      	mov	sp, r7
3418d79c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d7a0:	4770      	bx	lr
3418d7a2:	bf00      	nop
3418d7a4:	56028000 	.word	0x56028000

3418d7a8 <LL_RCC_GetSPIClockSource>:
{
3418d7a8:	b580      	push	{r7, lr}
3418d7aa:	b082      	sub	sp, #8
3418d7ac:	af00      	add	r7, sp, #0
3418d7ae:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d7b0:	6878      	ldr	r0, [r7, #4]
3418d7b2:	f7ff fead 	bl	3418d510 <LL_RCC_GetClockSource>
3418d7b6:	4603      	mov	r3, r0
}
3418d7b8:	4618      	mov	r0, r3
3418d7ba:	3708      	adds	r7, #8
3418d7bc:	46bd      	mov	sp, r7
3418d7be:	bd80      	pop	{r7, pc}

3418d7c0 <LL_RCC_GetUSARTClockSource>:
{
3418d7c0:	b580      	push	{r7, lr}
3418d7c2:	b082      	sub	sp, #8
3418d7c4:	af00      	add	r7, sp, #0
3418d7c6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d7c8:	6878      	ldr	r0, [r7, #4]
3418d7ca:	f7ff fea1 	bl	3418d510 <LL_RCC_GetClockSource>
3418d7ce:	4603      	mov	r3, r0
}
3418d7d0:	4618      	mov	r0, r3
3418d7d2:	3708      	adds	r7, #8
3418d7d4:	46bd      	mov	sp, r7
3418d7d6:	bd80      	pop	{r7, pc}

3418d7d8 <LL_RCC_GetUARTClockSource>:
{
3418d7d8:	b580      	push	{r7, lr}
3418d7da:	b082      	sub	sp, #8
3418d7dc:	af00      	add	r7, sp, #0
3418d7de:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d7e0:	6878      	ldr	r0, [r7, #4]
3418d7e2:	f7ff fe95 	bl	3418d510 <LL_RCC_GetClockSource>
3418d7e6:	4603      	mov	r3, r0
}
3418d7e8:	4618      	mov	r0, r3
3418d7ea:	3708      	adds	r7, #8
3418d7ec:	46bd      	mov	sp, r7
3418d7ee:	bd80      	pop	{r7, pc}

3418d7f0 <LL_RCC_GetUSBClockSource>:
{
3418d7f0:	b580      	push	{r7, lr}
3418d7f2:	b082      	sub	sp, #8
3418d7f4:	af00      	add	r7, sp, #0
3418d7f6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d7f8:	6878      	ldr	r0, [r7, #4]
3418d7fa:	f7ff fe89 	bl	3418d510 <LL_RCC_GetClockSource>
3418d7fe:	4603      	mov	r3, r0
}
3418d800:	4618      	mov	r0, r3
3418d802:	3708      	adds	r7, #8
3418d804:	46bd      	mov	sp, r7
3418d806:	bd80      	pop	{r7, pc}

3418d808 <LL_RCC_GetXSPIClockSource>:
{
3418d808:	b580      	push	{r7, lr}
3418d80a:	b082      	sub	sp, #8
3418d80c:	af00      	add	r7, sp, #0
3418d80e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418d810:	6878      	ldr	r0, [r7, #4]
3418d812:	f7ff fe7d 	bl	3418d510 <LL_RCC_GetClockSource>
3418d816:	4603      	mov	r3, r0
}
3418d818:	4618      	mov	r0, r3
3418d81a:	3708      	adds	r7, #8
3418d81c:	46bd      	mov	sp, r7
3418d81e:	bd80      	pop	{r7, pc}

3418d820 <LL_RCC_SetRTCClockSource>:
{
3418d820:	b480      	push	{r7}
3418d822:	b083      	sub	sp, #12
3418d824:	af00      	add	r7, sp, #0
3418d826:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3418d828:	4b07      	ldr	r3, [pc, #28]	@ (3418d848 <LL_RCC_SetRTCClockSource+0x28>)
3418d82a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d82e:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
3418d832:	4905      	ldr	r1, [pc, #20]	@ (3418d848 <LL_RCC_SetRTCClockSource+0x28>)
3418d834:	687b      	ldr	r3, [r7, #4]
3418d836:	4313      	orrs	r3, r2
3418d838:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418d83c:	bf00      	nop
3418d83e:	370c      	adds	r7, #12
3418d840:	46bd      	mov	sp, r7
3418d842:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d846:	4770      	bx	lr
3418d848:	56028000 	.word	0x56028000

3418d84c <LL_RCC_GetRTCClockSource>:
{
3418d84c:	b480      	push	{r7}
3418d84e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3418d850:	4b04      	ldr	r3, [pc, #16]	@ (3418d864 <LL_RCC_GetRTCClockSource+0x18>)
3418d852:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d856:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3418d85a:	4618      	mov	r0, r3
3418d85c:	46bd      	mov	sp, r7
3418d85e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d862:	4770      	bx	lr
3418d864:	56028000 	.word	0x56028000

3418d868 <LL_RCC_SetRTC_HSEPrescaler>:
{
3418d868:	b480      	push	{r7}
3418d86a:	b083      	sub	sp, #12
3418d86c:	af00      	add	r7, sp, #0
3418d86e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3418d870:	4b07      	ldr	r3, [pc, #28]	@ (3418d890 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3418d872:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418d876:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3418d87a:	4905      	ldr	r1, [pc, #20]	@ (3418d890 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3418d87c:	687b      	ldr	r3, [r7, #4]
3418d87e:	4313      	orrs	r3, r2
3418d880:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418d884:	bf00      	nop
3418d886:	370c      	adds	r7, #12
3418d888:	46bd      	mov	sp, r7
3418d88a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d88e:	4770      	bx	lr
3418d890:	56028000 	.word	0x56028000

3418d894 <LL_RCC_SetTIMPrescaler>:
{
3418d894:	b480      	push	{r7}
3418d896:	b083      	sub	sp, #12
3418d898:	af00      	add	r7, sp, #0
3418d89a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3418d89c:	4b07      	ldr	r3, [pc, #28]	@ (3418d8bc <LL_RCC_SetTIMPrescaler+0x28>)
3418d89e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d8a0:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418d8a4:	687b      	ldr	r3, [r7, #4]
3418d8a6:	061b      	lsls	r3, r3, #24
3418d8a8:	4904      	ldr	r1, [pc, #16]	@ (3418d8bc <LL_RCC_SetTIMPrescaler+0x28>)
3418d8aa:	4313      	orrs	r3, r2
3418d8ac:	624b      	str	r3, [r1, #36]	@ 0x24
}
3418d8ae:	bf00      	nop
3418d8b0:	370c      	adds	r7, #12
3418d8b2:	46bd      	mov	sp, r7
3418d8b4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d8b8:	4770      	bx	lr
3418d8ba:	bf00      	nop
3418d8bc:	56028000 	.word	0x56028000

3418d8c0 <LL_RCC_GetTIMPrescaler>:
{
3418d8c0:	b480      	push	{r7}
3418d8c2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3418d8c4:	4b04      	ldr	r3, [pc, #16]	@ (3418d8d8 <LL_RCC_GetTIMPrescaler+0x18>)
3418d8c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d8c8:	0e1b      	lsrs	r3, r3, #24
3418d8ca:	f003 0303 	and.w	r3, r3, #3
}
3418d8ce:	4618      	mov	r0, r3
3418d8d0:	46bd      	mov	sp, r7
3418d8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d8d6:	4770      	bx	lr
3418d8d8:	56028000 	.word	0x56028000

3418d8dc <LL_RCC_PLL1_GetSource>:
{
3418d8dc:	b480      	push	{r7}
3418d8de:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3418d8e0:	4b04      	ldr	r3, [pc, #16]	@ (3418d8f4 <LL_RCC_PLL1_GetSource+0x18>)
3418d8e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418d8e6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418d8ea:	4618      	mov	r0, r3
3418d8ec:	46bd      	mov	sp, r7
3418d8ee:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d8f2:	4770      	bx	lr
3418d8f4:	56028000 	.word	0x56028000

3418d8f8 <LL_RCC_PLL1_IsReady>:
{
3418d8f8:	b480      	push	{r7}
3418d8fa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3418d8fc:	4b07      	ldr	r3, [pc, #28]	@ (3418d91c <LL_RCC_PLL1_IsReady+0x24>)
3418d8fe:	685b      	ldr	r3, [r3, #4]
3418d900:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418d904:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418d908:	d101      	bne.n	3418d90e <LL_RCC_PLL1_IsReady+0x16>
3418d90a:	2301      	movs	r3, #1
3418d90c:	e000      	b.n	3418d910 <LL_RCC_PLL1_IsReady+0x18>
3418d90e:	2300      	movs	r3, #0
}
3418d910:	4618      	mov	r0, r3
3418d912:	46bd      	mov	sp, r7
3418d914:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d918:	4770      	bx	lr
3418d91a:	bf00      	nop
3418d91c:	56028000 	.word	0x56028000

3418d920 <LL_RCC_PLL1_IsEnabledBypass>:
{
3418d920:	b480      	push	{r7}
3418d922:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3418d924:	4b07      	ldr	r3, [pc, #28]	@ (3418d944 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3418d926:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418d92a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418d92e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418d932:	d101      	bne.n	3418d938 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3418d934:	2301      	movs	r3, #1
3418d936:	e000      	b.n	3418d93a <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3418d938:	2300      	movs	r3, #0
}
3418d93a:	4618      	mov	r0, r3
3418d93c:	46bd      	mov	sp, r7
3418d93e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d942:	4770      	bx	lr
3418d944:	56028000 	.word	0x56028000

3418d948 <LL_RCC_PLL1_GetN>:
{
3418d948:	b480      	push	{r7}
3418d94a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3418d94c:	4b05      	ldr	r3, [pc, #20]	@ (3418d964 <LL_RCC_PLL1_GetN+0x1c>)
3418d94e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418d952:	0a1b      	lsrs	r3, r3, #8
3418d954:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418d958:	4618      	mov	r0, r3
3418d95a:	46bd      	mov	sp, r7
3418d95c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d960:	4770      	bx	lr
3418d962:	bf00      	nop
3418d964:	56028000 	.word	0x56028000

3418d968 <LL_RCC_PLL1_GetM>:
{
3418d968:	b480      	push	{r7}
3418d96a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3418d96c:	4b05      	ldr	r3, [pc, #20]	@ (3418d984 <LL_RCC_PLL1_GetM+0x1c>)
3418d96e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418d972:	0d1b      	lsrs	r3, r3, #20
3418d974:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418d978:	4618      	mov	r0, r3
3418d97a:	46bd      	mov	sp, r7
3418d97c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d980:	4770      	bx	lr
3418d982:	bf00      	nop
3418d984:	56028000 	.word	0x56028000

3418d988 <LL_RCC_PLL1_GetP1>:
{
3418d988:	b480      	push	{r7}
3418d98a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3418d98c:	4b05      	ldr	r3, [pc, #20]	@ (3418d9a4 <LL_RCC_PLL1_GetP1+0x1c>)
3418d98e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418d992:	0edb      	lsrs	r3, r3, #27
3418d994:	f003 0307 	and.w	r3, r3, #7
}
3418d998:	4618      	mov	r0, r3
3418d99a:	46bd      	mov	sp, r7
3418d99c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d9a0:	4770      	bx	lr
3418d9a2:	bf00      	nop
3418d9a4:	56028000 	.word	0x56028000

3418d9a8 <LL_RCC_PLL1_GetP2>:
{
3418d9a8:	b480      	push	{r7}
3418d9aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3418d9ac:	4b05      	ldr	r3, [pc, #20]	@ (3418d9c4 <LL_RCC_PLL1_GetP2+0x1c>)
3418d9ae:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418d9b2:	0e1b      	lsrs	r3, r3, #24
3418d9b4:	f003 0307 	and.w	r3, r3, #7
}
3418d9b8:	4618      	mov	r0, r3
3418d9ba:	46bd      	mov	sp, r7
3418d9bc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d9c0:	4770      	bx	lr
3418d9c2:	bf00      	nop
3418d9c4:	56028000 	.word	0x56028000

3418d9c8 <LL_RCC_PLL1P_IsEnabled>:
{
3418d9c8:	b480      	push	{r7}
3418d9ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3418d9cc:	4b07      	ldr	r3, [pc, #28]	@ (3418d9ec <LL_RCC_PLL1P_IsEnabled+0x24>)
3418d9ce:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418d9d2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418d9d6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418d9da:	d101      	bne.n	3418d9e0 <LL_RCC_PLL1P_IsEnabled+0x18>
3418d9dc:	2301      	movs	r3, #1
3418d9de:	e000      	b.n	3418d9e2 <LL_RCC_PLL1P_IsEnabled+0x1a>
3418d9e0:	2300      	movs	r3, #0
}
3418d9e2:	4618      	mov	r0, r3
3418d9e4:	46bd      	mov	sp, r7
3418d9e6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418d9ea:	4770      	bx	lr
3418d9ec:	56028000 	.word	0x56028000

3418d9f0 <LL_RCC_PLL1_GetFRACN>:
{
3418d9f0:	b480      	push	{r7}
3418d9f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3418d9f4:	4b04      	ldr	r3, [pc, #16]	@ (3418da08 <LL_RCC_PLL1_GetFRACN+0x18>)
3418d9f6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418d9fa:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418d9fe:	4618      	mov	r0, r3
3418da00:	46bd      	mov	sp, r7
3418da02:	f85d 7b04 	ldr.w	r7, [sp], #4
3418da06:	4770      	bx	lr
3418da08:	56028000 	.word	0x56028000

3418da0c <LL_RCC_PLL2_GetSource>:
{
3418da0c:	b480      	push	{r7}
3418da0e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418da10:	4b04      	ldr	r3, [pc, #16]	@ (3418da24 <LL_RCC_PLL2_GetSource+0x18>)
3418da12:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418da16:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418da1a:	4618      	mov	r0, r3
3418da1c:	46bd      	mov	sp, r7
3418da1e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418da22:	4770      	bx	lr
3418da24:	56028000 	.word	0x56028000

3418da28 <LL_RCC_PLL2_IsReady>:
{
3418da28:	b480      	push	{r7}
3418da2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3418da2c:	4b07      	ldr	r3, [pc, #28]	@ (3418da4c <LL_RCC_PLL2_IsReady+0x24>)
3418da2e:	685b      	ldr	r3, [r3, #4]
3418da30:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418da34:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418da38:	d101      	bne.n	3418da3e <LL_RCC_PLL2_IsReady+0x16>
3418da3a:	2301      	movs	r3, #1
3418da3c:	e000      	b.n	3418da40 <LL_RCC_PLL2_IsReady+0x18>
3418da3e:	2300      	movs	r3, #0
}
3418da40:	4618      	mov	r0, r3
3418da42:	46bd      	mov	sp, r7
3418da44:	f85d 7b04 	ldr.w	r7, [sp], #4
3418da48:	4770      	bx	lr
3418da4a:	bf00      	nop
3418da4c:	56028000 	.word	0x56028000

3418da50 <LL_RCC_PLL2_IsEnabledBypass>:
{
3418da50:	b480      	push	{r7}
3418da52:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3418da54:	4b07      	ldr	r3, [pc, #28]	@ (3418da74 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418da56:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418da5a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418da5e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418da62:	d101      	bne.n	3418da68 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3418da64:	2301      	movs	r3, #1
3418da66:	e000      	b.n	3418da6a <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418da68:	2300      	movs	r3, #0
}
3418da6a:	4618      	mov	r0, r3
3418da6c:	46bd      	mov	sp, r7
3418da6e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418da72:	4770      	bx	lr
3418da74:	56028000 	.word	0x56028000

3418da78 <LL_RCC_PLL2_GetN>:
{
3418da78:	b480      	push	{r7}
3418da7a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3418da7c:	4b05      	ldr	r3, [pc, #20]	@ (3418da94 <LL_RCC_PLL2_GetN+0x1c>)
3418da7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418da82:	0a1b      	lsrs	r3, r3, #8
3418da84:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418da88:	4618      	mov	r0, r3
3418da8a:	46bd      	mov	sp, r7
3418da8c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418da90:	4770      	bx	lr
3418da92:	bf00      	nop
3418da94:	56028000 	.word	0x56028000

3418da98 <LL_RCC_PLL2_GetM>:
{
3418da98:	b480      	push	{r7}
3418da9a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3418da9c:	4b05      	ldr	r3, [pc, #20]	@ (3418dab4 <LL_RCC_PLL2_GetM+0x1c>)
3418da9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418daa2:	0d1b      	lsrs	r3, r3, #20
3418daa4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418daa8:	4618      	mov	r0, r3
3418daaa:	46bd      	mov	sp, r7
3418daac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dab0:	4770      	bx	lr
3418dab2:	bf00      	nop
3418dab4:	56028000 	.word	0x56028000

3418dab8 <LL_RCC_PLL2_GetP1>:
{
3418dab8:	b480      	push	{r7}
3418daba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3418dabc:	4b05      	ldr	r3, [pc, #20]	@ (3418dad4 <LL_RCC_PLL2_GetP1+0x1c>)
3418dabe:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418dac2:	0edb      	lsrs	r3, r3, #27
3418dac4:	f003 0307 	and.w	r3, r3, #7
}
3418dac8:	4618      	mov	r0, r3
3418daca:	46bd      	mov	sp, r7
3418dacc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dad0:	4770      	bx	lr
3418dad2:	bf00      	nop
3418dad4:	56028000 	.word	0x56028000

3418dad8 <LL_RCC_PLL2_GetP2>:
{
3418dad8:	b480      	push	{r7}
3418dada:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3418dadc:	4b05      	ldr	r3, [pc, #20]	@ (3418daf4 <LL_RCC_PLL2_GetP2+0x1c>)
3418dade:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418dae2:	0e1b      	lsrs	r3, r3, #24
3418dae4:	f003 0307 	and.w	r3, r3, #7
}
3418dae8:	4618      	mov	r0, r3
3418daea:	46bd      	mov	sp, r7
3418daec:	f85d 7b04 	ldr.w	r7, [sp], #4
3418daf0:	4770      	bx	lr
3418daf2:	bf00      	nop
3418daf4:	56028000 	.word	0x56028000

3418daf8 <LL_RCC_PLL2P_IsEnabled>:
{
3418daf8:	b480      	push	{r7}
3418dafa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3418dafc:	4b07      	ldr	r3, [pc, #28]	@ (3418db1c <LL_RCC_PLL2P_IsEnabled+0x24>)
3418dafe:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418db02:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418db06:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418db0a:	d101      	bne.n	3418db10 <LL_RCC_PLL2P_IsEnabled+0x18>
3418db0c:	2301      	movs	r3, #1
3418db0e:	e000      	b.n	3418db12 <LL_RCC_PLL2P_IsEnabled+0x1a>
3418db10:	2300      	movs	r3, #0
}
3418db12:	4618      	mov	r0, r3
3418db14:	46bd      	mov	sp, r7
3418db16:	f85d 7b04 	ldr.w	r7, [sp], #4
3418db1a:	4770      	bx	lr
3418db1c:	56028000 	.word	0x56028000

3418db20 <LL_RCC_PLL2_GetFRACN>:
{
3418db20:	b480      	push	{r7}
3418db22:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3418db24:	4b04      	ldr	r3, [pc, #16]	@ (3418db38 <LL_RCC_PLL2_GetFRACN+0x18>)
3418db26:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3418db2a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418db2e:	4618      	mov	r0, r3
3418db30:	46bd      	mov	sp, r7
3418db32:	f85d 7b04 	ldr.w	r7, [sp], #4
3418db36:	4770      	bx	lr
3418db38:	56028000 	.word	0x56028000

3418db3c <LL_RCC_PLL3_GetSource>:
{
3418db3c:	b480      	push	{r7}
3418db3e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3418db40:	4b04      	ldr	r3, [pc, #16]	@ (3418db54 <LL_RCC_PLL3_GetSource+0x18>)
3418db42:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418db46:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418db4a:	4618      	mov	r0, r3
3418db4c:	46bd      	mov	sp, r7
3418db4e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418db52:	4770      	bx	lr
3418db54:	56028000 	.word	0x56028000

3418db58 <LL_RCC_PLL3_IsReady>:
{
3418db58:	b480      	push	{r7}
3418db5a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418db5c:	4b07      	ldr	r3, [pc, #28]	@ (3418db7c <LL_RCC_PLL3_IsReady+0x24>)
3418db5e:	685b      	ldr	r3, [r3, #4]
3418db60:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418db64:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3418db68:	d101      	bne.n	3418db6e <LL_RCC_PLL3_IsReady+0x16>
3418db6a:	2301      	movs	r3, #1
3418db6c:	e000      	b.n	3418db70 <LL_RCC_PLL3_IsReady+0x18>
3418db6e:	2300      	movs	r3, #0
}
3418db70:	4618      	mov	r0, r3
3418db72:	46bd      	mov	sp, r7
3418db74:	f85d 7b04 	ldr.w	r7, [sp], #4
3418db78:	4770      	bx	lr
3418db7a:	bf00      	nop
3418db7c:	56028000 	.word	0x56028000

3418db80 <LL_RCC_PLL3_IsEnabledBypass>:
{
3418db80:	b480      	push	{r7}
3418db82:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3418db84:	4b07      	ldr	r3, [pc, #28]	@ (3418dba4 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3418db86:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418db8a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418db8e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418db92:	d101      	bne.n	3418db98 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3418db94:	2301      	movs	r3, #1
3418db96:	e000      	b.n	3418db9a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3418db98:	2300      	movs	r3, #0
}
3418db9a:	4618      	mov	r0, r3
3418db9c:	46bd      	mov	sp, r7
3418db9e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dba2:	4770      	bx	lr
3418dba4:	56028000 	.word	0x56028000

3418dba8 <LL_RCC_PLL3_GetN>:
{
3418dba8:	b480      	push	{r7}
3418dbaa:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3418dbac:	4b05      	ldr	r3, [pc, #20]	@ (3418dbc4 <LL_RCC_PLL3_GetN+0x1c>)
3418dbae:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418dbb2:	0a1b      	lsrs	r3, r3, #8
3418dbb4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418dbb8:	4618      	mov	r0, r3
3418dbba:	46bd      	mov	sp, r7
3418dbbc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dbc0:	4770      	bx	lr
3418dbc2:	bf00      	nop
3418dbc4:	56028000 	.word	0x56028000

3418dbc8 <LL_RCC_PLL3_GetM>:
{
3418dbc8:	b480      	push	{r7}
3418dbca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3418dbcc:	4b05      	ldr	r3, [pc, #20]	@ (3418dbe4 <LL_RCC_PLL3_GetM+0x1c>)
3418dbce:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418dbd2:	0d1b      	lsrs	r3, r3, #20
3418dbd4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418dbd8:	4618      	mov	r0, r3
3418dbda:	46bd      	mov	sp, r7
3418dbdc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dbe0:	4770      	bx	lr
3418dbe2:	bf00      	nop
3418dbe4:	56028000 	.word	0x56028000

3418dbe8 <LL_RCC_PLL3_GetP1>:
{
3418dbe8:	b480      	push	{r7}
3418dbea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3418dbec:	4b05      	ldr	r3, [pc, #20]	@ (3418dc04 <LL_RCC_PLL3_GetP1+0x1c>)
3418dbee:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418dbf2:	0edb      	lsrs	r3, r3, #27
3418dbf4:	f003 0307 	and.w	r3, r3, #7
}
3418dbf8:	4618      	mov	r0, r3
3418dbfa:	46bd      	mov	sp, r7
3418dbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc00:	4770      	bx	lr
3418dc02:	bf00      	nop
3418dc04:	56028000 	.word	0x56028000

3418dc08 <LL_RCC_PLL3_GetP2>:
{
3418dc08:	b480      	push	{r7}
3418dc0a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3418dc0c:	4b05      	ldr	r3, [pc, #20]	@ (3418dc24 <LL_RCC_PLL3_GetP2+0x1c>)
3418dc0e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418dc12:	0e1b      	lsrs	r3, r3, #24
3418dc14:	f003 0307 	and.w	r3, r3, #7
}
3418dc18:	4618      	mov	r0, r3
3418dc1a:	46bd      	mov	sp, r7
3418dc1c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc20:	4770      	bx	lr
3418dc22:	bf00      	nop
3418dc24:	56028000 	.word	0x56028000

3418dc28 <LL_RCC_PLL3P_IsEnabled>:
{
3418dc28:	b480      	push	{r7}
3418dc2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3418dc2c:	4b07      	ldr	r3, [pc, #28]	@ (3418dc4c <LL_RCC_PLL3P_IsEnabled+0x24>)
3418dc2e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418dc32:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418dc36:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418dc3a:	d101      	bne.n	3418dc40 <LL_RCC_PLL3P_IsEnabled+0x18>
3418dc3c:	2301      	movs	r3, #1
3418dc3e:	e000      	b.n	3418dc42 <LL_RCC_PLL3P_IsEnabled+0x1a>
3418dc40:	2300      	movs	r3, #0
}
3418dc42:	4618      	mov	r0, r3
3418dc44:	46bd      	mov	sp, r7
3418dc46:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc4a:	4770      	bx	lr
3418dc4c:	56028000 	.word	0x56028000

3418dc50 <LL_RCC_PLL3_GetFRACN>:
{
3418dc50:	b480      	push	{r7}
3418dc52:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3418dc54:	4b04      	ldr	r3, [pc, #16]	@ (3418dc68 <LL_RCC_PLL3_GetFRACN+0x18>)
3418dc56:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418dc5a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418dc5e:	4618      	mov	r0, r3
3418dc60:	46bd      	mov	sp, r7
3418dc62:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc66:	4770      	bx	lr
3418dc68:	56028000 	.word	0x56028000

3418dc6c <LL_RCC_PLL4_GetSource>:
{
3418dc6c:	b480      	push	{r7}
3418dc6e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3418dc70:	4b04      	ldr	r3, [pc, #16]	@ (3418dc84 <LL_RCC_PLL4_GetSource+0x18>)
3418dc72:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418dc76:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418dc7a:	4618      	mov	r0, r3
3418dc7c:	46bd      	mov	sp, r7
3418dc7e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc82:	4770      	bx	lr
3418dc84:	56028000 	.word	0x56028000

3418dc88 <LL_RCC_PLL4_IsReady>:
{
3418dc88:	b480      	push	{r7}
3418dc8a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418dc8c:	4b07      	ldr	r3, [pc, #28]	@ (3418dcac <LL_RCC_PLL4_IsReady+0x24>)
3418dc8e:	685b      	ldr	r3, [r3, #4]
3418dc90:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418dc94:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418dc98:	d101      	bne.n	3418dc9e <LL_RCC_PLL4_IsReady+0x16>
3418dc9a:	2301      	movs	r3, #1
3418dc9c:	e000      	b.n	3418dca0 <LL_RCC_PLL4_IsReady+0x18>
3418dc9e:	2300      	movs	r3, #0
}
3418dca0:	4618      	mov	r0, r3
3418dca2:	46bd      	mov	sp, r7
3418dca4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dca8:	4770      	bx	lr
3418dcaa:	bf00      	nop
3418dcac:	56028000 	.word	0x56028000

3418dcb0 <LL_RCC_PLL4_IsEnabledBypass>:
{
3418dcb0:	b480      	push	{r7}
3418dcb2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3418dcb4:	4b07      	ldr	r3, [pc, #28]	@ (3418dcd4 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3418dcb6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418dcba:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418dcbe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418dcc2:	d101      	bne.n	3418dcc8 <LL_RCC_PLL4_IsEnabledBypass+0x18>
3418dcc4:	2301      	movs	r3, #1
3418dcc6:	e000      	b.n	3418dcca <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3418dcc8:	2300      	movs	r3, #0
}
3418dcca:	4618      	mov	r0, r3
3418dccc:	46bd      	mov	sp, r7
3418dcce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dcd2:	4770      	bx	lr
3418dcd4:	56028000 	.word	0x56028000

3418dcd8 <LL_RCC_PLL4_GetN>:
{
3418dcd8:	b480      	push	{r7}
3418dcda:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3418dcdc:	4b05      	ldr	r3, [pc, #20]	@ (3418dcf4 <LL_RCC_PLL4_GetN+0x1c>)
3418dcde:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418dce2:	0a1b      	lsrs	r3, r3, #8
3418dce4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418dce8:	4618      	mov	r0, r3
3418dcea:	46bd      	mov	sp, r7
3418dcec:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dcf0:	4770      	bx	lr
3418dcf2:	bf00      	nop
3418dcf4:	56028000 	.word	0x56028000

3418dcf8 <LL_RCC_PLL4_GetM>:
{
3418dcf8:	b480      	push	{r7}
3418dcfa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3418dcfc:	4b05      	ldr	r3, [pc, #20]	@ (3418dd14 <LL_RCC_PLL4_GetM+0x1c>)
3418dcfe:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418dd02:	0d1b      	lsrs	r3, r3, #20
3418dd04:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418dd08:	4618      	mov	r0, r3
3418dd0a:	46bd      	mov	sp, r7
3418dd0c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dd10:	4770      	bx	lr
3418dd12:	bf00      	nop
3418dd14:	56028000 	.word	0x56028000

3418dd18 <LL_RCC_PLL4_GetP1>:
{
3418dd18:	b480      	push	{r7}
3418dd1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3418dd1c:	4b05      	ldr	r3, [pc, #20]	@ (3418dd34 <LL_RCC_PLL4_GetP1+0x1c>)
3418dd1e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418dd22:	0edb      	lsrs	r3, r3, #27
3418dd24:	f003 0307 	and.w	r3, r3, #7
}
3418dd28:	4618      	mov	r0, r3
3418dd2a:	46bd      	mov	sp, r7
3418dd2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dd30:	4770      	bx	lr
3418dd32:	bf00      	nop
3418dd34:	56028000 	.word	0x56028000

3418dd38 <LL_RCC_PLL4_GetP2>:
{
3418dd38:	b480      	push	{r7}
3418dd3a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3418dd3c:	4b05      	ldr	r3, [pc, #20]	@ (3418dd54 <LL_RCC_PLL4_GetP2+0x1c>)
3418dd3e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418dd42:	0e1b      	lsrs	r3, r3, #24
3418dd44:	f003 0307 	and.w	r3, r3, #7
}
3418dd48:	4618      	mov	r0, r3
3418dd4a:	46bd      	mov	sp, r7
3418dd4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dd50:	4770      	bx	lr
3418dd52:	bf00      	nop
3418dd54:	56028000 	.word	0x56028000

3418dd58 <LL_RCC_PLL4P_IsEnabled>:
{
3418dd58:	b480      	push	{r7}
3418dd5a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3418dd5c:	4b07      	ldr	r3, [pc, #28]	@ (3418dd7c <LL_RCC_PLL4P_IsEnabled+0x24>)
3418dd5e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418dd62:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418dd66:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418dd6a:	d101      	bne.n	3418dd70 <LL_RCC_PLL4P_IsEnabled+0x18>
3418dd6c:	2301      	movs	r3, #1
3418dd6e:	e000      	b.n	3418dd72 <LL_RCC_PLL4P_IsEnabled+0x1a>
3418dd70:	2300      	movs	r3, #0
}
3418dd72:	4618      	mov	r0, r3
3418dd74:	46bd      	mov	sp, r7
3418dd76:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dd7a:	4770      	bx	lr
3418dd7c:	56028000 	.word	0x56028000

3418dd80 <LL_RCC_PLL4_GetFRACN>:
{
3418dd80:	b480      	push	{r7}
3418dd82:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3418dd84:	4b04      	ldr	r3, [pc, #16]	@ (3418dd98 <LL_RCC_PLL4_GetFRACN+0x18>)
3418dd86:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418dd8a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418dd8e:	4618      	mov	r0, r3
3418dd90:	46bd      	mov	sp, r7
3418dd92:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dd96:	4770      	bx	lr
3418dd98:	56028000 	.word	0x56028000

3418dd9c <LL_RCC_IC3_Enable>:
{
3418dd9c:	b480      	push	{r7}
3418dd9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418dda0:	4b04      	ldr	r3, [pc, #16]	@ (3418ddb4 <LL_RCC_IC3_Enable+0x18>)
3418dda2:	2204      	movs	r2, #4
3418dda4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418dda8:	bf00      	nop
3418ddaa:	46bd      	mov	sp, r7
3418ddac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ddb0:	4770      	bx	lr
3418ddb2:	bf00      	nop
3418ddb4:	56028000 	.word	0x56028000

3418ddb8 <LL_RCC_IC3_IsEnabled>:
{
3418ddb8:	b480      	push	{r7}
3418ddba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3418ddbc:	4b07      	ldr	r3, [pc, #28]	@ (3418dddc <LL_RCC_IC3_IsEnabled+0x24>)
3418ddbe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418ddc2:	f003 0304 	and.w	r3, r3, #4
3418ddc6:	2b04      	cmp	r3, #4
3418ddc8:	d101      	bne.n	3418ddce <LL_RCC_IC3_IsEnabled+0x16>
3418ddca:	2301      	movs	r3, #1
3418ddcc:	e000      	b.n	3418ddd0 <LL_RCC_IC3_IsEnabled+0x18>
3418ddce:	2300      	movs	r3, #0
}
3418ddd0:	4618      	mov	r0, r3
3418ddd2:	46bd      	mov	sp, r7
3418ddd4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ddd8:	4770      	bx	lr
3418ddda:	bf00      	nop
3418dddc:	56028000 	.word	0x56028000

3418dde0 <LL_RCC_IC3_GetSource>:
{
3418dde0:	b480      	push	{r7}
3418dde2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3418dde4:	4b04      	ldr	r3, [pc, #16]	@ (3418ddf8 <LL_RCC_IC3_GetSource+0x18>)
3418dde6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418ddea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ddee:	4618      	mov	r0, r3
3418ddf0:	46bd      	mov	sp, r7
3418ddf2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ddf6:	4770      	bx	lr
3418ddf8:	56028000 	.word	0x56028000

3418ddfc <LL_RCC_IC3_GetDivider>:
{
3418ddfc:	b480      	push	{r7}
3418ddfe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418de00:	4b05      	ldr	r3, [pc, #20]	@ (3418de18 <LL_RCC_IC3_GetDivider+0x1c>)
3418de02:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418de06:	0c1b      	lsrs	r3, r3, #16
3418de08:	b2db      	uxtb	r3, r3
3418de0a:	3301      	adds	r3, #1
}
3418de0c:	4618      	mov	r0, r3
3418de0e:	46bd      	mov	sp, r7
3418de10:	f85d 7b04 	ldr.w	r7, [sp], #4
3418de14:	4770      	bx	lr
3418de16:	bf00      	nop
3418de18:	56028000 	.word	0x56028000

3418de1c <LL_RCC_IC4_Enable>:
{
3418de1c:	b480      	push	{r7}
3418de1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418de20:	4b04      	ldr	r3, [pc, #16]	@ (3418de34 <LL_RCC_IC4_Enable+0x18>)
3418de22:	2208      	movs	r2, #8
3418de24:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418de28:	bf00      	nop
3418de2a:	46bd      	mov	sp, r7
3418de2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418de30:	4770      	bx	lr
3418de32:	bf00      	nop
3418de34:	56028000 	.word	0x56028000

3418de38 <LL_RCC_IC4_IsEnabled>:
{
3418de38:	b480      	push	{r7}
3418de3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3418de3c:	4b07      	ldr	r3, [pc, #28]	@ (3418de5c <LL_RCC_IC4_IsEnabled+0x24>)
3418de3e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418de42:	f003 0308 	and.w	r3, r3, #8
3418de46:	2b08      	cmp	r3, #8
3418de48:	d101      	bne.n	3418de4e <LL_RCC_IC4_IsEnabled+0x16>
3418de4a:	2301      	movs	r3, #1
3418de4c:	e000      	b.n	3418de50 <LL_RCC_IC4_IsEnabled+0x18>
3418de4e:	2300      	movs	r3, #0
}
3418de50:	4618      	mov	r0, r3
3418de52:	46bd      	mov	sp, r7
3418de54:	f85d 7b04 	ldr.w	r7, [sp], #4
3418de58:	4770      	bx	lr
3418de5a:	bf00      	nop
3418de5c:	56028000 	.word	0x56028000

3418de60 <LL_RCC_IC4_GetSource>:
{
3418de60:	b480      	push	{r7}
3418de62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418de64:	4b04      	ldr	r3, [pc, #16]	@ (3418de78 <LL_RCC_IC4_GetSource+0x18>)
3418de66:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418de6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418de6e:	4618      	mov	r0, r3
3418de70:	46bd      	mov	sp, r7
3418de72:	f85d 7b04 	ldr.w	r7, [sp], #4
3418de76:	4770      	bx	lr
3418de78:	56028000 	.word	0x56028000

3418de7c <LL_RCC_IC4_GetDivider>:
{
3418de7c:	b480      	push	{r7}
3418de7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418de80:	4b05      	ldr	r3, [pc, #20]	@ (3418de98 <LL_RCC_IC4_GetDivider+0x1c>)
3418de82:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418de86:	0c1b      	lsrs	r3, r3, #16
3418de88:	b2db      	uxtb	r3, r3
3418de8a:	3301      	adds	r3, #1
}
3418de8c:	4618      	mov	r0, r3
3418de8e:	46bd      	mov	sp, r7
3418de90:	f85d 7b04 	ldr.w	r7, [sp], #4
3418de94:	4770      	bx	lr
3418de96:	bf00      	nop
3418de98:	56028000 	.word	0x56028000

3418de9c <LL_RCC_IC5_Enable>:
{
3418de9c:	b480      	push	{r7}
3418de9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418dea0:	4b04      	ldr	r3, [pc, #16]	@ (3418deb4 <LL_RCC_IC5_Enable+0x18>)
3418dea2:	2210      	movs	r2, #16
3418dea4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418dea8:	bf00      	nop
3418deaa:	46bd      	mov	sp, r7
3418deac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418deb0:	4770      	bx	lr
3418deb2:	bf00      	nop
3418deb4:	56028000 	.word	0x56028000

3418deb8 <LL_RCC_IC5_IsEnabled>:
{
3418deb8:	b480      	push	{r7}
3418deba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3418debc:	4b07      	ldr	r3, [pc, #28]	@ (3418dedc <LL_RCC_IC5_IsEnabled+0x24>)
3418debe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418dec2:	f003 0310 	and.w	r3, r3, #16
3418dec6:	2b10      	cmp	r3, #16
3418dec8:	d101      	bne.n	3418dece <LL_RCC_IC5_IsEnabled+0x16>
3418deca:	2301      	movs	r3, #1
3418decc:	e000      	b.n	3418ded0 <LL_RCC_IC5_IsEnabled+0x18>
3418dece:	2300      	movs	r3, #0
}
3418ded0:	4618      	mov	r0, r3
3418ded2:	46bd      	mov	sp, r7
3418ded4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ded8:	4770      	bx	lr
3418deda:	bf00      	nop
3418dedc:	56028000 	.word	0x56028000

3418dee0 <LL_RCC_IC5_GetSource>:
{
3418dee0:	b480      	push	{r7}
3418dee2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418dee4:	4b04      	ldr	r3, [pc, #16]	@ (3418def8 <LL_RCC_IC5_GetSource+0x18>)
3418dee6:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418deea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418deee:	4618      	mov	r0, r3
3418def0:	46bd      	mov	sp, r7
3418def2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418def6:	4770      	bx	lr
3418def8:	56028000 	.word	0x56028000

3418defc <LL_RCC_IC5_GetDivider>:
{
3418defc:	b480      	push	{r7}
3418defe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418df00:	4b05      	ldr	r3, [pc, #20]	@ (3418df18 <LL_RCC_IC5_GetDivider+0x1c>)
3418df02:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418df06:	0c1b      	lsrs	r3, r3, #16
3418df08:	b2db      	uxtb	r3, r3
3418df0a:	3301      	adds	r3, #1
}
3418df0c:	4618      	mov	r0, r3
3418df0e:	46bd      	mov	sp, r7
3418df10:	f85d 7b04 	ldr.w	r7, [sp], #4
3418df14:	4770      	bx	lr
3418df16:	bf00      	nop
3418df18:	56028000 	.word	0x56028000

3418df1c <LL_RCC_IC7_Enable>:
{
3418df1c:	b480      	push	{r7}
3418df1e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418df20:	4b04      	ldr	r3, [pc, #16]	@ (3418df34 <LL_RCC_IC7_Enable+0x18>)
3418df22:	2240      	movs	r2, #64	@ 0x40
3418df24:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418df28:	bf00      	nop
3418df2a:	46bd      	mov	sp, r7
3418df2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418df30:	4770      	bx	lr
3418df32:	bf00      	nop
3418df34:	56028000 	.word	0x56028000

3418df38 <LL_RCC_IC7_IsEnabled>:
{
3418df38:	b480      	push	{r7}
3418df3a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3418df3c:	4b07      	ldr	r3, [pc, #28]	@ (3418df5c <LL_RCC_IC7_IsEnabled+0x24>)
3418df3e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418df42:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418df46:	2b40      	cmp	r3, #64	@ 0x40
3418df48:	d101      	bne.n	3418df4e <LL_RCC_IC7_IsEnabled+0x16>
3418df4a:	2301      	movs	r3, #1
3418df4c:	e000      	b.n	3418df50 <LL_RCC_IC7_IsEnabled+0x18>
3418df4e:	2300      	movs	r3, #0
}
3418df50:	4618      	mov	r0, r3
3418df52:	46bd      	mov	sp, r7
3418df54:	f85d 7b04 	ldr.w	r7, [sp], #4
3418df58:	4770      	bx	lr
3418df5a:	bf00      	nop
3418df5c:	56028000 	.word	0x56028000

3418df60 <LL_RCC_IC7_GetSource>:
{
3418df60:	b480      	push	{r7}
3418df62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418df64:	4b04      	ldr	r3, [pc, #16]	@ (3418df78 <LL_RCC_IC7_GetSource+0x18>)
3418df66:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418df6a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418df6e:	4618      	mov	r0, r3
3418df70:	46bd      	mov	sp, r7
3418df72:	f85d 7b04 	ldr.w	r7, [sp], #4
3418df76:	4770      	bx	lr
3418df78:	56028000 	.word	0x56028000

3418df7c <LL_RCC_IC7_GetDivider>:
{
3418df7c:	b480      	push	{r7}
3418df7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3418df80:	4b05      	ldr	r3, [pc, #20]	@ (3418df98 <LL_RCC_IC7_GetDivider+0x1c>)
3418df82:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418df86:	0c1b      	lsrs	r3, r3, #16
3418df88:	b2db      	uxtb	r3, r3
3418df8a:	3301      	adds	r3, #1
}
3418df8c:	4618      	mov	r0, r3
3418df8e:	46bd      	mov	sp, r7
3418df90:	f85d 7b04 	ldr.w	r7, [sp], #4
3418df94:	4770      	bx	lr
3418df96:	bf00      	nop
3418df98:	56028000 	.word	0x56028000

3418df9c <LL_RCC_IC8_Enable>:
{
3418df9c:	b480      	push	{r7}
3418df9e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418dfa0:	4b04      	ldr	r3, [pc, #16]	@ (3418dfb4 <LL_RCC_IC8_Enable+0x18>)
3418dfa2:	2280      	movs	r2, #128	@ 0x80
3418dfa4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418dfa8:	bf00      	nop
3418dfaa:	46bd      	mov	sp, r7
3418dfac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dfb0:	4770      	bx	lr
3418dfb2:	bf00      	nop
3418dfb4:	56028000 	.word	0x56028000

3418dfb8 <LL_RCC_IC8_IsEnabled>:
{
3418dfb8:	b480      	push	{r7}
3418dfba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3418dfbc:	4b07      	ldr	r3, [pc, #28]	@ (3418dfdc <LL_RCC_IC8_IsEnabled+0x24>)
3418dfbe:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418dfc2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418dfc6:	2b80      	cmp	r3, #128	@ 0x80
3418dfc8:	d101      	bne.n	3418dfce <LL_RCC_IC8_IsEnabled+0x16>
3418dfca:	2301      	movs	r3, #1
3418dfcc:	e000      	b.n	3418dfd0 <LL_RCC_IC8_IsEnabled+0x18>
3418dfce:	2300      	movs	r3, #0
}
3418dfd0:	4618      	mov	r0, r3
3418dfd2:	46bd      	mov	sp, r7
3418dfd4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dfd8:	4770      	bx	lr
3418dfda:	bf00      	nop
3418dfdc:	56028000 	.word	0x56028000

3418dfe0 <LL_RCC_IC8_GetSource>:
{
3418dfe0:	b480      	push	{r7}
3418dfe2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418dfe4:	4b04      	ldr	r3, [pc, #16]	@ (3418dff8 <LL_RCC_IC8_GetSource+0x18>)
3418dfe6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418dfea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418dfee:	4618      	mov	r0, r3
3418dff0:	46bd      	mov	sp, r7
3418dff2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dff6:	4770      	bx	lr
3418dff8:	56028000 	.word	0x56028000

3418dffc <LL_RCC_IC8_GetDivider>:
{
3418dffc:	b480      	push	{r7}
3418dffe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3418e000:	4b05      	ldr	r3, [pc, #20]	@ (3418e018 <LL_RCC_IC8_GetDivider+0x1c>)
3418e002:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418e006:	0c1b      	lsrs	r3, r3, #16
3418e008:	b2db      	uxtb	r3, r3
3418e00a:	3301      	adds	r3, #1
}
3418e00c:	4618      	mov	r0, r3
3418e00e:	46bd      	mov	sp, r7
3418e010:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e014:	4770      	bx	lr
3418e016:	bf00      	nop
3418e018:	56028000 	.word	0x56028000

3418e01c <LL_RCC_IC9_Enable>:
{
3418e01c:	b480      	push	{r7}
3418e01e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418e020:	4b04      	ldr	r3, [pc, #16]	@ (3418e034 <LL_RCC_IC9_Enable+0x18>)
3418e022:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418e026:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e02a:	bf00      	nop
3418e02c:	46bd      	mov	sp, r7
3418e02e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e032:	4770      	bx	lr
3418e034:	56028000 	.word	0x56028000

3418e038 <LL_RCC_IC9_IsEnabled>:
{
3418e038:	b480      	push	{r7}
3418e03a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3418e03c:	4b07      	ldr	r3, [pc, #28]	@ (3418e05c <LL_RCC_IC9_IsEnabled+0x24>)
3418e03e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e042:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418e046:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418e04a:	d101      	bne.n	3418e050 <LL_RCC_IC9_IsEnabled+0x18>
3418e04c:	2301      	movs	r3, #1
3418e04e:	e000      	b.n	3418e052 <LL_RCC_IC9_IsEnabled+0x1a>
3418e050:	2300      	movs	r3, #0
}
3418e052:	4618      	mov	r0, r3
3418e054:	46bd      	mov	sp, r7
3418e056:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e05a:	4770      	bx	lr
3418e05c:	56028000 	.word	0x56028000

3418e060 <LL_RCC_IC9_GetSource>:
{
3418e060:	b480      	push	{r7}
3418e062:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418e064:	4b04      	ldr	r3, [pc, #16]	@ (3418e078 <LL_RCC_IC9_GetSource+0x18>)
3418e066:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418e06a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e06e:	4618      	mov	r0, r3
3418e070:	46bd      	mov	sp, r7
3418e072:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e076:	4770      	bx	lr
3418e078:	56028000 	.word	0x56028000

3418e07c <LL_RCC_IC9_GetDivider>:
{
3418e07c:	b480      	push	{r7}
3418e07e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3418e080:	4b05      	ldr	r3, [pc, #20]	@ (3418e098 <LL_RCC_IC9_GetDivider+0x1c>)
3418e082:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418e086:	0c1b      	lsrs	r3, r3, #16
3418e088:	b2db      	uxtb	r3, r3
3418e08a:	3301      	adds	r3, #1
}
3418e08c:	4618      	mov	r0, r3
3418e08e:	46bd      	mov	sp, r7
3418e090:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e094:	4770      	bx	lr
3418e096:	bf00      	nop
3418e098:	56028000 	.word	0x56028000

3418e09c <LL_RCC_IC10_Enable>:
{
3418e09c:	b480      	push	{r7}
3418e09e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418e0a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e0b4 <LL_RCC_IC10_Enable+0x18>)
3418e0a2:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418e0a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e0aa:	bf00      	nop
3418e0ac:	46bd      	mov	sp, r7
3418e0ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e0b2:	4770      	bx	lr
3418e0b4:	56028000 	.word	0x56028000

3418e0b8 <LL_RCC_IC10_IsEnabled>:
{
3418e0b8:	b480      	push	{r7}
3418e0ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3418e0bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e0dc <LL_RCC_IC10_IsEnabled+0x24>)
3418e0be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e0c2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418e0c6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418e0ca:	d101      	bne.n	3418e0d0 <LL_RCC_IC10_IsEnabled+0x18>
3418e0cc:	2301      	movs	r3, #1
3418e0ce:	e000      	b.n	3418e0d2 <LL_RCC_IC10_IsEnabled+0x1a>
3418e0d0:	2300      	movs	r3, #0
}
3418e0d2:	4618      	mov	r0, r3
3418e0d4:	46bd      	mov	sp, r7
3418e0d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e0da:	4770      	bx	lr
3418e0dc:	56028000 	.word	0x56028000

3418e0e0 <LL_RCC_IC10_GetSource>:
{
3418e0e0:	b480      	push	{r7}
3418e0e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418e0e4:	4b04      	ldr	r3, [pc, #16]	@ (3418e0f8 <LL_RCC_IC10_GetSource+0x18>)
3418e0e6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418e0ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e0ee:	4618      	mov	r0, r3
3418e0f0:	46bd      	mov	sp, r7
3418e0f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e0f6:	4770      	bx	lr
3418e0f8:	56028000 	.word	0x56028000

3418e0fc <LL_RCC_IC10_GetDivider>:
{
3418e0fc:	b480      	push	{r7}
3418e0fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418e100:	4b05      	ldr	r3, [pc, #20]	@ (3418e118 <LL_RCC_IC10_GetDivider+0x1c>)
3418e102:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418e106:	0c1b      	lsrs	r3, r3, #16
3418e108:	b2db      	uxtb	r3, r3
3418e10a:	3301      	adds	r3, #1
}
3418e10c:	4618      	mov	r0, r3
3418e10e:	46bd      	mov	sp, r7
3418e110:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e114:	4770      	bx	lr
3418e116:	bf00      	nop
3418e118:	56028000 	.word	0x56028000

3418e11c <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
3418e11c:	b480      	push	{r7}
3418e11e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3418e120:	4b04      	ldr	r3, [pc, #16]	@ (3418e134 <LL_RCC_IC12_Enable+0x18>)
3418e122:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3418e126:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e12a:	bf00      	nop
3418e12c:	46bd      	mov	sp, r7
3418e12e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e132:	4770      	bx	lr
3418e134:	56028000 	.word	0x56028000

3418e138 <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
3418e138:	b480      	push	{r7}
3418e13a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3418e13c:	4b07      	ldr	r3, [pc, #28]	@ (3418e15c <LL_RCC_IC12_IsEnabled+0x24>)
3418e13e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e142:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418e146:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418e14a:	d101      	bne.n	3418e150 <LL_RCC_IC12_IsEnabled+0x18>
3418e14c:	2301      	movs	r3, #1
3418e14e:	e000      	b.n	3418e152 <LL_RCC_IC12_IsEnabled+0x1a>
3418e150:	2300      	movs	r3, #0
}
3418e152:	4618      	mov	r0, r3
3418e154:	46bd      	mov	sp, r7
3418e156:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e15a:	4770      	bx	lr
3418e15c:	56028000 	.word	0x56028000

3418e160 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
3418e160:	b480      	push	{r7}
3418e162:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3418e164:	4b04      	ldr	r3, [pc, #16]	@ (3418e178 <LL_RCC_IC12_GetSource+0x18>)
3418e166:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418e16a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e16e:	4618      	mov	r0, r3
3418e170:	46bd      	mov	sp, r7
3418e172:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e176:	4770      	bx	lr
3418e178:	56028000 	.word	0x56028000

3418e17c <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
3418e17c:	b480      	push	{r7}
3418e17e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3418e180:	4b05      	ldr	r3, [pc, #20]	@ (3418e198 <LL_RCC_IC12_GetDivider+0x1c>)
3418e182:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418e186:	0c1b      	lsrs	r3, r3, #16
3418e188:	b2db      	uxtb	r3, r3
3418e18a:	3301      	adds	r3, #1
}
3418e18c:	4618      	mov	r0, r3
3418e18e:	46bd      	mov	sp, r7
3418e190:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e194:	4770      	bx	lr
3418e196:	bf00      	nop
3418e198:	56028000 	.word	0x56028000

3418e19c <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3418e19c:	b480      	push	{r7}
3418e19e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3418e1a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e1b4 <LL_RCC_IC13_Enable+0x18>)
3418e1a2:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3418e1a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e1aa:	bf00      	nop
3418e1ac:	46bd      	mov	sp, r7
3418e1ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e1b2:	4770      	bx	lr
3418e1b4:	56028000 	.word	0x56028000

3418e1b8 <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
3418e1b8:	b480      	push	{r7}
3418e1ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3418e1bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e1dc <LL_RCC_IC13_IsEnabled+0x24>)
3418e1be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e1c2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3418e1c6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3418e1ca:	d101      	bne.n	3418e1d0 <LL_RCC_IC13_IsEnabled+0x18>
3418e1cc:	2301      	movs	r3, #1
3418e1ce:	e000      	b.n	3418e1d2 <LL_RCC_IC13_IsEnabled+0x1a>
3418e1d0:	2300      	movs	r3, #0
}
3418e1d2:	4618      	mov	r0, r3
3418e1d4:	46bd      	mov	sp, r7
3418e1d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e1da:	4770      	bx	lr
3418e1dc:	56028000 	.word	0x56028000

3418e1e0 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
3418e1e0:	b480      	push	{r7}
3418e1e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3418e1e4:	4b04      	ldr	r3, [pc, #16]	@ (3418e1f8 <LL_RCC_IC13_GetSource+0x18>)
3418e1e6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418e1ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e1ee:	4618      	mov	r0, r3
3418e1f0:	46bd      	mov	sp, r7
3418e1f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e1f6:	4770      	bx	lr
3418e1f8:	56028000 	.word	0x56028000

3418e1fc <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
3418e1fc:	b480      	push	{r7}
3418e1fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3418e200:	4b05      	ldr	r3, [pc, #20]	@ (3418e218 <LL_RCC_IC13_GetDivider+0x1c>)
3418e202:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418e206:	0c1b      	lsrs	r3, r3, #16
3418e208:	b2db      	uxtb	r3, r3
3418e20a:	3301      	adds	r3, #1
}
3418e20c:	4618      	mov	r0, r3
3418e20e:	46bd      	mov	sp, r7
3418e210:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e214:	4770      	bx	lr
3418e216:	bf00      	nop
3418e218:	56028000 	.word	0x56028000

3418e21c <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
3418e21c:	b480      	push	{r7}
3418e21e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418e220:	4b04      	ldr	r3, [pc, #16]	@ (3418e234 <LL_RCC_IC14_Enable+0x18>)
3418e222:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3418e226:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e22a:	bf00      	nop
3418e22c:	46bd      	mov	sp, r7
3418e22e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e232:	4770      	bx	lr
3418e234:	56028000 	.word	0x56028000

3418e238 <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
3418e238:	b480      	push	{r7}
3418e23a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3418e23c:	4b07      	ldr	r3, [pc, #28]	@ (3418e25c <LL_RCC_IC14_IsEnabled+0x24>)
3418e23e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e242:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418e246:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3418e24a:	d101      	bne.n	3418e250 <LL_RCC_IC14_IsEnabled+0x18>
3418e24c:	2301      	movs	r3, #1
3418e24e:	e000      	b.n	3418e252 <LL_RCC_IC14_IsEnabled+0x1a>
3418e250:	2300      	movs	r3, #0
}
3418e252:	4618      	mov	r0, r3
3418e254:	46bd      	mov	sp, r7
3418e256:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e25a:	4770      	bx	lr
3418e25c:	56028000 	.word	0x56028000

3418e260 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
3418e260:	b480      	push	{r7}
3418e262:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418e264:	4b04      	ldr	r3, [pc, #16]	@ (3418e278 <LL_RCC_IC14_GetSource+0x18>)
3418e266:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418e26a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e26e:	4618      	mov	r0, r3
3418e270:	46bd      	mov	sp, r7
3418e272:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e276:	4770      	bx	lr
3418e278:	56028000 	.word	0x56028000

3418e27c <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
3418e27c:	b480      	push	{r7}
3418e27e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3418e280:	4b05      	ldr	r3, [pc, #20]	@ (3418e298 <LL_RCC_IC14_GetDivider+0x1c>)
3418e282:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418e286:	0c1b      	lsrs	r3, r3, #16
3418e288:	b2db      	uxtb	r3, r3
3418e28a:	3301      	adds	r3, #1
}
3418e28c:	4618      	mov	r0, r3
3418e28e:	46bd      	mov	sp, r7
3418e290:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e294:	4770      	bx	lr
3418e296:	bf00      	nop
3418e298:	56028000 	.word	0x56028000

3418e29c <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
3418e29c:	b480      	push	{r7}
3418e29e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418e2a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e2b4 <LL_RCC_IC15_Enable+0x18>)
3418e2a2:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3418e2a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e2aa:	bf00      	nop
3418e2ac:	46bd      	mov	sp, r7
3418e2ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e2b2:	4770      	bx	lr
3418e2b4:	56028000 	.word	0x56028000

3418e2b8 <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
3418e2b8:	b480      	push	{r7}
3418e2ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3418e2bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e2dc <LL_RCC_IC15_IsEnabled+0x24>)
3418e2be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e2c2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418e2c6:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3418e2ca:	d101      	bne.n	3418e2d0 <LL_RCC_IC15_IsEnabled+0x18>
3418e2cc:	2301      	movs	r3, #1
3418e2ce:	e000      	b.n	3418e2d2 <LL_RCC_IC15_IsEnabled+0x1a>
3418e2d0:	2300      	movs	r3, #0
}
3418e2d2:	4618      	mov	r0, r3
3418e2d4:	46bd      	mov	sp, r7
3418e2d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e2da:	4770      	bx	lr
3418e2dc:	56028000 	.word	0x56028000

3418e2e0 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
3418e2e0:	b480      	push	{r7}
3418e2e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418e2e4:	4b04      	ldr	r3, [pc, #16]	@ (3418e2f8 <LL_RCC_IC15_GetSource+0x18>)
3418e2e6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418e2ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e2ee:	4618      	mov	r0, r3
3418e2f0:	46bd      	mov	sp, r7
3418e2f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e2f6:	4770      	bx	lr
3418e2f8:	56028000 	.word	0x56028000

3418e2fc <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
3418e2fc:	b480      	push	{r7}
3418e2fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3418e300:	4b05      	ldr	r3, [pc, #20]	@ (3418e318 <LL_RCC_IC15_GetDivider+0x1c>)
3418e302:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418e306:	0c1b      	lsrs	r3, r3, #16
3418e308:	b2db      	uxtb	r3, r3
3418e30a:	3301      	adds	r3, #1
}
3418e30c:	4618      	mov	r0, r3
3418e30e:	46bd      	mov	sp, r7
3418e310:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e314:	4770      	bx	lr
3418e316:	bf00      	nop
3418e318:	56028000 	.word	0x56028000

3418e31c <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
3418e31c:	b480      	push	{r7}
3418e31e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3418e320:	4b04      	ldr	r3, [pc, #16]	@ (3418e334 <LL_RCC_IC16_Enable+0x18>)
3418e322:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3418e326:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e32a:	bf00      	nop
3418e32c:	46bd      	mov	sp, r7
3418e32e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e332:	4770      	bx	lr
3418e334:	56028000 	.word	0x56028000

3418e338 <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
3418e338:	b480      	push	{r7}
3418e33a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3418e33c:	4b07      	ldr	r3, [pc, #28]	@ (3418e35c <LL_RCC_IC16_IsEnabled+0x24>)
3418e33e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e342:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3418e346:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3418e34a:	d101      	bne.n	3418e350 <LL_RCC_IC16_IsEnabled+0x18>
3418e34c:	2301      	movs	r3, #1
3418e34e:	e000      	b.n	3418e352 <LL_RCC_IC16_IsEnabled+0x1a>
3418e350:	2300      	movs	r3, #0
}
3418e352:	4618      	mov	r0, r3
3418e354:	46bd      	mov	sp, r7
3418e356:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e35a:	4770      	bx	lr
3418e35c:	56028000 	.word	0x56028000

3418e360 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
3418e360:	b480      	push	{r7}
3418e362:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3418e364:	4b04      	ldr	r3, [pc, #16]	@ (3418e378 <LL_RCC_IC16_GetSource+0x18>)
3418e366:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418e36a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e36e:	4618      	mov	r0, r3
3418e370:	46bd      	mov	sp, r7
3418e372:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e376:	4770      	bx	lr
3418e378:	56028000 	.word	0x56028000

3418e37c <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
3418e37c:	b480      	push	{r7}
3418e37e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3418e380:	4b05      	ldr	r3, [pc, #20]	@ (3418e398 <LL_RCC_IC16_GetDivider+0x1c>)
3418e382:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418e386:	0c1b      	lsrs	r3, r3, #16
3418e388:	b2db      	uxtb	r3, r3
3418e38a:	3301      	adds	r3, #1
}
3418e38c:	4618      	mov	r0, r3
3418e38e:	46bd      	mov	sp, r7
3418e390:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e394:	4770      	bx	lr
3418e396:	bf00      	nop
3418e398:	56028000 	.word	0x56028000

3418e39c <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
3418e39c:	b480      	push	{r7}
3418e39e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3418e3a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e3b4 <LL_RCC_IC17_Enable+0x18>)
3418e3a2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3418e3a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e3aa:	bf00      	nop
3418e3ac:	46bd      	mov	sp, r7
3418e3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3b2:	4770      	bx	lr
3418e3b4:	56028000 	.word	0x56028000

3418e3b8 <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
3418e3b8:	b480      	push	{r7}
3418e3ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3418e3bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e3dc <LL_RCC_IC17_IsEnabled+0x24>)
3418e3be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e3c2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418e3c6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418e3ca:	d101      	bne.n	3418e3d0 <LL_RCC_IC17_IsEnabled+0x18>
3418e3cc:	2301      	movs	r3, #1
3418e3ce:	e000      	b.n	3418e3d2 <LL_RCC_IC17_IsEnabled+0x1a>
3418e3d0:	2300      	movs	r3, #0
}
3418e3d2:	4618      	mov	r0, r3
3418e3d4:	46bd      	mov	sp, r7
3418e3d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3da:	4770      	bx	lr
3418e3dc:	56028000 	.word	0x56028000

3418e3e0 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
3418e3e0:	b480      	push	{r7}
3418e3e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3418e3e4:	4b04      	ldr	r3, [pc, #16]	@ (3418e3f8 <LL_RCC_IC17_GetSource+0x18>)
3418e3e6:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418e3ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e3ee:	4618      	mov	r0, r3
3418e3f0:	46bd      	mov	sp, r7
3418e3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3f6:	4770      	bx	lr
3418e3f8:	56028000 	.word	0x56028000

3418e3fc <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
3418e3fc:	b480      	push	{r7}
3418e3fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3418e400:	4b05      	ldr	r3, [pc, #20]	@ (3418e418 <LL_RCC_IC17_GetDivider+0x1c>)
3418e402:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418e406:	0c1b      	lsrs	r3, r3, #16
3418e408:	b2db      	uxtb	r3, r3
3418e40a:	3301      	adds	r3, #1
}
3418e40c:	4618      	mov	r0, r3
3418e40e:	46bd      	mov	sp, r7
3418e410:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e414:	4770      	bx	lr
3418e416:	bf00      	nop
3418e418:	56028000 	.word	0x56028000

3418e41c <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
3418e41c:	b480      	push	{r7}
3418e41e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3418e420:	4b04      	ldr	r3, [pc, #16]	@ (3418e434 <LL_RCC_IC18_Enable+0x18>)
3418e422:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
3418e426:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e42a:	bf00      	nop
3418e42c:	46bd      	mov	sp, r7
3418e42e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e432:	4770      	bx	lr
3418e434:	56028000 	.word	0x56028000

3418e438 <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
3418e438:	b480      	push	{r7}
3418e43a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3418e43c:	4b07      	ldr	r3, [pc, #28]	@ (3418e45c <LL_RCC_IC18_IsEnabled+0x24>)
3418e43e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e442:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418e446:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418e44a:	d101      	bne.n	3418e450 <LL_RCC_IC18_IsEnabled+0x18>
3418e44c:	2301      	movs	r3, #1
3418e44e:	e000      	b.n	3418e452 <LL_RCC_IC18_IsEnabled+0x1a>
3418e450:	2300      	movs	r3, #0
}
3418e452:	4618      	mov	r0, r3
3418e454:	46bd      	mov	sp, r7
3418e456:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e45a:	4770      	bx	lr
3418e45c:	56028000 	.word	0x56028000

3418e460 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
3418e460:	b480      	push	{r7}
3418e462:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3418e464:	4b04      	ldr	r3, [pc, #16]	@ (3418e478 <LL_RCC_IC18_GetSource+0x18>)
3418e466:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418e46a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e46e:	4618      	mov	r0, r3
3418e470:	46bd      	mov	sp, r7
3418e472:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e476:	4770      	bx	lr
3418e478:	56028000 	.word	0x56028000

3418e47c <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
3418e47c:	b480      	push	{r7}
3418e47e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3418e480:	4b05      	ldr	r3, [pc, #20]	@ (3418e498 <LL_RCC_IC18_GetDivider+0x1c>)
3418e482:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418e486:	0c1b      	lsrs	r3, r3, #16
3418e488:	b2db      	uxtb	r3, r3
3418e48a:	3301      	adds	r3, #1
}
3418e48c:	4618      	mov	r0, r3
3418e48e:	46bd      	mov	sp, r7
3418e490:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e494:	4770      	bx	lr
3418e496:	bf00      	nop
3418e498:	56028000 	.word	0x56028000

3418e49c <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
3418e49c:	b480      	push	{r7}
3418e49e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3418e4a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e4b4 <LL_RCC_IC19_Enable+0x18>)
3418e4a2:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
3418e4a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e4aa:	bf00      	nop
3418e4ac:	46bd      	mov	sp, r7
3418e4ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e4b2:	4770      	bx	lr
3418e4b4:	56028000 	.word	0x56028000

3418e4b8 <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
3418e4b8:	b480      	push	{r7}
3418e4ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3418e4bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e4dc <LL_RCC_IC19_IsEnabled+0x24>)
3418e4be:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e4c2:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3418e4c6:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3418e4ca:	d101      	bne.n	3418e4d0 <LL_RCC_IC19_IsEnabled+0x18>
3418e4cc:	2301      	movs	r3, #1
3418e4ce:	e000      	b.n	3418e4d2 <LL_RCC_IC19_IsEnabled+0x1a>
3418e4d0:	2300      	movs	r3, #0
}
3418e4d2:	4618      	mov	r0, r3
3418e4d4:	46bd      	mov	sp, r7
3418e4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e4da:	4770      	bx	lr
3418e4dc:	56028000 	.word	0x56028000

3418e4e0 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
3418e4e0:	b480      	push	{r7}
3418e4e2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418e4e4:	4b04      	ldr	r3, [pc, #16]	@ (3418e4f8 <LL_RCC_IC19_GetSource+0x18>)
3418e4e6:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418e4ea:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e4ee:	4618      	mov	r0, r3
3418e4f0:	46bd      	mov	sp, r7
3418e4f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e4f6:	4770      	bx	lr
3418e4f8:	56028000 	.word	0x56028000

3418e4fc <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
3418e4fc:	b480      	push	{r7}
3418e4fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418e500:	4b05      	ldr	r3, [pc, #20]	@ (3418e518 <LL_RCC_IC19_GetDivider+0x1c>)
3418e502:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418e506:	0c1b      	lsrs	r3, r3, #16
3418e508:	b2db      	uxtb	r3, r3
3418e50a:	3301      	adds	r3, #1
}
3418e50c:	4618      	mov	r0, r3
3418e50e:	46bd      	mov	sp, r7
3418e510:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e514:	4770      	bx	lr
3418e516:	bf00      	nop
3418e518:	56028000 	.word	0x56028000

3418e51c <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
3418e51c:	b480      	push	{r7}
3418e51e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3418e520:	4b04      	ldr	r3, [pc, #16]	@ (3418e534 <LL_RCC_IC20_Enable+0x18>)
3418e522:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3418e526:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418e52a:	bf00      	nop
3418e52c:	46bd      	mov	sp, r7
3418e52e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e532:	4770      	bx	lr
3418e534:	56028000 	.word	0x56028000

3418e538 <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
3418e538:	b480      	push	{r7}
3418e53a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3418e53c:	4b07      	ldr	r3, [pc, #28]	@ (3418e55c <LL_RCC_IC20_IsEnabled+0x24>)
3418e53e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418e542:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3418e546:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
3418e54a:	d101      	bne.n	3418e550 <LL_RCC_IC20_IsEnabled+0x18>
3418e54c:	2301      	movs	r3, #1
3418e54e:	e000      	b.n	3418e552 <LL_RCC_IC20_IsEnabled+0x1a>
3418e550:	2300      	movs	r3, #0
}
3418e552:	4618      	mov	r0, r3
3418e554:	46bd      	mov	sp, r7
3418e556:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e55a:	4770      	bx	lr
3418e55c:	56028000 	.word	0x56028000

3418e560 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
3418e560:	b480      	push	{r7}
3418e562:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418e564:	4b04      	ldr	r3, [pc, #16]	@ (3418e578 <LL_RCC_IC20_GetSource+0x18>)
3418e566:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418e56a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418e56e:	4618      	mov	r0, r3
3418e570:	46bd      	mov	sp, r7
3418e572:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e576:	4770      	bx	lr
3418e578:	56028000 	.word	0x56028000

3418e57c <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
3418e57c:	b480      	push	{r7}
3418e57e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418e580:	4b05      	ldr	r3, [pc, #20]	@ (3418e598 <LL_RCC_IC20_GetDivider+0x1c>)
3418e582:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418e586:	0c1b      	lsrs	r3, r3, #16
3418e588:	b2db      	uxtb	r3, r3
3418e58a:	3301      	adds	r3, #1
}
3418e58c:	4618      	mov	r0, r3
3418e58e:	46bd      	mov	sp, r7
3418e590:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e594:	4770      	bx	lr
3418e596:	bf00      	nop
3418e598:	56028000 	.word	0x56028000

3418e59c <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
3418e59c:	b480      	push	{r7}
3418e59e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418e5a0:	4b04      	ldr	r3, [pc, #16]	@ (3418e5b4 <LL_RCC_CLKP_Enable+0x18>)
3418e5a2:	2240      	movs	r2, #64	@ 0x40
3418e5a4:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
3418e5a8:	bf00      	nop
3418e5aa:	46bd      	mov	sp, r7
3418e5ac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e5b0:	4770      	bx	lr
3418e5b2:	bf00      	nop
3418e5b4:	56028000 	.word	0x56028000

3418e5b8 <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
3418e5b8:	b480      	push	{r7}
3418e5ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3418e5bc:	4b07      	ldr	r3, [pc, #28]	@ (3418e5dc <LL_RCC_CLKP_IsEnabled+0x24>)
3418e5be:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
3418e5c2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418e5c6:	2b40      	cmp	r3, #64	@ 0x40
3418e5c8:	d101      	bne.n	3418e5ce <LL_RCC_CLKP_IsEnabled+0x16>
3418e5ca:	2301      	movs	r3, #1
3418e5cc:	e000      	b.n	3418e5d0 <LL_RCC_CLKP_IsEnabled+0x18>
3418e5ce:	2300      	movs	r3, #0
}
3418e5d0:	4618      	mov	r0, r3
3418e5d2:	46bd      	mov	sp, r7
3418e5d4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e5d8:	4770      	bx	lr
3418e5da:	bf00      	nop
3418e5dc:	56028000 	.word	0x56028000

3418e5e0 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
3418e5e0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3418e5e4:	b0f2      	sub	sp, #456	@ 0x1c8
3418e5e6:	af00      	add	r7, sp, #0
3418e5e8:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
3418e5ec:	2300      	movs	r3, #0
3418e5ee:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3418e5f2:	2300      	movs	r3, #0
3418e5f4:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418e5f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e5fc:	e9d3 2300 	ldrd	r2, r3, [r3]
3418e600:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
3418e604:	2500      	movs	r5, #0
3418e606:	ea54 0305 	orrs.w	r3, r4, r5
3418e60a:	d06c      	beq.n	3418e6e6 <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
3418e60c:	f7ff f91e 	bl	3418d84c <LL_RCC_GetRTCClockSource>
3418e610:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3418e614:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
3418e618:	2b00      	cmp	r3, #0
3418e61a:	d018      	beq.n	3418e64e <HAL_RCCEx_PeriphCLKConfig+0x6e>
3418e61c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e620:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418e624:	f403 7240 	and.w	r2, r3, #768	@ 0x300
3418e628:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
3418e62c:	4293      	cmp	r3, r2
3418e62e:	d00e      	beq.n	3418e64e <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3418e630:	4bc3      	ldr	r3, [pc, #780]	@ (3418e940 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418e632:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418e634:	4ac2      	ldr	r2, [pc, #776]	@ (3418e940 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418e636:	f043 0301 	orr.w	r3, r3, #1
3418e63a:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3418e63c:	4bc0      	ldr	r3, [pc, #768]	@ (3418e940 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418e63e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418e640:	f003 0301 	and.w	r3, r3, #1
3418e644:	2b00      	cmp	r3, #0
3418e646:	d102      	bne.n	3418e64e <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
3418e648:	2301      	movs	r3, #1
3418e64a:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
3418e64e:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418e652:	2b00      	cmp	r3, #0
3418e654:	d143      	bne.n	3418e6de <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3418e656:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e65a:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418e65e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418e662:	d117      	bne.n	3418e694 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418e664:	f7f6 fe74 	bl	34185350 <HAL_GetTick>
3418e668:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
3418e66c:	e00d      	b.n	3418e68a <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418e66e:	f7f6 fe6f 	bl	34185350 <HAL_GetTick>
3418e672:	4602      	mov	r2, r0
3418e674:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
3418e678:	1ad2      	subs	r2, r2, r3
3418e67a:	f241 3388 	movw	r3, #5000	@ 0x1388
3418e67e:	429a      	cmp	r2, r3
3418e680:	d903      	bls.n	3418e68a <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
3418e682:	2303      	movs	r3, #3
3418e684:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
3418e688:	e004      	b.n	3418e694 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
3418e68a:	f7fe fcf1 	bl	3418d070 <LL_RCC_LSE_IsReady>
3418e68e:	4603      	mov	r3, r0
3418e690:	2b00      	cmp	r3, #0
3418e692:	d0ec      	beq.n	3418e66e <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
3418e694:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418e698:	2b00      	cmp	r3, #0
3418e69a:	d11b      	bne.n	3418e6d4 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3418e69c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e6a0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418e6a4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3418e6a8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3418e6ac:	d108      	bne.n	3418e6c0 <HAL_RCCEx_PeriphCLKConfig+0xe0>
3418e6ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e6b2:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418e6b6:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3418e6ba:	4618      	mov	r0, r3
3418e6bc:	f7ff f8d4 	bl	3418d868 <LL_RCC_SetRTC_HSEPrescaler>
3418e6c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e6c4:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418e6c8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3418e6cc:	4618      	mov	r0, r3
3418e6ce:	f7ff f8a7 	bl	3418d820 <LL_RCC_SetRTCClockSource>
3418e6d2:	e008      	b.n	3418e6e6 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
3418e6d4:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418e6d8:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
3418e6dc:	e003      	b.n	3418e6e6 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3418e6de:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418e6e2:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3418e6e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e6ea:	e9d3 2300 	ldrd	r2, r3, [r3]
3418e6ee:	f002 0804 	and.w	r8, r2, #4
3418e6f2:	f04f 0900 	mov.w	r9, #0
3418e6f6:	ea58 0309 	orrs.w	r3, r8, r9
3418e6fa:	f000 809b 	beq.w	3418e834 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3418e6fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e702:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e706:	2b04      	cmp	r3, #4
3418e708:	d116      	bne.n	3418e738 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418e70a:	4b8e      	ldr	r3, [pc, #568]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e70c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418e710:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e714:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e718:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e71c:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418e71e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e722:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418e724:	3b01      	subs	r3, #1
3418e726:	041b      	lsls	r3, r3, #16
3418e728:	4313      	orrs	r3, r2
3418e72a:	4a86      	ldr	r2, [pc, #536]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e72c:	430b      	orrs	r3, r1
3418e72e:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3418e732:	f7ff fbb3 	bl	3418de9c <LL_RCC_IC5_Enable>
3418e736:	e076      	b.n	3418e826 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
3418e738:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e73c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e740:	2b05      	cmp	r3, #5
3418e742:	d116      	bne.n	3418e772 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418e744:	4b7f      	ldr	r3, [pc, #508]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e746:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418e74a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e74e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e752:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e756:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418e758:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e75c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418e75e:	3b01      	subs	r3, #1
3418e760:	041b      	lsls	r3, r3, #16
3418e762:	4313      	orrs	r3, r2
3418e764:	4a77      	ldr	r2, [pc, #476]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e766:	430b      	orrs	r3, r1
3418e768:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418e76c:	f7ff fc96 	bl	3418e09c <LL_RCC_IC10_Enable>
3418e770:	e059      	b.n	3418e826 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
3418e772:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e776:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e77a:	2b06      	cmp	r3, #6
3418e77c:	d116      	bne.n	3418e7ac <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418e77e:	4b71      	ldr	r3, [pc, #452]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e780:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418e784:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e788:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e78c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e790:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418e792:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e796:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418e798:	3b01      	subs	r3, #1
3418e79a:	041b      	lsls	r3, r3, #16
3418e79c:	4313      	orrs	r3, r2
3418e79e:	4a69      	ldr	r2, [pc, #420]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e7a0:	430b      	orrs	r3, r1
3418e7a2:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418e7a6:	f7ff fd79 	bl	3418e29c <LL_RCC_IC15_Enable>
3418e7aa:	e03c      	b.n	3418e826 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
3418e7ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e7b0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e7b4:	2b03      	cmp	r3, #3
3418e7b6:	d118      	bne.n	3418e7ea <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3418e7b8:	4b62      	ldr	r3, [pc, #392]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e7ba:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418e7be:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e7c2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e7c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e7ca:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3418e7ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e7d2:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3418e7d6:	3b01      	subs	r3, #1
3418e7d8:	041b      	lsls	r3, r3, #16
3418e7da:	4313      	orrs	r3, r2
3418e7dc:	4a59      	ldr	r2, [pc, #356]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e7de:	430b      	orrs	r3, r1
3418e7e0:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3418e7e4:	f7ff fe5a 	bl	3418e49c <LL_RCC_IC19_Enable>
3418e7e8:	e01d      	b.n	3418e826 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3418e7ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e7ee:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e7f2:	2b07      	cmp	r3, #7
3418e7f4:	d117      	bne.n	3418e826 <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418e7f6:	4b53      	ldr	r3, [pc, #332]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e7f8:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418e7fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e800:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e804:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e808:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3418e80c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e810:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418e814:	3b01      	subs	r3, #1
3418e816:	041b      	lsls	r3, r3, #16
3418e818:	4313      	orrs	r3, r2
3418e81a:	4a4a      	ldr	r2, [pc, #296]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e81c:	430b      	orrs	r3, r1
3418e81e:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418e822:	f7ff fe7b 	bl	3418e51c <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3418e826:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e82a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418e82e:	4618      	mov	r0, r3
3418e830:	f7fe fcd2 	bl	3418d1d8 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3418e834:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e838:	e9d3 2300 	ldrd	r2, r3, [r3]
3418e83c:	f04f 0a00 	mov.w	sl, #0
3418e840:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
3418e844:	ea5a 030b 	orrs.w	r3, sl, fp
3418e848:	d04b      	beq.n	3418e8e2 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3418e84a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e84e:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418e852:	4b3d      	ldr	r3, [pc, #244]	@ (3418e948 <HAL_RCCEx_PeriphCLKConfig+0x368>)
3418e854:	429a      	cmp	r2, r3
3418e856:	d116      	bne.n	3418e886 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418e858:	4b3a      	ldr	r3, [pc, #232]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e85a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418e85e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e862:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e866:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e86a:	699a      	ldr	r2, [r3, #24]
3418e86c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e870:	69db      	ldr	r3, [r3, #28]
3418e872:	3b01      	subs	r3, #1
3418e874:	041b      	lsls	r3, r3, #16
3418e876:	4313      	orrs	r3, r2
3418e878:	4a32      	ldr	r2, [pc, #200]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e87a:	430b      	orrs	r3, r1
3418e87c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418e880:	f7ff fa8c 	bl	3418dd9c <LL_RCC_IC3_Enable>
3418e884:	e026      	b.n	3418e8d4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3418e886:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e88a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418e88e:	4b2f      	ldr	r3, [pc, #188]	@ (3418e94c <HAL_RCCEx_PeriphCLKConfig+0x36c>)
3418e890:	429a      	cmp	r2, r3
3418e892:	d116      	bne.n	3418e8c2 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418e894:	4b2b      	ldr	r3, [pc, #172]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e896:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418e89a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e89e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e8a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e8a6:	6a1a      	ldr	r2, [r3, #32]
3418e8a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e8ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e8ae:	3b01      	subs	r3, #1
3418e8b0:	041b      	lsls	r3, r3, #16
3418e8b2:	4313      	orrs	r3, r2
3418e8b4:	4a23      	ldr	r2, [pc, #140]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e8b6:	430b      	orrs	r3, r1
3418e8b8:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418e8bc:	f7ff faae 	bl	3418de1c <LL_RCC_IC4_Enable>
3418e8c0:	e008      	b.n	3418e8d4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3418e8c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e8c6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418e8ca:	4b21      	ldr	r3, [pc, #132]	@ (3418e950 <HAL_RCCEx_PeriphCLKConfig+0x370>)
3418e8cc:	429a      	cmp	r2, r3
3418e8ce:	d101      	bne.n	3418e8d4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
3418e8d0:	f7ff fe64 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
3418e8d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e8d8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3418e8dc:	4618      	mov	r0, r3
3418e8de:	f7fe fe0b 	bl	3418d4f8 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3418e8e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e8e6:	e9d3 2300 	ldrd	r2, r3, [r3]
3418e8ea:	2100      	movs	r1, #0
3418e8ec:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
3418e8f0:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3418e8f4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3418e8f8:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
3418e8fc:	4603      	mov	r3, r0
3418e8fe:	460a      	mov	r2, r1
3418e900:	4313      	orrs	r3, r2
3418e902:	d057      	beq.n	3418e9b4 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3418e904:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e908:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418e90c:	4b11      	ldr	r3, [pc, #68]	@ (3418e954 <HAL_RCCEx_PeriphCLKConfig+0x374>)
3418e90e:	429a      	cmp	r2, r3
3418e910:	d122      	bne.n	3418e958 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418e912:	4b0c      	ldr	r3, [pc, #48]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e914:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418e918:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e91c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e920:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e924:	699a      	ldr	r2, [r3, #24]
3418e926:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e92a:	69db      	ldr	r3, [r3, #28]
3418e92c:	3b01      	subs	r3, #1
3418e92e:	041b      	lsls	r3, r3, #16
3418e930:	4313      	orrs	r3, r2
3418e932:	4a04      	ldr	r2, [pc, #16]	@ (3418e944 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418e934:	430b      	orrs	r3, r1
3418e936:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418e93a:	f7ff fa2f 	bl	3418dd9c <LL_RCC_IC3_Enable>
3418e93e:	e032      	b.n	3418e9a6 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
3418e940:	56024800 	.word	0x56024800
3418e944:	56028000 	.word	0x56028000
3418e948:	03020014 	.word	0x03020014
3418e94c:	03030014 	.word	0x03030014
3418e950:	03010014 	.word	0x03010014
3418e954:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3418e958:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e95c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418e960:	4bc5      	ldr	r3, [pc, #788]	@ (3418ec78 <HAL_RCCEx_PeriphCLKConfig+0x698>)
3418e962:	429a      	cmp	r2, r3
3418e964:	d116      	bne.n	3418e994 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418e966:	4bc5      	ldr	r3, [pc, #788]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418e968:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418e96c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e970:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e974:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e978:	6a1a      	ldr	r2, [r3, #32]
3418e97a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e97e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e980:	3b01      	subs	r3, #1
3418e982:	041b      	lsls	r3, r3, #16
3418e984:	4313      	orrs	r3, r2
3418e986:	4abd      	ldr	r2, [pc, #756]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418e988:	430b      	orrs	r3, r1
3418e98a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418e98e:	f7ff fa45 	bl	3418de1c <LL_RCC_IC4_Enable>
3418e992:	e008      	b.n	3418e9a6 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3418e994:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e998:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418e99c:	4bb8      	ldr	r3, [pc, #736]	@ (3418ec80 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
3418e99e:	429a      	cmp	r2, r3
3418e9a0:	d101      	bne.n	3418e9a6 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
3418e9a2:	f7ff fdfb 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
3418e9a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e9aa:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418e9ae:	4618      	mov	r0, r3
3418e9b0:	f7fe fda2 	bl	3418d4f8 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3418e9b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e9b8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418e9bc:	2100      	movs	r1, #0
3418e9be:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
3418e9c2:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418e9c6:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
3418e9ca:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
3418e9ce:	4603      	mov	r3, r0
3418e9d0:	460a      	mov	r2, r1
3418e9d2:	4313      	orrs	r3, r2
3418e9d4:	d04b      	beq.n	3418ea6e <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3418e9d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e9da:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418e9de:	4ba9      	ldr	r3, [pc, #676]	@ (3418ec84 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
3418e9e0:	429a      	cmp	r2, r3
3418e9e2:	d116      	bne.n	3418ea12 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418e9e4:	4ba5      	ldr	r3, [pc, #660]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418e9e6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418e9ea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418e9ee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418e9f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e9f6:	699a      	ldr	r2, [r3, #24]
3418e9f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418e9fc:	69db      	ldr	r3, [r3, #28]
3418e9fe:	3b01      	subs	r3, #1
3418ea00:	041b      	lsls	r3, r3, #16
3418ea02:	4313      	orrs	r3, r2
3418ea04:	4a9d      	ldr	r2, [pc, #628]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ea06:	430b      	orrs	r3, r1
3418ea08:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418ea0c:	f7ff f9c6 	bl	3418dd9c <LL_RCC_IC3_Enable>
3418ea10:	e026      	b.n	3418ea60 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3418ea12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea16:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418ea1a:	4b9b      	ldr	r3, [pc, #620]	@ (3418ec88 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
3418ea1c:	429a      	cmp	r2, r3
3418ea1e:	d116      	bne.n	3418ea4e <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418ea20:	4b96      	ldr	r3, [pc, #600]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ea22:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418ea26:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ea2a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ea2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea32:	6a1a      	ldr	r2, [r3, #32]
3418ea34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ea3a:	3b01      	subs	r3, #1
3418ea3c:	041b      	lsls	r3, r3, #16
3418ea3e:	4313      	orrs	r3, r2
3418ea40:	4a8e      	ldr	r2, [pc, #568]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ea42:	430b      	orrs	r3, r1
3418ea44:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418ea48:	f7ff f9e8 	bl	3418de1c <LL_RCC_IC4_Enable>
3418ea4c:	e008      	b.n	3418ea60 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3418ea4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea52:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418ea56:	4b8d      	ldr	r3, [pc, #564]	@ (3418ec8c <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
3418ea58:	429a      	cmp	r2, r3
3418ea5a:	d101      	bne.n	3418ea60 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
3418ea5c:	f7ff fd9e 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
3418ea60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea64:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418ea68:	4618      	mov	r0, r3
3418ea6a:	f7fe fd45 	bl	3418d4f8 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3418ea6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea72:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ea76:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3418ea7a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
3418ea7e:	2300      	movs	r3, #0
3418ea80:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
3418ea84:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
3418ea88:	4603      	mov	r3, r0
3418ea8a:	460a      	mov	r2, r1
3418ea8c:	4313      	orrs	r3, r2
3418ea8e:	d048      	beq.n	3418eb22 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3418ea90:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ea94:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418ea98:	2b20      	cmp	r3, #32
3418ea9a:	d116      	bne.n	3418eaca <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418ea9c:	4b77      	ldr	r3, [pc, #476]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ea9e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418eaa2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418eaa6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418eaaa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eaae:	699a      	ldr	r2, [r3, #24]
3418eab0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eab4:	69db      	ldr	r3, [r3, #28]
3418eab6:	3b01      	subs	r3, #1
3418eab8:	041b      	lsls	r3, r3, #16
3418eaba:	4313      	orrs	r3, r2
3418eabc:	4a6f      	ldr	r2, [pc, #444]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418eabe:	430b      	orrs	r3, r1
3418eac0:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418eac4:	f7ff f96a 	bl	3418dd9c <LL_RCC_IC3_Enable>
3418eac8:	e024      	b.n	3418eb14 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3418eaca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eace:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418ead2:	2b30      	cmp	r3, #48	@ 0x30
3418ead4:	d116      	bne.n	3418eb04 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418ead6:	4b69      	ldr	r3, [pc, #420]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ead8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418eadc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418eae0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418eae4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eae8:	6a1a      	ldr	r2, [r3, #32]
3418eaea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eaee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418eaf0:	3b01      	subs	r3, #1
3418eaf2:	041b      	lsls	r3, r3, #16
3418eaf4:	4313      	orrs	r3, r2
3418eaf6:	4a61      	ldr	r2, [pc, #388]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418eaf8:	430b      	orrs	r3, r1
3418eafa:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418eafe:	f7ff f98d 	bl	3418de1c <LL_RCC_IC4_Enable>
3418eb02:	e007      	b.n	3418eb14 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3418eb04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb08:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418eb0c:	2b10      	cmp	r3, #16
3418eb0e:	d101      	bne.n	3418eb14 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
3418eb10:	f7ff fd44 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
3418eb14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb18:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418eb1c:	4618      	mov	r0, r3
3418eb1e:	f7fe fc03 	bl	3418d328 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3418eb22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb26:	e9d3 2300 	ldrd	r2, r3, [r3]
3418eb2a:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3418eb2e:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
3418eb32:	2300      	movs	r3, #0
3418eb34:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
3418eb38:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
3418eb3c:	4603      	mov	r3, r0
3418eb3e:	460a      	mov	r2, r1
3418eb40:	4313      	orrs	r3, r2
3418eb42:	d04b      	beq.n	3418ebdc <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3418eb44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb48:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418eb4c:	4b50      	ldr	r3, [pc, #320]	@ (3418ec90 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
3418eb4e:	429a      	cmp	r2, r3
3418eb50:	d116      	bne.n	3418eb80 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418eb52:	4b4a      	ldr	r3, [pc, #296]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418eb54:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418eb58:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418eb5c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418eb60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb64:	6a1a      	ldr	r2, [r3, #32]
3418eb66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb6a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418eb6c:	3b01      	subs	r3, #1
3418eb6e:	041b      	lsls	r3, r3, #16
3418eb70:	4313      	orrs	r3, r2
3418eb72:	4a42      	ldr	r2, [pc, #264]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418eb74:	430b      	orrs	r3, r1
3418eb76:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418eb7a:	f7ff f94f 	bl	3418de1c <LL_RCC_IC4_Enable>
3418eb7e:	e026      	b.n	3418ebce <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3418eb80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eb84:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418eb88:	4b42      	ldr	r3, [pc, #264]	@ (3418ec94 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
3418eb8a:	429a      	cmp	r2, r3
3418eb8c:	d116      	bne.n	3418ebbc <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418eb8e:	4b3b      	ldr	r3, [pc, #236]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418eb90:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418eb94:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418eb98:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418eb9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eba0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418eba2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eba6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418eba8:	3b01      	subs	r3, #1
3418ebaa:	041b      	lsls	r3, r3, #16
3418ebac:	4313      	orrs	r3, r2
3418ebae:	4a33      	ldr	r2, [pc, #204]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ebb0:	430b      	orrs	r3, r1
3418ebb2:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3418ebb6:	f7ff f971 	bl	3418de9c <LL_RCC_IC5_Enable>
3418ebba:	e008      	b.n	3418ebce <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3418ebbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ebc0:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418ebc4:	4b34      	ldr	r3, [pc, #208]	@ (3418ec98 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
3418ebc6:	429a      	cmp	r2, r3
3418ebc8:	d101      	bne.n	3418ebce <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
3418ebca:	f7ff fce7 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
3418ebce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ebd2:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
3418ebd6:	4618      	mov	r0, r3
3418ebd8:	f7fe fc57 	bl	3418d48a <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3418ebdc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ebe0:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ebe4:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3418ebe8:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
3418ebec:	2300      	movs	r3, #0
3418ebee:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
3418ebf2:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3418ebf6:	4603      	mov	r3, r0
3418ebf8:	460a      	mov	r2, r1
3418ebfa:	4313      	orrs	r3, r2
3418ebfc:	d062      	beq.n	3418ecc4 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3418ebfe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec02:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418ec06:	4b25      	ldr	r3, [pc, #148]	@ (3418ec9c <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
3418ec08:	429a      	cmp	r2, r3
3418ec0a:	d116      	bne.n	3418ec3a <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418ec0c:	4b1b      	ldr	r3, [pc, #108]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ec0e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418ec12:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ec16:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ec1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec1e:	6a1a      	ldr	r2, [r3, #32]
3418ec20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec24:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ec26:	3b01      	subs	r3, #1
3418ec28:	041b      	lsls	r3, r3, #16
3418ec2a:	4313      	orrs	r3, r2
3418ec2c:	4a13      	ldr	r2, [pc, #76]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ec2e:	430b      	orrs	r3, r1
3418ec30:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418ec34:	f7ff f8f2 	bl	3418de1c <LL_RCC_IC4_Enable>
3418ec38:	e03d      	b.n	3418ecb6 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3418ec3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec3e:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418ec42:	4b17      	ldr	r3, [pc, #92]	@ (3418eca0 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
3418ec44:	429a      	cmp	r2, r3
3418ec46:	d12d      	bne.n	3418eca4 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418ec48:	4b0c      	ldr	r3, [pc, #48]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ec4a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418ec4e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ec52:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ec56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec5a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418ec5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ec60:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418ec62:	3b01      	subs	r3, #1
3418ec64:	041b      	lsls	r3, r3, #16
3418ec66:	4313      	orrs	r3, r2
3418ec68:	4a04      	ldr	r2, [pc, #16]	@ (3418ec7c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ec6a:	430b      	orrs	r3, r1
3418ec6c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3418ec70:	f7ff f914 	bl	3418de9c <LL_RCC_IC5_Enable>
3418ec74:	e01f      	b.n	3418ecb6 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
3418ec76:	bf00      	nop
3418ec78:	03030414 	.word	0x03030414
3418ec7c:	56028000 	.word	0x56028000
3418ec80:	03010414 	.word	0x03010414
3418ec84:	03020814 	.word	0x03020814
3418ec88:	03030814 	.word	0x03030814
3418ec8c:	03010814 	.word	0x03010814
3418ec90:	0302001c 	.word	0x0302001c
3418ec94:	0303001c 	.word	0x0303001c
3418ec98:	0301001c 	.word	0x0301001c
3418ec9c:	0302041c 	.word	0x0302041c
3418eca0:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
3418eca4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eca8:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418ecac:	4bb3      	ldr	r3, [pc, #716]	@ (3418ef7c <HAL_RCCEx_PeriphCLKConfig+0x99c>)
3418ecae:	429a      	cmp	r2, r3
3418ecb0:	d101      	bne.n	3418ecb6 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
3418ecb2:	f7ff fc73 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
3418ecb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ecba:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
3418ecbe:	4618      	mov	r0, r3
3418ecc0:	f7fe fbe3 	bl	3418d48a <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
3418ecc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ecc8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418eccc:	f002 0301 	and.w	r3, r2, #1
3418ecd0:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
3418ecd4:	2300      	movs	r3, #0
3418ecd6:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
3418ecda:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
3418ecde:	4603      	mov	r3, r0
3418ece0:	460a      	mov	r2, r1
3418ece2:	4313      	orrs	r3, r2
3418ece4:	d057      	beq.n	3418ed96 <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3418ece6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ecea:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3418ecee:	2b20      	cmp	r3, #32
3418ecf0:	d116      	bne.n	3418ed20 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418ecf2:	4ba3      	ldr	r3, [pc, #652]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ecf4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418ecf8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ecfc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ed00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed04:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418ed06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed0a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418ed0c:	3b01      	subs	r3, #1
3418ed0e:	041b      	lsls	r3, r3, #16
3418ed10:	4313      	orrs	r3, r2
3418ed12:	4a9b      	ldr	r2, [pc, #620]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ed14:	430b      	orrs	r3, r1
3418ed16:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418ed1a:	f7ff f8ff 	bl	3418df1c <LL_RCC_IC7_Enable>
3418ed1e:	e024      	b.n	3418ed6a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
3418ed20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed24:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3418ed28:	2b30      	cmp	r3, #48	@ 0x30
3418ed2a:	d116      	bne.n	3418ed5a <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418ed2c:	4b94      	ldr	r3, [pc, #592]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ed2e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418ed32:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ed36:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ed3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed3e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418ed40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed44:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418ed46:	3b01      	subs	r3, #1
3418ed48:	041b      	lsls	r3, r3, #16
3418ed4a:	4313      	orrs	r3, r2
3418ed4c:	4a8c      	ldr	r2, [pc, #560]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ed4e:	430b      	orrs	r3, r1
3418ed50:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418ed54:	f7ff f922 	bl	3418df9c <LL_RCC_IC8_Enable>
3418ed58:	e007      	b.n	3418ed6a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3418ed5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed5e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3418ed62:	2b10      	cmp	r3, #16
3418ed64:	d101      	bne.n	3418ed6a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
3418ed66:	f7ff fc19 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3418ed6a:	4b85      	ldr	r3, [pc, #532]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ed6c:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418ed70:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
3418ed74:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
3418ed78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed7c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
3418ed80:	3b01      	subs	r3, #1
3418ed82:	021a      	lsls	r2, r3, #8
3418ed84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed88:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3418ed8c:	4313      	orrs	r3, r2
3418ed8e:	4a7c      	ldr	r2, [pc, #496]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ed90:	430b      	orrs	r3, r1
3418ed92:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
3418ed96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ed9a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ed9e:	f002 0302 	and.w	r3, r2, #2
3418eda2:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
3418eda6:	2300      	movs	r3, #0
3418eda8:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
3418edac:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
3418edb0:	4603      	mov	r3, r0
3418edb2:	460a      	mov	r2, r1
3418edb4:	4313      	orrs	r3, r2
3418edb6:	d048      	beq.n	3418ee4a <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
3418edb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418edbc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418edc0:	2b02      	cmp	r3, #2
3418edc2:	d116      	bne.n	3418edf2 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418edc4:	4b6e      	ldr	r3, [pc, #440]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418edc6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418edca:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418edce:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418edd2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418edd6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418edd8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eddc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418edde:	3b01      	subs	r3, #1
3418ede0:	041b      	lsls	r3, r3, #16
3418ede2:	4313      	orrs	r3, r2
3418ede4:	4a66      	ldr	r2, [pc, #408]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ede6:	430b      	orrs	r3, r1
3418ede8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418edec:	f7ff f896 	bl	3418df1c <LL_RCC_IC7_Enable>
3418edf0:	e024      	b.n	3418ee3c <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
3418edf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418edf6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418edfa:	2b03      	cmp	r3, #3
3418edfc:	d116      	bne.n	3418ee2c <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418edfe:	4b60      	ldr	r3, [pc, #384]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ee00:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418ee04:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ee08:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ee0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee10:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418ee12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee16:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418ee18:	3b01      	subs	r3, #1
3418ee1a:	041b      	lsls	r3, r3, #16
3418ee1c:	4313      	orrs	r3, r2
3418ee1e:	4a58      	ldr	r2, [pc, #352]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ee20:	430b      	orrs	r3, r1
3418ee22:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418ee26:	f7ff f8b9 	bl	3418df9c <LL_RCC_IC8_Enable>
3418ee2a:	e007      	b.n	3418ee3c <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
3418ee2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee30:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418ee34:	2b01      	cmp	r3, #1
3418ee36:	d101      	bne.n	3418ee3c <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
3418ee38:	f7ff fbb0 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
3418ee3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee40:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418ee44:	4618      	mov	r0, r3
3418ee46:	f7fe f9b1 	bl	3418d1ac <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3418ee4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee4e:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ee52:	f002 0308 	and.w	r3, r2, #8
3418ee56:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
3418ee5a:	2300      	movs	r3, #0
3418ee5c:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
3418ee60:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
3418ee64:	4603      	mov	r3, r0
3418ee66:	460a      	mov	r2, r1
3418ee68:	4313      	orrs	r3, r2
3418ee6a:	d017      	beq.n	3418ee9c <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3418ee6c:	4b44      	ldr	r3, [pc, #272]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ee6e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418ee72:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ee76:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ee7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee7e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
3418ee82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ee86:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3418ee8a:	3b01      	subs	r3, #1
3418ee8c:	041b      	lsls	r3, r3, #16
3418ee8e:	4313      	orrs	r3, r2
3418ee90:	4a3b      	ldr	r2, [pc, #236]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ee92:	430b      	orrs	r3, r1
3418ee94:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
3418ee98:	f7ff fac0 	bl	3418e41c <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3418ee9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eea0:	e9d3 2300 	ldrd	r2, r3, [r3]
3418eea4:	f002 0310 	and.w	r3, r2, #16
3418eea8:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
3418eeac:	2300      	movs	r3, #0
3418eeae:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
3418eeb2:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
3418eeb6:	4603      	mov	r3, r0
3418eeb8:	460a      	mov	r2, r1
3418eeba:	4313      	orrs	r3, r2
3418eebc:	d02f      	beq.n	3418ef1e <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3418eebe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eec2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418eec6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418eeca:	d118      	bne.n	3418eefe <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3418eecc:	4b2c      	ldr	r3, [pc, #176]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418eece:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418eed2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418eed6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418eeda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eede:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
3418eee2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418eee6:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3418eeea:	3b01      	subs	r3, #1
3418eeec:	041b      	lsls	r3, r3, #16
3418eeee:	4313      	orrs	r3, r2
3418eef0:	4a23      	ldr	r2, [pc, #140]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418eef2:	430b      	orrs	r3, r1
3418eef4:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
3418eef8:	f7ff fa50 	bl	3418e39c <LL_RCC_IC17_Enable>
3418eefc:	e008      	b.n	3418ef10 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3418eefe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef02:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ef06:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418ef0a:	d101      	bne.n	3418ef10 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
3418ef0c:	f7ff fb46 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
3418ef10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef14:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ef18:	4618      	mov	r0, r3
3418ef1a:	f7fe f973 	bl	3418d204 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3418ef1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef22:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ef26:	f002 0320 	and.w	r3, r2, #32
3418ef2a:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
3418ef2e:	2300      	movs	r3, #0
3418ef30:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
3418ef34:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
3418ef38:	4603      	mov	r3, r0
3418ef3a:	460a      	mov	r2, r1
3418ef3c:	4313      	orrs	r3, r2
3418ef3e:	d031      	beq.n	3418efa4 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3418ef40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef44:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418ef48:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3418ef4c:	d11a      	bne.n	3418ef84 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3418ef4e:	4b0c      	ldr	r3, [pc, #48]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ef50:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418ef54:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ef58:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ef5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef60:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
3418ef62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef66:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3418ef68:	3b01      	subs	r3, #1
3418ef6a:	041b      	lsls	r3, r3, #16
3418ef6c:	4313      	orrs	r3, r2
3418ef6e:	4a04      	ldr	r2, [pc, #16]	@ (3418ef80 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3418ef70:	430b      	orrs	r3, r1
3418ef72:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
3418ef76:	f7ff f8d1 	bl	3418e11c <LL_RCC_IC12_Enable>
3418ef7a:	e00c      	b.n	3418ef96 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
3418ef7c:	0301041c 	.word	0x0301041c
3418ef80:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
3418ef84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef88:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418ef8c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3418ef90:	d101      	bne.n	3418ef96 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
3418ef92:	f7ff fb03 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
3418ef96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ef9a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418ef9e:	4618      	mov	r0, r3
3418efa0:	f7fe f946 	bl	3418d230 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
3418efa4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418efa8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418efac:	f002 0340 	and.w	r3, r2, #64	@ 0x40
3418efb0:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
3418efb4:	2300      	movs	r3, #0
3418efb6:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
3418efba:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
3418efbe:	4603      	mov	r3, r0
3418efc0:	460a      	mov	r2, r1
3418efc2:	4313      	orrs	r3, r2
3418efc4:	d006      	beq.n	3418efd4 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
3418efc6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418efca:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418efce:	4618      	mov	r0, r3
3418efd0:	f7fe f944 	bl	3418d25c <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
3418efd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418efd8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418efdc:	f002 0380 	and.w	r3, r2, #128	@ 0x80
3418efe0:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
3418efe4:	2300      	movs	r3, #0
3418efe6:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
3418efea:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
3418efee:	4603      	mov	r3, r0
3418eff0:	460a      	mov	r2, r1
3418eff2:	4313      	orrs	r3, r2
3418eff4:	d006      	beq.n	3418f004 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
3418eff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418effa:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418effe:	4618      	mov	r0, r3
3418f000:	f7fe f950 	bl	3418d2a4 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
3418f004:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f008:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f00c:	f402 7380 	and.w	r3, r2, #256	@ 0x100
3418f010:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
3418f014:	2300      	movs	r3, #0
3418f016:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
3418f01a:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
3418f01e:	4603      	mov	r3, r0
3418f020:	460a      	mov	r2, r1
3418f022:	4313      	orrs	r3, r2
3418f024:	d006      	beq.n	3418f034 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
3418f026:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f02a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418f02e:	4618      	mov	r0, r3
3418f030:	f7fe f94e 	bl	3418d2d0 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
3418f034:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f038:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f03c:	f402 7300 	and.w	r3, r2, #512	@ 0x200
3418f040:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
3418f044:	2300      	movs	r3, #0
3418f046:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
3418f04a:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
3418f04e:	4603      	mov	r3, r0
3418f050:	460a      	mov	r2, r1
3418f052:	4313      	orrs	r3, r2
3418f054:	d038      	beq.n	3418f0c8 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3418f056:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f05a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f05e:	2b02      	cmp	r3, #2
3418f060:	d116      	bne.n	3418f090 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3418f062:	4bbc      	ldr	r3, [pc, #752]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f064:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418f068:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f06c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f070:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f074:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
3418f076:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f07a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3418f07c:	3b01      	subs	r3, #1
3418f07e:	041b      	lsls	r3, r3, #16
3418f080:	4313      	orrs	r3, r2
3418f082:	4ab4      	ldr	r2, [pc, #720]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f084:	430b      	orrs	r3, r1
3418f086:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
3418f08a:	f7ff f887 	bl	3418e19c <LL_RCC_IC13_Enable>
3418f08e:	e007      	b.n	3418f0a0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
3418f090:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f094:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f098:	2b01      	cmp	r3, #1
3418f09a:	d101      	bne.n	3418f0a0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
3418f09c:	f7ff fa7e 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
3418f0a0:	4bac      	ldr	r3, [pc, #688]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f0a2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418f0a6:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
3418f0aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f0ae:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418f0b2:	3b01      	subs	r3, #1
3418f0b4:	011a      	lsls	r2, r3, #4
3418f0b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f0ba:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f0be:	4313      	orrs	r3, r2
3418f0c0:	4aa4      	ldr	r2, [pc, #656]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f0c2:	430b      	orrs	r3, r1
3418f0c4:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
3418f0c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f0cc:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f0d0:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
3418f0d4:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
3418f0d8:	2300      	movs	r3, #0
3418f0da:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3418f0de:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
3418f0e2:	4603      	mov	r3, r0
3418f0e4:	460a      	mov	r2, r1
3418f0e6:	4313      	orrs	r3, r2
3418f0e8:	d02d      	beq.n	3418f146 <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3418f0ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f0ee:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f0f2:	2b02      	cmp	r3, #2
3418f0f4:	d118      	bne.n	3418f128 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3418f0f6:	4b97      	ldr	r3, [pc, #604]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f0f8:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418f0fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f100:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f104:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f108:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3418f10c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f110:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3418f114:	3b01      	subs	r3, #1
3418f116:	041b      	lsls	r3, r3, #16
3418f118:	4313      	orrs	r3, r2
3418f11a:	4a8e      	ldr	r2, [pc, #568]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f11c:	430b      	orrs	r3, r1
3418f11e:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3418f122:	f7ff f9bb 	bl	3418e49c <LL_RCC_IC19_Enable>
3418f126:	e007      	b.n	3418f138 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3418f128:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f12c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f130:	2b01      	cmp	r3, #1
3418f132:	d101      	bne.n	3418f138 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
3418f134:	f7ff fa32 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
3418f138:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f13c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f140:	4618      	mov	r0, r3
3418f142:	f7fe f8db 	bl	3418d2fc <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3418f146:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f14a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f14e:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
3418f152:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
3418f156:	2300      	movs	r3, #0
3418f158:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
3418f15c:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
3418f160:	4603      	mov	r3, r0
3418f162:	460a      	mov	r2, r1
3418f164:	4313      	orrs	r3, r2
3418f166:	d04b      	beq.n	3418f200 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3418f168:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f16c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3418f170:	4b79      	ldr	r3, [pc, #484]	@ (3418f358 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
3418f172:	429a      	cmp	r2, r3
3418f174:	d116      	bne.n	3418f1a4 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f176:	4b77      	ldr	r3, [pc, #476]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f178:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f17c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f180:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f184:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f188:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f18a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f18e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f190:	3b01      	subs	r3, #1
3418f192:	041b      	lsls	r3, r3, #16
3418f194:	4313      	orrs	r3, r2
3418f196:	4a6f      	ldr	r2, [pc, #444]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f198:	430b      	orrs	r3, r1
3418f19a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f19e:	f7fe ff7d 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f1a2:	e026      	b.n	3418f1f2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
3418f1a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f1a8:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3418f1ac:	4b6b      	ldr	r3, [pc, #428]	@ (3418f35c <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
3418f1ae:	429a      	cmp	r2, r3
3418f1b0:	d116      	bne.n	3418f1e0 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f1b2:	4b68      	ldr	r3, [pc, #416]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f1b4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f1b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f1bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f1c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f1c4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f1c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f1ca:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f1cc:	3b01      	subs	r3, #1
3418f1ce:	041b      	lsls	r3, r3, #16
3418f1d0:	4313      	orrs	r3, r2
3418f1d2:	4a60      	ldr	r2, [pc, #384]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f1d4:	430b      	orrs	r3, r1
3418f1d6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f1da:	f7ff f85f 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f1de:	e008      	b.n	3418f1f2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3418f1e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f1e4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3418f1e8:	4b5d      	ldr	r3, [pc, #372]	@ (3418f360 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
3418f1ea:	429a      	cmp	r2, r3
3418f1ec:	d101      	bne.n	3418f1f2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
3418f1ee:	f7ff f9d5 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
3418f1f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f1f6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f1fa:	4618      	mov	r0, r3
3418f1fc:	f7fe f8aa 	bl	3418d354 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3418f200:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f204:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f208:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
3418f20c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
3418f210:	2300      	movs	r3, #0
3418f212:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
3418f216:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
3418f21a:	4603      	mov	r3, r0
3418f21c:	460a      	mov	r2, r1
3418f21e:	4313      	orrs	r3, r2
3418f220:	d04b      	beq.n	3418f2ba <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3418f222:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f226:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3418f22a:	4b4e      	ldr	r3, [pc, #312]	@ (3418f364 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
3418f22c:	429a      	cmp	r2, r3
3418f22e:	d116      	bne.n	3418f25e <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f230:	4b48      	ldr	r3, [pc, #288]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f232:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f236:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f23a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f23e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f242:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f244:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f248:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f24a:	3b01      	subs	r3, #1
3418f24c:	041b      	lsls	r3, r3, #16
3418f24e:	4313      	orrs	r3, r2
3418f250:	4a40      	ldr	r2, [pc, #256]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f252:	430b      	orrs	r3, r1
3418f254:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f258:	f7fe ff20 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f25c:	e026      	b.n	3418f2ac <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3418f25e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f262:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3418f266:	4b40      	ldr	r3, [pc, #256]	@ (3418f368 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
3418f268:	429a      	cmp	r2, r3
3418f26a:	d116      	bne.n	3418f29a <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f26c:	4b39      	ldr	r3, [pc, #228]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f26e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f272:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f276:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f27a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f27e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f280:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f284:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f286:	3b01      	subs	r3, #1
3418f288:	041b      	lsls	r3, r3, #16
3418f28a:	4313      	orrs	r3, r2
3418f28c:	4a31      	ldr	r2, [pc, #196]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f28e:	430b      	orrs	r3, r1
3418f290:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f294:	f7ff f802 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f298:	e008      	b.n	3418f2ac <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3418f29a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f29e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3418f2a2:	4b32      	ldr	r3, [pc, #200]	@ (3418f36c <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
3418f2a4:	429a      	cmp	r2, r3
3418f2a6:	d101      	bne.n	3418f2ac <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
3418f2a8:	f7ff f978 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3418f2ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f2b0:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418f2b4:	4618      	mov	r0, r3
3418f2b6:	f7fe f84d 	bl	3418d354 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3418f2ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f2be:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f2c2:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
3418f2c6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3418f2ca:	2300      	movs	r3, #0
3418f2cc:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
3418f2d0:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
3418f2d4:	4603      	mov	r3, r0
3418f2d6:	460a      	mov	r2, r1
3418f2d8:	4313      	orrs	r3, r2
3418f2da:	d05d      	beq.n	3418f398 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3418f2dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f2e0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3418f2e4:	4b22      	ldr	r3, [pc, #136]	@ (3418f370 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
3418f2e6:	429a      	cmp	r2, r3
3418f2e8:	d116      	bne.n	3418f318 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f2ea:	4b1a      	ldr	r3, [pc, #104]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f2ec:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f2f0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f2f4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f2f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f2fc:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f2fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f302:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f304:	3b01      	subs	r3, #1
3418f306:	041b      	lsls	r3, r3, #16
3418f308:	4313      	orrs	r3, r2
3418f30a:	4a12      	ldr	r2, [pc, #72]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f30c:	430b      	orrs	r3, r1
3418f30e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f312:	f7fe fec3 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f316:	e038      	b.n	3418f38a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
3418f318:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f31c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3418f320:	4b14      	ldr	r3, [pc, #80]	@ (3418f374 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
3418f322:	429a      	cmp	r2, r3
3418f324:	d128      	bne.n	3418f378 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f326:	4b0b      	ldr	r3, [pc, #44]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f328:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f32c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f330:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f334:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f338:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f33a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f33e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f340:	3b01      	subs	r3, #1
3418f342:	041b      	lsls	r3, r3, #16
3418f344:	4313      	orrs	r3, r2
3418f346:	4a03      	ldr	r2, [pc, #12]	@ (3418f354 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3418f348:	430b      	orrs	r3, r1
3418f34a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f34e:	f7fe ffa5 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f352:	e01a      	b.n	3418f38a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
3418f354:	56028000 	.word	0x56028000
3418f358:	0702000c 	.word	0x0702000c
3418f35c:	0703000c 	.word	0x0703000c
3418f360:	0701000c 	.word	0x0701000c
3418f364:	0702040c 	.word	0x0702040c
3418f368:	0703040c 	.word	0x0703040c
3418f36c:	0701040c 	.word	0x0701040c
3418f370:	0702080c 	.word	0x0702080c
3418f374:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
3418f378:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f37c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3418f380:	4bc8      	ldr	r3, [pc, #800]	@ (3418f6a4 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
3418f382:	429a      	cmp	r2, r3
3418f384:	d101      	bne.n	3418f38a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
3418f386:	f7ff f909 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
3418f38a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f38e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418f392:	4618      	mov	r0, r3
3418f394:	f7fd ffde 	bl	3418d354 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
3418f398:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f39c:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f3a0:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
3418f3a4:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
3418f3a8:	2300      	movs	r3, #0
3418f3aa:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
3418f3ae:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
3418f3b2:	4603      	mov	r3, r0
3418f3b4:	460a      	mov	r2, r1
3418f3b6:	4313      	orrs	r3, r2
3418f3b8:	d04b      	beq.n	3418f452 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3418f3ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f3be:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3418f3c2:	4bb9      	ldr	r3, [pc, #740]	@ (3418f6a8 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
3418f3c4:	429a      	cmp	r2, r3
3418f3c6:	d116      	bne.n	3418f3f6 <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f3c8:	4bb8      	ldr	r3, [pc, #736]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f3ca:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f3ce:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f3d2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f3d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f3da:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f3dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f3e0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f3e2:	3b01      	subs	r3, #1
3418f3e4:	041b      	lsls	r3, r3, #16
3418f3e6:	4313      	orrs	r3, r2
3418f3e8:	4ab0      	ldr	r2, [pc, #704]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f3ea:	430b      	orrs	r3, r1
3418f3ec:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f3f0:	f7fe fe54 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f3f4:	e026      	b.n	3418f444 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
3418f3f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f3fa:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3418f3fe:	4bac      	ldr	r3, [pc, #688]	@ (3418f6b0 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
3418f400:	429a      	cmp	r2, r3
3418f402:	d116      	bne.n	3418f432 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f404:	4ba9      	ldr	r3, [pc, #676]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f406:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f40a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f40e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f412:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f416:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f418:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f41c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f41e:	3b01      	subs	r3, #1
3418f420:	041b      	lsls	r3, r3, #16
3418f422:	4313      	orrs	r3, r2
3418f424:	4aa1      	ldr	r2, [pc, #644]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f426:	430b      	orrs	r3, r1
3418f428:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f42c:	f7fe ff36 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f430:	e008      	b.n	3418f444 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3418f432:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f436:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3418f43a:	4b9e      	ldr	r3, [pc, #632]	@ (3418f6b4 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
3418f43c:	429a      	cmp	r2, r3
3418f43e:	d101      	bne.n	3418f444 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
3418f440:	f7ff f8ac 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
3418f444:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f448:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418f44c:	4618      	mov	r0, r3
3418f44e:	f7fd ff81 	bl	3418d354 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3418f452:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f456:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f45a:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3418f45e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
3418f462:	2300      	movs	r3, #0
3418f464:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
3418f468:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
3418f46c:	4603      	mov	r3, r0
3418f46e:	460a      	mov	r2, r1
3418f470:	4313      	orrs	r3, r2
3418f472:	d04b      	beq.n	3418f50c <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
3418f474:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f478:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3418f47c:	4b8e      	ldr	r3, [pc, #568]	@ (3418f6b8 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
3418f47e:	429a      	cmp	r2, r3
3418f480:	d116      	bne.n	3418f4b0 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f482:	4b8a      	ldr	r3, [pc, #552]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f484:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f488:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f48c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f490:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f494:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f496:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f49a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f49c:	3b01      	subs	r3, #1
3418f49e:	041b      	lsls	r3, r3, #16
3418f4a0:	4313      	orrs	r3, r2
3418f4a2:	4a82      	ldr	r2, [pc, #520]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f4a4:	430b      	orrs	r3, r1
3418f4a6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f4aa:	f7fe fdf7 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f4ae:	e026      	b.n	3418f4fe <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
3418f4b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f4b4:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3418f4b8:	4b80      	ldr	r3, [pc, #512]	@ (3418f6bc <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
3418f4ba:	429a      	cmp	r2, r3
3418f4bc:	d116      	bne.n	3418f4ec <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f4be:	4b7b      	ldr	r3, [pc, #492]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f4c0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f4c4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f4c8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f4cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f4d0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f4d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f4d6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f4d8:	3b01      	subs	r3, #1
3418f4da:	041b      	lsls	r3, r3, #16
3418f4dc:	4313      	orrs	r3, r2
3418f4de:	4a73      	ldr	r2, [pc, #460]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f4e0:	430b      	orrs	r3, r1
3418f4e2:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f4e6:	f7fe fed9 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f4ea:	e008      	b.n	3418f4fe <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3418f4ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f4f0:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3418f4f4:	4b72      	ldr	r3, [pc, #456]	@ (3418f6c0 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
3418f4f6:	429a      	cmp	r2, r3
3418f4f8:	d101      	bne.n	3418f4fe <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
3418f4fa:	f7ff f84f 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
3418f4fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f502:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418f506:	4618      	mov	r0, r3
3418f508:	f7fd ff2f 	bl	3418d36a <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3418f50c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f510:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f514:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
3418f518:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
3418f51c:	2300      	movs	r3, #0
3418f51e:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3418f522:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
3418f526:	4603      	mov	r3, r0
3418f528:	460a      	mov	r2, r1
3418f52a:	4313      	orrs	r3, r2
3418f52c:	d04b      	beq.n	3418f5c6 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3418f52e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f532:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3418f536:	4b63      	ldr	r3, [pc, #396]	@ (3418f6c4 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
3418f538:	429a      	cmp	r2, r3
3418f53a:	d116      	bne.n	3418f56a <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418f53c:	4b5b      	ldr	r3, [pc, #364]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f53e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f542:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f546:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f54a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f54e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418f550:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f554:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418f556:	3b01      	subs	r3, #1
3418f558:	041b      	lsls	r3, r3, #16
3418f55a:	4313      	orrs	r3, r2
3418f55c:	4a53      	ldr	r2, [pc, #332]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f55e:	430b      	orrs	r3, r1
3418f560:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418f564:	f7fe fd9a 	bl	3418e09c <LL_RCC_IC10_Enable>
3418f568:	e026      	b.n	3418f5b8 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3418f56a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f56e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3418f572:	4b55      	ldr	r3, [pc, #340]	@ (3418f6c8 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
3418f574:	429a      	cmp	r2, r3
3418f576:	d116      	bne.n	3418f5a6 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f578:	4b4c      	ldr	r3, [pc, #304]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f57a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f57e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f582:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f586:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f58a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f58c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f590:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f592:	3b01      	subs	r3, #1
3418f594:	041b      	lsls	r3, r3, #16
3418f596:	4313      	orrs	r3, r2
3418f598:	4a44      	ldr	r2, [pc, #272]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f59a:	430b      	orrs	r3, r1
3418f59c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f5a0:	f7fe fe7c 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f5a4:	e008      	b.n	3418f5b8 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
3418f5a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f5aa:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3418f5ae:	4b47      	ldr	r3, [pc, #284]	@ (3418f6cc <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
3418f5b0:	429a      	cmp	r2, r3
3418f5b2:	d101      	bne.n	3418f5b8 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
3418f5b4:	f7fe fff2 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
3418f5b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f5bc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f5c0:	4618      	mov	r0, r3
3418f5c2:	f7fd fed2 	bl	3418d36a <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
3418f5c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f5ca:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f5ce:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
3418f5d2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
3418f5d6:	2300      	movs	r3, #0
3418f5d8:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3418f5dc:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
3418f5e0:	4603      	mov	r3, r0
3418f5e2:	460a      	mov	r2, r1
3418f5e4:	4313      	orrs	r3, r2
3418f5e6:	d02d      	beq.n	3418f644 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
3418f5e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f5ec:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3418f5f0:	4b37      	ldr	r3, [pc, #220]	@ (3418f6d0 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
3418f5f2:	429a      	cmp	r2, r3
3418f5f4:	d116      	bne.n	3418f624 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f5f6:	4b2d      	ldr	r3, [pc, #180]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f5f8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f5fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f600:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f604:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f608:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f60a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f60e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f610:	3b01      	subs	r3, #1
3418f612:	041b      	lsls	r3, r3, #16
3418f614:	4313      	orrs	r3, r2
3418f616:	4a25      	ldr	r2, [pc, #148]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f618:	430b      	orrs	r3, r1
3418f61a:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f61e:	f7fe fe3d 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f622:	e008      	b.n	3418f636 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
3418f624:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f628:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3418f62c:	4b29      	ldr	r3, [pc, #164]	@ (3418f6d4 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
3418f62e:	429a      	cmp	r2, r3
3418f630:	d101      	bne.n	3418f636 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
3418f632:	f7fe ffb3 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
3418f636:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f63a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418f63e:	4618      	mov	r0, r3
3418f640:	f7fd fe9e 	bl	3418d380 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
3418f644:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f648:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f64c:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
3418f650:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
3418f654:	2300      	movs	r3, #0
3418f656:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3418f65a:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
3418f65e:	4603      	mov	r3, r0
3418f660:	460a      	mov	r2, r1
3418f662:	4313      	orrs	r3, r2
3418f664:	d04a      	beq.n	3418f6fc <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
3418f666:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f66a:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3418f66e:	4b1a      	ldr	r3, [pc, #104]	@ (3418f6d8 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
3418f670:	429a      	cmp	r2, r3
3418f672:	d133      	bne.n	3418f6dc <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f674:	4b0d      	ldr	r3, [pc, #52]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f676:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f67a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f67e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f682:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f686:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f688:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f68c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f68e:	3b01      	subs	r3, #1
3418f690:	041b      	lsls	r3, r3, #16
3418f692:	4313      	orrs	r3, r2
3418f694:	4a05      	ldr	r2, [pc, #20]	@ (3418f6ac <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3418f696:	430b      	orrs	r3, r1
3418f698:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f69c:	f7fe fdfe 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f6a0:	e025      	b.n	3418f6ee <HAL_RCCEx_PeriphCLKConfig+0x110e>
3418f6a2:	bf00      	nop
3418f6a4:	0701080c 	.word	0x0701080c
3418f6a8:	07020c0c 	.word	0x07020c0c
3418f6ac:	56028000 	.word	0x56028000
3418f6b0:	07030c0c 	.word	0x07030c0c
3418f6b4:	07010c0c 	.word	0x07010c0c
3418f6b8:	0702100c 	.word	0x0702100c
3418f6bc:	0703100c 	.word	0x0703100c
3418f6c0:	0701100c 	.word	0x0701100c
3418f6c4:	0702140c 	.word	0x0702140c
3418f6c8:	0703140c 	.word	0x0703140c
3418f6cc:	0701140c 	.word	0x0701140c
3418f6d0:	0702082c 	.word	0x0702082c
3418f6d4:	0701082c 	.word	0x0701082c
3418f6d8:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3418f6dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f6e0:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3418f6e4:	4bca      	ldr	r3, [pc, #808]	@ (3418fa10 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
3418f6e6:	429a      	cmp	r2, r3
3418f6e8:	d101      	bne.n	3418f6ee <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
3418f6ea:	f7fe ff57 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
3418f6ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f6f2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418f6f6:	4618      	mov	r0, r3
3418f6f8:	f7fd fe42 	bl	3418d380 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
3418f6fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f700:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f704:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
3418f708:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
3418f70c:	2300      	movs	r3, #0
3418f70e:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
3418f712:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
3418f716:	4603      	mov	r3, r0
3418f718:	460a      	mov	r2, r1
3418f71a:	4313      	orrs	r3, r2
3418f71c:	d02d      	beq.n	3418f77a <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3418f71e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f722:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3418f726:	4bbb      	ldr	r3, [pc, #748]	@ (3418fa14 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
3418f728:	429a      	cmp	r2, r3
3418f72a:	d116      	bne.n	3418f75a <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f72c:	4bba      	ldr	r3, [pc, #744]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f72e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f732:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f736:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f73a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f73e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f740:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f744:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f746:	3b01      	subs	r3, #1
3418f748:	041b      	lsls	r3, r3, #16
3418f74a:	4313      	orrs	r3, r2
3418f74c:	4ab2      	ldr	r2, [pc, #712]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f74e:	430b      	orrs	r3, r1
3418f750:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f754:	f7fe fda2 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f758:	e008      	b.n	3418f76c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3418f75a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f75e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3418f762:	4bae      	ldr	r3, [pc, #696]	@ (3418fa1c <HAL_RCCEx_PeriphCLKConfig+0x143c>)
3418f764:	429a      	cmp	r2, r3
3418f766:	d101      	bne.n	3418f76c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
3418f768:	f7fe ff18 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
3418f76c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f770:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418f774:	4618      	mov	r0, r3
3418f776:	f7fd fe03 	bl	3418d380 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3418f77a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f77e:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f782:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
3418f786:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3418f78a:	2300      	movs	r3, #0
3418f78c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
3418f790:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
3418f794:	4603      	mov	r3, r0
3418f796:	460a      	mov	r2, r1
3418f798:	4313      	orrs	r3, r2
3418f79a:	d02d      	beq.n	3418f7f8 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3418f79c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7a0:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3418f7a4:	4b9e      	ldr	r3, [pc, #632]	@ (3418fa20 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
3418f7a6:	429a      	cmp	r2, r3
3418f7a8:	d116      	bne.n	3418f7d8 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f7aa:	4b9b      	ldr	r3, [pc, #620]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f7ac:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f7b0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f7b4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f7b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7bc:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f7be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7c2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f7c4:	3b01      	subs	r3, #1
3418f7c6:	041b      	lsls	r3, r3, #16
3418f7c8:	4313      	orrs	r3, r2
3418f7ca:	4a93      	ldr	r2, [pc, #588]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f7cc:	430b      	orrs	r3, r1
3418f7ce:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f7d2:	f7fe fd63 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f7d6:	e008      	b.n	3418f7ea <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
3418f7d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7dc:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3418f7e0:	4b90      	ldr	r3, [pc, #576]	@ (3418fa24 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
3418f7e2:	429a      	cmp	r2, r3
3418f7e4:	d101      	bne.n	3418f7ea <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
3418f7e6:	f7fe fed9 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
3418f7ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7ee:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418f7f2:	4618      	mov	r0, r3
3418f7f4:	f7fd fdc4 	bl	3418d380 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3418f7f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f7fc:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f800:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
3418f804:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3418f808:	2300      	movs	r3, #0
3418f80a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3418f80e:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3418f812:	4603      	mov	r3, r0
3418f814:	460a      	mov	r2, r1
3418f816:	4313      	orrs	r3, r2
3418f818:	d02d      	beq.n	3418f876 <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3418f81a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f81e:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3418f822:	4b81      	ldr	r3, [pc, #516]	@ (3418fa28 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
3418f824:	429a      	cmp	r2, r3
3418f826:	d116      	bne.n	3418f856 <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418f828:	4b7b      	ldr	r3, [pc, #492]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f82a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f82e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f832:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f836:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f83a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418f83c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f840:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418f842:	3b01      	subs	r3, #1
3418f844:	041b      	lsls	r3, r3, #16
3418f846:	4313      	orrs	r3, r2
3418f848:	4a73      	ldr	r2, [pc, #460]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f84a:	430b      	orrs	r3, r1
3418f84c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418f850:	f7fe fd24 	bl	3418e29c <LL_RCC_IC15_Enable>
3418f854:	e008      	b.n	3418f868 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3418f856:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f85a:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3418f85e:	4b73      	ldr	r3, [pc, #460]	@ (3418fa2c <HAL_RCCEx_PeriphCLKConfig+0x144c>)
3418f860:	429a      	cmp	r2, r3
3418f862:	d101      	bne.n	3418f868 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
3418f864:	f7fe fe9a 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
3418f868:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f86c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418f870:	4618      	mov	r0, r3
3418f872:	f7fd fd85 	bl	3418d380 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3418f876:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f87a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f87e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
3418f882:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
3418f886:	2300      	movs	r3, #0
3418f888:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3418f88c:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
3418f890:	4603      	mov	r3, r0
3418f892:	460a      	mov	r2, r1
3418f894:	4313      	orrs	r3, r2
3418f896:	d04b      	beq.n	3418f930 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
3418f898:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f89c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418f8a0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418f8a4:	d116      	bne.n	3418f8d4 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418f8a6:	4b5c      	ldr	r3, [pc, #368]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f8a8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f8ac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f8b0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f8b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f8b8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418f8ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f8be:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418f8c0:	3b01      	subs	r3, #1
3418f8c2:	041b      	lsls	r3, r3, #16
3418f8c4:	4313      	orrs	r3, r2
3418f8c6:	4a54      	ldr	r2, [pc, #336]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f8c8:	430b      	orrs	r3, r1
3418f8ca:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418f8ce:	f7fe fba5 	bl	3418e01c <LL_RCC_IC9_Enable>
3418f8d2:	e026      	b.n	3418f922 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
3418f8d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f8d8:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418f8dc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3418f8e0:	d116      	bne.n	3418f910 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418f8e2:	4b4d      	ldr	r3, [pc, #308]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f8e4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418f8e8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f8ec:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f8f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f8f4:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418f8f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f8fa:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3418f8fc:	3b01      	subs	r3, #1
3418f8fe:	041b      	lsls	r3, r3, #16
3418f900:	4313      	orrs	r3, r2
3418f902:	4a45      	ldr	r2, [pc, #276]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f904:	430b      	orrs	r3, r1
3418f906:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3418f90a:	f7fe fc87 	bl	3418e21c <LL_RCC_IC14_Enable>
3418f90e:	e008      	b.n	3418f922 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
3418f910:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f914:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418f918:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418f91c:	d101      	bne.n	3418f922 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
3418f91e:	f7fe fe3d 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
3418f922:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f926:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3418f92a:	4618      	mov	r0, r3
3418f92c:	f7fd fd34 	bl	3418d398 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
3418f930:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f934:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f938:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
3418f93c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
3418f940:	2300      	movs	r3, #0
3418f942:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3418f946:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3418f94a:	4603      	mov	r3, r0
3418f94c:	460a      	mov	r2, r1
3418f94e:	4313      	orrs	r3, r2
3418f950:	d02f      	beq.n	3418f9b2 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
3418f952:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f956:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3418f95a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418f95e:	d118      	bne.n	3418f992 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
3418f960:	4b2d      	ldr	r3, [pc, #180]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f962:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418f966:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f96a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f96e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f972:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3418f976:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f97a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418f97e:	3b01      	subs	r3, #1
3418f980:	041b      	lsls	r3, r3, #16
3418f982:	4313      	orrs	r3, r2
3418f984:	4a24      	ldr	r2, [pc, #144]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f986:	430b      	orrs	r3, r1
3418f988:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
3418f98c:	f7fe fcc6 	bl	3418e31c <LL_RCC_IC16_Enable>
3418f990:	e008      	b.n	3418f9a4 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
3418f992:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f996:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3418f99a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3418f99e:	d101      	bne.n	3418f9a4 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
3418f9a0:	f7fe fdfc 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
3418f9a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9a8:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3418f9ac:	4618      	mov	r0, r3
3418f9ae:	f7fd fd09 	bl	3418d3c4 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
3418f9b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9b6:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f9ba:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
3418f9be:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3418f9c2:	2300      	movs	r3, #0
3418f9c4:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
3418f9c8:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
3418f9cc:	4603      	mov	r3, r0
3418f9ce:	460a      	mov	r2, r1
3418f9d0:	4313      	orrs	r3, r2
3418f9d2:	d05b      	beq.n	3418fa8c <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
3418f9d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9d8:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3418f9dc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418f9e0:	d126      	bne.n	3418fa30 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418f9e2:	4b0d      	ldr	r3, [pc, #52]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418f9e4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f9e8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418f9ec:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418f9f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9f4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418f9f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418f9fc:	3b01      	subs	r3, #1
3418f9fe:	041b      	lsls	r3, r3, #16
3418fa00:	4313      	orrs	r3, r2
3418fa02:	4a05      	ldr	r2, [pc, #20]	@ (3418fa18 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3418fa04:	430b      	orrs	r3, r1
3418fa06:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418fa0a:	f7fe fa87 	bl	3418df1c <LL_RCC_IC7_Enable>
3418fa0e:	e036      	b.n	3418fa7e <HAL_RCCEx_PeriphCLKConfig+0x149e>
3418fa10:	07010c2c 	.word	0x07010c2c
3418fa14:	0702102c 	.word	0x0702102c
3418fa18:	56028000 	.word	0x56028000
3418fa1c:	0701102c 	.word	0x0701102c
3418fa20:	0702142c 	.word	0x0702142c
3418fa24:	0701142c 	.word	0x0701142c
3418fa28:	0702182c 	.word	0x0702182c
3418fa2c:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
3418fa30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa34:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3418fa38:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418fa3c:	d116      	bne.n	3418fa6c <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fa3e:	4bb5      	ldr	r3, [pc, #724]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fa40:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fa44:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fa48:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fa4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa50:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fa52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa56:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fa58:	3b01      	subs	r3, #1
3418fa5a:	041b      	lsls	r3, r3, #16
3418fa5c:	4313      	orrs	r3, r2
3418fa5e:	4aad      	ldr	r2, [pc, #692]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fa60:	430b      	orrs	r3, r1
3418fa62:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fa66:	f7fe fa99 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fa6a:	e008      	b.n	3418fa7e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3418fa6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa70:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3418fa74:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418fa78:	d101      	bne.n	3418fa7e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
3418fa7a:	f7fe fd8f 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
3418fa7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa82:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3418fa86:	4618      	mov	r0, r3
3418fa88:	f7fd fcb2 	bl	3418d3f0 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3418fa8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa90:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fa94:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
3418fa98:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3418fa9c:	2300      	movs	r3, #0
3418fa9e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3418faa2:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
3418faa6:	4603      	mov	r3, r0
3418faa8:	460a      	mov	r2, r1
3418faaa:	4313      	orrs	r3, r2
3418faac:	d02d      	beq.n	3418fb0a <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3418faae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fab2:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418fab6:	2b20      	cmp	r3, #32
3418fab8:	d118      	bne.n	3418faec <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418faba:	4b96      	ldr	r3, [pc, #600]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fabc:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418fac0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fac4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fac8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418facc:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3418fad0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fad4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418fad8:	3b01      	subs	r3, #1
3418fada:	041b      	lsls	r3, r3, #16
3418fadc:	4313      	orrs	r3, r2
3418fade:	4a8d      	ldr	r2, [pc, #564]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fae0:	430b      	orrs	r3, r1
3418fae2:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418fae6:	f7fe fd19 	bl	3418e51c <LL_RCC_IC20_Enable>
3418faea:	e007      	b.n	3418fafc <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3418faec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418faf0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418faf4:	2b10      	cmp	r3, #16
3418faf6:	d101      	bne.n	3418fafc <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
3418faf8:	f7fe fd50 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
3418fafc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb00:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3418fb04:	4618      	mov	r0, r3
3418fb06:	f7fd fc9f 	bl	3418d448 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3418fb0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb0e:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fb12:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3418fb16:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3418fb1a:	2300      	movs	r3, #0
3418fb1c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3418fb20:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
3418fb24:	4603      	mov	r3, r0
3418fb26:	460a      	mov	r2, r1
3418fb28:	4313      	orrs	r3, r2
3418fb2a:	d04b      	beq.n	3418fbc4 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
3418fb2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb30:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3418fb34:	4b78      	ldr	r3, [pc, #480]	@ (3418fd18 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
3418fb36:	429a      	cmp	r2, r3
3418fb38:	d116      	bne.n	3418fb68 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418fb3a:	4b76      	ldr	r3, [pc, #472]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fb3c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418fb40:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fb44:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fb48:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb4c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418fb4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb52:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418fb54:	3b01      	subs	r3, #1
3418fb56:	041b      	lsls	r3, r3, #16
3418fb58:	4313      	orrs	r3, r2
3418fb5a:	4a6e      	ldr	r2, [pc, #440]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fb5c:	430b      	orrs	r3, r1
3418fb5e:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418fb62:	f7fe f9db 	bl	3418df1c <LL_RCC_IC7_Enable>
3418fb66:	e026      	b.n	3418fbb6 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3418fb68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb6c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3418fb70:	4b6a      	ldr	r3, [pc, #424]	@ (3418fd1c <HAL_RCCEx_PeriphCLKConfig+0x173c>)
3418fb72:	429a      	cmp	r2, r3
3418fb74:	d116      	bne.n	3418fba4 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fb76:	4b67      	ldr	r3, [pc, #412]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fb78:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fb7c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fb80:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fb84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb88:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fb8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb8e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fb90:	3b01      	subs	r3, #1
3418fb92:	041b      	lsls	r3, r3, #16
3418fb94:	4313      	orrs	r3, r2
3418fb96:	4a5f      	ldr	r2, [pc, #380]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fb98:	430b      	orrs	r3, r1
3418fb9a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fb9e:	f7fe f9fd 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fba2:	e008      	b.n	3418fbb6 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
3418fba4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fba8:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
3418fbac:	4b5c      	ldr	r3, [pc, #368]	@ (3418fd20 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
3418fbae:	429a      	cmp	r2, r3
3418fbb0:	d101      	bne.n	3418fbb6 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
3418fbb2:	f7fe fcf3 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
3418fbb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbba:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
3418fbbe:	4618      	mov	r0, r3
3418fbc0:	f7fd fc58 	bl	3418d474 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
3418fbc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbc8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fbcc:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
3418fbd0:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
3418fbd4:	2300      	movs	r3, #0
3418fbd6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3418fbda:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
3418fbde:	4603      	mov	r3, r0
3418fbe0:	460a      	mov	r2, r1
3418fbe2:	4313      	orrs	r3, r2
3418fbe4:	d04b      	beq.n	3418fc7e <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3418fbe6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbea:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3418fbee:	4b4d      	ldr	r3, [pc, #308]	@ (3418fd24 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
3418fbf0:	429a      	cmp	r2, r3
3418fbf2:	d116      	bne.n	3418fc22 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418fbf4:	4b47      	ldr	r3, [pc, #284]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fbf6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418fbfa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fbfe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fc02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc06:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418fc08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc0c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418fc0e:	3b01      	subs	r3, #1
3418fc10:	041b      	lsls	r3, r3, #16
3418fc12:	4313      	orrs	r3, r2
3418fc14:	4a3f      	ldr	r2, [pc, #252]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fc16:	430b      	orrs	r3, r1
3418fc18:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418fc1c:	f7fe f97e 	bl	3418df1c <LL_RCC_IC7_Enable>
3418fc20:	e026      	b.n	3418fc70 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
3418fc22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc26:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3418fc2a:	4b3f      	ldr	r3, [pc, #252]	@ (3418fd28 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
3418fc2c:	429a      	cmp	r2, r3
3418fc2e:	d116      	bne.n	3418fc5e <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fc30:	4b38      	ldr	r3, [pc, #224]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fc32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fc36:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fc3a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fc3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc42:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fc44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc48:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fc4a:	3b01      	subs	r3, #1
3418fc4c:	041b      	lsls	r3, r3, #16
3418fc4e:	4313      	orrs	r3, r2
3418fc50:	4a30      	ldr	r2, [pc, #192]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fc52:	430b      	orrs	r3, r1
3418fc54:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fc58:	f7fe f9a0 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fc5c:	e008      	b.n	3418fc70 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
3418fc5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc62:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3418fc66:	4b31      	ldr	r3, [pc, #196]	@ (3418fd2c <HAL_RCCEx_PeriphCLKConfig+0x174c>)
3418fc68:	429a      	cmp	r2, r3
3418fc6a:	d101      	bne.n	3418fc70 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
3418fc6c:	f7fe fc96 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
3418fc70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc74:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
3418fc78:	4618      	mov	r0, r3
3418fc7a:	f7fd fbfb 	bl	3418d474 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3418fc7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc82:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fc86:	2100      	movs	r1, #0
3418fc88:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
3418fc8c:	f003 0301 	and.w	r3, r3, #1
3418fc90:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
3418fc94:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
3418fc98:	4603      	mov	r3, r0
3418fc9a:	460a      	mov	r2, r1
3418fc9c:	4313      	orrs	r3, r2
3418fc9e:	d056      	beq.n	3418fd4e <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
3418fca0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fca4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418fca8:	2b02      	cmp	r3, #2
3418fcaa:	d116      	bne.n	3418fcda <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3418fcac:	4b19      	ldr	r3, [pc, #100]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fcae:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418fcb2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fcb6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fcba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcbe:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418fcc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcc4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418fcc6:	3b01      	subs	r3, #1
3418fcc8:	041b      	lsls	r3, r3, #16
3418fcca:	4313      	orrs	r3, r2
3418fccc:	4a11      	ldr	r2, [pc, #68]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fcce:	430b      	orrs	r3, r1
3418fcd0:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3418fcd4:	f7fe f922 	bl	3418df1c <LL_RCC_IC7_Enable>
3418fcd8:	e032      	b.n	3418fd40 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3418fcda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcde:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418fce2:	2b03      	cmp	r3, #3
3418fce4:	d124      	bne.n	3418fd30 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fce6:	4b0b      	ldr	r3, [pc, #44]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fce8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fcec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fcf0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fcf4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcf8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fcfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcfe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fd00:	3b01      	subs	r3, #1
3418fd02:	041b      	lsls	r3, r3, #16
3418fd04:	4313      	orrs	r3, r2
3418fd06:	4a03      	ldr	r2, [pc, #12]	@ (3418fd14 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3418fd08:	430b      	orrs	r3, r1
3418fd0a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fd0e:	f7fe f945 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fd12:	e015      	b.n	3418fd40 <HAL_RCCEx_PeriphCLKConfig+0x1760>
3418fd14:	56028000 	.word	0x56028000
3418fd18:	07021418 	.word	0x07021418
3418fd1c:	07031418 	.word	0x07031418
3418fd20:	07011418 	.word	0x07011418
3418fd24:	07021818 	.word	0x07021818
3418fd28:	07031818 	.word	0x07031818
3418fd2c:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
3418fd30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd34:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418fd38:	2b01      	cmp	r3, #1
3418fd3a:	d101      	bne.n	3418fd40 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
3418fd3c:	f7fe fc2e 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
3418fd40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd44:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418fd48:	4618      	mov	r0, r3
3418fd4a:	f7fd fba9 	bl	3418d4a0 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
3418fd4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd52:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fd56:	2100      	movs	r1, #0
3418fd58:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
3418fd5c:	f003 0302 	and.w	r3, r3, #2
3418fd60:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
3418fd64:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
3418fd68:	4603      	mov	r3, r0
3418fd6a:	460a      	mov	r2, r1
3418fd6c:	4313      	orrs	r3, r2
3418fd6e:	d04b      	beq.n	3418fe08 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
3418fd70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd74:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3418fd78:	4bc6      	ldr	r3, [pc, #792]	@ (34190094 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
3418fd7a:	429a      	cmp	r2, r3
3418fd7c:	d116      	bne.n	3418fdac <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fd7e:	4bc6      	ldr	r3, [pc, #792]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fd80:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fd84:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fd88:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fd8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd90:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fd92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd96:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fd98:	3b01      	subs	r3, #1
3418fd9a:	041b      	lsls	r3, r3, #16
3418fd9c:	4313      	orrs	r3, r2
3418fd9e:	4abe      	ldr	r2, [pc, #760]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fda0:	430b      	orrs	r3, r1
3418fda2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fda6:	f7fe f8f9 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fdaa:	e026      	b.n	3418fdfa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3418fdac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdb0:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3418fdb4:	4bb9      	ldr	r3, [pc, #740]	@ (3419009c <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
3418fdb6:	429a      	cmp	r2, r3
3418fdb8:	d116      	bne.n	3418fde8 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418fdba:	4bb7      	ldr	r3, [pc, #732]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fdbc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418fdc0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fdc4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fdc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdcc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418fdce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdd2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418fdd4:	3b01      	subs	r3, #1
3418fdd6:	041b      	lsls	r3, r3, #16
3418fdd8:	4313      	orrs	r3, r2
3418fdda:	4aaf      	ldr	r2, [pc, #700]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fddc:	430b      	orrs	r3, r1
3418fdde:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418fde2:	f7fe f91b 	bl	3418e01c <LL_RCC_IC9_Enable>
3418fde6:	e008      	b.n	3418fdfa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3418fde8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdec:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3418fdf0:	4bab      	ldr	r3, [pc, #684]	@ (341900a0 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
3418fdf2:	429a      	cmp	r2, r3
3418fdf4:	d101      	bne.n	3418fdfa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
3418fdf6:	f7fe fbd1 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3418fdfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdfe:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
3418fe02:	4618      	mov	r0, r3
3418fe04:	f7fd fb62 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3418fe08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe0c:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fe10:	2100      	movs	r1, #0
3418fe12:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
3418fe16:	f003 0304 	and.w	r3, r3, #4
3418fe1a:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
3418fe1e:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
3418fe22:	4603      	mov	r3, r0
3418fe24:	460a      	mov	r2, r1
3418fe26:	4313      	orrs	r3, r2
3418fe28:	d04b      	beq.n	3418fec2 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3418fe2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe2e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3418fe32:	4b9c      	ldr	r3, [pc, #624]	@ (341900a4 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
3418fe34:	429a      	cmp	r2, r3
3418fe36:	d116      	bne.n	3418fe66 <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fe38:	4b97      	ldr	r3, [pc, #604]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fe3a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fe3e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fe42:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fe46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe4a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418fe4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe50:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418fe52:	3b01      	subs	r3, #1
3418fe54:	041b      	lsls	r3, r3, #16
3418fe56:	4313      	orrs	r3, r2
3418fe58:	4a8f      	ldr	r2, [pc, #572]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fe5a:	430b      	orrs	r3, r1
3418fe5c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418fe60:	f7fe f89c 	bl	3418df9c <LL_RCC_IC8_Enable>
3418fe64:	e026      	b.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3418fe66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe6a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3418fe6e:	4b8e      	ldr	r3, [pc, #568]	@ (341900a8 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
3418fe70:	429a      	cmp	r2, r3
3418fe72:	d116      	bne.n	3418fea2 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418fe74:	4b88      	ldr	r3, [pc, #544]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fe76:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418fe7a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fe7e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fe82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe86:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418fe88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe8c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418fe8e:	3b01      	subs	r3, #1
3418fe90:	041b      	lsls	r3, r3, #16
3418fe92:	4313      	orrs	r3, r2
3418fe94:	4a80      	ldr	r2, [pc, #512]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fe96:	430b      	orrs	r3, r1
3418fe98:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418fe9c:	f7fe f8be 	bl	3418e01c <LL_RCC_IC9_Enable>
3418fea0:	e008      	b.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
3418fea2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fea6:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3418feaa:	4b80      	ldr	r3, [pc, #512]	@ (341900ac <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
3418feac:	429a      	cmp	r2, r3
3418feae:	d101      	bne.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
3418feb0:	f7fe fb74 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
3418feb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418feb8:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3418febc:	4618      	mov	r0, r3
3418febe:	f7fd fb05 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
3418fec2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fec6:	e9d3 2300 	ldrd	r2, r3, [r3]
3418feca:	2100      	movs	r1, #0
3418fecc:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
3418fed0:	f003 0308 	and.w	r3, r3, #8
3418fed4:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
3418fed8:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
3418fedc:	4603      	mov	r3, r0
3418fede:	460a      	mov	r2, r1
3418fee0:	4313      	orrs	r3, r2
3418fee2:	d04b      	beq.n	3418ff7c <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3418fee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fee8:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3418feec:	4b70      	ldr	r3, [pc, #448]	@ (341900b0 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
3418feee:	429a      	cmp	r2, r3
3418fef0:	d116      	bne.n	3418ff20 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3418fef2:	4b69      	ldr	r3, [pc, #420]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418fef4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418fef8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fefc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ff00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff04:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3418ff06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff0a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418ff0c:	3b01      	subs	r3, #1
3418ff0e:	041b      	lsls	r3, r3, #16
3418ff10:	4313      	orrs	r3, r2
3418ff12:	4a61      	ldr	r2, [pc, #388]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ff14:	430b      	orrs	r3, r1
3418ff16:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3418ff1a:	f7fe f83f 	bl	3418df9c <LL_RCC_IC8_Enable>
3418ff1e:	e026      	b.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3418ff20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff24:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3418ff28:	4b62      	ldr	r3, [pc, #392]	@ (341900b4 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
3418ff2a:	429a      	cmp	r2, r3
3418ff2c:	d116      	bne.n	3418ff5c <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418ff2e:	4b5a      	ldr	r3, [pc, #360]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ff30:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418ff34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ff38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ff3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff40:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418ff42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff46:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418ff48:	3b01      	subs	r3, #1
3418ff4a:	041b      	lsls	r3, r3, #16
3418ff4c:	4313      	orrs	r3, r2
3418ff4e:	4a52      	ldr	r2, [pc, #328]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ff50:	430b      	orrs	r3, r1
3418ff52:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418ff56:	f7fe f861 	bl	3418e01c <LL_RCC_IC9_Enable>
3418ff5a:	e008      	b.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3418ff5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff60:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3418ff64:	4b54      	ldr	r3, [pc, #336]	@ (341900b8 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
3418ff66:	429a      	cmp	r2, r3
3418ff68:	d101      	bne.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
3418ff6a:	f7fe fb17 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
3418ff6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff72:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3418ff76:	4618      	mov	r0, r3
3418ff78:	f7fd faa8 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3418ff7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff80:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ff84:	2100      	movs	r1, #0
3418ff86:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3418ff8a:	f003 0310 	and.w	r3, r3, #16
3418ff8e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
3418ff92:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
3418ff96:	4603      	mov	r3, r0
3418ff98:	460a      	mov	r2, r1
3418ff9a:	4313      	orrs	r3, r2
3418ff9c:	d04b      	beq.n	34190036 <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3418ff9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffa2:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3418ffa6:	4b45      	ldr	r3, [pc, #276]	@ (341900bc <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
3418ffa8:	429a      	cmp	r2, r3
3418ffaa:	d116      	bne.n	3418ffda <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3418ffac:	4b3a      	ldr	r3, [pc, #232]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ffae:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418ffb2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ffb6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ffba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffbe:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3418ffc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffc4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418ffc6:	3b01      	subs	r3, #1
3418ffc8:	041b      	lsls	r3, r3, #16
3418ffca:	4313      	orrs	r3, r2
3418ffcc:	4a32      	ldr	r2, [pc, #200]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ffce:	430b      	orrs	r3, r1
3418ffd0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3418ffd4:	f7fe f822 	bl	3418e01c <LL_RCC_IC9_Enable>
3418ffd8:	e026      	b.n	34190028 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3418ffda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffde:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3418ffe2:	4b37      	ldr	r3, [pc, #220]	@ (341900c0 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
3418ffe4:	429a      	cmp	r2, r3
3418ffe6:	d116      	bne.n	34190016 <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3418ffe8:	4b2b      	ldr	r3, [pc, #172]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3418ffea:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418ffee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fff2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fffa:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418fffc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190000:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190002:	3b01      	subs	r3, #1
34190004:	041b      	lsls	r3, r3, #16
34190006:	4313      	orrs	r3, r2
34190008:	4a23      	ldr	r2, [pc, #140]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419000a:	430b      	orrs	r3, r1
3419000c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190010:	f7fe f904 	bl	3418e21c <LL_RCC_IC14_Enable>
34190014:	e008      	b.n	34190028 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34190016:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419001a:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3419001e:	4b29      	ldr	r3, [pc, #164]	@ (341900c4 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
34190020:	429a      	cmp	r2, r3
34190022:	d101      	bne.n	34190028 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
34190024:	f7fe faba 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
34190028:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419002c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
34190030:	4618      	mov	r0, r3
34190032:	f7fd fa4b 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34190036:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419003a:	e9d3 2300 	ldrd	r2, r3, [r3]
3419003e:	2100      	movs	r1, #0
34190040:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
34190044:	f003 0320 	and.w	r3, r3, #32
34190048:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3419004c:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
34190050:	4603      	mov	r3, r0
34190052:	460a      	mov	r2, r1
34190054:	4313      	orrs	r3, r2
34190056:	d067      	beq.n	34190128 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34190058:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419005c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34190060:	4b19      	ldr	r3, [pc, #100]	@ (341900c8 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34190062:	429a      	cmp	r2, r3
34190064:	d132      	bne.n	341900cc <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190066:	4b0c      	ldr	r3, [pc, #48]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34190068:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419006c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190070:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190074:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190078:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419007a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419007e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190080:	3b01      	subs	r3, #1
34190082:	041b      	lsls	r3, r3, #16
34190084:	4313      	orrs	r3, r2
34190086:	4a04      	ldr	r2, [pc, #16]	@ (34190098 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34190088:	430b      	orrs	r3, r1
3419008a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419008e:	f7fd ffc5 	bl	3418e01c <LL_RCC_IC9_Enable>
34190092:	e042      	b.n	3419011a <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34190094:	07020420 	.word	0x07020420
34190098:	56028000 	.word	0x56028000
3419009c:	07030420 	.word	0x07030420
341900a0:	07010420 	.word	0x07010420
341900a4:	07020820 	.word	0x07020820
341900a8:	07030820 	.word	0x07030820
341900ac:	07010820 	.word	0x07010820
341900b0:	07020c20 	.word	0x07020c20
341900b4:	07030c20 	.word	0x07030c20
341900b8:	07010c20 	.word	0x07010c20
341900bc:	07021020 	.word	0x07021020
341900c0:	07031020 	.word	0x07031020
341900c4:	07011020 	.word	0x07011020
341900c8:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
341900cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900d0:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
341900d4:	4bc2      	ldr	r3, [pc, #776]	@ (341903e0 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
341900d6:	429a      	cmp	r2, r3
341900d8:	d116      	bne.n	34190108 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341900da:	4bc2      	ldr	r3, [pc, #776]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341900dc:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341900e0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341900e4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341900e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900ec:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341900ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900f2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341900f4:	3b01      	subs	r3, #1
341900f6:	041b      	lsls	r3, r3, #16
341900f8:	4313      	orrs	r3, r2
341900fa:	4aba      	ldr	r2, [pc, #744]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341900fc:	430b      	orrs	r3, r1
341900fe:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190102:	f7fe f88b 	bl	3418e21c <LL_RCC_IC14_Enable>
34190106:	e008      	b.n	3419011a <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34190108:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419010c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34190110:	4bb5      	ldr	r3, [pc, #724]	@ (341903e8 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
34190112:	429a      	cmp	r2, r3
34190114:	d101      	bne.n	3419011a <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
34190116:	f7fe fa41 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
3419011a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419011e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34190122:	4618      	mov	r0, r3
34190124:	f7fd f9d2 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34190128:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419012c:	e9d3 2300 	ldrd	r2, r3, [r3]
34190130:	2100      	movs	r1, #0
34190132:	67b9      	str	r1, [r7, #120]	@ 0x78
34190134:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34190138:	67fb      	str	r3, [r7, #124]	@ 0x7c
3419013a:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
3419013e:	4603      	mov	r3, r0
34190140:	460a      	mov	r2, r1
34190142:	4313      	orrs	r3, r2
34190144:	d04b      	beq.n	341901de <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
34190146:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419014a:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3419014e:	4ba7      	ldr	r3, [pc, #668]	@ (341903ec <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
34190150:	429a      	cmp	r2, r3
34190152:	d116      	bne.n	34190182 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34190154:	4ba3      	ldr	r3, [pc, #652]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190156:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419015a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419015e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190162:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190166:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34190168:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419016c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419016e:	3b01      	subs	r3, #1
34190170:	041b      	lsls	r3, r3, #16
34190172:	4313      	orrs	r3, r2
34190174:	4a9b      	ldr	r2, [pc, #620]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190176:	430b      	orrs	r3, r1
34190178:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3419017c:	f7fd ff0e 	bl	3418df9c <LL_RCC_IC8_Enable>
34190180:	e026      	b.n	341901d0 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34190182:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190186:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3419018a:	4b99      	ldr	r3, [pc, #612]	@ (341903f0 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
3419018c:	429a      	cmp	r2, r3
3419018e:	d116      	bne.n	341901be <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190190:	4b94      	ldr	r3, [pc, #592]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190192:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190196:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419019a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419019e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901a2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341901a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901a8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341901aa:	3b01      	subs	r3, #1
341901ac:	041b      	lsls	r3, r3, #16
341901ae:	4313      	orrs	r3, r2
341901b0:	4a8c      	ldr	r2, [pc, #560]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341901b2:	430b      	orrs	r3, r1
341901b4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341901b8:	f7fd ff30 	bl	3418e01c <LL_RCC_IC9_Enable>
341901bc:	e008      	b.n	341901d0 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
341901be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901c2:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
341901c6:	4b8b      	ldr	r3, [pc, #556]	@ (341903f4 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
341901c8:	429a      	cmp	r2, r3
341901ca:	d101      	bne.n	341901d0 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
341901cc:	f7fe f9e6 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
341901d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901d4:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
341901d8:	4618      	mov	r0, r3
341901da:	f7fd f977 	bl	3418d4cc <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
341901de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901e2:	e9d3 2300 	ldrd	r2, r3, [r3]
341901e6:	2100      	movs	r1, #0
341901e8:	6739      	str	r1, [r7, #112]	@ 0x70
341901ea:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341901ee:	677b      	str	r3, [r7, #116]	@ 0x74
341901f0:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
341901f4:	4603      	mov	r3, r0
341901f6:	460a      	mov	r2, r1
341901f8:	4313      	orrs	r3, r2
341901fa:	d04b      	beq.n	34190294 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
341901fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190200:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34190204:	4b7c      	ldr	r3, [pc, #496]	@ (341903f8 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
34190206:	429a      	cmp	r2, r3
34190208:	d116      	bne.n	34190238 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3419020a:	4b76      	ldr	r3, [pc, #472]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419020c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190210:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190214:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190218:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419021c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419021e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190222:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190224:	3b01      	subs	r3, #1
34190226:	041b      	lsls	r3, r3, #16
34190228:	4313      	orrs	r3, r2
3419022a:	4a6e      	ldr	r2, [pc, #440]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419022c:	430b      	orrs	r3, r1
3419022e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34190232:	f7fd fef3 	bl	3418e01c <LL_RCC_IC9_Enable>
34190236:	e026      	b.n	34190286 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
34190238:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419023c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34190240:	4b6e      	ldr	r3, [pc, #440]	@ (341903fc <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
34190242:	429a      	cmp	r2, r3
34190244:	d116      	bne.n	34190274 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34190246:	4b67      	ldr	r3, [pc, #412]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190248:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419024c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190250:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190258:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3419025a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419025e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190260:	3b01      	subs	r3, #1
34190262:	041b      	lsls	r3, r3, #16
34190264:	4313      	orrs	r3, r2
34190266:	4a5f      	ldr	r2, [pc, #380]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190268:	430b      	orrs	r3, r1
3419026a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419026e:	f7fd ffd5 	bl	3418e21c <LL_RCC_IC14_Enable>
34190272:	e008      	b.n	34190286 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34190274:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190278:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3419027c:	4b60      	ldr	r3, [pc, #384]	@ (34190400 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
3419027e:	429a      	cmp	r2, r3
34190280:	d101      	bne.n	34190286 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34190282:	f7fe f98b 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34190286:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419028a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3419028e:	4618      	mov	r0, r3
34190290:	f7fd f927 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34190294:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190298:	e9d3 2300 	ldrd	r2, r3, [r3]
3419029c:	2100      	movs	r1, #0
3419029e:	66b9      	str	r1, [r7, #104]	@ 0x68
341902a0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341902a4:	66fb      	str	r3, [r7, #108]	@ 0x6c
341902a6:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
341902aa:	4603      	mov	r3, r0
341902ac:	460a      	mov	r2, r1
341902ae:	4313      	orrs	r3, r2
341902b0:	d04b      	beq.n	3419034a <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
341902b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902b6:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
341902ba:	4b52      	ldr	r3, [pc, #328]	@ (34190404 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
341902bc:	429a      	cmp	r2, r3
341902be:	d116      	bne.n	341902ee <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341902c0:	4b48      	ldr	r3, [pc, #288]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341902c2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341902c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341902ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341902ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902d2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341902d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902d8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341902da:	3b01      	subs	r3, #1
341902dc:	041b      	lsls	r3, r3, #16
341902de:	4313      	orrs	r3, r2
341902e0:	4a40      	ldr	r2, [pc, #256]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341902e2:	430b      	orrs	r3, r1
341902e4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341902e8:	f7fd fe98 	bl	3418e01c <LL_RCC_IC9_Enable>
341902ec:	e026      	b.n	3419033c <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
341902ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902f2:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
341902f6:	4b44      	ldr	r3, [pc, #272]	@ (34190408 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
341902f8:	429a      	cmp	r2, r3
341902fa:	d116      	bne.n	3419032a <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341902fc:	4b39      	ldr	r3, [pc, #228]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341902fe:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34190302:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190306:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419030a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419030e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34190310:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190314:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190316:	3b01      	subs	r3, #1
34190318:	041b      	lsls	r3, r3, #16
3419031a:	4313      	orrs	r3, r2
3419031c:	4a31      	ldr	r2, [pc, #196]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419031e:	430b      	orrs	r3, r1
34190320:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190324:	f7fd ff7a 	bl	3418e21c <LL_RCC_IC14_Enable>
34190328:	e008      	b.n	3419033c <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3419032a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419032e:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34190332:	4b36      	ldr	r3, [pc, #216]	@ (3419040c <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
34190334:	429a      	cmp	r2, r3
34190336:	d101      	bne.n	3419033c <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
34190338:	f7fe f930 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
3419033c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190340:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34190344:	4618      	mov	r0, r3
34190346:	f7fd f8cc 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3419034a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419034e:	e9d3 2300 	ldrd	r2, r3, [r3]
34190352:	2100      	movs	r1, #0
34190354:	6639      	str	r1, [r7, #96]	@ 0x60
34190356:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3419035a:	667b      	str	r3, [r7, #100]	@ 0x64
3419035c:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34190360:	4603      	mov	r3, r0
34190362:	460a      	mov	r2, r1
34190364:	4313      	orrs	r3, r2
34190366:	d067      	beq.n	34190438 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34190368:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419036c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34190370:	4b27      	ldr	r3, [pc, #156]	@ (34190410 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34190372:	429a      	cmp	r2, r3
34190374:	d116      	bne.n	341903a4 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190376:	4b1b      	ldr	r3, [pc, #108]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190378:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419037c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190380:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190384:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190388:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419038a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419038e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190390:	3b01      	subs	r3, #1
34190392:	041b      	lsls	r3, r3, #16
34190394:	4313      	orrs	r3, r2
34190396:	4a13      	ldr	r2, [pc, #76]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34190398:	430b      	orrs	r3, r1
3419039a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419039e:	f7fd fe3d 	bl	3418e01c <LL_RCC_IC9_Enable>
341903a2:	e042      	b.n	3419042a <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
341903a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903a8:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
341903ac:	4b19      	ldr	r3, [pc, #100]	@ (34190414 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
341903ae:	429a      	cmp	r2, r3
341903b0:	d132      	bne.n	34190418 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341903b2:	4b0c      	ldr	r3, [pc, #48]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341903b4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341903b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341903bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341903c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903c4:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341903c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903ca:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341903cc:	3b01      	subs	r3, #1
341903ce:	041b      	lsls	r3, r3, #16
341903d0:	4313      	orrs	r3, r2
341903d2:	4a04      	ldr	r2, [pc, #16]	@ (341903e4 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341903d4:	430b      	orrs	r3, r1
341903d6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341903da:	f7fd ff1f 	bl	3418e21c <LL_RCC_IC14_Enable>
341903de:	e024      	b.n	3419042a <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
341903e0:	07031420 	.word	0x07031420
341903e4:	56028000 	.word	0x56028000
341903e8:	07011420 	.word	0x07011420
341903ec:	07021820 	.word	0x07021820
341903f0:	07031820 	.word	0x07031820
341903f4:	07011820 	.word	0x07011820
341903f8:	07020030 	.word	0x07020030
341903fc:	07030030 	.word	0x07030030
34190400:	07010030 	.word	0x07010030
34190404:	07020430 	.word	0x07020430
34190408:	07030430 	.word	0x07030430
3419040c:	07010430 	.word	0x07010430
34190410:	07020830 	.word	0x07020830
34190414:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34190418:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419041c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34190420:	4bb3      	ldr	r3, [pc, #716]	@ (341906f0 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
34190422:	429a      	cmp	r2, r3
34190424:	d101      	bne.n	3419042a <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
34190426:	f7fe f8b9 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
3419042a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419042e:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
34190432:	4618      	mov	r0, r3
34190434:	f7fd f855 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
34190438:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419043c:	e9d3 2300 	ldrd	r2, r3, [r3]
34190440:	2100      	movs	r1, #0
34190442:	65b9      	str	r1, [r7, #88]	@ 0x58
34190444:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34190448:	65fb      	str	r3, [r7, #92]	@ 0x5c
3419044a:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
3419044e:	4603      	mov	r3, r0
34190450:	460a      	mov	r2, r1
34190452:	4313      	orrs	r3, r2
34190454:	d04b      	beq.n	341904ee <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
34190456:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419045a:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3419045e:	4ba5      	ldr	r3, [pc, #660]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
34190460:	429a      	cmp	r2, r3
34190462:	d116      	bne.n	34190492 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190464:	4ba4      	ldr	r3, [pc, #656]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34190466:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419046a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419046e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190472:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190476:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34190478:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419047c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419047e:	3b01      	subs	r3, #1
34190480:	041b      	lsls	r3, r3, #16
34190482:	4313      	orrs	r3, r2
34190484:	4a9c      	ldr	r2, [pc, #624]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34190486:	430b      	orrs	r3, r1
34190488:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419048c:	f7fd fdc6 	bl	3418e01c <LL_RCC_IC9_Enable>
34190490:	e026      	b.n	341904e0 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34190492:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190496:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3419049a:	4b98      	ldr	r3, [pc, #608]	@ (341906fc <HAL_RCCEx_PeriphCLKConfig+0x211c>)
3419049c:	429a      	cmp	r2, r3
3419049e:	d116      	bne.n	341904ce <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341904a0:	4b95      	ldr	r3, [pc, #596]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341904a2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341904a6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341904aa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341904ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904b2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341904b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904b8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341904ba:	3b01      	subs	r3, #1
341904bc:	041b      	lsls	r3, r3, #16
341904be:	4313      	orrs	r3, r2
341904c0:	4a8d      	ldr	r2, [pc, #564]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341904c2:	430b      	orrs	r3, r1
341904c4:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341904c8:	f7fd fea8 	bl	3418e21c <LL_RCC_IC14_Enable>
341904cc:	e008      	b.n	341904e0 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
341904ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904d2:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
341904d6:	4b8a      	ldr	r3, [pc, #552]	@ (34190700 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
341904d8:	429a      	cmp	r2, r3
341904da:	d101      	bne.n	341904e0 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
341904dc:	f7fe f85e 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
341904e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904e4:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
341904e8:	4618      	mov	r0, r3
341904ea:	f7fc fffa 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
341904ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904f2:	e9d3 2300 	ldrd	r2, r3, [r3]
341904f6:	2100      	movs	r1, #0
341904f8:	6539      	str	r1, [r7, #80]	@ 0x50
341904fa:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341904fe:	657b      	str	r3, [r7, #84]	@ 0x54
34190500:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
34190504:	4603      	mov	r3, r0
34190506:	460a      	mov	r2, r1
34190508:	4313      	orrs	r3, r2
3419050a:	d04b      	beq.n	341905a4 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3419050c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190510:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34190514:	4b7b      	ldr	r3, [pc, #492]	@ (34190704 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
34190516:	429a      	cmp	r2, r3
34190518:	d116      	bne.n	34190548 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3419051a:	4b77      	ldr	r3, [pc, #476]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3419051c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190520:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190524:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190528:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419052c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419052e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190532:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190534:	3b01      	subs	r3, #1
34190536:	041b      	lsls	r3, r3, #16
34190538:	4313      	orrs	r3, r2
3419053a:	4a6f      	ldr	r2, [pc, #444]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3419053c:	430b      	orrs	r3, r1
3419053e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34190542:	f7fd fd6b 	bl	3418e01c <LL_RCC_IC9_Enable>
34190546:	e026      	b.n	34190596 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
34190548:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419054c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34190550:	4b6d      	ldr	r3, [pc, #436]	@ (34190708 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
34190552:	429a      	cmp	r2, r3
34190554:	d116      	bne.n	34190584 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34190556:	4b68      	ldr	r3, [pc, #416]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34190558:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419055c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190560:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190564:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190568:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3419056a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419056e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190570:	3b01      	subs	r3, #1
34190572:	041b      	lsls	r3, r3, #16
34190574:	4313      	orrs	r3, r2
34190576:	4a60      	ldr	r2, [pc, #384]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34190578:	430b      	orrs	r3, r1
3419057a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419057e:	f7fd fe4d 	bl	3418e21c <LL_RCC_IC14_Enable>
34190582:	e008      	b.n	34190596 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34190584:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190588:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3419058c:	4b5f      	ldr	r3, [pc, #380]	@ (3419070c <HAL_RCCEx_PeriphCLKConfig+0x212c>)
3419058e:	429a      	cmp	r2, r3
34190590:	d101      	bne.n	34190596 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
34190592:	f7fe f803 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
34190596:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419059a:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3419059e:	4618      	mov	r0, r3
341905a0:	f7fc ff9f 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
341905a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905a8:	e9d3 2300 	ldrd	r2, r3, [r3]
341905ac:	2100      	movs	r1, #0
341905ae:	64b9      	str	r1, [r7, #72]	@ 0x48
341905b0:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
341905b4:	64fb      	str	r3, [r7, #76]	@ 0x4c
341905b6:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
341905ba:	4603      	mov	r3, r0
341905bc:	460a      	mov	r2, r1
341905be:	4313      	orrs	r3, r2
341905c0:	d04b      	beq.n	3419065a <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
341905c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905c6:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
341905ca:	4b51      	ldr	r3, [pc, #324]	@ (34190710 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
341905cc:	429a      	cmp	r2, r3
341905ce:	d116      	bne.n	341905fe <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341905d0:	4b49      	ldr	r3, [pc, #292]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341905d2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341905d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341905da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341905de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905e2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341905e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905e8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341905ea:	3b01      	subs	r3, #1
341905ec:	041b      	lsls	r3, r3, #16
341905ee:	4313      	orrs	r3, r2
341905f0:	4a41      	ldr	r2, [pc, #260]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341905f2:	430b      	orrs	r3, r1
341905f4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341905f8:	f7fd fd10 	bl	3418e01c <LL_RCC_IC9_Enable>
341905fc:	e026      	b.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
341905fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190602:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34190606:	4b43      	ldr	r3, [pc, #268]	@ (34190714 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
34190608:	429a      	cmp	r2, r3
3419060a:	d116      	bne.n	3419063a <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3419060c:	4b3a      	ldr	r3, [pc, #232]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3419060e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34190612:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190616:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419061a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419061e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34190620:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190624:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190626:	3b01      	subs	r3, #1
34190628:	041b      	lsls	r3, r3, #16
3419062a:	4313      	orrs	r3, r2
3419062c:	4a32      	ldr	r2, [pc, #200]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3419062e:	430b      	orrs	r3, r1
34190630:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190634:	f7fd fdf2 	bl	3418e21c <LL_RCC_IC14_Enable>
34190638:	e008      	b.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3419063a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419063e:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34190642:	4b35      	ldr	r3, [pc, #212]	@ (34190718 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
34190644:	429a      	cmp	r2, r3
34190646:	d101      	bne.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
34190648:	f7fd ffa8 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
3419064c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190650:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34190654:	4618      	mov	r0, r3
34190656:	f7fc ff44 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3419065a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419065e:	e9d3 2300 	ldrd	r2, r3, [r3]
34190662:	2100      	movs	r1, #0
34190664:	6439      	str	r1, [r7, #64]	@ 0x40
34190666:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3419066a:	647b      	str	r3, [r7, #68]	@ 0x44
3419066c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34190670:	4603      	mov	r3, r0
34190672:	460a      	mov	r2, r1
34190674:	4313      	orrs	r3, r2
34190676:	d065      	beq.n	34190744 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34190678:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419067c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34190680:	4b26      	ldr	r3, [pc, #152]	@ (3419071c <HAL_RCCEx_PeriphCLKConfig+0x213c>)
34190682:	429a      	cmp	r2, r3
34190684:	d116      	bne.n	341906b4 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190686:	4b1c      	ldr	r3, [pc, #112]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34190688:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419068c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190690:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190694:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190698:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419069a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419069e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341906a0:	3b01      	subs	r3, #1
341906a2:	041b      	lsls	r3, r3, #16
341906a4:	4313      	orrs	r3, r2
341906a6:	4a14      	ldr	r2, [pc, #80]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341906a8:	430b      	orrs	r3, r1
341906aa:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341906ae:	f7fd fcb5 	bl	3418e01c <LL_RCC_IC9_Enable>
341906b2:	e040      	b.n	34190736 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
341906b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906b8:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
341906bc:	4b18      	ldr	r3, [pc, #96]	@ (34190720 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
341906be:	429a      	cmp	r2, r3
341906c0:	d130      	bne.n	34190724 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341906c2:	4b0d      	ldr	r3, [pc, #52]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341906c4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341906c8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341906cc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341906d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906d4:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341906d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906da:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341906dc:	3b01      	subs	r3, #1
341906de:	041b      	lsls	r3, r3, #16
341906e0:	4313      	orrs	r3, r2
341906e2:	4a05      	ldr	r2, [pc, #20]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341906e4:	430b      	orrs	r3, r1
341906e6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341906ea:	f7fd fd97 	bl	3418e21c <LL_RCC_IC14_Enable>
341906ee:	e022      	b.n	34190736 <HAL_RCCEx_PeriphCLKConfig+0x2156>
341906f0:	07010830 	.word	0x07010830
341906f4:	07020c30 	.word	0x07020c30
341906f8:	56028000 	.word	0x56028000
341906fc:	07030c30 	.word	0x07030c30
34190700:	07010c30 	.word	0x07010c30
34190704:	07021030 	.word	0x07021030
34190708:	07031030 	.word	0x07031030
3419070c:	07011030 	.word	0x07011030
34190710:	07021430 	.word	0x07021430
34190714:	07031430 	.word	0x07031430
34190718:	07011430 	.word	0x07011430
3419071c:	07021830 	.word	0x07021830
34190720:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34190724:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190728:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3419072c:	4bc8      	ldr	r3, [pc, #800]	@ (34190a50 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3419072e:	429a      	cmp	r2, r3
34190730:	d101      	bne.n	34190736 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
34190732:	f7fd ff33 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
34190736:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419073a:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
3419073e:	4618      	mov	r0, r3
34190740:	f7fc fecf 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34190744:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190748:	e9d3 2300 	ldrd	r2, r3, [r3]
3419074c:	2100      	movs	r1, #0
3419074e:	63b9      	str	r1, [r7, #56]	@ 0x38
34190750:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34190754:	63fb      	str	r3, [r7, #60]	@ 0x3c
34190756:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
3419075a:	4603      	mov	r3, r0
3419075c:	460a      	mov	r2, r1
3419075e:	4313      	orrs	r3, r2
34190760:	d04b      	beq.n	341907fa <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34190762:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190766:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3419076a:	4bba      	ldr	r3, [pc, #744]	@ (34190a54 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3419076c:	429a      	cmp	r2, r3
3419076e:	d116      	bne.n	3419079e <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190770:	4bb9      	ldr	r3, [pc, #740]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190772:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190776:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419077a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419077e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190782:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34190784:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190788:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419078a:	3b01      	subs	r3, #1
3419078c:	041b      	lsls	r3, r3, #16
3419078e:	4313      	orrs	r3, r2
34190790:	4ab1      	ldr	r2, [pc, #708]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190792:	430b      	orrs	r3, r1
34190794:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34190798:	f7fd fc40 	bl	3418e01c <LL_RCC_IC9_Enable>
3419079c:	e026      	b.n	341907ec <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3419079e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907a2:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
341907a6:	4bad      	ldr	r3, [pc, #692]	@ (34190a5c <HAL_RCCEx_PeriphCLKConfig+0x247c>)
341907a8:	429a      	cmp	r2, r3
341907aa:	d116      	bne.n	341907da <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341907ac:	4baa      	ldr	r3, [pc, #680]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341907ae:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341907b2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341907b6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341907ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907be:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341907c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907c4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341907c6:	3b01      	subs	r3, #1
341907c8:	041b      	lsls	r3, r3, #16
341907ca:	4313      	orrs	r3, r2
341907cc:	4aa2      	ldr	r2, [pc, #648]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341907ce:	430b      	orrs	r3, r1
341907d0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341907d4:	f7fd fd22 	bl	3418e21c <LL_RCC_IC14_Enable>
341907d8:	e008      	b.n	341907ec <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
341907da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907de:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
341907e2:	4b9f      	ldr	r3, [pc, #636]	@ (34190a60 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
341907e4:	429a      	cmp	r2, r3
341907e6:	d101      	bne.n	341907ec <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
341907e8:	f7fd fed8 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
341907ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907f0:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
341907f4:	4618      	mov	r0, r3
341907f6:	f7fc fe74 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
341907fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907fe:	e9d3 2300 	ldrd	r2, r3, [r3]
34190802:	2100      	movs	r1, #0
34190804:	6339      	str	r1, [r7, #48]	@ 0x30
34190806:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3419080a:	637b      	str	r3, [r7, #52]	@ 0x34
3419080c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34190810:	4603      	mov	r3, r0
34190812:	460a      	mov	r2, r1
34190814:	4313      	orrs	r3, r2
34190816:	d04b      	beq.n	341908b0 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
34190818:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419081c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34190820:	4a90      	ldr	r2, [pc, #576]	@ (34190a64 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
34190822:	4293      	cmp	r3, r2
34190824:	d116      	bne.n	34190854 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190826:	4b8c      	ldr	r3, [pc, #560]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190828:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419082c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190830:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190834:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190838:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419083a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419083e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190840:	3b01      	subs	r3, #1
34190842:	041b      	lsls	r3, r3, #16
34190844:	4313      	orrs	r3, r2
34190846:	4a84      	ldr	r2, [pc, #528]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190848:	430b      	orrs	r3, r1
3419084a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419084e:	f7fd fbe5 	bl	3418e01c <LL_RCC_IC9_Enable>
34190852:	e026      	b.n	341908a2 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34190854:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190858:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3419085c:	4a82      	ldr	r2, [pc, #520]	@ (34190a68 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3419085e:	4293      	cmp	r3, r2
34190860:	d116      	bne.n	34190890 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34190862:	4b7d      	ldr	r3, [pc, #500]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190864:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34190868:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419086c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190870:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190874:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34190876:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419087a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3419087c:	3b01      	subs	r3, #1
3419087e:	041b      	lsls	r3, r3, #16
34190880:	4313      	orrs	r3, r2
34190882:	4a75      	ldr	r2, [pc, #468]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190884:	430b      	orrs	r3, r1
34190886:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419088a:	f7fd fcc7 	bl	3418e21c <LL_RCC_IC14_Enable>
3419088e:	e008      	b.n	341908a2 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34190890:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190894:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34190898:	4a74      	ldr	r2, [pc, #464]	@ (34190a6c <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3419089a:	4293      	cmp	r3, r2
3419089c:	d101      	bne.n	341908a2 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
3419089e:	f7fd fe7d 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
341908a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908a6:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
341908aa:	4618      	mov	r0, r3
341908ac:	f7fc fe19 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
341908b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908b4:	e9d3 2300 	ldrd	r2, r3, [r3]
341908b8:	2100      	movs	r1, #0
341908ba:	62b9      	str	r1, [r7, #40]	@ 0x28
341908bc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
341908c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
341908c2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
341908c6:	4603      	mov	r3, r0
341908c8:	460a      	mov	r2, r1
341908ca:	4313      	orrs	r3, r2
341908cc:	d04b      	beq.n	34190966 <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
341908ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908d2:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
341908d6:	4a66      	ldr	r2, [pc, #408]	@ (34190a70 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
341908d8:	4293      	cmp	r3, r2
341908da:	d116      	bne.n	3419090a <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341908dc:	4b5e      	ldr	r3, [pc, #376]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341908de:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341908e2:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
341908e6:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
341908ea:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341908ee:	6c91      	ldr	r1, [r2, #72]	@ 0x48
341908f0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
341908f4:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
341908f6:	3a01      	subs	r2, #1
341908f8:	0412      	lsls	r2, r2, #16
341908fa:	430a      	orrs	r2, r1
341908fc:	4956      	ldr	r1, [pc, #344]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
341908fe:	4313      	orrs	r3, r2
34190900:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34190904:	f7fd fb8a 	bl	3418e01c <LL_RCC_IC9_Enable>
34190908:	e026      	b.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3419090a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419090e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34190912:	4a58      	ldr	r2, [pc, #352]	@ (34190a74 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
34190914:	4293      	cmp	r3, r2
34190916:	d116      	bne.n	34190946 <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34190918:	4b4f      	ldr	r3, [pc, #316]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3419091a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419091e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34190922:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34190926:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3419092a:	6f11      	ldr	r1, [r2, #112]	@ 0x70
3419092c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34190930:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34190932:	3a01      	subs	r2, #1
34190934:	0412      	lsls	r2, r2, #16
34190936:	430a      	orrs	r2, r1
34190938:	4947      	ldr	r1, [pc, #284]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3419093a:	4313      	orrs	r3, r2
3419093c:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190940:	f7fd fc6c 	bl	3418e21c <LL_RCC_IC14_Enable>
34190944:	e008      	b.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34190946:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419094a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3419094e:	4a4a      	ldr	r2, [pc, #296]	@ (34190a78 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
34190950:	4293      	cmp	r3, r2
34190952:	d101      	bne.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34190954:	f7fd fe22 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34190958:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419095c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34190960:	4618      	mov	r0, r3
34190962:	f7fc fdbe 	bl	3418d4e2 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34190966:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419096a:	e9d3 2300 	ldrd	r2, r3, [r3]
3419096e:	2100      	movs	r1, #0
34190970:	6239      	str	r1, [r7, #32]
34190972:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34190976:	627b      	str	r3, [r7, #36]	@ 0x24
34190978:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
3419097c:	4603      	mov	r3, r0
3419097e:	460a      	mov	r2, r1
34190980:	4313      	orrs	r3, r2
34190982:	d014      	beq.n	341909ae <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34190984:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190988:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419098c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34190990:	4618      	mov	r0, r3
34190992:	f7fc fd4e 	bl	3418d432 <LL_RCC_SetOTGPHYCKREFClockSource>
34190996:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419099a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3419099e:	0fdb      	lsrs	r3, r3, #31
341909a0:	2b01      	cmp	r3, #1
341909a2:	d102      	bne.n	341909aa <HAL_RCCEx_PeriphCLKConfig+0x23ca>
341909a4:	f7fc faf0 	bl	3418cf88 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
341909a8:	e001      	b.n	341909ae <HAL_RCCEx_PeriphCLKConfig+0x23ce>
341909aa:	f7fc fadd 	bl	3418cf68 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
341909ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909b2:	e9d3 2300 	ldrd	r2, r3, [r3]
341909b6:	2100      	movs	r1, #0
341909b8:	61b9      	str	r1, [r7, #24]
341909ba:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
341909be:	61fb      	str	r3, [r7, #28]
341909c0:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
341909c4:	4603      	mov	r3, r0
341909c6:	460a      	mov	r2, r1
341909c8:	4313      	orrs	r3, r2
341909ca:	d014      	beq.n	341909f6 <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
341909cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909d0:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
341909d4:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341909d8:	4618      	mov	r0, r3
341909da:	f7fc fd2a 	bl	3418d432 <LL_RCC_SetOTGPHYCKREFClockSource>
341909de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909e2:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
341909e6:	0fdb      	lsrs	r3, r3, #31
341909e8:	2b01      	cmp	r3, #1
341909ea:	d102      	bne.n	341909f2 <HAL_RCCEx_PeriphCLKConfig+0x2412>
341909ec:	f7fc facc 	bl	3418cf88 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
341909f0:	e001      	b.n	341909f6 <HAL_RCCEx_PeriphCLKConfig+0x2416>
341909f2:	f7fc fab9 	bl	3418cf68 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
341909f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909fa:	e9d3 2300 	ldrd	r2, r3, [r3]
341909fe:	2100      	movs	r1, #0
34190a00:	6139      	str	r1, [r7, #16]
34190a02:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34190a06:	617b      	str	r3, [r7, #20]
34190a08:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34190a0c:	4603      	mov	r3, r0
34190a0e:	460a      	mov	r2, r1
34190a10:	4313      	orrs	r3, r2
34190a12:	d053      	beq.n	34190abc <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
34190a14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a18:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34190a1c:	4a17      	ldr	r2, [pc, #92]	@ (34190a7c <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34190a1e:	4293      	cmp	r3, r2
34190a20:	d12e      	bne.n	34190a80 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190a22:	4b0d      	ldr	r3, [pc, #52]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190a24:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190a28:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34190a2c:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34190a30:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34190a34:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34190a36:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34190a3a:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34190a3c:	3a01      	subs	r2, #1
34190a3e:	0412      	lsls	r2, r2, #16
34190a40:	430a      	orrs	r2, r1
34190a42:	4905      	ldr	r1, [pc, #20]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34190a44:	4313      	orrs	r3, r2
34190a46:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190a4a:	f7fd fc27 	bl	3418e29c <LL_RCC_IC15_Enable>
34190a4e:	e020      	b.n	34190a92 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
34190a50:	07011830 	.word	0x07011830
34190a54:	07021c30 	.word	0x07021c30
34190a58:	56028000 	.word	0x56028000
34190a5c:	07031c30 	.word	0x07031c30
34190a60:	07011c30 	.word	0x07011c30
34190a64:	07020034 	.word	0x07020034
34190a68:	07030034 	.word	0x07030034
34190a6c:	07010034 	.word	0x07010034
34190a70:	07020434 	.word	0x07020434
34190a74:	07030434 	.word	0x07030434
34190a78:	07010434 	.word	0x07010434
34190a7c:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34190a80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a84:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34190a88:	4a43      	ldr	r2, [pc, #268]	@ (34190b98 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
34190a8a:	4293      	cmp	r3, r2
34190a8c:	d101      	bne.n	34190a92 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
34190a8e:	f7fd fd85 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34190a92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a96:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34190a9a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34190a9e:	4618      	mov	r0, r3
34190aa0:	f7fc fcbc 	bl	3418d41c <LL_RCC_SetOTGPHYClockSource>
34190aa4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190aa8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34190aac:	0fdb      	lsrs	r3, r3, #31
34190aae:	2b01      	cmp	r3, #1
34190ab0:	d102      	bne.n	34190ab8 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
34190ab2:	f7fc fa69 	bl	3418cf88 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34190ab6:	e001      	b.n	34190abc <HAL_RCCEx_PeriphCLKConfig+0x24dc>
34190ab8:	f7fc fa56 	bl	3418cf68 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34190abc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ac0:	e9d3 2300 	ldrd	r2, r3, [r3]
34190ac4:	2100      	movs	r1, #0
34190ac6:	60b9      	str	r1, [r7, #8]
34190ac8:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34190acc:	60fb      	str	r3, [r7, #12]
34190ace:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34190ad2:	4603      	mov	r3, r0
34190ad4:	460a      	mov	r2, r1
34190ad6:	4313      	orrs	r3, r2
34190ad8:	d03b      	beq.n	34190b52 <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
34190ada:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ade:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34190ae2:	4a2e      	ldr	r2, [pc, #184]	@ (34190b9c <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
34190ae4:	4293      	cmp	r3, r2
34190ae6:	d116      	bne.n	34190b16 <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190ae8:	4b2d      	ldr	r3, [pc, #180]	@ (34190ba0 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34190aea:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190aee:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34190af2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34190af6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34190afa:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34190afc:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34190b00:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34190b02:	3a01      	subs	r2, #1
34190b04:	0412      	lsls	r2, r2, #16
34190b06:	430a      	orrs	r2, r1
34190b08:	4925      	ldr	r1, [pc, #148]	@ (34190ba0 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34190b0a:	4313      	orrs	r3, r2
34190b0c:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190b10:	f7fd fbc4 	bl	3418e29c <LL_RCC_IC15_Enable>
34190b14:	e008      	b.n	34190b28 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
34190b16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b1a:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34190b1e:	4a21      	ldr	r2, [pc, #132]	@ (34190ba4 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
34190b20:	4293      	cmp	r3, r2
34190b22:	d101      	bne.n	34190b28 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
34190b24:	f7fd fd3a 	bl	3418e59c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34190b28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b2c:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34190b30:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34190b34:	4618      	mov	r0, r3
34190b36:	f7fc fc71 	bl	3418d41c <LL_RCC_SetOTGPHYClockSource>
34190b3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b3e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34190b42:	0fdb      	lsrs	r3, r3, #31
34190b44:	2b01      	cmp	r3, #1
34190b46:	d102      	bne.n	34190b4e <HAL_RCCEx_PeriphCLKConfig+0x256e>
34190b48:	f7fc fa1e 	bl	3418cf88 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34190b4c:	e001      	b.n	34190b52 <HAL_RCCEx_PeriphCLKConfig+0x2572>
34190b4e:	f7fc fa0b 	bl	3418cf68 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34190b52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b56:	e9d3 2300 	ldrd	r2, r3, [r3]
34190b5a:	2100      	movs	r1, #0
34190b5c:	6039      	str	r1, [r7, #0]
34190b5e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34190b62:	607b      	str	r3, [r7, #4]
34190b64:	e9d7 0100 	ldrd	r0, r1, [r7]
34190b68:	4603      	mov	r3, r0
34190b6a:	460a      	mov	r2, r1
34190b6c:	4313      	orrs	r3, r2
34190b6e:	d006      	beq.n	34190b7e <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
34190b70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b74:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34190b78:	4618      	mov	r0, r3
34190b7a:	f7fc fe8b 	bl	3418d894 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
34190b7e:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
34190b82:	2b00      	cmp	r3, #0
34190b84:	d101      	bne.n	34190b8a <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
34190b86:	2300      	movs	r3, #0
34190b88:	e000      	b.n	34190b8c <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
34190b8a:	2301      	movs	r3, #1
}
34190b8c:	4618      	mov	r0, r3
34190b8e:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
34190b92:	46bd      	mov	sp, r7
34190b94:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34190b98:	03010c14 	.word	0x03010c14
34190b9c:	03021414 	.word	0x03021414
34190ba0:	56028000 	.word	0x56028000
34190ba4:	03011414 	.word	0x03011414

34190ba8 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
34190ba8:	b590      	push	{r4, r7, lr}
34190baa:	b085      	sub	sp, #20
34190bac:	af00      	add	r7, sp, #0
34190bae:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
34190bb2:	2100      	movs	r1, #0
34190bb4:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
34190bb6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190bba:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
34190bbe:	ea50 0104 	orrs.w	r1, r0, r4
34190bc2:	f000 8436 	beq.w	34191432 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
34190bc6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190bca:	2801      	cmp	r0, #1
34190bcc:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
34190bd0:	f080 8434 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190bd4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190bd8:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
34190bdc:	ea50 0104 	orrs.w	r1, r0, r4
34190be0:	f000 8422 	beq.w	34191428 <HAL_RCCEx_GetPeriphCLKFreq+0x880>
34190be4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190be8:	2801      	cmp	r0, #1
34190bea:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
34190bee:	f080 8425 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190bf2:	e9d7 0100 	ldrd	r0, r1, [r7]
34190bf6:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
34190bfa:	ea50 0104 	orrs.w	r1, r0, r4
34190bfe:	f000 840e 	beq.w	3419141e <HAL_RCCEx_GetPeriphCLKFreq+0x876>
34190c02:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c06:	2801      	cmp	r0, #1
34190c08:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34190c0c:	f080 8416 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190c10:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c14:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
34190c18:	ea50 0104 	orrs.w	r1, r0, r4
34190c1c:	f000 83fa 	beq.w	34191414 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
34190c20:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c24:	2801      	cmp	r0, #1
34190c26:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
34190c2a:	f080 8407 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190c2e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c32:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
34190c36:	ea50 0104 	orrs.w	r1, r0, r4
34190c3a:	f000 83e6 	beq.w	3419140a <HAL_RCCEx_GetPeriphCLKFreq+0x862>
34190c3e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c42:	2801      	cmp	r0, #1
34190c44:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
34190c48:	f080 83f8 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190c4c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c50:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
34190c54:	ea50 0104 	orrs.w	r1, r0, r4
34190c58:	f000 83d2 	beq.w	34191400 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
34190c5c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c60:	2801      	cmp	r0, #1
34190c62:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
34190c66:	f080 83e9 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190c6a:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c6e:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
34190c72:	ea50 0104 	orrs.w	r1, r0, r4
34190c76:	f000 83be 	beq.w	341913f6 <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
34190c7a:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c7e:	2801      	cmp	r0, #1
34190c80:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
34190c84:	f080 83da 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190c88:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c8c:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
34190c90:	ea50 0104 	orrs.w	r1, r0, r4
34190c94:	f000 83aa 	beq.w	341913ec <HAL_RCCEx_GetPeriphCLKFreq+0x844>
34190c98:	e9d7 0100 	ldrd	r0, r1, [r7]
34190c9c:	2801      	cmp	r0, #1
34190c9e:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
34190ca2:	f080 83cb 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190ca6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190caa:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
34190cae:	ea50 0104 	orrs.w	r1, r0, r4
34190cb2:	f000 8396 	beq.w	341913e2 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
34190cb6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190cba:	2801      	cmp	r0, #1
34190cbc:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
34190cc0:	f080 83bc 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190cc4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190cc8:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
34190ccc:	ea50 0104 	orrs.w	r1, r0, r4
34190cd0:	f000 8382 	beq.w	341913d8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
34190cd4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190cd8:	2801      	cmp	r0, #1
34190cda:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
34190cde:	f080 83ad 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190ce2:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ce6:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
34190cea:	ea50 0104 	orrs.w	r1, r0, r4
34190cee:	f000 836e 	beq.w	341913ce <HAL_RCCEx_GetPeriphCLKFreq+0x826>
34190cf2:	e9d7 0100 	ldrd	r0, r1, [r7]
34190cf6:	2801      	cmp	r0, #1
34190cf8:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
34190cfc:	f080 839e 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d00:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d04:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
34190d08:	ea50 0104 	orrs.w	r1, r0, r4
34190d0c:	f000 835a 	beq.w	341913c4 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
34190d10:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d14:	2801      	cmp	r0, #1
34190d16:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
34190d1a:	f080 838f 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d1e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d22:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
34190d26:	ea50 0104 	orrs.w	r1, r0, r4
34190d2a:	f000 8346 	beq.w	341913ba <HAL_RCCEx_GetPeriphCLKFreq+0x812>
34190d2e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d32:	2801      	cmp	r0, #1
34190d34:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
34190d38:	f080 8380 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d3c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d40:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
34190d44:	ea50 0104 	orrs.w	r1, r0, r4
34190d48:	f000 8332 	beq.w	341913b0 <HAL_RCCEx_GetPeriphCLKFreq+0x808>
34190d4c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d50:	2801      	cmp	r0, #1
34190d52:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
34190d56:	f080 8371 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d5a:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d5e:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
34190d62:	ea50 0104 	orrs.w	r1, r0, r4
34190d66:	f000 831e 	beq.w	341913a6 <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
34190d6a:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d6e:	2801      	cmp	r0, #1
34190d70:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
34190d74:	f080 8362 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d78:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d7c:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
34190d80:	ea50 0104 	orrs.w	r1, r0, r4
34190d84:	f000 830a 	beq.w	3419139c <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
34190d88:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d8c:	2801      	cmp	r0, #1
34190d8e:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
34190d92:	f080 8353 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190d96:	e9d7 0100 	ldrd	r0, r1, [r7]
34190d9a:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
34190d9e:	ea50 0104 	orrs.w	r1, r0, r4
34190da2:	f000 82f6 	beq.w	34191392 <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
34190da6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190daa:	2801      	cmp	r0, #1
34190dac:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
34190db0:	f080 8344 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190db4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190db8:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
34190dbc:	ea50 0104 	orrs.w	r1, r0, r4
34190dc0:	f000 82e2 	beq.w	34191388 <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
34190dc4:	e9d7 0100 	ldrd	r0, r1, [r7]
34190dc8:	2801      	cmp	r0, #1
34190dca:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
34190dce:	f080 8335 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190dd2:	e9d7 0100 	ldrd	r0, r1, [r7]
34190dd6:	f1a1 0420 	sub.w	r4, r1, #32
34190dda:	ea50 0104 	orrs.w	r1, r0, r4
34190dde:	f000 82ce 	beq.w	3419137e <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
34190de2:	e9d7 0100 	ldrd	r0, r1, [r7]
34190de6:	2801      	cmp	r0, #1
34190de8:	f171 0120 	sbcs.w	r1, r1, #32
34190dec:	f080 8326 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190df0:	e9d7 0100 	ldrd	r0, r1, [r7]
34190df4:	f1a1 0410 	sub.w	r4, r1, #16
34190df8:	ea50 0104 	orrs.w	r1, r0, r4
34190dfc:	f000 82ba 	beq.w	34191374 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
34190e00:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e04:	2801      	cmp	r0, #1
34190e06:	f171 0110 	sbcs.w	r1, r1, #16
34190e0a:	f080 8317 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e0e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e12:	f1a1 0408 	sub.w	r4, r1, #8
34190e16:	ea50 0104 	orrs.w	r1, r0, r4
34190e1a:	f000 82a6 	beq.w	3419136a <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
34190e1e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e22:	2801      	cmp	r0, #1
34190e24:	f171 0108 	sbcs.w	r1, r1, #8
34190e28:	f080 8308 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e2c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e30:	1f0c      	subs	r4, r1, #4
34190e32:	ea50 0104 	orrs.w	r1, r0, r4
34190e36:	f000 8293 	beq.w	34191360 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
34190e3a:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e3e:	2801      	cmp	r0, #1
34190e40:	f171 0104 	sbcs.w	r1, r1, #4
34190e44:	f080 82fa 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e48:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e4c:	1e8c      	subs	r4, r1, #2
34190e4e:	ea50 0104 	orrs.w	r1, r0, r4
34190e52:	f000 8280 	beq.w	34191356 <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
34190e56:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e5a:	2801      	cmp	r0, #1
34190e5c:	f171 0102 	sbcs.w	r1, r1, #2
34190e60:	f080 82ec 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e64:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e68:	1e4c      	subs	r4, r1, #1
34190e6a:	ea50 0104 	orrs.w	r1, r0, r4
34190e6e:	f000 826d 	beq.w	3419134c <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
34190e72:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e76:	2801      	cmp	r0, #1
34190e78:	f171 0101 	sbcs.w	r1, r1, #1
34190e7c:	f080 82de 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e80:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e84:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
34190e88:	4321      	orrs	r1, r4
34190e8a:	f000 825a 	beq.w	34191342 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
34190e8e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190e92:	4cda      	ldr	r4, [pc, #872]	@ (341911fc <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
34190e94:	42a0      	cmp	r0, r4
34190e96:	f171 0100 	sbcs.w	r1, r1, #0
34190e9a:	f080 82cf 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190e9e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ea2:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
34190ea6:	4321      	orrs	r1, r4
34190ea8:	f000 8246 	beq.w	34191338 <HAL_RCCEx_GetPeriphCLKFreq+0x790>
34190eac:	e9d7 0100 	ldrd	r0, r1, [r7]
34190eb0:	4cd3      	ldr	r4, [pc, #844]	@ (34191200 <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
34190eb2:	42a0      	cmp	r0, r4
34190eb4:	f171 0100 	sbcs.w	r1, r1, #0
34190eb8:	f080 82c0 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190ebc:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ec0:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
34190ec4:	4321      	orrs	r1, r4
34190ec6:	f000 8232 	beq.w	3419132e <HAL_RCCEx_GetPeriphCLKFreq+0x786>
34190eca:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ece:	4ccd      	ldr	r4, [pc, #820]	@ (34191204 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
34190ed0:	42a0      	cmp	r0, r4
34190ed2:	f171 0100 	sbcs.w	r1, r1, #0
34190ed6:	f080 82b1 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190eda:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ede:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
34190ee2:	4321      	orrs	r1, r4
34190ee4:	f000 821e 	beq.w	34191324 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
34190ee8:	e9d7 0100 	ldrd	r0, r1, [r7]
34190eec:	4cc6      	ldr	r4, [pc, #792]	@ (34191208 <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
34190eee:	42a0      	cmp	r0, r4
34190ef0:	f171 0100 	sbcs.w	r1, r1, #0
34190ef4:	f080 82a2 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190ef8:	e9d7 0100 	ldrd	r0, r1, [r7]
34190efc:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
34190f00:	4321      	orrs	r1, r4
34190f02:	f000 820b 	beq.w	3419131c <HAL_RCCEx_GetPeriphCLKFreq+0x774>
34190f06:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f0a:	4cc0      	ldr	r4, [pc, #768]	@ (3419120c <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
34190f0c:	42a0      	cmp	r0, r4
34190f0e:	f171 0100 	sbcs.w	r1, r1, #0
34190f12:	f080 8293 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190f16:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f1a:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
34190f1e:	4321      	orrs	r1, r4
34190f20:	f000 81f7 	beq.w	34191312 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
34190f24:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f28:	4cb9      	ldr	r4, [pc, #740]	@ (34191210 <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
34190f2a:	42a0      	cmp	r0, r4
34190f2c:	f171 0100 	sbcs.w	r1, r1, #0
34190f30:	f080 8284 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190f34:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f38:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
34190f3c:	4321      	orrs	r1, r4
34190f3e:	f000 81e2 	beq.w	34191306 <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
34190f42:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f46:	4cb3      	ldr	r4, [pc, #716]	@ (34191214 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
34190f48:	42a0      	cmp	r0, r4
34190f4a:	f171 0100 	sbcs.w	r1, r1, #0
34190f4e:	f080 8275 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190f52:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f56:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
34190f5a:	4321      	orrs	r1, r4
34190f5c:	f000 81cd 	beq.w	341912fa <HAL_RCCEx_GetPeriphCLKFreq+0x752>
34190f60:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f64:	4cac      	ldr	r4, [pc, #688]	@ (34191218 <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
34190f66:	42a0      	cmp	r0, r4
34190f68:	f171 0100 	sbcs.w	r1, r1, #0
34190f6c:	f080 8266 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190f70:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f74:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
34190f78:	4321      	orrs	r1, r4
34190f7a:	f000 81b8 	beq.w	341912ee <HAL_RCCEx_GetPeriphCLKFreq+0x746>
34190f7e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f82:	4ca6      	ldr	r4, [pc, #664]	@ (3419121c <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
34190f84:	42a0      	cmp	r0, r4
34190f86:	f171 0100 	sbcs.w	r1, r1, #0
34190f8a:	f080 8257 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190f8e:	e9d7 0100 	ldrd	r0, r1, [r7]
34190f92:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
34190f96:	4321      	orrs	r1, r4
34190f98:	f000 81a4 	beq.w	341912e4 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
34190f9c:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fa0:	4c9f      	ldr	r4, [pc, #636]	@ (34191220 <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
34190fa2:	42a0      	cmp	r0, r4
34190fa4:	f171 0100 	sbcs.w	r1, r1, #0
34190fa8:	f080 8248 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190fac:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fb0:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
34190fb4:	4321      	orrs	r1, r4
34190fb6:	f000 8190 	beq.w	341912da <HAL_RCCEx_GetPeriphCLKFreq+0x732>
34190fba:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fbe:	4c99      	ldr	r4, [pc, #612]	@ (34191224 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
34190fc0:	42a0      	cmp	r0, r4
34190fc2:	f171 0100 	sbcs.w	r1, r1, #0
34190fc6:	f080 8239 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190fca:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fce:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
34190fd2:	4321      	orrs	r1, r4
34190fd4:	f000 817c 	beq.w	341912d0 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
34190fd8:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fdc:	4c92      	ldr	r4, [pc, #584]	@ (34191228 <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
34190fde:	42a0      	cmp	r0, r4
34190fe0:	f171 0100 	sbcs.w	r1, r1, #0
34190fe4:	f080 822a 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34190fe8:	e9d7 0100 	ldrd	r0, r1, [r7]
34190fec:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
34190ff0:	4321      	orrs	r1, r4
34190ff2:	f000 8168 	beq.w	341912c6 <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
34190ff6:	e9d7 0100 	ldrd	r0, r1, [r7]
34190ffa:	4c8c      	ldr	r4, [pc, #560]	@ (3419122c <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
34190ffc:	42a0      	cmp	r0, r4
34190ffe:	f171 0100 	sbcs.w	r1, r1, #0
34191002:	f080 821b 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191006:	e9d7 0100 	ldrd	r0, r1, [r7]
3419100a:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
3419100e:	4321      	orrs	r1, r4
34191010:	f000 8154 	beq.w	341912bc <HAL_RCCEx_GetPeriphCLKFreq+0x714>
34191014:	e9d7 0100 	ldrd	r0, r1, [r7]
34191018:	4c85      	ldr	r4, [pc, #532]	@ (34191230 <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
3419101a:	42a0      	cmp	r0, r4
3419101c:	f171 0100 	sbcs.w	r1, r1, #0
34191020:	f080 820c 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191024:	e9d7 0100 	ldrd	r0, r1, [r7]
34191028:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
3419102c:	4321      	orrs	r1, r4
3419102e:	f000 8140 	beq.w	341912b2 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
34191032:	e9d7 0100 	ldrd	r0, r1, [r7]
34191036:	4c7f      	ldr	r4, [pc, #508]	@ (34191234 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
34191038:	42a0      	cmp	r0, r4
3419103a:	f171 0100 	sbcs.w	r1, r1, #0
3419103e:	f080 81fd 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191042:	e9d7 0100 	ldrd	r0, r1, [r7]
34191046:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
3419104a:	4321      	orrs	r1, r4
3419104c:	f000 812c 	beq.w	341912a8 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
34191050:	e9d7 0100 	ldrd	r0, r1, [r7]
34191054:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
34191058:	f171 0100 	sbcs.w	r1, r1, #0
3419105c:	f080 81ee 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191060:	e9d7 0100 	ldrd	r0, r1, [r7]
34191064:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
34191068:	4321      	orrs	r1, r4
3419106a:	f000 8118 	beq.w	3419129e <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
3419106e:	e9d7 0100 	ldrd	r0, r1, [r7]
34191072:	f248 0401 	movw	r4, #32769	@ 0x8001
34191076:	42a0      	cmp	r0, r4
34191078:	f171 0100 	sbcs.w	r1, r1, #0
3419107c:	f080 81de 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191080:	e9d7 0100 	ldrd	r0, r1, [r7]
34191084:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
34191088:	4321      	orrs	r1, r4
3419108a:	f000 8103 	beq.w	34191294 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3419108e:	e9d7 0100 	ldrd	r0, r1, [r7]
34191092:	f244 0401 	movw	r4, #16385	@ 0x4001
34191096:	42a0      	cmp	r0, r4
34191098:	f171 0100 	sbcs.w	r1, r1, #0
3419109c:	f080 81ce 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341910a0:	e9d7 0100 	ldrd	r0, r1, [r7]
341910a4:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
341910a8:	4321      	orrs	r1, r4
341910aa:	f000 80ee 	beq.w	3419128a <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
341910ae:	e9d7 0100 	ldrd	r0, r1, [r7]
341910b2:	f242 0401 	movw	r4, #8193	@ 0x2001
341910b6:	42a0      	cmp	r0, r4
341910b8:	f171 0100 	sbcs.w	r1, r1, #0
341910bc:	f080 81be 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341910c0:	e9d7 0100 	ldrd	r0, r1, [r7]
341910c4:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
341910c8:	4321      	orrs	r1, r4
341910ca:	f000 80d9 	beq.w	34191280 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
341910ce:	e9d7 0100 	ldrd	r0, r1, [r7]
341910d2:	f241 0401 	movw	r4, #4097	@ 0x1001
341910d6:	42a0      	cmp	r0, r4
341910d8:	f171 0100 	sbcs.w	r1, r1, #0
341910dc:	f080 81ae 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341910e0:	e9d7 0100 	ldrd	r0, r1, [r7]
341910e4:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
341910e8:	4321      	orrs	r1, r4
341910ea:	f000 80c4 	beq.w	34191276 <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
341910ee:	e9d7 0100 	ldrd	r0, r1, [r7]
341910f2:	f640 0401 	movw	r4, #2049	@ 0x801
341910f6:	42a0      	cmp	r0, r4
341910f8:	f171 0100 	sbcs.w	r1, r1, #0
341910fc:	f080 819e 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191100:	e9d7 0100 	ldrd	r0, r1, [r7]
34191104:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
34191108:	4321      	orrs	r1, r4
3419110a:	f000 80af 	beq.w	3419126c <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
3419110e:	e9d7 0100 	ldrd	r0, r1, [r7]
34191112:	f240 4401 	movw	r4, #1025	@ 0x401
34191116:	42a0      	cmp	r0, r4
34191118:	f171 0100 	sbcs.w	r1, r1, #0
3419111c:	f080 818e 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191120:	e9d7 0100 	ldrd	r0, r1, [r7]
34191124:	2821      	cmp	r0, #33	@ 0x21
34191126:	f171 0100 	sbcs.w	r1, r1, #0
3419112a:	d255      	bcs.n	341911d8 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
3419112c:	e9d7 0100 	ldrd	r0, r1, [r7]
34191130:	4301      	orrs	r1, r0
34191132:	f000 8183 	beq.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191136:	e9d7 0100 	ldrd	r0, r1, [r7]
3419113a:	1e42      	subs	r2, r0, #1
3419113c:	f141 33ff 	adc.w	r3, r1, #4294967295
34191140:	2a20      	cmp	r2, #32
34191142:	f173 0100 	sbcs.w	r1, r3, #0
34191146:	f080 8179 	bcs.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419114a:	2a1f      	cmp	r2, #31
3419114c:	f200 8176 	bhi.w	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191150:	a101      	add	r1, pc, #4	@ (adr r1, 34191158 <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
34191152:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
34191156:	bf00      	nop
34191158:	341911e7 	.word	0x341911e7
3419115c:	341911f1 	.word	0x341911f1
34191160:	3419143d 	.word	0x3419143d
34191164:	34191241 	.word	0x34191241
34191168:	3419143d 	.word	0x3419143d
3419116c:	3419143d 	.word	0x3419143d
34191170:	3419143d 	.word	0x3419143d
34191174:	34191239 	.word	0x34191239
34191178:	3419143d 	.word	0x3419143d
3419117c:	3419143d 	.word	0x3419143d
34191180:	3419143d 	.word	0x3419143d
34191184:	3419143d 	.word	0x3419143d
34191188:	3419143d 	.word	0x3419143d
3419118c:	3419143d 	.word	0x3419143d
34191190:	3419143d 	.word	0x3419143d
34191194:	3419124b 	.word	0x3419124b
34191198:	3419143d 	.word	0x3419143d
3419119c:	3419143d 	.word	0x3419143d
341911a0:	3419143d 	.word	0x3419143d
341911a4:	3419143d 	.word	0x3419143d
341911a8:	3419143d 	.word	0x3419143d
341911ac:	3419143d 	.word	0x3419143d
341911b0:	3419143d 	.word	0x3419143d
341911b4:	3419143d 	.word	0x3419143d
341911b8:	3419143d 	.word	0x3419143d
341911bc:	3419143d 	.word	0x3419143d
341911c0:	3419143d 	.word	0x3419143d
341911c4:	3419143d 	.word	0x3419143d
341911c8:	3419143d 	.word	0x3419143d
341911cc:	3419143d 	.word	0x3419143d
341911d0:	3419143d 	.word	0x3419143d
341911d4:	34191257 	.word	0x34191257
341911d8:	e9d7 2300 	ldrd	r2, r3, [r7]
341911dc:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
341911e0:	430b      	orrs	r3, r1
341911e2:	d03e      	beq.n	34191262 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
341911e4:	e12a      	b.n	3419143c <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
341911e6:	2070      	movs	r0, #112	@ 0x70
341911e8:	f000 fb90 	bl	3419190c <RCCEx_GetADCCLKFreq>
341911ec:	60f8      	str	r0, [r7, #12]
      break;
341911ee:	e126      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
341911f0:	2007      	movs	r0, #7
341911f2:	f000 fc8d 	bl	34191b10 <RCCEx_GetADFCLKFreq>
341911f6:	60f8      	str	r0, [r7, #12]
      break;
341911f8:	e121      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
341911fa:	bf00      	nop
341911fc:	80000001 	.word	0x80000001
34191200:	40000001 	.word	0x40000001
34191204:	20000001 	.word	0x20000001
34191208:	10000001 	.word	0x10000001
3419120c:	08000001 	.word	0x08000001
34191210:	04000001 	.word	0x04000001
34191214:	02000001 	.word	0x02000001
34191218:	01000001 	.word	0x01000001
3419121c:	00800001 	.word	0x00800001
34191220:	00400001 	.word	0x00400001
34191224:	00200001 	.word	0x00200001
34191228:	00100001 	.word	0x00100001
3419122c:	00080001 	.word	0x00080001
34191230:	00040001 	.word	0x00040001
34191234:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
34191238:	f000 ff0c 	bl	34192054 <RCCEx_GetCSICLKFreq>
3419123c:	60f8      	str	r0, [r7, #12]
      break;
3419123e:	e0fe      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34191240:	2007      	movs	r0, #7
34191242:	f000 fd51 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34191246:	60f8      	str	r0, [r7, #12]
      break;
34191248:	e0f9      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
3419124a:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
3419124e:	f000 ff4d 	bl	341920ec <RCCEx_GetDCMIPPCLKFreq>
34191252:	60f8      	str	r0, [r7, #12]
      break;
34191254:	e0f3      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
34191256:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
3419125a:	f000 ffd1 	bl	34192200 <RCCEx_GetETH1CLKFreq>
3419125e:	60f8      	str	r0, [r7, #12]
      break;
34191260:	e0ed      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
34191262:	2003      	movs	r0, #3
34191264:	f001 f84c 	bl	34192300 <RCCEx_GetETH1PTPCLKFreq>
34191268:	60f8      	str	r0, [r7, #12]
      break;
3419126a:	e0e8      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
3419126c:	2003      	movs	r0, #3
3419126e:	f001 f8cb 	bl	34192408 <RCCEx_GetFDCANCLKFreq>
34191272:	60f8      	str	r0, [r7, #12]
      break;
34191274:	e0e3      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34191276:	2030      	movs	r0, #48	@ 0x30
34191278:	f001 f946 	bl	34192508 <RCCEx_GetFMCCLKFreq>
3419127c:	60f8      	str	r0, [r7, #12]
      break;
3419127e:	e0de      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34191280:	4871      	ldr	r0, [pc, #452]	@ (34191448 <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
34191282:	f001 f9f9 	bl	34192678 <RCCEx_GetI2CCLKFreq>
34191286:	60f8      	str	r0, [r7, #12]
      break;
34191288:	e0d9      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3419128a:	4870      	ldr	r0, [pc, #448]	@ (3419144c <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
3419128c:	f001 f9f4 	bl	34192678 <RCCEx_GetI2CCLKFreq>
34191290:	60f8      	str	r0, [r7, #12]
      break;
34191292:	e0d4      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34191294:	486e      	ldr	r0, [pc, #440]	@ (34191450 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34191296:	f001 f9ef 	bl	34192678 <RCCEx_GetI2CCLKFreq>
3419129a:	60f8      	str	r0, [r7, #12]
      break;
3419129c:	e0cf      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3419129e:	486d      	ldr	r0, [pc, #436]	@ (34191454 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
341912a0:	f001 f9ea 	bl	34192678 <RCCEx_GetI2CCLKFreq>
341912a4:	60f8      	str	r0, [r7, #12]
      break;
341912a6:	e0ca      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
341912a8:	486b      	ldr	r0, [pc, #428]	@ (34191458 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
341912aa:	f001 fb8d 	bl	341929c8 <RCCEx_GetI3CCLKFreq>
341912ae:	60f8      	str	r0, [r7, #12]
      break;
341912b0:	e0c5      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
341912b2:	486a      	ldr	r0, [pc, #424]	@ (3419145c <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
341912b4:	f001 fb88 	bl	341929c8 <RCCEx_GetI3CCLKFreq>
341912b8:	60f8      	str	r0, [r7, #12]
      break;
341912ba:	e0c0      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
341912bc:	4868      	ldr	r0, [pc, #416]	@ (34191460 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
341912be:	f001 fcb7 	bl	34192c30 <RCCEx_GetLPTIMCLKFreq>
341912c2:	60f8      	str	r0, [r7, #12]
      break;
341912c4:	e0bb      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
341912c6:	4867      	ldr	r0, [pc, #412]	@ (34191464 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
341912c8:	f001 fcb2 	bl	34192c30 <RCCEx_GetLPTIMCLKFreq>
341912cc:	60f8      	str	r0, [r7, #12]
      break;
341912ce:	e0b6      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
341912d0:	4865      	ldr	r0, [pc, #404]	@ (34191468 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
341912d2:	f001 fcad 	bl	34192c30 <RCCEx_GetLPTIMCLKFreq>
341912d6:	60f8      	str	r0, [r7, #12]
      break;
341912d8:	e0b1      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
341912da:	4864      	ldr	r0, [pc, #400]	@ (3419146c <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
341912dc:	f001 fca8 	bl	34192c30 <RCCEx_GetLPTIMCLKFreq>
341912e0:	60f8      	str	r0, [r7, #12]
      break;
341912e2:	e0ac      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
341912e4:	4862      	ldr	r0, [pc, #392]	@ (34191470 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
341912e6:	f001 fca3 	bl	34192c30 <RCCEx_GetLPTIMCLKFreq>
341912ea:	60f8      	str	r0, [r7, #12]
      break;
341912ec:	e0a7      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
341912ee:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
341912f2:	f001 fe47 	bl	34192f84 <RCCEx_GetLPUARTCLKFreq>
341912f6:	60f8      	str	r0, [r7, #12]
      break;
341912f8:	e0a1      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
341912fa:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
341912fe:	f001 ff43 	bl	34193188 <RCCEx_GetLTDCCLKFreq>
34191302:	60f8      	str	r0, [r7, #12]
      break;
34191304:	e09b      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
34191306:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
3419130a:	f001 ffc7 	bl	3419329c <RCCEx_GetMDFCLKFreq>
3419130e:	60f8      	str	r0, [r7, #12]
      break;
34191310:	e095      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
34191312:	2030      	movs	r0, #48	@ 0x30
34191314:	f002 f8cc 	bl	341934b0 <RCCEx_GetPSSICLKFreq>
34191318:	60f8      	str	r0, [r7, #12]
      break;
3419131a:	e090      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
3419131c:	f002 f94a 	bl	341935b4 <RCCEx_GetRTCCLKFreq>
34191320:	60f8      	str	r0, [r7, #12]
      break;
34191322:	e08c      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
34191324:	4853      	ldr	r0, [pc, #332]	@ (34191474 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
34191326:	f002 f997 	bl	34193658 <RCCEx_GetSAICLKFreq>
3419132a:	60f8      	str	r0, [r7, #12]
      break;
3419132c:	e087      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
3419132e:	4852      	ldr	r0, [pc, #328]	@ (34191478 <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
34191330:	f002 f992 	bl	34193658 <RCCEx_GetSAICLKFreq>
34191334:	60f8      	str	r0, [r7, #12]
      break;
34191336:	e082      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
34191338:	4850      	ldr	r0, [pc, #320]	@ (3419147c <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
3419133a:	f002 faf3 	bl	34193924 <RCCEx_GetSDMMCCLKFreq>
3419133e:	60f8      	str	r0, [r7, #12]
      break;
34191340:	e07d      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
34191342:	484f      	ldr	r0, [pc, #316]	@ (34191480 <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
34191344:	f002 faee 	bl	34193924 <RCCEx_GetSDMMCCLKFreq>
34191348:	60f8      	str	r0, [r7, #12]
      break;
3419134a:	e078      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3419134c:	2007      	movs	r0, #7
3419134e:	f002 fbd3 	bl	34193af8 <RCCEx_GetSPDIFRXCLKFreq>
34191352:	60f8      	str	r0, [r7, #12]
      break;
34191354:	e073      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
34191356:	484b      	ldr	r0, [pc, #300]	@ (34191484 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
34191358:	f002 fcb2 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
3419135c:	60f8      	str	r0, [r7, #12]
      break;
3419135e:	e06e      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
34191360:	4849      	ldr	r0, [pc, #292]	@ (34191488 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
34191362:	f002 fcad 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
34191366:	60f8      	str	r0, [r7, #12]
      break;
34191368:	e069      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3419136a:	4848      	ldr	r0, [pc, #288]	@ (3419148c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
3419136c:	f002 fca8 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
34191370:	60f8      	str	r0, [r7, #12]
      break;
34191372:	e064      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34191374:	4846      	ldr	r0, [pc, #280]	@ (34191490 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34191376:	f002 fca3 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
3419137a:	60f8      	str	r0, [r7, #12]
      break;
3419137c:	e05f      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3419137e:	4845      	ldr	r0, [pc, #276]	@ (34191494 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
34191380:	f002 fc9e 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
34191384:	60f8      	str	r0, [r7, #12]
      break;
34191386:	e05a      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34191388:	4843      	ldr	r0, [pc, #268]	@ (34191498 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
3419138a:	f002 fc99 	bl	34193cc0 <RCCEx_GetSPICLKFreq>
3419138e:	60f8      	str	r0, [r7, #12]
      break;
34191390:	e055      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
34191392:	4842      	ldr	r0, [pc, #264]	@ (3419149c <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34191394:	f003 f990 	bl	341946b8 <RCCEx_GetUSARTCLKFreq>
34191398:	60f8      	str	r0, [r7, #12]
      break;
3419139a:	e050      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3419139c:	4840      	ldr	r0, [pc, #256]	@ (341914a0 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
3419139e:	f003 f98b 	bl	341946b8 <RCCEx_GetUSARTCLKFreq>
341913a2:	60f8      	str	r0, [r7, #12]
      break;
341913a4:	e04b      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
341913a6:	483f      	ldr	r0, [pc, #252]	@ (341914a4 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
341913a8:	f003 f986 	bl	341946b8 <RCCEx_GetUSARTCLKFreq>
341913ac:	60f8      	str	r0, [r7, #12]
      break;
341913ae:	e046      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
341913b0:	483d      	ldr	r0, [pc, #244]	@ (341914a8 <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
341913b2:	f002 ff57 	bl	34194264 <RCCEx_GetUARTCLKFreq>
341913b6:	60f8      	str	r0, [r7, #12]
      break;
341913b8:	e041      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
341913ba:	483c      	ldr	r0, [pc, #240]	@ (341914ac <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
341913bc:	f002 ff52 	bl	34194264 <RCCEx_GetUARTCLKFreq>
341913c0:	60f8      	str	r0, [r7, #12]
      break;
341913c2:	e03c      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
341913c4:	483a      	ldr	r0, [pc, #232]	@ (341914b0 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
341913c6:	f003 f977 	bl	341946b8 <RCCEx_GetUSARTCLKFreq>
341913ca:	60f8      	str	r0, [r7, #12]
      break;
341913cc:	e037      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
341913ce:	4839      	ldr	r0, [pc, #228]	@ (341914b4 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
341913d0:	f002 ff48 	bl	34194264 <RCCEx_GetUARTCLKFreq>
341913d4:	60f8      	str	r0, [r7, #12]
      break;
341913d6:	e032      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
341913d8:	4837      	ldr	r0, [pc, #220]	@ (341914b8 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
341913da:	f002 ff43 	bl	34194264 <RCCEx_GetUARTCLKFreq>
341913de:	60f8      	str	r0, [r7, #12]
      break;
341913e0:	e02d      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
341913e2:	4836      	ldr	r0, [pc, #216]	@ (341914bc <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
341913e4:	f002 ff3e 	bl	34194264 <RCCEx_GetUARTCLKFreq>
341913e8:	60f8      	str	r0, [r7, #12]
      break;
341913ea:	e028      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
341913ec:	4834      	ldr	r0, [pc, #208]	@ (341914c0 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
341913ee:	f003 f963 	bl	341946b8 <RCCEx_GetUSARTCLKFreq>
341913f2:	60f8      	str	r0, [r7, #12]
      break;
341913f4:	e023      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
341913f6:	4833      	ldr	r0, [pc, #204]	@ (341914c4 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
341913f8:	f003 fc3e 	bl	34194c78 <RCCEx_GetOTGPHYCKREFCLKFreq>
341913fc:	60f8      	str	r0, [r7, #12]
      break;
341913fe:	e01e      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34191400:	4831      	ldr	r0, [pc, #196]	@ (341914c8 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
34191402:	f003 fb83 	bl	34194b0c <RCCEx_GetOTGPHYCLKFreq>
34191406:	60f8      	str	r0, [r7, #12]
      break;
34191408:	e019      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3419140a:	4830      	ldr	r0, [pc, #192]	@ (341914cc <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3419140c:	f003 fc34 	bl	34194c78 <RCCEx_GetOTGPHYCKREFCLKFreq>
34191410:	60f8      	str	r0, [r7, #12]
      break;
34191412:	e014      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34191414:	482e      	ldr	r0, [pc, #184]	@ (341914d0 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
34191416:	f003 fb79 	bl	34194b0c <RCCEx_GetOTGPHYCLKFreq>
3419141a:	60f8      	str	r0, [r7, #12]
      break;
3419141c:	e00f      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
3419141e:	482d      	ldr	r0, [pc, #180]	@ (341914d4 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
34191420:	f003 fc7a 	bl	34194d18 <RCCEx_GetXSPICLKFreq>
34191424:	60f8      	str	r0, [r7, #12]
      break;
34191426:	e00a      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
34191428:	482b      	ldr	r0, [pc, #172]	@ (341914d8 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
3419142a:	f003 fc75 	bl	34194d18 <RCCEx_GetXSPICLKFreq>
3419142e:	60f8      	str	r0, [r7, #12]
      break;
34191430:	e005      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
34191432:	482a      	ldr	r0, [pc, #168]	@ (341914dc <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
34191434:	f003 fc70 	bl	34194d18 <RCCEx_GetXSPICLKFreq>
34191438:	60f8      	str	r0, [r7, #12]
      break;
3419143a:	e000      	b.n	3419143e <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
3419143c:	bf00      	nop
  }

  return frequency;
3419143e:	68fb      	ldr	r3, [r7, #12]
}
34191440:	4618      	mov	r0, r3
34191442:	3714      	adds	r7, #20
34191444:	46bd      	mov	sp, r7
34191446:	bd90      	pop	{r4, r7, pc}
34191448:	0700000c 	.word	0x0700000c
3419144c:	0700040c 	.word	0x0700040c
34191450:	0700080c 	.word	0x0700080c
34191454:	07000c0c 	.word	0x07000c0c
34191458:	0700100c 	.word	0x0700100c
3419145c:	0700140c 	.word	0x0700140c
34191460:	0700082c 	.word	0x0700082c
34191464:	07000c2c 	.word	0x07000c2c
34191468:	0700102c 	.word	0x0700102c
3419146c:	0700142c 	.word	0x0700142c
34191470:	0700182c 	.word	0x0700182c
34191474:	07001418 	.word	0x07001418
34191478:	07001818 	.word	0x07001818
3419147c:	0300001c 	.word	0x0300001c
34191480:	0300041c 	.word	0x0300041c
34191484:	07000420 	.word	0x07000420
34191488:	07000820 	.word	0x07000820
3419148c:	07000c20 	.word	0x07000c20
34191490:	07001020 	.word	0x07001020
34191494:	07001420 	.word	0x07001420
34191498:	07001820 	.word	0x07001820
3419149c:	07000030 	.word	0x07000030
341914a0:	07000430 	.word	0x07000430
341914a4:	07000830 	.word	0x07000830
341914a8:	07000c30 	.word	0x07000c30
341914ac:	07001030 	.word	0x07001030
341914b0:	07001430 	.word	0x07001430
341914b4:	07001830 	.word	0x07001830
341914b8:	07001c30 	.word	0x07001c30
341914bc:	07000034 	.word	0x07000034
341914c0:	07000434 	.word	0x07000434
341914c4:	01001014 	.word	0x01001014
341914c8:	03000c14 	.word	0x03000c14
341914cc:	01001814 	.word	0x01001814
341914d0:	03001414 	.word	0x03001414
341914d4:	03000014 	.word	0x03000014
341914d8:	03000414 	.word	0x03000414
341914dc:	03000814 	.word	0x03000814

341914e0 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
341914e0:	b5f0      	push	{r4, r5, r6, r7, lr}
341914e2:	b087      	sub	sp, #28
341914e4:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
341914e6:	2300      	movs	r3, #0
341914e8:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
341914ea:	f7fc fa05 	bl	3418d8f8 <LL_RCC_PLL1_IsReady>
341914ee:	4603      	mov	r3, r0
341914f0:	2b00      	cmp	r3, #0
341914f2:	d02a      	beq.n	3419154a <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
341914f4:	f7fc fa68 	bl	3418d9c8 <LL_RCC_PLL1P_IsEnabled>
341914f8:	4603      	mov	r3, r0
341914fa:	2b00      	cmp	r3, #0
341914fc:	d031      	beq.n	34191562 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
341914fe:	f7fc f9ed 	bl	3418d8dc <LL_RCC_PLL1_GetSource>
34191502:	4603      	mov	r3, r0
34191504:	4618      	mov	r0, r3
34191506:	f000 f957 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
3419150a:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3419150c:	68bb      	ldr	r3, [r7, #8]
3419150e:	2b00      	cmp	r3, #0
34191510:	d027      	beq.n	34191562 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
34191512:	f7fc fa29 	bl	3418d968 <LL_RCC_PLL1_GetM>
34191516:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34191518:	687b      	ldr	r3, [r7, #4]
3419151a:	2b00      	cmp	r3, #0
3419151c:	d021      	beq.n	34191562 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
3419151e:	f7fc fa13 	bl	3418d948 <LL_RCC_PLL1_GetN>
34191522:	4605      	mov	r5, r0
34191524:	f7fc fa64 	bl	3418d9f0 <LL_RCC_PLL1_GetFRACN>
34191528:	4606      	mov	r6, r0
3419152a:	f7fc fa2d 	bl	3418d988 <LL_RCC_PLL1_GetP1>
3419152e:	4604      	mov	r4, r0
34191530:	f7fc fa3a 	bl	3418d9a8 <LL_RCC_PLL1_GetP2>
34191534:	4603      	mov	r3, r0
34191536:	9301      	str	r3, [sp, #4]
34191538:	9400      	str	r4, [sp, #0]
3419153a:	4633      	mov	r3, r6
3419153c:	462a      	mov	r2, r5
3419153e:	6879      	ldr	r1, [r7, #4]
34191540:	68b8      	ldr	r0, [r7, #8]
34191542:	f000 f997 	bl	34191874 <RCCEx_CalcPLLFreq>
34191546:	60f8      	str	r0, [r7, #12]
34191548:	e00b      	b.n	34191562 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
3419154a:	f7fc f9e9 	bl	3418d920 <LL_RCC_PLL1_IsEnabledBypass>
3419154e:	4603      	mov	r3, r0
34191550:	2b00      	cmp	r3, #0
34191552:	d006      	beq.n	34191562 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34191554:	f7fc f9c2 	bl	3418d8dc <LL_RCC_PLL1_GetSource>
34191558:	4603      	mov	r3, r0
3419155a:	4618      	mov	r0, r3
3419155c:	f000 f92c 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
34191560:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34191562:	68fb      	ldr	r3, [r7, #12]
}
34191564:	4618      	mov	r0, r3
34191566:	3714      	adds	r7, #20
34191568:	46bd      	mov	sp, r7
3419156a:	bdf0      	pop	{r4, r5, r6, r7, pc}

3419156c <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
3419156c:	b5f0      	push	{r4, r5, r6, r7, lr}
3419156e:	b087      	sub	sp, #28
34191570:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34191572:	2300      	movs	r3, #0
34191574:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34191576:	f7fc fa57 	bl	3418da28 <LL_RCC_PLL2_IsReady>
3419157a:	4603      	mov	r3, r0
3419157c:	2b00      	cmp	r3, #0
3419157e:	d02a      	beq.n	341915d6 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34191580:	f7fc faba 	bl	3418daf8 <LL_RCC_PLL2P_IsEnabled>
34191584:	4603      	mov	r3, r0
34191586:	2b00      	cmp	r3, #0
34191588:	d031      	beq.n	341915ee <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3419158a:	f7fc fa3f 	bl	3418da0c <LL_RCC_PLL2_GetSource>
3419158e:	4603      	mov	r3, r0
34191590:	4618      	mov	r0, r3
34191592:	f000 f911 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
34191596:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34191598:	68bb      	ldr	r3, [r7, #8]
3419159a:	2b00      	cmp	r3, #0
3419159c:	d027      	beq.n	341915ee <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
3419159e:	f7fc fa7b 	bl	3418da98 <LL_RCC_PLL2_GetM>
341915a2:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341915a4:	687b      	ldr	r3, [r7, #4]
341915a6:	2b00      	cmp	r3, #0
341915a8:	d021      	beq.n	341915ee <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
341915aa:	f7fc fa65 	bl	3418da78 <LL_RCC_PLL2_GetN>
341915ae:	4605      	mov	r5, r0
341915b0:	f7fc fab6 	bl	3418db20 <LL_RCC_PLL2_GetFRACN>
341915b4:	4606      	mov	r6, r0
341915b6:	f7fc fa7f 	bl	3418dab8 <LL_RCC_PLL2_GetP1>
341915ba:	4604      	mov	r4, r0
341915bc:	f7fc fa8c 	bl	3418dad8 <LL_RCC_PLL2_GetP2>
341915c0:	4603      	mov	r3, r0
341915c2:	9301      	str	r3, [sp, #4]
341915c4:	9400      	str	r4, [sp, #0]
341915c6:	4633      	mov	r3, r6
341915c8:	462a      	mov	r2, r5
341915ca:	6879      	ldr	r1, [r7, #4]
341915cc:	68b8      	ldr	r0, [r7, #8]
341915ce:	f000 f951 	bl	34191874 <RCCEx_CalcPLLFreq>
341915d2:	60f8      	str	r0, [r7, #12]
341915d4:	e00b      	b.n	341915ee <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
341915d6:	f7fc fa3b 	bl	3418da50 <LL_RCC_PLL2_IsEnabledBypass>
341915da:	4603      	mov	r3, r0
341915dc:	2b00      	cmp	r3, #0
341915de:	d006      	beq.n	341915ee <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
341915e0:	f7fc fa14 	bl	3418da0c <LL_RCC_PLL2_GetSource>
341915e4:	4603      	mov	r3, r0
341915e6:	4618      	mov	r0, r3
341915e8:	f000 f8e6 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
341915ec:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
341915ee:	68fb      	ldr	r3, [r7, #12]
}
341915f0:	4618      	mov	r0, r3
341915f2:	3714      	adds	r7, #20
341915f4:	46bd      	mov	sp, r7
341915f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

341915f8 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
341915f8:	b5f0      	push	{r4, r5, r6, r7, lr}
341915fa:	b087      	sub	sp, #28
341915fc:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
341915fe:	2300      	movs	r3, #0
34191600:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34191602:	f7fc faa9 	bl	3418db58 <LL_RCC_PLL3_IsReady>
34191606:	4603      	mov	r3, r0
34191608:	2b00      	cmp	r3, #0
3419160a:	d02a      	beq.n	34191662 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
3419160c:	f7fc fb0c 	bl	3418dc28 <LL_RCC_PLL3P_IsEnabled>
34191610:	4603      	mov	r3, r0
34191612:	2b00      	cmp	r3, #0
34191614:	d031      	beq.n	3419167a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34191616:	f7fc fa91 	bl	3418db3c <LL_RCC_PLL3_GetSource>
3419161a:	4603      	mov	r3, r0
3419161c:	4618      	mov	r0, r3
3419161e:	f000 f8cb 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
34191622:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34191624:	68bb      	ldr	r3, [r7, #8]
34191626:	2b00      	cmp	r3, #0
34191628:	d027      	beq.n	3419167a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
3419162a:	f7fc facd 	bl	3418dbc8 <LL_RCC_PLL3_GetM>
3419162e:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34191630:	687b      	ldr	r3, [r7, #4]
34191632:	2b00      	cmp	r3, #0
34191634:	d021      	beq.n	3419167a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34191636:	f7fc fab7 	bl	3418dba8 <LL_RCC_PLL3_GetN>
3419163a:	4605      	mov	r5, r0
3419163c:	f7fc fb08 	bl	3418dc50 <LL_RCC_PLL3_GetFRACN>
34191640:	4606      	mov	r6, r0
34191642:	f7fc fad1 	bl	3418dbe8 <LL_RCC_PLL3_GetP1>
34191646:	4604      	mov	r4, r0
34191648:	f7fc fade 	bl	3418dc08 <LL_RCC_PLL3_GetP2>
3419164c:	4603      	mov	r3, r0
3419164e:	9301      	str	r3, [sp, #4]
34191650:	9400      	str	r4, [sp, #0]
34191652:	4633      	mov	r3, r6
34191654:	462a      	mov	r2, r5
34191656:	6879      	ldr	r1, [r7, #4]
34191658:	68b8      	ldr	r0, [r7, #8]
3419165a:	f000 f90b 	bl	34191874 <RCCEx_CalcPLLFreq>
3419165e:	60f8      	str	r0, [r7, #12]
34191660:	e00b      	b.n	3419167a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
34191662:	f7fc fa8d 	bl	3418db80 <LL_RCC_PLL3_IsEnabledBypass>
34191666:	4603      	mov	r3, r0
34191668:	2b00      	cmp	r3, #0
3419166a:	d006      	beq.n	3419167a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
3419166c:	f7fc fa66 	bl	3418db3c <LL_RCC_PLL3_GetSource>
34191670:	4603      	mov	r3, r0
34191672:	4618      	mov	r0, r3
34191674:	f000 f8a0 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
34191678:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3419167a:	68fb      	ldr	r3, [r7, #12]
}
3419167c:	4618      	mov	r0, r3
3419167e:	3714      	adds	r7, #20
34191680:	46bd      	mov	sp, r7
34191682:	bdf0      	pop	{r4, r5, r6, r7, pc}

34191684 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34191684:	b5f0      	push	{r4, r5, r6, r7, lr}
34191686:	b087      	sub	sp, #28
34191688:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3419168a:	2300      	movs	r3, #0
3419168c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
3419168e:	f7fc fafb 	bl	3418dc88 <LL_RCC_PLL4_IsReady>
34191692:	4603      	mov	r3, r0
34191694:	2b00      	cmp	r3, #0
34191696:	d02a      	beq.n	341916ee <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34191698:	f7fc fb5e 	bl	3418dd58 <LL_RCC_PLL4P_IsEnabled>
3419169c:	4603      	mov	r3, r0
3419169e:	2b00      	cmp	r3, #0
341916a0:	d031      	beq.n	34191706 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
341916a2:	f7fc fae3 	bl	3418dc6c <LL_RCC_PLL4_GetSource>
341916a6:	4603      	mov	r3, r0
341916a8:	4618      	mov	r0, r3
341916aa:	f000 f885 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
341916ae:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
341916b0:	68bb      	ldr	r3, [r7, #8]
341916b2:	2b00      	cmp	r3, #0
341916b4:	d027      	beq.n	34191706 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
341916b6:	f7fc fb1f 	bl	3418dcf8 <LL_RCC_PLL4_GetM>
341916ba:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341916bc:	687b      	ldr	r3, [r7, #4]
341916be:	2b00      	cmp	r3, #0
341916c0:	d021      	beq.n	34191706 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
341916c2:	f7fc fb09 	bl	3418dcd8 <LL_RCC_PLL4_GetN>
341916c6:	4605      	mov	r5, r0
341916c8:	f7fc fb5a 	bl	3418dd80 <LL_RCC_PLL4_GetFRACN>
341916cc:	4606      	mov	r6, r0
341916ce:	f7fc fb23 	bl	3418dd18 <LL_RCC_PLL4_GetP1>
341916d2:	4604      	mov	r4, r0
341916d4:	f7fc fb30 	bl	3418dd38 <LL_RCC_PLL4_GetP2>
341916d8:	4603      	mov	r3, r0
341916da:	9301      	str	r3, [sp, #4]
341916dc:	9400      	str	r4, [sp, #0]
341916de:	4633      	mov	r3, r6
341916e0:	462a      	mov	r2, r5
341916e2:	6879      	ldr	r1, [r7, #4]
341916e4:	68b8      	ldr	r0, [r7, #8]
341916e6:	f000 f8c5 	bl	34191874 <RCCEx_CalcPLLFreq>
341916ea:	60f8      	str	r0, [r7, #12]
341916ec:	e00b      	b.n	34191706 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
341916ee:	f7fc fadf 	bl	3418dcb0 <LL_RCC_PLL4_IsEnabledBypass>
341916f2:	4603      	mov	r3, r0
341916f4:	2b00      	cmp	r3, #0
341916f6:	d006      	beq.n	34191706 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
341916f8:	f7fc fab8 	bl	3418dc6c <LL_RCC_PLL4_GetSource>
341916fc:	4603      	mov	r3, r0
341916fe:	4618      	mov	r0, r3
34191700:	f000 f85a 	bl	341917b8 <RCCEx_GetPLLSourceFreq>
34191704:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34191706:	68fb      	ldr	r3, [r7, #12]
}
34191708:	4618      	mov	r0, r3
3419170a:	3714      	adds	r7, #20
3419170c:	46bd      	mov	sp, r7
3419170e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34191710 <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34191710:	b580      	push	{r7, lr}
34191712:	b082      	sub	sp, #8
34191714:	af00      	add	r7, sp, #0
34191716:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34191718:	f7fb fcca 	bl	3418d0b0 <LL_RCC_GetAHBPrescaler>
3419171c:	4603      	mov	r3, r0
3419171e:	0d1b      	lsrs	r3, r3, #20
34191720:	f003 0307 	and.w	r3, r3, #7
34191724:	687a      	ldr	r2, [r7, #4]
34191726:	fa22 f303 	lsr.w	r3, r2, r3
}
3419172a:	4618      	mov	r0, r3
3419172c:	3708      	adds	r7, #8
3419172e:	46bd      	mov	sp, r7
34191730:	bd80      	pop	{r7, pc}

34191732 <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34191732:	b580      	push	{r7, lr}
34191734:	b082      	sub	sp, #8
34191736:	af00      	add	r7, sp, #0
34191738:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
3419173a:	f7fb fcc7 	bl	3418d0cc <LL_RCC_GetAPB1Prescaler>
3419173e:	4603      	mov	r3, r0
34191740:	f003 0307 	and.w	r3, r3, #7
34191744:	687a      	ldr	r2, [r7, #4]
34191746:	fa22 f303 	lsr.w	r3, r2, r3
}
3419174a:	4618      	mov	r0, r3
3419174c:	3708      	adds	r7, #8
3419174e:	46bd      	mov	sp, r7
34191750:	bd80      	pop	{r7, pc}

34191752 <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
34191752:	b580      	push	{r7, lr}
34191754:	b082      	sub	sp, #8
34191756:	af00      	add	r7, sp, #0
34191758:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
3419175a:	f7fb fcc5 	bl	3418d0e8 <LL_RCC_GetAPB2Prescaler>
3419175e:	4603      	mov	r3, r0
34191760:	091b      	lsrs	r3, r3, #4
34191762:	f003 0307 	and.w	r3, r3, #7
34191766:	687a      	ldr	r2, [r7, #4]
34191768:	fa22 f303 	lsr.w	r3, r2, r3
}
3419176c:	4618      	mov	r0, r3
3419176e:	3708      	adds	r7, #8
34191770:	46bd      	mov	sp, r7
34191772:	bd80      	pop	{r7, pc}

34191774 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
34191774:	b580      	push	{r7, lr}
34191776:	b082      	sub	sp, #8
34191778:	af00      	add	r7, sp, #0
3419177a:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
3419177c:	f7fb fcc2 	bl	3418d104 <LL_RCC_GetAPB4Prescaler>
34191780:	4603      	mov	r3, r0
34191782:	0b1b      	lsrs	r3, r3, #12
34191784:	f003 0307 	and.w	r3, r3, #7
34191788:	687a      	ldr	r2, [r7, #4]
3419178a:	fa22 f303 	lsr.w	r3, r2, r3
}
3419178e:	4618      	mov	r0, r3
34191790:	3708      	adds	r7, #8
34191792:	46bd      	mov	sp, r7
34191794:	bd80      	pop	{r7, pc}

34191796 <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
34191796:	b580      	push	{r7, lr}
34191798:	b082      	sub	sp, #8
3419179a:	af00      	add	r7, sp, #0
3419179c:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
3419179e:	f7fb fcbf 	bl	3418d120 <LL_RCC_GetAPB5Prescaler>
341917a2:	4603      	mov	r3, r0
341917a4:	0c1b      	lsrs	r3, r3, #16
341917a6:	f003 0307 	and.w	r3, r3, #7
341917aa:	687a      	ldr	r2, [r7, #4]
341917ac:	fa22 f303 	lsr.w	r3, r2, r3
}
341917b0:	4618      	mov	r0, r3
341917b2:	3708      	adds	r7, #8
341917b4:	46bd      	mov	sp, r7
341917b6:	bd80      	pop	{r7, pc}

341917b8 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
341917b8:	b580      	push	{r7, lr}
341917ba:	b084      	sub	sp, #16
341917bc:	af00      	add	r7, sp, #0
341917be:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
341917c0:	2300      	movs	r3, #0
341917c2:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
341917c4:	687b      	ldr	r3, [r7, #4]
341917c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341917ca:	d039      	beq.n	34191840 <RCCEx_GetPLLSourceFreq+0x88>
341917cc:	687b      	ldr	r3, [r7, #4]
341917ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341917d2:	d838      	bhi.n	34191846 <RCCEx_GetPLLSourceFreq+0x8e>
341917d4:	687b      	ldr	r3, [r7, #4]
341917d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341917da:	d029      	beq.n	34191830 <RCCEx_GetPLLSourceFreq+0x78>
341917dc:	687b      	ldr	r3, [r7, #4]
341917de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341917e2:	d830      	bhi.n	34191846 <RCCEx_GetPLLSourceFreq+0x8e>
341917e4:	687b      	ldr	r3, [r7, #4]
341917e6:	2b00      	cmp	r3, #0
341917e8:	d004      	beq.n	341917f4 <RCCEx_GetPLLSourceFreq+0x3c>
341917ea:	687b      	ldr	r3, [r7, #4]
341917ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341917f0:	d00e      	beq.n	34191810 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
341917f2:	e028      	b.n	34191846 <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
341917f4:	f7fb fbfc 	bl	3418cff0 <LL_RCC_HSI_IsReady>
341917f8:	4603      	mov	r3, r0
341917fa:	2b00      	cmp	r3, #0
341917fc:	d025      	beq.n	3419184a <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341917fe:	f7fb fc09 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34191802:	4603      	mov	r3, r0
34191804:	09db      	lsrs	r3, r3, #7
34191806:	4a16      	ldr	r2, [pc, #88]	@ (34191860 <RCCEx_GetPLLSourceFreq+0xa8>)
34191808:	fa22 f303 	lsr.w	r3, r2, r3
3419180c:	60fb      	str	r3, [r7, #12]
      break;
3419180e:	e01c      	b.n	3419184a <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34191810:	f7fb fc0e 	bl	3418d030 <LL_RCC_MSI_IsReady>
34191814:	4603      	mov	r3, r0
34191816:	2b00      	cmp	r3, #0
34191818:	d019      	beq.n	3419184e <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3419181a:	f7fb fc1b 	bl	3418d054 <LL_RCC_MSI_GetFrequency>
3419181e:	4603      	mov	r3, r0
34191820:	2b00      	cmp	r3, #0
34191822:	d102      	bne.n	3419182a <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34191824:	4b0f      	ldr	r3, [pc, #60]	@ (34191864 <RCCEx_GetPLLSourceFreq+0xac>)
34191826:	60fb      	str	r3, [r7, #12]
      break;
34191828:	e011      	b.n	3419184e <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
3419182a:	4b0f      	ldr	r3, [pc, #60]	@ (34191868 <RCCEx_GetPLLSourceFreq+0xb0>)
3419182c:	60fb      	str	r3, [r7, #12]
      break;
3419182e:	e00e      	b.n	3419184e <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34191830:	f7fb fbcc 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34191834:	4603      	mov	r3, r0
34191836:	2b00      	cmp	r3, #0
34191838:	d00b      	beq.n	34191852 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
3419183a:	4b0c      	ldr	r3, [pc, #48]	@ (3419186c <RCCEx_GetPLLSourceFreq+0xb4>)
3419183c:	60fb      	str	r3, [r7, #12]
      break;
3419183e:	e008      	b.n	34191852 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34191840:	4b0b      	ldr	r3, [pc, #44]	@ (34191870 <RCCEx_GetPLLSourceFreq+0xb8>)
34191842:	60fb      	str	r3, [r7, #12]
      break;
34191844:	e006      	b.n	34191854 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34191846:	bf00      	nop
34191848:	e004      	b.n	34191854 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3419184a:	bf00      	nop
3419184c:	e002      	b.n	34191854 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3419184e:	bf00      	nop
34191850:	e000      	b.n	34191854 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34191852:	bf00      	nop
  }

  return pllinputfreq;
34191854:	68fb      	ldr	r3, [r7, #12]
}
34191856:	4618      	mov	r0, r3
34191858:	3710      	adds	r7, #16
3419185a:	46bd      	mov	sp, r7
3419185c:	bd80      	pop	{r7, pc}
3419185e:	bf00      	nop
34191860:	03d09000 	.word	0x03d09000
34191864:	003d0900 	.word	0x003d0900
34191868:	00f42400 	.word	0x00f42400
3419186c:	02dc6c00 	.word	0x02dc6c00
34191870:	00bb8000 	.word	0x00bb8000

34191874 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34191874:	b480      	push	{r7}
34191876:	b087      	sub	sp, #28
34191878:	af00      	add	r7, sp, #0
3419187a:	60f8      	str	r0, [r7, #12]
3419187c:	60b9      	str	r1, [r7, #8]
3419187e:	607a      	str	r2, [r7, #4]
34191880:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34191882:	68fb      	ldr	r3, [r7, #12]
34191884:	ee07 3a90 	vmov	s15, r3
34191888:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419188c:	687b      	ldr	r3, [r7, #4]
3419188e:	ee07 3a90 	vmov	s15, r3
34191892:	eef8 6a67 	vcvt.f32.u32	s13, s15
34191896:	683b      	ldr	r3, [r7, #0]
34191898:	ee07 3a90 	vmov	s15, r3
3419189c:	eeb8 6a67 	vcvt.f32.u32	s12, s15
341918a0:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34191908 <RCCEx_CalcPLLFreq+0x94>
341918a4:	eec6 7a25 	vdiv.f32	s15, s12, s11
341918a8:	ee76 7aa7 	vadd.f32	s15, s13, s15
341918ac:	ee67 6a27 	vmul.f32	s13, s14, s15
341918b0:	68bb      	ldr	r3, [r7, #8]
341918b2:	ee07 3a90 	vmov	s15, r3
341918b6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341918ba:	eec6 7a87 	vdiv.f32	s15, s13, s14
341918be:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
341918c2:	6a3b      	ldr	r3, [r7, #32]
341918c4:	ee07 3a90 	vmov	s15, r3
341918c8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341918cc:	edd7 6a05 	vldr	s13, [r7, #20]
341918d0:	eec6 7a87 	vdiv.f32	s15, s13, s14
341918d4:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
341918d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341918da:	ee07 3a90 	vmov	s15, r3
341918de:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341918e2:	edd7 6a05 	vldr	s13, [r7, #20]
341918e6:	eec6 7a87 	vdiv.f32	s15, s13, s14
341918ea:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
341918ee:	edd7 7a05 	vldr	s15, [r7, #20]
341918f2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
341918f6:	ee17 3a90 	vmov	r3, s15
}
341918fa:	4618      	mov	r0, r3
341918fc:	371c      	adds	r7, #28
341918fe:	46bd      	mov	sp, r7
34191900:	f85d 7b04 	ldr.w	r7, [sp], #4
34191904:	4770      	bx	lr
34191906:	bf00      	nop
34191908:	4b800000 	.word	0x4b800000

3419190c <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
3419190c:	b590      	push	{r4, r7, lr}
3419190e:	b085      	sub	sp, #20
34191910:	af00      	add	r7, sp, #0
34191912:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34191914:	2300      	movs	r3, #0
34191916:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
34191918:	6878      	ldr	r0, [r7, #4]
3419191a:	f7fb fe1f 	bl	3418d55c <LL_RCC_GetADCClockSource>
3419191e:	4603      	mov	r3, r0
34191920:	2b70      	cmp	r3, #112	@ 0x70
34191922:	f000 80d1 	beq.w	34191ac8 <RCCEx_GetADCCLKFreq+0x1bc>
34191926:	2b70      	cmp	r3, #112	@ 0x70
34191928:	f200 80d8 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
3419192c:	2b60      	cmp	r3, #96	@ 0x60
3419192e:	f000 80c8 	beq.w	34191ac2 <RCCEx_GetADCCLKFreq+0x1b6>
34191932:	2b60      	cmp	r3, #96	@ 0x60
34191934:	f200 80d2 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
34191938:	2b50      	cmp	r3, #80	@ 0x50
3419193a:	f000 80ac 	beq.w	34191a96 <RCCEx_GetADCCLKFreq+0x18a>
3419193e:	2b50      	cmp	r3, #80	@ 0x50
34191940:	f200 80cc 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
34191944:	2b40      	cmp	r3, #64	@ 0x40
34191946:	f000 80b4 	beq.w	34191ab2 <RCCEx_GetADCCLKFreq+0x1a6>
3419194a:	2b40      	cmp	r3, #64	@ 0x40
3419194c:	f200 80c6 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
34191950:	2b30      	cmp	r3, #48	@ 0x30
34191952:	d05d      	beq.n	34191a10 <RCCEx_GetADCCLKFreq+0x104>
34191954:	2b30      	cmp	r3, #48	@ 0x30
34191956:	f200 80c1 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
3419195a:	2b20      	cmp	r3, #32
3419195c:	d014      	beq.n	34191988 <RCCEx_GetADCCLKFreq+0x7c>
3419195e:	2b20      	cmp	r3, #32
34191960:	f200 80bc 	bhi.w	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
34191964:	2b00      	cmp	r3, #0
34191966:	d002      	beq.n	3419196e <RCCEx_GetADCCLKFreq+0x62>
34191968:	2b10      	cmp	r3, #16
3419196a:	d008      	beq.n	3419197e <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
3419196c:	e0b6      	b.n	34191adc <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3419196e:	f7fa ff17 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34191972:	4603      	mov	r3, r0
34191974:	4618      	mov	r0, r3
34191976:	f7ff fecb 	bl	34191710 <RCCEx_GetHCLKFreq>
3419197a:	60f8      	str	r0, [r7, #12]
      break;
3419197c:	e0b7      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419197e:	2007      	movs	r0, #7
34191980:	f000 f9b2 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34191984:	60f8      	str	r0, [r7, #12]
      break;
34191986:	e0b2      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34191988:	f7fc fad6 	bl	3418df38 <LL_RCC_IC7_IsEnabled>
3419198c:	4603      	mov	r3, r0
3419198e:	2b00      	cmp	r3, #0
34191990:	f000 80a6 	beq.w	34191ae0 <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
34191994:	f7fc faf2 	bl	3418df7c <LL_RCC_IC7_GetDivider>
34191998:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
3419199a:	f7fc fae1 	bl	3418df60 <LL_RCC_IC7_GetSource>
3419199e:	4603      	mov	r3, r0
341919a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341919a4:	d029      	beq.n	341919fa <RCCEx_GetADCCLKFreq+0xee>
341919a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341919aa:	d82f      	bhi.n	34191a0c <RCCEx_GetADCCLKFreq+0x100>
341919ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341919b0:	d01a      	beq.n	341919e8 <RCCEx_GetADCCLKFreq+0xdc>
341919b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341919b6:	d829      	bhi.n	34191a0c <RCCEx_GetADCCLKFreq+0x100>
341919b8:	2b00      	cmp	r3, #0
341919ba:	d003      	beq.n	341919c4 <RCCEx_GetADCCLKFreq+0xb8>
341919bc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341919c0:	d009      	beq.n	341919d6 <RCCEx_GetADCCLKFreq+0xca>
            break;
341919c2:	e023      	b.n	34191a0c <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341919c4:	f7ff fd8c 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341919c8:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
341919ca:	68fa      	ldr	r2, [r7, #12]
341919cc:	68bb      	ldr	r3, [r7, #8]
341919ce:	fbb2 f3f3 	udiv	r3, r2, r3
341919d2:	60fb      	str	r3, [r7, #12]
            break;
341919d4:	e01b      	b.n	34191a0e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341919d6:	f7ff fdc9 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341919da:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
341919dc:	68fa      	ldr	r2, [r7, #12]
341919de:	68bb      	ldr	r3, [r7, #8]
341919e0:	fbb2 f3f3 	udiv	r3, r2, r3
341919e4:	60fb      	str	r3, [r7, #12]
            break;
341919e6:	e012      	b.n	34191a0e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341919e8:	f7ff fe06 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341919ec:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
341919ee:	68fa      	ldr	r2, [r7, #12]
341919f0:	68bb      	ldr	r3, [r7, #8]
341919f2:	fbb2 f3f3 	udiv	r3, r2, r3
341919f6:	60fb      	str	r3, [r7, #12]
            break;
341919f8:	e009      	b.n	34191a0e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341919fa:	f7ff fe43 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341919fe:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34191a00:	68fa      	ldr	r2, [r7, #12]
34191a02:	68bb      	ldr	r3, [r7, #8]
34191a04:	fbb2 f3f3 	udiv	r3, r2, r3
34191a08:	60fb      	str	r3, [r7, #12]
            break;
34191a0a:	e000      	b.n	34191a0e <RCCEx_GetADCCLKFreq+0x102>
            break;
34191a0c:	bf00      	nop
      break;
34191a0e:	e067      	b.n	34191ae0 <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34191a10:	f7fc fad2 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
34191a14:	4603      	mov	r3, r0
34191a16:	2b00      	cmp	r3, #0
34191a18:	d064      	beq.n	34191ae4 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
34191a1a:	f7fc faef 	bl	3418dffc <LL_RCC_IC8_GetDivider>
34191a1e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34191a20:	f7fc fade 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
34191a24:	4603      	mov	r3, r0
34191a26:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191a2a:	d029      	beq.n	34191a80 <RCCEx_GetADCCLKFreq+0x174>
34191a2c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191a30:	d82f      	bhi.n	34191a92 <RCCEx_GetADCCLKFreq+0x186>
34191a32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191a36:	d01a      	beq.n	34191a6e <RCCEx_GetADCCLKFreq+0x162>
34191a38:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191a3c:	d829      	bhi.n	34191a92 <RCCEx_GetADCCLKFreq+0x186>
34191a3e:	2b00      	cmp	r3, #0
34191a40:	d003      	beq.n	34191a4a <RCCEx_GetADCCLKFreq+0x13e>
34191a42:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191a46:	d009      	beq.n	34191a5c <RCCEx_GetADCCLKFreq+0x150>
            break;
34191a48:	e023      	b.n	34191a92 <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191a4a:	f7ff fd49 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191a4e:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34191a50:	68fa      	ldr	r2, [r7, #12]
34191a52:	68bb      	ldr	r3, [r7, #8]
34191a54:	fbb2 f3f3 	udiv	r3, r2, r3
34191a58:	60fb      	str	r3, [r7, #12]
            break;
34191a5a:	e01b      	b.n	34191a94 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191a5c:	f7ff fd86 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191a60:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34191a62:	68fa      	ldr	r2, [r7, #12]
34191a64:	68bb      	ldr	r3, [r7, #8]
34191a66:	fbb2 f3f3 	udiv	r3, r2, r3
34191a6a:	60fb      	str	r3, [r7, #12]
            break;
34191a6c:	e012      	b.n	34191a94 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191a6e:	f7ff fdc3 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191a72:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34191a74:	68fa      	ldr	r2, [r7, #12]
34191a76:	68bb      	ldr	r3, [r7, #8]
34191a78:	fbb2 f3f3 	udiv	r3, r2, r3
34191a7c:	60fb      	str	r3, [r7, #12]
            break;
34191a7e:	e009      	b.n	34191a94 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191a80:	f7ff fe00 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191a84:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34191a86:	68fa      	ldr	r2, [r7, #12]
34191a88:	68bb      	ldr	r3, [r7, #8]
34191a8a:	fbb2 f3f3 	udiv	r3, r2, r3
34191a8e:	60fb      	str	r3, [r7, #12]
            break;
34191a90:	e000      	b.n	34191a94 <RCCEx_GetADCCLKFreq+0x188>
            break;
34191a92:	bf00      	nop
      break;
34191a94:	e026      	b.n	34191ae4 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
34191a96:	f7fb faab 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34191a9a:	4603      	mov	r3, r0
34191a9c:	2b00      	cmp	r3, #0
34191a9e:	d023      	beq.n	34191ae8 <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34191aa0:	f7fb fab8 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34191aa4:	4603      	mov	r3, r0
34191aa6:	09db      	lsrs	r3, r3, #7
34191aa8:	4a16      	ldr	r2, [pc, #88]	@ (34191b04 <RCCEx_GetADCCLKFreq+0x1f8>)
34191aaa:	fa22 f303 	lsr.w	r3, r2, r3
34191aae:	60fb      	str	r3, [r7, #12]
      break;
34191ab0:	e01a      	b.n	34191ae8 <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
34191ab2:	f7fb fabd 	bl	3418d030 <LL_RCC_MSI_IsReady>
34191ab6:	4603      	mov	r3, r0
34191ab8:	2b00      	cmp	r3, #0
34191aba:	d017      	beq.n	34191aec <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
34191abc:	4b12      	ldr	r3, [pc, #72]	@ (34191b08 <RCCEx_GetADCCLKFreq+0x1fc>)
34191abe:	60fb      	str	r3, [r7, #12]
      break;
34191ac0:	e014      	b.n	34191aec <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
34191ac2:	4b12      	ldr	r3, [pc, #72]	@ (34191b0c <RCCEx_GetADCCLKFreq+0x200>)
34191ac4:	60fb      	str	r3, [r7, #12]
      break;
34191ac6:	e012      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34191ac8:	f7fa fe6a 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34191acc:	4604      	mov	r4, r0
34191ace:	f7fb fef7 	bl	3418d8c0 <LL_RCC_GetTIMPrescaler>
34191ad2:	4603      	mov	r3, r0
34191ad4:	fa24 f303 	lsr.w	r3, r4, r3
34191ad8:	60fb      	str	r3, [r7, #12]
      break;
34191ada:	e008      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34191adc:	bf00      	nop
34191ade:	e006      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34191ae0:	bf00      	nop
34191ae2:	e004      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34191ae4:	bf00      	nop
34191ae6:	e002      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34191ae8:	bf00      	nop
34191aea:	e000      	b.n	34191aee <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34191aec:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
34191aee:	f7fb fb4f 	bl	3418d190 <LL_RCC_GetADCPrescaler>
34191af2:	4603      	mov	r3, r0
34191af4:	3301      	adds	r3, #1
34191af6:	68fa      	ldr	r2, [r7, #12]
34191af8:	fbb2 f3f3 	udiv	r3, r2, r3
}
34191afc:	4618      	mov	r0, r3
34191afe:	3714      	adds	r7, #20
34191b00:	46bd      	mov	sp, r7
34191b02:	bd90      	pop	{r4, r7, pc}
34191b04:	03d09000 	.word	0x03d09000
34191b08:	003d0900 	.word	0x003d0900
34191b0c:	00bb8000 	.word	0x00bb8000

34191b10 <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
34191b10:	b590      	push	{r4, r7, lr}
34191b12:	b085      	sub	sp, #20
34191b14:	af00      	add	r7, sp, #0
34191b16:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34191b18:	2300      	movs	r3, #0
34191b1a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34191b1c:	6878      	ldr	r0, [r7, #4]
34191b1e:	f7fb fd2f 	bl	3418d580 <LL_RCC_GetADFClockSource>
34191b22:	4603      	mov	r3, r0
34191b24:	2b07      	cmp	r3, #7
34191b26:	f200 80ca 	bhi.w	34191cbe <RCCEx_GetADFCLKFreq+0x1ae>
34191b2a:	a201      	add	r2, pc, #4	@ (adr r2, 34191b30 <RCCEx_GetADFCLKFreq+0x20>)
34191b2c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34191b30:	34191b51 	.word	0x34191b51
34191b34:	34191b61 	.word	0x34191b61
34191b38:	34191b6b 	.word	0x34191b6b
34191b3c:	34191bf3 	.word	0x34191bf3
34191b40:	34191c95 	.word	0x34191c95
34191b44:	34191c79 	.word	0x34191c79
34191b48:	34191ca5 	.word	0x34191ca5
34191b4c:	34191cab 	.word	0x34191cab
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34191b50:	f7fa fe26 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34191b54:	4603      	mov	r3, r0
34191b56:	4618      	mov	r0, r3
34191b58:	f7ff fdda 	bl	34191710 <RCCEx_GetHCLKFreq>
34191b5c:	60f8      	str	r0, [r7, #12]
      break;
34191b5e:	e0b7      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34191b60:	2007      	movs	r0, #7
34191b62:	f000 f8c1 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34191b66:	60f8      	str	r0, [r7, #12]
      break;
34191b68:	e0b2      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34191b6a:	f7fc f9e5 	bl	3418df38 <LL_RCC_IC7_IsEnabled>
34191b6e:	4603      	mov	r3, r0
34191b70:	2b00      	cmp	r3, #0
34191b72:	f000 80a6 	beq.w	34191cc2 <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34191b76:	f7fc fa01 	bl	3418df7c <LL_RCC_IC7_GetDivider>
34191b7a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34191b7c:	f7fc f9f0 	bl	3418df60 <LL_RCC_IC7_GetSource>
34191b80:	4603      	mov	r3, r0
34191b82:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191b86:	d029      	beq.n	34191bdc <RCCEx_GetADFCLKFreq+0xcc>
34191b88:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191b8c:	d82f      	bhi.n	34191bee <RCCEx_GetADFCLKFreq+0xde>
34191b8e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191b92:	d01a      	beq.n	34191bca <RCCEx_GetADFCLKFreq+0xba>
34191b94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191b98:	d829      	bhi.n	34191bee <RCCEx_GetADFCLKFreq+0xde>
34191b9a:	2b00      	cmp	r3, #0
34191b9c:	d003      	beq.n	34191ba6 <RCCEx_GetADFCLKFreq+0x96>
34191b9e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191ba2:	d009      	beq.n	34191bb8 <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34191ba4:	e023      	b.n	34191bee <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191ba6:	f7ff fc9b 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191baa:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191bac:	68fa      	ldr	r2, [r7, #12]
34191bae:	68bb      	ldr	r3, [r7, #8]
34191bb0:	fbb2 f3f3 	udiv	r3, r2, r3
34191bb4:	60fb      	str	r3, [r7, #12]
            break;
34191bb6:	e01b      	b.n	34191bf0 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191bb8:	f7ff fcd8 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191bbc:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191bbe:	68fa      	ldr	r2, [r7, #12]
34191bc0:	68bb      	ldr	r3, [r7, #8]
34191bc2:	fbb2 f3f3 	udiv	r3, r2, r3
34191bc6:	60fb      	str	r3, [r7, #12]
            break;
34191bc8:	e012      	b.n	34191bf0 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191bca:	f7ff fd15 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191bce:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191bd0:	68fa      	ldr	r2, [r7, #12]
34191bd2:	68bb      	ldr	r3, [r7, #8]
34191bd4:	fbb2 f3f3 	udiv	r3, r2, r3
34191bd8:	60fb      	str	r3, [r7, #12]
            break;
34191bda:	e009      	b.n	34191bf0 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191bdc:	f7ff fd52 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191be0:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191be2:	68fa      	ldr	r2, [r7, #12]
34191be4:	68bb      	ldr	r3, [r7, #8]
34191be6:	fbb2 f3f3 	udiv	r3, r2, r3
34191bea:	60fb      	str	r3, [r7, #12]
            break;
34191bec:	e000      	b.n	34191bf0 <RCCEx_GetADFCLKFreq+0xe0>
            break;
34191bee:	bf00      	nop
        }
      }
      break;
34191bf0:	e067      	b.n	34191cc2 <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34191bf2:	f7fc f9e1 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
34191bf6:	4603      	mov	r3, r0
34191bf8:	2b00      	cmp	r3, #0
34191bfa:	d064      	beq.n	34191cc6 <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34191bfc:	f7fc f9fe 	bl	3418dffc <LL_RCC_IC8_GetDivider>
34191c00:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34191c02:	f7fc f9ed 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
34191c06:	4603      	mov	r3, r0
34191c08:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191c0c:	d029      	beq.n	34191c62 <RCCEx_GetADFCLKFreq+0x152>
34191c0e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191c12:	d82f      	bhi.n	34191c74 <RCCEx_GetADFCLKFreq+0x164>
34191c14:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191c18:	d01a      	beq.n	34191c50 <RCCEx_GetADFCLKFreq+0x140>
34191c1a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191c1e:	d829      	bhi.n	34191c74 <RCCEx_GetADFCLKFreq+0x164>
34191c20:	2b00      	cmp	r3, #0
34191c22:	d003      	beq.n	34191c2c <RCCEx_GetADFCLKFreq+0x11c>
34191c24:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191c28:	d009      	beq.n	34191c3e <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34191c2a:	e023      	b.n	34191c74 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191c2c:	f7ff fc58 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191c30:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191c32:	68fa      	ldr	r2, [r7, #12]
34191c34:	68bb      	ldr	r3, [r7, #8]
34191c36:	fbb2 f3f3 	udiv	r3, r2, r3
34191c3a:	60fb      	str	r3, [r7, #12]
            break;
34191c3c:	e01b      	b.n	34191c76 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191c3e:	f7ff fc95 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191c42:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191c44:	68fa      	ldr	r2, [r7, #12]
34191c46:	68bb      	ldr	r3, [r7, #8]
34191c48:	fbb2 f3f3 	udiv	r3, r2, r3
34191c4c:	60fb      	str	r3, [r7, #12]
            break;
34191c4e:	e012      	b.n	34191c76 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191c50:	f7ff fcd2 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191c54:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191c56:	68fa      	ldr	r2, [r7, #12]
34191c58:	68bb      	ldr	r3, [r7, #8]
34191c5a:	fbb2 f3f3 	udiv	r3, r2, r3
34191c5e:	60fb      	str	r3, [r7, #12]
            break;
34191c60:	e009      	b.n	34191c76 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191c62:	f7ff fd0f 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191c66:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34191c68:	68fa      	ldr	r2, [r7, #12]
34191c6a:	68bb      	ldr	r3, [r7, #8]
34191c6c:	fbb2 f3f3 	udiv	r3, r2, r3
34191c70:	60fb      	str	r3, [r7, #12]
            break;
34191c72:	e000      	b.n	34191c76 <RCCEx_GetADFCLKFreq+0x166>
            break;
34191c74:	bf00      	nop
        }
      }
      break;
34191c76:	e026      	b.n	34191cc6 <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34191c78:	f7fb f9ba 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34191c7c:	4603      	mov	r3, r0
34191c7e:	2b00      	cmp	r3, #0
34191c80:	d023      	beq.n	34191cca <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34191c82:	f7fb f9c7 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34191c86:	4603      	mov	r3, r0
34191c88:	09db      	lsrs	r3, r3, #7
34191c8a:	4a14      	ldr	r2, [pc, #80]	@ (34191cdc <RCCEx_GetADFCLKFreq+0x1cc>)
34191c8c:	fa22 f303 	lsr.w	r3, r2, r3
34191c90:	60fb      	str	r3, [r7, #12]
      }
      break;
34191c92:	e01a      	b.n	34191cca <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34191c94:	f7fb f9cc 	bl	3418d030 <LL_RCC_MSI_IsReady>
34191c98:	4603      	mov	r3, r0
34191c9a:	2b00      	cmp	r3, #0
34191c9c:	d017      	beq.n	34191cce <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
34191c9e:	4b10      	ldr	r3, [pc, #64]	@ (34191ce0 <RCCEx_GetADFCLKFreq+0x1d0>)
34191ca0:	60fb      	str	r3, [r7, #12]
      }
      break;
34191ca2:	e014      	b.n	34191cce <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34191ca4:	4b0f      	ldr	r3, [pc, #60]	@ (34191ce4 <RCCEx_GetADFCLKFreq+0x1d4>)
34191ca6:	60fb      	str	r3, [r7, #12]
      break;
34191ca8:	e012      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34191caa:	f7fa fd79 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34191cae:	4604      	mov	r4, r0
34191cb0:	f7fb fe06 	bl	3418d8c0 <LL_RCC_GetTIMPrescaler>
34191cb4:	4603      	mov	r3, r0
34191cb6:	fa24 f303 	lsr.w	r3, r4, r3
34191cba:	60fb      	str	r3, [r7, #12]
      break;
34191cbc:	e008      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
34191cbe:	bf00      	nop
34191cc0:	e006      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34191cc2:	bf00      	nop
34191cc4:	e004      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34191cc6:	bf00      	nop
34191cc8:	e002      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34191cca:	bf00      	nop
34191ccc:	e000      	b.n	34191cd0 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34191cce:	bf00      	nop
  }

  return adf_frequency;
34191cd0:	68fb      	ldr	r3, [r7, #12]
}
34191cd2:	4618      	mov	r0, r3
34191cd4:	3714      	adds	r7, #20
34191cd6:	46bd      	mov	sp, r7
34191cd8:	bd90      	pop	{r4, r7, pc}
34191cda:	bf00      	nop
34191cdc:	03d09000 	.word	0x03d09000
34191ce0:	003d0900 	.word	0x003d0900
34191ce4:	00bb8000 	.word	0x00bb8000

34191ce8 <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
34191ce8:	b580      	push	{r7, lr}
34191cea:	b084      	sub	sp, #16
34191cec:	af00      	add	r7, sp, #0
34191cee:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34191cf0:	2300      	movs	r3, #0
34191cf2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
34191cf4:	f7fc fc60 	bl	3418e5b8 <LL_RCC_CLKP_IsEnabled>
34191cf8:	4603      	mov	r3, r0
34191cfa:	2b01      	cmp	r3, #1
34191cfc:	f040 81a5 	bne.w	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
34191d00:	6878      	ldr	r0, [r7, #4]
34191d02:	f7fb fc4f 	bl	3418d5a4 <LL_RCC_GetCLKPClockSource>
34191d06:	4603      	mov	r3, r0
34191d08:	2b07      	cmp	r3, #7
34191d0a:	f200 818d 	bhi.w	34192028 <RCCEx_GetCLKPCLKFreq+0x340>
34191d0e:	a201      	add	r2, pc, #4	@ (adr r2, 34191d14 <RCCEx_GetCLKPCLKFreq+0x2c>)
34191d10:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34191d14:	34191d35 	.word	0x34191d35
34191d18:	34191d53 	.word	0x34191d53
34191d1c:	34191d65 	.word	0x34191d65
34191d20:	34191f0f 	.word	0x34191f0f
34191d24:	34191d77 	.word	0x34191d77
34191d28:	34191dff 	.word	0x34191dff
34191d2c:	34191e87 	.word	0x34191e87
34191d30:	34191f97 	.word	0x34191f97
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
34191d34:	f7fb f95c 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34191d38:	4603      	mov	r3, r0
34191d3a:	2b00      	cmp	r3, #0
34191d3c:	f000 8176 	beq.w	3419202c <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34191d40:	f7fb f968 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34191d44:	4603      	mov	r3, r0
34191d46:	09db      	lsrs	r3, r3, #7
34191d48:	4aa1      	ldr	r2, [pc, #644]	@ (34191fd0 <RCCEx_GetCLKPCLKFreq+0x2e8>)
34191d4a:	fa22 f303 	lsr.w	r3, r2, r3
34191d4e:	60fb      	str	r3, [r7, #12]
        }
        break;
34191d50:	e16c      	b.n	3419202c <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
34191d52:	f7fb f96d 	bl	3418d030 <LL_RCC_MSI_IsReady>
34191d56:	4603      	mov	r3, r0
34191d58:	2b00      	cmp	r3, #0
34191d5a:	f000 8169 	beq.w	34192030 <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
34191d5e:	4b9d      	ldr	r3, [pc, #628]	@ (34191fd4 <RCCEx_GetCLKPCLKFreq+0x2ec>)
34191d60:	60fb      	str	r3, [r7, #12]
        }
        break;
34191d62:	e165      	b.n	34192030 <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
34191d64:	f7fb f932 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34191d68:	4603      	mov	r3, r0
34191d6a:	2b00      	cmp	r3, #0
34191d6c:	f000 8162 	beq.w	34192034 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
34191d70:	4b99      	ldr	r3, [pc, #612]	@ (34191fd8 <RCCEx_GetCLKPCLKFreq+0x2f0>)
34191d72:	60fb      	str	r3, [r7, #12]
        }
        break;
34191d74:	e15e      	b.n	34192034 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
34191d76:	f7fc f89f 	bl	3418deb8 <LL_RCC_IC5_IsEnabled>
34191d7a:	4603      	mov	r3, r0
34191d7c:	2b00      	cmp	r3, #0
34191d7e:	f000 815b 	beq.w	34192038 <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
34191d82:	f7fc f8bb 	bl	3418defc <LL_RCC_IC5_GetDivider>
34191d86:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
34191d88:	f7fc f8aa 	bl	3418dee0 <LL_RCC_IC5_GetSource>
34191d8c:	4603      	mov	r3, r0
34191d8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191d92:	d029      	beq.n	34191de8 <RCCEx_GetCLKPCLKFreq+0x100>
34191d94:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191d98:	d82f      	bhi.n	34191dfa <RCCEx_GetCLKPCLKFreq+0x112>
34191d9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191d9e:	d01a      	beq.n	34191dd6 <RCCEx_GetCLKPCLKFreq+0xee>
34191da0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191da4:	d829      	bhi.n	34191dfa <RCCEx_GetCLKPCLKFreq+0x112>
34191da6:	2b00      	cmp	r3, #0
34191da8:	d003      	beq.n	34191db2 <RCCEx_GetCLKPCLKFreq+0xca>
34191daa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191dae:	d009      	beq.n	34191dc4 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34191db0:	e023      	b.n	34191dfa <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191db2:	f7ff fb95 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191db6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191db8:	68fa      	ldr	r2, [r7, #12]
34191dba:	68bb      	ldr	r3, [r7, #8]
34191dbc:	fbb2 f3f3 	udiv	r3, r2, r3
34191dc0:	60fb      	str	r3, [r7, #12]
              break;
34191dc2:	e01b      	b.n	34191dfc <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191dc4:	f7ff fbd2 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191dc8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191dca:	68fa      	ldr	r2, [r7, #12]
34191dcc:	68bb      	ldr	r3, [r7, #8]
34191dce:	fbb2 f3f3 	udiv	r3, r2, r3
34191dd2:	60fb      	str	r3, [r7, #12]
              break;
34191dd4:	e012      	b.n	34191dfc <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191dd6:	f7ff fc0f 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191dda:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191ddc:	68fa      	ldr	r2, [r7, #12]
34191dde:	68bb      	ldr	r3, [r7, #8]
34191de0:	fbb2 f3f3 	udiv	r3, r2, r3
34191de4:	60fb      	str	r3, [r7, #12]
              break;
34191de6:	e009      	b.n	34191dfc <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191de8:	f7ff fc4c 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191dec:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191dee:	68fa      	ldr	r2, [r7, #12]
34191df0:	68bb      	ldr	r3, [r7, #8]
34191df2:	fbb2 f3f3 	udiv	r3, r2, r3
34191df6:	60fb      	str	r3, [r7, #12]
              break;
34191df8:	e000      	b.n	34191dfc <RCCEx_GetCLKPCLKFreq+0x114>
              break;
34191dfa:	bf00      	nop
          }
        }
        break;
34191dfc:	e11c      	b.n	34192038 <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
34191dfe:	f7fc f95b 	bl	3418e0b8 <LL_RCC_IC10_IsEnabled>
34191e02:	4603      	mov	r3, r0
34191e04:	2b00      	cmp	r3, #0
34191e06:	f000 8119 	beq.w	3419203c <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
34191e0a:	f7fc f977 	bl	3418e0fc <LL_RCC_IC10_GetDivider>
34191e0e:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
34191e10:	f7fc f966 	bl	3418e0e0 <LL_RCC_IC10_GetSource>
34191e14:	4603      	mov	r3, r0
34191e16:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191e1a:	d029      	beq.n	34191e70 <RCCEx_GetCLKPCLKFreq+0x188>
34191e1c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191e20:	d82f      	bhi.n	34191e82 <RCCEx_GetCLKPCLKFreq+0x19a>
34191e22:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191e26:	d01a      	beq.n	34191e5e <RCCEx_GetCLKPCLKFreq+0x176>
34191e28:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191e2c:	d829      	bhi.n	34191e82 <RCCEx_GetCLKPCLKFreq+0x19a>
34191e2e:	2b00      	cmp	r3, #0
34191e30:	d003      	beq.n	34191e3a <RCCEx_GetCLKPCLKFreq+0x152>
34191e32:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191e36:	d009      	beq.n	34191e4c <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34191e38:	e023      	b.n	34191e82 <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191e3a:	f7ff fb51 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191e3e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191e40:	68fa      	ldr	r2, [r7, #12]
34191e42:	68bb      	ldr	r3, [r7, #8]
34191e44:	fbb2 f3f3 	udiv	r3, r2, r3
34191e48:	60fb      	str	r3, [r7, #12]
              break;
34191e4a:	e01b      	b.n	34191e84 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191e4c:	f7ff fb8e 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191e50:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191e52:	68fa      	ldr	r2, [r7, #12]
34191e54:	68bb      	ldr	r3, [r7, #8]
34191e56:	fbb2 f3f3 	udiv	r3, r2, r3
34191e5a:	60fb      	str	r3, [r7, #12]
              break;
34191e5c:	e012      	b.n	34191e84 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191e5e:	f7ff fbcb 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191e62:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191e64:	68fa      	ldr	r2, [r7, #12]
34191e66:	68bb      	ldr	r3, [r7, #8]
34191e68:	fbb2 f3f3 	udiv	r3, r2, r3
34191e6c:	60fb      	str	r3, [r7, #12]
              break;
34191e6e:	e009      	b.n	34191e84 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191e70:	f7ff fc08 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191e74:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191e76:	68fa      	ldr	r2, [r7, #12]
34191e78:	68bb      	ldr	r3, [r7, #8]
34191e7a:	fbb2 f3f3 	udiv	r3, r2, r3
34191e7e:	60fb      	str	r3, [r7, #12]
              break;
34191e80:	e000      	b.n	34191e84 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
34191e82:	bf00      	nop
          }
        }
        break;
34191e84:	e0da      	b.n	3419203c <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
34191e86:	f7fc fa17 	bl	3418e2b8 <LL_RCC_IC15_IsEnabled>
34191e8a:	4603      	mov	r3, r0
34191e8c:	2b00      	cmp	r3, #0
34191e8e:	f000 80d7 	beq.w	34192040 <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
34191e92:	f7fc fa33 	bl	3418e2fc <LL_RCC_IC15_GetDivider>
34191e96:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
34191e98:	f7fc fa22 	bl	3418e2e0 <LL_RCC_IC15_GetSource>
34191e9c:	4603      	mov	r3, r0
34191e9e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191ea2:	d029      	beq.n	34191ef8 <RCCEx_GetCLKPCLKFreq+0x210>
34191ea4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191ea8:	d82f      	bhi.n	34191f0a <RCCEx_GetCLKPCLKFreq+0x222>
34191eaa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191eae:	d01a      	beq.n	34191ee6 <RCCEx_GetCLKPCLKFreq+0x1fe>
34191eb0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191eb4:	d829      	bhi.n	34191f0a <RCCEx_GetCLKPCLKFreq+0x222>
34191eb6:	2b00      	cmp	r3, #0
34191eb8:	d003      	beq.n	34191ec2 <RCCEx_GetCLKPCLKFreq+0x1da>
34191eba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191ebe:	d009      	beq.n	34191ed4 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34191ec0:	e023      	b.n	34191f0a <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191ec2:	f7ff fb0d 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191ec6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191ec8:	68fa      	ldr	r2, [r7, #12]
34191eca:	68bb      	ldr	r3, [r7, #8]
34191ecc:	fbb2 f3f3 	udiv	r3, r2, r3
34191ed0:	60fb      	str	r3, [r7, #12]
              break;
34191ed2:	e01b      	b.n	34191f0c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191ed4:	f7ff fb4a 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191ed8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191eda:	68fa      	ldr	r2, [r7, #12]
34191edc:	68bb      	ldr	r3, [r7, #8]
34191ede:	fbb2 f3f3 	udiv	r3, r2, r3
34191ee2:	60fb      	str	r3, [r7, #12]
              break;
34191ee4:	e012      	b.n	34191f0c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191ee6:	f7ff fb87 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191eea:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191eec:	68fa      	ldr	r2, [r7, #12]
34191eee:	68bb      	ldr	r3, [r7, #8]
34191ef0:	fbb2 f3f3 	udiv	r3, r2, r3
34191ef4:	60fb      	str	r3, [r7, #12]
              break;
34191ef6:	e009      	b.n	34191f0c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191ef8:	f7ff fbc4 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191efc:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191efe:	68fa      	ldr	r2, [r7, #12]
34191f00:	68bb      	ldr	r3, [r7, #8]
34191f02:	fbb2 f3f3 	udiv	r3, r2, r3
34191f06:	60fb      	str	r3, [r7, #12]
              break;
34191f08:	e000      	b.n	34191f0c <RCCEx_GetCLKPCLKFreq+0x224>
              break;
34191f0a:	bf00      	nop
          }
        }
        break;
34191f0c:	e098      	b.n	34192040 <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
34191f0e:	f7fc fad3 	bl	3418e4b8 <LL_RCC_IC19_IsEnabled>
34191f12:	4603      	mov	r3, r0
34191f14:	2b00      	cmp	r3, #0
34191f16:	f000 8095 	beq.w	34192044 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
34191f1a:	f7fc faef 	bl	3418e4fc <LL_RCC_IC19_GetDivider>
34191f1e:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
34191f20:	f7fc fade 	bl	3418e4e0 <LL_RCC_IC19_GetSource>
34191f24:	4603      	mov	r3, r0
34191f26:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191f2a:	d029      	beq.n	34191f80 <RCCEx_GetCLKPCLKFreq+0x298>
34191f2c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191f30:	d82f      	bhi.n	34191f92 <RCCEx_GetCLKPCLKFreq+0x2aa>
34191f32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191f36:	d01a      	beq.n	34191f6e <RCCEx_GetCLKPCLKFreq+0x286>
34191f38:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191f3c:	d829      	bhi.n	34191f92 <RCCEx_GetCLKPCLKFreq+0x2aa>
34191f3e:	2b00      	cmp	r3, #0
34191f40:	d003      	beq.n	34191f4a <RCCEx_GetCLKPCLKFreq+0x262>
34191f42:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191f46:	d009      	beq.n	34191f5c <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34191f48:	e023      	b.n	34191f92 <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191f4a:	f7ff fac9 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191f4e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191f50:	68fa      	ldr	r2, [r7, #12]
34191f52:	68bb      	ldr	r3, [r7, #8]
34191f54:	fbb2 f3f3 	udiv	r3, r2, r3
34191f58:	60fb      	str	r3, [r7, #12]
              break;
34191f5a:	e01b      	b.n	34191f94 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191f5c:	f7ff fb06 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191f60:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191f62:	68fa      	ldr	r2, [r7, #12]
34191f64:	68bb      	ldr	r3, [r7, #8]
34191f66:	fbb2 f3f3 	udiv	r3, r2, r3
34191f6a:	60fb      	str	r3, [r7, #12]
              break;
34191f6c:	e012      	b.n	34191f94 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34191f6e:	f7ff fb43 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34191f72:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191f74:	68fa      	ldr	r2, [r7, #12]
34191f76:	68bb      	ldr	r3, [r7, #8]
34191f78:	fbb2 f3f3 	udiv	r3, r2, r3
34191f7c:	60fb      	str	r3, [r7, #12]
              break;
34191f7e:	e009      	b.n	34191f94 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34191f80:	f7ff fb80 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34191f84:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191f86:	68fa      	ldr	r2, [r7, #12]
34191f88:	68bb      	ldr	r3, [r7, #8]
34191f8a:	fbb2 f3f3 	udiv	r3, r2, r3
34191f8e:	60fb      	str	r3, [r7, #12]
              break;
34191f90:	e000      	b.n	34191f94 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
34191f92:	bf00      	nop
          }
        }
        break;
34191f94:	e056      	b.n	34192044 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
34191f96:	f7fc facf 	bl	3418e538 <LL_RCC_IC20_IsEnabled>
34191f9a:	4603      	mov	r3, r0
34191f9c:	2b00      	cmp	r3, #0
34191f9e:	d053      	beq.n	34192048 <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
34191fa0:	f7fc faec 	bl	3418e57c <LL_RCC_IC20_GetDivider>
34191fa4:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
34191fa6:	f7fc fadb 	bl	3418e560 <LL_RCC_IC20_GetSource>
34191faa:	4603      	mov	r3, r0
34191fac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191fb0:	d02f      	beq.n	34192012 <RCCEx_GetCLKPCLKFreq+0x32a>
34191fb2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34191fb6:	d835      	bhi.n	34192024 <RCCEx_GetCLKPCLKFreq+0x33c>
34191fb8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191fbc:	d020      	beq.n	34192000 <RCCEx_GetCLKPCLKFreq+0x318>
34191fbe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34191fc2:	d82f      	bhi.n	34192024 <RCCEx_GetCLKPCLKFreq+0x33c>
34191fc4:	2b00      	cmp	r3, #0
34191fc6:	d009      	beq.n	34191fdc <RCCEx_GetCLKPCLKFreq+0x2f4>
34191fc8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34191fcc:	d00f      	beq.n	34191fee <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34191fce:	e029      	b.n	34192024 <RCCEx_GetCLKPCLKFreq+0x33c>
34191fd0:	03d09000 	.word	0x03d09000
34191fd4:	003d0900 	.word	0x003d0900
34191fd8:	02dc6c00 	.word	0x02dc6c00
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34191fdc:	f7ff fa80 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34191fe0:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191fe2:	68fa      	ldr	r2, [r7, #12]
34191fe4:	68bb      	ldr	r3, [r7, #8]
34191fe6:	fbb2 f3f3 	udiv	r3, r2, r3
34191fea:	60fb      	str	r3, [r7, #12]
              break;
34191fec:	e01b      	b.n	34192026 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34191fee:	f7ff fabd 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34191ff2:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34191ff4:	68fa      	ldr	r2, [r7, #12]
34191ff6:	68bb      	ldr	r3, [r7, #8]
34191ff8:	fbb2 f3f3 	udiv	r3, r2, r3
34191ffc:	60fb      	str	r3, [r7, #12]
              break;
34191ffe:	e012      	b.n	34192026 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192000:	f7ff fafa 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34192004:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34192006:	68fa      	ldr	r2, [r7, #12]
34192008:	68bb      	ldr	r3, [r7, #8]
3419200a:	fbb2 f3f3 	udiv	r3, r2, r3
3419200e:	60fb      	str	r3, [r7, #12]
              break;
34192010:	e009      	b.n	34192026 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192012:	f7ff fb37 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192016:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34192018:	68fa      	ldr	r2, [r7, #12]
3419201a:	68bb      	ldr	r3, [r7, #8]
3419201c:	fbb2 f3f3 	udiv	r3, r2, r3
34192020:	60fb      	str	r3, [r7, #12]
              break;
34192022:	e000      	b.n	34192026 <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
34192024:	bf00      	nop
          }
        }
        break;
34192026:	e00f      	b.n	34192048 <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
34192028:	bf00      	nop
3419202a:	e00e      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3419202c:	bf00      	nop
3419202e:	e00c      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192030:	bf00      	nop
34192032:	e00a      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192034:	bf00      	nop
34192036:	e008      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192038:	bf00      	nop
3419203a:	e006      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3419203c:	bf00      	nop
3419203e:	e004      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192040:	bf00      	nop
34192042:	e002      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192044:	bf00      	nop
34192046:	e000      	b.n	3419204a <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34192048:	bf00      	nop
    }
  }

  return clkp_frequency;
3419204a:	68fb      	ldr	r3, [r7, #12]
}
3419204c:	4618      	mov	r0, r3
3419204e:	3710      	adds	r7, #16
34192050:	46bd      	mov	sp, r7
34192052:	bd80      	pop	{r7, pc}

34192054 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
34192054:	b580      	push	{r7, lr}
34192056:	b082      	sub	sp, #8
34192058:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3419205a:	2300      	movs	r3, #0
3419205c:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
3419205e:	f7fc f9eb 	bl	3418e438 <LL_RCC_IC18_IsEnabled>
34192062:	4603      	mov	r3, r0
34192064:	2b00      	cmp	r3, #0
34192066:	d03c      	beq.n	341920e2 <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
34192068:	f7fc fa08 	bl	3418e47c <LL_RCC_IC18_GetDivider>
3419206c:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
3419206e:	f7fc f9f7 	bl	3418e460 <LL_RCC_IC18_GetSource>
34192072:	4603      	mov	r3, r0
34192074:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192078:	d029      	beq.n	341920ce <RCCEx_GetCSICLKFreq+0x7a>
3419207a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419207e:	d82f      	bhi.n	341920e0 <RCCEx_GetCSICLKFreq+0x8c>
34192080:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192084:	d01a      	beq.n	341920bc <RCCEx_GetCSICLKFreq+0x68>
34192086:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419208a:	d829      	bhi.n	341920e0 <RCCEx_GetCSICLKFreq+0x8c>
3419208c:	2b00      	cmp	r3, #0
3419208e:	d003      	beq.n	34192098 <RCCEx_GetCSICLKFreq+0x44>
34192090:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192094:	d009      	beq.n	341920aa <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
34192096:	e023      	b.n	341920e0 <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192098:	f7ff fa22 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3419209c:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
3419209e:	687a      	ldr	r2, [r7, #4]
341920a0:	683b      	ldr	r3, [r7, #0]
341920a2:	fbb2 f3f3 	udiv	r3, r2, r3
341920a6:	607b      	str	r3, [r7, #4]
        break;
341920a8:	e01b      	b.n	341920e2 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341920aa:	f7ff fa5f 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341920ae:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
341920b0:	687a      	ldr	r2, [r7, #4]
341920b2:	683b      	ldr	r3, [r7, #0]
341920b4:	fbb2 f3f3 	udiv	r3, r2, r3
341920b8:	607b      	str	r3, [r7, #4]
        break;
341920ba:	e012      	b.n	341920e2 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341920bc:	f7ff fa9c 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341920c0:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
341920c2:	687a      	ldr	r2, [r7, #4]
341920c4:	683b      	ldr	r3, [r7, #0]
341920c6:	fbb2 f3f3 	udiv	r3, r2, r3
341920ca:	607b      	str	r3, [r7, #4]
        break;
341920cc:	e009      	b.n	341920e2 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341920ce:	f7ff fad9 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341920d2:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
341920d4:	687a      	ldr	r2, [r7, #4]
341920d6:	683b      	ldr	r3, [r7, #0]
341920d8:	fbb2 f3f3 	udiv	r3, r2, r3
341920dc:	607b      	str	r3, [r7, #4]
        break;
341920de:	e000      	b.n	341920e2 <RCCEx_GetCSICLKFreq+0x8e>
        break;
341920e0:	bf00      	nop
    }
  }

  return clkp_frequency;
341920e2:	687b      	ldr	r3, [r7, #4]
}
341920e4:	4618      	mov	r0, r3
341920e6:	3708      	adds	r7, #8
341920e8:	46bd      	mov	sp, r7
341920ea:	bd80      	pop	{r7, pc}

341920ec <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
341920ec:	b580      	push	{r7, lr}
341920ee:	b084      	sub	sp, #16
341920f0:	af00      	add	r7, sp, #0
341920f2:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
341920f4:	2300      	movs	r3, #0
341920f6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
341920f8:	6878      	ldr	r0, [r7, #4]
341920fa:	f7fb fa65 	bl	3418d5c8 <LL_RCC_GetDCMIPPClockSource>
341920fe:	4603      	mov	r3, r0
34192100:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34192104:	d062      	beq.n	341921cc <RCCEx_GetDCMIPPCLKFreq+0xe0>
34192106:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3419210a:	d86d      	bhi.n	341921e8 <RCCEx_GetDCMIPPCLKFreq+0xfc>
3419210c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34192110:	d019      	beq.n	34192146 <RCCEx_GetDCMIPPCLKFreq+0x5a>
34192112:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34192116:	d867      	bhi.n	341921e8 <RCCEx_GetDCMIPPCLKFreq+0xfc>
34192118:	2b00      	cmp	r3, #0
3419211a:	d003      	beq.n	34192124 <RCCEx_GetDCMIPPCLKFreq+0x38>
3419211c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34192120:	d00c      	beq.n	3419213c <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
34192122:	e061      	b.n	341921e8 <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192124:	f7fa fb3c 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192128:	4603      	mov	r3, r0
3419212a:	4618      	mov	r0, r3
3419212c:	f7ff faf0 	bl	34191710 <RCCEx_GetHCLKFreq>
34192130:	4603      	mov	r3, r0
34192132:	4618      	mov	r0, r3
34192134:	f7ff fb2f 	bl	34191796 <RCCEx_GetPCLK5Freq>
34192138:	60f8      	str	r0, [r7, #12]
      break;
3419213a:	e05a      	b.n	341921f2 <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419213c:	2007      	movs	r0, #7
3419213e:	f7ff fdd3 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192142:	60f8      	str	r0, [r7, #12]
      break;
34192144:	e055      	b.n	341921f2 <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
34192146:	f7fc f937 	bl	3418e3b8 <LL_RCC_IC17_IsEnabled>
3419214a:	4603      	mov	r3, r0
3419214c:	2b00      	cmp	r3, #0
3419214e:	d04d      	beq.n	341921ec <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
34192150:	f7fc f954 	bl	3418e3fc <LL_RCC_IC17_GetDivider>
34192154:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
34192156:	f7fc f943 	bl	3418e3e0 <LL_RCC_IC17_GetSource>
3419215a:	4603      	mov	r3, r0
3419215c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192160:	d029      	beq.n	341921b6 <RCCEx_GetDCMIPPCLKFreq+0xca>
34192162:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192166:	d82f      	bhi.n	341921c8 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34192168:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419216c:	d01a      	beq.n	341921a4 <RCCEx_GetDCMIPPCLKFreq+0xb8>
3419216e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192172:	d829      	bhi.n	341921c8 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34192174:	2b00      	cmp	r3, #0
34192176:	d003      	beq.n	34192180 <RCCEx_GetDCMIPPCLKFreq+0x94>
34192178:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419217c:	d009      	beq.n	34192192 <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
3419217e:	e023      	b.n	341921c8 <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192180:	f7ff f9ae 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192184:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34192186:	68fa      	ldr	r2, [r7, #12]
34192188:	68bb      	ldr	r3, [r7, #8]
3419218a:	fbb2 f3f3 	udiv	r3, r2, r3
3419218e:	60fb      	str	r3, [r7, #12]
            break;
34192190:	e01b      	b.n	341921ca <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192192:	f7ff f9eb 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34192196:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34192198:	68fa      	ldr	r2, [r7, #12]
3419219a:	68bb      	ldr	r3, [r7, #8]
3419219c:	fbb2 f3f3 	udiv	r3, r2, r3
341921a0:	60fb      	str	r3, [r7, #12]
            break;
341921a2:	e012      	b.n	341921ca <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341921a4:	f7ff fa28 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341921a8:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
341921aa:	68fa      	ldr	r2, [r7, #12]
341921ac:	68bb      	ldr	r3, [r7, #8]
341921ae:	fbb2 f3f3 	udiv	r3, r2, r3
341921b2:	60fb      	str	r3, [r7, #12]
            break;
341921b4:	e009      	b.n	341921ca <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341921b6:	f7ff fa65 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341921ba:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
341921bc:	68fa      	ldr	r2, [r7, #12]
341921be:	68bb      	ldr	r3, [r7, #8]
341921c0:	fbb2 f3f3 	udiv	r3, r2, r3
341921c4:	60fb      	str	r3, [r7, #12]
            break;
341921c6:	e000      	b.n	341921ca <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
341921c8:	bf00      	nop
      break;
341921ca:	e00f      	b.n	341921ec <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
341921cc:	f7fa ff10 	bl	3418cff0 <LL_RCC_HSI_IsReady>
341921d0:	4603      	mov	r3, r0
341921d2:	2b00      	cmp	r3, #0
341921d4:	d00c      	beq.n	341921f0 <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341921d6:	f7fa ff1d 	bl	3418d014 <LL_RCC_HSI_GetDivider>
341921da:	4603      	mov	r3, r0
341921dc:	09db      	lsrs	r3, r3, #7
341921de:	4a07      	ldr	r2, [pc, #28]	@ (341921fc <RCCEx_GetDCMIPPCLKFreq+0x110>)
341921e0:	fa22 f303 	lsr.w	r3, r2, r3
341921e4:	60fb      	str	r3, [r7, #12]
      break;
341921e6:	e003      	b.n	341921f0 <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
341921e8:	bf00      	nop
341921ea:	e002      	b.n	341921f2 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
341921ec:	bf00      	nop
341921ee:	e000      	b.n	341921f2 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
341921f0:	bf00      	nop
  }

  return dcmipp_frequency;
341921f2:	68fb      	ldr	r3, [r7, #12]
}
341921f4:	4618      	mov	r0, r3
341921f6:	3710      	adds	r7, #16
341921f8:	46bd      	mov	sp, r7
341921fa:	bd80      	pop	{r7, pc}
341921fc:	03d09000 	.word	0x03d09000

34192200 <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
34192200:	b580      	push	{r7, lr}
34192202:	b084      	sub	sp, #16
34192204:	af00      	add	r7, sp, #0
34192206:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
34192208:	2300      	movs	r3, #0
3419220a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3419220c:	6878      	ldr	r0, [r7, #4]
3419220e:	f7fb f9ed 	bl	3418d5ec <LL_RCC_GetETHClockSource>
34192212:	4603      	mov	r3, r0
34192214:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34192218:	d05e      	beq.n	341922d8 <RCCEx_GetETH1CLKFreq+0xd8>
3419221a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
3419221e:	d863      	bhi.n	341922e8 <RCCEx_GetETH1CLKFreq+0xe8>
34192220:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34192224:	d015      	beq.n	34192252 <RCCEx_GetETH1CLKFreq+0x52>
34192226:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3419222a:	d85d      	bhi.n	341922e8 <RCCEx_GetETH1CLKFreq+0xe8>
3419222c:	2b00      	cmp	r3, #0
3419222e:	d003      	beq.n	34192238 <RCCEx_GetETH1CLKFreq+0x38>
34192230:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34192234:	d008      	beq.n	34192248 <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
34192236:	e057      	b.n	341922e8 <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34192238:	f7fa fab2 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3419223c:	4603      	mov	r3, r0
3419223e:	4618      	mov	r0, r3
34192240:	f7ff fa66 	bl	34191710 <RCCEx_GetHCLKFreq>
34192244:	60f8      	str	r0, [r7, #12]
      break;
34192246:	e054      	b.n	341922f2 <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192248:	2007      	movs	r0, #7
3419224a:	f7ff fd4d 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
3419224e:	60f8      	str	r0, [r7, #12]
      break;
34192250:	e04f      	b.n	341922f2 <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
34192252:	f7fb ff71 	bl	3418e138 <LL_RCC_IC12_IsEnabled>
34192256:	4603      	mov	r3, r0
34192258:	2b00      	cmp	r3, #0
3419225a:	d047      	beq.n	341922ec <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
3419225c:	f7fb ff8e 	bl	3418e17c <LL_RCC_IC12_GetDivider>
34192260:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
34192262:	f7fb ff7d 	bl	3418e160 <LL_RCC_IC12_GetSource>
34192266:	4603      	mov	r3, r0
34192268:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419226c:	d029      	beq.n	341922c2 <RCCEx_GetETH1CLKFreq+0xc2>
3419226e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192272:	d82f      	bhi.n	341922d4 <RCCEx_GetETH1CLKFreq+0xd4>
34192274:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192278:	d01a      	beq.n	341922b0 <RCCEx_GetETH1CLKFreq+0xb0>
3419227a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419227e:	d829      	bhi.n	341922d4 <RCCEx_GetETH1CLKFreq+0xd4>
34192280:	2b00      	cmp	r3, #0
34192282:	d003      	beq.n	3419228c <RCCEx_GetETH1CLKFreq+0x8c>
34192284:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192288:	d009      	beq.n	3419229e <RCCEx_GetETH1CLKFreq+0x9e>
            break;
3419228a:	e023      	b.n	341922d4 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419228c:	f7ff f928 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192290:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34192292:	68fa      	ldr	r2, [r7, #12]
34192294:	68bb      	ldr	r3, [r7, #8]
34192296:	fbb2 f3f3 	udiv	r3, r2, r3
3419229a:	60fb      	str	r3, [r7, #12]
            break;
3419229c:	e01b      	b.n	341922d6 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419229e:	f7ff f965 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341922a2:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
341922a4:	68fa      	ldr	r2, [r7, #12]
341922a6:	68bb      	ldr	r3, [r7, #8]
341922a8:	fbb2 f3f3 	udiv	r3, r2, r3
341922ac:	60fb      	str	r3, [r7, #12]
            break;
341922ae:	e012      	b.n	341922d6 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341922b0:	f7ff f9a2 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341922b4:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
341922b6:	68fa      	ldr	r2, [r7, #12]
341922b8:	68bb      	ldr	r3, [r7, #8]
341922ba:	fbb2 f3f3 	udiv	r3, r2, r3
341922be:	60fb      	str	r3, [r7, #12]
            break;
341922c0:	e009      	b.n	341922d6 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341922c2:	f7ff f9df 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341922c6:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
341922c8:	68fa      	ldr	r2, [r7, #12]
341922ca:	68bb      	ldr	r3, [r7, #8]
341922cc:	fbb2 f3f3 	udiv	r3, r2, r3
341922d0:	60fb      	str	r3, [r7, #12]
            break;
341922d2:	e000      	b.n	341922d6 <RCCEx_GetETH1CLKFreq+0xd6>
            break;
341922d4:	bf00      	nop
      break;
341922d6:	e009      	b.n	341922ec <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
341922d8:	f7fa fe78 	bl	3418cfcc <LL_RCC_HSE_IsReady>
341922dc:	4603      	mov	r3, r0
341922de:	2b00      	cmp	r3, #0
341922e0:	d006      	beq.n	341922f0 <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
341922e2:	4b06      	ldr	r3, [pc, #24]	@ (341922fc <RCCEx_GetETH1CLKFreq+0xfc>)
341922e4:	60fb      	str	r3, [r7, #12]
      break;
341922e6:	e003      	b.n	341922f0 <RCCEx_GetETH1CLKFreq+0xf0>
      break;
341922e8:	bf00      	nop
341922ea:	e002      	b.n	341922f2 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
341922ec:	bf00      	nop
341922ee:	e000      	b.n	341922f2 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
341922f0:	bf00      	nop
  }

  return eth1_frequency;
341922f2:	68fb      	ldr	r3, [r7, #12]
}
341922f4:	4618      	mov	r0, r3
341922f6:	3710      	adds	r7, #16
341922f8:	46bd      	mov	sp, r7
341922fa:	bd80      	pop	{r7, pc}
341922fc:	02dc6c00 	.word	0x02dc6c00

34192300 <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
34192300:	b580      	push	{r7, lr}
34192302:	b084      	sub	sp, #16
34192304:	af00      	add	r7, sp, #0
34192306:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
34192308:	2300      	movs	r3, #0
3419230a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3419230c:	6878      	ldr	r0, [r7, #4]
3419230e:	f7fb f97f 	bl	3418d610 <LL_RCC_GetETHPTPClockSource>
34192312:	4603      	mov	r3, r0
34192314:	2b03      	cmp	r3, #3
34192316:	d863      	bhi.n	341923e0 <RCCEx_GetETH1PTPCLKFreq+0xe0>
34192318:	a201      	add	r2, pc, #4	@ (adr r2, 34192320 <RCCEx_GetETH1PTPCLKFreq+0x20>)
3419231a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419231e:	bf00      	nop
34192320:	34192331 	.word	0x34192331
34192324:	34192341 	.word	0x34192341
34192328:	3419234b 	.word	0x3419234b
3419232c:	341923d1 	.word	0x341923d1
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34192330:	f7fa fa36 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192334:	4603      	mov	r3, r0
34192336:	4618      	mov	r0, r3
34192338:	f7ff f9ea 	bl	34191710 <RCCEx_GetHCLKFreq>
3419233c:	60f8      	str	r0, [r7, #12]
      break;
3419233e:	e054      	b.n	341923ea <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192340:	2007      	movs	r0, #7
34192342:	f7ff fcd1 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192346:	60f8      	str	r0, [r7, #12]
      break;
34192348:	e04f      	b.n	341923ea <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
3419234a:	f7fb ff35 	bl	3418e1b8 <LL_RCC_IC13_IsEnabled>
3419234e:	4603      	mov	r3, r0
34192350:	2b00      	cmp	r3, #0
34192352:	d047      	beq.n	341923e4 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
34192354:	f7fb ff52 	bl	3418e1fc <LL_RCC_IC13_GetDivider>
34192358:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
3419235a:	f7fb ff41 	bl	3418e1e0 <LL_RCC_IC13_GetSource>
3419235e:	4603      	mov	r3, r0
34192360:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192364:	d029      	beq.n	341923ba <RCCEx_GetETH1PTPCLKFreq+0xba>
34192366:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419236a:	d82f      	bhi.n	341923cc <RCCEx_GetETH1PTPCLKFreq+0xcc>
3419236c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192370:	d01a      	beq.n	341923a8 <RCCEx_GetETH1PTPCLKFreq+0xa8>
34192372:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192376:	d829      	bhi.n	341923cc <RCCEx_GetETH1PTPCLKFreq+0xcc>
34192378:	2b00      	cmp	r3, #0
3419237a:	d003      	beq.n	34192384 <RCCEx_GetETH1PTPCLKFreq+0x84>
3419237c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192380:	d009      	beq.n	34192396 <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192382:	e023      	b.n	341923cc <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192384:	f7ff f8ac 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192388:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3419238a:	68fa      	ldr	r2, [r7, #12]
3419238c:	68bb      	ldr	r3, [r7, #8]
3419238e:	fbb2 f3f3 	udiv	r3, r2, r3
34192392:	60fb      	str	r3, [r7, #12]
            break;
34192394:	e01b      	b.n	341923ce <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192396:	f7ff f8e9 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419239a:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3419239c:	68fa      	ldr	r2, [r7, #12]
3419239e:	68bb      	ldr	r3, [r7, #8]
341923a0:	fbb2 f3f3 	udiv	r3, r2, r3
341923a4:	60fb      	str	r3, [r7, #12]
            break;
341923a6:	e012      	b.n	341923ce <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341923a8:	f7ff f926 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341923ac:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
341923ae:	68fa      	ldr	r2, [r7, #12]
341923b0:	68bb      	ldr	r3, [r7, #8]
341923b2:	fbb2 f3f3 	udiv	r3, r2, r3
341923b6:	60fb      	str	r3, [r7, #12]
            break;
341923b8:	e009      	b.n	341923ce <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341923ba:	f7ff f963 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341923be:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
341923c0:	68fa      	ldr	r2, [r7, #12]
341923c2:	68bb      	ldr	r3, [r7, #8]
341923c4:	fbb2 f3f3 	udiv	r3, r2, r3
341923c8:	60fb      	str	r3, [r7, #12]
            break;
341923ca:	e000      	b.n	341923ce <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
341923cc:	bf00      	nop
        }
      }
      break;
341923ce:	e009      	b.n	341923e4 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
341923d0:	f7fa fdfc 	bl	3418cfcc <LL_RCC_HSE_IsReady>
341923d4:	4603      	mov	r3, r0
341923d6:	2b00      	cmp	r3, #0
341923d8:	d006      	beq.n	341923e8 <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
341923da:	4b0a      	ldr	r3, [pc, #40]	@ (34192404 <RCCEx_GetETH1PTPCLKFreq+0x104>)
341923dc:	60fb      	str	r3, [r7, #12]
      }
      break;
341923de:	e003      	b.n	341923e8 <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
341923e0:	bf00      	nop
341923e2:	e002      	b.n	341923ea <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
341923e4:	bf00      	nop
341923e6:	e000      	b.n	341923ea <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
341923e8:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
341923ea:	f7fa ff4d 	bl	3418d288 <LL_RCC_GetETH1PTPDivider>
341923ee:	4603      	mov	r3, r0
341923f0:	091b      	lsrs	r3, r3, #4
341923f2:	3301      	adds	r3, #1
341923f4:	68fa      	ldr	r2, [r7, #12]
341923f6:	fbb2 f3f3 	udiv	r3, r2, r3
}
341923fa:	4618      	mov	r0, r3
341923fc:	3710      	adds	r7, #16
341923fe:	46bd      	mov	sp, r7
34192400:	bd80      	pop	{r7, pc}
34192402:	bf00      	nop
34192404:	02dc6c00 	.word	0x02dc6c00

34192408 <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
34192408:	b580      	push	{r7, lr}
3419240a:	b084      	sub	sp, #16
3419240c:	af00      	add	r7, sp, #0
3419240e:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
34192410:	2300      	movs	r3, #0
34192412:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
34192414:	6878      	ldr	r0, [r7, #4]
34192416:	f7fb f90d 	bl	3418d634 <LL_RCC_GetFDCANClockSource>
3419241a:	4603      	mov	r3, r0
3419241c:	2b03      	cmp	r3, #3
3419241e:	d867      	bhi.n	341924f0 <RCCEx_GetFDCANCLKFreq+0xe8>
34192420:	a201      	add	r2, pc, #4	@ (adr r2, 34192428 <RCCEx_GetFDCANCLKFreq+0x20>)
34192422:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34192426:	bf00      	nop
34192428:	34192439 	.word	0x34192439
3419242c:	34192451 	.word	0x34192451
34192430:	3419245b 	.word	0x3419245b
34192434:	341924e1 	.word	0x341924e1
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192438:	f7fa f9b2 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3419243c:	4603      	mov	r3, r0
3419243e:	4618      	mov	r0, r3
34192440:	f7ff f966 	bl	34191710 <RCCEx_GetHCLKFreq>
34192444:	4603      	mov	r3, r0
34192446:	4618      	mov	r0, r3
34192448:	f7ff f973 	bl	34191732 <RCCEx_GetPCLK1Freq>
3419244c:	60f8      	str	r0, [r7, #12]
      break;
3419244e:	e054      	b.n	341924fa <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192450:	2007      	movs	r0, #7
34192452:	f7ff fc49 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192456:	60f8      	str	r0, [r7, #12]
      break;
34192458:	e04f      	b.n	341924fa <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
3419245a:	f7fc f82d 	bl	3418e4b8 <LL_RCC_IC19_IsEnabled>
3419245e:	4603      	mov	r3, r0
34192460:	2b00      	cmp	r3, #0
34192462:	d047      	beq.n	341924f4 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
34192464:	f7fc f84a 	bl	3418e4fc <LL_RCC_IC19_GetDivider>
34192468:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
3419246a:	f7fc f839 	bl	3418e4e0 <LL_RCC_IC19_GetSource>
3419246e:	4603      	mov	r3, r0
34192470:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192474:	d029      	beq.n	341924ca <RCCEx_GetFDCANCLKFreq+0xc2>
34192476:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419247a:	d82f      	bhi.n	341924dc <RCCEx_GetFDCANCLKFreq+0xd4>
3419247c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192480:	d01a      	beq.n	341924b8 <RCCEx_GetFDCANCLKFreq+0xb0>
34192482:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192486:	d829      	bhi.n	341924dc <RCCEx_GetFDCANCLKFreq+0xd4>
34192488:	2b00      	cmp	r3, #0
3419248a:	d003      	beq.n	34192494 <RCCEx_GetFDCANCLKFreq+0x8c>
3419248c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192490:	d009      	beq.n	341924a6 <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192492:	e023      	b.n	341924dc <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192494:	f7ff f824 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192498:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3419249a:	68fa      	ldr	r2, [r7, #12]
3419249c:	68bb      	ldr	r3, [r7, #8]
3419249e:	fbb2 f3f3 	udiv	r3, r2, r3
341924a2:	60fb      	str	r3, [r7, #12]
            break;
341924a4:	e01b      	b.n	341924de <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341924a6:	f7ff f861 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341924aa:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
341924ac:	68fa      	ldr	r2, [r7, #12]
341924ae:	68bb      	ldr	r3, [r7, #8]
341924b0:	fbb2 f3f3 	udiv	r3, r2, r3
341924b4:	60fb      	str	r3, [r7, #12]
            break;
341924b6:	e012      	b.n	341924de <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341924b8:	f7ff f89e 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341924bc:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
341924be:	68fa      	ldr	r2, [r7, #12]
341924c0:	68bb      	ldr	r3, [r7, #8]
341924c2:	fbb2 f3f3 	udiv	r3, r2, r3
341924c6:	60fb      	str	r3, [r7, #12]
            break;
341924c8:	e009      	b.n	341924de <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341924ca:	f7ff f8db 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341924ce:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
341924d0:	68fa      	ldr	r2, [r7, #12]
341924d2:	68bb      	ldr	r3, [r7, #8]
341924d4:	fbb2 f3f3 	udiv	r3, r2, r3
341924d8:	60fb      	str	r3, [r7, #12]
            break;
341924da:	e000      	b.n	341924de <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
341924dc:	bf00      	nop
        }
      }
      break;
341924de:	e009      	b.n	341924f4 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
341924e0:	f7fa fd74 	bl	3418cfcc <LL_RCC_HSE_IsReady>
341924e4:	4603      	mov	r3, r0
341924e6:	2b00      	cmp	r3, #0
341924e8:	d006      	beq.n	341924f8 <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
341924ea:	4b06      	ldr	r3, [pc, #24]	@ (34192504 <RCCEx_GetFDCANCLKFreq+0xfc>)
341924ec:	60fb      	str	r3, [r7, #12]
      }
      break;
341924ee:	e003      	b.n	341924f8 <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
341924f0:	bf00      	nop
341924f2:	e002      	b.n	341924fa <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
341924f4:	bf00      	nop
341924f6:	e000      	b.n	341924fa <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
341924f8:	bf00      	nop
  }

  return fdcan_frequency;
341924fa:	68fb      	ldr	r3, [r7, #12]
}
341924fc:	4618      	mov	r0, r3
341924fe:	3710      	adds	r7, #16
34192500:	46bd      	mov	sp, r7
34192502:	bd80      	pop	{r7, pc}
34192504:	02dc6c00 	.word	0x02dc6c00

34192508 <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
34192508:	b580      	push	{r7, lr}
3419250a:	b084      	sub	sp, #16
3419250c:	af00      	add	r7, sp, #0
3419250e:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34192510:	2300      	movs	r3, #0
34192512:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
34192514:	6878      	ldr	r0, [r7, #4]
34192516:	f7fb f89f 	bl	3418d658 <LL_RCC_GetFMCClockSource>
3419251a:	4603      	mov	r3, r0
3419251c:	2b30      	cmp	r3, #48	@ 0x30
3419251e:	d05d      	beq.n	341925dc <RCCEx_GetFMCCLKFreq+0xd4>
34192520:	2b30      	cmp	r3, #48	@ 0x30
34192522:	f200 809e 	bhi.w	34192662 <RCCEx_GetFMCCLKFreq+0x15a>
34192526:	2b20      	cmp	r3, #32
34192528:	d014      	beq.n	34192554 <RCCEx_GetFMCCLKFreq+0x4c>
3419252a:	2b20      	cmp	r3, #32
3419252c:	f200 8099 	bhi.w	34192662 <RCCEx_GetFMCCLKFreq+0x15a>
34192530:	2b00      	cmp	r3, #0
34192532:	d002      	beq.n	3419253a <RCCEx_GetFMCCLKFreq+0x32>
34192534:	2b10      	cmp	r3, #16
34192536:	d008      	beq.n	3419254a <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
34192538:	e093      	b.n	34192662 <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3419253a:	f7fa f931 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3419253e:	4603      	mov	r3, r0
34192540:	4618      	mov	r0, r3
34192542:	f7ff f8e5 	bl	34191710 <RCCEx_GetHCLKFreq>
34192546:	60f8      	str	r0, [r7, #12]
      break;
34192548:	e090      	b.n	3419266c <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419254a:	2007      	movs	r0, #7
3419254c:	f7ff fbcc 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192550:	60f8      	str	r0, [r7, #12]
      break;
34192552:	e08b      	b.n	3419266c <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
34192554:	f7fb fc30 	bl	3418ddb8 <LL_RCC_IC3_IsEnabled>
34192558:	4603      	mov	r3, r0
3419255a:	2b00      	cmp	r3, #0
3419255c:	f000 8083 	beq.w	34192666 <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
34192560:	f7fb fc4c 	bl	3418ddfc <LL_RCC_IC3_GetDivider>
34192564:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34192566:	f7fb fc3b 	bl	3418dde0 <LL_RCC_IC3_GetSource>
3419256a:	4603      	mov	r3, r0
3419256c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192570:	d029      	beq.n	341925c6 <RCCEx_GetFMCCLKFreq+0xbe>
34192572:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192576:	d82f      	bhi.n	341925d8 <RCCEx_GetFMCCLKFreq+0xd0>
34192578:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419257c:	d01a      	beq.n	341925b4 <RCCEx_GetFMCCLKFreq+0xac>
3419257e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192582:	d829      	bhi.n	341925d8 <RCCEx_GetFMCCLKFreq+0xd0>
34192584:	2b00      	cmp	r3, #0
34192586:	d003      	beq.n	34192590 <RCCEx_GetFMCCLKFreq+0x88>
34192588:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419258c:	d009      	beq.n	341925a2 <RCCEx_GetFMCCLKFreq+0x9a>
            break;
3419258e:	e023      	b.n	341925d8 <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192590:	f7fe ffa6 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192594:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34192596:	68fa      	ldr	r2, [r7, #12]
34192598:	68bb      	ldr	r3, [r7, #8]
3419259a:	fbb2 f3f3 	udiv	r3, r2, r3
3419259e:	60fb      	str	r3, [r7, #12]
            break;
341925a0:	e01b      	b.n	341925da <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341925a2:	f7fe ffe3 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341925a6:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341925a8:	68fa      	ldr	r2, [r7, #12]
341925aa:	68bb      	ldr	r3, [r7, #8]
341925ac:	fbb2 f3f3 	udiv	r3, r2, r3
341925b0:	60fb      	str	r3, [r7, #12]
            break;
341925b2:	e012      	b.n	341925da <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341925b4:	f7ff f820 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341925b8:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341925ba:	68fa      	ldr	r2, [r7, #12]
341925bc:	68bb      	ldr	r3, [r7, #8]
341925be:	fbb2 f3f3 	udiv	r3, r2, r3
341925c2:	60fb      	str	r3, [r7, #12]
            break;
341925c4:	e009      	b.n	341925da <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341925c6:	f7ff f85d 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341925ca:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341925cc:	68fa      	ldr	r2, [r7, #12]
341925ce:	68bb      	ldr	r3, [r7, #8]
341925d0:	fbb2 f3f3 	udiv	r3, r2, r3
341925d4:	60fb      	str	r3, [r7, #12]
            break;
341925d6:	e000      	b.n	341925da <RCCEx_GetFMCCLKFreq+0xd2>
            break;
341925d8:	bf00      	nop
      break;
341925da:	e044      	b.n	34192666 <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
341925dc:	f7fb fc2c 	bl	3418de38 <LL_RCC_IC4_IsEnabled>
341925e0:	4603      	mov	r3, r0
341925e2:	2b00      	cmp	r3, #0
341925e4:	d041      	beq.n	3419266a <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
341925e6:	f7fb fc49 	bl	3418de7c <LL_RCC_IC4_GetDivider>
341925ea:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
341925ec:	f7fb fc38 	bl	3418de60 <LL_RCC_IC4_GetSource>
341925f0:	4603      	mov	r3, r0
341925f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341925f6:	d029      	beq.n	3419264c <RCCEx_GetFMCCLKFreq+0x144>
341925f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341925fc:	d82f      	bhi.n	3419265e <RCCEx_GetFMCCLKFreq+0x156>
341925fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192602:	d01a      	beq.n	3419263a <RCCEx_GetFMCCLKFreq+0x132>
34192604:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192608:	d829      	bhi.n	3419265e <RCCEx_GetFMCCLKFreq+0x156>
3419260a:	2b00      	cmp	r3, #0
3419260c:	d003      	beq.n	34192616 <RCCEx_GetFMCCLKFreq+0x10e>
3419260e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192612:	d009      	beq.n	34192628 <RCCEx_GetFMCCLKFreq+0x120>
            break;
34192614:	e023      	b.n	3419265e <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192616:	f7fe ff63 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3419261a:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3419261c:	68fa      	ldr	r2, [r7, #12]
3419261e:	68bb      	ldr	r3, [r7, #8]
34192620:	fbb2 f3f3 	udiv	r3, r2, r3
34192624:	60fb      	str	r3, [r7, #12]
            break;
34192626:	e01b      	b.n	34192660 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192628:	f7fe ffa0 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419262c:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3419262e:	68fa      	ldr	r2, [r7, #12]
34192630:	68bb      	ldr	r3, [r7, #8]
34192632:	fbb2 f3f3 	udiv	r3, r2, r3
34192636:	60fb      	str	r3, [r7, #12]
            break;
34192638:	e012      	b.n	34192660 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3419263a:	f7fe ffdd 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419263e:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34192640:	68fa      	ldr	r2, [r7, #12]
34192642:	68bb      	ldr	r3, [r7, #8]
34192644:	fbb2 f3f3 	udiv	r3, r2, r3
34192648:	60fb      	str	r3, [r7, #12]
            break;
3419264a:	e009      	b.n	34192660 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419264c:	f7ff f81a 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192650:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34192652:	68fa      	ldr	r2, [r7, #12]
34192654:	68bb      	ldr	r3, [r7, #8]
34192656:	fbb2 f3f3 	udiv	r3, r2, r3
3419265a:	60fb      	str	r3, [r7, #12]
            break;
3419265c:	e000      	b.n	34192660 <RCCEx_GetFMCCLKFreq+0x158>
            break;
3419265e:	bf00      	nop
      break;
34192660:	e003      	b.n	3419266a <RCCEx_GetFMCCLKFreq+0x162>
      break;
34192662:	bf00      	nop
34192664:	e002      	b.n	3419266c <RCCEx_GetFMCCLKFreq+0x164>
      break;
34192666:	bf00      	nop
34192668:	e000      	b.n	3419266c <RCCEx_GetFMCCLKFreq+0x164>
      break;
3419266a:	bf00      	nop
  }

  return fmc_frequency;
3419266c:	68fb      	ldr	r3, [r7, #12]
}
3419266e:	4618      	mov	r0, r3
34192670:	3710      	adds	r7, #16
34192672:	46bd      	mov	sp, r7
34192674:	bd80      	pop	{r7, pc}
	...

34192678 <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
34192678:	b580      	push	{r7, lr}
3419267a:	b084      	sub	sp, #16
3419267c:	af00      	add	r7, sp, #0
3419267e:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34192680:	2300      	movs	r3, #0
34192682:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34192684:	6878      	ldr	r0, [r7, #4]
34192686:	f7fa fff9 	bl	3418d67c <LL_RCC_GetI2CClockSource>
3419268a:	4603      	mov	r3, r0
3419268c:	4aa2      	ldr	r2, [pc, #648]	@ (34192918 <RCCEx_GetI2CCLKFreq+0x2a0>)
3419268e:	4293      	cmp	r3, r2
34192690:	f000 8172 	beq.w	34192978 <RCCEx_GetI2CCLKFreq+0x300>
34192694:	4aa0      	ldr	r2, [pc, #640]	@ (34192918 <RCCEx_GetI2CCLKFreq+0x2a0>)
34192696:	4293      	cmp	r3, r2
34192698:	f200 8184 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419269c:	4a9f      	ldr	r2, [pc, #636]	@ (3419291c <RCCEx_GetI2CCLKFreq+0x2a4>)
3419269e:	4293      	cmp	r3, r2
341926a0:	f000 816a 	beq.w	34192978 <RCCEx_GetI2CCLKFreq+0x300>
341926a4:	4a9d      	ldr	r2, [pc, #628]	@ (3419291c <RCCEx_GetI2CCLKFreq+0x2a4>)
341926a6:	4293      	cmp	r3, r2
341926a8:	f200 817c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926ac:	4a9c      	ldr	r2, [pc, #624]	@ (34192920 <RCCEx_GetI2CCLKFreq+0x2a8>)
341926ae:	4293      	cmp	r3, r2
341926b0:	f000 8162 	beq.w	34192978 <RCCEx_GetI2CCLKFreq+0x300>
341926b4:	4a9a      	ldr	r2, [pc, #616]	@ (34192920 <RCCEx_GetI2CCLKFreq+0x2a8>)
341926b6:	4293      	cmp	r3, r2
341926b8:	f200 8174 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926bc:	4a99      	ldr	r2, [pc, #612]	@ (34192924 <RCCEx_GetI2CCLKFreq+0x2ac>)
341926be:	4293      	cmp	r3, r2
341926c0:	f000 815a 	beq.w	34192978 <RCCEx_GetI2CCLKFreq+0x300>
341926c4:	4a97      	ldr	r2, [pc, #604]	@ (34192924 <RCCEx_GetI2CCLKFreq+0x2ac>)
341926c6:	4293      	cmp	r3, r2
341926c8:	f200 816c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926cc:	4a96      	ldr	r2, [pc, #600]	@ (34192928 <RCCEx_GetI2CCLKFreq+0x2b0>)
341926ce:	4293      	cmp	r3, r2
341926d0:	f000 8160 	beq.w	34192994 <RCCEx_GetI2CCLKFreq+0x31c>
341926d4:	4a94      	ldr	r2, [pc, #592]	@ (34192928 <RCCEx_GetI2CCLKFreq+0x2b0>)
341926d6:	4293      	cmp	r3, r2
341926d8:	f200 8164 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926dc:	4a93      	ldr	r2, [pc, #588]	@ (3419292c <RCCEx_GetI2CCLKFreq+0x2b4>)
341926de:	4293      	cmp	r3, r2
341926e0:	f000 8158 	beq.w	34192994 <RCCEx_GetI2CCLKFreq+0x31c>
341926e4:	4a91      	ldr	r2, [pc, #580]	@ (3419292c <RCCEx_GetI2CCLKFreq+0x2b4>)
341926e6:	4293      	cmp	r3, r2
341926e8:	f200 815c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926ec:	4a90      	ldr	r2, [pc, #576]	@ (34192930 <RCCEx_GetI2CCLKFreq+0x2b8>)
341926ee:	4293      	cmp	r3, r2
341926f0:	f000 8150 	beq.w	34192994 <RCCEx_GetI2CCLKFreq+0x31c>
341926f4:	4a8e      	ldr	r2, [pc, #568]	@ (34192930 <RCCEx_GetI2CCLKFreq+0x2b8>)
341926f6:	4293      	cmp	r3, r2
341926f8:	f200 8154 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341926fc:	4a8d      	ldr	r2, [pc, #564]	@ (34192934 <RCCEx_GetI2CCLKFreq+0x2bc>)
341926fe:	4293      	cmp	r3, r2
34192700:	f000 8148 	beq.w	34192994 <RCCEx_GetI2CCLKFreq+0x31c>
34192704:	4a8b      	ldr	r2, [pc, #556]	@ (34192934 <RCCEx_GetI2CCLKFreq+0x2bc>)
34192706:	4293      	cmp	r3, r2
34192708:	f200 814c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419270c:	4a8a      	ldr	r2, [pc, #552]	@ (34192938 <RCCEx_GetI2CCLKFreq+0x2c0>)
3419270e:	4293      	cmp	r3, r2
34192710:	f000 80be 	beq.w	34192890 <RCCEx_GetI2CCLKFreq+0x218>
34192714:	4a88      	ldr	r2, [pc, #544]	@ (34192938 <RCCEx_GetI2CCLKFreq+0x2c0>)
34192716:	4293      	cmp	r3, r2
34192718:	f200 8144 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419271c:	4a87      	ldr	r2, [pc, #540]	@ (3419293c <RCCEx_GetI2CCLKFreq+0x2c4>)
3419271e:	4293      	cmp	r3, r2
34192720:	f000 80b6 	beq.w	34192890 <RCCEx_GetI2CCLKFreq+0x218>
34192724:	4a85      	ldr	r2, [pc, #532]	@ (3419293c <RCCEx_GetI2CCLKFreq+0x2c4>)
34192726:	4293      	cmp	r3, r2
34192728:	f200 813c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419272c:	4a84      	ldr	r2, [pc, #528]	@ (34192940 <RCCEx_GetI2CCLKFreq+0x2c8>)
3419272e:	4293      	cmp	r3, r2
34192730:	f000 80ae 	beq.w	34192890 <RCCEx_GetI2CCLKFreq+0x218>
34192734:	4a82      	ldr	r2, [pc, #520]	@ (34192940 <RCCEx_GetI2CCLKFreq+0x2c8>)
34192736:	4293      	cmp	r3, r2
34192738:	f200 8134 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419273c:	4a81      	ldr	r2, [pc, #516]	@ (34192944 <RCCEx_GetI2CCLKFreq+0x2cc>)
3419273e:	4293      	cmp	r3, r2
34192740:	f000 80a6 	beq.w	34192890 <RCCEx_GetI2CCLKFreq+0x218>
34192744:	4a7f      	ldr	r2, [pc, #508]	@ (34192944 <RCCEx_GetI2CCLKFreq+0x2cc>)
34192746:	4293      	cmp	r3, r2
34192748:	f200 812c 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419274c:	4a7e      	ldr	r2, [pc, #504]	@ (34192948 <RCCEx_GetI2CCLKFreq+0x2d0>)
3419274e:	4293      	cmp	r3, r2
34192750:	d05a      	beq.n	34192808 <RCCEx_GetI2CCLKFreq+0x190>
34192752:	4a7d      	ldr	r2, [pc, #500]	@ (34192948 <RCCEx_GetI2CCLKFreq+0x2d0>)
34192754:	4293      	cmp	r3, r2
34192756:	f200 8125 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
3419275a:	4a7c      	ldr	r2, [pc, #496]	@ (3419294c <RCCEx_GetI2CCLKFreq+0x2d4>)
3419275c:	4293      	cmp	r3, r2
3419275e:	d053      	beq.n	34192808 <RCCEx_GetI2CCLKFreq+0x190>
34192760:	4a7a      	ldr	r2, [pc, #488]	@ (3419294c <RCCEx_GetI2CCLKFreq+0x2d4>)
34192762:	4293      	cmp	r3, r2
34192764:	f200 811e 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
34192768:	4a79      	ldr	r2, [pc, #484]	@ (34192950 <RCCEx_GetI2CCLKFreq+0x2d8>)
3419276a:	4293      	cmp	r3, r2
3419276c:	d04c      	beq.n	34192808 <RCCEx_GetI2CCLKFreq+0x190>
3419276e:	4a78      	ldr	r2, [pc, #480]	@ (34192950 <RCCEx_GetI2CCLKFreq+0x2d8>)
34192770:	4293      	cmp	r3, r2
34192772:	f200 8117 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
34192776:	4a77      	ldr	r2, [pc, #476]	@ (34192954 <RCCEx_GetI2CCLKFreq+0x2dc>)
34192778:	4293      	cmp	r3, r2
3419277a:	d045      	beq.n	34192808 <RCCEx_GetI2CCLKFreq+0x190>
3419277c:	4a75      	ldr	r2, [pc, #468]	@ (34192954 <RCCEx_GetI2CCLKFreq+0x2dc>)
3419277e:	4293      	cmp	r3, r2
34192780:	f200 8110 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
34192784:	4a74      	ldr	r2, [pc, #464]	@ (34192958 <RCCEx_GetI2CCLKFreq+0x2e0>)
34192786:	4293      	cmp	r3, r2
34192788:	d039      	beq.n	341927fe <RCCEx_GetI2CCLKFreq+0x186>
3419278a:	4a73      	ldr	r2, [pc, #460]	@ (34192958 <RCCEx_GetI2CCLKFreq+0x2e0>)
3419278c:	4293      	cmp	r3, r2
3419278e:	f200 8109 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
34192792:	4a72      	ldr	r2, [pc, #456]	@ (3419295c <RCCEx_GetI2CCLKFreq+0x2e4>)
34192794:	4293      	cmp	r3, r2
34192796:	d032      	beq.n	341927fe <RCCEx_GetI2CCLKFreq+0x186>
34192798:	4a70      	ldr	r2, [pc, #448]	@ (3419295c <RCCEx_GetI2CCLKFreq+0x2e4>)
3419279a:	4293      	cmp	r3, r2
3419279c:	f200 8102 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341927a0:	4a6f      	ldr	r2, [pc, #444]	@ (34192960 <RCCEx_GetI2CCLKFreq+0x2e8>)
341927a2:	4293      	cmp	r3, r2
341927a4:	d02b      	beq.n	341927fe <RCCEx_GetI2CCLKFreq+0x186>
341927a6:	4a6e      	ldr	r2, [pc, #440]	@ (34192960 <RCCEx_GetI2CCLKFreq+0x2e8>)
341927a8:	4293      	cmp	r3, r2
341927aa:	f200 80fb 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341927ae:	4a6d      	ldr	r2, [pc, #436]	@ (34192964 <RCCEx_GetI2CCLKFreq+0x2ec>)
341927b0:	4293      	cmp	r3, r2
341927b2:	d024      	beq.n	341927fe <RCCEx_GetI2CCLKFreq+0x186>
341927b4:	4a6b      	ldr	r2, [pc, #428]	@ (34192964 <RCCEx_GetI2CCLKFreq+0x2ec>)
341927b6:	4293      	cmp	r3, r2
341927b8:	f200 80f4 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341927bc:	4a6a      	ldr	r2, [pc, #424]	@ (34192968 <RCCEx_GetI2CCLKFreq+0x2f0>)
341927be:	4293      	cmp	r3, r2
341927c0:	d011      	beq.n	341927e6 <RCCEx_GetI2CCLKFreq+0x16e>
341927c2:	4a69      	ldr	r2, [pc, #420]	@ (34192968 <RCCEx_GetI2CCLKFreq+0x2f0>)
341927c4:	4293      	cmp	r3, r2
341927c6:	f200 80ed 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341927ca:	4a68      	ldr	r2, [pc, #416]	@ (3419296c <RCCEx_GetI2CCLKFreq+0x2f4>)
341927cc:	4293      	cmp	r3, r2
341927ce:	d00a      	beq.n	341927e6 <RCCEx_GetI2CCLKFreq+0x16e>
341927d0:	4a66      	ldr	r2, [pc, #408]	@ (3419296c <RCCEx_GetI2CCLKFreq+0x2f4>)
341927d2:	4293      	cmp	r3, r2
341927d4:	f200 80e6 	bhi.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
341927d8:	4a65      	ldr	r2, [pc, #404]	@ (34192970 <RCCEx_GetI2CCLKFreq+0x2f8>)
341927da:	4293      	cmp	r3, r2
341927dc:	d003      	beq.n	341927e6 <RCCEx_GetI2CCLKFreq+0x16e>
341927de:	4a65      	ldr	r2, [pc, #404]	@ (34192974 <RCCEx_GetI2CCLKFreq+0x2fc>)
341927e0:	4293      	cmp	r3, r2
341927e2:	f040 80df 	bne.w	341929a4 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341927e6:	f7f9 ffdb 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
341927ea:	4603      	mov	r3, r0
341927ec:	4618      	mov	r0, r3
341927ee:	f7fe ff8f 	bl	34191710 <RCCEx_GetHCLKFreq>
341927f2:	4603      	mov	r3, r0
341927f4:	4618      	mov	r0, r3
341927f6:	f7fe ff9c 	bl	34191732 <RCCEx_GetPCLK1Freq>
341927fa:	60f8      	str	r0, [r7, #12]
      break;
341927fc:	e0db      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341927fe:	2007      	movs	r0, #7
34192800:	f7ff fa72 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192804:	60f8      	str	r0, [r7, #12]
      break;
34192806:	e0d6      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34192808:	f7fb fc56 	bl	3418e0b8 <LL_RCC_IC10_IsEnabled>
3419280c:	4603      	mov	r3, r0
3419280e:	2b00      	cmp	r3, #0
34192810:	f000 80ca 	beq.w	341929a8 <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34192814:	f7fb fc72 	bl	3418e0fc <LL_RCC_IC10_GetDivider>
34192818:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
3419281a:	f7fb fc61 	bl	3418e0e0 <LL_RCC_IC10_GetSource>
3419281e:	4603      	mov	r3, r0
34192820:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192824:	d029      	beq.n	3419287a <RCCEx_GetI2CCLKFreq+0x202>
34192826:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419282a:	d82f      	bhi.n	3419288c <RCCEx_GetI2CCLKFreq+0x214>
3419282c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192830:	d01a      	beq.n	34192868 <RCCEx_GetI2CCLKFreq+0x1f0>
34192832:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192836:	d829      	bhi.n	3419288c <RCCEx_GetI2CCLKFreq+0x214>
34192838:	2b00      	cmp	r3, #0
3419283a:	d003      	beq.n	34192844 <RCCEx_GetI2CCLKFreq+0x1cc>
3419283c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192840:	d009      	beq.n	34192856 <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192842:	e023      	b.n	3419288c <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192844:	f7fe fe4c 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192848:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3419284a:	68fa      	ldr	r2, [r7, #12]
3419284c:	68bb      	ldr	r3, [r7, #8]
3419284e:	fbb2 f3f3 	udiv	r3, r2, r3
34192852:	60fb      	str	r3, [r7, #12]
            break;
34192854:	e01b      	b.n	3419288e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192856:	f7fe fe89 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419285a:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3419285c:	68fa      	ldr	r2, [r7, #12]
3419285e:	68bb      	ldr	r3, [r7, #8]
34192860:	fbb2 f3f3 	udiv	r3, r2, r3
34192864:	60fb      	str	r3, [r7, #12]
            break;
34192866:	e012      	b.n	3419288e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192868:	f7fe fec6 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419286c:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3419286e:	68fa      	ldr	r2, [r7, #12]
34192870:	68bb      	ldr	r3, [r7, #8]
34192872:	fbb2 f3f3 	udiv	r3, r2, r3
34192876:	60fb      	str	r3, [r7, #12]
            break;
34192878:	e009      	b.n	3419288e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419287a:	f7fe ff03 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419287e:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34192880:	68fa      	ldr	r2, [r7, #12]
34192882:	68bb      	ldr	r3, [r7, #8]
34192884:	fbb2 f3f3 	udiv	r3, r2, r3
34192888:	60fb      	str	r3, [r7, #12]
            break;
3419288a:	e000      	b.n	3419288e <RCCEx_GetI2CCLKFreq+0x216>
            break;
3419288c:	bf00      	nop
        }
      }
      break;
3419288e:	e08b      	b.n	341929a8 <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34192890:	f7fb fd12 	bl	3418e2b8 <LL_RCC_IC15_IsEnabled>
34192894:	4603      	mov	r3, r0
34192896:	2b00      	cmp	r3, #0
34192898:	f000 8088 	beq.w	341929ac <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
3419289c:	f7fb fd2e 	bl	3418e2fc <LL_RCC_IC15_GetDivider>
341928a0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
341928a2:	f7fb fd1d 	bl	3418e2e0 <LL_RCC_IC15_GetSource>
341928a6:	4603      	mov	r3, r0
341928a8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341928ac:	d029      	beq.n	34192902 <RCCEx_GetI2CCLKFreq+0x28a>
341928ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341928b2:	d82f      	bhi.n	34192914 <RCCEx_GetI2CCLKFreq+0x29c>
341928b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341928b8:	d01a      	beq.n	341928f0 <RCCEx_GetI2CCLKFreq+0x278>
341928ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341928be:	d829      	bhi.n	34192914 <RCCEx_GetI2CCLKFreq+0x29c>
341928c0:	2b00      	cmp	r3, #0
341928c2:	d003      	beq.n	341928cc <RCCEx_GetI2CCLKFreq+0x254>
341928c4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341928c8:	d009      	beq.n	341928de <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341928ca:	e023      	b.n	34192914 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341928cc:	f7fe fe08 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341928d0:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
341928d2:	68fa      	ldr	r2, [r7, #12]
341928d4:	68bb      	ldr	r3, [r7, #8]
341928d6:	fbb2 f3f3 	udiv	r3, r2, r3
341928da:	60fb      	str	r3, [r7, #12]
            break;
341928dc:	e01b      	b.n	34192916 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341928de:	f7fe fe45 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341928e2:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
341928e4:	68fa      	ldr	r2, [r7, #12]
341928e6:	68bb      	ldr	r3, [r7, #8]
341928e8:	fbb2 f3f3 	udiv	r3, r2, r3
341928ec:	60fb      	str	r3, [r7, #12]
            break;
341928ee:	e012      	b.n	34192916 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341928f0:	f7fe fe82 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341928f4:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
341928f6:	68fa      	ldr	r2, [r7, #12]
341928f8:	68bb      	ldr	r3, [r7, #8]
341928fa:	fbb2 f3f3 	udiv	r3, r2, r3
341928fe:	60fb      	str	r3, [r7, #12]
            break;
34192900:	e009      	b.n	34192916 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192902:	f7fe febf 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192906:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34192908:	68fa      	ldr	r2, [r7, #12]
3419290a:	68bb      	ldr	r3, [r7, #8]
3419290c:	fbb2 f3f3 	udiv	r3, r2, r3
34192910:	60fb      	str	r3, [r7, #12]
            break;
34192912:	e000      	b.n	34192916 <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34192914:	bf00      	nop
        }
      }
      break;
34192916:	e049      	b.n	341929ac <RCCEx_GetI2CCLKFreq+0x334>
34192918:	07050c0c 	.word	0x07050c0c
3419291c:	0705080c 	.word	0x0705080c
34192920:	0705040c 	.word	0x0705040c
34192924:	0705000c 	.word	0x0705000c
34192928:	07040c0c 	.word	0x07040c0c
3419292c:	0704080c 	.word	0x0704080c
34192930:	0704040c 	.word	0x0704040c
34192934:	0704000c 	.word	0x0704000c
34192938:	07030c0c 	.word	0x07030c0c
3419293c:	0703080c 	.word	0x0703080c
34192940:	0703040c 	.word	0x0703040c
34192944:	0703000c 	.word	0x0703000c
34192948:	07020c0c 	.word	0x07020c0c
3419294c:	0702080c 	.word	0x0702080c
34192950:	0702040c 	.word	0x0702040c
34192954:	0702000c 	.word	0x0702000c
34192958:	07010c0c 	.word	0x07010c0c
3419295c:	0701080c 	.word	0x0701080c
34192960:	0701040c 	.word	0x0701040c
34192964:	0701000c 	.word	0x0701000c
34192968:	07000c0c 	.word	0x07000c0c
3419296c:	0700080c 	.word	0x0700080c
34192970:	0700000c 	.word	0x0700000c
34192974:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34192978:	f7fa fb3a 	bl	3418cff0 <LL_RCC_HSI_IsReady>
3419297c:	4603      	mov	r3, r0
3419297e:	2b00      	cmp	r3, #0
34192980:	d016      	beq.n	341929b0 <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34192982:	f7fa fb47 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34192986:	4603      	mov	r3, r0
34192988:	09db      	lsrs	r3, r3, #7
3419298a:	4a0d      	ldr	r2, [pc, #52]	@ (341929c0 <RCCEx_GetI2CCLKFreq+0x348>)
3419298c:	fa22 f303 	lsr.w	r3, r2, r3
34192990:	60fb      	str	r3, [r7, #12]
      }
      break;
34192992:	e00d      	b.n	341929b0 <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34192994:	f7fa fb4c 	bl	3418d030 <LL_RCC_MSI_IsReady>
34192998:	4603      	mov	r3, r0
3419299a:	2b00      	cmp	r3, #0
3419299c:	d00a      	beq.n	341929b4 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
3419299e:	4b09      	ldr	r3, [pc, #36]	@ (341929c4 <RCCEx_GetI2CCLKFreq+0x34c>)
341929a0:	60fb      	str	r3, [r7, #12]
      }
      break;
341929a2:	e007      	b.n	341929b4 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
341929a4:	bf00      	nop
341929a6:	e006      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
341929a8:	bf00      	nop
341929aa:	e004      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
341929ac:	bf00      	nop
341929ae:	e002      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
341929b0:	bf00      	nop
341929b2:	e000      	b.n	341929b6 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
341929b4:	bf00      	nop
  }

  return i2c_frequency;
341929b6:	68fb      	ldr	r3, [r7, #12]
}
341929b8:	4618      	mov	r0, r3
341929ba:	3710      	adds	r7, #16
341929bc:	46bd      	mov	sp, r7
341929be:	bd80      	pop	{r7, pc}
341929c0:	03d09000 	.word	0x03d09000
341929c4:	003d0900 	.word	0x003d0900

341929c8 <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
341929c8:	b580      	push	{r7, lr}
341929ca:	b084      	sub	sp, #16
341929cc:	af00      	add	r7, sp, #0
341929ce:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
341929d0:	2300      	movs	r3, #0
341929d2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
341929d4:	6878      	ldr	r0, [r7, #4]
341929d6:	f7fa fe5d 	bl	3418d694 <LL_RCC_GetI3CClockSource>
341929da:	4603      	mov	r3, r0
341929dc:	4a86      	ldr	r2, [pc, #536]	@ (34192bf8 <RCCEx_GetI3CCLKFreq+0x230>)
341929de:	4293      	cmp	r3, r2
341929e0:	f000 80e6 	beq.w	34192bb0 <RCCEx_GetI3CCLKFreq+0x1e8>
341929e4:	4a84      	ldr	r2, [pc, #528]	@ (34192bf8 <RCCEx_GetI3CCLKFreq+0x230>)
341929e6:	4293      	cmp	r3, r2
341929e8:	f200 80f8 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
341929ec:	4a83      	ldr	r2, [pc, #524]	@ (34192bfc <RCCEx_GetI3CCLKFreq+0x234>)
341929ee:	4293      	cmp	r3, r2
341929f0:	f000 80de 	beq.w	34192bb0 <RCCEx_GetI3CCLKFreq+0x1e8>
341929f4:	4a81      	ldr	r2, [pc, #516]	@ (34192bfc <RCCEx_GetI3CCLKFreq+0x234>)
341929f6:	4293      	cmp	r3, r2
341929f8:	f200 80f0 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
341929fc:	4a80      	ldr	r2, [pc, #512]	@ (34192c00 <RCCEx_GetI3CCLKFreq+0x238>)
341929fe:	4293      	cmp	r3, r2
34192a00:	f000 80e4 	beq.w	34192bcc <RCCEx_GetI3CCLKFreq+0x204>
34192a04:	4a7e      	ldr	r2, [pc, #504]	@ (34192c00 <RCCEx_GetI3CCLKFreq+0x238>)
34192a06:	4293      	cmp	r3, r2
34192a08:	f200 80e8 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a0c:	4a7d      	ldr	r2, [pc, #500]	@ (34192c04 <RCCEx_GetI3CCLKFreq+0x23c>)
34192a0e:	4293      	cmp	r3, r2
34192a10:	f000 80dc 	beq.w	34192bcc <RCCEx_GetI3CCLKFreq+0x204>
34192a14:	4a7b      	ldr	r2, [pc, #492]	@ (34192c04 <RCCEx_GetI3CCLKFreq+0x23c>)
34192a16:	4293      	cmp	r3, r2
34192a18:	f200 80e0 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a1c:	4a7a      	ldr	r2, [pc, #488]	@ (34192c08 <RCCEx_GetI3CCLKFreq+0x240>)
34192a1e:	4293      	cmp	r3, r2
34192a20:	f000 8083 	beq.w	34192b2a <RCCEx_GetI3CCLKFreq+0x162>
34192a24:	4a78      	ldr	r2, [pc, #480]	@ (34192c08 <RCCEx_GetI3CCLKFreq+0x240>)
34192a26:	4293      	cmp	r3, r2
34192a28:	f200 80d8 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a2c:	4a77      	ldr	r2, [pc, #476]	@ (34192c0c <RCCEx_GetI3CCLKFreq+0x244>)
34192a2e:	4293      	cmp	r3, r2
34192a30:	d07b      	beq.n	34192b2a <RCCEx_GetI3CCLKFreq+0x162>
34192a32:	4a76      	ldr	r2, [pc, #472]	@ (34192c0c <RCCEx_GetI3CCLKFreq+0x244>)
34192a34:	4293      	cmp	r3, r2
34192a36:	f200 80d1 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a3a:	4a75      	ldr	r2, [pc, #468]	@ (34192c10 <RCCEx_GetI3CCLKFreq+0x248>)
34192a3c:	4293      	cmp	r3, r2
34192a3e:	d030      	beq.n	34192aa2 <RCCEx_GetI3CCLKFreq+0xda>
34192a40:	4a73      	ldr	r2, [pc, #460]	@ (34192c10 <RCCEx_GetI3CCLKFreq+0x248>)
34192a42:	4293      	cmp	r3, r2
34192a44:	f200 80ca 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a48:	4a72      	ldr	r2, [pc, #456]	@ (34192c14 <RCCEx_GetI3CCLKFreq+0x24c>)
34192a4a:	4293      	cmp	r3, r2
34192a4c:	d029      	beq.n	34192aa2 <RCCEx_GetI3CCLKFreq+0xda>
34192a4e:	4a71      	ldr	r2, [pc, #452]	@ (34192c14 <RCCEx_GetI3CCLKFreq+0x24c>)
34192a50:	4293      	cmp	r3, r2
34192a52:	f200 80c3 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a56:	4a70      	ldr	r2, [pc, #448]	@ (34192c18 <RCCEx_GetI3CCLKFreq+0x250>)
34192a58:	4293      	cmp	r3, r2
34192a5a:	d01d      	beq.n	34192a98 <RCCEx_GetI3CCLKFreq+0xd0>
34192a5c:	4a6e      	ldr	r2, [pc, #440]	@ (34192c18 <RCCEx_GetI3CCLKFreq+0x250>)
34192a5e:	4293      	cmp	r3, r2
34192a60:	f200 80bc 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a64:	4a6d      	ldr	r2, [pc, #436]	@ (34192c1c <RCCEx_GetI3CCLKFreq+0x254>)
34192a66:	4293      	cmp	r3, r2
34192a68:	d016      	beq.n	34192a98 <RCCEx_GetI3CCLKFreq+0xd0>
34192a6a:	4a6c      	ldr	r2, [pc, #432]	@ (34192c1c <RCCEx_GetI3CCLKFreq+0x254>)
34192a6c:	4293      	cmp	r3, r2
34192a6e:	f200 80b5 	bhi.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
34192a72:	4a6b      	ldr	r2, [pc, #428]	@ (34192c20 <RCCEx_GetI3CCLKFreq+0x258>)
34192a74:	4293      	cmp	r3, r2
34192a76:	d003      	beq.n	34192a80 <RCCEx_GetI3CCLKFreq+0xb8>
34192a78:	4a6a      	ldr	r2, [pc, #424]	@ (34192c24 <RCCEx_GetI3CCLKFreq+0x25c>)
34192a7a:	4293      	cmp	r3, r2
34192a7c:	f040 80ae 	bne.w	34192bdc <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192a80:	f7f9 fe8e 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192a84:	4603      	mov	r3, r0
34192a86:	4618      	mov	r0, r3
34192a88:	f7fe fe42 	bl	34191710 <RCCEx_GetHCLKFreq>
34192a8c:	4603      	mov	r3, r0
34192a8e:	4618      	mov	r0, r3
34192a90:	f7fe fe4f 	bl	34191732 <RCCEx_GetPCLK1Freq>
34192a94:	60f8      	str	r0, [r7, #12]
      break;
34192a96:	e0aa      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192a98:	2007      	movs	r0, #7
34192a9a:	f7ff f925 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192a9e:	60f8      	str	r0, [r7, #12]
      break;
34192aa0:	e0a5      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34192aa2:	f7fb fb09 	bl	3418e0b8 <LL_RCC_IC10_IsEnabled>
34192aa6:	4603      	mov	r3, r0
34192aa8:	2b00      	cmp	r3, #0
34192aaa:	f000 8099 	beq.w	34192be0 <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34192aae:	f7fb fb25 	bl	3418e0fc <LL_RCC_IC10_GetDivider>
34192ab2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34192ab4:	f7fb fb14 	bl	3418e0e0 <LL_RCC_IC10_GetSource>
34192ab8:	4603      	mov	r3, r0
34192aba:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192abe:	d029      	beq.n	34192b14 <RCCEx_GetI3CCLKFreq+0x14c>
34192ac0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192ac4:	d82f      	bhi.n	34192b26 <RCCEx_GetI3CCLKFreq+0x15e>
34192ac6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192aca:	d01a      	beq.n	34192b02 <RCCEx_GetI3CCLKFreq+0x13a>
34192acc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192ad0:	d829      	bhi.n	34192b26 <RCCEx_GetI3CCLKFreq+0x15e>
34192ad2:	2b00      	cmp	r3, #0
34192ad4:	d003      	beq.n	34192ade <RCCEx_GetI3CCLKFreq+0x116>
34192ad6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192ada:	d009      	beq.n	34192af0 <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192adc:	e023      	b.n	34192b26 <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192ade:	f7fe fcff 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192ae2:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192ae4:	68fa      	ldr	r2, [r7, #12]
34192ae6:	68bb      	ldr	r3, [r7, #8]
34192ae8:	fbb2 f3f3 	udiv	r3, r2, r3
34192aec:	60fb      	str	r3, [r7, #12]
            break;
34192aee:	e01b      	b.n	34192b28 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192af0:	f7fe fd3c 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34192af4:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192af6:	68fa      	ldr	r2, [r7, #12]
34192af8:	68bb      	ldr	r3, [r7, #8]
34192afa:	fbb2 f3f3 	udiv	r3, r2, r3
34192afe:	60fb      	str	r3, [r7, #12]
            break;
34192b00:	e012      	b.n	34192b28 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192b02:	f7fe fd79 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34192b06:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192b08:	68fa      	ldr	r2, [r7, #12]
34192b0a:	68bb      	ldr	r3, [r7, #8]
34192b0c:	fbb2 f3f3 	udiv	r3, r2, r3
34192b10:	60fb      	str	r3, [r7, #12]
            break;
34192b12:	e009      	b.n	34192b28 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192b14:	f7fe fdb6 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192b18:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192b1a:	68fa      	ldr	r2, [r7, #12]
34192b1c:	68bb      	ldr	r3, [r7, #8]
34192b1e:	fbb2 f3f3 	udiv	r3, r2, r3
34192b22:	60fb      	str	r3, [r7, #12]
            break;
34192b24:	e000      	b.n	34192b28 <RCCEx_GetI3CCLKFreq+0x160>
            break;
34192b26:	bf00      	nop
        }
      }
      break;
34192b28:	e05a      	b.n	34192be0 <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34192b2a:	f7fb fbc5 	bl	3418e2b8 <LL_RCC_IC15_IsEnabled>
34192b2e:	4603      	mov	r3, r0
34192b30:	2b00      	cmp	r3, #0
34192b32:	d057      	beq.n	34192be4 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34192b34:	f7fb fbe2 	bl	3418e2fc <LL_RCC_IC15_GetDivider>
34192b38:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34192b3a:	f7fb fbd1 	bl	3418e2e0 <LL_RCC_IC15_GetSource>
34192b3e:	4603      	mov	r3, r0
34192b40:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192b44:	d029      	beq.n	34192b9a <RCCEx_GetI3CCLKFreq+0x1d2>
34192b46:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192b4a:	d82f      	bhi.n	34192bac <RCCEx_GetI3CCLKFreq+0x1e4>
34192b4c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192b50:	d01a      	beq.n	34192b88 <RCCEx_GetI3CCLKFreq+0x1c0>
34192b52:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192b56:	d829      	bhi.n	34192bac <RCCEx_GetI3CCLKFreq+0x1e4>
34192b58:	2b00      	cmp	r3, #0
34192b5a:	d003      	beq.n	34192b64 <RCCEx_GetI3CCLKFreq+0x19c>
34192b5c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192b60:	d009      	beq.n	34192b76 <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192b62:	e023      	b.n	34192bac <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192b64:	f7fe fcbc 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192b68:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192b6a:	68fa      	ldr	r2, [r7, #12]
34192b6c:	68bb      	ldr	r3, [r7, #8]
34192b6e:	fbb2 f3f3 	udiv	r3, r2, r3
34192b72:	60fb      	str	r3, [r7, #12]
            break;
34192b74:	e01b      	b.n	34192bae <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192b76:	f7fe fcf9 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34192b7a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192b7c:	68fa      	ldr	r2, [r7, #12]
34192b7e:	68bb      	ldr	r3, [r7, #8]
34192b80:	fbb2 f3f3 	udiv	r3, r2, r3
34192b84:	60fb      	str	r3, [r7, #12]
            break;
34192b86:	e012      	b.n	34192bae <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192b88:	f7fe fd36 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34192b8c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192b8e:	68fa      	ldr	r2, [r7, #12]
34192b90:	68bb      	ldr	r3, [r7, #8]
34192b92:	fbb2 f3f3 	udiv	r3, r2, r3
34192b96:	60fb      	str	r3, [r7, #12]
            break;
34192b98:	e009      	b.n	34192bae <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192b9a:	f7fe fd73 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192b9e:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34192ba0:	68fa      	ldr	r2, [r7, #12]
34192ba2:	68bb      	ldr	r3, [r7, #8]
34192ba4:	fbb2 f3f3 	udiv	r3, r2, r3
34192ba8:	60fb      	str	r3, [r7, #12]
            break;
34192baa:	e000      	b.n	34192bae <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
34192bac:	bf00      	nop
        }
      }
      break;
34192bae:	e019      	b.n	34192be4 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34192bb0:	f7fa fa1e 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34192bb4:	4603      	mov	r3, r0
34192bb6:	2b00      	cmp	r3, #0
34192bb8:	d016      	beq.n	34192be8 <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34192bba:	f7fa fa2b 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34192bbe:	4603      	mov	r3, r0
34192bc0:	09db      	lsrs	r3, r3, #7
34192bc2:	4a19      	ldr	r2, [pc, #100]	@ (34192c28 <RCCEx_GetI3CCLKFreq+0x260>)
34192bc4:	fa22 f303 	lsr.w	r3, r2, r3
34192bc8:	60fb      	str	r3, [r7, #12]
      }
      break;
34192bca:	e00d      	b.n	34192be8 <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34192bcc:	f7fa fa30 	bl	3418d030 <LL_RCC_MSI_IsReady>
34192bd0:	4603      	mov	r3, r0
34192bd2:	2b00      	cmp	r3, #0
34192bd4:	d00a      	beq.n	34192bec <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
34192bd6:	4b15      	ldr	r3, [pc, #84]	@ (34192c2c <RCCEx_GetI3CCLKFreq+0x264>)
34192bd8:	60fb      	str	r3, [r7, #12]
      }
      break;
34192bda:	e007      	b.n	34192bec <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
34192bdc:	bf00      	nop
34192bde:	e006      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>
      break;
34192be0:	bf00      	nop
34192be2:	e004      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>
      break;
34192be4:	bf00      	nop
34192be6:	e002      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>
      break;
34192be8:	bf00      	nop
34192bea:	e000      	b.n	34192bee <RCCEx_GetI3CCLKFreq+0x226>
      break;
34192bec:	bf00      	nop
  }

  return i3c_frequency;
34192bee:	68fb      	ldr	r3, [r7, #12]
}
34192bf0:	4618      	mov	r0, r3
34192bf2:	3710      	adds	r7, #16
34192bf4:	46bd      	mov	sp, r7
34192bf6:	bd80      	pop	{r7, pc}
34192bf8:	0705140c 	.word	0x0705140c
34192bfc:	0705100c 	.word	0x0705100c
34192c00:	0704140c 	.word	0x0704140c
34192c04:	0704100c 	.word	0x0704100c
34192c08:	0703140c 	.word	0x0703140c
34192c0c:	0703100c 	.word	0x0703100c
34192c10:	0702140c 	.word	0x0702140c
34192c14:	0702100c 	.word	0x0702100c
34192c18:	0701140c 	.word	0x0701140c
34192c1c:	0701100c 	.word	0x0701100c
34192c20:	0700100c 	.word	0x0700100c
34192c24:	0700140c 	.word	0x0700140c
34192c28:	03d09000 	.word	0x03d09000
34192c2c:	003d0900 	.word	0x003d0900

34192c30 <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
34192c30:	b590      	push	{r4, r7, lr}
34192c32:	b085      	sub	sp, #20
34192c34:	af00      	add	r7, sp, #0
34192c36:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
34192c38:	2300      	movs	r3, #0
34192c3a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34192c3c:	6878      	ldr	r0, [r7, #4]
34192c3e:	f7fa fd35 	bl	3418d6ac <LL_RCC_GetLPTIMClockSource>
34192c42:	4603      	mov	r3, r0
34192c44:	4aa1      	ldr	r2, [pc, #644]	@ (34192ecc <RCCEx_GetLPTIMCLKFreq+0x29c>)
34192c46:	4293      	cmp	r3, r2
34192c48:	f000 8185 	beq.w	34192f56 <RCCEx_GetLPTIMCLKFreq+0x326>
34192c4c:	4a9f      	ldr	r2, [pc, #636]	@ (34192ecc <RCCEx_GetLPTIMCLKFreq+0x29c>)
34192c4e:	4293      	cmp	r3, r2
34192c50:	f200 818b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192c54:	4a9e      	ldr	r2, [pc, #632]	@ (34192ed0 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34192c56:	4293      	cmp	r3, r2
34192c58:	f000 817d 	beq.w	34192f56 <RCCEx_GetLPTIMCLKFreq+0x326>
34192c5c:	4a9c      	ldr	r2, [pc, #624]	@ (34192ed0 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34192c5e:	4293      	cmp	r3, r2
34192c60:	f200 8183 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192c64:	4a9b      	ldr	r2, [pc, #620]	@ (34192ed4 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34192c66:	4293      	cmp	r3, r2
34192c68:	f000 8175 	beq.w	34192f56 <RCCEx_GetLPTIMCLKFreq+0x326>
34192c6c:	4a99      	ldr	r2, [pc, #612]	@ (34192ed4 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34192c6e:	4293      	cmp	r3, r2
34192c70:	f200 817b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192c74:	4a98      	ldr	r2, [pc, #608]	@ (34192ed8 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
34192c76:	4293      	cmp	r3, r2
34192c78:	f000 816d 	beq.w	34192f56 <RCCEx_GetLPTIMCLKFreq+0x326>
34192c7c:	4a96      	ldr	r2, [pc, #600]	@ (34192ed8 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
34192c7e:	4293      	cmp	r3, r2
34192c80:	f200 8173 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192c84:	4a95      	ldr	r2, [pc, #596]	@ (34192edc <RCCEx_GetLPTIMCLKFreq+0x2ac>)
34192c86:	4293      	cmp	r3, r2
34192c88:	f000 8165 	beq.w	34192f56 <RCCEx_GetLPTIMCLKFreq+0x326>
34192c8c:	4a93      	ldr	r2, [pc, #588]	@ (34192edc <RCCEx_GetLPTIMCLKFreq+0x2ac>)
34192c8e:	4293      	cmp	r3, r2
34192c90:	f200 816b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192c94:	4a92      	ldr	r2, [pc, #584]	@ (34192ee0 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
34192c96:	4293      	cmp	r3, r2
34192c98:	f000 8154 	beq.w	34192f44 <RCCEx_GetLPTIMCLKFreq+0x314>
34192c9c:	4a90      	ldr	r2, [pc, #576]	@ (34192ee0 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
34192c9e:	4293      	cmp	r3, r2
34192ca0:	f200 8163 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192ca4:	4a8f      	ldr	r2, [pc, #572]	@ (34192ee4 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
34192ca6:	4293      	cmp	r3, r2
34192ca8:	f000 814c 	beq.w	34192f44 <RCCEx_GetLPTIMCLKFreq+0x314>
34192cac:	4a8d      	ldr	r2, [pc, #564]	@ (34192ee4 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
34192cae:	4293      	cmp	r3, r2
34192cb0:	f200 815b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192cb4:	4a8c      	ldr	r2, [pc, #560]	@ (34192ee8 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
34192cb6:	4293      	cmp	r3, r2
34192cb8:	f000 8144 	beq.w	34192f44 <RCCEx_GetLPTIMCLKFreq+0x314>
34192cbc:	4a8a      	ldr	r2, [pc, #552]	@ (34192ee8 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
34192cbe:	4293      	cmp	r3, r2
34192cc0:	f200 8153 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192cc4:	4a89      	ldr	r2, [pc, #548]	@ (34192eec <RCCEx_GetLPTIMCLKFreq+0x2bc>)
34192cc6:	4293      	cmp	r3, r2
34192cc8:	f000 813c 	beq.w	34192f44 <RCCEx_GetLPTIMCLKFreq+0x314>
34192ccc:	4a87      	ldr	r2, [pc, #540]	@ (34192eec <RCCEx_GetLPTIMCLKFreq+0x2bc>)
34192cce:	4293      	cmp	r3, r2
34192cd0:	f200 814b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192cd4:	4a86      	ldr	r2, [pc, #536]	@ (34192ef0 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34192cd6:	4293      	cmp	r3, r2
34192cd8:	f000 8134 	beq.w	34192f44 <RCCEx_GetLPTIMCLKFreq+0x314>
34192cdc:	4a84      	ldr	r2, [pc, #528]	@ (34192ef0 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34192cde:	4293      	cmp	r3, r2
34192ce0:	f200 8143 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192ce4:	4a83      	ldr	r2, [pc, #524]	@ (34192ef4 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34192ce6:	4293      	cmp	r3, r2
34192ce8:	f000 80e7 	beq.w	34192eba <RCCEx_GetLPTIMCLKFreq+0x28a>
34192cec:	4a81      	ldr	r2, [pc, #516]	@ (34192ef4 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34192cee:	4293      	cmp	r3, r2
34192cf0:	f200 813b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192cf4:	4a80      	ldr	r2, [pc, #512]	@ (34192ef8 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34192cf6:	4293      	cmp	r3, r2
34192cf8:	f000 80df 	beq.w	34192eba <RCCEx_GetLPTIMCLKFreq+0x28a>
34192cfc:	4a7e      	ldr	r2, [pc, #504]	@ (34192ef8 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34192cfe:	4293      	cmp	r3, r2
34192d00:	f200 8133 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d04:	4a7d      	ldr	r2, [pc, #500]	@ (34192efc <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34192d06:	4293      	cmp	r3, r2
34192d08:	f000 80d7 	beq.w	34192eba <RCCEx_GetLPTIMCLKFreq+0x28a>
34192d0c:	4a7b      	ldr	r2, [pc, #492]	@ (34192efc <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34192d0e:	4293      	cmp	r3, r2
34192d10:	f200 812b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d14:	4a7a      	ldr	r2, [pc, #488]	@ (34192f00 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
34192d16:	4293      	cmp	r3, r2
34192d18:	f000 80cf 	beq.w	34192eba <RCCEx_GetLPTIMCLKFreq+0x28a>
34192d1c:	4a78      	ldr	r2, [pc, #480]	@ (34192f00 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
34192d1e:	4293      	cmp	r3, r2
34192d20:	f200 8123 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d24:	4a77      	ldr	r2, [pc, #476]	@ (34192f04 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
34192d26:	4293      	cmp	r3, r2
34192d28:	f000 80c7 	beq.w	34192eba <RCCEx_GetLPTIMCLKFreq+0x28a>
34192d2c:	4a75      	ldr	r2, [pc, #468]	@ (34192f04 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
34192d2e:	4293      	cmp	r3, r2
34192d30:	f200 811b 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d34:	4a74      	ldr	r2, [pc, #464]	@ (34192f08 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34192d36:	4293      	cmp	r3, r2
34192d38:	d07b      	beq.n	34192e32 <RCCEx_GetLPTIMCLKFreq+0x202>
34192d3a:	4a73      	ldr	r2, [pc, #460]	@ (34192f08 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34192d3c:	4293      	cmp	r3, r2
34192d3e:	f200 8114 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d42:	4a72      	ldr	r2, [pc, #456]	@ (34192f0c <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34192d44:	4293      	cmp	r3, r2
34192d46:	d074      	beq.n	34192e32 <RCCEx_GetLPTIMCLKFreq+0x202>
34192d48:	4a70      	ldr	r2, [pc, #448]	@ (34192f0c <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34192d4a:	4293      	cmp	r3, r2
34192d4c:	f200 810d 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d50:	4a6f      	ldr	r2, [pc, #444]	@ (34192f10 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
34192d52:	4293      	cmp	r3, r2
34192d54:	d06d      	beq.n	34192e32 <RCCEx_GetLPTIMCLKFreq+0x202>
34192d56:	4a6e      	ldr	r2, [pc, #440]	@ (34192f10 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
34192d58:	4293      	cmp	r3, r2
34192d5a:	f200 8106 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d5e:	4a6d      	ldr	r2, [pc, #436]	@ (34192f14 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34192d60:	4293      	cmp	r3, r2
34192d62:	d066      	beq.n	34192e32 <RCCEx_GetLPTIMCLKFreq+0x202>
34192d64:	4a6b      	ldr	r2, [pc, #428]	@ (34192f14 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34192d66:	4293      	cmp	r3, r2
34192d68:	f200 80ff 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d6c:	4a6a      	ldr	r2, [pc, #424]	@ (34192f18 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34192d6e:	4293      	cmp	r3, r2
34192d70:	d05f      	beq.n	34192e32 <RCCEx_GetLPTIMCLKFreq+0x202>
34192d72:	4a69      	ldr	r2, [pc, #420]	@ (34192f18 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34192d74:	4293      	cmp	r3, r2
34192d76:	f200 80f8 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d7a:	4a68      	ldr	r2, [pc, #416]	@ (34192f1c <RCCEx_GetLPTIMCLKFreq+0x2ec>)
34192d7c:	4293      	cmp	r3, r2
34192d7e:	d053      	beq.n	34192e28 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34192d80:	4a66      	ldr	r2, [pc, #408]	@ (34192f1c <RCCEx_GetLPTIMCLKFreq+0x2ec>)
34192d82:	4293      	cmp	r3, r2
34192d84:	f200 80f1 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d88:	4a65      	ldr	r2, [pc, #404]	@ (34192f20 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
34192d8a:	4293      	cmp	r3, r2
34192d8c:	d04c      	beq.n	34192e28 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34192d8e:	4a64      	ldr	r2, [pc, #400]	@ (34192f20 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
34192d90:	4293      	cmp	r3, r2
34192d92:	f200 80ea 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192d96:	4a63      	ldr	r2, [pc, #396]	@ (34192f24 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
34192d98:	4293      	cmp	r3, r2
34192d9a:	d045      	beq.n	34192e28 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34192d9c:	4a61      	ldr	r2, [pc, #388]	@ (34192f24 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
34192d9e:	4293      	cmp	r3, r2
34192da0:	f200 80e3 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192da4:	4a60      	ldr	r2, [pc, #384]	@ (34192f28 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
34192da6:	4293      	cmp	r3, r2
34192da8:	d03e      	beq.n	34192e28 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34192daa:	4a5f      	ldr	r2, [pc, #380]	@ (34192f28 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
34192dac:	4293      	cmp	r3, r2
34192dae:	f200 80dc 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192db2:	4a5e      	ldr	r2, [pc, #376]	@ (34192f2c <RCCEx_GetLPTIMCLKFreq+0x2fc>)
34192db4:	4293      	cmp	r3, r2
34192db6:	d037      	beq.n	34192e28 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34192db8:	4a5c      	ldr	r2, [pc, #368]	@ (34192f2c <RCCEx_GetLPTIMCLKFreq+0x2fc>)
34192dba:	4293      	cmp	r3, r2
34192dbc:	f200 80d5 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192dc0:	4a5b      	ldr	r2, [pc, #364]	@ (34192f30 <RCCEx_GetLPTIMCLKFreq+0x300>)
34192dc2:	4293      	cmp	r3, r2
34192dc4:	d024      	beq.n	34192e10 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34192dc6:	4a5a      	ldr	r2, [pc, #360]	@ (34192f30 <RCCEx_GetLPTIMCLKFreq+0x300>)
34192dc8:	4293      	cmp	r3, r2
34192dca:	f200 80ce 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192dce:	4a59      	ldr	r2, [pc, #356]	@ (34192f34 <RCCEx_GetLPTIMCLKFreq+0x304>)
34192dd0:	4293      	cmp	r3, r2
34192dd2:	d01d      	beq.n	34192e10 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34192dd4:	4a57      	ldr	r2, [pc, #348]	@ (34192f34 <RCCEx_GetLPTIMCLKFreq+0x304>)
34192dd6:	4293      	cmp	r3, r2
34192dd8:	f200 80c7 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192ddc:	4a56      	ldr	r2, [pc, #344]	@ (34192f38 <RCCEx_GetLPTIMCLKFreq+0x308>)
34192dde:	4293      	cmp	r3, r2
34192de0:	d016      	beq.n	34192e10 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34192de2:	4a55      	ldr	r2, [pc, #340]	@ (34192f38 <RCCEx_GetLPTIMCLKFreq+0x308>)
34192de4:	4293      	cmp	r3, r2
34192de6:	f200 80c0 	bhi.w	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
34192dea:	4a54      	ldr	r2, [pc, #336]	@ (34192f3c <RCCEx_GetLPTIMCLKFreq+0x30c>)
34192dec:	4293      	cmp	r3, r2
34192dee:	d003      	beq.n	34192df8 <RCCEx_GetLPTIMCLKFreq+0x1c8>
34192df0:	4a53      	ldr	r2, [pc, #332]	@ (34192f40 <RCCEx_GetLPTIMCLKFreq+0x310>)
34192df2:	4293      	cmp	r3, r2
34192df4:	d00c      	beq.n	34192e10 <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34192df6:	e0b8      	b.n	34192f6a <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192df8:	f7f9 fcd2 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192dfc:	4603      	mov	r3, r0
34192dfe:	4618      	mov	r0, r3
34192e00:	f7fe fc86 	bl	34191710 <RCCEx_GetHCLKFreq>
34192e04:	4603      	mov	r3, r0
34192e06:	4618      	mov	r0, r3
34192e08:	f7fe fc93 	bl	34191732 <RCCEx_GetPCLK1Freq>
34192e0c:	60f8      	str	r0, [r7, #12]
      break;
34192e0e:	e0b3      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192e10:	f7f9 fcc6 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192e14:	4603      	mov	r3, r0
34192e16:	4618      	mov	r0, r3
34192e18:	f7fe fc7a 	bl	34191710 <RCCEx_GetHCLKFreq>
34192e1c:	4603      	mov	r3, r0
34192e1e:	4618      	mov	r0, r3
34192e20:	f7fe fca8 	bl	34191774 <RCCEx_GetPCLK4Freq>
34192e24:	60f8      	str	r0, [r7, #12]
      break;
34192e26:	e0a7      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192e28:	2007      	movs	r0, #7
34192e2a:	f7fe ff5d 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34192e2e:	60f8      	str	r0, [r7, #12]
      break;
34192e30:	e0a2      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34192e32:	f7fb fa41 	bl	3418e2b8 <LL_RCC_IC15_IsEnabled>
34192e36:	4603      	mov	r3, r0
34192e38:	2b00      	cmp	r3, #0
34192e3a:	f000 8098 	beq.w	34192f6e <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
34192e3e:	f7fb fa5d 	bl	3418e2fc <LL_RCC_IC15_GetDivider>
34192e42:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34192e44:	f7fb fa4c 	bl	3418e2e0 <LL_RCC_IC15_GetSource>
34192e48:	4603      	mov	r3, r0
34192e4a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192e4e:	d029      	beq.n	34192ea4 <RCCEx_GetLPTIMCLKFreq+0x274>
34192e50:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192e54:	d82f      	bhi.n	34192eb6 <RCCEx_GetLPTIMCLKFreq+0x286>
34192e56:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192e5a:	d01a      	beq.n	34192e92 <RCCEx_GetLPTIMCLKFreq+0x262>
34192e5c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192e60:	d829      	bhi.n	34192eb6 <RCCEx_GetLPTIMCLKFreq+0x286>
34192e62:	2b00      	cmp	r3, #0
34192e64:	d003      	beq.n	34192e6e <RCCEx_GetLPTIMCLKFreq+0x23e>
34192e66:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192e6a:	d009      	beq.n	34192e80 <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
34192e6c:	e023      	b.n	34192eb6 <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192e6e:	f7fe fb37 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34192e72:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34192e74:	68fa      	ldr	r2, [r7, #12]
34192e76:	68bb      	ldr	r3, [r7, #8]
34192e78:	fbb2 f3f3 	udiv	r3, r2, r3
34192e7c:	60fb      	str	r3, [r7, #12]
            break;
34192e7e:	e01b      	b.n	34192eb8 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192e80:	f7fe fb74 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34192e84:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34192e86:	68fa      	ldr	r2, [r7, #12]
34192e88:	68bb      	ldr	r3, [r7, #8]
34192e8a:	fbb2 f3f3 	udiv	r3, r2, r3
34192e8e:	60fb      	str	r3, [r7, #12]
            break;
34192e90:	e012      	b.n	34192eb8 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192e92:	f7fe fbb1 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34192e96:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34192e98:	68fa      	ldr	r2, [r7, #12]
34192e9a:	68bb      	ldr	r3, [r7, #8]
34192e9c:	fbb2 f3f3 	udiv	r3, r2, r3
34192ea0:	60fb      	str	r3, [r7, #12]
            break;
34192ea2:	e009      	b.n	34192eb8 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192ea4:	f7fe fbee 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34192ea8:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34192eaa:	68fa      	ldr	r2, [r7, #12]
34192eac:	68bb      	ldr	r3, [r7, #8]
34192eae:	fbb2 f3f3 	udiv	r3, r2, r3
34192eb2:	60fb      	str	r3, [r7, #12]
            break;
34192eb4:	e000      	b.n	34192eb8 <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
34192eb6:	bf00      	nop
      break;
34192eb8:	e059      	b.n	34192f6e <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
34192eba:	f7fa f8d9 	bl	3418d070 <LL_RCC_LSE_IsReady>
34192ebe:	4603      	mov	r3, r0
34192ec0:	2b00      	cmp	r3, #0
34192ec2:	d056      	beq.n	34192f72 <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
34192ec4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34192ec8:	60fb      	str	r3, [r7, #12]
      break;
34192eca:	e052      	b.n	34192f72 <RCCEx_GetLPTIMCLKFreq+0x342>
34192ecc:	0705182c 	.word	0x0705182c
34192ed0:	0705142c 	.word	0x0705142c
34192ed4:	0705102c 	.word	0x0705102c
34192ed8:	07050c2c 	.word	0x07050c2c
34192edc:	0705082c 	.word	0x0705082c
34192ee0:	0704182c 	.word	0x0704182c
34192ee4:	0704142c 	.word	0x0704142c
34192ee8:	0704102c 	.word	0x0704102c
34192eec:	07040c2c 	.word	0x07040c2c
34192ef0:	0704082c 	.word	0x0704082c
34192ef4:	0703182c 	.word	0x0703182c
34192ef8:	0703142c 	.word	0x0703142c
34192efc:	0703102c 	.word	0x0703102c
34192f00:	07030c2c 	.word	0x07030c2c
34192f04:	0703082c 	.word	0x0703082c
34192f08:	0702182c 	.word	0x0702182c
34192f0c:	0702142c 	.word	0x0702142c
34192f10:	0702102c 	.word	0x0702102c
34192f14:	07020c2c 	.word	0x07020c2c
34192f18:	0702082c 	.word	0x0702082c
34192f1c:	0701182c 	.word	0x0701182c
34192f20:	0701142c 	.word	0x0701142c
34192f24:	0701102c 	.word	0x0701102c
34192f28:	07010c2c 	.word	0x07010c2c
34192f2c:	0701082c 	.word	0x0701082c
34192f30:	0700182c 	.word	0x0700182c
34192f34:	0700142c 	.word	0x0700142c
34192f38:	0700102c 	.word	0x0700102c
34192f3c:	0700082c 	.word	0x0700082c
34192f40:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
34192f44:	f7fa f8a6 	bl	3418d094 <LL_RCC_LSI_IsReady>
34192f48:	4603      	mov	r3, r0
34192f4a:	2b00      	cmp	r3, #0
34192f4c:	d013      	beq.n	34192f76 <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
34192f4e:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34192f52:	60fb      	str	r3, [r7, #12]
      break;
34192f54:	e00f      	b.n	34192f76 <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34192f56:	f7f9 fc23 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192f5a:	4604      	mov	r4, r0
34192f5c:	f7fa fcb0 	bl	3418d8c0 <LL_RCC_GetTIMPrescaler>
34192f60:	4603      	mov	r3, r0
34192f62:	fa24 f303 	lsr.w	r3, r4, r3
34192f66:	60fb      	str	r3, [r7, #12]
      break;
34192f68:	e006      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34192f6a:	bf00      	nop
34192f6c:	e004      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34192f6e:	bf00      	nop
34192f70:	e002      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34192f72:	bf00      	nop
34192f74:	e000      	b.n	34192f78 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34192f76:	bf00      	nop
  }

  return lptim_frequency;
34192f78:	68fb      	ldr	r3, [r7, #12]
}
34192f7a:	4618      	mov	r0, r3
34192f7c:	3714      	adds	r7, #20
34192f7e:	46bd      	mov	sp, r7
34192f80:	bd90      	pop	{r4, r7, pc}
34192f82:	bf00      	nop

34192f84 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
34192f84:	b580      	push	{r7, lr}
34192f86:	b084      	sub	sp, #16
34192f88:	af00      	add	r7, sp, #0
34192f8a:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
34192f8c:	2300      	movs	r3, #0
34192f8e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
34192f90:	6878      	ldr	r0, [r7, #4]
34192f92:	f7fa fb97 	bl	3418d6c4 <LL_RCC_GetLPUARTClockSource>
34192f96:	4603      	mov	r3, r0
34192f98:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34192f9c:	f000 80c0 	beq.w	34193120 <RCCEx_GetLPUARTCLKFreq+0x19c>
34192fa0:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34192fa4:	f200 80db 	bhi.w	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
34192fa8:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34192fac:	f000 80c6 	beq.w	3419313c <RCCEx_GetLPUARTCLKFreq+0x1b8>
34192fb0:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34192fb4:	f200 80d3 	bhi.w	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
34192fb8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34192fbc:	f000 80c6 	beq.w	3419314c <RCCEx_GetLPUARTCLKFreq+0x1c8>
34192fc0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34192fc4:	f200 80cb 	bhi.w	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
34192fc8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34192fcc:	d065      	beq.n	3419309a <RCCEx_GetLPUARTCLKFreq+0x116>
34192fce:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34192fd2:	f200 80c4 	bhi.w	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
34192fd6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34192fda:	d01a      	beq.n	34193012 <RCCEx_GetLPUARTCLKFreq+0x8e>
34192fdc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34192fe0:	f200 80bd 	bhi.w	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
34192fe4:	2b00      	cmp	r3, #0
34192fe6:	d003      	beq.n	34192ff0 <RCCEx_GetLPUARTCLKFreq+0x6c>
34192fe8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34192fec:	d00c      	beq.n	34193008 <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
34192fee:	e0b6      	b.n	3419315e <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34192ff0:	f7f9 fbd6 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34192ff4:	4603      	mov	r3, r0
34192ff6:	4618      	mov	r0, r3
34192ff8:	f7fe fb8a 	bl	34191710 <RCCEx_GetHCLKFreq>
34192ffc:	4603      	mov	r3, r0
34192ffe:	4618      	mov	r0, r3
34193000:	f7fe fbb8 	bl	34191774 <RCCEx_GetPCLK4Freq>
34193004:	60f8      	str	r0, [r7, #12]
      break;
34193006:	e0b5      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193008:	2007      	movs	r0, #7
3419300a:	f7fe fe6d 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
3419300e:	60f8      	str	r0, [r7, #12]
      break;
34193010:	e0b0      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34193012:	f7fb f811 	bl	3418e038 <LL_RCC_IC9_IsEnabled>
34193016:	4603      	mov	r3, r0
34193018:	2b00      	cmp	r3, #0
3419301a:	f000 80a2 	beq.w	34193162 <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
3419301e:	f7fb f82d 	bl	3418e07c <LL_RCC_IC9_GetDivider>
34193022:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34193024:	f7fb f81c 	bl	3418e060 <LL_RCC_IC9_GetSource>
34193028:	4603      	mov	r3, r0
3419302a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419302e:	d029      	beq.n	34193084 <RCCEx_GetLPUARTCLKFreq+0x100>
34193030:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193034:	d82f      	bhi.n	34193096 <RCCEx_GetLPUARTCLKFreq+0x112>
34193036:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419303a:	d01a      	beq.n	34193072 <RCCEx_GetLPUARTCLKFreq+0xee>
3419303c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193040:	d829      	bhi.n	34193096 <RCCEx_GetLPUARTCLKFreq+0x112>
34193042:	2b00      	cmp	r3, #0
34193044:	d003      	beq.n	3419304e <RCCEx_GetLPUARTCLKFreq+0xca>
34193046:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419304a:	d009      	beq.n	34193060 <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
3419304c:	e023      	b.n	34193096 <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419304e:	f7fe fa47 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193052:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34193054:	68fa      	ldr	r2, [r7, #12]
34193056:	68bb      	ldr	r3, [r7, #8]
34193058:	fbb2 f3f3 	udiv	r3, r2, r3
3419305c:	60fb      	str	r3, [r7, #12]
            break;
3419305e:	e01b      	b.n	34193098 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193060:	f7fe fa84 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193064:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34193066:	68fa      	ldr	r2, [r7, #12]
34193068:	68bb      	ldr	r3, [r7, #8]
3419306a:	fbb2 f3f3 	udiv	r3, r2, r3
3419306e:	60fb      	str	r3, [r7, #12]
            break;
34193070:	e012      	b.n	34193098 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193072:	f7fe fac1 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193076:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34193078:	68fa      	ldr	r2, [r7, #12]
3419307a:	68bb      	ldr	r3, [r7, #8]
3419307c:	fbb2 f3f3 	udiv	r3, r2, r3
34193080:	60fb      	str	r3, [r7, #12]
            break;
34193082:	e009      	b.n	34193098 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193084:	f7fe fafe 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193088:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3419308a:	68fa      	ldr	r2, [r7, #12]
3419308c:	68bb      	ldr	r3, [r7, #8]
3419308e:	fbb2 f3f3 	udiv	r3, r2, r3
34193092:	60fb      	str	r3, [r7, #12]
            break;
34193094:	e000      	b.n	34193098 <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
34193096:	bf00      	nop
      break;
34193098:	e063      	b.n	34193162 <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3419309a:	f7fb f8cd 	bl	3418e238 <LL_RCC_IC14_IsEnabled>
3419309e:	4603      	mov	r3, r0
341930a0:	2b00      	cmp	r3, #0
341930a2:	d060      	beq.n	34193166 <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
341930a4:	f7fb f8ea 	bl	3418e27c <LL_RCC_IC14_GetDivider>
341930a8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
341930aa:	f7fb f8d9 	bl	3418e260 <LL_RCC_IC14_GetSource>
341930ae:	4603      	mov	r3, r0
341930b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341930b4:	d029      	beq.n	3419310a <RCCEx_GetLPUARTCLKFreq+0x186>
341930b6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341930ba:	d82f      	bhi.n	3419311c <RCCEx_GetLPUARTCLKFreq+0x198>
341930bc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341930c0:	d01a      	beq.n	341930f8 <RCCEx_GetLPUARTCLKFreq+0x174>
341930c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341930c6:	d829      	bhi.n	3419311c <RCCEx_GetLPUARTCLKFreq+0x198>
341930c8:	2b00      	cmp	r3, #0
341930ca:	d003      	beq.n	341930d4 <RCCEx_GetLPUARTCLKFreq+0x150>
341930cc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341930d0:	d009      	beq.n	341930e6 <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
341930d2:	e023      	b.n	3419311c <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341930d4:	f7fe fa04 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341930d8:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
341930da:	68fa      	ldr	r2, [r7, #12]
341930dc:	68bb      	ldr	r3, [r7, #8]
341930de:	fbb2 f3f3 	udiv	r3, r2, r3
341930e2:	60fb      	str	r3, [r7, #12]
            break;
341930e4:	e01b      	b.n	3419311e <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341930e6:	f7fe fa41 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341930ea:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
341930ec:	68fa      	ldr	r2, [r7, #12]
341930ee:	68bb      	ldr	r3, [r7, #8]
341930f0:	fbb2 f3f3 	udiv	r3, r2, r3
341930f4:	60fb      	str	r3, [r7, #12]
            break;
341930f6:	e012      	b.n	3419311e <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341930f8:	f7fe fa7e 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341930fc:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
341930fe:	68fa      	ldr	r2, [r7, #12]
34193100:	68bb      	ldr	r3, [r7, #8]
34193102:	fbb2 f3f3 	udiv	r3, r2, r3
34193106:	60fb      	str	r3, [r7, #12]
            break;
34193108:	e009      	b.n	3419311e <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419310a:	f7fe fabb 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419310e:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34193110:	68fa      	ldr	r2, [r7, #12]
34193112:	68bb      	ldr	r3, [r7, #8]
34193114:	fbb2 f3f3 	udiv	r3, r2, r3
34193118:	60fb      	str	r3, [r7, #12]
            break;
3419311a:	e000      	b.n	3419311e <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
3419311c:	bf00      	nop
      break;
3419311e:	e022      	b.n	34193166 <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
34193120:	f7f9 ff66 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34193124:	4603      	mov	r3, r0
34193126:	2b00      	cmp	r3, #0
34193128:	d01f      	beq.n	3419316a <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3419312a:	f7f9 ff73 	bl	3418d014 <LL_RCC_HSI_GetDivider>
3419312e:	4603      	mov	r3, r0
34193130:	09db      	lsrs	r3, r3, #7
34193132:	4a13      	ldr	r2, [pc, #76]	@ (34193180 <RCCEx_GetLPUARTCLKFreq+0x1fc>)
34193134:	fa22 f303 	lsr.w	r3, r2, r3
34193138:	60fb      	str	r3, [r7, #12]
      break;
3419313a:	e016      	b.n	3419316a <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
3419313c:	f7f9 ff78 	bl	3418d030 <LL_RCC_MSI_IsReady>
34193140:	4603      	mov	r3, r0
34193142:	2b00      	cmp	r3, #0
34193144:	d013      	beq.n	3419316e <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
34193146:	4b0f      	ldr	r3, [pc, #60]	@ (34193184 <RCCEx_GetLPUARTCLKFreq+0x200>)
34193148:	60fb      	str	r3, [r7, #12]
      break;
3419314a:	e010      	b.n	3419316e <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
3419314c:	f7f9 ff90 	bl	3418d070 <LL_RCC_LSE_IsReady>
34193150:	4603      	mov	r3, r0
34193152:	2b00      	cmp	r3, #0
34193154:	d00d      	beq.n	34193172 <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
34193156:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3419315a:	60fb      	str	r3, [r7, #12]
      break;
3419315c:	e009      	b.n	34193172 <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
3419315e:	bf00      	nop
34193160:	e008      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34193162:	bf00      	nop
34193164:	e006      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34193166:	bf00      	nop
34193168:	e004      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3419316a:	bf00      	nop
3419316c:	e002      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3419316e:	bf00      	nop
34193170:	e000      	b.n	34193174 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34193172:	bf00      	nop
  }

  return lpuart_frequency;
34193174:	68fb      	ldr	r3, [r7, #12]
}
34193176:	4618      	mov	r0, r3
34193178:	3710      	adds	r7, #16
3419317a:	46bd      	mov	sp, r7
3419317c:	bd80      	pop	{r7, pc}
3419317e:	bf00      	nop
34193180:	03d09000 	.word	0x03d09000
34193184:	003d0900 	.word	0x003d0900

34193188 <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
34193188:	b580      	push	{r7, lr}
3419318a:	b084      	sub	sp, #16
3419318c:	af00      	add	r7, sp, #0
3419318e:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
34193190:	2300      	movs	r3, #0
34193192:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34193194:	6878      	ldr	r0, [r7, #4]
34193196:	f7fa faa7 	bl	3418d6e8 <LL_RCC_GetLTDCClockSource>
3419319a:	4603      	mov	r3, r0
3419319c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
341931a0:	d062      	beq.n	34193268 <RCCEx_GetLTDCCLKFreq+0xe0>
341931a2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
341931a6:	d86d      	bhi.n	34193284 <RCCEx_GetLTDCCLKFreq+0xfc>
341931a8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
341931ac:	d019      	beq.n	341931e2 <RCCEx_GetLTDCCLKFreq+0x5a>
341931ae:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
341931b2:	d867      	bhi.n	34193284 <RCCEx_GetLTDCCLKFreq+0xfc>
341931b4:	2b00      	cmp	r3, #0
341931b6:	d003      	beq.n	341931c0 <RCCEx_GetLTDCCLKFreq+0x38>
341931b8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341931bc:	d00c      	beq.n	341931d8 <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
341931be:	e061      	b.n	34193284 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341931c0:	f7f9 faee 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
341931c4:	4603      	mov	r3, r0
341931c6:	4618      	mov	r0, r3
341931c8:	f7fe faa2 	bl	34191710 <RCCEx_GetHCLKFreq>
341931cc:	4603      	mov	r3, r0
341931ce:	4618      	mov	r0, r3
341931d0:	f7fe fae1 	bl	34191796 <RCCEx_GetPCLK5Freq>
341931d4:	60f8      	str	r0, [r7, #12]
      break;
341931d6:	e05a      	b.n	3419328e <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341931d8:	2007      	movs	r0, #7
341931da:	f7fe fd85 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
341931de:	60f8      	str	r0, [r7, #12]
      break;
341931e0:	e055      	b.n	3419328e <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
341931e2:	f7fb f8a9 	bl	3418e338 <LL_RCC_IC16_IsEnabled>
341931e6:	4603      	mov	r3, r0
341931e8:	2b00      	cmp	r3, #0
341931ea:	d04d      	beq.n	34193288 <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
341931ec:	f7fb f8c6 	bl	3418e37c <LL_RCC_IC16_GetDivider>
341931f0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
341931f2:	f7fb f8b5 	bl	3418e360 <LL_RCC_IC16_GetSource>
341931f6:	4603      	mov	r3, r0
341931f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341931fc:	d029      	beq.n	34193252 <RCCEx_GetLTDCCLKFreq+0xca>
341931fe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193202:	d82f      	bhi.n	34193264 <RCCEx_GetLTDCCLKFreq+0xdc>
34193204:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193208:	d01a      	beq.n	34193240 <RCCEx_GetLTDCCLKFreq+0xb8>
3419320a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419320e:	d829      	bhi.n	34193264 <RCCEx_GetLTDCCLKFreq+0xdc>
34193210:	2b00      	cmp	r3, #0
34193212:	d003      	beq.n	3419321c <RCCEx_GetLTDCCLKFreq+0x94>
34193214:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193218:	d009      	beq.n	3419322e <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
3419321a:	e023      	b.n	34193264 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419321c:	f7fe f960 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193220:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34193222:	68fa      	ldr	r2, [r7, #12]
34193224:	68bb      	ldr	r3, [r7, #8]
34193226:	fbb2 f3f3 	udiv	r3, r2, r3
3419322a:	60fb      	str	r3, [r7, #12]
            break;
3419322c:	e01b      	b.n	34193266 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419322e:	f7fe f99d 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193232:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34193234:	68fa      	ldr	r2, [r7, #12]
34193236:	68bb      	ldr	r3, [r7, #8]
34193238:	fbb2 f3f3 	udiv	r3, r2, r3
3419323c:	60fb      	str	r3, [r7, #12]
            break;
3419323e:	e012      	b.n	34193266 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193240:	f7fe f9da 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193244:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34193246:	68fa      	ldr	r2, [r7, #12]
34193248:	68bb      	ldr	r3, [r7, #8]
3419324a:	fbb2 f3f3 	udiv	r3, r2, r3
3419324e:	60fb      	str	r3, [r7, #12]
            break;
34193250:	e009      	b.n	34193266 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193252:	f7fe fa17 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193256:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34193258:	68fa      	ldr	r2, [r7, #12]
3419325a:	68bb      	ldr	r3, [r7, #8]
3419325c:	fbb2 f3f3 	udiv	r3, r2, r3
34193260:	60fb      	str	r3, [r7, #12]
            break;
34193262:	e000      	b.n	34193266 <RCCEx_GetLTDCCLKFreq+0xde>
            break;
34193264:	bf00      	nop
      break;
34193266:	e00f      	b.n	34193288 <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34193268:	f7f9 fec2 	bl	3418cff0 <LL_RCC_HSI_IsReady>
3419326c:	4603      	mov	r3, r0
3419326e:	2b00      	cmp	r3, #0
34193270:	d00c      	beq.n	3419328c <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193272:	f7f9 fecf 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34193276:	4603      	mov	r3, r0
34193278:	09db      	lsrs	r3, r3, #7
3419327a:	4a07      	ldr	r2, [pc, #28]	@ (34193298 <RCCEx_GetLTDCCLKFreq+0x110>)
3419327c:	fa22 f303 	lsr.w	r3, r2, r3
34193280:	60fb      	str	r3, [r7, #12]
      break;
34193282:	e003      	b.n	3419328c <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34193284:	bf00      	nop
34193286:	e002      	b.n	3419328e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34193288:	bf00      	nop
3419328a:	e000      	b.n	3419328e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
3419328c:	bf00      	nop
  }

  return ltdc_frequency;
3419328e:	68fb      	ldr	r3, [r7, #12]
}
34193290:	4618      	mov	r0, r3
34193292:	3710      	adds	r7, #16
34193294:	46bd      	mov	sp, r7
34193296:	bd80      	pop	{r7, pc}
34193298:	03d09000 	.word	0x03d09000

3419329c <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
3419329c:	b590      	push	{r4, r7, lr}
3419329e:	b085      	sub	sp, #20
341932a0:	af00      	add	r7, sp, #0
341932a2:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
341932a4:	2300      	movs	r3, #0
341932a6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
341932a8:	6878      	ldr	r0, [r7, #4]
341932aa:	f7fa fa2f 	bl	3418d70c <LL_RCC_GetMDFClockSource>
341932ae:	4603      	mov	r3, r0
341932b0:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
341932b4:	f000 80dd 	beq.w	34193472 <RCCEx_GetMDFCLKFreq+0x1d6>
341932b8:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
341932bc:	f200 80e3 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
341932c0:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
341932c4:	f000 80d2 	beq.w	3419346c <RCCEx_GetMDFCLKFreq+0x1d0>
341932c8:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
341932cc:	f200 80db 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
341932d0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
341932d4:	f000 80b4 	beq.w	34193440 <RCCEx_GetMDFCLKFreq+0x1a4>
341932d8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
341932dc:	f200 80d3 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
341932e0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
341932e4:	f000 80ba 	beq.w	3419345c <RCCEx_GetMDFCLKFreq+0x1c0>
341932e8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
341932ec:	f200 80cb 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
341932f0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
341932f4:	d061      	beq.n	341933ba <RCCEx_GetMDFCLKFreq+0x11e>
341932f6:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
341932fa:	f200 80c4 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
341932fe:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34193302:	d016      	beq.n	34193332 <RCCEx_GetMDFCLKFreq+0x96>
34193304:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34193308:	f200 80bd 	bhi.w	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
3419330c:	2b00      	cmp	r3, #0
3419330e:	d003      	beq.n	34193318 <RCCEx_GetMDFCLKFreq+0x7c>
34193310:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34193314:	d008      	beq.n	34193328 <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34193316:	e0b6      	b.n	34193486 <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34193318:	f7f9 fa42 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3419331c:	4603      	mov	r3, r0
3419331e:	4618      	mov	r0, r3
34193320:	f7fe f9f6 	bl	34191710 <RCCEx_GetHCLKFreq>
34193324:	60f8      	str	r0, [r7, #12]
      break;
34193326:	e0b7      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193328:	2007      	movs	r0, #7
3419332a:	f7fe fcdd 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
3419332e:	60f8      	str	r0, [r7, #12]
      break;
34193330:	e0b2      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34193332:	f7fa fe01 	bl	3418df38 <LL_RCC_IC7_IsEnabled>
34193336:	4603      	mov	r3, r0
34193338:	2b00      	cmp	r3, #0
3419333a:	f000 80a6 	beq.w	3419348a <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
3419333e:	f7fa fe1d 	bl	3418df7c <LL_RCC_IC7_GetDivider>
34193342:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34193344:	f7fa fe0c 	bl	3418df60 <LL_RCC_IC7_GetSource>
34193348:	4603      	mov	r3, r0
3419334a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419334e:	d029      	beq.n	341933a4 <RCCEx_GetMDFCLKFreq+0x108>
34193350:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193354:	d82f      	bhi.n	341933b6 <RCCEx_GetMDFCLKFreq+0x11a>
34193356:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419335a:	d01a      	beq.n	34193392 <RCCEx_GetMDFCLKFreq+0xf6>
3419335c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193360:	d829      	bhi.n	341933b6 <RCCEx_GetMDFCLKFreq+0x11a>
34193362:	2b00      	cmp	r3, #0
34193364:	d003      	beq.n	3419336e <RCCEx_GetMDFCLKFreq+0xd2>
34193366:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419336a:	d009      	beq.n	34193380 <RCCEx_GetMDFCLKFreq+0xe4>
            break;
3419336c:	e023      	b.n	341933b6 <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419336e:	f7fe f8b7 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193372:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34193374:	68fa      	ldr	r2, [r7, #12]
34193376:	68bb      	ldr	r3, [r7, #8]
34193378:	fbb2 f3f3 	udiv	r3, r2, r3
3419337c:	60fb      	str	r3, [r7, #12]
            break;
3419337e:	e01b      	b.n	341933b8 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193380:	f7fe f8f4 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193384:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34193386:	68fa      	ldr	r2, [r7, #12]
34193388:	68bb      	ldr	r3, [r7, #8]
3419338a:	fbb2 f3f3 	udiv	r3, r2, r3
3419338e:	60fb      	str	r3, [r7, #12]
            break;
34193390:	e012      	b.n	341933b8 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193392:	f7fe f931 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193396:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34193398:	68fa      	ldr	r2, [r7, #12]
3419339a:	68bb      	ldr	r3, [r7, #8]
3419339c:	fbb2 f3f3 	udiv	r3, r2, r3
341933a0:	60fb      	str	r3, [r7, #12]
            break;
341933a2:	e009      	b.n	341933b8 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341933a4:	f7fe f96e 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341933a8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
341933aa:	68fa      	ldr	r2, [r7, #12]
341933ac:	68bb      	ldr	r3, [r7, #8]
341933ae:	fbb2 f3f3 	udiv	r3, r2, r3
341933b2:	60fb      	str	r3, [r7, #12]
            break;
341933b4:	e000      	b.n	341933b8 <RCCEx_GetMDFCLKFreq+0x11c>
            break;
341933b6:	bf00      	nop
      break;
341933b8:	e067      	b.n	3419348a <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
341933ba:	f7fa fdfd 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
341933be:	4603      	mov	r3, r0
341933c0:	2b00      	cmp	r3, #0
341933c2:	d064      	beq.n	3419348e <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
341933c4:	f7fa fe1a 	bl	3418dffc <LL_RCC_IC8_GetDivider>
341933c8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
341933ca:	f7fa fe09 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
341933ce:	4603      	mov	r3, r0
341933d0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341933d4:	d029      	beq.n	3419342a <RCCEx_GetMDFCLKFreq+0x18e>
341933d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341933da:	d82f      	bhi.n	3419343c <RCCEx_GetMDFCLKFreq+0x1a0>
341933dc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341933e0:	d01a      	beq.n	34193418 <RCCEx_GetMDFCLKFreq+0x17c>
341933e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341933e6:	d829      	bhi.n	3419343c <RCCEx_GetMDFCLKFreq+0x1a0>
341933e8:	2b00      	cmp	r3, #0
341933ea:	d003      	beq.n	341933f4 <RCCEx_GetMDFCLKFreq+0x158>
341933ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341933f0:	d009      	beq.n	34193406 <RCCEx_GetMDFCLKFreq+0x16a>
            break;
341933f2:	e023      	b.n	3419343c <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341933f4:	f7fe f874 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341933f8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
341933fa:	68fa      	ldr	r2, [r7, #12]
341933fc:	68bb      	ldr	r3, [r7, #8]
341933fe:	fbb2 f3f3 	udiv	r3, r2, r3
34193402:	60fb      	str	r3, [r7, #12]
            break;
34193404:	e01b      	b.n	3419343e <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193406:	f7fe f8b1 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419340a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3419340c:	68fa      	ldr	r2, [r7, #12]
3419340e:	68bb      	ldr	r3, [r7, #8]
34193410:	fbb2 f3f3 	udiv	r3, r2, r3
34193414:	60fb      	str	r3, [r7, #12]
            break;
34193416:	e012      	b.n	3419343e <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193418:	f7fe f8ee 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419341c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3419341e:	68fa      	ldr	r2, [r7, #12]
34193420:	68bb      	ldr	r3, [r7, #8]
34193422:	fbb2 f3f3 	udiv	r3, r2, r3
34193426:	60fb      	str	r3, [r7, #12]
            break;
34193428:	e009      	b.n	3419343e <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419342a:	f7fe f92b 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419342e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34193430:	68fa      	ldr	r2, [r7, #12]
34193432:	68bb      	ldr	r3, [r7, #8]
34193434:	fbb2 f3f3 	udiv	r3, r2, r3
34193438:	60fb      	str	r3, [r7, #12]
            break;
3419343a:	e000      	b.n	3419343e <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
3419343c:	bf00      	nop
      break;
3419343e:	e026      	b.n	3419348e <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
34193440:	f7f9 fdd6 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34193444:	4603      	mov	r3, r0
34193446:	2b00      	cmp	r3, #0
34193448:	d023      	beq.n	34193492 <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3419344a:	f7f9 fde3 	bl	3418d014 <LL_RCC_HSI_GetDivider>
3419344e:	4603      	mov	r3, r0
34193450:	09db      	lsrs	r3, r3, #7
34193452:	4a14      	ldr	r2, [pc, #80]	@ (341934a4 <RCCEx_GetMDFCLKFreq+0x208>)
34193454:	fa22 f303 	lsr.w	r3, r2, r3
34193458:	60fb      	str	r3, [r7, #12]
      break;
3419345a:	e01a      	b.n	34193492 <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
3419345c:	f7f9 fde8 	bl	3418d030 <LL_RCC_MSI_IsReady>
34193460:	4603      	mov	r3, r0
34193462:	2b00      	cmp	r3, #0
34193464:	d017      	beq.n	34193496 <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
34193466:	4b10      	ldr	r3, [pc, #64]	@ (341934a8 <RCCEx_GetMDFCLKFreq+0x20c>)
34193468:	60fb      	str	r3, [r7, #12]
      break;
3419346a:	e014      	b.n	34193496 <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
3419346c:	4b0f      	ldr	r3, [pc, #60]	@ (341934ac <RCCEx_GetMDFCLKFreq+0x210>)
3419346e:	60fb      	str	r3, [r7, #12]
      break;
34193470:	e012      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34193472:	f7f9 f995 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34193476:	4604      	mov	r4, r0
34193478:	f7fa fa22 	bl	3418d8c0 <LL_RCC_GetTIMPrescaler>
3419347c:	4603      	mov	r3, r0
3419347e:	fa24 f303 	lsr.w	r3, r4, r3
34193482:	60fb      	str	r3, [r7, #12]
      break;
34193484:	e008      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34193486:	bf00      	nop
34193488:	e006      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3419348a:	bf00      	nop
3419348c:	e004      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3419348e:	bf00      	nop
34193490:	e002      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34193492:	bf00      	nop
34193494:	e000      	b.n	34193498 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34193496:	bf00      	nop
  }

  return adf_frequency;
34193498:	68fb      	ldr	r3, [r7, #12]
}
3419349a:	4618      	mov	r0, r3
3419349c:	3714      	adds	r7, #20
3419349e:	46bd      	mov	sp, r7
341934a0:	bd90      	pop	{r4, r7, pc}
341934a2:	bf00      	nop
341934a4:	03d09000 	.word	0x03d09000
341934a8:	003d0900 	.word	0x003d0900
341934ac:	00bb8000 	.word	0x00bb8000

341934b0 <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
341934b0:	b580      	push	{r7, lr}
341934b2:	b084      	sub	sp, #16
341934b4:	af00      	add	r7, sp, #0
341934b6:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
341934b8:	2300      	movs	r3, #0
341934ba:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
341934bc:	6878      	ldr	r0, [r7, #4]
341934be:	f7fa f937 	bl	3418d730 <LL_RCC_GetPSSIClockSource>
341934c2:	4603      	mov	r3, r0
341934c4:	2b30      	cmp	r3, #48	@ 0x30
341934c6:	d05a      	beq.n	3419357e <RCCEx_GetPSSICLKFreq+0xce>
341934c8:	2b30      	cmp	r3, #48	@ 0x30
341934ca:	d866      	bhi.n	3419359a <RCCEx_GetPSSICLKFreq+0xea>
341934cc:	2b20      	cmp	r3, #32
341934ce:	d013      	beq.n	341934f8 <RCCEx_GetPSSICLKFreq+0x48>
341934d0:	2b20      	cmp	r3, #32
341934d2:	d862      	bhi.n	3419359a <RCCEx_GetPSSICLKFreq+0xea>
341934d4:	2b00      	cmp	r3, #0
341934d6:	d002      	beq.n	341934de <RCCEx_GetPSSICLKFreq+0x2e>
341934d8:	2b10      	cmp	r3, #16
341934da:	d008      	beq.n	341934ee <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
341934dc:	e05d      	b.n	3419359a <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
341934de:	f7f9 f95f 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
341934e2:	4603      	mov	r3, r0
341934e4:	4618      	mov	r0, r3
341934e6:	f7fe f913 	bl	34191710 <RCCEx_GetHCLKFreq>
341934ea:	60f8      	str	r0, [r7, #12]
      break;
341934ec:	e05a      	b.n	341935a4 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341934ee:	2007      	movs	r0, #7
341934f0:	f7fe fbfa 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
341934f4:	60f8      	str	r0, [r7, #12]
      break;
341934f6:	e055      	b.n	341935a4 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
341934f8:	f7fb f81e 	bl	3418e538 <LL_RCC_IC20_IsEnabled>
341934fc:	4603      	mov	r3, r0
341934fe:	2b00      	cmp	r3, #0
34193500:	d04d      	beq.n	3419359e <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
34193502:	f7fb f83b 	bl	3418e57c <LL_RCC_IC20_GetDivider>
34193506:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
34193508:	f7fb f82a 	bl	3418e560 <LL_RCC_IC20_GetSource>
3419350c:	4603      	mov	r3, r0
3419350e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193512:	d029      	beq.n	34193568 <RCCEx_GetPSSICLKFreq+0xb8>
34193514:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193518:	d82f      	bhi.n	3419357a <RCCEx_GetPSSICLKFreq+0xca>
3419351a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419351e:	d01a      	beq.n	34193556 <RCCEx_GetPSSICLKFreq+0xa6>
34193520:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193524:	d829      	bhi.n	3419357a <RCCEx_GetPSSICLKFreq+0xca>
34193526:	2b00      	cmp	r3, #0
34193528:	d003      	beq.n	34193532 <RCCEx_GetPSSICLKFreq+0x82>
3419352a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419352e:	d009      	beq.n	34193544 <RCCEx_GetPSSICLKFreq+0x94>
            break;
34193530:	e023      	b.n	3419357a <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193532:	f7fd ffd5 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193536:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34193538:	68fa      	ldr	r2, [r7, #12]
3419353a:	68bb      	ldr	r3, [r7, #8]
3419353c:	fbb2 f3f3 	udiv	r3, r2, r3
34193540:	60fb      	str	r3, [r7, #12]
            break;
34193542:	e01b      	b.n	3419357c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193544:	f7fe f812 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193548:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
3419354a:	68fa      	ldr	r2, [r7, #12]
3419354c:	68bb      	ldr	r3, [r7, #8]
3419354e:	fbb2 f3f3 	udiv	r3, r2, r3
34193552:	60fb      	str	r3, [r7, #12]
            break;
34193554:	e012      	b.n	3419357c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193556:	f7fe f84f 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419355a:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
3419355c:	68fa      	ldr	r2, [r7, #12]
3419355e:	68bb      	ldr	r3, [r7, #8]
34193560:	fbb2 f3f3 	udiv	r3, r2, r3
34193564:	60fb      	str	r3, [r7, #12]
            break;
34193566:	e009      	b.n	3419357c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193568:	f7fe f88c 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419356c:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
3419356e:	68fa      	ldr	r2, [r7, #12]
34193570:	68bb      	ldr	r3, [r7, #8]
34193572:	fbb2 f3f3 	udiv	r3, r2, r3
34193576:	60fb      	str	r3, [r7, #12]
            break;
34193578:	e000      	b.n	3419357c <RCCEx_GetPSSICLKFreq+0xcc>
            break;
3419357a:	bf00      	nop
      break;
3419357c:	e00f      	b.n	3419359e <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
3419357e:	f7f9 fd37 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34193582:	4603      	mov	r3, r0
34193584:	2b00      	cmp	r3, #0
34193586:	d00c      	beq.n	341935a2 <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193588:	f7f9 fd44 	bl	3418d014 <LL_RCC_HSI_GetDivider>
3419358c:	4603      	mov	r3, r0
3419358e:	09db      	lsrs	r3, r3, #7
34193590:	4a07      	ldr	r2, [pc, #28]	@ (341935b0 <RCCEx_GetPSSICLKFreq+0x100>)
34193592:	fa22 f303 	lsr.w	r3, r2, r3
34193596:	60fb      	str	r3, [r7, #12]
      break;
34193598:	e003      	b.n	341935a2 <RCCEx_GetPSSICLKFreq+0xf2>
      break;
3419359a:	bf00      	nop
3419359c:	e002      	b.n	341935a4 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
3419359e:	bf00      	nop
341935a0:	e000      	b.n	341935a4 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
341935a2:	bf00      	nop
  }

  return pssi_frequency;
341935a4:	68fb      	ldr	r3, [r7, #12]
}
341935a6:	4618      	mov	r0, r3
341935a8:	3710      	adds	r7, #16
341935aa:	46bd      	mov	sp, r7
341935ac:	bd80      	pop	{r7, pc}
341935ae:	bf00      	nop
341935b0:	03d09000 	.word	0x03d09000

341935b4 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
341935b4:	b580      	push	{r7, lr}
341935b6:	b082      	sub	sp, #8
341935b8:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
341935ba:	2300      	movs	r3, #0
341935bc:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
341935be:	f7fa f945 	bl	3418d84c <LL_RCC_GetRTCClockSource>
341935c2:	4603      	mov	r3, r0
341935c4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
341935c8:	d020      	beq.n	3419360c <RCCEx_GetRTCCLKFreq+0x58>
341935ca:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
341935ce:	d830      	bhi.n	34193632 <RCCEx_GetRTCCLKFreq+0x7e>
341935d0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341935d4:	d011      	beq.n	341935fa <RCCEx_GetRTCCLKFreq+0x46>
341935d6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341935da:	d82a      	bhi.n	34193632 <RCCEx_GetRTCCLKFreq+0x7e>
341935dc:	2b00      	cmp	r3, #0
341935de:	d02a      	beq.n	34193636 <RCCEx_GetRTCCLKFreq+0x82>
341935e0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341935e4:	d000      	beq.n	341935e8 <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
341935e6:	e024      	b.n	34193632 <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
341935e8:	f7f9 fd42 	bl	3418d070 <LL_RCC_LSE_IsReady>
341935ec:	4603      	mov	r3, r0
341935ee:	2b00      	cmp	r3, #0
341935f0:	d023      	beq.n	3419363a <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
341935f2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
341935f6:	607b      	str	r3, [r7, #4]
      break;
341935f8:	e01f      	b.n	3419363a <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
341935fa:	f7f9 fd4b 	bl	3418d094 <LL_RCC_LSI_IsReady>
341935fe:	4603      	mov	r3, r0
34193600:	2b00      	cmp	r3, #0
34193602:	d01c      	beq.n	3419363e <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
34193604:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34193608:	607b      	str	r3, [r7, #4]
      break;
3419360a:	e018      	b.n	3419363e <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
3419360c:	f7f9 fcde 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34193610:	4603      	mov	r3, r0
34193612:	2b00      	cmp	r3, #0
34193614:	d015      	beq.n	34193642 <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
34193616:	4b0e      	ldr	r3, [pc, #56]	@ (34193650 <RCCEx_GetRTCCLKFreq+0x9c>)
34193618:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3419361c:	0b1b      	lsrs	r3, r3, #12
3419361e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34193622:	3301      	adds	r3, #1
34193624:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
34193626:	4a0b      	ldr	r2, [pc, #44]	@ (34193654 <RCCEx_GetRTCCLKFreq+0xa0>)
34193628:	683b      	ldr	r3, [r7, #0]
3419362a:	fbb2 f3f3 	udiv	r3, r2, r3
3419362e:	607b      	str	r3, [r7, #4]
      break;
34193630:	e007      	b.n	34193642 <RCCEx_GetRTCCLKFreq+0x8e>
      break;
34193632:	bf00      	nop
34193634:	e006      	b.n	34193644 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34193636:	bf00      	nop
34193638:	e004      	b.n	34193644 <RCCEx_GetRTCCLKFreq+0x90>
      break;
3419363a:	bf00      	nop
3419363c:	e002      	b.n	34193644 <RCCEx_GetRTCCLKFreq+0x90>
      break;
3419363e:	bf00      	nop
34193640:	e000      	b.n	34193644 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34193642:	bf00      	nop
  }

  return rtc_frequency;
34193644:	687b      	ldr	r3, [r7, #4]
}
34193646:	4618      	mov	r0, r3
34193648:	3708      	adds	r7, #8
3419364a:	46bd      	mov	sp, r7
3419364c:	bd80      	pop	{r7, pc}
3419364e:	bf00      	nop
34193650:	56028000 	.word	0x56028000
34193654:	02dc6c00 	.word	0x02dc6c00

34193658 <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
34193658:	b580      	push	{r7, lr}
3419365a:	b084      	sub	sp, #16
3419365c:	af00      	add	r7, sp, #0
3419365e:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
34193660:	2300      	movs	r3, #0
34193662:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34193664:	6878      	ldr	r0, [r7, #4]
34193666:	f7fa f875 	bl	3418d754 <LL_RCC_GetSAIClockSource>
3419366a:	4603      	mov	r3, r0
3419366c:	4a9a      	ldr	r2, [pc, #616]	@ (341938d8 <RCCEx_GetSAICLKFreq+0x280>)
3419366e:	4293      	cmp	r3, r2
34193670:	f000 811f 	beq.w	341938b2 <RCCEx_GetSAICLKFreq+0x25a>
34193674:	4a98      	ldr	r2, [pc, #608]	@ (341938d8 <RCCEx_GetSAICLKFreq+0x280>)
34193676:	4293      	cmp	r3, r2
34193678:	f200 8120 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
3419367c:	4a97      	ldr	r2, [pc, #604]	@ (341938dc <RCCEx_GetSAICLKFreq+0x284>)
3419367e:	4293      	cmp	r3, r2
34193680:	f000 8117 	beq.w	341938b2 <RCCEx_GetSAICLKFreq+0x25a>
34193684:	4a95      	ldr	r2, [pc, #596]	@ (341938dc <RCCEx_GetSAICLKFreq+0x284>)
34193686:	4293      	cmp	r3, r2
34193688:	f200 8118 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
3419368c:	4a94      	ldr	r2, [pc, #592]	@ (341938e0 <RCCEx_GetSAICLKFreq+0x288>)
3419368e:	4293      	cmp	r3, r2
34193690:	f000 810c 	beq.w	341938ac <RCCEx_GetSAICLKFreq+0x254>
34193694:	4a92      	ldr	r2, [pc, #584]	@ (341938e0 <RCCEx_GetSAICLKFreq+0x288>)
34193696:	4293      	cmp	r3, r2
34193698:	f200 8110 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
3419369c:	4a91      	ldr	r2, [pc, #580]	@ (341938e4 <RCCEx_GetSAICLKFreq+0x28c>)
3419369e:	4293      	cmp	r3, r2
341936a0:	f000 8104 	beq.w	341938ac <RCCEx_GetSAICLKFreq+0x254>
341936a4:	4a8f      	ldr	r2, [pc, #572]	@ (341938e4 <RCCEx_GetSAICLKFreq+0x28c>)
341936a6:	4293      	cmp	r3, r2
341936a8:	f200 8108 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936ac:	4a8e      	ldr	r2, [pc, #568]	@ (341938e8 <RCCEx_GetSAICLKFreq+0x290>)
341936ae:	4293      	cmp	r3, r2
341936b0:	f000 80e6 	beq.w	34193880 <RCCEx_GetSAICLKFreq+0x228>
341936b4:	4a8c      	ldr	r2, [pc, #560]	@ (341938e8 <RCCEx_GetSAICLKFreq+0x290>)
341936b6:	4293      	cmp	r3, r2
341936b8:	f200 8100 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936bc:	4a8b      	ldr	r2, [pc, #556]	@ (341938ec <RCCEx_GetSAICLKFreq+0x294>)
341936be:	4293      	cmp	r3, r2
341936c0:	f000 80de 	beq.w	34193880 <RCCEx_GetSAICLKFreq+0x228>
341936c4:	4a89      	ldr	r2, [pc, #548]	@ (341938ec <RCCEx_GetSAICLKFreq+0x294>)
341936c6:	4293      	cmp	r3, r2
341936c8:	f200 80f8 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936cc:	4a88      	ldr	r2, [pc, #544]	@ (341938f0 <RCCEx_GetSAICLKFreq+0x298>)
341936ce:	4293      	cmp	r3, r2
341936d0:	f000 80e4 	beq.w	3419389c <RCCEx_GetSAICLKFreq+0x244>
341936d4:	4a86      	ldr	r2, [pc, #536]	@ (341938f0 <RCCEx_GetSAICLKFreq+0x298>)
341936d6:	4293      	cmp	r3, r2
341936d8:	f200 80f0 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936dc:	4a85      	ldr	r2, [pc, #532]	@ (341938f4 <RCCEx_GetSAICLKFreq+0x29c>)
341936de:	4293      	cmp	r3, r2
341936e0:	f000 80dc 	beq.w	3419389c <RCCEx_GetSAICLKFreq+0x244>
341936e4:	4a83      	ldr	r2, [pc, #524]	@ (341938f4 <RCCEx_GetSAICLKFreq+0x29c>)
341936e6:	4293      	cmp	r3, r2
341936e8:	f200 80e8 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936ec:	4a82      	ldr	r2, [pc, #520]	@ (341938f8 <RCCEx_GetSAICLKFreq+0x2a0>)
341936ee:	4293      	cmp	r3, r2
341936f0:	f000 8083 	beq.w	341937fa <RCCEx_GetSAICLKFreq+0x1a2>
341936f4:	4a80      	ldr	r2, [pc, #512]	@ (341938f8 <RCCEx_GetSAICLKFreq+0x2a0>)
341936f6:	4293      	cmp	r3, r2
341936f8:	f200 80e0 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
341936fc:	4a7f      	ldr	r2, [pc, #508]	@ (341938fc <RCCEx_GetSAICLKFreq+0x2a4>)
341936fe:	4293      	cmp	r3, r2
34193700:	d07b      	beq.n	341937fa <RCCEx_GetSAICLKFreq+0x1a2>
34193702:	4a7e      	ldr	r2, [pc, #504]	@ (341938fc <RCCEx_GetSAICLKFreq+0x2a4>)
34193704:	4293      	cmp	r3, r2
34193706:	f200 80d9 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
3419370a:	4a7d      	ldr	r2, [pc, #500]	@ (34193900 <RCCEx_GetSAICLKFreq+0x2a8>)
3419370c:	4293      	cmp	r3, r2
3419370e:	d030      	beq.n	34193772 <RCCEx_GetSAICLKFreq+0x11a>
34193710:	4a7b      	ldr	r2, [pc, #492]	@ (34193900 <RCCEx_GetSAICLKFreq+0x2a8>)
34193712:	4293      	cmp	r3, r2
34193714:	f200 80d2 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
34193718:	4a7a      	ldr	r2, [pc, #488]	@ (34193904 <RCCEx_GetSAICLKFreq+0x2ac>)
3419371a:	4293      	cmp	r3, r2
3419371c:	d029      	beq.n	34193772 <RCCEx_GetSAICLKFreq+0x11a>
3419371e:	4a79      	ldr	r2, [pc, #484]	@ (34193904 <RCCEx_GetSAICLKFreq+0x2ac>)
34193720:	4293      	cmp	r3, r2
34193722:	f200 80cb 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
34193726:	4a78      	ldr	r2, [pc, #480]	@ (34193908 <RCCEx_GetSAICLKFreq+0x2b0>)
34193728:	4293      	cmp	r3, r2
3419372a:	d01d      	beq.n	34193768 <RCCEx_GetSAICLKFreq+0x110>
3419372c:	4a76      	ldr	r2, [pc, #472]	@ (34193908 <RCCEx_GetSAICLKFreq+0x2b0>)
3419372e:	4293      	cmp	r3, r2
34193730:	f200 80c4 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
34193734:	4a75      	ldr	r2, [pc, #468]	@ (3419390c <RCCEx_GetSAICLKFreq+0x2b4>)
34193736:	4293      	cmp	r3, r2
34193738:	d016      	beq.n	34193768 <RCCEx_GetSAICLKFreq+0x110>
3419373a:	4a74      	ldr	r2, [pc, #464]	@ (3419390c <RCCEx_GetSAICLKFreq+0x2b4>)
3419373c:	4293      	cmp	r3, r2
3419373e:	f200 80bd 	bhi.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
34193742:	4a73      	ldr	r2, [pc, #460]	@ (34193910 <RCCEx_GetSAICLKFreq+0x2b8>)
34193744:	4293      	cmp	r3, r2
34193746:	d003      	beq.n	34193750 <RCCEx_GetSAICLKFreq+0xf8>
34193748:	4a72      	ldr	r2, [pc, #456]	@ (34193914 <RCCEx_GetSAICLKFreq+0x2bc>)
3419374a:	4293      	cmp	r3, r2
3419374c:	f040 80b6 	bne.w	341938bc <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34193750:	f7f9 f826 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34193754:	4603      	mov	r3, r0
34193756:	4618      	mov	r0, r3
34193758:	f7fd ffda 	bl	34191710 <RCCEx_GetHCLKFreq>
3419375c:	4603      	mov	r3, r0
3419375e:	4618      	mov	r0, r3
34193760:	f7fd fff7 	bl	34191752 <RCCEx_GetPCLK2Freq>
34193764:	60f8      	str	r0, [r7, #12]
      break;
34193766:	e0b2      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193768:	2007      	movs	r0, #7
3419376a:	f7fe fabd 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
3419376e:	60f8      	str	r0, [r7, #12]
      break;
34193770:	e0ad      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34193772:	f7fa fbe1 	bl	3418df38 <LL_RCC_IC7_IsEnabled>
34193776:	4603      	mov	r3, r0
34193778:	2b00      	cmp	r3, #0
3419377a:	f000 80a1 	beq.w	341938c0 <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
3419377e:	f7fa fbfd 	bl	3418df7c <LL_RCC_IC7_GetDivider>
34193782:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34193784:	f7fa fbec 	bl	3418df60 <LL_RCC_IC7_GetSource>
34193788:	4603      	mov	r3, r0
3419378a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419378e:	d029      	beq.n	341937e4 <RCCEx_GetSAICLKFreq+0x18c>
34193790:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193794:	d82f      	bhi.n	341937f6 <RCCEx_GetSAICLKFreq+0x19e>
34193796:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419379a:	d01a      	beq.n	341937d2 <RCCEx_GetSAICLKFreq+0x17a>
3419379c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341937a0:	d829      	bhi.n	341937f6 <RCCEx_GetSAICLKFreq+0x19e>
341937a2:	2b00      	cmp	r3, #0
341937a4:	d003      	beq.n	341937ae <RCCEx_GetSAICLKFreq+0x156>
341937a6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341937aa:	d009      	beq.n	341937c0 <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341937ac:	e023      	b.n	341937f6 <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341937ae:	f7fd fe97 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341937b2:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
341937b4:	68fa      	ldr	r2, [r7, #12]
341937b6:	68bb      	ldr	r3, [r7, #8]
341937b8:	fbb2 f3f3 	udiv	r3, r2, r3
341937bc:	60fb      	str	r3, [r7, #12]
            break;
341937be:	e01b      	b.n	341937f8 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341937c0:	f7fd fed4 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341937c4:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
341937c6:	68fa      	ldr	r2, [r7, #12]
341937c8:	68bb      	ldr	r3, [r7, #8]
341937ca:	fbb2 f3f3 	udiv	r3, r2, r3
341937ce:	60fb      	str	r3, [r7, #12]
            break;
341937d0:	e012      	b.n	341937f8 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341937d2:	f7fd ff11 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341937d6:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
341937d8:	68fa      	ldr	r2, [r7, #12]
341937da:	68bb      	ldr	r3, [r7, #8]
341937dc:	fbb2 f3f3 	udiv	r3, r2, r3
341937e0:	60fb      	str	r3, [r7, #12]
            break;
341937e2:	e009      	b.n	341937f8 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341937e4:	f7fd ff4e 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341937e8:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
341937ea:	68fa      	ldr	r2, [r7, #12]
341937ec:	68bb      	ldr	r3, [r7, #8]
341937ee:	fbb2 f3f3 	udiv	r3, r2, r3
341937f2:	60fb      	str	r3, [r7, #12]
            break;
341937f4:	e000      	b.n	341937f8 <RCCEx_GetSAICLKFreq+0x1a0>
            break;
341937f6:	bf00      	nop
        }
      }
      break;
341937f8:	e062      	b.n	341938c0 <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
341937fa:	f7fa fbdd 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
341937fe:	4603      	mov	r3, r0
34193800:	2b00      	cmp	r3, #0
34193802:	d05f      	beq.n	341938c4 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34193804:	f7fa fbfa 	bl	3418dffc <LL_RCC_IC8_GetDivider>
34193808:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3419380a:	f7fa fbe9 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
3419380e:	4603      	mov	r3, r0
34193810:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193814:	d029      	beq.n	3419386a <RCCEx_GetSAICLKFreq+0x212>
34193816:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419381a:	d82f      	bhi.n	3419387c <RCCEx_GetSAICLKFreq+0x224>
3419381c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193820:	d01a      	beq.n	34193858 <RCCEx_GetSAICLKFreq+0x200>
34193822:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193826:	d829      	bhi.n	3419387c <RCCEx_GetSAICLKFreq+0x224>
34193828:	2b00      	cmp	r3, #0
3419382a:	d003      	beq.n	34193834 <RCCEx_GetSAICLKFreq+0x1dc>
3419382c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193830:	d009      	beq.n	34193846 <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193832:	e023      	b.n	3419387c <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193834:	f7fd fe54 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193838:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3419383a:	68fa      	ldr	r2, [r7, #12]
3419383c:	68bb      	ldr	r3, [r7, #8]
3419383e:	fbb2 f3f3 	udiv	r3, r2, r3
34193842:	60fb      	str	r3, [r7, #12]
            break;
34193844:	e01b      	b.n	3419387e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193846:	f7fd fe91 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419384a:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3419384c:	68fa      	ldr	r2, [r7, #12]
3419384e:	68bb      	ldr	r3, [r7, #8]
34193850:	fbb2 f3f3 	udiv	r3, r2, r3
34193854:	60fb      	str	r3, [r7, #12]
            break;
34193856:	e012      	b.n	3419387e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193858:	f7fd fece 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419385c:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3419385e:	68fa      	ldr	r2, [r7, #12]
34193860:	68bb      	ldr	r3, [r7, #8]
34193862:	fbb2 f3f3 	udiv	r3, r2, r3
34193866:	60fb      	str	r3, [r7, #12]
            break;
34193868:	e009      	b.n	3419387e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419386a:	f7fd ff0b 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419386e:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34193870:	68fa      	ldr	r2, [r7, #12]
34193872:	68bb      	ldr	r3, [r7, #8]
34193874:	fbb2 f3f3 	udiv	r3, r2, r3
34193878:	60fb      	str	r3, [r7, #12]
            break;
3419387a:	e000      	b.n	3419387e <RCCEx_GetSAICLKFreq+0x226>
            break;
3419387c:	bf00      	nop
        }
      }
      break;
3419387e:	e021      	b.n	341938c4 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34193880:	f7f9 fbb6 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34193884:	4603      	mov	r3, r0
34193886:	2b00      	cmp	r3, #0
34193888:	d01e      	beq.n	341938c8 <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3419388a:	f7f9 fbc3 	bl	3418d014 <LL_RCC_HSI_GetDivider>
3419388e:	4603      	mov	r3, r0
34193890:	09db      	lsrs	r3, r3, #7
34193892:	4a21      	ldr	r2, [pc, #132]	@ (34193918 <RCCEx_GetSAICLKFreq+0x2c0>)
34193894:	fa22 f303 	lsr.w	r3, r2, r3
34193898:	60fb      	str	r3, [r7, #12]
      }
      break;
3419389a:	e015      	b.n	341938c8 <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3419389c:	f7f9 fbc8 	bl	3418d030 <LL_RCC_MSI_IsReady>
341938a0:	4603      	mov	r3, r0
341938a2:	2b00      	cmp	r3, #0
341938a4:	d012      	beq.n	341938cc <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
341938a6:	4b1d      	ldr	r3, [pc, #116]	@ (3419391c <RCCEx_GetSAICLKFreq+0x2c4>)
341938a8:	60fb      	str	r3, [r7, #12]
      }
      break;
341938aa:	e00f      	b.n	341938cc <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
341938ac:	4b1c      	ldr	r3, [pc, #112]	@ (34193920 <RCCEx_GetSAICLKFreq+0x2c8>)
341938ae:	60fb      	str	r3, [r7, #12]
      break;
341938b0:	e00d      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
341938b2:	2007      	movs	r0, #7
341938b4:	f000 f920 	bl	34193af8 <RCCEx_GetSPDIFRXCLKFreq>
341938b8:	60f8      	str	r0, [r7, #12]
      break;
341938ba:	e008      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
341938bc:	bf00      	nop
341938be:	e006      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>
      break;
341938c0:	bf00      	nop
341938c2:	e004      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>
      break;
341938c4:	bf00      	nop
341938c6:	e002      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>
      break;
341938c8:	bf00      	nop
341938ca:	e000      	b.n	341938ce <RCCEx_GetSAICLKFreq+0x276>
      break;
341938cc:	bf00      	nop
  }

  return sai_frequency;
341938ce:	68fb      	ldr	r3, [r7, #12]
}
341938d0:	4618      	mov	r0, r3
341938d2:	3710      	adds	r7, #16
341938d4:	46bd      	mov	sp, r7
341938d6:	bd80      	pop	{r7, pc}
341938d8:	07071818 	.word	0x07071818
341938dc:	07071418 	.word	0x07071418
341938e0:	07061818 	.word	0x07061818
341938e4:	07061418 	.word	0x07061418
341938e8:	07051818 	.word	0x07051818
341938ec:	07051418 	.word	0x07051418
341938f0:	07041818 	.word	0x07041818
341938f4:	07041418 	.word	0x07041418
341938f8:	07031818 	.word	0x07031818
341938fc:	07031418 	.word	0x07031418
34193900:	07021818 	.word	0x07021818
34193904:	07021418 	.word	0x07021418
34193908:	07011818 	.word	0x07011818
3419390c:	07011418 	.word	0x07011418
34193910:	07001418 	.word	0x07001418
34193914:	07001818 	.word	0x07001818
34193918:	03d09000 	.word	0x03d09000
3419391c:	003d0900 	.word	0x003d0900
34193920:	00bb8000 	.word	0x00bb8000

34193924 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
34193924:	b580      	push	{r7, lr}
34193926:	b084      	sub	sp, #16
34193928:	af00      	add	r7, sp, #0
3419392a:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3419392c:	2300      	movs	r3, #0
3419392e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34193930:	6878      	ldr	r0, [r7, #4]
34193932:	f7f9 ff1b 	bl	3418d76c <LL_RCC_GetSDMMCClockSource>
34193936:	4603      	mov	r3, r0
34193938:	4a67      	ldr	r2, [pc, #412]	@ (34193ad8 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
3419393a:	4293      	cmp	r3, r2
3419393c:	d07e      	beq.n	34193a3c <RCCEx_GetSDMMCCLKFreq+0x118>
3419393e:	4a66      	ldr	r2, [pc, #408]	@ (34193ad8 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34193940:	4293      	cmp	r3, r2
34193942:	f200 80be 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
34193946:	4a65      	ldr	r2, [pc, #404]	@ (34193adc <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34193948:	4293      	cmp	r3, r2
3419394a:	d077      	beq.n	34193a3c <RCCEx_GetSDMMCCLKFreq+0x118>
3419394c:	4a63      	ldr	r2, [pc, #396]	@ (34193adc <RCCEx_GetSDMMCCLKFreq+0x1b8>)
3419394e:	4293      	cmp	r3, r2
34193950:	f200 80b7 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
34193954:	4a62      	ldr	r2, [pc, #392]	@ (34193ae0 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34193956:	4293      	cmp	r3, r2
34193958:	d02c      	beq.n	341939b4 <RCCEx_GetSDMMCCLKFreq+0x90>
3419395a:	4a61      	ldr	r2, [pc, #388]	@ (34193ae0 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
3419395c:	4293      	cmp	r3, r2
3419395e:	f200 80b0 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
34193962:	4a60      	ldr	r2, [pc, #384]	@ (34193ae4 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34193964:	4293      	cmp	r3, r2
34193966:	d025      	beq.n	341939b4 <RCCEx_GetSDMMCCLKFreq+0x90>
34193968:	4a5e      	ldr	r2, [pc, #376]	@ (34193ae4 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
3419396a:	4293      	cmp	r3, r2
3419396c:	f200 80a9 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
34193970:	4a5d      	ldr	r2, [pc, #372]	@ (34193ae8 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34193972:	4293      	cmp	r3, r2
34193974:	d019      	beq.n	341939aa <RCCEx_GetSDMMCCLKFreq+0x86>
34193976:	4a5c      	ldr	r2, [pc, #368]	@ (34193ae8 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34193978:	4293      	cmp	r3, r2
3419397a:	f200 80a2 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
3419397e:	4a5b      	ldr	r2, [pc, #364]	@ (34193aec <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34193980:	4293      	cmp	r3, r2
34193982:	d012      	beq.n	341939aa <RCCEx_GetSDMMCCLKFreq+0x86>
34193984:	4a59      	ldr	r2, [pc, #356]	@ (34193aec <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34193986:	4293      	cmp	r3, r2
34193988:	f200 809b 	bhi.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
3419398c:	4a58      	ldr	r2, [pc, #352]	@ (34193af0 <RCCEx_GetSDMMCCLKFreq+0x1cc>)
3419398e:	4293      	cmp	r3, r2
34193990:	d003      	beq.n	3419399a <RCCEx_GetSDMMCCLKFreq+0x76>
34193992:	4a58      	ldr	r2, [pc, #352]	@ (34193af4 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
34193994:	4293      	cmp	r3, r2
34193996:	f040 8094 	bne.w	34193ac2 <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3419399a:	f7f8 ff01 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
3419399e:	4603      	mov	r3, r0
341939a0:	4618      	mov	r0, r3
341939a2:	f7fd feb5 	bl	34191710 <RCCEx_GetHCLKFreq>
341939a6:	60f8      	str	r0, [r7, #12]
      break;
341939a8:	e090      	b.n	34193acc <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341939aa:	2007      	movs	r0, #7
341939ac:	f7fe f99c 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
341939b0:	60f8      	str	r0, [r7, #12]
      break;
341939b2:	e08b      	b.n	34193acc <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
341939b4:	f7fa fa40 	bl	3418de38 <LL_RCC_IC4_IsEnabled>
341939b8:	4603      	mov	r3, r0
341939ba:	2b00      	cmp	r3, #0
341939bc:	f000 8083 	beq.w	34193ac6 <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
341939c0:	f7fa fa5c 	bl	3418de7c <LL_RCC_IC4_GetDivider>
341939c4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
341939c6:	f7fa fa4b 	bl	3418de60 <LL_RCC_IC4_GetSource>
341939ca:	4603      	mov	r3, r0
341939cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341939d0:	d029      	beq.n	34193a26 <RCCEx_GetSDMMCCLKFreq+0x102>
341939d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341939d6:	d82f      	bhi.n	34193a38 <RCCEx_GetSDMMCCLKFreq+0x114>
341939d8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341939dc:	d01a      	beq.n	34193a14 <RCCEx_GetSDMMCCLKFreq+0xf0>
341939de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341939e2:	d829      	bhi.n	34193a38 <RCCEx_GetSDMMCCLKFreq+0x114>
341939e4:	2b00      	cmp	r3, #0
341939e6:	d003      	beq.n	341939f0 <RCCEx_GetSDMMCCLKFreq+0xcc>
341939e8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341939ec:	d009      	beq.n	34193a02 <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341939ee:	e023      	b.n	34193a38 <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341939f0:	f7fd fd76 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341939f4:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
341939f6:	68fa      	ldr	r2, [r7, #12]
341939f8:	68bb      	ldr	r3, [r7, #8]
341939fa:	fbb2 f3f3 	udiv	r3, r2, r3
341939fe:	60fb      	str	r3, [r7, #12]
            break;
34193a00:	e01b      	b.n	34193a3a <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193a02:	f7fd fdb3 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193a06:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193a08:	68fa      	ldr	r2, [r7, #12]
34193a0a:	68bb      	ldr	r3, [r7, #8]
34193a0c:	fbb2 f3f3 	udiv	r3, r2, r3
34193a10:	60fb      	str	r3, [r7, #12]
            break;
34193a12:	e012      	b.n	34193a3a <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193a14:	f7fd fdf0 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193a18:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193a1a:	68fa      	ldr	r2, [r7, #12]
34193a1c:	68bb      	ldr	r3, [r7, #8]
34193a1e:	fbb2 f3f3 	udiv	r3, r2, r3
34193a22:	60fb      	str	r3, [r7, #12]
            break;
34193a24:	e009      	b.n	34193a3a <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193a26:	f7fd fe2d 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193a2a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193a2c:	68fa      	ldr	r2, [r7, #12]
34193a2e:	68bb      	ldr	r3, [r7, #8]
34193a30:	fbb2 f3f3 	udiv	r3, r2, r3
34193a34:	60fb      	str	r3, [r7, #12]
            break;
34193a36:	e000      	b.n	34193a3a <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
34193a38:	bf00      	nop
        }
      }
      break;
34193a3a:	e044      	b.n	34193ac6 <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
34193a3c:	f7fa fa3c 	bl	3418deb8 <LL_RCC_IC5_IsEnabled>
34193a40:	4603      	mov	r3, r0
34193a42:	2b00      	cmp	r3, #0
34193a44:	d041      	beq.n	34193aca <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
34193a46:	f7fa fa59 	bl	3418defc <LL_RCC_IC5_GetDivider>
34193a4a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
34193a4c:	f7fa fa48 	bl	3418dee0 <LL_RCC_IC5_GetSource>
34193a50:	4603      	mov	r3, r0
34193a52:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193a56:	d029      	beq.n	34193aac <RCCEx_GetSDMMCCLKFreq+0x188>
34193a58:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193a5c:	d82f      	bhi.n	34193abe <RCCEx_GetSDMMCCLKFreq+0x19a>
34193a5e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193a62:	d01a      	beq.n	34193a9a <RCCEx_GetSDMMCCLKFreq+0x176>
34193a64:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193a68:	d829      	bhi.n	34193abe <RCCEx_GetSDMMCCLKFreq+0x19a>
34193a6a:	2b00      	cmp	r3, #0
34193a6c:	d003      	beq.n	34193a76 <RCCEx_GetSDMMCCLKFreq+0x152>
34193a6e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193a72:	d009      	beq.n	34193a88 <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193a74:	e023      	b.n	34193abe <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193a76:	f7fd fd33 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193a7a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193a7c:	68fa      	ldr	r2, [r7, #12]
34193a7e:	68bb      	ldr	r3, [r7, #8]
34193a80:	fbb2 f3f3 	udiv	r3, r2, r3
34193a84:	60fb      	str	r3, [r7, #12]
            break;
34193a86:	e01b      	b.n	34193ac0 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193a88:	f7fd fd70 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193a8c:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193a8e:	68fa      	ldr	r2, [r7, #12]
34193a90:	68bb      	ldr	r3, [r7, #8]
34193a92:	fbb2 f3f3 	udiv	r3, r2, r3
34193a96:	60fb      	str	r3, [r7, #12]
            break;
34193a98:	e012      	b.n	34193ac0 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193a9a:	f7fd fdad 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193a9e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193aa0:	68fa      	ldr	r2, [r7, #12]
34193aa2:	68bb      	ldr	r3, [r7, #8]
34193aa4:	fbb2 f3f3 	udiv	r3, r2, r3
34193aa8:	60fb      	str	r3, [r7, #12]
            break;
34193aaa:	e009      	b.n	34193ac0 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193aac:	f7fd fdea 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193ab0:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34193ab2:	68fa      	ldr	r2, [r7, #12]
34193ab4:	68bb      	ldr	r3, [r7, #8]
34193ab6:	fbb2 f3f3 	udiv	r3, r2, r3
34193aba:	60fb      	str	r3, [r7, #12]
            break;
34193abc:	e000      	b.n	34193ac0 <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
34193abe:	bf00      	nop
        }
      }
      break;
34193ac0:	e003      	b.n	34193aca <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
34193ac2:	bf00      	nop
34193ac4:	e002      	b.n	34193acc <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34193ac6:	bf00      	nop
34193ac8:	e000      	b.n	34193acc <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34193aca:	bf00      	nop
  }

  return sdmmc_frequency;
34193acc:	68fb      	ldr	r3, [r7, #12]
}
34193ace:	4618      	mov	r0, r3
34193ad0:	3710      	adds	r7, #16
34193ad2:	46bd      	mov	sp, r7
34193ad4:	bd80      	pop	{r7, pc}
34193ad6:	bf00      	nop
34193ad8:	0303041c 	.word	0x0303041c
34193adc:	0303001c 	.word	0x0303001c
34193ae0:	0302041c 	.word	0x0302041c
34193ae4:	0302001c 	.word	0x0302001c
34193ae8:	0301041c 	.word	0x0301041c
34193aec:	0301001c 	.word	0x0301001c
34193af0:	0300001c 	.word	0x0300001c
34193af4:	0300041c 	.word	0x0300041c

34193af8 <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
34193af8:	b580      	push	{r7, lr}
34193afa:	b084      	sub	sp, #16
34193afc:	af00      	add	r7, sp, #0
34193afe:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
34193b00:	2300      	movs	r3, #0
34193b02:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34193b04:	6878      	ldr	r0, [r7, #4]
34193b06:	f7f9 fe3d 	bl	3418d784 <LL_RCC_GetSPDIFRXClockSource>
34193b0a:	4603      	mov	r3, r0
34193b0c:	2b06      	cmp	r3, #6
34193b0e:	f200 80c2 	bhi.w	34193c96 <RCCEx_GetSPDIFRXCLKFreq+0x19e>
34193b12:	a201      	add	r2, pc, #4	@ (adr r2, 34193b18 <RCCEx_GetSPDIFRXCLKFreq+0x20>)
34193b14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34193b18:	34193b35 	.word	0x34193b35
34193b1c:	34193b4d 	.word	0x34193b4d
34193b20:	34193b57 	.word	0x34193b57
34193b24:	34193bdf 	.word	0x34193bdf
34193b28:	34193c81 	.word	0x34193c81
34193b2c:	34193c65 	.word	0x34193c65
34193b30:	34193c91 	.word	0x34193c91
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34193b34:	f7f8 fe34 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34193b38:	4603      	mov	r3, r0
34193b3a:	4618      	mov	r0, r3
34193b3c:	f7fd fde8 	bl	34191710 <RCCEx_GetHCLKFreq>
34193b40:	4603      	mov	r3, r0
34193b42:	4618      	mov	r0, r3
34193b44:	f7fd fdf5 	bl	34191732 <RCCEx_GetPCLK1Freq>
34193b48:	60f8      	str	r0, [r7, #12]
      break;
34193b4a:	e0ad      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193b4c:	2007      	movs	r0, #7
34193b4e:	f7fe f8cb 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34193b52:	60f8      	str	r0, [r7, #12]
      break;
34193b54:	e0a8      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34193b56:	f7fa f9ef 	bl	3418df38 <LL_RCC_IC7_IsEnabled>
34193b5a:	4603      	mov	r3, r0
34193b5c:	2b00      	cmp	r3, #0
34193b5e:	f000 809c 	beq.w	34193c9a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34193b62:	f7fa fa0b 	bl	3418df7c <LL_RCC_IC7_GetDivider>
34193b66:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34193b68:	f7fa f9fa 	bl	3418df60 <LL_RCC_IC7_GetSource>
34193b6c:	4603      	mov	r3, r0
34193b6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193b72:	d029      	beq.n	34193bc8 <RCCEx_GetSPDIFRXCLKFreq+0xd0>
34193b74:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193b78:	d82f      	bhi.n	34193bda <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34193b7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193b7e:	d01a      	beq.n	34193bb6 <RCCEx_GetSPDIFRXCLKFreq+0xbe>
34193b80:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193b84:	d829      	bhi.n	34193bda <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34193b86:	2b00      	cmp	r3, #0
34193b88:	d003      	beq.n	34193b92 <RCCEx_GetSPDIFRXCLKFreq+0x9a>
34193b8a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193b8e:	d009      	beq.n	34193ba4 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193b90:	e023      	b.n	34193bda <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193b92:	f7fd fca5 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193b96:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193b98:	68fa      	ldr	r2, [r7, #12]
34193b9a:	68bb      	ldr	r3, [r7, #8]
34193b9c:	fbb2 f3f3 	udiv	r3, r2, r3
34193ba0:	60fb      	str	r3, [r7, #12]
            break;
34193ba2:	e01b      	b.n	34193bdc <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193ba4:	f7fd fce2 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193ba8:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193baa:	68fa      	ldr	r2, [r7, #12]
34193bac:	68bb      	ldr	r3, [r7, #8]
34193bae:	fbb2 f3f3 	udiv	r3, r2, r3
34193bb2:	60fb      	str	r3, [r7, #12]
            break;
34193bb4:	e012      	b.n	34193bdc <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193bb6:	f7fd fd1f 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193bba:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193bbc:	68fa      	ldr	r2, [r7, #12]
34193bbe:	68bb      	ldr	r3, [r7, #8]
34193bc0:	fbb2 f3f3 	udiv	r3, r2, r3
34193bc4:	60fb      	str	r3, [r7, #12]
            break;
34193bc6:	e009      	b.n	34193bdc <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193bc8:	f7fd fd5c 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193bcc:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193bce:	68fa      	ldr	r2, [r7, #12]
34193bd0:	68bb      	ldr	r3, [r7, #8]
34193bd2:	fbb2 f3f3 	udiv	r3, r2, r3
34193bd6:	60fb      	str	r3, [r7, #12]
            break;
34193bd8:	e000      	b.n	34193bdc <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
34193bda:	bf00      	nop
        }
      }
      break;
34193bdc:	e05d      	b.n	34193c9a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34193bde:	f7fa f9eb 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
34193be2:	4603      	mov	r3, r0
34193be4:	2b00      	cmp	r3, #0
34193be6:	d05a      	beq.n	34193c9e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34193be8:	f7fa fa08 	bl	3418dffc <LL_RCC_IC8_GetDivider>
34193bec:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34193bee:	f7fa f9f7 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
34193bf2:	4603      	mov	r3, r0
34193bf4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193bf8:	d029      	beq.n	34193c4e <RCCEx_GetSPDIFRXCLKFreq+0x156>
34193bfa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193bfe:	d82f      	bhi.n	34193c60 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34193c00:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193c04:	d01a      	beq.n	34193c3c <RCCEx_GetSPDIFRXCLKFreq+0x144>
34193c06:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193c0a:	d829      	bhi.n	34193c60 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34193c0c:	2b00      	cmp	r3, #0
34193c0e:	d003      	beq.n	34193c18 <RCCEx_GetSPDIFRXCLKFreq+0x120>
34193c10:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193c14:	d009      	beq.n	34193c2a <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193c16:	e023      	b.n	34193c60 <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193c18:	f7fd fc62 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34193c1c:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193c1e:	68fa      	ldr	r2, [r7, #12]
34193c20:	68bb      	ldr	r3, [r7, #8]
34193c22:	fbb2 f3f3 	udiv	r3, r2, r3
34193c26:	60fb      	str	r3, [r7, #12]
            break;
34193c28:	e01b      	b.n	34193c62 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193c2a:	f7fd fc9f 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34193c2e:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193c30:	68fa      	ldr	r2, [r7, #12]
34193c32:	68bb      	ldr	r3, [r7, #8]
34193c34:	fbb2 f3f3 	udiv	r3, r2, r3
34193c38:	60fb      	str	r3, [r7, #12]
            break;
34193c3a:	e012      	b.n	34193c62 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193c3c:	f7fd fcdc 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34193c40:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193c42:	68fa      	ldr	r2, [r7, #12]
34193c44:	68bb      	ldr	r3, [r7, #8]
34193c46:	fbb2 f3f3 	udiv	r3, r2, r3
34193c4a:	60fb      	str	r3, [r7, #12]
            break;
34193c4c:	e009      	b.n	34193c62 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193c4e:	f7fd fd19 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34193c52:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34193c54:	68fa      	ldr	r2, [r7, #12]
34193c56:	68bb      	ldr	r3, [r7, #8]
34193c58:	fbb2 f3f3 	udiv	r3, r2, r3
34193c5c:	60fb      	str	r3, [r7, #12]
            break;
34193c5e:	e000      	b.n	34193c62 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
34193c60:	bf00      	nop
        }
      }
      break;
34193c62:	e01c      	b.n	34193c9e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34193c64:	f7f9 f9c4 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34193c68:	4603      	mov	r3, r0
34193c6a:	2b00      	cmp	r3, #0
34193c6c:	d019      	beq.n	34193ca2 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193c6e:	f7f9 f9d1 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34193c72:	4603      	mov	r3, r0
34193c74:	09db      	lsrs	r3, r3, #7
34193c76:	4a0f      	ldr	r2, [pc, #60]	@ (34193cb4 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
34193c78:	fa22 f303 	lsr.w	r3, r2, r3
34193c7c:	60fb      	str	r3, [r7, #12]
      }
      break;
34193c7e:	e010      	b.n	34193ca2 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34193c80:	f7f9 f9d6 	bl	3418d030 <LL_RCC_MSI_IsReady>
34193c84:	4603      	mov	r3, r0
34193c86:	2b00      	cmp	r3, #0
34193c88:	d00d      	beq.n	34193ca6 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
34193c8a:	4b0b      	ldr	r3, [pc, #44]	@ (34193cb8 <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
34193c8c:	60fb      	str	r3, [r7, #12]
      }
      break;
34193c8e:	e00a      	b.n	34193ca6 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
34193c90:	4b0a      	ldr	r3, [pc, #40]	@ (34193cbc <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
34193c92:	60fb      	str	r3, [r7, #12]
      break;
34193c94:	e008      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
34193c96:	bf00      	nop
34193c98:	e006      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34193c9a:	bf00      	nop
34193c9c:	e004      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34193c9e:	bf00      	nop
34193ca0:	e002      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34193ca2:	bf00      	nop
34193ca4:	e000      	b.n	34193ca8 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34193ca6:	bf00      	nop
  }

  return spdifrx_frequency;
34193ca8:	68fb      	ldr	r3, [r7, #12]
}
34193caa:	4618      	mov	r0, r3
34193cac:	3710      	adds	r7, #16
34193cae:	46bd      	mov	sp, r7
34193cb0:	bd80      	pop	{r7, pc}
34193cb2:	bf00      	nop
34193cb4:	03d09000 	.word	0x03d09000
34193cb8:	003d0900 	.word	0x003d0900
34193cbc:	00bb8000 	.word	0x00bb8000

34193cc0 <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
34193cc0:	b580      	push	{r7, lr}
34193cc2:	b084      	sub	sp, #16
34193cc4:	af00      	add	r7, sp, #0
34193cc6:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
34193cc8:	2300      	movs	r3, #0
34193cca:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
34193ccc:	6878      	ldr	r0, [r7, #4]
34193cce:	f7f9 fd6b 	bl	3418d7a8 <LL_RCC_GetSPIClockSource>
34193cd2:	4603      	mov	r3, r0
34193cd4:	4aa7      	ldr	r2, [pc, #668]	@ (34193f74 <RCCEx_GetSPICLKFreq+0x2b4>)
34193cd6:	4293      	cmp	r3, r2
34193cd8:	f000 829e 	beq.w	34194218 <RCCEx_GetSPICLKFreq+0x558>
34193cdc:	4aa5      	ldr	r2, [pc, #660]	@ (34193f74 <RCCEx_GetSPICLKFreq+0x2b4>)
34193cde:	4293      	cmp	r3, r2
34193ce0:	f200 82a5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ce4:	4aa4      	ldr	r2, [pc, #656]	@ (34193f78 <RCCEx_GetSPICLKFreq+0x2b8>)
34193ce6:	4293      	cmp	r3, r2
34193ce8:	f000 8299 	beq.w	3419421e <RCCEx_GetSPICLKFreq+0x55e>
34193cec:	4aa2      	ldr	r2, [pc, #648]	@ (34193f78 <RCCEx_GetSPICLKFreq+0x2b8>)
34193cee:	4293      	cmp	r3, r2
34193cf0:	f200 829d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193cf4:	4aa1      	ldr	r2, [pc, #644]	@ (34193f7c <RCCEx_GetSPICLKFreq+0x2bc>)
34193cf6:	4293      	cmp	r3, r2
34193cf8:	f000 8291 	beq.w	3419421e <RCCEx_GetSPICLKFreq+0x55e>
34193cfc:	4a9f      	ldr	r2, [pc, #636]	@ (34193f7c <RCCEx_GetSPICLKFreq+0x2bc>)
34193cfe:	4293      	cmp	r3, r2
34193d00:	f200 8295 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d04:	4a9e      	ldr	r2, [pc, #632]	@ (34193f80 <RCCEx_GetSPICLKFreq+0x2c0>)
34193d06:	4293      	cmp	r3, r2
34193d08:	f000 8286 	beq.w	34194218 <RCCEx_GetSPICLKFreq+0x558>
34193d0c:	4a9c      	ldr	r2, [pc, #624]	@ (34193f80 <RCCEx_GetSPICLKFreq+0x2c0>)
34193d0e:	4293      	cmp	r3, r2
34193d10:	f200 828d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d14:	4a9b      	ldr	r2, [pc, #620]	@ (34193f84 <RCCEx_GetSPICLKFreq+0x2c4>)
34193d16:	4293      	cmp	r3, r2
34193d18:	f000 827e 	beq.w	34194218 <RCCEx_GetSPICLKFreq+0x558>
34193d1c:	4a99      	ldr	r2, [pc, #612]	@ (34193f84 <RCCEx_GetSPICLKFreq+0x2c4>)
34193d1e:	4293      	cmp	r3, r2
34193d20:	f200 8285 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d24:	4a98      	ldr	r2, [pc, #608]	@ (34193f88 <RCCEx_GetSPICLKFreq+0x2c8>)
34193d26:	4293      	cmp	r3, r2
34193d28:	f000 8276 	beq.w	34194218 <RCCEx_GetSPICLKFreq+0x558>
34193d2c:	4a96      	ldr	r2, [pc, #600]	@ (34193f88 <RCCEx_GetSPICLKFreq+0x2c8>)
34193d2e:	4293      	cmp	r3, r2
34193d30:	f200 827d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d34:	4a95      	ldr	r2, [pc, #596]	@ (34193f8c <RCCEx_GetSPICLKFreq+0x2cc>)
34193d36:	4293      	cmp	r3, r2
34193d38:	f000 8258 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d3c:	4a93      	ldr	r2, [pc, #588]	@ (34193f8c <RCCEx_GetSPICLKFreq+0x2cc>)
34193d3e:	4293      	cmp	r3, r2
34193d40:	f200 8275 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d44:	4a92      	ldr	r2, [pc, #584]	@ (34193f90 <RCCEx_GetSPICLKFreq+0x2d0>)
34193d46:	4293      	cmp	r3, r2
34193d48:	f000 8250 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d4c:	4a90      	ldr	r2, [pc, #576]	@ (34193f90 <RCCEx_GetSPICLKFreq+0x2d0>)
34193d4e:	4293      	cmp	r3, r2
34193d50:	f200 826d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d54:	4a8f      	ldr	r2, [pc, #572]	@ (34193f94 <RCCEx_GetSPICLKFreq+0x2d4>)
34193d56:	4293      	cmp	r3, r2
34193d58:	f000 8248 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d5c:	4a8d      	ldr	r2, [pc, #564]	@ (34193f94 <RCCEx_GetSPICLKFreq+0x2d4>)
34193d5e:	4293      	cmp	r3, r2
34193d60:	f200 8265 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d64:	4a8c      	ldr	r2, [pc, #560]	@ (34193f98 <RCCEx_GetSPICLKFreq+0x2d8>)
34193d66:	4293      	cmp	r3, r2
34193d68:	f000 8240 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d6c:	4a8a      	ldr	r2, [pc, #552]	@ (34193f98 <RCCEx_GetSPICLKFreq+0x2d8>)
34193d6e:	4293      	cmp	r3, r2
34193d70:	f200 825d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d74:	4a89      	ldr	r2, [pc, #548]	@ (34193f9c <RCCEx_GetSPICLKFreq+0x2dc>)
34193d76:	4293      	cmp	r3, r2
34193d78:	f000 8238 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d7c:	4a87      	ldr	r2, [pc, #540]	@ (34193f9c <RCCEx_GetSPICLKFreq+0x2dc>)
34193d7e:	4293      	cmp	r3, r2
34193d80:	f200 8255 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d84:	4a86      	ldr	r2, [pc, #536]	@ (34193fa0 <RCCEx_GetSPICLKFreq+0x2e0>)
34193d86:	4293      	cmp	r3, r2
34193d88:	f000 8230 	beq.w	341941ec <RCCEx_GetSPICLKFreq+0x52c>
34193d8c:	4a84      	ldr	r2, [pc, #528]	@ (34193fa0 <RCCEx_GetSPICLKFreq+0x2e0>)
34193d8e:	4293      	cmp	r3, r2
34193d90:	f200 824d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193d94:	4a83      	ldr	r2, [pc, #524]	@ (34193fa4 <RCCEx_GetSPICLKFreq+0x2e4>)
34193d96:	4293      	cmp	r3, r2
34193d98:	f000 8236 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193d9c:	4a81      	ldr	r2, [pc, #516]	@ (34193fa4 <RCCEx_GetSPICLKFreq+0x2e4>)
34193d9e:	4293      	cmp	r3, r2
34193da0:	f200 8245 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193da4:	4a80      	ldr	r2, [pc, #512]	@ (34193fa8 <RCCEx_GetSPICLKFreq+0x2e8>)
34193da6:	4293      	cmp	r3, r2
34193da8:	f000 822e 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193dac:	4a7e      	ldr	r2, [pc, #504]	@ (34193fa8 <RCCEx_GetSPICLKFreq+0x2e8>)
34193dae:	4293      	cmp	r3, r2
34193db0:	f200 823d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193db4:	4a7d      	ldr	r2, [pc, #500]	@ (34193fac <RCCEx_GetSPICLKFreq+0x2ec>)
34193db6:	4293      	cmp	r3, r2
34193db8:	f000 8226 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193dbc:	4a7b      	ldr	r2, [pc, #492]	@ (34193fac <RCCEx_GetSPICLKFreq+0x2ec>)
34193dbe:	4293      	cmp	r3, r2
34193dc0:	f200 8235 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193dc4:	4a7a      	ldr	r2, [pc, #488]	@ (34193fb0 <RCCEx_GetSPICLKFreq+0x2f0>)
34193dc6:	4293      	cmp	r3, r2
34193dc8:	f000 821e 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193dcc:	4a78      	ldr	r2, [pc, #480]	@ (34193fb0 <RCCEx_GetSPICLKFreq+0x2f0>)
34193dce:	4293      	cmp	r3, r2
34193dd0:	f200 822d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193dd4:	4a77      	ldr	r2, [pc, #476]	@ (34193fb4 <RCCEx_GetSPICLKFreq+0x2f4>)
34193dd6:	4293      	cmp	r3, r2
34193dd8:	f000 8216 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193ddc:	4a75      	ldr	r2, [pc, #468]	@ (34193fb4 <RCCEx_GetSPICLKFreq+0x2f4>)
34193dde:	4293      	cmp	r3, r2
34193de0:	f200 8225 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193de4:	4a74      	ldr	r2, [pc, #464]	@ (34193fb8 <RCCEx_GetSPICLKFreq+0x2f8>)
34193de6:	4293      	cmp	r3, r2
34193de8:	f000 820e 	beq.w	34194208 <RCCEx_GetSPICLKFreq+0x548>
34193dec:	4a72      	ldr	r2, [pc, #456]	@ (34193fb8 <RCCEx_GetSPICLKFreq+0x2f8>)
34193dee:	4293      	cmp	r3, r2
34193df0:	f200 821d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193df4:	4a71      	ldr	r2, [pc, #452]	@ (34193fbc <RCCEx_GetSPICLKFreq+0x2fc>)
34193df6:	4293      	cmp	r3, r2
34193df8:	f000 8171 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193dfc:	4a6f      	ldr	r2, [pc, #444]	@ (34193fbc <RCCEx_GetSPICLKFreq+0x2fc>)
34193dfe:	4293      	cmp	r3, r2
34193e00:	f200 8215 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e04:	4a6e      	ldr	r2, [pc, #440]	@ (34193fc0 <RCCEx_GetSPICLKFreq+0x300>)
34193e06:	4293      	cmp	r3, r2
34193e08:	f000 81ad 	beq.w	34194166 <RCCEx_GetSPICLKFreq+0x4a6>
34193e0c:	4a6c      	ldr	r2, [pc, #432]	@ (34193fc0 <RCCEx_GetSPICLKFreq+0x300>)
34193e0e:	4293      	cmp	r3, r2
34193e10:	f200 820d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e14:	4a6b      	ldr	r2, [pc, #428]	@ (34193fc4 <RCCEx_GetSPICLKFreq+0x304>)
34193e16:	4293      	cmp	r3, r2
34193e18:	f000 81a5 	beq.w	34194166 <RCCEx_GetSPICLKFreq+0x4a6>
34193e1c:	4a69      	ldr	r2, [pc, #420]	@ (34193fc4 <RCCEx_GetSPICLKFreq+0x304>)
34193e1e:	4293      	cmp	r3, r2
34193e20:	f200 8205 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e24:	4a68      	ldr	r2, [pc, #416]	@ (34193fc8 <RCCEx_GetSPICLKFreq+0x308>)
34193e26:	4293      	cmp	r3, r2
34193e28:	f000 8159 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193e2c:	4a66      	ldr	r2, [pc, #408]	@ (34193fc8 <RCCEx_GetSPICLKFreq+0x308>)
34193e2e:	4293      	cmp	r3, r2
34193e30:	f200 81fd 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e34:	4a65      	ldr	r2, [pc, #404]	@ (34193fcc <RCCEx_GetSPICLKFreq+0x30c>)
34193e36:	4293      	cmp	r3, r2
34193e38:	f000 8151 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193e3c:	4a63      	ldr	r2, [pc, #396]	@ (34193fcc <RCCEx_GetSPICLKFreq+0x30c>)
34193e3e:	4293      	cmp	r3, r2
34193e40:	f200 81f5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e44:	4a62      	ldr	r2, [pc, #392]	@ (34193fd0 <RCCEx_GetSPICLKFreq+0x310>)
34193e46:	4293      	cmp	r3, r2
34193e48:	f000 8149 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193e4c:	4a60      	ldr	r2, [pc, #384]	@ (34193fd0 <RCCEx_GetSPICLKFreq+0x310>)
34193e4e:	4293      	cmp	r3, r2
34193e50:	f200 81ed 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e54:	4a5f      	ldr	r2, [pc, #380]	@ (34193fd4 <RCCEx_GetSPICLKFreq+0x314>)
34193e56:	4293      	cmp	r3, r2
34193e58:	f000 80fd 	beq.w	34194056 <RCCEx_GetSPICLKFreq+0x396>
34193e5c:	4a5d      	ldr	r2, [pc, #372]	@ (34193fd4 <RCCEx_GetSPICLKFreq+0x314>)
34193e5e:	4293      	cmp	r3, r2
34193e60:	f200 81e5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e64:	4a5c      	ldr	r2, [pc, #368]	@ (34193fd8 <RCCEx_GetSPICLKFreq+0x318>)
34193e66:	4293      	cmp	r3, r2
34193e68:	f000 8139 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193e6c:	4a5a      	ldr	r2, [pc, #360]	@ (34193fd8 <RCCEx_GetSPICLKFreq+0x318>)
34193e6e:	4293      	cmp	r3, r2
34193e70:	f200 81dd 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e74:	4a59      	ldr	r2, [pc, #356]	@ (34193fdc <RCCEx_GetSPICLKFreq+0x31c>)
34193e76:	4293      	cmp	r3, r2
34193e78:	f000 8131 	beq.w	341940de <RCCEx_GetSPICLKFreq+0x41e>
34193e7c:	4a57      	ldr	r2, [pc, #348]	@ (34193fdc <RCCEx_GetSPICLKFreq+0x31c>)
34193e7e:	4293      	cmp	r3, r2
34193e80:	f200 81d5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e84:	4a56      	ldr	r2, [pc, #344]	@ (34193fe0 <RCCEx_GetSPICLKFreq+0x320>)
34193e86:	4293      	cmp	r3, r2
34193e88:	f000 80e5 	beq.w	34194056 <RCCEx_GetSPICLKFreq+0x396>
34193e8c:	4a54      	ldr	r2, [pc, #336]	@ (34193fe0 <RCCEx_GetSPICLKFreq+0x320>)
34193e8e:	4293      	cmp	r3, r2
34193e90:	f200 81cd 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193e94:	4a53      	ldr	r2, [pc, #332]	@ (34193fe4 <RCCEx_GetSPICLKFreq+0x324>)
34193e96:	4293      	cmp	r3, r2
34193e98:	f000 80dd 	beq.w	34194056 <RCCEx_GetSPICLKFreq+0x396>
34193e9c:	4a51      	ldr	r2, [pc, #324]	@ (34193fe4 <RCCEx_GetSPICLKFreq+0x324>)
34193e9e:	4293      	cmp	r3, r2
34193ea0:	f200 81c5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ea4:	4a50      	ldr	r2, [pc, #320]	@ (34193fe8 <RCCEx_GetSPICLKFreq+0x328>)
34193ea6:	4293      	cmp	r3, r2
34193ea8:	f000 80d5 	beq.w	34194056 <RCCEx_GetSPICLKFreq+0x396>
34193eac:	4a4e      	ldr	r2, [pc, #312]	@ (34193fe8 <RCCEx_GetSPICLKFreq+0x328>)
34193eae:	4293      	cmp	r3, r2
34193eb0:	f200 81bd 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193eb4:	4a4d      	ldr	r2, [pc, #308]	@ (34193fec <RCCEx_GetSPICLKFreq+0x32c>)
34193eb6:	4293      	cmp	r3, r2
34193eb8:	f000 80c8 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193ebc:	4a4b      	ldr	r2, [pc, #300]	@ (34193fec <RCCEx_GetSPICLKFreq+0x32c>)
34193ebe:	4293      	cmp	r3, r2
34193ec0:	f200 81b5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ec4:	4a4a      	ldr	r2, [pc, #296]	@ (34193ff0 <RCCEx_GetSPICLKFreq+0x330>)
34193ec6:	4293      	cmp	r3, r2
34193ec8:	f000 80c0 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193ecc:	4a48      	ldr	r2, [pc, #288]	@ (34193ff0 <RCCEx_GetSPICLKFreq+0x330>)
34193ece:	4293      	cmp	r3, r2
34193ed0:	f200 81ad 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ed4:	4a47      	ldr	r2, [pc, #284]	@ (34193ff4 <RCCEx_GetSPICLKFreq+0x334>)
34193ed6:	4293      	cmp	r3, r2
34193ed8:	f000 80b8 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193edc:	4a45      	ldr	r2, [pc, #276]	@ (34193ff4 <RCCEx_GetSPICLKFreq+0x334>)
34193ede:	4293      	cmp	r3, r2
34193ee0:	f200 81a5 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ee4:	4a44      	ldr	r2, [pc, #272]	@ (34193ff8 <RCCEx_GetSPICLKFreq+0x338>)
34193ee6:	4293      	cmp	r3, r2
34193ee8:	f000 80b0 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193eec:	4a42      	ldr	r2, [pc, #264]	@ (34193ff8 <RCCEx_GetSPICLKFreq+0x338>)
34193eee:	4293      	cmp	r3, r2
34193ef0:	f200 819d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193ef4:	4a41      	ldr	r2, [pc, #260]	@ (34193ffc <RCCEx_GetSPICLKFreq+0x33c>)
34193ef6:	4293      	cmp	r3, r2
34193ef8:	f000 80a8 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193efc:	4a3f      	ldr	r2, [pc, #252]	@ (34193ffc <RCCEx_GetSPICLKFreq+0x33c>)
34193efe:	4293      	cmp	r3, r2
34193f00:	f200 8195 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f04:	4a3e      	ldr	r2, [pc, #248]	@ (34194000 <RCCEx_GetSPICLKFreq+0x340>)
34193f06:	4293      	cmp	r3, r2
34193f08:	f000 80a0 	beq.w	3419404c <RCCEx_GetSPICLKFreq+0x38c>
34193f0c:	4a3c      	ldr	r2, [pc, #240]	@ (34194000 <RCCEx_GetSPICLKFreq+0x340>)
34193f0e:	4293      	cmp	r3, r2
34193f10:	f200 818d 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f14:	4a3b      	ldr	r2, [pc, #236]	@ (34194004 <RCCEx_GetSPICLKFreq+0x344>)
34193f16:	4293      	cmp	r3, r2
34193f18:	f000 808c 	beq.w	34194034 <RCCEx_GetSPICLKFreq+0x374>
34193f1c:	4a39      	ldr	r2, [pc, #228]	@ (34194004 <RCCEx_GetSPICLKFreq+0x344>)
34193f1e:	4293      	cmp	r3, r2
34193f20:	f200 8185 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f24:	4a38      	ldr	r2, [pc, #224]	@ (34194008 <RCCEx_GetSPICLKFreq+0x348>)
34193f26:	4293      	cmp	r3, r2
34193f28:	d078      	beq.n	3419401c <RCCEx_GetSPICLKFreq+0x35c>
34193f2a:	4a37      	ldr	r2, [pc, #220]	@ (34194008 <RCCEx_GetSPICLKFreq+0x348>)
34193f2c:	4293      	cmp	r3, r2
34193f2e:	f200 817e 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f32:	4a36      	ldr	r2, [pc, #216]	@ (3419400c <RCCEx_GetSPICLKFreq+0x34c>)
34193f34:	4293      	cmp	r3, r2
34193f36:	d071      	beq.n	3419401c <RCCEx_GetSPICLKFreq+0x35c>
34193f38:	4a34      	ldr	r2, [pc, #208]	@ (3419400c <RCCEx_GetSPICLKFreq+0x34c>)
34193f3a:	4293      	cmp	r3, r2
34193f3c:	f200 8177 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f40:	4a33      	ldr	r2, [pc, #204]	@ (34194010 <RCCEx_GetSPICLKFreq+0x350>)
34193f42:	4293      	cmp	r3, r2
34193f44:	d00a      	beq.n	34193f5c <RCCEx_GetSPICLKFreq+0x29c>
34193f46:	4a32      	ldr	r2, [pc, #200]	@ (34194010 <RCCEx_GetSPICLKFreq+0x350>)
34193f48:	4293      	cmp	r3, r2
34193f4a:	f200 8170 	bhi.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
34193f4e:	4a31      	ldr	r2, [pc, #196]	@ (34194014 <RCCEx_GetSPICLKFreq+0x354>)
34193f50:	4293      	cmp	r3, r2
34193f52:	d063      	beq.n	3419401c <RCCEx_GetSPICLKFreq+0x35c>
34193f54:	4a30      	ldr	r2, [pc, #192]	@ (34194018 <RCCEx_GetSPICLKFreq+0x358>)
34193f56:	4293      	cmp	r3, r2
34193f58:	f040 8169 	bne.w	3419422e <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34193f5c:	f7f8 fc20 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34193f60:	4603      	mov	r3, r0
34193f62:	4618      	mov	r0, r3
34193f64:	f7fd fbd4 	bl	34191710 <RCCEx_GetHCLKFreq>
34193f68:	4603      	mov	r3, r0
34193f6a:	4618      	mov	r0, r3
34193f6c:	f7fd fbe1 	bl	34191732 <RCCEx_GetPCLK1Freq>
34193f70:	60f8      	str	r0, [r7, #12]
      break;
34193f72:	e169      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
34193f74:	07061820 	.word	0x07061820
34193f78:	07061420 	.word	0x07061420
34193f7c:	07061020 	.word	0x07061020
34193f80:	07060c20 	.word	0x07060c20
34193f84:	07060820 	.word	0x07060820
34193f88:	07060420 	.word	0x07060420
34193f8c:	07051820 	.word	0x07051820
34193f90:	07051420 	.word	0x07051420
34193f94:	07051020 	.word	0x07051020
34193f98:	07050c20 	.word	0x07050c20
34193f9c:	07050820 	.word	0x07050820
34193fa0:	07050420 	.word	0x07050420
34193fa4:	07041820 	.word	0x07041820
34193fa8:	07041420 	.word	0x07041420
34193fac:	07041020 	.word	0x07041020
34193fb0:	07040c20 	.word	0x07040c20
34193fb4:	07040820 	.word	0x07040820
34193fb8:	07040420 	.word	0x07040420
34193fbc:	07031820 	.word	0x07031820
34193fc0:	07031420 	.word	0x07031420
34193fc4:	07031020 	.word	0x07031020
34193fc8:	07030c20 	.word	0x07030c20
34193fcc:	07030820 	.word	0x07030820
34193fd0:	07030420 	.word	0x07030420
34193fd4:	07021820 	.word	0x07021820
34193fd8:	07021420 	.word	0x07021420
34193fdc:	07021020 	.word	0x07021020
34193fe0:	07020c20 	.word	0x07020c20
34193fe4:	07020820 	.word	0x07020820
34193fe8:	07020420 	.word	0x07020420
34193fec:	07011820 	.word	0x07011820
34193ff0:	07011420 	.word	0x07011420
34193ff4:	07011020 	.word	0x07011020
34193ff8:	07010c20 	.word	0x07010c20
34193ffc:	07010820 	.word	0x07010820
34194000:	07010420 	.word	0x07010420
34194004:	07001820 	.word	0x07001820
34194008:	07001420 	.word	0x07001420
3419400c:	07001020 	.word	0x07001020
34194010:	07000c20 	.word	0x07000c20
34194014:	07000420 	.word	0x07000420
34194018:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3419401c:	f7f8 fbc0 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34194020:	4603      	mov	r3, r0
34194022:	4618      	mov	r0, r3
34194024:	f7fd fb74 	bl	34191710 <RCCEx_GetHCLKFreq>
34194028:	4603      	mov	r3, r0
3419402a:	4618      	mov	r0, r3
3419402c:	f7fd fb91 	bl	34191752 <RCCEx_GetPCLK2Freq>
34194030:	60f8      	str	r0, [r7, #12]
      break;
34194032:	e109      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194034:	f7f8 fbb4 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34194038:	4603      	mov	r3, r0
3419403a:	4618      	mov	r0, r3
3419403c:	f7fd fb68 	bl	34191710 <RCCEx_GetHCLKFreq>
34194040:	4603      	mov	r3, r0
34194042:	4618      	mov	r0, r3
34194044:	f7fd fb96 	bl	34191774 <RCCEx_GetPCLK4Freq>
34194048:	60f8      	str	r0, [r7, #12]
      break;
3419404a:	e0fd      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419404c:	2007      	movs	r0, #7
3419404e:	f7fd fe4b 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34194052:	60f8      	str	r0, [r7, #12]
      break;
34194054:	e0f8      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34194056:	f7f9 ffaf 	bl	3418dfb8 <LL_RCC_IC8_IsEnabled>
3419405a:	4603      	mov	r3, r0
3419405c:	2b00      	cmp	r3, #0
3419405e:	f000 80e8 	beq.w	34194232 <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34194062:	f7f9 ffcb 	bl	3418dffc <LL_RCC_IC8_GetDivider>
34194066:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34194068:	f7f9 ffba 	bl	3418dfe0 <LL_RCC_IC8_GetSource>
3419406c:	4603      	mov	r3, r0
3419406e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194072:	d029      	beq.n	341940c8 <RCCEx_GetSPICLKFreq+0x408>
34194074:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194078:	d82f      	bhi.n	341940da <RCCEx_GetSPICLKFreq+0x41a>
3419407a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419407e:	d01a      	beq.n	341940b6 <RCCEx_GetSPICLKFreq+0x3f6>
34194080:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194084:	d829      	bhi.n	341940da <RCCEx_GetSPICLKFreq+0x41a>
34194086:	2b00      	cmp	r3, #0
34194088:	d003      	beq.n	34194092 <RCCEx_GetSPICLKFreq+0x3d2>
3419408a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419408e:	d009      	beq.n	341940a4 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194090:	e023      	b.n	341940da <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194092:	f7fd fa25 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194096:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34194098:	68fa      	ldr	r2, [r7, #12]
3419409a:	68bb      	ldr	r3, [r7, #8]
3419409c:	fbb2 f3f3 	udiv	r3, r2, r3
341940a0:	60fb      	str	r3, [r7, #12]
            break;
341940a2:	e01b      	b.n	341940dc <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341940a4:	f7fd fa62 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341940a8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341940aa:	68fa      	ldr	r2, [r7, #12]
341940ac:	68bb      	ldr	r3, [r7, #8]
341940ae:	fbb2 f3f3 	udiv	r3, r2, r3
341940b2:	60fb      	str	r3, [r7, #12]
            break;
341940b4:	e012      	b.n	341940dc <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341940b6:	f7fd fa9f 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341940ba:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341940bc:	68fa      	ldr	r2, [r7, #12]
341940be:	68bb      	ldr	r3, [r7, #8]
341940c0:	fbb2 f3f3 	udiv	r3, r2, r3
341940c4:	60fb      	str	r3, [r7, #12]
            break;
341940c6:	e009      	b.n	341940dc <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341940c8:	f7fd fadc 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341940cc:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341940ce:	68fa      	ldr	r2, [r7, #12]
341940d0:	68bb      	ldr	r3, [r7, #8]
341940d2:	fbb2 f3f3 	udiv	r3, r2, r3
341940d6:	60fb      	str	r3, [r7, #12]
            break;
341940d8:	e000      	b.n	341940dc <RCCEx_GetSPICLKFreq+0x41c>
            break;
341940da:	bf00      	nop
        }
      }
      break;
341940dc:	e0a9      	b.n	34194232 <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
341940de:	f7f9 ffab 	bl	3418e038 <LL_RCC_IC9_IsEnabled>
341940e2:	4603      	mov	r3, r0
341940e4:	2b00      	cmp	r3, #0
341940e6:	f000 80a6 	beq.w	34194236 <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
341940ea:	f7f9 ffc7 	bl	3418e07c <LL_RCC_IC9_GetDivider>
341940ee:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
341940f0:	f7f9 ffb6 	bl	3418e060 <LL_RCC_IC9_GetSource>
341940f4:	4603      	mov	r3, r0
341940f6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341940fa:	d029      	beq.n	34194150 <RCCEx_GetSPICLKFreq+0x490>
341940fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194100:	d82f      	bhi.n	34194162 <RCCEx_GetSPICLKFreq+0x4a2>
34194102:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194106:	d01a      	beq.n	3419413e <RCCEx_GetSPICLKFreq+0x47e>
34194108:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419410c:	d829      	bhi.n	34194162 <RCCEx_GetSPICLKFreq+0x4a2>
3419410e:	2b00      	cmp	r3, #0
34194110:	d003      	beq.n	3419411a <RCCEx_GetSPICLKFreq+0x45a>
34194112:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194116:	d009      	beq.n	3419412c <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194118:	e023      	b.n	34194162 <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419411a:	f7fd f9e1 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3419411e:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34194120:	68fa      	ldr	r2, [r7, #12]
34194122:	68bb      	ldr	r3, [r7, #8]
34194124:	fbb2 f3f3 	udiv	r3, r2, r3
34194128:	60fb      	str	r3, [r7, #12]
            break;
3419412a:	e01b      	b.n	34194164 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419412c:	f7fd fa1e 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194130:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34194132:	68fa      	ldr	r2, [r7, #12]
34194134:	68bb      	ldr	r3, [r7, #8]
34194136:	fbb2 f3f3 	udiv	r3, r2, r3
3419413a:	60fb      	str	r3, [r7, #12]
            break;
3419413c:	e012      	b.n	34194164 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3419413e:	f7fd fa5b 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34194142:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34194144:	68fa      	ldr	r2, [r7, #12]
34194146:	68bb      	ldr	r3, [r7, #8]
34194148:	fbb2 f3f3 	udiv	r3, r2, r3
3419414c:	60fb      	str	r3, [r7, #12]
            break;
3419414e:	e009      	b.n	34194164 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194150:	f7fd fa98 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194154:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34194156:	68fa      	ldr	r2, [r7, #12]
34194158:	68bb      	ldr	r3, [r7, #8]
3419415a:	fbb2 f3f3 	udiv	r3, r2, r3
3419415e:	60fb      	str	r3, [r7, #12]
            break;
34194160:	e000      	b.n	34194164 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
34194162:	bf00      	nop
        }
      }
      break;
34194164:	e067      	b.n	34194236 <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
34194166:	f7fa f867 	bl	3418e238 <LL_RCC_IC14_IsEnabled>
3419416a:	4603      	mov	r3, r0
3419416c:	2b00      	cmp	r3, #0
3419416e:	d064      	beq.n	3419423a <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34194170:	f7fa f884 	bl	3418e27c <LL_RCC_IC14_GetDivider>
34194174:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34194176:	f7fa f873 	bl	3418e260 <LL_RCC_IC14_GetSource>
3419417a:	4603      	mov	r3, r0
3419417c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194180:	d029      	beq.n	341941d6 <RCCEx_GetSPICLKFreq+0x516>
34194182:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194186:	d82f      	bhi.n	341941e8 <RCCEx_GetSPICLKFreq+0x528>
34194188:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419418c:	d01a      	beq.n	341941c4 <RCCEx_GetSPICLKFreq+0x504>
3419418e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194192:	d829      	bhi.n	341941e8 <RCCEx_GetSPICLKFreq+0x528>
34194194:	2b00      	cmp	r3, #0
34194196:	d003      	beq.n	341941a0 <RCCEx_GetSPICLKFreq+0x4e0>
34194198:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419419c:	d009      	beq.n	341941b2 <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3419419e:	e023      	b.n	341941e8 <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341941a0:	f7fd f99e 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341941a4:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341941a6:	68fa      	ldr	r2, [r7, #12]
341941a8:	68bb      	ldr	r3, [r7, #8]
341941aa:	fbb2 f3f3 	udiv	r3, r2, r3
341941ae:	60fb      	str	r3, [r7, #12]
            break;
341941b0:	e01b      	b.n	341941ea <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341941b2:	f7fd f9db 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341941b6:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341941b8:	68fa      	ldr	r2, [r7, #12]
341941ba:	68bb      	ldr	r3, [r7, #8]
341941bc:	fbb2 f3f3 	udiv	r3, r2, r3
341941c0:	60fb      	str	r3, [r7, #12]
            break;
341941c2:	e012      	b.n	341941ea <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341941c4:	f7fd fa18 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341941c8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341941ca:	68fa      	ldr	r2, [r7, #12]
341941cc:	68bb      	ldr	r3, [r7, #8]
341941ce:	fbb2 f3f3 	udiv	r3, r2, r3
341941d2:	60fb      	str	r3, [r7, #12]
            break;
341941d4:	e009      	b.n	341941ea <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341941d6:	f7fd fa55 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341941da:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341941dc:	68fa      	ldr	r2, [r7, #12]
341941de:	68bb      	ldr	r3, [r7, #8]
341941e0:	fbb2 f3f3 	udiv	r3, r2, r3
341941e4:	60fb      	str	r3, [r7, #12]
            break;
341941e6:	e000      	b.n	341941ea <RCCEx_GetSPICLKFreq+0x52a>
            break;
341941e8:	bf00      	nop
        }
      }
      break;
341941ea:	e026      	b.n	3419423a <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
341941ec:	f7f8 ff00 	bl	3418cff0 <LL_RCC_HSI_IsReady>
341941f0:	4603      	mov	r3, r0
341941f2:	2b00      	cmp	r3, #0
341941f4:	d023      	beq.n	3419423e <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341941f6:	f7f8 ff0d 	bl	3418d014 <LL_RCC_HSI_GetDivider>
341941fa:	4603      	mov	r3, r0
341941fc:	09db      	lsrs	r3, r3, #7
341941fe:	4a15      	ldr	r2, [pc, #84]	@ (34194254 <RCCEx_GetSPICLKFreq+0x594>)
34194200:	fa22 f303 	lsr.w	r3, r2, r3
34194204:	60fb      	str	r3, [r7, #12]
      }
      break;
34194206:	e01a      	b.n	3419423e <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34194208:	f7f8 ff12 	bl	3418d030 <LL_RCC_MSI_IsReady>
3419420c:	4603      	mov	r3, r0
3419420e:	2b00      	cmp	r3, #0
34194210:	d017      	beq.n	34194242 <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
34194212:	4b11      	ldr	r3, [pc, #68]	@ (34194258 <RCCEx_GetSPICLKFreq+0x598>)
34194214:	60fb      	str	r3, [r7, #12]
      }
      break;
34194216:	e014      	b.n	34194242 <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
34194218:	4b10      	ldr	r3, [pc, #64]	@ (3419425c <RCCEx_GetSPICLKFreq+0x59c>)
3419421a:	60fb      	str	r3, [r7, #12]
      break;
3419421c:	e014      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
3419421e:	f7f8 fed5 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34194222:	4603      	mov	r3, r0
34194224:	2b00      	cmp	r3, #0
34194226:	d00e      	beq.n	34194246 <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
34194228:	4b0d      	ldr	r3, [pc, #52]	@ (34194260 <RCCEx_GetSPICLKFreq+0x5a0>)
3419422a:	60fb      	str	r3, [r7, #12]
      }
      break;
3419422c:	e00b      	b.n	34194246 <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
3419422e:	bf00      	nop
34194230:	e00a      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
34194232:	bf00      	nop
34194234:	e008      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
34194236:	bf00      	nop
34194238:	e006      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
3419423a:	bf00      	nop
3419423c:	e004      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
3419423e:	bf00      	nop
34194240:	e002      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
34194242:	bf00      	nop
34194244:	e000      	b.n	34194248 <RCCEx_GetSPICLKFreq+0x588>
      break;
34194246:	bf00      	nop
  }

  return spi_frequency;
34194248:	68fb      	ldr	r3, [r7, #12]
}
3419424a:	4618      	mov	r0, r3
3419424c:	3710      	adds	r7, #16
3419424e:	46bd      	mov	sp, r7
34194250:	bd80      	pop	{r7, pc}
34194252:	bf00      	nop
34194254:	03d09000 	.word	0x03d09000
34194258:	003d0900 	.word	0x003d0900
3419425c:	00bb8000 	.word	0x00bb8000
34194260:	02dc6c00 	.word	0x02dc6c00

34194264 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
34194264:	b580      	push	{r7, lr}
34194266:	b084      	sub	sp, #16
34194268:	af00      	add	r7, sp, #0
3419426a:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3419426c:	2300      	movs	r3, #0
3419426e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
34194270:	6878      	ldr	r0, [r7, #4]
34194272:	f7f9 fab1 	bl	3418d7d8 <LL_RCC_GetUARTClockSource>
34194276:	4603      	mov	r3, r0
34194278:	4aa2      	ldr	r2, [pc, #648]	@ (34194504 <RCCEx_GetUARTCLKFreq+0x2a0>)
3419427a:	4293      	cmp	r3, r2
3419427c:	f000 81e8 	beq.w	34194650 <RCCEx_GetUARTCLKFreq+0x3ec>
34194280:	4aa0      	ldr	r2, [pc, #640]	@ (34194504 <RCCEx_GetUARTCLKFreq+0x2a0>)
34194282:	4293      	cmp	r3, r2
34194284:	f200 8203 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194288:	4a9f      	ldr	r2, [pc, #636]	@ (34194508 <RCCEx_GetUARTCLKFreq+0x2a4>)
3419428a:	4293      	cmp	r3, r2
3419428c:	f000 81e0 	beq.w	34194650 <RCCEx_GetUARTCLKFreq+0x3ec>
34194290:	4a9d      	ldr	r2, [pc, #628]	@ (34194508 <RCCEx_GetUARTCLKFreq+0x2a4>)
34194292:	4293      	cmp	r3, r2
34194294:	f200 81fb 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194298:	4a9c      	ldr	r2, [pc, #624]	@ (3419450c <RCCEx_GetUARTCLKFreq+0x2a8>)
3419429a:	4293      	cmp	r3, r2
3419429c:	f000 81d8 	beq.w	34194650 <RCCEx_GetUARTCLKFreq+0x3ec>
341942a0:	4a9a      	ldr	r2, [pc, #616]	@ (3419450c <RCCEx_GetUARTCLKFreq+0x2a8>)
341942a2:	4293      	cmp	r3, r2
341942a4:	f200 81f3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942a8:	4a99      	ldr	r2, [pc, #612]	@ (34194510 <RCCEx_GetUARTCLKFreq+0x2ac>)
341942aa:	4293      	cmp	r3, r2
341942ac:	f000 81d0 	beq.w	34194650 <RCCEx_GetUARTCLKFreq+0x3ec>
341942b0:	4a97      	ldr	r2, [pc, #604]	@ (34194510 <RCCEx_GetUARTCLKFreq+0x2ac>)
341942b2:	4293      	cmp	r3, r2
341942b4:	f200 81eb 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942b8:	4a96      	ldr	r2, [pc, #600]	@ (34194514 <RCCEx_GetUARTCLKFreq+0x2b0>)
341942ba:	4293      	cmp	r3, r2
341942bc:	f000 81c8 	beq.w	34194650 <RCCEx_GetUARTCLKFreq+0x3ec>
341942c0:	4a94      	ldr	r2, [pc, #592]	@ (34194514 <RCCEx_GetUARTCLKFreq+0x2b0>)
341942c2:	4293      	cmp	r3, r2
341942c4:	f200 81e3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942c8:	4a93      	ldr	r2, [pc, #588]	@ (34194518 <RCCEx_GetUARTCLKFreq+0x2b4>)
341942ca:	4293      	cmp	r3, r2
341942cc:	f000 81ce 	beq.w	3419466c <RCCEx_GetUARTCLKFreq+0x408>
341942d0:	4a91      	ldr	r2, [pc, #580]	@ (34194518 <RCCEx_GetUARTCLKFreq+0x2b4>)
341942d2:	4293      	cmp	r3, r2
341942d4:	f200 81db 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942d8:	4a90      	ldr	r2, [pc, #576]	@ (3419451c <RCCEx_GetUARTCLKFreq+0x2b8>)
341942da:	4293      	cmp	r3, r2
341942dc:	f000 81c6 	beq.w	3419466c <RCCEx_GetUARTCLKFreq+0x408>
341942e0:	4a8e      	ldr	r2, [pc, #568]	@ (3419451c <RCCEx_GetUARTCLKFreq+0x2b8>)
341942e2:	4293      	cmp	r3, r2
341942e4:	f200 81d3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942e8:	4a8d      	ldr	r2, [pc, #564]	@ (34194520 <RCCEx_GetUARTCLKFreq+0x2bc>)
341942ea:	4293      	cmp	r3, r2
341942ec:	f000 81be 	beq.w	3419466c <RCCEx_GetUARTCLKFreq+0x408>
341942f0:	4a8b      	ldr	r2, [pc, #556]	@ (34194520 <RCCEx_GetUARTCLKFreq+0x2bc>)
341942f2:	4293      	cmp	r3, r2
341942f4:	f200 81cb 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341942f8:	4a8a      	ldr	r2, [pc, #552]	@ (34194524 <RCCEx_GetUARTCLKFreq+0x2c0>)
341942fa:	4293      	cmp	r3, r2
341942fc:	f000 81b6 	beq.w	3419466c <RCCEx_GetUARTCLKFreq+0x408>
34194300:	4a88      	ldr	r2, [pc, #544]	@ (34194524 <RCCEx_GetUARTCLKFreq+0x2c0>)
34194302:	4293      	cmp	r3, r2
34194304:	f200 81c3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194308:	4a87      	ldr	r2, [pc, #540]	@ (34194528 <RCCEx_GetUARTCLKFreq+0x2c4>)
3419430a:	4293      	cmp	r3, r2
3419430c:	f000 81ae 	beq.w	3419466c <RCCEx_GetUARTCLKFreq+0x408>
34194310:	4a85      	ldr	r2, [pc, #532]	@ (34194528 <RCCEx_GetUARTCLKFreq+0x2c4>)
34194312:	4293      	cmp	r3, r2
34194314:	f200 81bb 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194318:	4a84      	ldr	r2, [pc, #528]	@ (3419452c <RCCEx_GetUARTCLKFreq+0x2c8>)
3419431a:	4293      	cmp	r3, r2
3419431c:	f000 81ae 	beq.w	3419467c <RCCEx_GetUARTCLKFreq+0x418>
34194320:	4a82      	ldr	r2, [pc, #520]	@ (3419452c <RCCEx_GetUARTCLKFreq+0x2c8>)
34194322:	4293      	cmp	r3, r2
34194324:	f200 81b3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194328:	4a81      	ldr	r2, [pc, #516]	@ (34194530 <RCCEx_GetUARTCLKFreq+0x2cc>)
3419432a:	4293      	cmp	r3, r2
3419432c:	f000 81a6 	beq.w	3419467c <RCCEx_GetUARTCLKFreq+0x418>
34194330:	4a7f      	ldr	r2, [pc, #508]	@ (34194530 <RCCEx_GetUARTCLKFreq+0x2cc>)
34194332:	4293      	cmp	r3, r2
34194334:	f200 81ab 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194338:	4a7e      	ldr	r2, [pc, #504]	@ (34194534 <RCCEx_GetUARTCLKFreq+0x2d0>)
3419433a:	4293      	cmp	r3, r2
3419433c:	f000 819e 	beq.w	3419467c <RCCEx_GetUARTCLKFreq+0x418>
34194340:	4a7c      	ldr	r2, [pc, #496]	@ (34194534 <RCCEx_GetUARTCLKFreq+0x2d0>)
34194342:	4293      	cmp	r3, r2
34194344:	f200 81a3 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194348:	4a7b      	ldr	r2, [pc, #492]	@ (34194538 <RCCEx_GetUARTCLKFreq+0x2d4>)
3419434a:	4293      	cmp	r3, r2
3419434c:	f000 8196 	beq.w	3419467c <RCCEx_GetUARTCLKFreq+0x418>
34194350:	4a79      	ldr	r2, [pc, #484]	@ (34194538 <RCCEx_GetUARTCLKFreq+0x2d4>)
34194352:	4293      	cmp	r3, r2
34194354:	f200 819b 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194358:	4a78      	ldr	r2, [pc, #480]	@ (3419453c <RCCEx_GetUARTCLKFreq+0x2d8>)
3419435a:	4293      	cmp	r3, r2
3419435c:	f000 818e 	beq.w	3419467c <RCCEx_GetUARTCLKFreq+0x418>
34194360:	4a76      	ldr	r2, [pc, #472]	@ (3419453c <RCCEx_GetUARTCLKFreq+0x2d8>)
34194362:	4293      	cmp	r3, r2
34194364:	f200 8193 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194368:	4a75      	ldr	r2, [pc, #468]	@ (34194540 <RCCEx_GetUARTCLKFreq+0x2dc>)
3419436a:	4293      	cmp	r3, r2
3419436c:	f000 812d 	beq.w	341945ca <RCCEx_GetUARTCLKFreq+0x366>
34194370:	4a73      	ldr	r2, [pc, #460]	@ (34194540 <RCCEx_GetUARTCLKFreq+0x2dc>)
34194372:	4293      	cmp	r3, r2
34194374:	f200 818b 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194378:	4a72      	ldr	r2, [pc, #456]	@ (34194544 <RCCEx_GetUARTCLKFreq+0x2e0>)
3419437a:	4293      	cmp	r3, r2
3419437c:	f000 8125 	beq.w	341945ca <RCCEx_GetUARTCLKFreq+0x366>
34194380:	4a70      	ldr	r2, [pc, #448]	@ (34194544 <RCCEx_GetUARTCLKFreq+0x2e0>)
34194382:	4293      	cmp	r3, r2
34194384:	f200 8183 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194388:	4a6f      	ldr	r2, [pc, #444]	@ (34194548 <RCCEx_GetUARTCLKFreq+0x2e4>)
3419438a:	4293      	cmp	r3, r2
3419438c:	f000 811d 	beq.w	341945ca <RCCEx_GetUARTCLKFreq+0x366>
34194390:	4a6d      	ldr	r2, [pc, #436]	@ (34194548 <RCCEx_GetUARTCLKFreq+0x2e4>)
34194392:	4293      	cmp	r3, r2
34194394:	f200 817b 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194398:	4a6c      	ldr	r2, [pc, #432]	@ (3419454c <RCCEx_GetUARTCLKFreq+0x2e8>)
3419439a:	4293      	cmp	r3, r2
3419439c:	f000 8115 	beq.w	341945ca <RCCEx_GetUARTCLKFreq+0x366>
341943a0:	4a6a      	ldr	r2, [pc, #424]	@ (3419454c <RCCEx_GetUARTCLKFreq+0x2e8>)
341943a2:	4293      	cmp	r3, r2
341943a4:	f200 8173 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943a8:	4a69      	ldr	r2, [pc, #420]	@ (34194550 <RCCEx_GetUARTCLKFreq+0x2ec>)
341943aa:	4293      	cmp	r3, r2
341943ac:	f000 810d 	beq.w	341945ca <RCCEx_GetUARTCLKFreq+0x366>
341943b0:	4a67      	ldr	r2, [pc, #412]	@ (34194550 <RCCEx_GetUARTCLKFreq+0x2ec>)
341943b2:	4293      	cmp	r3, r2
341943b4:	f200 816b 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943b8:	4a66      	ldr	r2, [pc, #408]	@ (34194554 <RCCEx_GetUARTCLKFreq+0x2f0>)
341943ba:	4293      	cmp	r3, r2
341943bc:	d07b      	beq.n	341944b6 <RCCEx_GetUARTCLKFreq+0x252>
341943be:	4a65      	ldr	r2, [pc, #404]	@ (34194554 <RCCEx_GetUARTCLKFreq+0x2f0>)
341943c0:	4293      	cmp	r3, r2
341943c2:	f200 8164 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943c6:	4a64      	ldr	r2, [pc, #400]	@ (34194558 <RCCEx_GetUARTCLKFreq+0x2f4>)
341943c8:	4293      	cmp	r3, r2
341943ca:	d074      	beq.n	341944b6 <RCCEx_GetUARTCLKFreq+0x252>
341943cc:	4a62      	ldr	r2, [pc, #392]	@ (34194558 <RCCEx_GetUARTCLKFreq+0x2f4>)
341943ce:	4293      	cmp	r3, r2
341943d0:	f200 815d 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943d4:	4a61      	ldr	r2, [pc, #388]	@ (3419455c <RCCEx_GetUARTCLKFreq+0x2f8>)
341943d6:	4293      	cmp	r3, r2
341943d8:	d06d      	beq.n	341944b6 <RCCEx_GetUARTCLKFreq+0x252>
341943da:	4a60      	ldr	r2, [pc, #384]	@ (3419455c <RCCEx_GetUARTCLKFreq+0x2f8>)
341943dc:	4293      	cmp	r3, r2
341943de:	f200 8156 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943e2:	4a5f      	ldr	r2, [pc, #380]	@ (34194560 <RCCEx_GetUARTCLKFreq+0x2fc>)
341943e4:	4293      	cmp	r3, r2
341943e6:	d066      	beq.n	341944b6 <RCCEx_GetUARTCLKFreq+0x252>
341943e8:	4a5d      	ldr	r2, [pc, #372]	@ (34194560 <RCCEx_GetUARTCLKFreq+0x2fc>)
341943ea:	4293      	cmp	r3, r2
341943ec:	f200 814f 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943f0:	4a5c      	ldr	r2, [pc, #368]	@ (34194564 <RCCEx_GetUARTCLKFreq+0x300>)
341943f2:	4293      	cmp	r3, r2
341943f4:	d05f      	beq.n	341944b6 <RCCEx_GetUARTCLKFreq+0x252>
341943f6:	4a5b      	ldr	r2, [pc, #364]	@ (34194564 <RCCEx_GetUARTCLKFreq+0x300>)
341943f8:	4293      	cmp	r3, r2
341943fa:	f200 8148 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
341943fe:	4a5a      	ldr	r2, [pc, #360]	@ (34194568 <RCCEx_GetUARTCLKFreq+0x304>)
34194400:	4293      	cmp	r3, r2
34194402:	d053      	beq.n	341944ac <RCCEx_GetUARTCLKFreq+0x248>
34194404:	4a58      	ldr	r2, [pc, #352]	@ (34194568 <RCCEx_GetUARTCLKFreq+0x304>)
34194406:	4293      	cmp	r3, r2
34194408:	f200 8141 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
3419440c:	4a57      	ldr	r2, [pc, #348]	@ (3419456c <RCCEx_GetUARTCLKFreq+0x308>)
3419440e:	4293      	cmp	r3, r2
34194410:	d04c      	beq.n	341944ac <RCCEx_GetUARTCLKFreq+0x248>
34194412:	4a56      	ldr	r2, [pc, #344]	@ (3419456c <RCCEx_GetUARTCLKFreq+0x308>)
34194414:	4293      	cmp	r3, r2
34194416:	f200 813a 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
3419441a:	4a55      	ldr	r2, [pc, #340]	@ (34194570 <RCCEx_GetUARTCLKFreq+0x30c>)
3419441c:	4293      	cmp	r3, r2
3419441e:	d045      	beq.n	341944ac <RCCEx_GetUARTCLKFreq+0x248>
34194420:	4a53      	ldr	r2, [pc, #332]	@ (34194570 <RCCEx_GetUARTCLKFreq+0x30c>)
34194422:	4293      	cmp	r3, r2
34194424:	f200 8133 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194428:	4a52      	ldr	r2, [pc, #328]	@ (34194574 <RCCEx_GetUARTCLKFreq+0x310>)
3419442a:	4293      	cmp	r3, r2
3419442c:	d03e      	beq.n	341944ac <RCCEx_GetUARTCLKFreq+0x248>
3419442e:	4a51      	ldr	r2, [pc, #324]	@ (34194574 <RCCEx_GetUARTCLKFreq+0x310>)
34194430:	4293      	cmp	r3, r2
34194432:	f200 812c 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194436:	4a50      	ldr	r2, [pc, #320]	@ (34194578 <RCCEx_GetUARTCLKFreq+0x314>)
34194438:	4293      	cmp	r3, r2
3419443a:	d037      	beq.n	341944ac <RCCEx_GetUARTCLKFreq+0x248>
3419443c:	4a4e      	ldr	r2, [pc, #312]	@ (34194578 <RCCEx_GetUARTCLKFreq+0x314>)
3419443e:	4293      	cmp	r3, r2
34194440:	f200 8125 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194444:	4a4d      	ldr	r2, [pc, #308]	@ (3419457c <RCCEx_GetUARTCLKFreq+0x318>)
34194446:	4293      	cmp	r3, r2
34194448:	d018      	beq.n	3419447c <RCCEx_GetUARTCLKFreq+0x218>
3419444a:	4a4c      	ldr	r2, [pc, #304]	@ (3419457c <RCCEx_GetUARTCLKFreq+0x318>)
3419444c:	4293      	cmp	r3, r2
3419444e:	f200 811e 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194452:	4a4b      	ldr	r2, [pc, #300]	@ (34194580 <RCCEx_GetUARTCLKFreq+0x31c>)
34194454:	4293      	cmp	r3, r2
34194456:	d011      	beq.n	3419447c <RCCEx_GetUARTCLKFreq+0x218>
34194458:	4a49      	ldr	r2, [pc, #292]	@ (34194580 <RCCEx_GetUARTCLKFreq+0x31c>)
3419445a:	4293      	cmp	r3, r2
3419445c:	f200 8117 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
34194460:	4a48      	ldr	r2, [pc, #288]	@ (34194584 <RCCEx_GetUARTCLKFreq+0x320>)
34194462:	4293      	cmp	r3, r2
34194464:	d00a      	beq.n	3419447c <RCCEx_GetUARTCLKFreq+0x218>
34194466:	4a47      	ldr	r2, [pc, #284]	@ (34194584 <RCCEx_GetUARTCLKFreq+0x320>)
34194468:	4293      	cmp	r3, r2
3419446a:	f200 8110 	bhi.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
3419446e:	4a46      	ldr	r2, [pc, #280]	@ (34194588 <RCCEx_GetUARTCLKFreq+0x324>)
34194470:	4293      	cmp	r3, r2
34194472:	d00f      	beq.n	34194494 <RCCEx_GetUARTCLKFreq+0x230>
34194474:	4a45      	ldr	r2, [pc, #276]	@ (3419458c <RCCEx_GetUARTCLKFreq+0x328>)
34194476:	4293      	cmp	r3, r2
34194478:	f040 8109 	bne.w	3419468e <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3419447c:	f7f8 f990 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34194480:	4603      	mov	r3, r0
34194482:	4618      	mov	r0, r3
34194484:	f7fd f944 	bl	34191710 <RCCEx_GetHCLKFreq>
34194488:	4603      	mov	r3, r0
3419448a:	4618      	mov	r0, r3
3419448c:	f7fd f951 	bl	34191732 <RCCEx_GetPCLK1Freq>
34194490:	60f8      	str	r0, [r7, #12]
      break;
34194492:	e107      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194494:	f7f8 f984 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34194498:	4603      	mov	r3, r0
3419449a:	4618      	mov	r0, r3
3419449c:	f7fd f938 	bl	34191710 <RCCEx_GetHCLKFreq>
341944a0:	4603      	mov	r3, r0
341944a2:	4618      	mov	r0, r3
341944a4:	f7fd f955 	bl	34191752 <RCCEx_GetPCLK2Freq>
341944a8:	60f8      	str	r0, [r7, #12]
      break;
341944aa:	e0fb      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341944ac:	2007      	movs	r0, #7
341944ae:	f7fd fc1b 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
341944b2:	60f8      	str	r0, [r7, #12]
      break;
341944b4:	e0f6      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
341944b6:	f7f9 fdbf 	bl	3418e038 <LL_RCC_IC9_IsEnabled>
341944ba:	4603      	mov	r3, r0
341944bc:	2b00      	cmp	r3, #0
341944be:	f000 80e8 	beq.w	34194692 <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
341944c2:	f7f9 fddb 	bl	3418e07c <LL_RCC_IC9_GetDivider>
341944c6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
341944c8:	f7f9 fdca 	bl	3418e060 <LL_RCC_IC9_GetSource>
341944cc:	4603      	mov	r3, r0
341944ce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341944d2:	d06f      	beq.n	341945b4 <RCCEx_GetUARTCLKFreq+0x350>
341944d4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341944d8:	d875      	bhi.n	341945c6 <RCCEx_GetUARTCLKFreq+0x362>
341944da:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341944de:	d060      	beq.n	341945a2 <RCCEx_GetUARTCLKFreq+0x33e>
341944e0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341944e4:	d86f      	bhi.n	341945c6 <RCCEx_GetUARTCLKFreq+0x362>
341944e6:	2b00      	cmp	r3, #0
341944e8:	d003      	beq.n	341944f2 <RCCEx_GetUARTCLKFreq+0x28e>
341944ea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341944ee:	d04f      	beq.n	34194590 <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341944f0:	e069      	b.n	341945c6 <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341944f2:	f7fc fff5 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
341944f6:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341944f8:	68fa      	ldr	r2, [r7, #12]
341944fa:	68bb      	ldr	r3, [r7, #8]
341944fc:	fbb2 f3f3 	udiv	r3, r2, r3
34194500:	60fb      	str	r3, [r7, #12]
            break;
34194502:	e061      	b.n	341945c8 <RCCEx_GetUARTCLKFreq+0x364>
34194504:	07061c30 	.word	0x07061c30
34194508:	07061830 	.word	0x07061830
3419450c:	07061030 	.word	0x07061030
34194510:	07060c30 	.word	0x07060c30
34194514:	07060034 	.word	0x07060034
34194518:	07051c30 	.word	0x07051c30
3419451c:	07051830 	.word	0x07051830
34194520:	07051030 	.word	0x07051030
34194524:	07050c30 	.word	0x07050c30
34194528:	07050034 	.word	0x07050034
3419452c:	07041c30 	.word	0x07041c30
34194530:	07041830 	.word	0x07041830
34194534:	07041030 	.word	0x07041030
34194538:	07040c30 	.word	0x07040c30
3419453c:	07040034 	.word	0x07040034
34194540:	07031c30 	.word	0x07031c30
34194544:	07031830 	.word	0x07031830
34194548:	07031030 	.word	0x07031030
3419454c:	07030c30 	.word	0x07030c30
34194550:	07030034 	.word	0x07030034
34194554:	07021c30 	.word	0x07021c30
34194558:	07021830 	.word	0x07021830
3419455c:	07021030 	.word	0x07021030
34194560:	07020c30 	.word	0x07020c30
34194564:	07020034 	.word	0x07020034
34194568:	07011c30 	.word	0x07011c30
3419456c:	07011830 	.word	0x07011830
34194570:	07011030 	.word	0x07011030
34194574:	07010c30 	.word	0x07010c30
34194578:	07010034 	.word	0x07010034
3419457c:	07001c30 	.word	0x07001c30
34194580:	07001830 	.word	0x07001830
34194584:	07001030 	.word	0x07001030
34194588:	07000034 	.word	0x07000034
3419458c:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194590:	f7fc ffec 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194594:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34194596:	68fa      	ldr	r2, [r7, #12]
34194598:	68bb      	ldr	r3, [r7, #8]
3419459a:	fbb2 f3f3 	udiv	r3, r2, r3
3419459e:	60fb      	str	r3, [r7, #12]
            break;
341945a0:	e012      	b.n	341945c8 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341945a2:	f7fd f829 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341945a6:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341945a8:	68fa      	ldr	r2, [r7, #12]
341945aa:	68bb      	ldr	r3, [r7, #8]
341945ac:	fbb2 f3f3 	udiv	r3, r2, r3
341945b0:	60fb      	str	r3, [r7, #12]
            break;
341945b2:	e009      	b.n	341945c8 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341945b4:	f7fd f866 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
341945b8:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341945ba:	68fa      	ldr	r2, [r7, #12]
341945bc:	68bb      	ldr	r3, [r7, #8]
341945be:	fbb2 f3f3 	udiv	r3, r2, r3
341945c2:	60fb      	str	r3, [r7, #12]
            break;
341945c4:	e000      	b.n	341945c8 <RCCEx_GetUARTCLKFreq+0x364>
            break;
341945c6:	bf00      	nop
        }
      }
      break;
341945c8:	e063      	b.n	34194692 <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
341945ca:	f7f9 fe35 	bl	3418e238 <LL_RCC_IC14_IsEnabled>
341945ce:	4603      	mov	r3, r0
341945d0:	2b00      	cmp	r3, #0
341945d2:	d060      	beq.n	34194696 <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
341945d4:	f7f9 fe52 	bl	3418e27c <LL_RCC_IC14_GetDivider>
341945d8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
341945da:	f7f9 fe41 	bl	3418e260 <LL_RCC_IC14_GetSource>
341945de:	4603      	mov	r3, r0
341945e0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341945e4:	d029      	beq.n	3419463a <RCCEx_GetUARTCLKFreq+0x3d6>
341945e6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341945ea:	d82f      	bhi.n	3419464c <RCCEx_GetUARTCLKFreq+0x3e8>
341945ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341945f0:	d01a      	beq.n	34194628 <RCCEx_GetUARTCLKFreq+0x3c4>
341945f2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341945f6:	d829      	bhi.n	3419464c <RCCEx_GetUARTCLKFreq+0x3e8>
341945f8:	2b00      	cmp	r3, #0
341945fa:	d003      	beq.n	34194604 <RCCEx_GetUARTCLKFreq+0x3a0>
341945fc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194600:	d009      	beq.n	34194616 <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194602:	e023      	b.n	3419464c <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194604:	f7fc ff6c 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194608:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3419460a:	68fa      	ldr	r2, [r7, #12]
3419460c:	68bb      	ldr	r3, [r7, #8]
3419460e:	fbb2 f3f3 	udiv	r3, r2, r3
34194612:	60fb      	str	r3, [r7, #12]
            break;
34194614:	e01b      	b.n	3419464e <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194616:	f7fc ffa9 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
3419461a:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3419461c:	68fa      	ldr	r2, [r7, #12]
3419461e:	68bb      	ldr	r3, [r7, #8]
34194620:	fbb2 f3f3 	udiv	r3, r2, r3
34194624:	60fb      	str	r3, [r7, #12]
            break;
34194626:	e012      	b.n	3419464e <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194628:	f7fc ffe6 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
3419462c:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3419462e:	68fa      	ldr	r2, [r7, #12]
34194630:	68bb      	ldr	r3, [r7, #8]
34194632:	fbb2 f3f3 	udiv	r3, r2, r3
34194636:	60fb      	str	r3, [r7, #12]
            break;
34194638:	e009      	b.n	3419464e <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419463a:	f7fd f823 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
3419463e:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34194640:	68fa      	ldr	r2, [r7, #12]
34194642:	68bb      	ldr	r3, [r7, #8]
34194644:	fbb2 f3f3 	udiv	r3, r2, r3
34194648:	60fb      	str	r3, [r7, #12]
            break;
3419464a:	e000      	b.n	3419464e <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
3419464c:	bf00      	nop
        }
      }
      break;
3419464e:	e022      	b.n	34194696 <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34194650:	f7f8 fcce 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34194654:	4603      	mov	r3, r0
34194656:	2b00      	cmp	r3, #0
34194658:	d01f      	beq.n	3419469a <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3419465a:	f7f8 fcdb 	bl	3418d014 <LL_RCC_HSI_GetDivider>
3419465e:	4603      	mov	r3, r0
34194660:	09db      	lsrs	r3, r3, #7
34194662:	4a13      	ldr	r2, [pc, #76]	@ (341946b0 <RCCEx_GetUARTCLKFreq+0x44c>)
34194664:	fa22 f303 	lsr.w	r3, r2, r3
34194668:	60fb      	str	r3, [r7, #12]
      }
      break;
3419466a:	e016      	b.n	3419469a <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3419466c:	f7f8 fce0 	bl	3418d030 <LL_RCC_MSI_IsReady>
34194670:	4603      	mov	r3, r0
34194672:	2b00      	cmp	r3, #0
34194674:	d013      	beq.n	3419469e <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
34194676:	4b0f      	ldr	r3, [pc, #60]	@ (341946b4 <RCCEx_GetUARTCLKFreq+0x450>)
34194678:	60fb      	str	r3, [r7, #12]
      }
      break;
3419467a:	e010      	b.n	3419469e <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
3419467c:	f7f8 fcf8 	bl	3418d070 <LL_RCC_LSE_IsReady>
34194680:	4603      	mov	r3, r0
34194682:	2b00      	cmp	r3, #0
34194684:	d00d      	beq.n	341946a2 <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
34194686:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3419468a:	60fb      	str	r3, [r7, #12]
      }
      break;
3419468c:	e009      	b.n	341946a2 <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
3419468e:	bf00      	nop
34194690:	e008      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34194692:	bf00      	nop
34194694:	e006      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34194696:	bf00      	nop
34194698:	e004      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3419469a:	bf00      	nop
3419469c:	e002      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3419469e:	bf00      	nop
341946a0:	e000      	b.n	341946a4 <RCCEx_GetUARTCLKFreq+0x440>
      break;
341946a2:	bf00      	nop
  }

  return uart_frequency;
341946a4:	68fb      	ldr	r3, [r7, #12]
}
341946a6:	4618      	mov	r0, r3
341946a8:	3710      	adds	r7, #16
341946aa:	46bd      	mov	sp, r7
341946ac:	bd80      	pop	{r7, pc}
341946ae:	bf00      	nop
341946b0:	03d09000 	.word	0x03d09000
341946b4:	003d0900 	.word	0x003d0900

341946b8 <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
341946b8:	b580      	push	{r7, lr}
341946ba:	b084      	sub	sp, #16
341946bc:	af00      	add	r7, sp, #0
341946be:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
341946c0:	2300      	movs	r3, #0
341946c2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
341946c4:	6878      	ldr	r0, [r7, #4]
341946c6:	f7f9 f87b 	bl	3418d7c0 <LL_RCC_GetUSARTClockSource>
341946ca:	4603      	mov	r3, r0
341946cc:	4aa2      	ldr	r2, [pc, #648]	@ (34194958 <RCCEx_GetUSARTCLKFreq+0x2a0>)
341946ce:	4293      	cmp	r3, r2
341946d0:	f000 81e8 	beq.w	34194aa4 <RCCEx_GetUSARTCLKFreq+0x3ec>
341946d4:	4aa0      	ldr	r2, [pc, #640]	@ (34194958 <RCCEx_GetUSARTCLKFreq+0x2a0>)
341946d6:	4293      	cmp	r3, r2
341946d8:	f200 8203 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341946dc:	4a9f      	ldr	r2, [pc, #636]	@ (3419495c <RCCEx_GetUSARTCLKFreq+0x2a4>)
341946de:	4293      	cmp	r3, r2
341946e0:	f000 81e0 	beq.w	34194aa4 <RCCEx_GetUSARTCLKFreq+0x3ec>
341946e4:	4a9d      	ldr	r2, [pc, #628]	@ (3419495c <RCCEx_GetUSARTCLKFreq+0x2a4>)
341946e6:	4293      	cmp	r3, r2
341946e8:	f200 81fb 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341946ec:	4a9c      	ldr	r2, [pc, #624]	@ (34194960 <RCCEx_GetUSARTCLKFreq+0x2a8>)
341946ee:	4293      	cmp	r3, r2
341946f0:	f000 81d8 	beq.w	34194aa4 <RCCEx_GetUSARTCLKFreq+0x3ec>
341946f4:	4a9a      	ldr	r2, [pc, #616]	@ (34194960 <RCCEx_GetUSARTCLKFreq+0x2a8>)
341946f6:	4293      	cmp	r3, r2
341946f8:	f200 81f3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341946fc:	4a99      	ldr	r2, [pc, #612]	@ (34194964 <RCCEx_GetUSARTCLKFreq+0x2ac>)
341946fe:	4293      	cmp	r3, r2
34194700:	f000 81d0 	beq.w	34194aa4 <RCCEx_GetUSARTCLKFreq+0x3ec>
34194704:	4a97      	ldr	r2, [pc, #604]	@ (34194964 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34194706:	4293      	cmp	r3, r2
34194708:	f200 81eb 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419470c:	4a96      	ldr	r2, [pc, #600]	@ (34194968 <RCCEx_GetUSARTCLKFreq+0x2b0>)
3419470e:	4293      	cmp	r3, r2
34194710:	f000 81c8 	beq.w	34194aa4 <RCCEx_GetUSARTCLKFreq+0x3ec>
34194714:	4a94      	ldr	r2, [pc, #592]	@ (34194968 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34194716:	4293      	cmp	r3, r2
34194718:	f200 81e3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419471c:	4a93      	ldr	r2, [pc, #588]	@ (3419496c <RCCEx_GetUSARTCLKFreq+0x2b4>)
3419471e:	4293      	cmp	r3, r2
34194720:	f000 81ce 	beq.w	34194ac0 <RCCEx_GetUSARTCLKFreq+0x408>
34194724:	4a91      	ldr	r2, [pc, #580]	@ (3419496c <RCCEx_GetUSARTCLKFreq+0x2b4>)
34194726:	4293      	cmp	r3, r2
34194728:	f200 81db 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419472c:	4a90      	ldr	r2, [pc, #576]	@ (34194970 <RCCEx_GetUSARTCLKFreq+0x2b8>)
3419472e:	4293      	cmp	r3, r2
34194730:	f000 81c6 	beq.w	34194ac0 <RCCEx_GetUSARTCLKFreq+0x408>
34194734:	4a8e      	ldr	r2, [pc, #568]	@ (34194970 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34194736:	4293      	cmp	r3, r2
34194738:	f200 81d3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419473c:	4a8d      	ldr	r2, [pc, #564]	@ (34194974 <RCCEx_GetUSARTCLKFreq+0x2bc>)
3419473e:	4293      	cmp	r3, r2
34194740:	f000 81be 	beq.w	34194ac0 <RCCEx_GetUSARTCLKFreq+0x408>
34194744:	4a8b      	ldr	r2, [pc, #556]	@ (34194974 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34194746:	4293      	cmp	r3, r2
34194748:	f200 81cb 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419474c:	4a8a      	ldr	r2, [pc, #552]	@ (34194978 <RCCEx_GetUSARTCLKFreq+0x2c0>)
3419474e:	4293      	cmp	r3, r2
34194750:	f000 81b6 	beq.w	34194ac0 <RCCEx_GetUSARTCLKFreq+0x408>
34194754:	4a88      	ldr	r2, [pc, #544]	@ (34194978 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34194756:	4293      	cmp	r3, r2
34194758:	f200 81c3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419475c:	4a87      	ldr	r2, [pc, #540]	@ (3419497c <RCCEx_GetUSARTCLKFreq+0x2c4>)
3419475e:	4293      	cmp	r3, r2
34194760:	f000 81ae 	beq.w	34194ac0 <RCCEx_GetUSARTCLKFreq+0x408>
34194764:	4a85      	ldr	r2, [pc, #532]	@ (3419497c <RCCEx_GetUSARTCLKFreq+0x2c4>)
34194766:	4293      	cmp	r3, r2
34194768:	f200 81bb 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419476c:	4a84      	ldr	r2, [pc, #528]	@ (34194980 <RCCEx_GetUSARTCLKFreq+0x2c8>)
3419476e:	4293      	cmp	r3, r2
34194770:	f000 81ae 	beq.w	34194ad0 <RCCEx_GetUSARTCLKFreq+0x418>
34194774:	4a82      	ldr	r2, [pc, #520]	@ (34194980 <RCCEx_GetUSARTCLKFreq+0x2c8>)
34194776:	4293      	cmp	r3, r2
34194778:	f200 81b3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419477c:	4a81      	ldr	r2, [pc, #516]	@ (34194984 <RCCEx_GetUSARTCLKFreq+0x2cc>)
3419477e:	4293      	cmp	r3, r2
34194780:	f000 81a6 	beq.w	34194ad0 <RCCEx_GetUSARTCLKFreq+0x418>
34194784:	4a7f      	ldr	r2, [pc, #508]	@ (34194984 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34194786:	4293      	cmp	r3, r2
34194788:	f200 81ab 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419478c:	4a7e      	ldr	r2, [pc, #504]	@ (34194988 <RCCEx_GetUSARTCLKFreq+0x2d0>)
3419478e:	4293      	cmp	r3, r2
34194790:	f000 819e 	beq.w	34194ad0 <RCCEx_GetUSARTCLKFreq+0x418>
34194794:	4a7c      	ldr	r2, [pc, #496]	@ (34194988 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34194796:	4293      	cmp	r3, r2
34194798:	f200 81a3 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419479c:	4a7b      	ldr	r2, [pc, #492]	@ (3419498c <RCCEx_GetUSARTCLKFreq+0x2d4>)
3419479e:	4293      	cmp	r3, r2
341947a0:	f000 8196 	beq.w	34194ad0 <RCCEx_GetUSARTCLKFreq+0x418>
341947a4:	4a79      	ldr	r2, [pc, #484]	@ (3419498c <RCCEx_GetUSARTCLKFreq+0x2d4>)
341947a6:	4293      	cmp	r3, r2
341947a8:	f200 819b 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947ac:	4a78      	ldr	r2, [pc, #480]	@ (34194990 <RCCEx_GetUSARTCLKFreq+0x2d8>)
341947ae:	4293      	cmp	r3, r2
341947b0:	f000 818e 	beq.w	34194ad0 <RCCEx_GetUSARTCLKFreq+0x418>
341947b4:	4a76      	ldr	r2, [pc, #472]	@ (34194990 <RCCEx_GetUSARTCLKFreq+0x2d8>)
341947b6:	4293      	cmp	r3, r2
341947b8:	f200 8193 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947bc:	4a75      	ldr	r2, [pc, #468]	@ (34194994 <RCCEx_GetUSARTCLKFreq+0x2dc>)
341947be:	4293      	cmp	r3, r2
341947c0:	f000 812d 	beq.w	34194a1e <RCCEx_GetUSARTCLKFreq+0x366>
341947c4:	4a73      	ldr	r2, [pc, #460]	@ (34194994 <RCCEx_GetUSARTCLKFreq+0x2dc>)
341947c6:	4293      	cmp	r3, r2
341947c8:	f200 818b 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947cc:	4a72      	ldr	r2, [pc, #456]	@ (34194998 <RCCEx_GetUSARTCLKFreq+0x2e0>)
341947ce:	4293      	cmp	r3, r2
341947d0:	f000 8125 	beq.w	34194a1e <RCCEx_GetUSARTCLKFreq+0x366>
341947d4:	4a70      	ldr	r2, [pc, #448]	@ (34194998 <RCCEx_GetUSARTCLKFreq+0x2e0>)
341947d6:	4293      	cmp	r3, r2
341947d8:	f200 8183 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947dc:	4a6f      	ldr	r2, [pc, #444]	@ (3419499c <RCCEx_GetUSARTCLKFreq+0x2e4>)
341947de:	4293      	cmp	r3, r2
341947e0:	f000 811d 	beq.w	34194a1e <RCCEx_GetUSARTCLKFreq+0x366>
341947e4:	4a6d      	ldr	r2, [pc, #436]	@ (3419499c <RCCEx_GetUSARTCLKFreq+0x2e4>)
341947e6:	4293      	cmp	r3, r2
341947e8:	f200 817b 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947ec:	4a6c      	ldr	r2, [pc, #432]	@ (341949a0 <RCCEx_GetUSARTCLKFreq+0x2e8>)
341947ee:	4293      	cmp	r3, r2
341947f0:	f000 8115 	beq.w	34194a1e <RCCEx_GetUSARTCLKFreq+0x366>
341947f4:	4a6a      	ldr	r2, [pc, #424]	@ (341949a0 <RCCEx_GetUSARTCLKFreq+0x2e8>)
341947f6:	4293      	cmp	r3, r2
341947f8:	f200 8173 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341947fc:	4a69      	ldr	r2, [pc, #420]	@ (341949a4 <RCCEx_GetUSARTCLKFreq+0x2ec>)
341947fe:	4293      	cmp	r3, r2
34194800:	f000 810d 	beq.w	34194a1e <RCCEx_GetUSARTCLKFreq+0x366>
34194804:	4a67      	ldr	r2, [pc, #412]	@ (341949a4 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34194806:	4293      	cmp	r3, r2
34194808:	f200 816b 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419480c:	4a66      	ldr	r2, [pc, #408]	@ (341949a8 <RCCEx_GetUSARTCLKFreq+0x2f0>)
3419480e:	4293      	cmp	r3, r2
34194810:	d07b      	beq.n	3419490a <RCCEx_GetUSARTCLKFreq+0x252>
34194812:	4a65      	ldr	r2, [pc, #404]	@ (341949a8 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34194814:	4293      	cmp	r3, r2
34194816:	f200 8164 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419481a:	4a64      	ldr	r2, [pc, #400]	@ (341949ac <RCCEx_GetUSARTCLKFreq+0x2f4>)
3419481c:	4293      	cmp	r3, r2
3419481e:	d074      	beq.n	3419490a <RCCEx_GetUSARTCLKFreq+0x252>
34194820:	4a62      	ldr	r2, [pc, #392]	@ (341949ac <RCCEx_GetUSARTCLKFreq+0x2f4>)
34194822:	4293      	cmp	r3, r2
34194824:	f200 815d 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194828:	4a61      	ldr	r2, [pc, #388]	@ (341949b0 <RCCEx_GetUSARTCLKFreq+0x2f8>)
3419482a:	4293      	cmp	r3, r2
3419482c:	d06d      	beq.n	3419490a <RCCEx_GetUSARTCLKFreq+0x252>
3419482e:	4a60      	ldr	r2, [pc, #384]	@ (341949b0 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34194830:	4293      	cmp	r3, r2
34194832:	f200 8156 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194836:	4a5f      	ldr	r2, [pc, #380]	@ (341949b4 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34194838:	4293      	cmp	r3, r2
3419483a:	d066      	beq.n	3419490a <RCCEx_GetUSARTCLKFreq+0x252>
3419483c:	4a5d      	ldr	r2, [pc, #372]	@ (341949b4 <RCCEx_GetUSARTCLKFreq+0x2fc>)
3419483e:	4293      	cmp	r3, r2
34194840:	f200 814f 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194844:	4a5c      	ldr	r2, [pc, #368]	@ (341949b8 <RCCEx_GetUSARTCLKFreq+0x300>)
34194846:	4293      	cmp	r3, r2
34194848:	d05f      	beq.n	3419490a <RCCEx_GetUSARTCLKFreq+0x252>
3419484a:	4a5b      	ldr	r2, [pc, #364]	@ (341949b8 <RCCEx_GetUSARTCLKFreq+0x300>)
3419484c:	4293      	cmp	r3, r2
3419484e:	f200 8148 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194852:	4a5a      	ldr	r2, [pc, #360]	@ (341949bc <RCCEx_GetUSARTCLKFreq+0x304>)
34194854:	4293      	cmp	r3, r2
34194856:	d053      	beq.n	34194900 <RCCEx_GetUSARTCLKFreq+0x248>
34194858:	4a58      	ldr	r2, [pc, #352]	@ (341949bc <RCCEx_GetUSARTCLKFreq+0x304>)
3419485a:	4293      	cmp	r3, r2
3419485c:	f200 8141 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194860:	4a57      	ldr	r2, [pc, #348]	@ (341949c0 <RCCEx_GetUSARTCLKFreq+0x308>)
34194862:	4293      	cmp	r3, r2
34194864:	d04c      	beq.n	34194900 <RCCEx_GetUSARTCLKFreq+0x248>
34194866:	4a56      	ldr	r2, [pc, #344]	@ (341949c0 <RCCEx_GetUSARTCLKFreq+0x308>)
34194868:	4293      	cmp	r3, r2
3419486a:	f200 813a 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419486e:	4a55      	ldr	r2, [pc, #340]	@ (341949c4 <RCCEx_GetUSARTCLKFreq+0x30c>)
34194870:	4293      	cmp	r3, r2
34194872:	d045      	beq.n	34194900 <RCCEx_GetUSARTCLKFreq+0x248>
34194874:	4a53      	ldr	r2, [pc, #332]	@ (341949c4 <RCCEx_GetUSARTCLKFreq+0x30c>)
34194876:	4293      	cmp	r3, r2
34194878:	f200 8133 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419487c:	4a52      	ldr	r2, [pc, #328]	@ (341949c8 <RCCEx_GetUSARTCLKFreq+0x310>)
3419487e:	4293      	cmp	r3, r2
34194880:	d03e      	beq.n	34194900 <RCCEx_GetUSARTCLKFreq+0x248>
34194882:	4a51      	ldr	r2, [pc, #324]	@ (341949c8 <RCCEx_GetUSARTCLKFreq+0x310>)
34194884:	4293      	cmp	r3, r2
34194886:	f200 812c 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
3419488a:	4a50      	ldr	r2, [pc, #320]	@ (341949cc <RCCEx_GetUSARTCLKFreq+0x314>)
3419488c:	4293      	cmp	r3, r2
3419488e:	d037      	beq.n	34194900 <RCCEx_GetUSARTCLKFreq+0x248>
34194890:	4a4e      	ldr	r2, [pc, #312]	@ (341949cc <RCCEx_GetUSARTCLKFreq+0x314>)
34194892:	4293      	cmp	r3, r2
34194894:	f200 8125 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
34194898:	4a4d      	ldr	r2, [pc, #308]	@ (341949d0 <RCCEx_GetUSARTCLKFreq+0x318>)
3419489a:	4293      	cmp	r3, r2
3419489c:	d018      	beq.n	341948d0 <RCCEx_GetUSARTCLKFreq+0x218>
3419489e:	4a4c      	ldr	r2, [pc, #304]	@ (341949d0 <RCCEx_GetUSARTCLKFreq+0x318>)
341948a0:	4293      	cmp	r3, r2
341948a2:	f200 811e 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341948a6:	4a4b      	ldr	r2, [pc, #300]	@ (341949d4 <RCCEx_GetUSARTCLKFreq+0x31c>)
341948a8:	4293      	cmp	r3, r2
341948aa:	d01d      	beq.n	341948e8 <RCCEx_GetUSARTCLKFreq+0x230>
341948ac:	4a49      	ldr	r2, [pc, #292]	@ (341949d4 <RCCEx_GetUSARTCLKFreq+0x31c>)
341948ae:	4293      	cmp	r3, r2
341948b0:	f200 8117 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341948b4:	4a48      	ldr	r2, [pc, #288]	@ (341949d8 <RCCEx_GetUSARTCLKFreq+0x320>)
341948b6:	4293      	cmp	r3, r2
341948b8:	d00a      	beq.n	341948d0 <RCCEx_GetUSARTCLKFreq+0x218>
341948ba:	4a47      	ldr	r2, [pc, #284]	@ (341949d8 <RCCEx_GetUSARTCLKFreq+0x320>)
341948bc:	4293      	cmp	r3, r2
341948be:	f200 8110 	bhi.w	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
341948c2:	4a46      	ldr	r2, [pc, #280]	@ (341949dc <RCCEx_GetUSARTCLKFreq+0x324>)
341948c4:	4293      	cmp	r3, r2
341948c6:	d003      	beq.n	341948d0 <RCCEx_GetUSARTCLKFreq+0x218>
341948c8:	4a45      	ldr	r2, [pc, #276]	@ (341949e0 <RCCEx_GetUSARTCLKFreq+0x328>)
341948ca:	4293      	cmp	r3, r2
341948cc:	d00c      	beq.n	341948e8 <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
341948ce:	e108      	b.n	34194ae2 <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341948d0:	f7f7 ff66 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
341948d4:	4603      	mov	r3, r0
341948d6:	4618      	mov	r0, r3
341948d8:	f7fc ff1a 	bl	34191710 <RCCEx_GetHCLKFreq>
341948dc:	4603      	mov	r3, r0
341948de:	4618      	mov	r0, r3
341948e0:	f7fc ff37 	bl	34191752 <RCCEx_GetPCLK2Freq>
341948e4:	60f8      	str	r0, [r7, #12]
      break;
341948e6:	e107      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341948e8:	f7f7 ff5a 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
341948ec:	4603      	mov	r3, r0
341948ee:	4618      	mov	r0, r3
341948f0:	f7fc ff0e 	bl	34191710 <RCCEx_GetHCLKFreq>
341948f4:	4603      	mov	r3, r0
341948f6:	4618      	mov	r0, r3
341948f8:	f7fc ff1b 	bl	34191732 <RCCEx_GetPCLK1Freq>
341948fc:	60f8      	str	r0, [r7, #12]
      break;
341948fe:	e0fb      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194900:	2007      	movs	r0, #7
34194902:	f7fd f9f1 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34194906:	60f8      	str	r0, [r7, #12]
      break;
34194908:	e0f6      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3419490a:	f7f9 fb95 	bl	3418e038 <LL_RCC_IC9_IsEnabled>
3419490e:	4603      	mov	r3, r0
34194910:	2b00      	cmp	r3, #0
34194912:	f000 80e8 	beq.w	34194ae6 <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
34194916:	f7f9 fbb1 	bl	3418e07c <LL_RCC_IC9_GetDivider>
3419491a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
3419491c:	f7f9 fba0 	bl	3418e060 <LL_RCC_IC9_GetSource>
34194920:	4603      	mov	r3, r0
34194922:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194926:	d06f      	beq.n	34194a08 <RCCEx_GetUSARTCLKFreq+0x350>
34194928:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419492c:	d875      	bhi.n	34194a1a <RCCEx_GetUSARTCLKFreq+0x362>
3419492e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194932:	d060      	beq.n	341949f6 <RCCEx_GetUSARTCLKFreq+0x33e>
34194934:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194938:	d86f      	bhi.n	34194a1a <RCCEx_GetUSARTCLKFreq+0x362>
3419493a:	2b00      	cmp	r3, #0
3419493c:	d003      	beq.n	34194946 <RCCEx_GetUSARTCLKFreq+0x28e>
3419493e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194942:	d04f      	beq.n	341949e4 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
34194944:	e069      	b.n	34194a1a <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194946:	f7fc fdcb 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
3419494a:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3419494c:	68fa      	ldr	r2, [r7, #12]
3419494e:	68bb      	ldr	r3, [r7, #8]
34194950:	fbb2 f3f3 	udiv	r3, r2, r3
34194954:	60fb      	str	r3, [r7, #12]
            break;
34194956:	e061      	b.n	34194a1c <RCCEx_GetUSARTCLKFreq+0x364>
34194958:	07061430 	.word	0x07061430
3419495c:	07060830 	.word	0x07060830
34194960:	07060434 	.word	0x07060434
34194964:	07060430 	.word	0x07060430
34194968:	07060030 	.word	0x07060030
3419496c:	07051430 	.word	0x07051430
34194970:	07050830 	.word	0x07050830
34194974:	07050434 	.word	0x07050434
34194978:	07050430 	.word	0x07050430
3419497c:	07050030 	.word	0x07050030
34194980:	07041430 	.word	0x07041430
34194984:	07040830 	.word	0x07040830
34194988:	07040434 	.word	0x07040434
3419498c:	07040430 	.word	0x07040430
34194990:	07040030 	.word	0x07040030
34194994:	07031430 	.word	0x07031430
34194998:	07030830 	.word	0x07030830
3419499c:	07030434 	.word	0x07030434
341949a0:	07030430 	.word	0x07030430
341949a4:	07030030 	.word	0x07030030
341949a8:	07021430 	.word	0x07021430
341949ac:	07020830 	.word	0x07020830
341949b0:	07020434 	.word	0x07020434
341949b4:	07020430 	.word	0x07020430
341949b8:	07020030 	.word	0x07020030
341949bc:	07011430 	.word	0x07011430
341949c0:	07010830 	.word	0x07010830
341949c4:	07010434 	.word	0x07010434
341949c8:	07010430 	.word	0x07010430
341949cc:	07010030 	.word	0x07010030
341949d0:	07001430 	.word	0x07001430
341949d4:	07000830 	.word	0x07000830
341949d8:	07000434 	.word	0x07000434
341949dc:	07000030 	.word	0x07000030
341949e0:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341949e4:	f7fc fdc2 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
341949e8:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
341949ea:	68fa      	ldr	r2, [r7, #12]
341949ec:	68bb      	ldr	r3, [r7, #8]
341949ee:	fbb2 f3f3 	udiv	r3, r2, r3
341949f2:	60fb      	str	r3, [r7, #12]
            break;
341949f4:	e012      	b.n	34194a1c <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341949f6:	f7fc fdff 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
341949fa:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
341949fc:	68fa      	ldr	r2, [r7, #12]
341949fe:	68bb      	ldr	r3, [r7, #8]
34194a00:	fbb2 f3f3 	udiv	r3, r2, r3
34194a04:	60fb      	str	r3, [r7, #12]
            break;
34194a06:	e009      	b.n	34194a1c <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194a08:	f7fc fe3c 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194a0c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34194a0e:	68fa      	ldr	r2, [r7, #12]
34194a10:	68bb      	ldr	r3, [r7, #8]
34194a12:	fbb2 f3f3 	udiv	r3, r2, r3
34194a16:	60fb      	str	r3, [r7, #12]
            break;
34194a18:	e000      	b.n	34194a1c <RCCEx_GetUSARTCLKFreq+0x364>
            break;
34194a1a:	bf00      	nop
      break;
34194a1c:	e063      	b.n	34194ae6 <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34194a1e:	f7f9 fc0b 	bl	3418e238 <LL_RCC_IC14_IsEnabled>
34194a22:	4603      	mov	r3, r0
34194a24:	2b00      	cmp	r3, #0
34194a26:	d060      	beq.n	34194aea <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
34194a28:	f7f9 fc28 	bl	3418e27c <LL_RCC_IC14_GetDivider>
34194a2c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34194a2e:	f7f9 fc17 	bl	3418e260 <LL_RCC_IC14_GetSource>
34194a32:	4603      	mov	r3, r0
34194a34:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194a38:	d029      	beq.n	34194a8e <RCCEx_GetUSARTCLKFreq+0x3d6>
34194a3a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194a3e:	d82f      	bhi.n	34194aa0 <RCCEx_GetUSARTCLKFreq+0x3e8>
34194a40:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194a44:	d01a      	beq.n	34194a7c <RCCEx_GetUSARTCLKFreq+0x3c4>
34194a46:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194a4a:	d829      	bhi.n	34194aa0 <RCCEx_GetUSARTCLKFreq+0x3e8>
34194a4c:	2b00      	cmp	r3, #0
34194a4e:	d003      	beq.n	34194a58 <RCCEx_GetUSARTCLKFreq+0x3a0>
34194a50:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194a54:	d009      	beq.n	34194a6a <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
34194a56:	e023      	b.n	34194aa0 <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194a58:	f7fc fd42 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194a5c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34194a5e:	68fa      	ldr	r2, [r7, #12]
34194a60:	68bb      	ldr	r3, [r7, #8]
34194a62:	fbb2 f3f3 	udiv	r3, r2, r3
34194a66:	60fb      	str	r3, [r7, #12]
            break;
34194a68:	e01b      	b.n	34194aa2 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194a6a:	f7fc fd7f 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194a6e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34194a70:	68fa      	ldr	r2, [r7, #12]
34194a72:	68bb      	ldr	r3, [r7, #8]
34194a74:	fbb2 f3f3 	udiv	r3, r2, r3
34194a78:	60fb      	str	r3, [r7, #12]
            break;
34194a7a:	e012      	b.n	34194aa2 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194a7c:	f7fc fdbc 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34194a80:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34194a82:	68fa      	ldr	r2, [r7, #12]
34194a84:	68bb      	ldr	r3, [r7, #8]
34194a86:	fbb2 f3f3 	udiv	r3, r2, r3
34194a8a:	60fb      	str	r3, [r7, #12]
            break;
34194a8c:	e009      	b.n	34194aa2 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194a8e:	f7fc fdf9 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194a92:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34194a94:	68fa      	ldr	r2, [r7, #12]
34194a96:	68bb      	ldr	r3, [r7, #8]
34194a98:	fbb2 f3f3 	udiv	r3, r2, r3
34194a9c:	60fb      	str	r3, [r7, #12]
            break;
34194a9e:	e000      	b.n	34194aa2 <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
34194aa0:	bf00      	nop
      break;
34194aa2:	e022      	b.n	34194aea <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
34194aa4:	f7f8 faa4 	bl	3418cff0 <LL_RCC_HSI_IsReady>
34194aa8:	4603      	mov	r3, r0
34194aaa:	2b00      	cmp	r3, #0
34194aac:	d01f      	beq.n	34194aee <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34194aae:	f7f8 fab1 	bl	3418d014 <LL_RCC_HSI_GetDivider>
34194ab2:	4603      	mov	r3, r0
34194ab4:	09db      	lsrs	r3, r3, #7
34194ab6:	4a13      	ldr	r2, [pc, #76]	@ (34194b04 <RCCEx_GetUSARTCLKFreq+0x44c>)
34194ab8:	fa22 f303 	lsr.w	r3, r2, r3
34194abc:	60fb      	str	r3, [r7, #12]
      break;
34194abe:	e016      	b.n	34194aee <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
34194ac0:	f7f8 fab6 	bl	3418d030 <LL_RCC_MSI_IsReady>
34194ac4:	4603      	mov	r3, r0
34194ac6:	2b00      	cmp	r3, #0
34194ac8:	d013      	beq.n	34194af2 <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
34194aca:	4b0f      	ldr	r3, [pc, #60]	@ (34194b08 <RCCEx_GetUSARTCLKFreq+0x450>)
34194acc:	60fb      	str	r3, [r7, #12]
      break;
34194ace:	e010      	b.n	34194af2 <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
34194ad0:	f7f8 face 	bl	3418d070 <LL_RCC_LSE_IsReady>
34194ad4:	4603      	mov	r3, r0
34194ad6:	2b00      	cmp	r3, #0
34194ad8:	d00d      	beq.n	34194af6 <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
34194ada:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34194ade:	60fb      	str	r3, [r7, #12]
      break;
34194ae0:	e009      	b.n	34194af6 <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
34194ae2:	bf00      	nop
34194ae4:	e008      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34194ae6:	bf00      	nop
34194ae8:	e006      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34194aea:	bf00      	nop
34194aec:	e004      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34194aee:	bf00      	nop
34194af0:	e002      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34194af2:	bf00      	nop
34194af4:	e000      	b.n	34194af8 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34194af6:	bf00      	nop
  }

  return usart_frequency;
34194af8:	68fb      	ldr	r3, [r7, #12]
}
34194afa:	4618      	mov	r0, r3
34194afc:	3710      	adds	r7, #16
34194afe:	46bd      	mov	sp, r7
34194b00:	bd80      	pop	{r7, pc}
34194b02:	bf00      	nop
34194b04:	03d09000 	.word	0x03d09000
34194b08:	003d0900 	.word	0x003d0900

34194b0c <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
34194b0c:	b580      	push	{r7, lr}
34194b0e:	b084      	sub	sp, #16
34194b10:	af00      	add	r7, sp, #0
34194b12:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34194b14:	2300      	movs	r3, #0
34194b16:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
34194b18:	6878      	ldr	r0, [r7, #4]
34194b1a:	f7f8 fe69 	bl	3418d7f0 <LL_RCC_GetUSBClockSource>
34194b1e:	4603      	mov	r3, r0
34194b20:	4a4b      	ldr	r2, [pc, #300]	@ (34194c50 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34194b22:	4293      	cmp	r3, r2
34194b24:	d035      	beq.n	34194b92 <RCCEx_GetOTGPHYCLKFreq+0x86>
34194b26:	4a4a      	ldr	r2, [pc, #296]	@ (34194c50 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34194b28:	4293      	cmp	r3, r2
34194b2a:	f200 8085 	bhi.w	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b2e:	4a49      	ldr	r2, [pc, #292]	@ (34194c54 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34194b30:	4293      	cmp	r3, r2
34194b32:	d02e      	beq.n	34194b92 <RCCEx_GetOTGPHYCLKFreq+0x86>
34194b34:	4a47      	ldr	r2, [pc, #284]	@ (34194c54 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34194b36:	4293      	cmp	r3, r2
34194b38:	d87e      	bhi.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b3a:	4a47      	ldr	r2, [pc, #284]	@ (34194c58 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34194b3c:	4293      	cmp	r3, r2
34194b3e:	d038      	beq.n	34194bb2 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34194b40:	4a45      	ldr	r2, [pc, #276]	@ (34194c58 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34194b42:	4293      	cmp	r3, r2
34194b44:	d878      	bhi.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b46:	4a45      	ldr	r2, [pc, #276]	@ (34194c5c <RCCEx_GetOTGPHYCLKFreq+0x150>)
34194b48:	4293      	cmp	r3, r2
34194b4a:	d032      	beq.n	34194bb2 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34194b4c:	4a43      	ldr	r2, [pc, #268]	@ (34194c5c <RCCEx_GetOTGPHYCLKFreq+0x150>)
34194b4e:	4293      	cmp	r3, r2
34194b50:	d872      	bhi.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b52:	4a43      	ldr	r2, [pc, #268]	@ (34194c60 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34194b54:	4293      	cmp	r3, r2
34194b56:	d00f      	beq.n	34194b78 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34194b58:	4a41      	ldr	r2, [pc, #260]	@ (34194c60 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34194b5a:	4293      	cmp	r3, r2
34194b5c:	d86c      	bhi.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b5e:	4a41      	ldr	r2, [pc, #260]	@ (34194c64 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34194b60:	4293      	cmp	r3, r2
34194b62:	d009      	beq.n	34194b78 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34194b64:	4a3f      	ldr	r2, [pc, #252]	@ (34194c64 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34194b66:	4293      	cmp	r3, r2
34194b68:	d866      	bhi.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34194b6a:	4a3f      	ldr	r2, [pc, #252]	@ (34194c68 <RCCEx_GetOTGPHYCLKFreq+0x15c>)
34194b6c:	4293      	cmp	r3, r2
34194b6e:	d008      	beq.n	34194b82 <RCCEx_GetOTGPHYCLKFreq+0x76>
34194b70:	4a3e      	ldr	r2, [pc, #248]	@ (34194c6c <RCCEx_GetOTGPHYCLKFreq+0x160>)
34194b72:	4293      	cmp	r3, r2
34194b74:	d005      	beq.n	34194b82 <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
34194b76:	e05f      	b.n	34194c38 <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194b78:	2007      	movs	r0, #7
34194b7a:	f7fd f8b5 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34194b7e:	60f8      	str	r0, [r7, #12]
      break;
34194b80:	e061      	b.n	34194c46 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
34194b82:	f7f8 fa23 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34194b86:	4603      	mov	r3, r0
34194b88:	2b00      	cmp	r3, #0
34194b8a:	d057      	beq.n	34194c3c <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
34194b8c:	4b38      	ldr	r3, [pc, #224]	@ (34194c70 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34194b8e:	60fb      	str	r3, [r7, #12]
      break;
34194b90:	e054      	b.n	34194c3c <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
34194b92:	f7f8 fa1b 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34194b96:	4603      	mov	r3, r0
34194b98:	2b00      	cmp	r3, #0
34194b9a:	d051      	beq.n	34194c40 <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34194b9c:	f7f8 fa04 	bl	3418cfa8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34194ba0:	4603      	mov	r3, r0
34194ba2:	2b00      	cmp	r3, #0
34194ba4:	d102      	bne.n	34194bac <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
34194ba6:	4b33      	ldr	r3, [pc, #204]	@ (34194c74 <RCCEx_GetOTGPHYCLKFreq+0x168>)
34194ba8:	60fb      	str	r3, [r7, #12]
      break;
34194baa:	e049      	b.n	34194c40 <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
34194bac:	4b30      	ldr	r3, [pc, #192]	@ (34194c70 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34194bae:	60fb      	str	r3, [r7, #12]
      break;
34194bb0:	e046      	b.n	34194c40 <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34194bb2:	f7f9 fb81 	bl	3418e2b8 <LL_RCC_IC15_IsEnabled>
34194bb6:	4603      	mov	r3, r0
34194bb8:	2b00      	cmp	r3, #0
34194bba:	d043      	beq.n	34194c44 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
34194bbc:	f7f9 fb9e 	bl	3418e2fc <LL_RCC_IC15_GetDivider>
34194bc0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34194bc2:	f7f9 fb8d 	bl	3418e2e0 <LL_RCC_IC15_GetSource>
34194bc6:	4603      	mov	r3, r0
34194bc8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194bcc:	d029      	beq.n	34194c22 <RCCEx_GetOTGPHYCLKFreq+0x116>
34194bce:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194bd2:	d82f      	bhi.n	34194c34 <RCCEx_GetOTGPHYCLKFreq+0x128>
34194bd4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194bd8:	d01a      	beq.n	34194c10 <RCCEx_GetOTGPHYCLKFreq+0x104>
34194bda:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194bde:	d829      	bhi.n	34194c34 <RCCEx_GetOTGPHYCLKFreq+0x128>
34194be0:	2b00      	cmp	r3, #0
34194be2:	d003      	beq.n	34194bec <RCCEx_GetOTGPHYCLKFreq+0xe0>
34194be4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194be8:	d009      	beq.n	34194bfe <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
34194bea:	e023      	b.n	34194c34 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194bec:	f7fc fc78 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194bf0:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34194bf2:	68fa      	ldr	r2, [r7, #12]
34194bf4:	68bb      	ldr	r3, [r7, #8]
34194bf6:	fbb2 f3f3 	udiv	r3, r2, r3
34194bfa:	60fb      	str	r3, [r7, #12]
            break;
34194bfc:	e01b      	b.n	34194c36 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194bfe:	f7fc fcb5 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194c02:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34194c04:	68fa      	ldr	r2, [r7, #12]
34194c06:	68bb      	ldr	r3, [r7, #8]
34194c08:	fbb2 f3f3 	udiv	r3, r2, r3
34194c0c:	60fb      	str	r3, [r7, #12]
            break;
34194c0e:	e012      	b.n	34194c36 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194c10:	f7fc fcf2 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34194c14:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34194c16:	68fa      	ldr	r2, [r7, #12]
34194c18:	68bb      	ldr	r3, [r7, #8]
34194c1a:	fbb2 f3f3 	udiv	r3, r2, r3
34194c1e:	60fb      	str	r3, [r7, #12]
            break;
34194c20:	e009      	b.n	34194c36 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194c22:	f7fc fd2f 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194c26:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34194c28:	68fa      	ldr	r2, [r7, #12]
34194c2a:	68bb      	ldr	r3, [r7, #8]
34194c2c:	fbb2 f3f3 	udiv	r3, r2, r3
34194c30:	60fb      	str	r3, [r7, #12]
            break;
34194c32:	e000      	b.n	34194c36 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
34194c34:	bf00      	nop
      break;
34194c36:	e005      	b.n	34194c44 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
34194c38:	bf00      	nop
34194c3a:	e004      	b.n	34194c46 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34194c3c:	bf00      	nop
34194c3e:	e002      	b.n	34194c46 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34194c40:	bf00      	nop
34194c42:	e000      	b.n	34194c46 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34194c44:	bf00      	nop
  }

  return usb_frequency;
34194c46:	68fb      	ldr	r3, [r7, #12]
}
34194c48:	4618      	mov	r0, r3
34194c4a:	3710      	adds	r7, #16
34194c4c:	46bd      	mov	sp, r7
34194c4e:	bd80      	pop	{r7, pc}
34194c50:	03031414 	.word	0x03031414
34194c54:	03030c14 	.word	0x03030c14
34194c58:	03021414 	.word	0x03021414
34194c5c:	03020c14 	.word	0x03020c14
34194c60:	03011414 	.word	0x03011414
34194c64:	03010c14 	.word	0x03010c14
34194c68:	03000c14 	.word	0x03000c14
34194c6c:	03001414 	.word	0x03001414
34194c70:	016e3600 	.word	0x016e3600
34194c74:	02dc6c00 	.word	0x02dc6c00

34194c78 <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
34194c78:	b580      	push	{r7, lr}
34194c7a:	b084      	sub	sp, #16
34194c7c:	af00      	add	r7, sp, #0
34194c7e:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34194c80:	2300      	movs	r3, #0
34194c82:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
34194c84:	6878      	ldr	r0, [r7, #4]
34194c86:	f7f8 fdb3 	bl	3418d7f0 <LL_RCC_GetUSBClockSource>
34194c8a:	4603      	mov	r3, r0
34194c8c:	4a1a      	ldr	r2, [pc, #104]	@ (34194cf8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
34194c8e:	4293      	cmp	r3, r2
34194c90:	d00f      	beq.n	34194cb2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
34194c92:	4a19      	ldr	r2, [pc, #100]	@ (34194cf8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
34194c94:	4293      	cmp	r3, r2
34194c96:	d826      	bhi.n	34194ce6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34194c98:	4a18      	ldr	r2, [pc, #96]	@ (34194cfc <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
34194c9a:	4293      	cmp	r3, r2
34194c9c:	d009      	beq.n	34194cb2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
34194c9e:	4a17      	ldr	r2, [pc, #92]	@ (34194cfc <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
34194ca0:	4293      	cmp	r3, r2
34194ca2:	d820      	bhi.n	34194ce6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34194ca4:	4a16      	ldr	r2, [pc, #88]	@ (34194d00 <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
34194ca6:	4293      	cmp	r3, r2
34194ca8:	d013      	beq.n	34194cd2 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
34194caa:	4a16      	ldr	r2, [pc, #88]	@ (34194d04 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
34194cac:	4293      	cmp	r3, r2
34194cae:	d015      	beq.n	34194cdc <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
34194cb0:	e019      	b.n	34194ce6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
34194cb2:	f7f8 f98b 	bl	3418cfcc <LL_RCC_HSE_IsReady>
34194cb6:	4603      	mov	r3, r0
34194cb8:	2b00      	cmp	r3, #0
34194cba:	d016      	beq.n	34194cea <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34194cbc:	f7f8 f974 	bl	3418cfa8 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34194cc0:	4603      	mov	r3, r0
34194cc2:	2b00      	cmp	r3, #0
34194cc4:	d102      	bne.n	34194ccc <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
34194cc6:	4b10      	ldr	r3, [pc, #64]	@ (34194d08 <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
34194cc8:	60fb      	str	r3, [r7, #12]
      break;
34194cca:	e00e      	b.n	34194cea <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
34194ccc:	4b0f      	ldr	r3, [pc, #60]	@ (34194d0c <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
34194cce:	60fb      	str	r3, [r7, #12]
      break;
34194cd0:	e00b      	b.n	34194cea <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34194cd2:	480f      	ldr	r0, [pc, #60]	@ (34194d10 <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
34194cd4:	f7ff ff1a 	bl	34194b0c <RCCEx_GetOTGPHYCLKFreq>
34194cd8:	60f8      	str	r0, [r7, #12]
      break;
34194cda:	e007      	b.n	34194cec <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34194cdc:	480d      	ldr	r0, [pc, #52]	@ (34194d14 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
34194cde:	f7ff ff15 	bl	34194b0c <RCCEx_GetOTGPHYCLKFreq>
34194ce2:	60f8      	str	r0, [r7, #12]
      break;
34194ce4:	e002      	b.n	34194cec <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
34194ce6:	bf00      	nop
34194ce8:	e000      	b.n	34194cec <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
34194cea:	bf00      	nop
  }

  return usb_frequency;
34194cec:	68fb      	ldr	r3, [r7, #12]
}
34194cee:	4618      	mov	r0, r3
34194cf0:	3710      	adds	r7, #16
34194cf2:	46bd      	mov	sp, r7
34194cf4:	bd80      	pop	{r7, pc}
34194cf6:	bf00      	nop
34194cf8:	01011814 	.word	0x01011814
34194cfc:	01011014 	.word	0x01011014
34194d00:	01001014 	.word	0x01001014
34194d04:	01001814 	.word	0x01001814
34194d08:	02dc6c00 	.word	0x02dc6c00
34194d0c:	016e3600 	.word	0x016e3600
34194d10:	03000c14 	.word	0x03000c14
34194d14:	03001414 	.word	0x03001414

34194d18 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
34194d18:	b580      	push	{r7, lr}
34194d1a:	b084      	sub	sp, #16
34194d1c:	af00      	add	r7, sp, #0
34194d1e:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
34194d20:	2300      	movs	r3, #0
34194d22:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
34194d24:	6878      	ldr	r0, [r7, #4]
34194d26:	f7f8 fd6f 	bl	3418d808 <LL_RCC_GetXSPIClockSource>
34194d2a:	4603      	mov	r3, r0
34194d2c:	4a76      	ldr	r2, [pc, #472]	@ (34194f08 <RCCEx_GetXSPICLKFreq+0x1f0>)
34194d2e:	4293      	cmp	r3, r2
34194d30:	f000 809d 	beq.w	34194e6e <RCCEx_GetXSPICLKFreq+0x156>
34194d34:	4a74      	ldr	r2, [pc, #464]	@ (34194f08 <RCCEx_GetXSPICLKFreq+0x1f0>)
34194d36:	4293      	cmp	r3, r2
34194d38:	f200 80dc 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d3c:	4a73      	ldr	r2, [pc, #460]	@ (34194f0c <RCCEx_GetXSPICLKFreq+0x1f4>)
34194d3e:	4293      	cmp	r3, r2
34194d40:	f000 8095 	beq.w	34194e6e <RCCEx_GetXSPICLKFreq+0x156>
34194d44:	4a71      	ldr	r2, [pc, #452]	@ (34194f0c <RCCEx_GetXSPICLKFreq+0x1f4>)
34194d46:	4293      	cmp	r3, r2
34194d48:	f200 80d4 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d4c:	4a70      	ldr	r2, [pc, #448]	@ (34194f10 <RCCEx_GetXSPICLKFreq+0x1f8>)
34194d4e:	4293      	cmp	r3, r2
34194d50:	f000 808d 	beq.w	34194e6e <RCCEx_GetXSPICLKFreq+0x156>
34194d54:	4a6e      	ldr	r2, [pc, #440]	@ (34194f10 <RCCEx_GetXSPICLKFreq+0x1f8>)
34194d56:	4293      	cmp	r3, r2
34194d58:	f200 80cc 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d5c:	4a6d      	ldr	r2, [pc, #436]	@ (34194f14 <RCCEx_GetXSPICLKFreq+0x1fc>)
34194d5e:	4293      	cmp	r3, r2
34194d60:	d041      	beq.n	34194de6 <RCCEx_GetXSPICLKFreq+0xce>
34194d62:	4a6c      	ldr	r2, [pc, #432]	@ (34194f14 <RCCEx_GetXSPICLKFreq+0x1fc>)
34194d64:	4293      	cmp	r3, r2
34194d66:	f200 80c5 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d6a:	4a6b      	ldr	r2, [pc, #428]	@ (34194f18 <RCCEx_GetXSPICLKFreq+0x200>)
34194d6c:	4293      	cmp	r3, r2
34194d6e:	d03a      	beq.n	34194de6 <RCCEx_GetXSPICLKFreq+0xce>
34194d70:	4a69      	ldr	r2, [pc, #420]	@ (34194f18 <RCCEx_GetXSPICLKFreq+0x200>)
34194d72:	4293      	cmp	r3, r2
34194d74:	f200 80be 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d78:	4a68      	ldr	r2, [pc, #416]	@ (34194f1c <RCCEx_GetXSPICLKFreq+0x204>)
34194d7a:	4293      	cmp	r3, r2
34194d7c:	d033      	beq.n	34194de6 <RCCEx_GetXSPICLKFreq+0xce>
34194d7e:	4a67      	ldr	r2, [pc, #412]	@ (34194f1c <RCCEx_GetXSPICLKFreq+0x204>)
34194d80:	4293      	cmp	r3, r2
34194d82:	f200 80b7 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d86:	4a66      	ldr	r2, [pc, #408]	@ (34194f20 <RCCEx_GetXSPICLKFreq+0x208>)
34194d88:	4293      	cmp	r3, r2
34194d8a:	d027      	beq.n	34194ddc <RCCEx_GetXSPICLKFreq+0xc4>
34194d8c:	4a64      	ldr	r2, [pc, #400]	@ (34194f20 <RCCEx_GetXSPICLKFreq+0x208>)
34194d8e:	4293      	cmp	r3, r2
34194d90:	f200 80b0 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194d94:	4a63      	ldr	r2, [pc, #396]	@ (34194f24 <RCCEx_GetXSPICLKFreq+0x20c>)
34194d96:	4293      	cmp	r3, r2
34194d98:	d020      	beq.n	34194ddc <RCCEx_GetXSPICLKFreq+0xc4>
34194d9a:	4a62      	ldr	r2, [pc, #392]	@ (34194f24 <RCCEx_GetXSPICLKFreq+0x20c>)
34194d9c:	4293      	cmp	r3, r2
34194d9e:	f200 80a9 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194da2:	4a61      	ldr	r2, [pc, #388]	@ (34194f28 <RCCEx_GetXSPICLKFreq+0x210>)
34194da4:	4293      	cmp	r3, r2
34194da6:	d019      	beq.n	34194ddc <RCCEx_GetXSPICLKFreq+0xc4>
34194da8:	4a5f      	ldr	r2, [pc, #380]	@ (34194f28 <RCCEx_GetXSPICLKFreq+0x210>)
34194daa:	4293      	cmp	r3, r2
34194dac:	f200 80a2 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194db0:	4a5e      	ldr	r2, [pc, #376]	@ (34194f2c <RCCEx_GetXSPICLKFreq+0x214>)
34194db2:	4293      	cmp	r3, r2
34194db4:	d00a      	beq.n	34194dcc <RCCEx_GetXSPICLKFreq+0xb4>
34194db6:	4a5d      	ldr	r2, [pc, #372]	@ (34194f2c <RCCEx_GetXSPICLKFreq+0x214>)
34194db8:	4293      	cmp	r3, r2
34194dba:	f200 809b 	bhi.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
34194dbe:	4a5c      	ldr	r2, [pc, #368]	@ (34194f30 <RCCEx_GetXSPICLKFreq+0x218>)
34194dc0:	4293      	cmp	r3, r2
34194dc2:	d003      	beq.n	34194dcc <RCCEx_GetXSPICLKFreq+0xb4>
34194dc4:	4a5b      	ldr	r2, [pc, #364]	@ (34194f34 <RCCEx_GetXSPICLKFreq+0x21c>)
34194dc6:	4293      	cmp	r3, r2
34194dc8:	f040 8094 	bne.w	34194ef4 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34194dcc:	f7f7 fce8 	bl	3418c7a0 <HAL_RCC_GetSysClockFreq>
34194dd0:	4603      	mov	r3, r0
34194dd2:	4618      	mov	r0, r3
34194dd4:	f7fc fc9c 	bl	34191710 <RCCEx_GetHCLKFreq>
34194dd8:	60f8      	str	r0, [r7, #12]
      break;
34194dda:	e090      	b.n	34194efe <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194ddc:	2007      	movs	r0, #7
34194dde:	f7fc ff83 	bl	34191ce8 <RCCEx_GetCLKPCLKFreq>
34194de2:	60f8      	str	r0, [r7, #12]
      break;
34194de4:	e08b      	b.n	34194efe <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
34194de6:	f7f8 ffe7 	bl	3418ddb8 <LL_RCC_IC3_IsEnabled>
34194dea:	4603      	mov	r3, r0
34194dec:	2b00      	cmp	r3, #0
34194dee:	f000 8083 	beq.w	34194ef8 <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
34194df2:	f7f9 f803 	bl	3418ddfc <LL_RCC_IC3_GetDivider>
34194df6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34194df8:	f7f8 fff2 	bl	3418dde0 <LL_RCC_IC3_GetSource>
34194dfc:	4603      	mov	r3, r0
34194dfe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194e02:	d029      	beq.n	34194e58 <RCCEx_GetXSPICLKFreq+0x140>
34194e04:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194e08:	d82f      	bhi.n	34194e6a <RCCEx_GetXSPICLKFreq+0x152>
34194e0a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e0e:	d01a      	beq.n	34194e46 <RCCEx_GetXSPICLKFreq+0x12e>
34194e10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e14:	d829      	bhi.n	34194e6a <RCCEx_GetXSPICLKFreq+0x152>
34194e16:	2b00      	cmp	r3, #0
34194e18:	d003      	beq.n	34194e22 <RCCEx_GetXSPICLKFreq+0x10a>
34194e1a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194e1e:	d009      	beq.n	34194e34 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194e20:	e023      	b.n	34194e6a <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194e22:	f7fc fb5d 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194e26:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194e28:	68fa      	ldr	r2, [r7, #12]
34194e2a:	68bb      	ldr	r3, [r7, #8]
34194e2c:	fbb2 f3f3 	udiv	r3, r2, r3
34194e30:	60fb      	str	r3, [r7, #12]
            break;
34194e32:	e01b      	b.n	34194e6c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194e34:	f7fc fb9a 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194e38:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194e3a:	68fa      	ldr	r2, [r7, #12]
34194e3c:	68bb      	ldr	r3, [r7, #8]
34194e3e:	fbb2 f3f3 	udiv	r3, r2, r3
34194e42:	60fb      	str	r3, [r7, #12]
            break;
34194e44:	e012      	b.n	34194e6c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194e46:	f7fc fbd7 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34194e4a:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194e4c:	68fa      	ldr	r2, [r7, #12]
34194e4e:	68bb      	ldr	r3, [r7, #8]
34194e50:	fbb2 f3f3 	udiv	r3, r2, r3
34194e54:	60fb      	str	r3, [r7, #12]
            break;
34194e56:	e009      	b.n	34194e6c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194e58:	f7fc fc14 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194e5c:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194e5e:	68fa      	ldr	r2, [r7, #12]
34194e60:	68bb      	ldr	r3, [r7, #8]
34194e62:	fbb2 f3f3 	udiv	r3, r2, r3
34194e66:	60fb      	str	r3, [r7, #12]
            break;
34194e68:	e000      	b.n	34194e6c <RCCEx_GetXSPICLKFreq+0x154>
            break;
34194e6a:	bf00      	nop
        }
      }
      break;
34194e6c:	e044      	b.n	34194ef8 <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
34194e6e:	f7f8 ffe3 	bl	3418de38 <LL_RCC_IC4_IsEnabled>
34194e72:	4603      	mov	r3, r0
34194e74:	2b00      	cmp	r3, #0
34194e76:	d041      	beq.n	34194efc <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34194e78:	f7f9 f800 	bl	3418de7c <LL_RCC_IC4_GetDivider>
34194e7c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34194e7e:	f7f8 ffef 	bl	3418de60 <LL_RCC_IC4_GetSource>
34194e82:	4603      	mov	r3, r0
34194e84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194e88:	d029      	beq.n	34194ede <RCCEx_GetXSPICLKFreq+0x1c6>
34194e8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194e8e:	d82f      	bhi.n	34194ef0 <RCCEx_GetXSPICLKFreq+0x1d8>
34194e90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e94:	d01a      	beq.n	34194ecc <RCCEx_GetXSPICLKFreq+0x1b4>
34194e96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e9a:	d829      	bhi.n	34194ef0 <RCCEx_GetXSPICLKFreq+0x1d8>
34194e9c:	2b00      	cmp	r3, #0
34194e9e:	d003      	beq.n	34194ea8 <RCCEx_GetXSPICLKFreq+0x190>
34194ea0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194ea4:	d009      	beq.n	34194eba <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194ea6:	e023      	b.n	34194ef0 <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194ea8:	f7fc fb1a 	bl	341914e0 <HAL_RCCEx_GetPLL1CLKFreq>
34194eac:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194eae:	68fa      	ldr	r2, [r7, #12]
34194eb0:	68bb      	ldr	r3, [r7, #8]
34194eb2:	fbb2 f3f3 	udiv	r3, r2, r3
34194eb6:	60fb      	str	r3, [r7, #12]
            break;
34194eb8:	e01b      	b.n	34194ef2 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194eba:	f7fc fb57 	bl	3419156c <HAL_RCCEx_GetPLL2CLKFreq>
34194ebe:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194ec0:	68fa      	ldr	r2, [r7, #12]
34194ec2:	68bb      	ldr	r3, [r7, #8]
34194ec4:	fbb2 f3f3 	udiv	r3, r2, r3
34194ec8:	60fb      	str	r3, [r7, #12]
            break;
34194eca:	e012      	b.n	34194ef2 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194ecc:	f7fc fb94 	bl	341915f8 <HAL_RCCEx_GetPLL3CLKFreq>
34194ed0:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194ed2:	68fa      	ldr	r2, [r7, #12]
34194ed4:	68bb      	ldr	r3, [r7, #8]
34194ed6:	fbb2 f3f3 	udiv	r3, r2, r3
34194eda:	60fb      	str	r3, [r7, #12]
            break;
34194edc:	e009      	b.n	34194ef2 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194ede:	f7fc fbd1 	bl	34191684 <HAL_RCCEx_GetPLL4CLKFreq>
34194ee2:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34194ee4:	68fa      	ldr	r2, [r7, #12]
34194ee6:	68bb      	ldr	r3, [r7, #8]
34194ee8:	fbb2 f3f3 	udiv	r3, r2, r3
34194eec:	60fb      	str	r3, [r7, #12]
            break;
34194eee:	e000      	b.n	34194ef2 <RCCEx_GetXSPICLKFreq+0x1da>
            break;
34194ef0:	bf00      	nop
        }
      }
      break;
34194ef2:	e003      	b.n	34194efc <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
34194ef4:	bf00      	nop
34194ef6:	e002      	b.n	34194efe <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
34194ef8:	bf00      	nop
34194efa:	e000      	b.n	34194efe <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
34194efc:	bf00      	nop
  }

  return xspi_frequency;
34194efe:	68fb      	ldr	r3, [r7, #12]
}
34194f00:	4618      	mov	r0, r3
34194f02:	3710      	adds	r7, #16
34194f04:	46bd      	mov	sp, r7
34194f06:	bd80      	pop	{r7, pc}
34194f08:	03030814 	.word	0x03030814
34194f0c:	03030414 	.word	0x03030414
34194f10:	03030014 	.word	0x03030014
34194f14:	03020814 	.word	0x03020814
34194f18:	03020414 	.word	0x03020414
34194f1c:	03020014 	.word	0x03020014
34194f20:	03010814 	.word	0x03010814
34194f24:	03010414 	.word	0x03010414
34194f28:	03010014 	.word	0x03010014
34194f2c:	03000814 	.word	0x03000814
34194f30:	03000014 	.word	0x03000014
34194f34:	03000414 	.word	0x03000414

34194f38 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
34194f38:	b480      	push	{r7}
34194f3a:	b089      	sub	sp, #36	@ 0x24
34194f3c:	af00      	add	r7, sp, #0
34194f3e:	6078      	str	r0, [r7, #4]
34194f40:	6039      	str	r1, [r7, #0]
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
34194f42:	683b      	ldr	r3, [r7, #0]
34194f44:	681b      	ldr	r3, [r3, #0]
34194f46:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34194f48:	693b      	ldr	r3, [r7, #16]
34194f4a:	fa93 f3a3 	rbit	r3, r3
34194f4e:	60fb      	str	r3, [r7, #12]
  return result;
34194f50:	68fb      	ldr	r3, [r7, #12]
34194f52:	617b      	str	r3, [r7, #20]
  if (value == 0U)
34194f54:	697b      	ldr	r3, [r7, #20]
34194f56:	2b00      	cmp	r3, #0
34194f58:	d101      	bne.n	34194f5e <HAL_RIF_RIMC_ConfigMasterAttributes+0x26>
    return 32U;
34194f5a:	2320      	movs	r3, #32
34194f5c:	e003      	b.n	34194f66 <HAL_RIF_RIMC_ConfigMasterAttributes+0x2e>
  return __builtin_clz(value);
34194f5e:	697b      	ldr	r3, [r7, #20]
34194f60:	fab3 f383 	clz	r3, r3
34194f64:	b2db      	uxtb	r3, r3
34194f66:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
34194f68:	4a10      	ldr	r2, [pc, #64]	@ (34194fac <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34194f6a:	687b      	ldr	r3, [r7, #4]
34194f6c:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34194f70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34194f74:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34194f76:	69bb      	ldr	r3, [r7, #24]
34194f78:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
34194f7c:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
34194f7e:	69fb      	ldr	r3, [r7, #28]
34194f80:	011a      	lsls	r2, r3, #4
34194f82:	683b      	ldr	r3, [r7, #0]
34194f84:	685b      	ldr	r3, [r3, #4]
34194f86:	021b      	lsls	r3, r3, #8
34194f88:	4313      	orrs	r3, r2
34194f8a:	69ba      	ldr	r2, [r7, #24]
34194f8c:	4313      	orrs	r3, r2
34194f8e:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
34194f90:	4906      	ldr	r1, [pc, #24]	@ (34194fac <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34194f92:	687b      	ldr	r3, [r7, #4]
34194f94:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34194f98:	69ba      	ldr	r2, [r7, #24]
34194f9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34194f9e:	bf00      	nop
34194fa0:	3724      	adds	r7, #36	@ 0x24
34194fa2:	46bd      	mov	sp, r7
34194fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
34194fa8:	4770      	bx	lr
34194faa:	bf00      	nop
34194fac:	54024000 	.word	0x54024000

34194fb0 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34194fb0:	b480      	push	{r7}
34194fb2:	b085      	sub	sp, #20
34194fb4:	af00      	add	r7, sp, #0
34194fb6:	6078      	str	r0, [r7, #4]
34194fb8:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34194fba:	4a25      	ldr	r2, [pc, #148]	@ (34195050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34194fbc:	687b      	ldr	r3, [r7, #4]
34194fbe:	0f1b      	lsrs	r3, r3, #28
34194fc0:	3304      	adds	r3, #4
34194fc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34194fc6:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34194fc8:	687b      	ldr	r3, [r7, #4]
34194fca:	f003 031f 	and.w	r3, r3, #31
34194fce:	2201      	movs	r2, #1
34194fd0:	fa02 f303 	lsl.w	r3, r2, r3
34194fd4:	43da      	mvns	r2, r3
34194fd6:	68fb      	ldr	r3, [r7, #12]
34194fd8:	4013      	ands	r3, r2
34194fda:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34194fdc:	683b      	ldr	r3, [r7, #0]
34194fde:	f003 0201 	and.w	r2, r3, #1
34194fe2:	687b      	ldr	r3, [r7, #4]
34194fe4:	f003 031f 	and.w	r3, r3, #31
34194fe8:	409a      	lsls	r2, r3
34194fea:	68fb      	ldr	r3, [r7, #12]
34194fec:	4313      	orrs	r3, r2
34194fee:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34194ff0:	4917      	ldr	r1, [pc, #92]	@ (34195050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34194ff2:	687b      	ldr	r3, [r7, #4]
34194ff4:	0f1b      	lsrs	r3, r3, #28
34194ff6:	68fa      	ldr	r2, [r7, #12]
34194ff8:	3304      	adds	r3, #4
34194ffa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
34194ffe:	4a14      	ldr	r2, [pc, #80]	@ (34195050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34195000:	687b      	ldr	r3, [r7, #4]
34195002:	0f1b      	lsrs	r3, r3, #28
34195004:	330c      	adds	r3, #12
34195006:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3419500a:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3419500c:	687b      	ldr	r3, [r7, #4]
3419500e:	f003 031f 	and.w	r3, r3, #31
34195012:	2201      	movs	r2, #1
34195014:	fa02 f303 	lsl.w	r3, r2, r3
34195018:	43da      	mvns	r2, r3
3419501a:	68fb      	ldr	r3, [r7, #12]
3419501c:	4013      	ands	r3, r2
3419501e:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
34195020:	683b      	ldr	r3, [r7, #0]
34195022:	085b      	lsrs	r3, r3, #1
34195024:	f003 0201 	and.w	r2, r3, #1
34195028:	687b      	ldr	r3, [r7, #4]
3419502a:	f003 031f 	and.w	r3, r3, #31
3419502e:	409a      	lsls	r2, r3
34195030:	68fb      	ldr	r3, [r7, #12]
34195032:	4313      	orrs	r3, r2
34195034:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34195036:	4906      	ldr	r1, [pc, #24]	@ (34195050 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34195038:	687b      	ldr	r3, [r7, #4]
3419503a:	0f1b      	lsrs	r3, r3, #28
3419503c:	68fa      	ldr	r2, [r7, #12]
3419503e:	330c      	adds	r3, #12
34195040:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
34195044:	bf00      	nop
34195046:	3714      	adds	r7, #20
34195048:	46bd      	mov	sp, r7
3419504a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419504e:	4770      	bx	lr
34195050:	54024000 	.word	0x54024000

34195054 <LL_AHB5_GRP1_IsEnabledClock>:
{
34195054:	b480      	push	{r7}
34195056:	b083      	sub	sp, #12
34195058:	af00      	add	r7, sp, #0
3419505a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
3419505c:	4b08      	ldr	r3, [pc, #32]	@ (34195080 <LL_AHB5_GRP1_IsEnabledClock+0x2c>)
3419505e:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
34195062:	687b      	ldr	r3, [r7, #4]
34195064:	4013      	ands	r3, r2
34195066:	687a      	ldr	r2, [r7, #4]
34195068:	429a      	cmp	r2, r3
3419506a:	d101      	bne.n	34195070 <LL_AHB5_GRP1_IsEnabledClock+0x1c>
3419506c:	2301      	movs	r3, #1
3419506e:	e000      	b.n	34195072 <LL_AHB5_GRP1_IsEnabledClock+0x1e>
34195070:	2300      	movs	r3, #0
}
34195072:	4618      	mov	r0, r3
34195074:	370c      	adds	r7, #12
34195076:	46bd      	mov	sp, r7
34195078:	f85d 7b04 	ldr.w	r7, [sp], #4
3419507c:	4770      	bx	lr
3419507e:	bf00      	nop
34195080:	56028000 	.word	0x56028000

34195084 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
34195084:	b580      	push	{r7, lr}
34195086:	b086      	sub	sp, #24
34195088:	af02      	add	r7, sp, #8
3419508a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3419508c:	2300      	movs	r3, #0
3419508e:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34195090:	f7f0 f95e 	bl	34185350 <HAL_GetTick>
34195094:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
34195096:	687b      	ldr	r3, [r7, #4]
34195098:	2b00      	cmp	r3, #0
3419509a:	d102      	bne.n	341950a2 <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
3419509c:	2301      	movs	r3, #1
3419509e:	73fb      	strb	r3, [r7, #15]
341950a0:	e0ec      	b.n	3419527c <HAL_XSPI_Init+0x1f8>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
341950a2:	687b      	ldr	r3, [r7, #4]
341950a4:	2200      	movs	r2, #0
341950a6:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
341950a8:	687b      	ldr	r3, [r7, #4]
341950aa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341950ac:	2b00      	cmp	r3, #0
341950ae:	f040 80e5 	bne.w	3419527c <HAL_XSPI_Init+0x1f8>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
341950b2:	6878      	ldr	r0, [r7, #4]
341950b4:	f7ee f886 	bl	341831c4 <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341950b8:	f241 3188 	movw	r1, #5000	@ 0x1388
341950bc:	6878      	ldr	r0, [r7, #4]
341950be:	f000 fc3c 	bl	3419593a <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
341950c2:	687b      	ldr	r3, [r7, #4]
341950c4:	681b      	ldr	r3, [r3, #0]
341950c6:	689a      	ldr	r2, [r3, #8]
341950c8:	4b6f      	ldr	r3, [pc, #444]	@ (34195288 <HAL_XSPI_Init+0x204>)
341950ca:	4013      	ands	r3, r2
341950cc:	687a      	ldr	r2, [r7, #4]
341950ce:	68d1      	ldr	r1, [r2, #12]
341950d0:	687a      	ldr	r2, [r7, #4]
341950d2:	6912      	ldr	r2, [r2, #16]
341950d4:	0412      	lsls	r2, r2, #16
341950d6:	4311      	orrs	r1, r2
341950d8:	687a      	ldr	r2, [r7, #4]
341950da:	6952      	ldr	r2, [r2, #20]
341950dc:	3a01      	subs	r2, #1
341950de:	0212      	lsls	r2, r2, #8
341950e0:	4311      	orrs	r1, r2
341950e2:	687a      	ldr	r2, [r7, #4]
341950e4:	69d2      	ldr	r2, [r2, #28]
341950e6:	4311      	orrs	r1, r2
341950e8:	687a      	ldr	r2, [r7, #4]
341950ea:	6812      	ldr	r2, [r2, #0]
341950ec:	430b      	orrs	r3, r1
341950ee:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
341950f0:	687b      	ldr	r3, [r7, #4]
341950f2:	681b      	ldr	r3, [r3, #0]
341950f4:	68db      	ldr	r3, [r3, #12]
341950f6:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
341950fa:	687b      	ldr	r3, [r7, #4]
341950fc:	6a1a      	ldr	r2, [r3, #32]
341950fe:	687b      	ldr	r3, [r7, #4]
34195100:	681b      	ldr	r3, [r3, #0]
34195102:	430a      	orrs	r2, r1
34195104:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
34195106:	687b      	ldr	r3, [r7, #4]
34195108:	681b      	ldr	r3, [r3, #0]
3419510a:	691b      	ldr	r3, [r3, #16]
3419510c:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
34195110:	687b      	ldr	r3, [r7, #4]
34195112:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195114:	041a      	lsls	r2, r3, #16
34195116:	687b      	ldr	r3, [r7, #4]
34195118:	681b      	ldr	r3, [r3, #0]
3419511a:	430a      	orrs	r2, r1
3419511c:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3419511e:	687b      	ldr	r3, [r7, #4]
34195120:	681b      	ldr	r3, [r3, #0]
34195122:	691b      	ldr	r3, [r3, #16]
34195124:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34195128:	687b      	ldr	r3, [r7, #4]
3419512a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3419512c:	687b      	ldr	r3, [r7, #4]
3419512e:	681b      	ldr	r3, [r3, #0]
34195130:	430a      	orrs	r2, r1
34195132:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
34195134:	687b      	ldr	r3, [r7, #4]
34195136:	681b      	ldr	r3, [r3, #0]
34195138:	687a      	ldr	r2, [r7, #4]
3419513a:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3419513c:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3419513e:	687b      	ldr	r3, [r7, #4]
34195140:	681b      	ldr	r3, [r3, #0]
34195142:	681b      	ldr	r3, [r3, #0]
34195144:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
34195148:	687b      	ldr	r3, [r7, #4]
3419514a:	685b      	ldr	r3, [r3, #4]
3419514c:	3b01      	subs	r3, #1
3419514e:	021a      	lsls	r2, r3, #8
34195150:	687b      	ldr	r3, [r7, #4]
34195152:	681b      	ldr	r3, [r3, #0]
34195154:	430a      	orrs	r2, r1
34195156:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34195158:	687b      	ldr	r3, [r7, #4]
3419515a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419515c:	9300      	str	r3, [sp, #0]
3419515e:	68bb      	ldr	r3, [r7, #8]
34195160:	2200      	movs	r2, #0
34195162:	2120      	movs	r1, #32
34195164:	6878      	ldr	r0, [r7, #4]
34195166:	f000 fd23 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
3419516a:	4603      	mov	r3, r0
3419516c:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
3419516e:	7bfb      	ldrb	r3, [r7, #15]
34195170:	2b00      	cmp	r3, #0
34195172:	f040 8083 	bne.w	3419527c <HAL_XSPI_Init+0x1f8>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34195176:	687b      	ldr	r3, [r7, #4]
34195178:	681b      	ldr	r3, [r3, #0]
3419517a:	68db      	ldr	r3, [r3, #12]
3419517c:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34195180:	687b      	ldr	r3, [r7, #4]
34195182:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34195184:	687b      	ldr	r3, [r7, #4]
34195186:	681b      	ldr	r3, [r3, #0]
34195188:	430a      	orrs	r2, r1
3419518a:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3419518c:	687b      	ldr	r3, [r7, #4]
3419518e:	681b      	ldr	r3, [r3, #0]
34195190:	4a3e      	ldr	r2, [pc, #248]	@ (3419528c <HAL_XSPI_Init+0x208>)
34195192:	4293      	cmp	r3, r2
34195194:	d018      	beq.n	341951c8 <HAL_XSPI_Init+0x144>
34195196:	687b      	ldr	r3, [r7, #4]
34195198:	681b      	ldr	r3, [r3, #0]
3419519a:	4a3d      	ldr	r2, [pc, #244]	@ (34195290 <HAL_XSPI_Init+0x20c>)
3419519c:	4293      	cmp	r3, r2
3419519e:	d013      	beq.n	341951c8 <HAL_XSPI_Init+0x144>
341951a0:	687b      	ldr	r3, [r7, #4]
341951a2:	681b      	ldr	r3, [r3, #0]
341951a4:	4a3b      	ldr	r2, [pc, #236]	@ (34195294 <HAL_XSPI_Init+0x210>)
341951a6:	4293      	cmp	r3, r2
341951a8:	d00e      	beq.n	341951c8 <HAL_XSPI_Init+0x144>
341951aa:	687b      	ldr	r3, [r7, #4]
341951ac:	681b      	ldr	r3, [r3, #0]
341951ae:	4a3a      	ldr	r2, [pc, #232]	@ (34195298 <HAL_XSPI_Init+0x214>)
341951b0:	4293      	cmp	r3, r2
341951b2:	d009      	beq.n	341951c8 <HAL_XSPI_Init+0x144>
341951b4:	687b      	ldr	r3, [r7, #4]
341951b6:	681b      	ldr	r3, [r3, #0]
341951b8:	4a38      	ldr	r2, [pc, #224]	@ (3419529c <HAL_XSPI_Init+0x218>)
341951ba:	4293      	cmp	r3, r2
341951bc:	d004      	beq.n	341951c8 <HAL_XSPI_Init+0x144>
341951be:	687b      	ldr	r3, [r7, #4]
341951c0:	681b      	ldr	r3, [r3, #0]
341951c2:	4a37      	ldr	r2, [pc, #220]	@ (341952a0 <HAL_XSPI_Init+0x21c>)
341951c4:	4293      	cmp	r3, r2
341951c6:	d10f      	bne.n	341951e8 <HAL_XSPI_Init+0x164>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
341951c8:	687b      	ldr	r3, [r7, #4]
341951ca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
341951cc:	9300      	str	r3, [sp, #0]
341951ce:	68bb      	ldr	r3, [r7, #8]
341951d0:	2200      	movs	r2, #0
341951d2:	2120      	movs	r1, #32
341951d4:	6878      	ldr	r0, [r7, #4]
341951d6:	f000 fceb 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
341951da:	4603      	mov	r3, r0
341951dc:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
341951de:	7bfb      	ldrb	r3, [r7, #15]
341951e0:	2b00      	cmp	r3, #0
341951e2:	d001      	beq.n	341951e8 <HAL_XSPI_Init+0x164>
          {
            return status;
341951e4:	7bfb      	ldrb	r3, [r7, #15]
341951e6:	e04a      	b.n	3419527e <HAL_XSPI_Init+0x1fa>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
341951e8:	687b      	ldr	r3, [r7, #4]
341951ea:	681b      	ldr	r3, [r3, #0]
341951ec:	681b      	ldr	r3, [r3, #0]
341951ee:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
341951f2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
341951f6:	687a      	ldr	r2, [r7, #4]
341951f8:	6891      	ldr	r1, [r2, #8]
341951fa:	687a      	ldr	r2, [r7, #4]
341951fc:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
341951fe:	4311      	orrs	r1, r2
34195200:	687a      	ldr	r2, [r7, #4]
34195202:	6812      	ldr	r2, [r2, #0]
34195204:	430b      	orrs	r3, r1
34195206:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
34195208:	687b      	ldr	r3, [r7, #4]
3419520a:	681b      	ldr	r3, [r3, #0]
3419520c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34195210:	f023 4180 	bic.w	r1, r3, #1073741824	@ 0x40000000
34195214:	687b      	ldr	r3, [r7, #4]
34195216:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34195218:	687b      	ldr	r3, [r7, #4]
3419521a:	681b      	ldr	r3, [r3, #0]
3419521c:	430a      	orrs	r2, r1
3419521e:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
34195222:	687b      	ldr	r3, [r7, #4]
34195224:	681b      	ldr	r3, [r3, #0]
34195226:	681a      	ldr	r2, [r3, #0]
34195228:	687b      	ldr	r3, [r7, #4]
3419522a:	681b      	ldr	r3, [r3, #0]
3419522c:	f042 0201 	orr.w	r2, r2, #1
34195230:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
34195232:	687b      	ldr	r3, [r7, #4]
34195234:	699b      	ldr	r3, [r3, #24]
34195236:	2b02      	cmp	r3, #2
34195238:	d107      	bne.n	3419524a <HAL_XSPI_Init+0x1c6>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3419523a:	687b      	ldr	r3, [r7, #4]
3419523c:	681b      	ldr	r3, [r3, #0]
3419523e:	689a      	ldr	r2, [r3, #8]
34195240:	687b      	ldr	r3, [r7, #4]
34195242:	681b      	ldr	r3, [r3, #0]
34195244:	f042 0202 	orr.w	r2, r2, #2
34195248:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3419524a:	687b      	ldr	r3, [r7, #4]
3419524c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419524e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34195252:	d107      	bne.n	34195264 <HAL_XSPI_Init+0x1e0>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
34195254:	687b      	ldr	r3, [r7, #4]
34195256:	681b      	ldr	r3, [r3, #0]
34195258:	689a      	ldr	r2, [r3, #8]
3419525a:	687b      	ldr	r3, [r7, #4]
3419525c:	681b      	ldr	r3, [r3, #0]
3419525e:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
34195262:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34195264:	687b      	ldr	r3, [r7, #4]
34195266:	68db      	ldr	r3, [r3, #12]
34195268:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3419526c:	d103      	bne.n	34195276 <HAL_XSPI_Init+0x1f2>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3419526e:	687b      	ldr	r3, [r7, #4]
34195270:	2201      	movs	r2, #1
34195272:	659a      	str	r2, [r3, #88]	@ 0x58
34195274:	e002      	b.n	3419527c <HAL_XSPI_Init+0x1f8>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
34195276:	687b      	ldr	r3, [r7, #4]
34195278:	2202      	movs	r2, #2
3419527a:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
3419527c:	7bfb      	ldrb	r3, [r7, #15]
}
3419527e:	4618      	mov	r0, r3
34195280:	3710      	adds	r7, #16
34195282:	46bd      	mov	sp, r7
34195284:	bd80      	pop	{r7, pc}
34195286:	bf00      	nop
34195288:	f8e0c0fc 	.word	0xf8e0c0fc
3419528c:	58025000 	.word	0x58025000
34195290:	48025000 	.word	0x48025000
34195294:	5802a000 	.word	0x5802a000
34195298:	4802a000 	.word	0x4802a000
3419529c:	5802d000 	.word	0x5802d000
341952a0:	4802d000 	.word	0x4802d000

341952a4 <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd, uint32_t Timeout)
{
341952a4:	b580      	push	{r7, lr}
341952a6:	b08a      	sub	sp, #40	@ 0x28
341952a8:	af02      	add	r7, sp, #8
341952aa:	60f8      	str	r0, [r7, #12]
341952ac:	60b9      	str	r1, [r7, #8]
341952ae:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
341952b0:	f7f0 f84e 	bl	34185350 <HAL_GetTick>
341952b4:	61b8      	str	r0, [r7, #24]
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
341952b6:	68bb      	ldr	r3, [r7, #8]
341952b8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341952ba:	2b00      	cmp	r3, #0
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));

  /* Check the state of the driver */
  state = hxspi->State;
341952bc:	68fb      	ldr	r3, [r7, #12]
341952be:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341952c0:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
341952c2:	697b      	ldr	r3, [r7, #20]
341952c4:	2b02      	cmp	r3, #2
341952c6:	d104      	bne.n	341952d2 <HAL_XSPI_Command+0x2e>
341952c8:	68fb      	ldr	r3, [r7, #12]
341952ca:	68db      	ldr	r3, [r3, #12]
341952cc:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
341952d0:	d115      	bne.n	341952fe <HAL_XSPI_Command+0x5a>
341952d2:	697b      	ldr	r3, [r7, #20]
341952d4:	2b14      	cmp	r3, #20
341952d6:	d107      	bne.n	341952e8 <HAL_XSPI_Command+0x44>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
341952d8:	68bb      	ldr	r3, [r7, #8]
341952da:	681b      	ldr	r3, [r3, #0]
341952dc:	2b02      	cmp	r3, #2
341952de:	d00e      	beq.n	341952fe <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
341952e0:	68bb      	ldr	r3, [r7, #8]
341952e2:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
341952e4:	2b03      	cmp	r3, #3
341952e6:	d00a      	beq.n	341952fe <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
341952e8:	697b      	ldr	r3, [r7, #20]
341952ea:	2b24      	cmp	r3, #36	@ 0x24
341952ec:	d15e      	bne.n	341953ac <HAL_XSPI_Command+0x108>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
341952ee:	68bb      	ldr	r3, [r7, #8]
341952f0:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
341952f2:	2b01      	cmp	r3, #1
341952f4:	d003      	beq.n	341952fe <HAL_XSPI_Command+0x5a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
341952f6:	68bb      	ldr	r3, [r7, #8]
341952f8:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
341952fa:	2b03      	cmp	r3, #3
341952fc:	d156      	bne.n	341953ac <HAL_XSPI_Command+0x108>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
341952fe:	687b      	ldr	r3, [r7, #4]
34195300:	9300      	str	r3, [sp, #0]
34195302:	69bb      	ldr	r3, [r7, #24]
34195304:	2200      	movs	r2, #0
34195306:	2120      	movs	r1, #32
34195308:	68f8      	ldr	r0, [r7, #12]
3419530a:	f000 fc51 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
3419530e:	4603      	mov	r3, r0
34195310:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
34195312:	7ffb      	ldrb	r3, [r7, #31]
34195314:	2b00      	cmp	r3, #0
34195316:	d146      	bne.n	341953a6 <HAL_XSPI_Command+0x102>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34195318:	68fb      	ldr	r3, [r7, #12]
3419531a:	2200      	movs	r2, #0
3419531c:	65da      	str	r2, [r3, #92]	@ 0x5c

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
3419531e:	68b9      	ldr	r1, [r7, #8]
34195320:	68f8      	ldr	r0, [r7, #12]
34195322:	f000 fc7b 	bl	34195c1c <XSPI_ConfigCmd>
34195326:	4603      	mov	r3, r0
34195328:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
3419532a:	7ffb      	ldrb	r3, [r7, #31]
3419532c:	2b00      	cmp	r3, #0
3419532e:	d143      	bne.n	341953b8 <HAL_XSPI_Command+0x114>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
34195330:	68bb      	ldr	r3, [r7, #8]
34195332:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195334:	2b00      	cmp	r3, #0
34195336:	d10e      	bne.n	34195356 <HAL_XSPI_Command+0xb2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until BUSY flag is reset to go back in idle state. */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34195338:	687b      	ldr	r3, [r7, #4]
3419533a:	9300      	str	r3, [sp, #0]
3419533c:	69bb      	ldr	r3, [r7, #24]
3419533e:	2200      	movs	r2, #0
34195340:	2120      	movs	r1, #32
34195342:	68f8      	ldr	r0, [r7, #12]
34195344:	f000 fc34 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
34195348:	4603      	mov	r3, r0
3419534a:	77fb      	strb	r3, [r7, #31]

          /* Clear TC flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3419534c:	68fb      	ldr	r3, [r7, #12]
3419534e:	681b      	ldr	r3, [r3, #0]
34195350:	2202      	movs	r2, #2
34195352:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
34195354:	e030      	b.n	341953b8 <HAL_XSPI_Command+0x114>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34195356:	68bb      	ldr	r3, [r7, #8]
34195358:	681b      	ldr	r3, [r3, #0]
3419535a:	2b00      	cmp	r3, #0
3419535c:	d103      	bne.n	34195366 <HAL_XSPI_Command+0xc2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3419535e:	68fb      	ldr	r3, [r7, #12]
34195360:	2204      	movs	r2, #4
34195362:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34195364:	e028      	b.n	341953b8 <HAL_XSPI_Command+0x114>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
34195366:	68bb      	ldr	r3, [r7, #8]
34195368:	681b      	ldr	r3, [r3, #0]
3419536a:	2b01      	cmp	r3, #1
3419536c:	d10b      	bne.n	34195386 <HAL_XSPI_Command+0xe2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
3419536e:	68fb      	ldr	r3, [r7, #12]
34195370:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34195372:	2b24      	cmp	r3, #36	@ 0x24
34195374:	d103      	bne.n	3419537e <HAL_XSPI_Command+0xda>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34195376:	68fb      	ldr	r3, [r7, #12]
34195378:	2204      	movs	r2, #4
3419537a:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3419537c:	e01c      	b.n	341953b8 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
3419537e:	68fb      	ldr	r3, [r7, #12]
34195380:	2214      	movs	r2, #20
34195382:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34195384:	e018      	b.n	341953b8 <HAL_XSPI_Command+0x114>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34195386:	68bb      	ldr	r3, [r7, #8]
34195388:	681b      	ldr	r3, [r3, #0]
3419538a:	2b02      	cmp	r3, #2
3419538c:	d114      	bne.n	341953b8 <HAL_XSPI_Command+0x114>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
3419538e:	68fb      	ldr	r3, [r7, #12]
34195390:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34195392:	2b14      	cmp	r3, #20
34195394:	d103      	bne.n	3419539e <HAL_XSPI_Command+0xfa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34195396:	68fb      	ldr	r3, [r7, #12]
34195398:	2204      	movs	r2, #4
3419539a:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3419539c:	e00c      	b.n	341953b8 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3419539e:	68fb      	ldr	r3, [r7, #12]
341953a0:	2224      	movs	r2, #36	@ 0x24
341953a2:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
341953a4:	e008      	b.n	341953b8 <HAL_XSPI_Command+0x114>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
341953a6:	2302      	movs	r3, #2
341953a8:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
341953aa:	e005      	b.n	341953b8 <HAL_XSPI_Command+0x114>
    }
  }
  else
  {
    status = HAL_ERROR;
341953ac:	2301      	movs	r3, #1
341953ae:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
341953b0:	68fb      	ldr	r3, [r7, #12]
341953b2:	2210      	movs	r2, #16
341953b4:	65da      	str	r2, [r3, #92]	@ 0x5c
341953b6:	e000      	b.n	341953ba <HAL_XSPI_Command+0x116>
    if (status == HAL_OK)
341953b8:	bf00      	nop
  }

  return status;
341953ba:	7ffb      	ldrb	r3, [r7, #31]
}
341953bc:	4618      	mov	r0, r3
341953be:	3720      	adds	r7, #32
341953c0:	46bd      	mov	sp, r7
341953c2:	bd80      	pop	{r7, pc}

341953c4 <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
341953c4:	b580      	push	{r7, lr}
341953c6:	b08a      	sub	sp, #40	@ 0x28
341953c8:	af02      	add	r7, sp, #8
341953ca:	60f8      	str	r0, [r7, #12]
341953cc:	60b9      	str	r1, [r7, #8]
341953ce:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
341953d0:	f7ef ffbe 	bl	34185350 <HAL_GetTick>
341953d4:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
341953d6:	68fb      	ldr	r3, [r7, #12]
341953d8:	681b      	ldr	r3, [r3, #0]
341953da:	3350      	adds	r3, #80	@ 0x50
341953dc:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
341953de:	68bb      	ldr	r3, [r7, #8]
341953e0:	2b00      	cmp	r3, #0
341953e2:	d105      	bne.n	341953f0 <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
341953e4:	2301      	movs	r3, #1
341953e6:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
341953e8:	68fb      	ldr	r3, [r7, #12]
341953ea:	2208      	movs	r2, #8
341953ec:	65da      	str	r2, [r3, #92]	@ 0x5c
341953ee:	e057      	b.n	341954a0 <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
341953f0:	68fb      	ldr	r3, [r7, #12]
341953f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341953f4:	2b04      	cmp	r3, #4
341953f6:	d14e      	bne.n	34195496 <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
341953f8:	68fb      	ldr	r3, [r7, #12]
341953fa:	681b      	ldr	r3, [r3, #0]
341953fc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341953fe:	1c5a      	adds	r2, r3, #1
34195400:	68fb      	ldr	r3, [r7, #12]
34195402:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
34195404:	68fb      	ldr	r3, [r7, #12]
34195406:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34195408:	68fb      	ldr	r3, [r7, #12]
3419540a:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = (uint8_t *)pData;
3419540c:	68fb      	ldr	r3, [r7, #12]
3419540e:	68ba      	ldr	r2, [r7, #8]
34195410:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
34195412:	68fb      	ldr	r3, [r7, #12]
34195414:	681b      	ldr	r3, [r3, #0]
34195416:	681a      	ldr	r2, [r3, #0]
34195418:	68fb      	ldr	r3, [r7, #12]
3419541a:	681b      	ldr	r3, [r3, #0]
3419541c:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34195420:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
34195422:	687b      	ldr	r3, [r7, #4]
34195424:	9300      	str	r3, [sp, #0]
34195426:	69bb      	ldr	r3, [r7, #24]
34195428:	2201      	movs	r2, #1
3419542a:	2104      	movs	r1, #4
3419542c:	68f8      	ldr	r0, [r7, #12]
3419542e:	f000 fbbf 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
34195432:	4603      	mov	r3, r0
34195434:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
34195436:	7ffb      	ldrb	r3, [r7, #31]
34195438:	2b00      	cmp	r3, #0
3419543a:	d113      	bne.n	34195464 <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
3419543c:	68fb      	ldr	r3, [r7, #12]
3419543e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34195440:	781a      	ldrb	r2, [r3, #0]
34195442:	697b      	ldr	r3, [r7, #20]
34195444:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34195446:	68fb      	ldr	r3, [r7, #12]
34195448:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419544a:	1c5a      	adds	r2, r3, #1
3419544c:	68fb      	ldr	r3, [r7, #12]
3419544e:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
34195450:	68fb      	ldr	r3, [r7, #12]
34195452:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34195454:	1e5a      	subs	r2, r3, #1
34195456:	68fb      	ldr	r3, [r7, #12]
34195458:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
3419545a:	68fb      	ldr	r3, [r7, #12]
3419545c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419545e:	2b00      	cmp	r3, #0
34195460:	d1df      	bne.n	34195422 <HAL_XSPI_Transmit+0x5e>
34195462:	e000      	b.n	34195466 <HAL_XSPI_Transmit+0xa2>
          break;
34195464:	bf00      	nop

      if (status == HAL_OK)
34195466:	7ffb      	ldrb	r3, [r7, #31]
34195468:	2b00      	cmp	r3, #0
3419546a:	d119      	bne.n	341954a0 <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3419546c:	687b      	ldr	r3, [r7, #4]
3419546e:	9300      	str	r3, [sp, #0]
34195470:	69bb      	ldr	r3, [r7, #24]
34195472:	2201      	movs	r2, #1
34195474:	2102      	movs	r1, #2
34195476:	68f8      	ldr	r0, [r7, #12]
34195478:	f000 fb9a 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
3419547c:	4603      	mov	r3, r0
3419547e:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
34195480:	7ffb      	ldrb	r3, [r7, #31]
34195482:	2b00      	cmp	r3, #0
34195484:	d10c      	bne.n	341954a0 <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34195486:	68fb      	ldr	r3, [r7, #12]
34195488:	681b      	ldr	r3, [r3, #0]
3419548a:	2202      	movs	r2, #2
3419548c:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3419548e:	68fb      	ldr	r3, [r7, #12]
34195490:	2202      	movs	r2, #2
34195492:	659a      	str	r2, [r3, #88]	@ 0x58
34195494:	e004      	b.n	341954a0 <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
34195496:	2301      	movs	r3, #1
34195498:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3419549a:	68fb      	ldr	r3, [r7, #12]
3419549c:	2210      	movs	r2, #16
3419549e:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
341954a0:	7ffb      	ldrb	r3, [r7, #31]
}
341954a2:	4618      	mov	r0, r3
341954a4:	3720      	adds	r7, #32
341954a6:	46bd      	mov	sp, r7
341954a8:	bd80      	pop	{r7, pc}

341954aa <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *pData, uint32_t Timeout)
{
341954aa:	b580      	push	{r7, lr}
341954ac:	b08c      	sub	sp, #48	@ 0x30
341954ae:	af02      	add	r7, sp, #8
341954b0:	60f8      	str	r0, [r7, #12]
341954b2:	60b9      	str	r1, [r7, #8]
341954b4:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
341954b6:	f7ef ff4b 	bl	34185350 <HAL_GetTick>
341954ba:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
341954bc:	68fb      	ldr	r3, [r7, #12]
341954be:	681b      	ldr	r3, [r3, #0]
341954c0:	3350      	adds	r3, #80	@ 0x50
341954c2:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
341954c4:	68fb      	ldr	r3, [r7, #12]
341954c6:	681b      	ldr	r3, [r3, #0]
341954c8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341954ca:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
341954cc:	68fb      	ldr	r3, [r7, #12]
341954ce:	681b      	ldr	r3, [r3, #0]
341954d0:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
341954d4:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
341954d6:	68bb      	ldr	r3, [r7, #8]
341954d8:	2b00      	cmp	r3, #0
341954da:	d106      	bne.n	341954ea <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
341954dc:	2301      	movs	r3, #1
341954de:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
341954e2:	68fb      	ldr	r3, [r7, #12]
341954e4:	2208      	movs	r2, #8
341954e6:	65da      	str	r2, [r3, #92]	@ 0x5c
341954e8:	e07c      	b.n	341955e4 <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
341954ea:	68fb      	ldr	r3, [r7, #12]
341954ec:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341954ee:	2b04      	cmp	r3, #4
341954f0:	d172      	bne.n	341955d8 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
341954f2:	68fb      	ldr	r3, [r7, #12]
341954f4:	681b      	ldr	r3, [r3, #0]
341954f6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341954f8:	1c5a      	adds	r2, r3, #1
341954fa:	68fb      	ldr	r3, [r7, #12]
341954fc:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
341954fe:	68fb      	ldr	r3, [r7, #12]
34195500:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34195502:	68fb      	ldr	r3, [r7, #12]
34195504:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = pData;
34195506:	68fb      	ldr	r3, [r7, #12]
34195508:	68ba      	ldr	r2, [r7, #8]
3419550a:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
3419550c:	68fb      	ldr	r3, [r7, #12]
3419550e:	681b      	ldr	r3, [r3, #0]
34195510:	681b      	ldr	r3, [r3, #0]
34195512:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
34195516:	68fb      	ldr	r3, [r7, #12]
34195518:	681b      	ldr	r3, [r3, #0]
3419551a:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
3419551e:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34195520:	68fb      	ldr	r3, [r7, #12]
34195522:	68db      	ldr	r3, [r3, #12]
34195524:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34195528:	d104      	bne.n	34195534 <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3419552a:	68fb      	ldr	r3, [r7, #12]
3419552c:	681b      	ldr	r3, [r3, #0]
3419552e:	69ba      	ldr	r2, [r7, #24]
34195530:	649a      	str	r2, [r3, #72]	@ 0x48
34195532:	e011      	b.n	34195558 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34195534:	68fb      	ldr	r3, [r7, #12]
34195536:	681b      	ldr	r3, [r3, #0]
34195538:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419553c:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
34195540:	2b00      	cmp	r3, #0
34195542:	d004      	beq.n	3419554e <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34195544:	68fb      	ldr	r3, [r7, #12]
34195546:	681b      	ldr	r3, [r3, #0]
34195548:	69ba      	ldr	r2, [r7, #24]
3419554a:	649a      	str	r2, [r3, #72]	@ 0x48
3419554c:	e004      	b.n	34195558 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3419554e:	68fb      	ldr	r3, [r7, #12]
34195550:	681b      	ldr	r3, [r3, #0]
34195552:	697a      	ldr	r2, [r7, #20]
34195554:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
34195558:	687b      	ldr	r3, [r7, #4]
3419555a:	9300      	str	r3, [sp, #0]
3419555c:	6a3b      	ldr	r3, [r7, #32]
3419555e:	2201      	movs	r2, #1
34195560:	2106      	movs	r1, #6
34195562:	68f8      	ldr	r0, [r7, #12]
34195564:	f000 fb24 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
34195568:	4603      	mov	r3, r0
3419556a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
3419556e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34195572:	2b00      	cmp	r3, #0
34195574:	d114      	bne.n	341955a0 <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
34195576:	68fb      	ldr	r3, [r7, #12]
34195578:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419557a:	69fa      	ldr	r2, [r7, #28]
3419557c:	7812      	ldrb	r2, [r2, #0]
3419557e:	b2d2      	uxtb	r2, r2
34195580:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34195582:	68fb      	ldr	r3, [r7, #12]
34195584:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34195586:	1c5a      	adds	r2, r3, #1
34195588:	68fb      	ldr	r3, [r7, #12]
3419558a:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3419558c:	68fb      	ldr	r3, [r7, #12]
3419558e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34195590:	1e5a      	subs	r2, r3, #1
34195592:	68fb      	ldr	r3, [r7, #12]
34195594:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34195596:	68fb      	ldr	r3, [r7, #12]
34195598:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419559a:	2b00      	cmp	r3, #0
3419559c:	d1dc      	bne.n	34195558 <HAL_XSPI_Receive+0xae>
3419559e:	e000      	b.n	341955a2 <HAL_XSPI_Receive+0xf8>
          break;
341955a0:	bf00      	nop

      if (status == HAL_OK)
341955a2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341955a6:	2b00      	cmp	r3, #0
341955a8:	d11c      	bne.n	341955e4 <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
341955aa:	687b      	ldr	r3, [r7, #4]
341955ac:	9300      	str	r3, [sp, #0]
341955ae:	6a3b      	ldr	r3, [r7, #32]
341955b0:	2201      	movs	r2, #1
341955b2:	2102      	movs	r1, #2
341955b4:	68f8      	ldr	r0, [r7, #12]
341955b6:	f000 fafb 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
341955ba:	4603      	mov	r3, r0
341955bc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
341955c0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341955c4:	2b00      	cmp	r3, #0
341955c6:	d10d      	bne.n	341955e4 <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
341955c8:	68fb      	ldr	r3, [r7, #12]
341955ca:	681b      	ldr	r3, [r3, #0]
341955cc:	2202      	movs	r2, #2
341955ce:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
341955d0:	68fb      	ldr	r3, [r7, #12]
341955d2:	2202      	movs	r2, #2
341955d4:	659a      	str	r2, [r3, #88]	@ 0x58
341955d6:	e005      	b.n	341955e4 <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
341955d8:	2301      	movs	r3, #1
341955da:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
341955de:	68fb      	ldr	r3, [r7, #12]
341955e0:	2210      	movs	r2, #16
341955e2:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
341955e4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
341955e8:	4618      	mov	r0, r3
341955ea:	3728      	adds	r7, #40	@ 0x28
341955ec:	46bd      	mov	sp, r7
341955ee:	bd80      	pop	{r7, pc}

341955f0 <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, const XSPI_AutoPollingTypeDef *pCfg,
                                       uint32_t Timeout)
{
341955f0:	b580      	push	{r7, lr}
341955f2:	b08a      	sub	sp, #40	@ 0x28
341955f4:	af02      	add	r7, sp, #8
341955f6:	60f8      	str	r0, [r7, #12]
341955f8:	60b9      	str	r1, [r7, #8]
341955fa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
341955fc:	f7ef fea8 	bl	34185350 <HAL_GetTick>
34195600:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = hxspi->Instance->AR;
34195602:	68fb      	ldr	r3, [r7, #12]
34195604:	681b      	ldr	r3, [r3, #0]
34195606:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34195608:	617b      	str	r3, [r7, #20]
  uint32_t ir_reg = hxspi->Instance->IR;
3419560a:	68fb      	ldr	r3, [r7, #12]
3419560c:	681b      	ldr	r3, [r3, #0]
3419560e:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34195612:	613b      	str	r3, [r7, #16]
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
34195614:	68fb      	ldr	r3, [r7, #12]
34195616:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34195618:	2b04      	cmp	r3, #4
3419561a:	d167      	bne.n	341956ec <HAL_XSPI_AutoPolling+0xfc>
3419561c:	68bb      	ldr	r3, [r7, #8]
3419561e:	68db      	ldr	r3, [r3, #12]
34195620:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
34195624:	d162      	bne.n	341956ec <HAL_XSPI_AutoPolling+0xfc>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34195626:	687b      	ldr	r3, [r7, #4]
34195628:	9300      	str	r3, [sp, #0]
3419562a:	69bb      	ldr	r3, [r7, #24]
3419562c:	2200      	movs	r2, #0
3419562e:	2120      	movs	r1, #32
34195630:	68f8      	ldr	r0, [r7, #12]
34195632:	f000 fabd 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
34195636:	4603      	mov	r3, r0
34195638:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
3419563a:	7ffb      	ldrb	r3, [r7, #31]
3419563c:	2b00      	cmp	r3, #0
3419563e:	d152      	bne.n	341956e6 <HAL_XSPI_AutoPolling+0xf6>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
34195640:	68fb      	ldr	r3, [r7, #12]
34195642:	681b      	ldr	r3, [r3, #0]
34195644:	68ba      	ldr	r2, [r7, #8]
34195646:	6812      	ldr	r2, [r2, #0]
34195648:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
3419564c:	68fb      	ldr	r3, [r7, #12]
3419564e:	681b      	ldr	r3, [r3, #0]
34195650:	68ba      	ldr	r2, [r7, #8]
34195652:	6852      	ldr	r2, [r2, #4]
34195654:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
34195658:	68fb      	ldr	r3, [r7, #12]
3419565a:	681b      	ldr	r3, [r3, #0]
3419565c:	68ba      	ldr	r2, [r7, #8]
3419565e:	6912      	ldr	r2, [r2, #16]
34195660:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34195664:	68fb      	ldr	r3, [r7, #12]
34195666:	681b      	ldr	r3, [r3, #0]
34195668:	681b      	ldr	r3, [r3, #0]
3419566a:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
3419566e:	68bb      	ldr	r3, [r7, #8]
34195670:	6899      	ldr	r1, [r3, #8]
34195672:	68bb      	ldr	r3, [r7, #8]
34195674:	68db      	ldr	r3, [r3, #12]
34195676:	430b      	orrs	r3, r1
34195678:	431a      	orrs	r2, r3
3419567a:	68fb      	ldr	r3, [r7, #12]
3419567c:	681b      	ldr	r3, [r3, #0]
3419567e:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
34195682:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34195684:	68fb      	ldr	r3, [r7, #12]
34195686:	68db      	ldr	r3, [r3, #12]
34195688:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3419568c:	d104      	bne.n	34195698 <HAL_XSPI_AutoPolling+0xa8>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3419568e:	68fb      	ldr	r3, [r7, #12]
34195690:	681b      	ldr	r3, [r3, #0]
34195692:	697a      	ldr	r2, [r7, #20]
34195694:	649a      	str	r2, [r3, #72]	@ 0x48
34195696:	e011      	b.n	341956bc <HAL_XSPI_AutoPolling+0xcc>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34195698:	68fb      	ldr	r3, [r7, #12]
3419569a:	681b      	ldr	r3, [r3, #0]
3419569c:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
341956a0:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
341956a4:	2b00      	cmp	r3, #0
341956a6:	d004      	beq.n	341956b2 <HAL_XSPI_AutoPolling+0xc2>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
341956a8:	68fb      	ldr	r3, [r7, #12]
341956aa:	681b      	ldr	r3, [r3, #0]
341956ac:	697a      	ldr	r2, [r7, #20]
341956ae:	649a      	str	r2, [r3, #72]	@ 0x48
341956b0:	e004      	b.n	341956bc <HAL_XSPI_AutoPolling+0xcc>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
341956b2:	68fb      	ldr	r3, [r7, #12]
341956b4:	681b      	ldr	r3, [r3, #0]
341956b6:	693a      	ldr	r2, [r7, #16]
341956b8:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
341956bc:	687b      	ldr	r3, [r7, #4]
341956be:	9300      	str	r3, [sp, #0]
341956c0:	69bb      	ldr	r3, [r7, #24]
341956c2:	2201      	movs	r2, #1
341956c4:	2108      	movs	r1, #8
341956c6:	68f8      	ldr	r0, [r7, #12]
341956c8:	f000 fa72 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
341956cc:	4603      	mov	r3, r0
341956ce:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
341956d0:	7ffb      	ldrb	r3, [r7, #31]
341956d2:	2b00      	cmp	r3, #0
341956d4:	d110      	bne.n	341956f8 <HAL_XSPI_AutoPolling+0x108>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
341956d6:	68fb      	ldr	r3, [r7, #12]
341956d8:	681b      	ldr	r3, [r3, #0]
341956da:	2208      	movs	r2, #8
341956dc:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
341956de:	68fb      	ldr	r3, [r7, #12]
341956e0:	2202      	movs	r2, #2
341956e2:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
341956e4:	e008      	b.n	341956f8 <HAL_XSPI_AutoPolling+0x108>
      }
    }
    else
    {
      status = HAL_BUSY;
341956e6:	2302      	movs	r3, #2
341956e8:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
341956ea:	e005      	b.n	341956f8 <HAL_XSPI_AutoPolling+0x108>
    }
  }
  else
  {
    status = HAL_ERROR;
341956ec:	2301      	movs	r3, #1
341956ee:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
341956f0:	68fb      	ldr	r3, [r7, #12]
341956f2:	2210      	movs	r2, #16
341956f4:	65da      	str	r2, [r3, #92]	@ 0x5c
341956f6:	e000      	b.n	341956fa <HAL_XSPI_AutoPolling+0x10a>
    if (status == HAL_OK)
341956f8:	bf00      	nop
  }

  return status;
341956fa:	7ffb      	ldrb	r3, [r7, #31]
}
341956fc:	4618      	mov	r0, r3
341956fe:	3720      	adds	r7, #32
34195700:	46bd      	mov	sp, r7
34195702:	bd80      	pop	{r7, pc}

34195704 <HAL_XSPI_MemoryMapped>:
  * @param  pCfg   : Pointer to structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_MemoryMapped(XSPI_HandleTypeDef *hxspi, const XSPI_MemoryMappedTypeDef *pCfg)
{
34195704:	b580      	push	{r7, lr}
34195706:	b086      	sub	sp, #24
34195708:	af02      	add	r7, sp, #8
3419570a:	6078      	str	r0, [r7, #4]
3419570c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3419570e:	f7ef fe1f 	bl	34185350 <HAL_GetTick>
34195712:	60b8      	str	r0, [r7, #8]
  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));

  /* Check the state */
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34195714:	687b      	ldr	r3, [r7, #4]
34195716:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34195718:	2b04      	cmp	r3, #4
3419571a:	d155      	bne.n	341957c8 <HAL_XSPI_MemoryMapped+0xc4>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3419571c:	687b      	ldr	r3, [r7, #4]
3419571e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34195720:	9300      	str	r3, [sp, #0]
34195722:	68bb      	ldr	r3, [r7, #8]
34195724:	2200      	movs	r2, #0
34195726:	2120      	movs	r1, #32
34195728:	6878      	ldr	r0, [r7, #4]
3419572a:	f000 fa41 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
3419572e:	4603      	mov	r3, r0
34195730:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
34195732:	7bfb      	ldrb	r3, [r7, #15]
34195734:	2b00      	cmp	r3, #0
34195736:	d14c      	bne.n	341957d2 <HAL_XSPI_MemoryMapped+0xce>
    {
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
34195738:	687b      	ldr	r3, [r7, #4]
3419573a:	2288      	movs	r2, #136	@ 0x88
3419573c:	659a      	str	r2, [r3, #88]	@ 0x58

      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
3419573e:	683b      	ldr	r3, [r7, #0]
34195740:	689b      	ldr	r3, [r3, #8]
34195742:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34195746:	d10b      	bne.n	34195760 <HAL_XSPI_MemoryMapped+0x5c>
      {
        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34195748:	687b      	ldr	r3, [r7, #4]
3419574a:	681b      	ldr	r3, [r3, #0]
3419574c:	681b      	ldr	r3, [r3, #0]
3419574e:	f023 7100 	bic.w	r1, r3, #33554432	@ 0x2000000
34195752:	683b      	ldr	r3, [r7, #0]
34195754:	689a      	ldr	r2, [r3, #8]
34195756:	687b      	ldr	r3, [r7, #4]
34195758:	681b      	ldr	r3, [r3, #0]
3419575a:	430a      	orrs	r2, r1
3419575c:	601a      	str	r2, [r3, #0]
3419575e:	e00d      	b.n	3419577c <HAL_XSPI_MemoryMapped+0x78>
      else
      {
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));

        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
34195760:	687b      	ldr	r3, [r7, #4]
34195762:	681b      	ldr	r3, [r3, #0]
34195764:	681b      	ldr	r3, [r3, #0]
34195766:	f023 61c0 	bic.w	r1, r3, #100663296	@ 0x6000000
3419576a:	683b      	ldr	r3, [r7, #0]
3419576c:	689a      	ldr	r2, [r3, #8]
3419576e:	683b      	ldr	r3, [r7, #0]
34195770:	68db      	ldr	r3, [r3, #12]
34195772:	431a      	orrs	r2, r3
34195774:	687b      	ldr	r3, [r7, #4]
34195776:	681b      	ldr	r3, [r3, #0]
34195778:	430a      	orrs	r2, r1
3419577a:	601a      	str	r2, [r3, #0]
                   (pCfg->NoPrefetchData | pCfg->NoPrefetchAXI));
      }
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
3419577c:	683b      	ldr	r3, [r7, #0]
3419577e:	681b      	ldr	r3, [r3, #0]
34195780:	2b08      	cmp	r3, #8
34195782:	d111      	bne.n	341957a8 <HAL_XSPI_MemoryMapped+0xa4>
      {
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));

        /* Configure register */
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34195784:	687b      	ldr	r3, [r7, #4]
34195786:	681b      	ldr	r3, [r3, #0]
34195788:	683a      	ldr	r2, [r7, #0]
3419578a:	6852      	ldr	r2, [r2, #4]
3419578c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

        /* Clear flags related to interrupt */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
34195790:	687b      	ldr	r3, [r7, #4]
34195792:	681b      	ldr	r3, [r3, #0]
34195794:	2210      	movs	r2, #16
34195796:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enable the timeout interrupt */
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34195798:	687b      	ldr	r3, [r7, #4]
3419579a:	681b      	ldr	r3, [r3, #0]
3419579c:	681a      	ldr	r2, [r3, #0]
3419579e:	687b      	ldr	r3, [r7, #4]
341957a0:	681b      	ldr	r3, [r3, #0]
341957a2:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
341957a6:	601a      	str	r2, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
341957a8:	687b      	ldr	r3, [r7, #4]
341957aa:	681b      	ldr	r3, [r3, #0]
341957ac:	681b      	ldr	r3, [r3, #0]
341957ae:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
341957b2:	f023 0308 	bic.w	r3, r3, #8
341957b6:	683a      	ldr	r2, [r7, #0]
341957b8:	6812      	ldr	r2, [r2, #0]
341957ba:	431a      	orrs	r2, r3
341957bc:	687b      	ldr	r3, [r7, #4]
341957be:	681b      	ldr	r3, [r3, #0]
341957c0:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
341957c4:	601a      	str	r2, [r3, #0]
341957c6:	e004      	b.n	341957d2 <HAL_XSPI_MemoryMapped+0xce>
                 (pCfg->TimeOutActivation | XSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
341957c8:	2301      	movs	r3, #1
341957ca:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
341957cc:	687b      	ldr	r3, [r7, #4]
341957ce:	2210      	movs	r2, #16
341957d0:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
341957d2:	7bfb      	ldrb	r3, [r7, #15]
}
341957d4:	4618      	mov	r0, r3
341957d6:	3710      	adds	r7, #16
341957d8:	46bd      	mov	sp, r7
341957da:	bd80      	pop	{r7, pc}

341957dc <HAL_XSPI_Abort>:
  * @brief  Abort the current operation, return to the indirect mode.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Abort(XSPI_HandleTypeDef *hxspi)
{
341957dc:	b580      	push	{r7, lr}
341957de:	b086      	sub	sp, #24
341957e0:	af02      	add	r7, sp, #8
341957e2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
341957e4:	2300      	movs	r3, #0
341957e6:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
341957e8:	f7ef fdb2 	bl	34185350 <HAL_GetTick>
341957ec:	60b8      	str	r0, [r7, #8]

  /* Check if the state is not in reset state */
  if (hxspi->State != HAL_XSPI_STATE_RESET)
341957ee:	687b      	ldr	r3, [r7, #4]
341957f0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341957f2:	2b00      	cmp	r3, #0
341957f4:	d06f      	beq.n	341958d6 <HAL_XSPI_Abort+0xfa>
  {
    /* Check if the DMA is enabled */
    if ((hxspi->Instance->CR & XSPI_CR_DMAEN) != 0U)
341957f6:	687b      	ldr	r3, [r7, #4]
341957f8:	681b      	ldr	r3, [r3, #0]
341957fa:	681b      	ldr	r3, [r3, #0]
341957fc:	f003 0304 	and.w	r3, r3, #4
34195800:	2b00      	cmp	r3, #0
34195802:	d021      	beq.n	34195848 <HAL_XSPI_Abort+0x6c>
    {
      /* Disable the DMA transfer on the XSPI side */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_DMAEN);
34195804:	687b      	ldr	r3, [r7, #4]
34195806:	681b      	ldr	r3, [r3, #0]
34195808:	681a      	ldr	r2, [r3, #0]
3419580a:	687b      	ldr	r3, [r7, #4]
3419580c:	681b      	ldr	r3, [r3, #0]
3419580e:	f022 0204 	bic.w	r2, r2, #4
34195812:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transmit on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmatx);
34195814:	687b      	ldr	r3, [r7, #4]
34195816:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34195818:	4618      	mov	r0, r3
3419581a:	f7f2 feba 	bl	34188592 <HAL_DMA_Abort>
3419581e:	4603      	mov	r3, r0
34195820:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
34195822:	7bfb      	ldrb	r3, [r7, #15]
34195824:	2b00      	cmp	r3, #0
34195826:	d002      	beq.n	3419582e <HAL_XSPI_Abort+0x52>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
34195828:	687b      	ldr	r3, [r7, #4]
3419582a:	2204      	movs	r2, #4
3419582c:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Disable the DMA receive on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmarx);
3419582e:	687b      	ldr	r3, [r7, #4]
34195830:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34195832:	4618      	mov	r0, r3
34195834:	f7f2 fead 	bl	34188592 <HAL_DMA_Abort>
34195838:	4603      	mov	r3, r0
3419583a:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
3419583c:	7bfb      	ldrb	r3, [r7, #15]
3419583e:	2b00      	cmp	r3, #0
34195840:	d002      	beq.n	34195848 <HAL_XSPI_Abort+0x6c>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
34195842:	687b      	ldr	r3, [r7, #4]
34195844:	2204      	movs	r2, #4
34195846:	65da      	str	r2, [r3, #92]	@ 0x5c
      }
    }

    if (HAL_XSPI_GET_FLAG(hxspi, HAL_XSPI_FLAG_BUSY) != RESET)
34195848:	687b      	ldr	r3, [r7, #4]
3419584a:	681b      	ldr	r3, [r3, #0]
3419584c:	6a1b      	ldr	r3, [r3, #32]
3419584e:	f003 0320 	and.w	r3, r3, #32
34195852:	2b00      	cmp	r3, #0
34195854:	d033      	beq.n	341958be <HAL_XSPI_Abort+0xe2>
    {
      /* Perform an abort of the XSPI */
      SET_BIT(hxspi->Instance->CR, XSPI_CR_ABORT);
34195856:	687b      	ldr	r3, [r7, #4]
34195858:	681b      	ldr	r3, [r3, #0]
3419585a:	681a      	ldr	r2, [r3, #0]
3419585c:	687b      	ldr	r3, [r7, #4]
3419585e:	681b      	ldr	r3, [r3, #0]
34195860:	f042 0202 	orr.w	r2, r2, #2
34195864:	601a      	str	r2, [r3, #0]

      /* Wait until the transfer complete flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, hxspi->Timeout);
34195866:	687b      	ldr	r3, [r7, #4]
34195868:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419586a:	9300      	str	r3, [sp, #0]
3419586c:	68bb      	ldr	r3, [r7, #8]
3419586e:	2201      	movs	r2, #1
34195870:	2102      	movs	r1, #2
34195872:	6878      	ldr	r0, [r7, #4]
34195874:	f000 f99c 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
34195878:	4603      	mov	r3, r0
3419587a:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
3419587c:	7bfb      	ldrb	r3, [r7, #15]
3419587e:	2b00      	cmp	r3, #0
34195880:	d12e      	bne.n	341958e0 <HAL_XSPI_Abort+0x104>
      {
        /* Clear transfer complete flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34195882:	687b      	ldr	r3, [r7, #4]
34195884:	681b      	ldr	r3, [r3, #0]
34195886:	2202      	movs	r2, #2
34195888:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Wait until the busy flag is reset to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3419588a:	687b      	ldr	r3, [r7, #4]
3419588c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419588e:	9300      	str	r3, [sp, #0]
34195890:	68bb      	ldr	r3, [r7, #8]
34195892:	2200      	movs	r2, #0
34195894:	2120      	movs	r1, #32
34195896:	6878      	ldr	r0, [r7, #4]
34195898:	f000 f98a 	bl	34195bb0 <XSPI_WaitFlagStateUntilTimeout>
3419589c:	4603      	mov	r3, r0
3419589e:	73fb      	strb	r3, [r7, #15]

        if (status == HAL_OK)
341958a0:	7bfb      	ldrb	r3, [r7, #15]
341958a2:	2b00      	cmp	r3, #0
341958a4:	d11c      	bne.n	341958e0 <HAL_XSPI_Abort+0x104>
        {
          /* Return to indirect mode */
          CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
341958a6:	687b      	ldr	r3, [r7, #4]
341958a8:	681b      	ldr	r3, [r3, #0]
341958aa:	681a      	ldr	r2, [r3, #0]
341958ac:	687b      	ldr	r3, [r7, #4]
341958ae:	681b      	ldr	r3, [r3, #0]
341958b0:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
341958b4:	601a      	str	r2, [r3, #0]

          hxspi->State = HAL_XSPI_STATE_READY;
341958b6:	687b      	ldr	r3, [r7, #4]
341958b8:	2202      	movs	r2, #2
341958ba:	659a      	str	r2, [r3, #88]	@ 0x58
341958bc:	e010      	b.n	341958e0 <HAL_XSPI_Abort+0x104>
      }
    }
    else
    {
      /* Return to indirect mode */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
341958be:	687b      	ldr	r3, [r7, #4]
341958c0:	681b      	ldr	r3, [r3, #0]
341958c2:	681a      	ldr	r2, [r3, #0]
341958c4:	687b      	ldr	r3, [r7, #4]
341958c6:	681b      	ldr	r3, [r3, #0]
341958c8:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
341958cc:	601a      	str	r2, [r3, #0]

      hxspi->State = HAL_XSPI_STATE_READY;
341958ce:	687b      	ldr	r3, [r7, #4]
341958d0:	2202      	movs	r2, #2
341958d2:	659a      	str	r2, [r3, #88]	@ 0x58
341958d4:	e004      	b.n	341958e0 <HAL_XSPI_Abort+0x104>
    }
  }
  else
  {
    status = HAL_ERROR;
341958d6:	2301      	movs	r3, #1
341958d8:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
341958da:	687b      	ldr	r3, [r7, #4]
341958dc:	2210      	movs	r2, #16
341958de:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
341958e0:	7bfb      	ldrb	r3, [r7, #15]
}
341958e2:	4618      	mov	r0, r3
341958e4:	3710      	adds	r7, #16
341958e6:	46bd      	mov	sp, r7
341958e8:	bd80      	pop	{r7, pc}

341958ea <HAL_XSPI_SetClockPrescaler>:
  * @param  hxspi     : XSPI handle.
  * @param  Prescaler : Clock prescaler.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_SetClockPrescaler(XSPI_HandleTypeDef *hxspi, uint32_t Prescaler)
{
341958ea:	b480      	push	{r7}
341958ec:	b085      	sub	sp, #20
341958ee:	af00      	add	r7, sp, #0
341958f0:	6078      	str	r0, [r7, #4]
341958f2:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
341958f4:	2300      	movs	r3, #0
341958f6:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));

  /* Check the state */
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
341958f8:	687b      	ldr	r3, [r7, #4]
341958fa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341958fc:	f003 0308 	and.w	r3, r3, #8
34195900:	2b00      	cmp	r3, #0
34195902:	d10e      	bne.n	34195922 <HAL_XSPI_SetClockPrescaler+0x38>
  {
    /* Synchronize initialization structure with the new clock prescaler value */
    hxspi->Init.ClockPrescaler = Prescaler;
34195904:	687b      	ldr	r3, [r7, #4]
34195906:	683a      	ldr	r2, [r7, #0]
34195908:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Configure clock prescaler */
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3419590a:	687b      	ldr	r3, [r7, #4]
3419590c:	681b      	ldr	r3, [r3, #0]
3419590e:	68db      	ldr	r3, [r3, #12]
34195910:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34195914:	687b      	ldr	r3, [r7, #4]
34195916:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34195918:	687b      	ldr	r3, [r7, #4]
3419591a:	681b      	ldr	r3, [r3, #0]
3419591c:	430a      	orrs	r2, r1
3419591e:	60da      	str	r2, [r3, #12]
34195920:	e004      	b.n	3419592c <HAL_XSPI_SetClockPrescaler+0x42>
               ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));
  }
  else
  {
    status = HAL_ERROR;
34195922:	2301      	movs	r3, #1
34195924:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34195926:	687b      	ldr	r3, [r7, #4]
34195928:	2210      	movs	r2, #16
3419592a:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
3419592c:	7bfb      	ldrb	r3, [r7, #15]
}
3419592e:	4618      	mov	r0, r3
34195930:	3714      	adds	r7, #20
34195932:	46bd      	mov	sp, r7
34195934:	f85d 7b04 	ldr.w	r7, [sp], #4
34195938:	4770      	bx	lr

3419593a <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
3419593a:	b480      	push	{r7}
3419593c:	b083      	sub	sp, #12
3419593e:	af00      	add	r7, sp, #0
34195940:	6078      	str	r0, [r7, #4]
34195942:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
34195944:	687b      	ldr	r3, [r7, #4]
34195946:	683a      	ldr	r2, [r7, #0]
34195948:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
3419594a:	2300      	movs	r3, #0
}
3419594c:	4618      	mov	r0, r3
3419594e:	370c      	adds	r7, #12
34195950:	46bd      	mov	sp, r7
34195952:	f85d 7b04 	ldr.w	r7, [sp], #4
34195956:	4770      	bx	lr

34195958 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *hxspi, const XSPIM_CfgTypeDef *pCfg, uint32_t Timeout)
{
34195958:	b580      	push	{r7, lr}
3419595a:	b08e      	sub	sp, #56	@ 0x38
3419595c:	af00      	add	r7, sp, #0
3419595e:	60f8      	str	r0, [r7, #12]
34195960:	60b9      	str	r1, [r7, #8]
34195962:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34195964:	2300      	movs	r3, #0
34195966:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
  uint8_t index;
  uint8_t xspi_enabled = 0U;
3419596a:	2300      	movs	r3, #0
3419596c:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
34195970:	f107 0310 	add.w	r3, r7, #16
34195974:	2224      	movs	r2, #36	@ 0x24
34195976:	2100      	movs	r1, #0
34195978:	4618      	mov	r0, r3
3419597a:	f00e fa13 	bl	341a3da4 <memset>
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
3419597e:	2300      	movs	r3, #0
34195980:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34195984:	e014      	b.n	341959b0 <HAL_XSPIM_Config+0x58>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
34195986:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3419598a:	3301      	adds	r3, #1
3419598c:	b2d8      	uxtb	r0, r3
3419598e:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34195992:	f107 0110 	add.w	r1, r7, #16
34195996:	4613      	mov	r3, r2
34195998:	005b      	lsls	r3, r3, #1
3419599a:	4413      	add	r3, r2
3419599c:	009b      	lsls	r3, r3, #2
3419599e:	440b      	add	r3, r1
341959a0:	4619      	mov	r1, r3
341959a2:	f000 fad9 	bl	34195f58 <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
341959a6:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
341959aa:	3301      	adds	r3, #1
341959ac:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
341959b0:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
341959b4:	2b02      	cmp	r3, #2
341959b6:	d9e6      	bls.n	34195986 <HAL_XSPIM_Config+0x2e>
  }

  /********** Disable all XSPI to configure XSPI IO Manager **********/
  if (__HAL_RCC_XSPI1_IS_CLK_ENABLED() != 0U)
341959b8:	2020      	movs	r0, #32
341959ba:	f7ff fb4b 	bl	34195054 <LL_AHB5_GRP1_IsEnabledClock>
341959be:	4603      	mov	r3, r0
341959c0:	2b00      	cmp	r3, #0
341959c2:	d011      	beq.n	341959e8 <HAL_XSPIM_Config+0x90>
  {
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
341959c4:	4b76      	ldr	r3, [pc, #472]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
341959c6:	681b      	ldr	r3, [r3, #0]
341959c8:	f003 0301 	and.w	r3, r3, #1
341959cc:	2b00      	cmp	r3, #0
341959ce:	d00b      	beq.n	341959e8 <HAL_XSPIM_Config+0x90>
    {
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
341959d0:	4b73      	ldr	r3, [pc, #460]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
341959d2:	681b      	ldr	r3, [r3, #0]
341959d4:	4a72      	ldr	r2, [pc, #456]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
341959d6:	f023 0301 	bic.w	r3, r3, #1
341959da:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x1U;
341959dc:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
341959e0:	f043 0301 	orr.w	r3, r3, #1
341959e4:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI2_IS_CLK_ENABLED() != 0U)
341959e8:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
341959ec:	f7ff fb32 	bl	34195054 <LL_AHB5_GRP1_IsEnabledClock>
341959f0:	4603      	mov	r3, r0
341959f2:	2b00      	cmp	r3, #0
341959f4:	d011      	beq.n	34195a1a <HAL_XSPIM_Config+0xc2>
  {
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
341959f6:	4b6b      	ldr	r3, [pc, #428]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
341959f8:	681b      	ldr	r3, [r3, #0]
341959fa:	f003 0301 	and.w	r3, r3, #1
341959fe:	2b00      	cmp	r3, #0
34195a00:	d00b      	beq.n	34195a1a <HAL_XSPIM_Config+0xc2>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34195a02:	4b68      	ldr	r3, [pc, #416]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195a04:	681b      	ldr	r3, [r3, #0]
34195a06:	4a67      	ldr	r2, [pc, #412]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195a08:	f023 0301 	bic.w	r3, r3, #1
34195a0c:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x2U;
34195a0e:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34195a12:	f043 0302 	orr.w	r3, r3, #2
34195a16:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI3_IS_CLK_ENABLED() != 0U)
34195a1a:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
34195a1e:	f7ff fb19 	bl	34195054 <LL_AHB5_GRP1_IsEnabledClock>
34195a22:	4603      	mov	r3, r0
34195a24:	2b00      	cmp	r3, #0
34195a26:	d011      	beq.n	34195a4c <HAL_XSPIM_Config+0xf4>
  {
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
34195a28:	4b5f      	ldr	r3, [pc, #380]	@ (34195ba8 <HAL_XSPIM_Config+0x250>)
34195a2a:	681b      	ldr	r3, [r3, #0]
34195a2c:	f003 0301 	and.w	r3, r3, #1
34195a30:	2b00      	cmp	r3, #0
34195a32:	d00b      	beq.n	34195a4c <HAL_XSPIM_Config+0xf4>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34195a34:	4b5b      	ldr	r3, [pc, #364]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195a36:	681b      	ldr	r3, [r3, #0]
34195a38:	4a5a      	ldr	r2, [pc, #360]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195a3a:	f023 0301 	bic.w	r3, r3, #1
34195a3e:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x4U;
34195a40:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34195a44:	f043 0304 	orr.w	r3, r3, #4
34195a48:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
34195a4c:	4b57      	ldr	r3, [pc, #348]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195a4e:	2200      	movs	r2, #0
34195a50:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
34195a52:	4b56      	ldr	r3, [pc, #344]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195a54:	681b      	ldr	r3, [r3, #0]
34195a56:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
34195a5a:	68bb      	ldr	r3, [r7, #8]
34195a5c:	689b      	ldr	r3, [r3, #8]
34195a5e:	3b01      	subs	r3, #1
34195a60:	041b      	lsls	r3, r3, #16
34195a62:	4952      	ldr	r1, [pc, #328]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195a64:	4313      	orrs	r3, r2
34195a66:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
34195a68:	68fb      	ldr	r3, [r7, #12]
34195a6a:	681b      	ldr	r3, [r3, #0]
34195a6c:	4a4c      	ldr	r2, [pc, #304]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
34195a6e:	4293      	cmp	r3, r2
34195a70:	d110      	bne.n	34195a94 <HAL_XSPIM_Config+0x13c>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
34195a72:	68bb      	ldr	r3, [r7, #8]
34195a74:	685b      	ldr	r3, [r3, #4]
34195a76:	617b      	str	r3, [r7, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34195a78:	68bb      	ldr	r3, [r7, #8]
34195a7a:	681b      	ldr	r3, [r3, #0]
34195a7c:	2b00      	cmp	r3, #0
34195a7e:	d03e      	beq.n	34195afe <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34195a80:	4b4a      	ldr	r3, [pc, #296]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195a82:	681b      	ldr	r3, [r3, #0]
34195a84:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34195a88:	68bb      	ldr	r3, [r7, #8]
34195a8a:	681b      	ldr	r3, [r3, #0]
34195a8c:	4947      	ldr	r1, [pc, #284]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195a8e:	4313      	orrs	r3, r2
34195a90:	600b      	str	r3, [r1, #0]
34195a92:	e034      	b.n	34195afe <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
34195a94:	68fb      	ldr	r3, [r7, #12]
34195a96:	681b      	ldr	r3, [r3, #0]
34195a98:	4a42      	ldr	r2, [pc, #264]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195a9a:	4293      	cmp	r3, r2
34195a9c:	d110      	bne.n	34195ac0 <HAL_XSPIM_Config+0x168>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
34195a9e:	68bb      	ldr	r3, [r7, #8]
34195aa0:	685b      	ldr	r3, [r3, #4]
34195aa2:	623b      	str	r3, [r7, #32]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34195aa4:	68bb      	ldr	r3, [r7, #8]
34195aa6:	681b      	ldr	r3, [r3, #0]
34195aa8:	2b00      	cmp	r3, #0
34195aaa:	d028      	beq.n	34195afe <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34195aac:	4b3f      	ldr	r3, [pc, #252]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195aae:	681b      	ldr	r3, [r3, #0]
34195ab0:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
34195ab4:	68bb      	ldr	r3, [r7, #8]
34195ab6:	681b      	ldr	r3, [r3, #0]
34195ab8:	493c      	ldr	r1, [pc, #240]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195aba:	4313      	orrs	r3, r2
34195abc:	600b      	str	r3, [r1, #0]
34195abe:	e01e      	b.n	34195afe <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI3)
34195ac0:	68fb      	ldr	r3, [r7, #12]
34195ac2:	681b      	ldr	r3, [r3, #0]
34195ac4:	4a38      	ldr	r2, [pc, #224]	@ (34195ba8 <HAL_XSPIM_Config+0x250>)
34195ac6:	4293      	cmp	r3, r2
34195ac8:	d111      	bne.n	34195aee <HAL_XSPIM_Config+0x196>
  {
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
34195aca:	68bb      	ldr	r3, [r7, #8]
34195acc:	685b      	ldr	r3, [r3, #4]
34195ace:	2b00      	cmp	r3, #0
34195ad0:	d104      	bne.n	34195adc <HAL_XSPIM_Config+0x184>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
34195ad2:	2301      	movs	r3, #1
34195ad4:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
34195ad6:	2301      	movs	r3, #1
34195ad8:	623b      	str	r3, [r7, #32]
34195ada:	e010      	b.n	34195afe <HAL_XSPIM_Config+0x1a6>
    }
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
34195adc:	68bb      	ldr	r3, [r7, #8]
34195ade:	685b      	ldr	r3, [r3, #4]
34195ae0:	2b01      	cmp	r3, #1
34195ae2:	d10c      	bne.n	34195afe <HAL_XSPIM_Config+0x1a6>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
34195ae4:	2300      	movs	r3, #0
34195ae6:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
34195ae8:	2300      	movs	r3, #0
34195aea:	623b      	str	r3, [r7, #32]
34195aec:	e007      	b.n	34195afe <HAL_XSPIM_Config+0x1a6>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
34195aee:	68fb      	ldr	r3, [r7, #12]
34195af0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34195af2:	f043 0208 	orr.w	r2, r3, #8
34195af6:	68fb      	ldr	r3, [r7, #12]
34195af8:	65da      	str	r2, [r3, #92]	@ 0x5c
    return HAL_ERROR;
34195afa:	2301      	movs	r3, #1
34195afc:	e04c      	b.n	34195b98 <HAL_XSPIM_Config+0x240>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34195afe:	2300      	movs	r3, #0
34195b00:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34195b04:	e02a      	b.n	34195b5c <HAL_XSPIM_Config+0x204>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
34195b06:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34195b0a:	4613      	mov	r3, r2
34195b0c:	005b      	lsls	r3, r3, #1
34195b0e:	4413      	add	r3, r2
34195b10:	009b      	lsls	r3, r3, #2
34195b12:	3338      	adds	r3, #56	@ 0x38
34195b14:	443b      	add	r3, r7
34195b16:	3b24      	subs	r3, #36	@ 0x24
34195b18:	6819      	ldr	r1, [r3, #0]
34195b1a:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34195b1e:	1c5a      	adds	r2, r3, #1
34195b20:	4613      	mov	r3, r2
34195b22:	005b      	lsls	r3, r3, #1
34195b24:	4413      	add	r3, r2
34195b26:	009b      	lsls	r3, r3, #2
34195b28:	3338      	adds	r3, #56	@ 0x38
34195b2a:	443b      	add	r3, r7
34195b2c:	3b24      	subs	r3, #36	@ 0x24
34195b2e:	681b      	ldr	r3, [r3, #0]
34195b30:	4299      	cmp	r1, r3
34195b32:	d105      	bne.n	34195b40 <HAL_XSPIM_Config+0x1e8>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
34195b34:	4b1d      	ldr	r3, [pc, #116]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195b36:	681b      	ldr	r3, [r3, #0]
34195b38:	4a1c      	ldr	r2, [pc, #112]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195b3a:	f043 0301 	orr.w	r3, r3, #1
34195b3e:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
34195b40:	697b      	ldr	r3, [r7, #20]
34195b42:	2b01      	cmp	r3, #1
34195b44:	d105      	bne.n	34195b52 <HAL_XSPIM_Config+0x1fa>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
34195b46:	4b19      	ldr	r3, [pc, #100]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195b48:	681b      	ldr	r3, [r3, #0]
34195b4a:	4a18      	ldr	r2, [pc, #96]	@ (34195bac <HAL_XSPIM_Config+0x254>)
34195b4c:	f043 0302 	orr.w	r3, r3, #2
34195b50:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34195b52:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34195b56:	3301      	adds	r3, #1
34195b58:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34195b5c:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34195b60:	2b00      	cmp	r3, #0
34195b62:	d0d0      	beq.n	34195b06 <HAL_XSPIM_Config+0x1ae>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
34195b64:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34195b68:	f003 0301 	and.w	r3, r3, #1
34195b6c:	2b00      	cmp	r3, #0
34195b6e:	d005      	beq.n	34195b7c <HAL_XSPIM_Config+0x224>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
34195b70:	4b0b      	ldr	r3, [pc, #44]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
34195b72:	681b      	ldr	r3, [r3, #0]
34195b74:	4a0a      	ldr	r2, [pc, #40]	@ (34195ba0 <HAL_XSPIM_Config+0x248>)
34195b76:	f043 0301 	orr.w	r3, r3, #1
34195b7a:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
34195b7c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34195b80:	f003 0302 	and.w	r3, r3, #2
34195b84:	2b00      	cmp	r3, #0
34195b86:	d005      	beq.n	34195b94 <HAL_XSPIM_Config+0x23c>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
34195b88:	4b06      	ldr	r3, [pc, #24]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195b8a:	681b      	ldr	r3, [r3, #0]
34195b8c:	4a05      	ldr	r2, [pc, #20]	@ (34195ba4 <HAL_XSPIM_Config+0x24c>)
34195b8e:	f043 0301 	orr.w	r3, r3, #1
34195b92:	6013      	str	r3, [r2, #0]
  }

  return status;
34195b94:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
}
34195b98:	4618      	mov	r0, r3
34195b9a:	3738      	adds	r7, #56	@ 0x38
34195b9c:	46bd      	mov	sp, r7
34195b9e:	bd80      	pop	{r7, pc}
34195ba0:	58025000 	.word	0x58025000
34195ba4:	5802a000 	.word	0x5802a000
34195ba8:	5802d000 	.word	0x5802d000
34195bac:	5802b400 	.word	0x5802b400

34195bb0 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34195bb0:	b580      	push	{r7, lr}
34195bb2:	b084      	sub	sp, #16
34195bb4:	af00      	add	r7, sp, #0
34195bb6:	60f8      	str	r0, [r7, #12]
34195bb8:	60b9      	str	r1, [r7, #8]
34195bba:	603b      	str	r3, [r7, #0]
34195bbc:	4613      	mov	r3, r2
34195bbe:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34195bc0:	e019      	b.n	34195bf6 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34195bc2:	69bb      	ldr	r3, [r7, #24]
34195bc4:	f1b3 3fff 	cmp.w	r3, #4294967295
34195bc8:	d015      	beq.n	34195bf6 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34195bca:	f7ef fbc1 	bl	34185350 <HAL_GetTick>
34195bce:	4602      	mov	r2, r0
34195bd0:	683b      	ldr	r3, [r7, #0]
34195bd2:	1ad3      	subs	r3, r2, r3
34195bd4:	69ba      	ldr	r2, [r7, #24]
34195bd6:	429a      	cmp	r2, r3
34195bd8:	d302      	bcc.n	34195be0 <XSPI_WaitFlagStateUntilTimeout+0x30>
34195bda:	69bb      	ldr	r3, [r7, #24]
34195bdc:	2b00      	cmp	r3, #0
34195bde:	d10a      	bne.n	34195bf6 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
34195be0:	68fb      	ldr	r3, [r7, #12]
34195be2:	2202      	movs	r2, #2
34195be4:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34195be6:	68fb      	ldr	r3, [r7, #12]
34195be8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34195bea:	f043 0201 	orr.w	r2, r3, #1
34195bee:	68fb      	ldr	r3, [r7, #12]
34195bf0:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
34195bf2:	2303      	movs	r3, #3
34195bf4:	e00e      	b.n	34195c14 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34195bf6:	68fb      	ldr	r3, [r7, #12]
34195bf8:	681b      	ldr	r3, [r3, #0]
34195bfa:	6a1a      	ldr	r2, [r3, #32]
34195bfc:	68bb      	ldr	r3, [r7, #8]
34195bfe:	4013      	ands	r3, r2
34195c00:	2b00      	cmp	r3, #0
34195c02:	bf14      	ite	ne
34195c04:	2301      	movne	r3, #1
34195c06:	2300      	moveq	r3, #0
34195c08:	b2db      	uxtb	r3, r3
34195c0a:	461a      	mov	r2, r3
34195c0c:	79fb      	ldrb	r3, [r7, #7]
34195c0e:	429a      	cmp	r2, r3
34195c10:	d1d7      	bne.n	34195bc2 <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
34195c12:	2300      	movs	r3, #0
}
34195c14:	4618      	mov	r0, r3
34195c16:	3710      	adds	r7, #16
34195c18:	46bd      	mov	sp, r7
34195c1a:	bd80      	pop	{r7, pc}

34195c1c <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd)
{
34195c1c:	b480      	push	{r7}
34195c1e:	b089      	sub	sp, #36	@ 0x24
34195c20:	af00      	add	r7, sp, #0
34195c22:	6078      	str	r0, [r7, #4]
34195c24:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34195c26:	2300      	movs	r3, #0
34195c28:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
34195c2a:	687b      	ldr	r3, [r7, #4]
34195c2c:	681b      	ldr	r3, [r3, #0]
34195c2e:	681a      	ldr	r2, [r3, #0]
34195c30:	687b      	ldr	r3, [r7, #4]
34195c32:	681b      	ldr	r3, [r3, #0]
34195c34:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34195c38:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34195c3a:	687b      	ldr	r3, [r7, #4]
34195c3c:	689b      	ldr	r3, [r3, #8]
34195c3e:	2b00      	cmp	r3, #0
34195c40:	d10a      	bne.n	34195c58 <XSPI_ConfigCmd+0x3c>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
34195c42:	687b      	ldr	r3, [r7, #4]
34195c44:	681b      	ldr	r3, [r3, #0]
34195c46:	681b      	ldr	r3, [r3, #0]
34195c48:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
34195c4c:	683b      	ldr	r3, [r7, #0]
34195c4e:	685a      	ldr	r2, [r3, #4]
34195c50:	687b      	ldr	r3, [r7, #4]
34195c52:	681b      	ldr	r3, [r3, #0]
34195c54:	430a      	orrs	r2, r1
34195c56:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34195c58:	683b      	ldr	r3, [r7, #0]
34195c5a:	681b      	ldr	r3, [r3, #0]
34195c5c:	2b02      	cmp	r3, #2
34195c5e:	d114      	bne.n	34195c8a <XSPI_ConfigCmd+0x6e>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
34195c60:	687b      	ldr	r3, [r7, #4]
34195c62:	681b      	ldr	r3, [r3, #0]
34195c64:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
34195c68:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
34195c6a:	687b      	ldr	r3, [r7, #4]
34195c6c:	681b      	ldr	r3, [r3, #0]
34195c6e:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
34195c72:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
34195c74:	687b      	ldr	r3, [r7, #4]
34195c76:	681b      	ldr	r3, [r3, #0]
34195c78:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
34195c7c:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
34195c7e:	687b      	ldr	r3, [r7, #4]
34195c80:	681b      	ldr	r3, [r3, #0]
34195c82:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
34195c86:	60fb      	str	r3, [r7, #12]
34195c88:	e02c      	b.n	34195ce4 <XSPI_ConfigCmd+0xc8>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
34195c8a:	683b      	ldr	r3, [r7, #0]
34195c8c:	681b      	ldr	r3, [r3, #0]
34195c8e:	2b03      	cmp	r3, #3
34195c90:	d114      	bne.n	34195cbc <XSPI_ConfigCmd+0xa0>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
34195c92:	687b      	ldr	r3, [r7, #4]
34195c94:	681b      	ldr	r3, [r3, #0]
34195c96:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
34195c9a:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
34195c9c:	687b      	ldr	r3, [r7, #4]
34195c9e:	681b      	ldr	r3, [r3, #0]
34195ca0:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
34195ca4:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
34195ca6:	687b      	ldr	r3, [r7, #4]
34195ca8:	681b      	ldr	r3, [r3, #0]
34195caa:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
34195cae:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
34195cb0:	687b      	ldr	r3, [r7, #4]
34195cb2:	681b      	ldr	r3, [r3, #0]
34195cb4:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34195cb8:	60fb      	str	r3, [r7, #12]
34195cba:	e013      	b.n	34195ce4 <XSPI_ConfigCmd+0xc8>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
34195cbc:	687b      	ldr	r3, [r7, #4]
34195cbe:	681b      	ldr	r3, [r3, #0]
34195cc0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34195cc4:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
34195cc6:	687b      	ldr	r3, [r7, #4]
34195cc8:	681b      	ldr	r3, [r3, #0]
34195cca:	f503 7384 	add.w	r3, r3, #264	@ 0x108
34195cce:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
34195cd0:	687b      	ldr	r3, [r7, #4]
34195cd2:	681b      	ldr	r3, [r3, #0]
34195cd4:	f503 7388 	add.w	r3, r3, #272	@ 0x110
34195cd8:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
34195cda:	687b      	ldr	r3, [r7, #4]
34195cdc:	681b      	ldr	r3, [r3, #0]
34195cde:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34195ce2:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
34195ce4:	683b      	ldr	r3, [r7, #0]
34195ce6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34195ce8:	69bb      	ldr	r3, [r7, #24]
34195cea:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
34195cec:	683b      	ldr	r3, [r7, #0]
34195cee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34195cf0:	2b00      	cmp	r3, #0
34195cf2:	d012      	beq.n	34195d1a <XSPI_ConfigCmd+0xfe>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
34195cf4:	683b      	ldr	r3, [r7, #0]
34195cf6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34195cf8:	68fb      	ldr	r3, [r7, #12]
34195cfa:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
34195cfc:	69bb      	ldr	r3, [r7, #24]
34195cfe:	681b      	ldr	r3, [r3, #0]
34195d00:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
34195d04:	683b      	ldr	r3, [r7, #0]
34195d06:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34195d08:	683b      	ldr	r3, [r7, #0]
34195d0a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34195d0c:	4319      	orrs	r1, r3
34195d0e:	683b      	ldr	r3, [r7, #0]
34195d10:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34195d12:	430b      	orrs	r3, r1
34195d14:	431a      	orrs	r2, r3
34195d16:	69bb      	ldr	r3, [r7, #24]
34195d18:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
34195d1a:	697b      	ldr	r3, [r7, #20]
34195d1c:	681b      	ldr	r3, [r3, #0]
34195d1e:	f023 021f 	bic.w	r2, r3, #31
34195d22:	683b      	ldr	r3, [r7, #0]
34195d24:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34195d26:	431a      	orrs	r2, r3
34195d28:	697b      	ldr	r3, [r7, #20]
34195d2a:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195d2c:	683b      	ldr	r3, [r7, #0]
34195d2e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195d30:	2b00      	cmp	r3, #0
34195d32:	d009      	beq.n	34195d48 <XSPI_ConfigCmd+0x12c>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34195d34:	683b      	ldr	r3, [r7, #0]
34195d36:	681b      	ldr	r3, [r3, #0]
34195d38:	2b00      	cmp	r3, #0
34195d3a:	d105      	bne.n	34195d48 <XSPI_ConfigCmd+0x12c>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
34195d3c:	683b      	ldr	r3, [r7, #0]
34195d3e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34195d40:	687b      	ldr	r3, [r7, #4]
34195d42:	681b      	ldr	r3, [r3, #0]
34195d44:	3a01      	subs	r2, #1
34195d46:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195d48:	683b      	ldr	r3, [r7, #0]
34195d4a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195d4c:	2b00      	cmp	r3, #0
34195d4e:	d01e      	beq.n	34195d8e <XSPI_ConfigCmd+0x172>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
34195d50:	683b      	ldr	r3, [r7, #0]
34195d52:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34195d54:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34195d58:	d10a      	bne.n	34195d70 <XSPI_ConfigCmd+0x154>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34195d5a:	687b      	ldr	r3, [r7, #4]
34195d5c:	681b      	ldr	r3, [r3, #0]
34195d5e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34195d62:	687b      	ldr	r3, [r7, #4]
34195d64:	681b      	ldr	r3, [r3, #0]
34195d66:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
34195d6a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
34195d6e:	e00e      	b.n	34195d8e <XSPI_ConfigCmd+0x172>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
34195d70:	687b      	ldr	r3, [r7, #4]
34195d72:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34195d74:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34195d78:	d109      	bne.n	34195d8e <XSPI_ConfigCmd+0x172>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34195d7a:	687b      	ldr	r3, [r7, #4]
34195d7c:	681b      	ldr	r3, [r3, #0]
34195d7e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34195d82:	687b      	ldr	r3, [r7, #4]
34195d84:	681b      	ldr	r3, [r3, #0]
34195d86:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
34195d8a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
34195d8e:	683b      	ldr	r3, [r7, #0]
34195d90:	68db      	ldr	r3, [r3, #12]
34195d92:	2b00      	cmp	r3, #0
34195d94:	f000 808f 	beq.w	34195eb6 <XSPI_ConfigCmd+0x29a>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34195d98:	683b      	ldr	r3, [r7, #0]
34195d9a:	69db      	ldr	r3, [r3, #28]
34195d9c:	2b00      	cmp	r3, #0
34195d9e:	d050      	beq.n	34195e42 <XSPI_ConfigCmd+0x226>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195da0:	683b      	ldr	r3, [r7, #0]
34195da2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195da4:	2b00      	cmp	r3, #0
34195da6:	d01e      	beq.n	34195de6 <XSPI_ConfigCmd+0x1ca>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34195da8:	69bb      	ldr	r3, [r7, #24]
34195daa:	681a      	ldr	r2, [r3, #0]
34195dac:	4b69      	ldr	r3, [pc, #420]	@ (34195f54 <XSPI_ConfigCmd+0x338>)
34195dae:	4013      	ands	r3, r2
34195db0:	683a      	ldr	r2, [r7, #0]
34195db2:	68d1      	ldr	r1, [r2, #12]
34195db4:	683a      	ldr	r2, [r7, #0]
34195db6:	6952      	ldr	r2, [r2, #20]
34195db8:	4311      	orrs	r1, r2
34195dba:	683a      	ldr	r2, [r7, #0]
34195dbc:	6912      	ldr	r2, [r2, #16]
34195dbe:	4311      	orrs	r1, r2
34195dc0:	683a      	ldr	r2, [r7, #0]
34195dc2:	69d2      	ldr	r2, [r2, #28]
34195dc4:	4311      	orrs	r1, r2
34195dc6:	683a      	ldr	r2, [r7, #0]
34195dc8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34195dca:	4311      	orrs	r1, r2
34195dcc:	683a      	ldr	r2, [r7, #0]
34195dce:	6a12      	ldr	r2, [r2, #32]
34195dd0:	4311      	orrs	r1, r2
34195dd2:	683a      	ldr	r2, [r7, #0]
34195dd4:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34195dd6:	4311      	orrs	r1, r2
34195dd8:	683a      	ldr	r2, [r7, #0]
34195dda:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34195ddc:	430a      	orrs	r2, r1
34195dde:	431a      	orrs	r2, r3
34195de0:	69bb      	ldr	r3, [r7, #24]
34195de2:	601a      	str	r2, [r3, #0]
34195de4:	e023      	b.n	34195e2e <XSPI_ConfigCmd+0x212>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34195de6:	69bb      	ldr	r3, [r7, #24]
34195de8:	681b      	ldr	r3, [r3, #0]
34195dea:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34195dee:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34195df2:	683a      	ldr	r2, [r7, #0]
34195df4:	68d1      	ldr	r1, [r2, #12]
34195df6:	683a      	ldr	r2, [r7, #0]
34195df8:	6952      	ldr	r2, [r2, #20]
34195dfa:	4311      	orrs	r1, r2
34195dfc:	683a      	ldr	r2, [r7, #0]
34195dfe:	6912      	ldr	r2, [r2, #16]
34195e00:	4311      	orrs	r1, r2
34195e02:	683a      	ldr	r2, [r7, #0]
34195e04:	69d2      	ldr	r2, [r2, #28]
34195e06:	4311      	orrs	r1, r2
34195e08:	683a      	ldr	r2, [r7, #0]
34195e0a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34195e0c:	4311      	orrs	r1, r2
34195e0e:	683a      	ldr	r2, [r7, #0]
34195e10:	6a12      	ldr	r2, [r2, #32]
34195e12:	430a      	orrs	r2, r1
34195e14:	431a      	orrs	r2, r3
34195e16:	69bb      	ldr	r3, [r7, #24]
34195e18:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* DDTR bit should be activated */
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
34195e1a:	683b      	ldr	r3, [r7, #0]
34195e1c:	695b      	ldr	r3, [r3, #20]
34195e1e:	2b08      	cmp	r3, #8
34195e20:	d105      	bne.n	34195e2e <XSPI_ConfigCmd+0x212>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34195e22:	69bb      	ldr	r3, [r7, #24]
34195e24:	681b      	ldr	r3, [r3, #0]
34195e26:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34195e2a:	69bb      	ldr	r3, [r7, #24]
34195e2c:	601a      	str	r2, [r3, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34195e2e:	683b      	ldr	r3, [r7, #0]
34195e30:	689a      	ldr	r2, [r3, #8]
34195e32:	693b      	ldr	r3, [r7, #16]
34195e34:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
34195e36:	687b      	ldr	r3, [r7, #4]
34195e38:	681b      	ldr	r3, [r3, #0]
34195e3a:	683a      	ldr	r2, [r7, #0]
34195e3c:	6992      	ldr	r2, [r2, #24]
34195e3e:	649a      	str	r2, [r3, #72]	@ 0x48
34195e40:	e073      	b.n	34195f2a <XSPI_ConfigCmd+0x30e>
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
      }
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195e42:	683b      	ldr	r3, [r7, #0]
34195e44:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195e46:	2b00      	cmp	r3, #0
34195e48:	d017      	beq.n	34195e7a <XSPI_ConfigCmd+0x25e>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
34195e4a:	69bb      	ldr	r3, [r7, #24]
34195e4c:	681b      	ldr	r3, [r3, #0]
34195e4e:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34195e52:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34195e56:	683a      	ldr	r2, [r7, #0]
34195e58:	68d1      	ldr	r1, [r2, #12]
34195e5a:	683a      	ldr	r2, [r7, #0]
34195e5c:	6952      	ldr	r2, [r2, #20]
34195e5e:	4311      	orrs	r1, r2
34195e60:	683a      	ldr	r2, [r7, #0]
34195e62:	6912      	ldr	r2, [r2, #16]
34195e64:	4311      	orrs	r1, r2
34195e66:	683a      	ldr	r2, [r7, #0]
34195e68:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34195e6a:	4311      	orrs	r1, r2
34195e6c:	683a      	ldr	r2, [r7, #0]
34195e6e:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34195e70:	430a      	orrs	r2, r1
34195e72:	431a      	orrs	r2, r3
34195e74:	69bb      	ldr	r3, [r7, #24]
34195e76:	601a      	str	r2, [r3, #0]
34195e78:	e018      	b.n	34195eac <XSPI_ConfigCmd+0x290>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
34195e7a:	69bb      	ldr	r3, [r7, #24]
34195e7c:	681b      	ldr	r3, [r3, #0]
34195e7e:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
34195e82:	683b      	ldr	r3, [r7, #0]
34195e84:	68d9      	ldr	r1, [r3, #12]
34195e86:	683b      	ldr	r3, [r7, #0]
34195e88:	695b      	ldr	r3, [r3, #20]
34195e8a:	4319      	orrs	r1, r3
34195e8c:	683b      	ldr	r3, [r7, #0]
34195e8e:	691b      	ldr	r3, [r3, #16]
34195e90:	430b      	orrs	r3, r1
34195e92:	431a      	orrs	r2, r3
34195e94:	69bb      	ldr	r3, [r7, #24]
34195e96:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));

        /* DDTR bit should be activated */
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
34195e98:	683b      	ldr	r3, [r7, #0]
34195e9a:	695b      	ldr	r3, [r3, #20]
34195e9c:	2b08      	cmp	r3, #8
34195e9e:	d105      	bne.n	34195eac <XSPI_ConfigCmd+0x290>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34195ea0:	69bb      	ldr	r3, [r7, #24]
34195ea2:	681b      	ldr	r3, [r3, #0]
34195ea4:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34195ea8:	69bb      	ldr	r3, [r7, #24]
34195eaa:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34195eac:	683b      	ldr	r3, [r7, #0]
34195eae:	689a      	ldr	r2, [r3, #8]
34195eb0:	693b      	ldr	r3, [r7, #16]
34195eb2:	601a      	str	r2, [r3, #0]
34195eb4:	e039      	b.n	34195f2a <XSPI_ConfigCmd+0x30e>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34195eb6:	683b      	ldr	r3, [r7, #0]
34195eb8:	69db      	ldr	r3, [r3, #28]
34195eba:	2b00      	cmp	r3, #0
34195ebc:	d030      	beq.n	34195f20 <XSPI_ConfigCmd+0x304>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195ebe:	683b      	ldr	r3, [r7, #0]
34195ec0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195ec2:	2b00      	cmp	r3, #0
34195ec4:	d017      	beq.n	34195ef6 <XSPI_ConfigCmd+0x2da>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
34195ec6:	69bb      	ldr	r3, [r7, #24]
34195ec8:	681b      	ldr	r3, [r3, #0]
34195eca:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34195ece:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34195ed2:	683a      	ldr	r2, [r7, #0]
34195ed4:	69d1      	ldr	r1, [r2, #28]
34195ed6:	683a      	ldr	r2, [r7, #0]
34195ed8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34195eda:	4311      	orrs	r1, r2
34195edc:	683a      	ldr	r2, [r7, #0]
34195ede:	6a12      	ldr	r2, [r2, #32]
34195ee0:	4311      	orrs	r1, r2
34195ee2:	683a      	ldr	r2, [r7, #0]
34195ee4:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34195ee6:	4311      	orrs	r1, r2
34195ee8:	683a      	ldr	r2, [r7, #0]
34195eea:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34195eec:	430a      	orrs	r2, r1
34195eee:	431a      	orrs	r2, r3
34195ef0:	69bb      	ldr	r3, [r7, #24]
34195ef2:	601a      	str	r2, [r3, #0]
34195ef4:	e00e      	b.n	34195f14 <XSPI_ConfigCmd+0x2f8>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
34195ef6:	69bb      	ldr	r3, [r7, #24]
34195ef8:	681b      	ldr	r3, [r3, #0]
34195efa:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
34195efe:	683b      	ldr	r3, [r7, #0]
34195f00:	69d9      	ldr	r1, [r3, #28]
34195f02:	683b      	ldr	r3, [r7, #0]
34195f04:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34195f06:	4319      	orrs	r1, r3
34195f08:	683b      	ldr	r3, [r7, #0]
34195f0a:	6a1b      	ldr	r3, [r3, #32]
34195f0c:	430b      	orrs	r3, r1
34195f0e:	431a      	orrs	r2, r3
34195f10:	69bb      	ldr	r3, [r7, #24]
34195f12:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
34195f14:	687b      	ldr	r3, [r7, #4]
34195f16:	681b      	ldr	r3, [r3, #0]
34195f18:	683a      	ldr	r2, [r7, #0]
34195f1a:	6992      	ldr	r2, [r2, #24]
34195f1c:	649a      	str	r2, [r3, #72]	@ 0x48
34195f1e:	e004      	b.n	34195f2a <XSPI_ConfigCmd+0x30e>
      }
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
34195f20:	2301      	movs	r3, #1
34195f22:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34195f24:	687b      	ldr	r3, [r7, #4]
34195f26:	2208      	movs	r2, #8
34195f28:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34195f2a:	683b      	ldr	r3, [r7, #0]
34195f2c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34195f2e:	2b00      	cmp	r3, #0
34195f30:	d009      	beq.n	34195f46 <XSPI_ConfigCmd+0x32a>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34195f32:	683b      	ldr	r3, [r7, #0]
34195f34:	681b      	ldr	r3, [r3, #0]
34195f36:	2b00      	cmp	r3, #0
34195f38:	d105      	bne.n	34195f46 <XSPI_ConfigCmd+0x32a>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
34195f3a:	683b      	ldr	r3, [r7, #0]
34195f3c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34195f3e:	687b      	ldr	r3, [r7, #4]
34195f40:	681b      	ldr	r3, [r3, #0]
34195f42:	3a01      	subs	r2, #1
34195f44:	641a      	str	r2, [r3, #64]	@ 0x40
      /* Verify if programmed data fit with requirement of Reference Manual 28.5 chapter */
      assert_param(IS_XSPI_PROG_DATA(hxspi->Instance->DLR, (pCmd->DataLength - 1U)));
    }
  }

  return status;
34195f46:	7ffb      	ldrb	r3, [r7, #31]
}
34195f48:	4618      	mov	r0, r3
34195f4a:	3724      	adds	r7, #36	@ 0x24
34195f4c:	46bd      	mov	sp, r7
34195f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34195f52:	4770      	bx	lr
34195f54:	f0ffc0c0 	.word	0xf0ffc0c0

34195f58 <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *pCfg)
{
34195f58:	b480      	push	{r7}
34195f5a:	b085      	sub	sp, #20
34195f5c:	af00      	add	r7, sp, #0
34195f5e:	4603      	mov	r3, r0
34195f60:	6039      	str	r1, [r7, #0]
34195f62:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
34195f64:	79fb      	ldrb	r3, [r7, #7]
34195f66:	2b01      	cmp	r3, #1
34195f68:	d124      	bne.n	34195fb4 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
34195f6a:	4b2c      	ldr	r3, [pc, #176]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195f6c:	681b      	ldr	r3, [r3, #0]
34195f6e:	f003 0302 	and.w	r3, r3, #2
34195f72:	2b00      	cmp	r3, #0
34195f74:	d103      	bne.n	34195f7e <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34195f76:	683b      	ldr	r3, [r7, #0]
34195f78:	2200      	movs	r2, #0
34195f7a:	605a      	str	r2, [r3, #4]
34195f7c:	e002      	b.n	34195f84 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
34195f7e:	683b      	ldr	r3, [r7, #0]
34195f80:	2201      	movs	r2, #1
34195f82:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34195f84:	4b25      	ldr	r3, [pc, #148]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195f86:	681b      	ldr	r3, [r3, #0]
34195f88:	f003 0310 	and.w	r3, r3, #16
34195f8c:	2b10      	cmp	r3, #16
34195f8e:	d003      	beq.n	34195f98 <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
34195f90:	683b      	ldr	r3, [r7, #0]
34195f92:	2200      	movs	r2, #0
34195f94:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
34195f96:	e03a      	b.n	3419600e <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
34195f98:	4b20      	ldr	r3, [pc, #128]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195f9a:	681b      	ldr	r3, [r3, #0]
34195f9c:	f003 0320 	and.w	r3, r3, #32
34195fa0:	2b20      	cmp	r3, #32
34195fa2:	d103      	bne.n	34195fac <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
34195fa4:	683b      	ldr	r3, [r7, #0]
34195fa6:	2270      	movs	r2, #112	@ 0x70
34195fa8:	601a      	str	r2, [r3, #0]
}
34195faa:	e030      	b.n	3419600e <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34195fac:	683b      	ldr	r3, [r7, #0]
34195fae:	2210      	movs	r2, #16
34195fb0:	601a      	str	r2, [r3, #0]
}
34195fb2:	e02c      	b.n	3419600e <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
34195fb4:	4b19      	ldr	r3, [pc, #100]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195fb6:	681b      	ldr	r3, [r3, #0]
34195fb8:	f003 0301 	and.w	r3, r3, #1
34195fbc:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
34195fbe:	4b17      	ldr	r3, [pc, #92]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195fc0:	681b      	ldr	r3, [r3, #0]
34195fc2:	085b      	lsrs	r3, r3, #1
34195fc4:	f003 0301 	and.w	r3, r3, #1
34195fc8:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
34195fca:	68fa      	ldr	r2, [r7, #12]
34195fcc:	68bb      	ldr	r3, [r7, #8]
34195fce:	429a      	cmp	r2, r3
34195fd0:	d003      	beq.n	34195fda <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34195fd2:	683b      	ldr	r3, [r7, #0]
34195fd4:	2200      	movs	r2, #0
34195fd6:	605a      	str	r2, [r3, #4]
34195fd8:	e002      	b.n	34195fe0 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
34195fda:	683b      	ldr	r3, [r7, #0]
34195fdc:	2201      	movs	r2, #1
34195fde:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34195fe0:	4b0e      	ldr	r3, [pc, #56]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195fe2:	681b      	ldr	r3, [r3, #0]
34195fe4:	f003 0310 	and.w	r3, r3, #16
34195fe8:	2b10      	cmp	r3, #16
34195fea:	d003      	beq.n	34195ff4 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
34195fec:	683b      	ldr	r3, [r7, #0]
34195fee:	2200      	movs	r2, #0
34195ff0:	601a      	str	r2, [r3, #0]
}
34195ff2:	e00c      	b.n	3419600e <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
34195ff4:	4b09      	ldr	r3, [pc, #36]	@ (3419601c <XSPIM_GetConfig+0xc4>)
34195ff6:	681b      	ldr	r3, [r3, #0]
34195ff8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34195ffc:	2b40      	cmp	r3, #64	@ 0x40
34195ffe:	d103      	bne.n	34196008 <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
34196000:	683b      	ldr	r3, [r7, #0]
34196002:	2270      	movs	r2, #112	@ 0x70
34196004:	601a      	str	r2, [r3, #0]
}
34196006:	e002      	b.n	3419600e <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34196008:	683b      	ldr	r3, [r7, #0]
3419600a:	2210      	movs	r2, #16
3419600c:	601a      	str	r2, [r3, #0]
}
3419600e:	bf00      	nop
34196010:	3714      	adds	r7, #20
34196012:	46bd      	mov	sp, r7
34196014:	f85d 7b04 	ldr.w	r7, [sp], #4
34196018:	4770      	bx	lr
3419601a:	bf00      	nop
3419601c:	5802b400 	.word	0x5802b400

34196020 <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
34196020:	b580      	push	{r7, lr}
34196022:	b09c      	sub	sp, #112	@ 0x70
34196024:	af00      	add	r7, sp, #0
34196026:	60f8      	str	r0, [r7, #12]
34196028:	60b9      	str	r1, [r7, #8]
3419602a:	607a      	str	r2, [r7, #4]
3419602c:	603b      	str	r3, [r7, #0]
  XSPI_RegularCmdTypeDef   sCommand = {0};
3419602e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34196032:	224c      	movs	r2, #76	@ 0x4c
34196034:	2100      	movs	r1, #0
34196036:	4618      	mov	r0, r3
34196038:	f00d feb4 	bl	341a3da4 <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
3419603c:	f107 0314 	add.w	r3, r7, #20
34196040:	2200      	movs	r2, #0
34196042:	601a      	str	r2, [r3, #0]
34196044:	605a      	str	r2, [r3, #4]
34196046:	609a      	str	r2, [r3, #8]
34196048:	60da      	str	r2, [r3, #12]

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
3419604a:	2302      	movs	r3, #2
3419604c:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
3419604e:	2304      	movs	r3, #4
34196050:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
34196052:	2300      	movs	r3, #0
34196054:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34196056:	2300      	movs	r3, #0
34196058:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
3419605a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3419605c:	2b00      	cmp	r3, #0
3419605e:	d101      	bne.n	34196064 <APS256XX_EnableMemoryMappedMode+0x44>
34196060:	23a0      	movs	r3, #160	@ 0xa0
34196062:	e000      	b.n	34196066 <APS256XX_EnableMemoryMappedMode+0x46>
34196064:	2380      	movs	r3, #128	@ 0x80
34196066:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
34196068:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419606c:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3419606e:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34196072:	647b      	str	r3, [r7, #68]	@ 0x44
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34196074:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34196078:	64bb      	str	r3, [r7, #72]	@ 0x48
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
3419607a:	2300      	movs	r3, #0
3419607c:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
3419607e:	683b      	ldr	r3, [r7, #0]
34196080:	2b00      	cmp	r3, #0
34196082:	d102      	bne.n	3419608a <APS256XX_EnableMemoryMappedMode+0x6a>
34196084:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34196088:	e001      	b.n	3419608e <APS256XX_EnableMemoryMappedMode+0x6e>
3419608a:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
3419608e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
34196090:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34196094:	667b      	str	r3, [r7, #100]	@ 0x64
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
34196096:	687b      	ldr	r3, [r7, #4]
34196098:	3b01      	subs	r3, #1
3419609a:	66bb      	str	r3, [r7, #104]	@ 0x68
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
3419609c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341960a0:	66fb      	str	r3, [r7, #108]	@ 0x6c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341960a2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
341960a6:	f241 3288 	movw	r2, #5000	@ 0x1388
341960aa:	4619      	mov	r1, r3
341960ac:	68f8      	ldr	r0, [r7, #12]
341960ae:	f7ff f8f9 	bl	341952a4 <HAL_XSPI_Command>
341960b2:	4603      	mov	r3, r0
341960b4:	2b00      	cmp	r3, #0
341960b6:	d002      	beq.n	341960be <APS256XX_EnableMemoryMappedMode+0x9e>
  {
    return APS256XX_ERROR;
341960b8:	f04f 33ff 	mov.w	r3, #4294967295
341960bc:	e028      	b.n	34196110 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Initialize the read command */
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
341960be:	2301      	movs	r3, #1
341960c0:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
341960c2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341960c4:	2b00      	cmp	r3, #0
341960c6:	d101      	bne.n	341960cc <APS256XX_EnableMemoryMappedMode+0xac>
341960c8:	2320      	movs	r3, #32
341960ca:	e000      	b.n	341960ce <APS256XX_EnableMemoryMappedMode+0xae>
341960cc:	2300      	movs	r3, #0
341960ce:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
341960d0:	68bb      	ldr	r3, [r7, #8]
341960d2:	3b01      	subs	r3, #1
341960d4:	66bb      	str	r3, [r7, #104]	@ 0x68

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341960d6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
341960da:	f241 3288 	movw	r2, #5000	@ 0x1388
341960de:	4619      	mov	r1, r3
341960e0:	68f8      	ldr	r0, [r7, #12]
341960e2:	f7ff f8df 	bl	341952a4 <HAL_XSPI_Command>
341960e6:	4603      	mov	r3, r0
341960e8:	2b00      	cmp	r3, #0
341960ea:	d002      	beq.n	341960f2 <APS256XX_EnableMemoryMappedMode+0xd2>
  {
    return APS256XX_ERROR;
341960ec:	f04f 33ff 	mov.w	r3, #4294967295
341960f0:	e00e      	b.n	34196110 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Activation of memory-mapped mode */
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
341960f2:	2300      	movs	r3, #0
341960f4:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
341960f6:	f107 0314 	add.w	r3, r7, #20
341960fa:	4619      	mov	r1, r3
341960fc:	68f8      	ldr	r0, [r7, #12]
341960fe:	f7ff fb01 	bl	34195704 <HAL_XSPI_MemoryMapped>
34196102:	4603      	mov	r3, r0
34196104:	2b00      	cmp	r3, #0
34196106:	d002      	beq.n	3419610e <APS256XX_EnableMemoryMappedMode+0xee>
  {
    return APS256XX_ERROR;
34196108:	f04f 33ff 	mov.w	r3, #4294967295
3419610c:	e000      	b.n	34196110 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  return APS256XX_OK;
3419610e:	2300      	movs	r3, #0
}
34196110:	4618      	mov	r0, r3
34196112:	3770      	adds	r7, #112	@ 0x70
34196114:	46bd      	mov	sp, r7
34196116:	bd80      	pop	{r7, pc}

34196118 <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
34196118:	b580      	push	{r7, lr}
3419611a:	b098      	sub	sp, #96	@ 0x60
3419611c:	af00      	add	r7, sp, #0
3419611e:	60f8      	str	r0, [r7, #12]
34196120:	60b9      	str	r1, [r7, #8]
34196122:	4613      	mov	r3, r2
34196124:	71fb      	strb	r3, [r7, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
34196126:	f107 0314 	add.w	r3, r7, #20
3419612a:	224c      	movs	r2, #76	@ 0x4c
3419612c:	2100      	movs	r1, #0
3419612e:	4618      	mov	r0, r3
34196130:	f00d fe38 	bl	341a3da4 <memset>

  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
34196134:	2300      	movs	r3, #0
34196136:	617b      	str	r3, [r7, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
34196138:	2304      	movs	r3, #4
3419613a:	623b      	str	r3, [r7, #32]
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
3419613c:	2300      	movs	r3, #0
3419613e:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34196140:	2300      	movs	r3, #0
34196142:	62bb      	str	r3, [r7, #40]	@ 0x28
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
34196144:	23c0      	movs	r3, #192	@ 0xc0
34196146:	61fb      	str	r3, [r7, #28]
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
34196148:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419614c:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3419614e:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34196152:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34196154:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34196158:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Address             = Address;
3419615a:	68bb      	ldr	r3, [r7, #8]
3419615c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
3419615e:	2300      	movs	r3, #0
34196160:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34196162:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34196166:	64fb      	str	r3, [r7, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
34196168:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3419616c:	657b      	str	r3, [r7, #84]	@ 0x54
  sCommand.DataLength          = 2;
3419616e:	2302      	movs	r3, #2
34196170:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DummyCycles         = 0;
34196172:	2300      	movs	r3, #0
34196174:	65bb      	str	r3, [r7, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_DISABLE;
34196176:	2300      	movs	r3, #0
34196178:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419617a:	f107 0314 	add.w	r3, r7, #20
3419617e:	f241 3288 	movw	r2, #5000	@ 0x1388
34196182:	4619      	mov	r1, r3
34196184:	68f8      	ldr	r0, [r7, #12]
34196186:	f7ff f88d 	bl	341952a4 <HAL_XSPI_Command>
3419618a:	4603      	mov	r3, r0
3419618c:	2b00      	cmp	r3, #0
3419618e:	d002      	beq.n	34196196 <APS256XX_WriteReg+0x7e>
  {
    return APS256XX_ERROR;
34196190:	f04f 33ff 	mov.w	r3, #4294967295
34196194:	e00d      	b.n	341961b2 <APS256XX_WriteReg+0x9a>
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196196:	1dfb      	adds	r3, r7, #7
34196198:	f241 3288 	movw	r2, #5000	@ 0x1388
3419619c:	4619      	mov	r1, r3
3419619e:	68f8      	ldr	r0, [r7, #12]
341961a0:	f7ff f910 	bl	341953c4 <HAL_XSPI_Transmit>
341961a4:	4603      	mov	r3, r0
341961a6:	2b00      	cmp	r3, #0
341961a8:	d002      	beq.n	341961b0 <APS256XX_WriteReg+0x98>
  {
    return APS256XX_ERROR;
341961aa:	f04f 33ff 	mov.w	r3, #4294967295
341961ae:	e000      	b.n	341961b2 <APS256XX_WriteReg+0x9a>
  }

  return APS256XX_OK;
341961b0:	2300      	movs	r3, #0
}
341961b2:	4618      	mov	r0, r3
341961b4:	3760      	adds	r7, #96	@ 0x60
341961b6:	46bd      	mov	sp, r7
341961b8:	bd80      	pop	{r7, pc}

341961ba <MX66UW1G45G_GetFlashInfo>:
  * @brief  Get Flash information
  * @param  pInfo pointer to information structure
  * @retval error status
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
341961ba:	b480      	push	{r7}
341961bc:	b083      	sub	sp, #12
341961be:	af00      	add	r7, sp, #0
341961c0:	6078      	str	r0, [r7, #4]
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
341961c2:	687b      	ldr	r3, [r7, #4]
341961c4:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
341961c8:	601a      	str	r2, [r3, #0]
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
341961ca:	687b      	ldr	r3, [r7, #4]
341961cc:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341961d0:	605a      	str	r2, [r3, #4]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
341961d2:	687b      	ldr	r3, [r7, #4]
341961d4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
341961d8:	609a      	str	r2, [r3, #8]
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
341961da:	687b      	ldr	r3, [r7, #4]
341961dc:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
341961e0:	60da      	str	r2, [r3, #12]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
341961e2:	687b      	ldr	r3, [r7, #4]
341961e4:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341961e8:	611a      	str	r2, [r3, #16]
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
341961ea:	687b      	ldr	r3, [r7, #4]
341961ec:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
341961f0:	615a      	str	r2, [r3, #20]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
341961f2:	687b      	ldr	r3, [r7, #4]
341961f4:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341961f8:	619a      	str	r2, [r3, #24]
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
341961fa:	687b      	ldr	r3, [r7, #4]
341961fc:	f44f 7280 	mov.w	r2, #256	@ 0x100
34196200:	61da      	str	r2, [r3, #28]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
34196202:	687b      	ldr	r3, [r7, #4]
34196204:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
34196208:	621a      	str	r2, [r3, #32]

  return MX66UW1G45G_OK;
3419620a:	2300      	movs	r3, #0
};
3419620c:	4618      	mov	r0, r3
3419620e:	370c      	adds	r7, #12
34196210:	46bd      	mov	sp, r7
34196212:	f85d 7b04 	ldr.w	r7, [sp], #4
34196216:	4770      	bx	lr

34196218 <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
34196218:	b580      	push	{r7, lr}
3419621a:	b09a      	sub	sp, #104	@ 0x68
3419621c:	af00      	add	r7, sp, #0
3419621e:	6078      	str	r0, [r7, #4]
34196220:	460b      	mov	r3, r1
34196222:	70fb      	strb	r3, [r7, #3]
34196224:	4613      	mov	r3, r2
34196226:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34196228:	f107 031c 	add.w	r3, r7, #28
3419622c:	224c      	movs	r2, #76	@ 0x4c
3419622e:	2100      	movs	r1, #0
34196230:	4618      	mov	r0, r3
34196232:	f00d fdb7 	bl	341a3da4 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
34196236:	f107 0308 	add.w	r3, r7, #8
3419623a:	2200      	movs	r2, #0
3419623c:	601a      	str	r2, [r3, #0]
3419623e:	605a      	str	r2, [r3, #4]
34196240:	609a      	str	r2, [r3, #8]
34196242:	60da      	str	r2, [r3, #12]
34196244:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34196246:	78fb      	ldrb	r3, [r7, #3]
34196248:	2b00      	cmp	r3, #0
3419624a:	d105      	bne.n	34196258 <MX66UW1G45G_AutoPollingMemReady+0x40>
3419624c:	78bb      	ldrb	r3, [r7, #2]
3419624e:	2b01      	cmp	r3, #1
34196250:	d102      	bne.n	34196258 <MX66UW1G45G_AutoPollingMemReady+0x40>
  {
    return MX66UW1G45G_ERROR;
34196252:	f04f 33ff 	mov.w	r3, #4294967295
34196256:	e089      	b.n	3419636c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  /* Configure automatic polling mode to wait for memory ready */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34196258:	2300      	movs	r3, #0
3419625a:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
3419625c:	78fb      	ldrb	r3, [r7, #3]
3419625e:	2b00      	cmp	r3, #0
34196260:	d101      	bne.n	34196266 <MX66UW1G45G_AutoPollingMemReady+0x4e>
34196262:	2301      	movs	r3, #1
34196264:	e000      	b.n	34196268 <MX66UW1G45G_AutoPollingMemReady+0x50>
34196266:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34196268:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3419626a:	78bb      	ldrb	r3, [r7, #2]
3419626c:	2b01      	cmp	r3, #1
3419626e:	d101      	bne.n	34196274 <MX66UW1G45G_AutoPollingMemReady+0x5c>
34196270:	2308      	movs	r3, #8
34196272:	e000      	b.n	34196276 <MX66UW1G45G_AutoPollingMemReady+0x5e>
34196274:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34196276:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34196278:	78fb      	ldrb	r3, [r7, #3]
3419627a:	2b00      	cmp	r3, #0
3419627c:	d101      	bne.n	34196282 <MX66UW1G45G_AutoPollingMemReady+0x6a>
3419627e:	2300      	movs	r3, #0
34196280:	e000      	b.n	34196284 <MX66UW1G45G_AutoPollingMemReady+0x6c>
34196282:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34196284:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
34196286:	78fb      	ldrb	r3, [r7, #3]
34196288:	2b00      	cmp	r3, #0
3419628a:	d101      	bne.n	34196290 <MX66UW1G45G_AutoPollingMemReady+0x78>
3419628c:	2305      	movs	r3, #5
3419628e:	e001      	b.n	34196294 <MX66UW1G45G_AutoPollingMemReady+0x7c>
34196290:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34196294:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34196296:	78fb      	ldrb	r3, [r7, #3]
34196298:	2b00      	cmp	r3, #0
3419629a:	d101      	bne.n	341962a0 <MX66UW1G45G_AutoPollingMemReady+0x88>
3419629c:	2300      	movs	r3, #0
3419629e:	e001      	b.n	341962a4 <MX66UW1G45G_AutoPollingMemReady+0x8c>
341962a0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341962a4:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
341962a6:	78bb      	ldrb	r3, [r7, #2]
341962a8:	2b01      	cmp	r3, #1
341962aa:	d102      	bne.n	341962b2 <MX66UW1G45G_AutoPollingMemReady+0x9a>
341962ac:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341962b0:	e000      	b.n	341962b4 <MX66UW1G45G_AutoPollingMemReady+0x9c>
341962b2:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341962b4:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341962b6:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341962ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
341962bc:	2300      	movs	r3, #0
341962be:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341962c0:	2300      	movs	r3, #0
341962c2:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
341962c4:	78fb      	ldrb	r3, [r7, #3]
341962c6:	2b00      	cmp	r3, #0
341962c8:	d102      	bne.n	341962d0 <MX66UW1G45G_AutoPollingMemReady+0xb8>
341962ca:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341962ce:	e001      	b.n	341962d4 <MX66UW1G45G_AutoPollingMemReady+0xbc>
341962d0:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341962d4:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
341962d6:	78bb      	ldrb	r3, [r7, #2]
341962d8:	2b01      	cmp	r3, #1
341962da:	d102      	bne.n	341962e2 <MX66UW1G45G_AutoPollingMemReady+0xca>
341962dc:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341962e0:	e000      	b.n	341962e4 <MX66UW1G45G_AutoPollingMemReady+0xcc>
341962e2:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341962e4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
341962e6:	78fb      	ldrb	r3, [r7, #3]
341962e8:	2b00      	cmp	r3, #0
341962ea:	d006      	beq.n	341962fa <MX66UW1G45G_AutoPollingMemReady+0xe2>
341962ec:	78bb      	ldrb	r3, [r7, #2]
341962ee:	2b01      	cmp	r3, #1
341962f0:	d101      	bne.n	341962f6 <MX66UW1G45G_AutoPollingMemReady+0xde>
341962f2:	2305      	movs	r3, #5
341962f4:	e002      	b.n	341962fc <MX66UW1G45G_AutoPollingMemReady+0xe4>
341962f6:	2304      	movs	r3, #4
341962f8:	e000      	b.n	341962fc <MX66UW1G45G_AutoPollingMemReady+0xe4>
341962fa:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
341962fc:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
341962fe:	78bb      	ldrb	r3, [r7, #2]
34196300:	2b01      	cmp	r3, #1
34196302:	d101      	bne.n	34196308 <MX66UW1G45G_AutoPollingMemReady+0xf0>
34196304:	2302      	movs	r3, #2
34196306:	e000      	b.n	3419630a <MX66UW1G45G_AutoPollingMemReady+0xf2>
34196308:	2301      	movs	r3, #1
3419630a:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
3419630c:	78bb      	ldrb	r3, [r7, #2]
3419630e:	2b01      	cmp	r3, #1
34196310:	d102      	bne.n	34196318 <MX66UW1G45G_AutoPollingMemReady+0x100>
34196312:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34196316:	e000      	b.n	3419631a <MX66UW1G45G_AutoPollingMemReady+0x102>
34196318:	2300      	movs	r3, #0
3419631a:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  s_config.MatchValue = 0U;
3419631c:	2300      	movs	r3, #0
3419631e:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
34196320:	2301      	movs	r3, #1
34196322:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34196324:	2300      	movs	r3, #0
34196326:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
34196328:	2310      	movs	r3, #16
3419632a:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
3419632c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34196330:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196332:	f107 031c 	add.w	r3, r7, #28
34196336:	f241 3288 	movw	r2, #5000	@ 0x1388
3419633a:	4619      	mov	r1, r3
3419633c:	6878      	ldr	r0, [r7, #4]
3419633e:	f7fe ffb1 	bl	341952a4 <HAL_XSPI_Command>
34196342:	4603      	mov	r3, r0
34196344:	2b00      	cmp	r3, #0
34196346:	d002      	beq.n	3419634e <MX66UW1G45G_AutoPollingMemReady+0x136>
  {
    return MX66UW1G45G_ERROR;
34196348:	f04f 33ff 	mov.w	r3, #4294967295
3419634c:	e00e      	b.n	3419636c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419634e:	f107 0308 	add.w	r3, r7, #8
34196352:	f241 3288 	movw	r2, #5000	@ 0x1388
34196356:	4619      	mov	r1, r3
34196358:	6878      	ldr	r0, [r7, #4]
3419635a:	f7ff f949 	bl	341955f0 <HAL_XSPI_AutoPolling>
3419635e:	4603      	mov	r3, r0
34196360:	2b00      	cmp	r3, #0
34196362:	d002      	beq.n	3419636a <MX66UW1G45G_AutoPollingMemReady+0x152>
  {
    return MX66UW1G45G_ERROR;
34196364:	f04f 33ff 	mov.w	r3, #4294967295
34196368:	e000      	b.n	3419636c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  return MX66UW1G45G_OK;
3419636a:	2300      	movs	r3, #0
}
3419636c:	4618      	mov	r0, r3
3419636e:	3768      	adds	r7, #104	@ 0x68
34196370:	46bd      	mov	sp, r7
34196372:	bd80      	pop	{r7, pc}

34196374 <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34196374:	b580      	push	{r7, lr}
34196376:	b09a      	sub	sp, #104	@ 0x68
34196378:	af00      	add	r7, sp, #0
3419637a:	6078      	str	r0, [r7, #4]
3419637c:	460b      	mov	r3, r1
3419637e:	70fb      	strb	r3, [r7, #3]
34196380:	4613      	mov	r3, r2
34196382:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34196384:	f107 031c 	add.w	r3, r7, #28
34196388:	224c      	movs	r2, #76	@ 0x4c
3419638a:	2100      	movs	r1, #0
3419638c:	4618      	mov	r0, r3
3419638e:	f00d fd09 	bl	341a3da4 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34196392:	f107 030c 	add.w	r3, r7, #12
34196396:	2200      	movs	r2, #0
34196398:	601a      	str	r2, [r3, #0]
3419639a:	605a      	str	r2, [r3, #4]
3419639c:	609a      	str	r2, [r3, #8]
3419639e:	60da      	str	r2, [r3, #12]

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
341963a0:	78fb      	ldrb	r3, [r7, #3]
341963a2:	2b01      	cmp	r3, #1
341963a4:	d105      	bne.n	341963b2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
341963a6:	78bb      	ldrb	r3, [r7, #2]
341963a8:	2b00      	cmp	r3, #0
341963aa:	d102      	bne.n	341963b2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
  {
    return MX66UW1G45G_ERROR;
341963ac:	f04f 33ff 	mov.w	r3, #4294967295
341963b0:	e084      	b.n	341964bc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
341963b2:	2301      	movs	r3, #1
341963b4:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
341963b6:	78fb      	ldrb	r3, [r7, #3]
341963b8:	2b00      	cmp	r3, #0
341963ba:	d101      	bne.n	341963c0 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4c>
341963bc:	2301      	movs	r3, #1
341963be:	e000      	b.n	341963c2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4e>
341963c0:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
341963c2:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341963c4:	2300      	movs	r3, #0
341963c6:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
341963c8:	78fb      	ldrb	r3, [r7, #3]
341963ca:	2b00      	cmp	r3, #0
341963cc:	d101      	bne.n	341963d2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x5e>
341963ce:	2300      	movs	r3, #0
341963d0:	e000      	b.n	341963d4 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x60>
341963d2:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
341963d4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_FAST_READ_CMD
                                     : MX66UW1G45G_4_BYTE_ADDR_FAST_READ_CMD)
                              : MX66UW1G45G_OCTA_READ_CMD;
341963d6:	78fb      	ldrb	r3, [r7, #3]
341963d8:	2b00      	cmp	r3, #0
341963da:	d106      	bne.n	341963ea <MX66UW1G45G_EnableSTRMemoryMappedMode+0x76>
341963dc:	78bb      	ldrb	r3, [r7, #2]
341963de:	2b00      	cmp	r3, #0
341963e0:	d101      	bne.n	341963e6 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x72>
341963e2:	230b      	movs	r3, #11
341963e4:	e003      	b.n	341963ee <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
341963e6:	230c      	movs	r3, #12
341963e8:	e001      	b.n	341963ee <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
341963ea:	f64e 4313 	movw	r3, #60435	@ 0xec13
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341963ee:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
341963f0:	78fb      	ldrb	r3, [r7, #3]
341963f2:	2b00      	cmp	r3, #0
341963f4:	d102      	bne.n	341963fc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x88>
341963f6:	f44f 7380 	mov.w	r3, #256	@ 0x100
341963fa:	e001      	b.n	34196400 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x8c>
341963fc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34196400:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
34196402:	2300      	movs	r3, #0
34196404:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                               ? HAL_XSPI_ADDRESS_24_BITS
                               : HAL_XSPI_ADDRESS_32_BITS;
34196406:	78bb      	ldrb	r3, [r7, #2]
34196408:	2b00      	cmp	r3, #0
3419640a:	d102      	bne.n	34196412 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x9e>
3419640c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34196410:	e001      	b.n	34196416 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xa2>
34196412:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
34196416:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34196418:	2300      	movs	r3, #0
3419641a:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
3419641c:	78fb      	ldrb	r3, [r7, #3]
3419641e:	2b00      	cmp	r3, #0
34196420:	d102      	bne.n	34196428 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb4>
34196422:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34196426:	e001      	b.n	3419642c <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb8>
34196428:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
3419642c:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
3419642e:	2300      	movs	r3, #0
34196430:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
34196432:	78fb      	ldrb	r3, [r7, #3]
34196434:	2b00      	cmp	r3, #0
34196436:	d101      	bne.n	3419643c <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc8>
34196438:	2308      	movs	r3, #8
3419643a:	e000      	b.n	3419643e <MX66UW1G45G_EnableSTRMemoryMappedMode+0xca>
3419643c:	230a      	movs	r3, #10
3419643e:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34196440:	2300      	movs	r3, #0
34196442:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the read command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196444:	f107 031c 	add.w	r3, r7, #28
34196448:	f241 3288 	movw	r2, #5000	@ 0x1388
3419644c:	4619      	mov	r1, r3
3419644e:	6878      	ldr	r0, [r7, #4]
34196450:	f7fe ff28 	bl	341952a4 <HAL_XSPI_Command>
34196454:	4603      	mov	r3, r0
34196456:	2b00      	cmp	r3, #0
34196458:	d002      	beq.n	34196460 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xec>
  {
    return MX66UW1G45G_ERROR;
3419645a:	f04f 33ff 	mov.w	r3, #4294967295
3419645e:	e02d      	b.n	341964bc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34196460:	2302      	movs	r3, #2
34196462:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_PAGE_PROG_CMD
                                     : MX66UW1G45G_4_BYTE_PAGE_PROG_CMD)
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34196464:	78fb      	ldrb	r3, [r7, #3]
34196466:	2b00      	cmp	r3, #0
34196468:	d106      	bne.n	34196478 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x104>
3419646a:	78bb      	ldrb	r3, [r7, #2]
3419646c:	2b00      	cmp	r3, #0
3419646e:	d101      	bne.n	34196474 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x100>
34196470:	2302      	movs	r3, #2
34196472:	e003      	b.n	3419647c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34196474:	2312      	movs	r3, #18
34196476:	e001      	b.n	3419647c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34196478:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3419647c:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
3419647e:	2300      	movs	r3, #0
34196480:	663b      	str	r3, [r7, #96]	@ 0x60

  /* Send the write command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196482:	f107 031c 	add.w	r3, r7, #28
34196486:	f241 3288 	movw	r2, #5000	@ 0x1388
3419648a:	4619      	mov	r1, r3
3419648c:	6878      	ldr	r0, [r7, #4]
3419648e:	f7fe ff09 	bl	341952a4 <HAL_XSPI_Command>
34196492:	4603      	mov	r3, r0
34196494:	2b00      	cmp	r3, #0
34196496:	d002      	beq.n	3419649e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x12a>
  {
    return MX66UW1G45G_ERROR;
34196498:	f04f 33ff 	mov.w	r3, #4294967295
3419649c:	e00e      	b.n	341964bc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3419649e:	2300      	movs	r3, #0
341964a0:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
341964a2:	f107 030c 	add.w	r3, r7, #12
341964a6:	4619      	mov	r1, r3
341964a8:	6878      	ldr	r0, [r7, #4]
341964aa:	f7ff f92b 	bl	34195704 <HAL_XSPI_MemoryMapped>
341964ae:	4603      	mov	r3, r0
341964b0:	2b00      	cmp	r3, #0
341964b2:	d002      	beq.n	341964ba <MX66UW1G45G_EnableSTRMemoryMappedMode+0x146>
  {
    return MX66UW1G45G_ERROR;
341964b4:	f04f 33ff 	mov.w	r3, #4294967295
341964b8:	e000      	b.n	341964bc <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  return MX66UW1G45G_OK;
341964ba:	2300      	movs	r3, #0
}
341964bc:	4618      	mov	r0, r3
341964be:	3768      	adds	r7, #104	@ 0x68
341964c0:	46bd      	mov	sp, r7
341964c2:	bd80      	pop	{r7, pc}

341964c4 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
341964c4:	b580      	push	{r7, lr}
341964c6:	b09a      	sub	sp, #104	@ 0x68
341964c8:	af00      	add	r7, sp, #0
341964ca:	6078      	str	r0, [r7, #4]
341964cc:	460b      	mov	r3, r1
341964ce:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
341964d0:	f107 031c 	add.w	r3, r7, #28
341964d4:	224c      	movs	r2, #76	@ 0x4c
341964d6:	2100      	movs	r1, #0
341964d8:	4618      	mov	r0, r3
341964da:	f00d fc63 	bl	341a3da4 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
341964de:	f107 030c 	add.w	r3, r7, #12
341964e2:	2200      	movs	r2, #0
341964e4:	601a      	str	r2, [r3, #0]
341964e6:	605a      	str	r2, [r3, #4]
341964e8:	609a      	str	r2, [r3, #8]
341964ea:	60da      	str	r2, [r3, #12]

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
341964ec:	2301      	movs	r3, #1
341964ee:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
341964f0:	2304      	movs	r3, #4
341964f2:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
341964f4:	2308      	movs	r3, #8
341964f6:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
341964f8:	2310      	movs	r3, #16
341964fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
341964fc:	f64e 6311 	movw	r3, #60945	@ 0xee11
34196500:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34196502:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34196506:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
34196508:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3419650c:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
3419650e:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34196512:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34196514:	2300      	movs	r3, #0
34196516:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
34196518:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
3419651c:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
3419651e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34196522:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
34196524:	230a      	movs	r3, #10
34196526:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
34196528:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3419652c:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419652e:	f107 031c 	add.w	r3, r7, #28
34196532:	f241 3288 	movw	r2, #5000	@ 0x1388
34196536:	4619      	mov	r1, r3
34196538:	6878      	ldr	r0, [r7, #4]
3419653a:	f7fe feb3 	bl	341952a4 <HAL_XSPI_Command>
3419653e:	4603      	mov	r3, r0
34196540:	2b00      	cmp	r3, #0
34196542:	d002      	beq.n	3419654a <MX66UW1G45G_EnableDTRMemoryMappedMode+0x86>
  {
    return MX66UW1G45G_ERROR;
34196544:	f04f 33ff 	mov.w	r3, #4294967295
34196548:	e025      	b.n	34196596 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
3419654a:	2302      	movs	r3, #2
3419654c:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
3419654e:	f241 23ed 	movw	r3, #4845	@ 0x12ed
34196552:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
34196554:	2300      	movs	r3, #0
34196556:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34196558:	2300      	movs	r3, #0
3419655a:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419655c:	f107 031c 	add.w	r3, r7, #28
34196560:	f241 3288 	movw	r2, #5000	@ 0x1388
34196564:	4619      	mov	r1, r3
34196566:	6878      	ldr	r0, [r7, #4]
34196568:	f7fe fe9c 	bl	341952a4 <HAL_XSPI_Command>
3419656c:	4603      	mov	r3, r0
3419656e:	2b00      	cmp	r3, #0
34196570:	d002      	beq.n	34196578 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xb4>
  {
    return MX66UW1G45G_ERROR;
34196572:	f04f 33ff 	mov.w	r3, #4294967295
34196576:	e00e      	b.n	34196596 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }
  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34196578:	2300      	movs	r3, #0
3419657a:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
3419657c:	f107 030c 	add.w	r3, r7, #12
34196580:	4619      	mov	r1, r3
34196582:	6878      	ldr	r0, [r7, #4]
34196584:	f7ff f8be 	bl	34195704 <HAL_XSPI_MemoryMapped>
34196588:	4603      	mov	r3, r0
3419658a:	2b00      	cmp	r3, #0
3419658c:	d002      	beq.n	34196594 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd0>
  {
    return MX66UW1G45G_ERROR;
3419658e:	f04f 33ff 	mov.w	r3, #4294967295
34196592:	e000      	b.n	34196596 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  return MX66UW1G45G_OK;
34196594:	2300      	movs	r3, #0
}
34196596:	4618      	mov	r0, r3
34196598:	3768      	adds	r7, #104	@ 0x68
3419659a:	46bd      	mov	sp, r7
3419659c:	bd80      	pop	{r7, pc}

3419659e <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
3419659e:	b580      	push	{r7, lr}
341965a0:	b09a      	sub	sp, #104	@ 0x68
341965a2:	af00      	add	r7, sp, #0
341965a4:	6078      	str	r0, [r7, #4]
341965a6:	460b      	mov	r3, r1
341965a8:	70fb      	strb	r3, [r7, #3]
341965aa:	4613      	mov	r3, r2
341965ac:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
341965ae:	f107 031c 	add.w	r3, r7, #28
341965b2:	224c      	movs	r2, #76	@ 0x4c
341965b4:	2100      	movs	r1, #0
341965b6:	4618      	mov	r0, r3
341965b8:	f00d fbf4 	bl	341a3da4 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
341965bc:	f107 0308 	add.w	r3, r7, #8
341965c0:	2200      	movs	r2, #0
341965c2:	601a      	str	r2, [r3, #0]
341965c4:	605a      	str	r2, [r3, #4]
341965c6:	609a      	str	r2, [r3, #8]
341965c8:	60da      	str	r2, [r3, #12]
341965ca:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
341965cc:	78fb      	ldrb	r3, [r7, #3]
341965ce:	2b00      	cmp	r3, #0
341965d0:	d105      	bne.n	341965de <MX66UW1G45G_WriteEnable+0x40>
341965d2:	78bb      	ldrb	r3, [r7, #2]
341965d4:	2b01      	cmp	r3, #1
341965d6:	d102      	bne.n	341965de <MX66UW1G45G_WriteEnable+0x40>
  {
    return MX66UW1G45G_ERROR;
341965d8:	f04f 33ff 	mov.w	r3, #4294967295
341965dc:	e0a7      	b.n	3419672e <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Initialize the write enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
341965de:	2300      	movs	r3, #0
341965e0:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
341965e2:	78fb      	ldrb	r3, [r7, #3]
341965e4:	2b00      	cmp	r3, #0
341965e6:	d101      	bne.n	341965ec <MX66UW1G45G_WriteEnable+0x4e>
341965e8:	2301      	movs	r3, #1
341965ea:	e000      	b.n	341965ee <MX66UW1G45G_WriteEnable+0x50>
341965ec:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
341965ee:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341965f0:	78bb      	ldrb	r3, [r7, #2]
341965f2:	2b01      	cmp	r3, #1
341965f4:	d101      	bne.n	341965fa <MX66UW1G45G_WriteEnable+0x5c>
341965f6:	2308      	movs	r3, #8
341965f8:	e000      	b.n	341965fc <MX66UW1G45G_WriteEnable+0x5e>
341965fa:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341965fc:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
341965fe:	78fb      	ldrb	r3, [r7, #3]
34196600:	2b00      	cmp	r3, #0
34196602:	d101      	bne.n	34196608 <MX66UW1G45G_WriteEnable+0x6a>
34196604:	2300      	movs	r3, #0
34196606:	e000      	b.n	3419660a <MX66UW1G45G_WriteEnable+0x6c>
34196608:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
3419660a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_ENABLE_CMD
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
3419660c:	78fb      	ldrb	r3, [r7, #3]
3419660e:	2b00      	cmp	r3, #0
34196610:	d101      	bne.n	34196616 <MX66UW1G45G_WriteEnable+0x78>
34196612:	2306      	movs	r3, #6
34196614:	e001      	b.n	3419661a <MX66UW1G45G_WriteEnable+0x7c>
34196616:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3419661a:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
3419661c:	2300      	movs	r3, #0
3419661e:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34196620:	2300      	movs	r3, #0
34196622:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34196624:	2300      	movs	r3, #0
34196626:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
34196628:	2300      	movs	r3, #0
3419662a:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
3419662c:	2300      	movs	r3, #0
3419662e:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196630:	f107 031c 	add.w	r3, r7, #28
34196634:	f241 3288 	movw	r2, #5000	@ 0x1388
34196638:	4619      	mov	r1, r3
3419663a:	6878      	ldr	r0, [r7, #4]
3419663c:	f7fe fe32 	bl	341952a4 <HAL_XSPI_Command>
34196640:	4603      	mov	r3, r0
34196642:	2b00      	cmp	r3, #0
34196644:	d002      	beq.n	3419664c <MX66UW1G45G_WriteEnable+0xae>
  {
    return MX66UW1G45G_ERROR;
34196646:	f04f 33ff 	mov.w	r3, #4294967295
3419664a:	e070      	b.n	3419672e <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Configure automatic polling mode to wait for write enabling */
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
3419664c:	78fb      	ldrb	r3, [r7, #3]
3419664e:	2b00      	cmp	r3, #0
34196650:	d101      	bne.n	34196656 <MX66UW1G45G_WriteEnable+0xb8>
34196652:	2305      	movs	r3, #5
34196654:	e001      	b.n	3419665a <MX66UW1G45G_WriteEnable+0xbc>
34196656:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3419665a:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
3419665c:	78fb      	ldrb	r3, [r7, #3]
3419665e:	2b00      	cmp	r3, #0
34196660:	d101      	bne.n	34196666 <MX66UW1G45G_WriteEnable+0xc8>
34196662:	2300      	movs	r3, #0
34196664:	e001      	b.n	3419666a <MX66UW1G45G_WriteEnable+0xcc>
34196666:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419666a:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
3419666c:	78bb      	ldrb	r3, [r7, #2]
3419666e:	2b01      	cmp	r3, #1
34196670:	d102      	bne.n	34196678 <MX66UW1G45G_WriteEnable+0xda>
34196672:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34196676:	e000      	b.n	3419667a <MX66UW1G45G_WriteEnable+0xdc>
34196678:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
3419667a:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
3419667c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34196680:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
34196682:	2300      	movs	r3, #0
34196684:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34196686:	78fb      	ldrb	r3, [r7, #3]
34196688:	2b00      	cmp	r3, #0
3419668a:	d102      	bne.n	34196692 <MX66UW1G45G_WriteEnable+0xf4>
3419668c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34196690:	e001      	b.n	34196696 <MX66UW1G45G_WriteEnable+0xf8>
34196692:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34196696:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34196698:	78bb      	ldrb	r3, [r7, #2]
3419669a:	2b01      	cmp	r3, #1
3419669c:	d102      	bne.n	341966a4 <MX66UW1G45G_WriteEnable+0x106>
3419669e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341966a2:	e000      	b.n	341966a6 <MX66UW1G45G_WriteEnable+0x108>
341966a4:	2300      	movs	r3, #0
341966a6:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
341966a8:	78fb      	ldrb	r3, [r7, #3]
341966aa:	2b00      	cmp	r3, #0
341966ac:	d006      	beq.n	341966bc <MX66UW1G45G_WriteEnable+0x11e>
341966ae:	78bb      	ldrb	r3, [r7, #2]
341966b0:	2b01      	cmp	r3, #1
341966b2:	d101      	bne.n	341966b8 <MX66UW1G45G_WriteEnable+0x11a>
341966b4:	2305      	movs	r3, #5
341966b6:	e002      	b.n	341966be <MX66UW1G45G_WriteEnable+0x120>
341966b8:	2304      	movs	r3, #4
341966ba:	e000      	b.n	341966be <MX66UW1G45G_WriteEnable+0x120>
341966bc:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
341966be:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
341966c0:	78bb      	ldrb	r3, [r7, #2]
341966c2:	2b01      	cmp	r3, #1
341966c4:	d101      	bne.n	341966ca <MX66UW1G45G_WriteEnable+0x12c>
341966c6:	2302      	movs	r3, #2
341966c8:	e000      	b.n	341966cc <MX66UW1G45G_WriteEnable+0x12e>
341966ca:	2301      	movs	r3, #1
341966cc:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
341966ce:	78bb      	ldrb	r3, [r7, #2]
341966d0:	2b01      	cmp	r3, #1
341966d2:	d102      	bne.n	341966da <MX66UW1G45G_WriteEnable+0x13c>
341966d4:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341966d8:	e000      	b.n	341966dc <MX66UW1G45G_WriteEnable+0x13e>
341966da:	2300      	movs	r3, #0
341966dc:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341966de:	f107 031c 	add.w	r3, r7, #28
341966e2:	f241 3288 	movw	r2, #5000	@ 0x1388
341966e6:	4619      	mov	r1, r3
341966e8:	6878      	ldr	r0, [r7, #4]
341966ea:	f7fe fddb 	bl	341952a4 <HAL_XSPI_Command>
341966ee:	4603      	mov	r3, r0
341966f0:	2b00      	cmp	r3, #0
341966f2:	d002      	beq.n	341966fa <MX66UW1G45G_WriteEnable+0x15c>
  {
    return MX66UW1G45G_ERROR;
341966f4:	f04f 33ff 	mov.w	r3, #4294967295
341966f8:	e019      	b.n	3419672e <MX66UW1G45G_WriteEnable+0x190>
  }

  s_config.MatchValue = 2U;
341966fa:	2302      	movs	r3, #2
341966fc:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = 2U;
341966fe:	2302      	movs	r3, #2
34196700:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34196702:	2300      	movs	r3, #0
34196704:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
34196706:	2310      	movs	r3, #16
34196708:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
3419670a:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
3419670e:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196710:	f107 0308 	add.w	r3, r7, #8
34196714:	f241 3288 	movw	r2, #5000	@ 0x1388
34196718:	4619      	mov	r1, r3
3419671a:	6878      	ldr	r0, [r7, #4]
3419671c:	f7fe ff68 	bl	341955f0 <HAL_XSPI_AutoPolling>
34196720:	4603      	mov	r3, r0
34196722:	2b00      	cmp	r3, #0
34196724:	d002      	beq.n	3419672c <MX66UW1G45G_WriteEnable+0x18e>
  {
    return MX66UW1G45G_ERROR;
34196726:	f04f 33ff 	mov.w	r3, #4294967295
3419672a:	e000      	b.n	3419672e <MX66UW1G45G_WriteEnable+0x190>
  }

  return MX66UW1G45G_OK;
3419672c:	2300      	movs	r3, #0
}
3419672e:	4618      	mov	r0, r3
34196730:	3768      	adds	r7, #104	@ 0x68
34196732:	46bd      	mov	sp, r7
34196734:	bd80      	pop	{r7, pc}

34196736 <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
34196736:	b580      	push	{r7, lr}
34196738:	b098      	sub	sp, #96	@ 0x60
3419673a:	af00      	add	r7, sp, #0
3419673c:	60f8      	str	r0, [r7, #12]
3419673e:	607b      	str	r3, [r7, #4]
34196740:	460b      	mov	r3, r1
34196742:	72fb      	strb	r3, [r7, #11]
34196744:	4613      	mov	r3, r2
34196746:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
34196748:	f107 0314 	add.w	r3, r7, #20
3419674c:	224c      	movs	r2, #76	@ 0x4c
3419674e:	2100      	movs	r1, #0
34196750:	4618      	mov	r0, r3
34196752:	f00d fb27 	bl	341a3da4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34196756:	7afb      	ldrb	r3, [r7, #11]
34196758:	2b00      	cmp	r3, #0
3419675a:	d105      	bne.n	34196768 <MX66UW1G45G_WriteCfg2Register+0x32>
3419675c:	7abb      	ldrb	r3, [r7, #10]
3419675e:	2b01      	cmp	r3, #1
34196760:	d102      	bne.n	34196768 <MX66UW1G45G_WriteCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
34196762:	f04f 33ff 	mov.w	r3, #4294967295
34196766:	e073      	b.n	34196850 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  /* Initialize the writing of configuration register 2 */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34196768:	2300      	movs	r3, #0
3419676a:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
3419676c:	7afb      	ldrb	r3, [r7, #11]
3419676e:	2b00      	cmp	r3, #0
34196770:	d101      	bne.n	34196776 <MX66UW1G45G_WriteCfg2Register+0x40>
34196772:	2301      	movs	r3, #1
34196774:	e000      	b.n	34196778 <MX66UW1G45G_WriteCfg2Register+0x42>
34196776:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34196778:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3419677a:	7abb      	ldrb	r3, [r7, #10]
3419677c:	2b01      	cmp	r3, #1
3419677e:	d101      	bne.n	34196784 <MX66UW1G45G_WriteCfg2Register+0x4e>
34196780:	2308      	movs	r3, #8
34196782:	e000      	b.n	34196786 <MX66UW1G45G_WriteCfg2Register+0x50>
34196784:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34196786:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34196788:	7afb      	ldrb	r3, [r7, #11]
3419678a:	2b00      	cmp	r3, #0
3419678c:	d101      	bne.n	34196792 <MX66UW1G45G_WriteCfg2Register+0x5c>
3419678e:	2300      	movs	r3, #0
34196790:	e000      	b.n	34196794 <MX66UW1G45G_WriteCfg2Register+0x5e>
34196792:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34196794:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_WRITE_CFG_REG2_CMD;
34196796:	7afb      	ldrb	r3, [r7, #11]
34196798:	2b00      	cmp	r3, #0
3419679a:	d101      	bne.n	341967a0 <MX66UW1G45G_WriteCfg2Register+0x6a>
3419679c:	2372      	movs	r3, #114	@ 0x72
3419679e:	e001      	b.n	341967a4 <MX66UW1G45G_WriteCfg2Register+0x6e>
341967a0:	f247 238d 	movw	r3, #29325	@ 0x728d
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341967a4:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
341967a6:	7afb      	ldrb	r3, [r7, #11]
341967a8:	2b00      	cmp	r3, #0
341967aa:	d102      	bne.n	341967b2 <MX66UW1G45G_WriteCfg2Register+0x7c>
341967ac:	f44f 7380 	mov.w	r3, #256	@ 0x100
341967b0:	e001      	b.n	341967b6 <MX66UW1G45G_WriteCfg2Register+0x80>
341967b2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341967b6:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
341967b8:	7abb      	ldrb	r3, [r7, #10]
341967ba:	2b01      	cmp	r3, #1
341967bc:	d102      	bne.n	341967c4 <MX66UW1G45G_WriteCfg2Register+0x8e>
341967be:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341967c2:	e000      	b.n	341967c6 <MX66UW1G45G_WriteCfg2Register+0x90>
341967c4:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341967c6:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341967c8:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341967cc:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = WriteAddr;
341967ce:	687b      	ldr	r3, [r7, #4]
341967d0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341967d2:	2300      	movs	r3, #0
341967d4:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
341967d6:	7afb      	ldrb	r3, [r7, #11]
341967d8:	2b00      	cmp	r3, #0
341967da:	d102      	bne.n	341967e2 <MX66UW1G45G_WriteCfg2Register+0xac>
341967dc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341967e0:	e001      	b.n	341967e6 <MX66UW1G45G_WriteCfg2Register+0xb0>
341967e2:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341967e6:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
341967e8:	7abb      	ldrb	r3, [r7, #10]
341967ea:	2b01      	cmp	r3, #1
341967ec:	d102      	bne.n	341967f4 <MX66UW1G45G_WriteCfg2Register+0xbe>
341967ee:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341967f2:	e000      	b.n	341967f6 <MX66UW1G45G_WriteCfg2Register+0xc0>
341967f4:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341967f6:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
341967f8:	2300      	movs	r3, #0
341967fa:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
341967fc:	7afb      	ldrb	r3, [r7, #11]
341967fe:	2b00      	cmp	r3, #0
34196800:	d006      	beq.n	34196810 <MX66UW1G45G_WriteCfg2Register+0xda>
34196802:	7abb      	ldrb	r3, [r7, #10]
34196804:	2b01      	cmp	r3, #1
34196806:	d101      	bne.n	3419680c <MX66UW1G45G_WriteCfg2Register+0xd6>
34196808:	2302      	movs	r3, #2
3419680a:	e002      	b.n	34196812 <MX66UW1G45G_WriteCfg2Register+0xdc>
3419680c:	2301      	movs	r3, #1
3419680e:	e000      	b.n	34196812 <MX66UW1G45G_WriteCfg2Register+0xdc>
34196810:	2301      	movs	r3, #1
34196812:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34196814:	2300      	movs	r3, #0
34196816:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196818:	f107 0314 	add.w	r3, r7, #20
3419681c:	f241 3288 	movw	r2, #5000	@ 0x1388
34196820:	4619      	mov	r1, r3
34196822:	68f8      	ldr	r0, [r7, #12]
34196824:	f7fe fd3e 	bl	341952a4 <HAL_XSPI_Command>
34196828:	4603      	mov	r3, r0
3419682a:	2b00      	cmp	r3, #0
3419682c:	d002      	beq.n	34196834 <MX66UW1G45G_WriteCfg2Register+0xfe>
  {
    return MX66UW1G45G_ERROR;
3419682e:	f04f 33ff 	mov.w	r3, #4294967295
34196832:	e00d      	b.n	34196850 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196834:	f241 3288 	movw	r2, #5000	@ 0x1388
34196838:	f107 0168 	add.w	r1, r7, #104	@ 0x68
3419683c:	68f8      	ldr	r0, [r7, #12]
3419683e:	f7fe fdc1 	bl	341953c4 <HAL_XSPI_Transmit>
34196842:	4603      	mov	r3, r0
34196844:	2b00      	cmp	r3, #0
34196846:	d002      	beq.n	3419684e <MX66UW1G45G_WriteCfg2Register+0x118>
  {
    return MX66UW1G45G_ERROR;
34196848:	f04f 33ff 	mov.w	r3, #4294967295
3419684c:	e000      	b.n	34196850 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  return MX66UW1G45G_OK;
3419684e:	2300      	movs	r3, #0
}
34196850:	4618      	mov	r0, r3
34196852:	3760      	adds	r7, #96	@ 0x60
34196854:	46bd      	mov	sp, r7
34196856:	bd80      	pop	{r7, pc}

34196858 <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34196858:	b580      	push	{r7, lr}
3419685a:	b098      	sub	sp, #96	@ 0x60
3419685c:	af00      	add	r7, sp, #0
3419685e:	60f8      	str	r0, [r7, #12]
34196860:	607b      	str	r3, [r7, #4]
34196862:	460b      	mov	r3, r1
34196864:	72fb      	strb	r3, [r7, #11]
34196866:	4613      	mov	r3, r2
34196868:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
3419686a:	f107 0314 	add.w	r3, r7, #20
3419686e:	224c      	movs	r2, #76	@ 0x4c
34196870:	2100      	movs	r1, #0
34196872:	4618      	mov	r0, r3
34196874:	f00d fa96 	bl	341a3da4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34196878:	7afb      	ldrb	r3, [r7, #11]
3419687a:	2b00      	cmp	r3, #0
3419687c:	d105      	bne.n	3419688a <MX66UW1G45G_ReadCfg2Register+0x32>
3419687e:	7abb      	ldrb	r3, [r7, #10]
34196880:	2b01      	cmp	r3, #1
34196882:	d102      	bne.n	3419688a <MX66UW1G45G_ReadCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
34196884:	f04f 33ff 	mov.w	r3, #4294967295
34196888:	e07d      	b.n	34196986 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Initialize the reading of status register */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
3419688a:	2300      	movs	r3, #0
3419688c:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
3419688e:	7afb      	ldrb	r3, [r7, #11]
34196890:	2b00      	cmp	r3, #0
34196892:	d101      	bne.n	34196898 <MX66UW1G45G_ReadCfg2Register+0x40>
34196894:	2301      	movs	r3, #1
34196896:	e000      	b.n	3419689a <MX66UW1G45G_ReadCfg2Register+0x42>
34196898:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
3419689a:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3419689c:	7abb      	ldrb	r3, [r7, #10]
3419689e:	2b01      	cmp	r3, #1
341968a0:	d101      	bne.n	341968a6 <MX66UW1G45G_ReadCfg2Register+0x4e>
341968a2:	2308      	movs	r3, #8
341968a4:	e000      	b.n	341968a8 <MX66UW1G45G_ReadCfg2Register+0x50>
341968a6:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341968a8:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
341968aa:	7afb      	ldrb	r3, [r7, #11]
341968ac:	2b00      	cmp	r3, #0
341968ae:	d101      	bne.n	341968b4 <MX66UW1G45G_ReadCfg2Register+0x5c>
341968b0:	2300      	movs	r3, #0
341968b2:	e000      	b.n	341968b6 <MX66UW1G45G_ReadCfg2Register+0x5e>
341968b4:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
341968b6:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_READ_CFG_REG2_CMD;
341968b8:	7afb      	ldrb	r3, [r7, #11]
341968ba:	2b00      	cmp	r3, #0
341968bc:	d101      	bne.n	341968c2 <MX66UW1G45G_ReadCfg2Register+0x6a>
341968be:	2371      	movs	r3, #113	@ 0x71
341968c0:	e001      	b.n	341968c6 <MX66UW1G45G_ReadCfg2Register+0x6e>
341968c2:	f247 138e 	movw	r3, #29070	@ 0x718e
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341968c6:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
341968c8:	7afb      	ldrb	r3, [r7, #11]
341968ca:	2b00      	cmp	r3, #0
341968cc:	d102      	bne.n	341968d4 <MX66UW1G45G_ReadCfg2Register+0x7c>
341968ce:	f44f 7380 	mov.w	r3, #256	@ 0x100
341968d2:	e001      	b.n	341968d8 <MX66UW1G45G_ReadCfg2Register+0x80>
341968d4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341968d8:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
341968da:	7abb      	ldrb	r3, [r7, #10]
341968dc:	2b01      	cmp	r3, #1
341968de:	d102      	bne.n	341968e6 <MX66UW1G45G_ReadCfg2Register+0x8e>
341968e0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341968e4:	e000      	b.n	341968e8 <MX66UW1G45G_ReadCfg2Register+0x90>
341968e6:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341968e8:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341968ea:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341968ee:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = ReadAddr;
341968f0:	687b      	ldr	r3, [r7, #4]
341968f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341968f4:	2300      	movs	r3, #0
341968f6:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
341968f8:	7afb      	ldrb	r3, [r7, #11]
341968fa:	2b00      	cmp	r3, #0
341968fc:	d102      	bne.n	34196904 <MX66UW1G45G_ReadCfg2Register+0xac>
341968fe:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34196902:	e001      	b.n	34196908 <MX66UW1G45G_ReadCfg2Register+0xb0>
34196904:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34196908:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
3419690a:	7abb      	ldrb	r3, [r7, #10]
3419690c:	2b01      	cmp	r3, #1
3419690e:	d102      	bne.n	34196916 <MX66UW1G45G_ReadCfg2Register+0xbe>
34196910:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34196914:	e000      	b.n	34196918 <MX66UW1G45G_ReadCfg2Register+0xc0>
34196916:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34196918:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
3419691a:	7afb      	ldrb	r3, [r7, #11]
3419691c:	2b00      	cmp	r3, #0
3419691e:	d006      	beq.n	3419692e <MX66UW1G45G_ReadCfg2Register+0xd6>
34196920:	7abb      	ldrb	r3, [r7, #10]
34196922:	2b01      	cmp	r3, #1
34196924:	d101      	bne.n	3419692a <MX66UW1G45G_ReadCfg2Register+0xd2>
34196926:	2305      	movs	r3, #5
34196928:	e002      	b.n	34196930 <MX66UW1G45G_ReadCfg2Register+0xd8>
3419692a:	2304      	movs	r3, #4
3419692c:	e000      	b.n	34196930 <MX66UW1G45G_ReadCfg2Register+0xd8>
3419692e:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34196930:	65bb      	str	r3, [r7, #88]	@ 0x58
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34196932:	7abb      	ldrb	r3, [r7, #10]
34196934:	2b01      	cmp	r3, #1
34196936:	d101      	bne.n	3419693c <MX66UW1G45G_ReadCfg2Register+0xe4>
34196938:	2302      	movs	r3, #2
3419693a:	e000      	b.n	3419693e <MX66UW1G45G_ReadCfg2Register+0xe6>
3419693c:	2301      	movs	r3, #1
3419693e:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34196940:	7abb      	ldrb	r3, [r7, #10]
34196942:	2b01      	cmp	r3, #1
34196944:	d102      	bne.n	3419694c <MX66UW1G45G_ReadCfg2Register+0xf4>
34196946:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3419694a:	e000      	b.n	3419694e <MX66UW1G45G_ReadCfg2Register+0xf6>
3419694c:	2300      	movs	r3, #0
3419694e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196950:	f107 0314 	add.w	r3, r7, #20
34196954:	f241 3288 	movw	r2, #5000	@ 0x1388
34196958:	4619      	mov	r1, r3
3419695a:	68f8      	ldr	r0, [r7, #12]
3419695c:	f7fe fca2 	bl	341952a4 <HAL_XSPI_Command>
34196960:	4603      	mov	r3, r0
34196962:	2b00      	cmp	r3, #0
34196964:	d002      	beq.n	3419696c <MX66UW1G45G_ReadCfg2Register+0x114>
  {
    return MX66UW1G45G_ERROR;
34196966:	f04f 33ff 	mov.w	r3, #4294967295
3419696a:	e00c      	b.n	34196986 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Reception of the data */
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419696c:	f241 3288 	movw	r2, #5000	@ 0x1388
34196970:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
34196972:	68f8      	ldr	r0, [r7, #12]
34196974:	f7fe fd99 	bl	341954aa <HAL_XSPI_Receive>
34196978:	4603      	mov	r3, r0
3419697a:	2b00      	cmp	r3, #0
3419697c:	d002      	beq.n	34196984 <MX66UW1G45G_ReadCfg2Register+0x12c>
  {
    return MX66UW1G45G_ERROR;
3419697e:	f04f 33ff 	mov.w	r3, #4294967295
34196982:	e000      	b.n	34196986 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  return MX66UW1G45G_OK;
34196984:	2300      	movs	r3, #0
}
34196986:	4618      	mov	r0, r3
34196988:	3760      	adds	r7, #96	@ 0x60
3419698a:	46bd      	mov	sp, r7
3419698c:	bd80      	pop	{r7, pc}

3419698e <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
3419698e:	b580      	push	{r7, lr}
34196990:	b096      	sub	sp, #88	@ 0x58
34196992:	af00      	add	r7, sp, #0
34196994:	6078      	str	r0, [r7, #4]
34196996:	460b      	mov	r3, r1
34196998:	70fb      	strb	r3, [r7, #3]
3419699a:	4613      	mov	r3, r2
3419699c:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
3419699e:	f107 030c 	add.w	r3, r7, #12
341969a2:	224c      	movs	r2, #76	@ 0x4c
341969a4:	2100      	movs	r1, #0
341969a6:	4618      	mov	r0, r3
341969a8:	f00d f9fc 	bl	341a3da4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
341969ac:	78fb      	ldrb	r3, [r7, #3]
341969ae:	2b00      	cmp	r3, #0
341969b0:	d105      	bne.n	341969be <MX66UW1G45G_ResetEnable+0x30>
341969b2:	78bb      	ldrb	r3, [r7, #2]
341969b4:	2b01      	cmp	r3, #1
341969b6:	d102      	bne.n	341969be <MX66UW1G45G_ResetEnable+0x30>
  {
    return MX66UW1G45G_ERROR;
341969b8:	f04f 33ff 	mov.w	r3, #4294967295
341969bc:	e039      	b.n	34196a32 <MX66UW1G45G_ResetEnable+0xa4>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
341969be:	2300      	movs	r3, #0
341969c0:	60fb      	str	r3, [r7, #12]
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
341969c2:	2300      	movs	r3, #0
341969c4:	613b      	str	r3, [r7, #16]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
341969c6:	78fb      	ldrb	r3, [r7, #3]
341969c8:	2b00      	cmp	r3, #0
341969ca:	d101      	bne.n	341969d0 <MX66UW1G45G_ResetEnable+0x42>
341969cc:	2301      	movs	r3, #1
341969ce:	e000      	b.n	341969d2 <MX66UW1G45G_ResetEnable+0x44>
341969d0:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
341969d2:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341969d4:	78bb      	ldrb	r3, [r7, #2]
341969d6:	2b01      	cmp	r3, #1
341969d8:	d101      	bne.n	341969de <MX66UW1G45G_ResetEnable+0x50>
341969da:	2308      	movs	r3, #8
341969dc:	e000      	b.n	341969e0 <MX66UW1G45G_ResetEnable+0x52>
341969de:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
341969e0:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
341969e2:	78fb      	ldrb	r3, [r7, #3]
341969e4:	2b00      	cmp	r3, #0
341969e6:	d101      	bne.n	341969ec <MX66UW1G45G_ResetEnable+0x5e>
341969e8:	2300      	movs	r3, #0
341969ea:	e000      	b.n	341969ee <MX66UW1G45G_ResetEnable+0x60>
341969ec:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
341969ee:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
341969f0:	78fb      	ldrb	r3, [r7, #3]
341969f2:	2b00      	cmp	r3, #0
341969f4:	d101      	bne.n	341969fa <MX66UW1G45G_ResetEnable+0x6c>
341969f6:	2366      	movs	r3, #102	@ 0x66
341969f8:	e001      	b.n	341969fe <MX66UW1G45G_ResetEnable+0x70>
341969fa:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341969fe:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34196a00:	2300      	movs	r3, #0
34196a02:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34196a04:	2300      	movs	r3, #0
34196a06:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34196a08:	2300      	movs	r3, #0
34196a0a:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34196a0c:	2300      	movs	r3, #0
34196a0e:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34196a10:	2300      	movs	r3, #0
34196a12:	657b      	str	r3, [r7, #84]	@ 0x54


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196a14:	f107 030c 	add.w	r3, r7, #12
34196a18:	f241 3288 	movw	r2, #5000	@ 0x1388
34196a1c:	4619      	mov	r1, r3
34196a1e:	6878      	ldr	r0, [r7, #4]
34196a20:	f7fe fc40 	bl	341952a4 <HAL_XSPI_Command>
34196a24:	4603      	mov	r3, r0
34196a26:	2b00      	cmp	r3, #0
34196a28:	d002      	beq.n	34196a30 <MX66UW1G45G_ResetEnable+0xa2>
  {
    return MX66UW1G45G_ERROR;
34196a2a:	f04f 33ff 	mov.w	r3, #4294967295
34196a2e:	e000      	b.n	34196a32 <MX66UW1G45G_ResetEnable+0xa4>
  }

  return MX66UW1G45G_OK;
34196a30:	2300      	movs	r3, #0
}
34196a32:	4618      	mov	r0, r3
34196a34:	3758      	adds	r7, #88	@ 0x58
34196a36:	46bd      	mov	sp, r7
34196a38:	bd80      	pop	{r7, pc}

34196a3a <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34196a3a:	b580      	push	{r7, lr}
34196a3c:	b096      	sub	sp, #88	@ 0x58
34196a3e:	af00      	add	r7, sp, #0
34196a40:	6078      	str	r0, [r7, #4]
34196a42:	460b      	mov	r3, r1
34196a44:	70fb      	strb	r3, [r7, #3]
34196a46:	4613      	mov	r3, r2
34196a48:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34196a4a:	f107 030c 	add.w	r3, r7, #12
34196a4e:	224c      	movs	r2, #76	@ 0x4c
34196a50:	2100      	movs	r1, #0
34196a52:	4618      	mov	r0, r3
34196a54:	f00d f9a6 	bl	341a3da4 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34196a58:	78fb      	ldrb	r3, [r7, #3]
34196a5a:	2b00      	cmp	r3, #0
34196a5c:	d105      	bne.n	34196a6a <MX66UW1G45G_ResetMemory+0x30>
34196a5e:	78bb      	ldrb	r3, [r7, #2]
34196a60:	2b01      	cmp	r3, #1
34196a62:	d102      	bne.n	34196a6a <MX66UW1G45G_ResetMemory+0x30>
  {
    return MX66UW1G45G_ERROR;
34196a64:	f04f 33ff 	mov.w	r3, #4294967295
34196a68:	e037      	b.n	34196ada <MX66UW1G45G_ResetMemory+0xa0>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34196a6a:	2300      	movs	r3, #0
34196a6c:	60fb      	str	r3, [r7, #12]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34196a6e:	78fb      	ldrb	r3, [r7, #3]
34196a70:	2b00      	cmp	r3, #0
34196a72:	d101      	bne.n	34196a78 <MX66UW1G45G_ResetMemory+0x3e>
34196a74:	2301      	movs	r3, #1
34196a76:	e000      	b.n	34196a7a <MX66UW1G45G_ResetMemory+0x40>
34196a78:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34196a7a:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34196a7c:	78bb      	ldrb	r3, [r7, #2]
34196a7e:	2b01      	cmp	r3, #1
34196a80:	d101      	bne.n	34196a86 <MX66UW1G45G_ResetMemory+0x4c>
34196a82:	2308      	movs	r3, #8
34196a84:	e000      	b.n	34196a88 <MX66UW1G45G_ResetMemory+0x4e>
34196a86:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34196a88:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34196a8a:	78fb      	ldrb	r3, [r7, #3]
34196a8c:	2b00      	cmp	r3, #0
34196a8e:	d101      	bne.n	34196a94 <MX66UW1G45G_ResetMemory+0x5a>
34196a90:	2300      	movs	r3, #0
34196a92:	e000      	b.n	34196a96 <MX66UW1G45G_ResetMemory+0x5c>
34196a94:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34196a96:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34196a98:	78fb      	ldrb	r3, [r7, #3]
34196a9a:	2b00      	cmp	r3, #0
34196a9c:	d101      	bne.n	34196aa2 <MX66UW1G45G_ResetMemory+0x68>
34196a9e:	2399      	movs	r3, #153	@ 0x99
34196aa0:	e001      	b.n	34196aa6 <MX66UW1G45G_ResetMemory+0x6c>
34196aa2:	f649 1366 	movw	r3, #39270	@ 0x9966
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34196aa6:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34196aa8:	2300      	movs	r3, #0
34196aaa:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34196aac:	2300      	movs	r3, #0
34196aae:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34196ab0:	2300      	movs	r3, #0
34196ab2:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34196ab4:	2300      	movs	r3, #0
34196ab6:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34196ab8:	2300      	movs	r3, #0
34196aba:	657b      	str	r3, [r7, #84]	@ 0x54
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34196abc:	f107 030c 	add.w	r3, r7, #12
34196ac0:	f241 3288 	movw	r2, #5000	@ 0x1388
34196ac4:	4619      	mov	r1, r3
34196ac6:	6878      	ldr	r0, [r7, #4]
34196ac8:	f7fe fbec 	bl	341952a4 <HAL_XSPI_Command>
34196acc:	4603      	mov	r3, r0
34196ace:	2b00      	cmp	r3, #0
34196ad0:	d002      	beq.n	34196ad8 <MX66UW1G45G_ResetMemory+0x9e>
  {
    return MX66UW1G45G_ERROR;
34196ad2:	f04f 33ff 	mov.w	r3, #4294967295
34196ad6:	e000      	b.n	34196ada <MX66UW1G45G_ResetMemory+0xa0>
  }

  return MX66UW1G45G_OK;
34196ad8:	2300      	movs	r3, #0
}
34196ada:	4618      	mov	r0, r3
34196adc:	3758      	adds	r7, #88	@ 0x58
34196ade:	46bd      	mov	sp, r7
34196ae0:	bd80      	pop	{r7, pc}

34196ae2 <ISP_Algo_BadPixel_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
34196ae2:	b480      	push	{r7}
34196ae4:	b083      	sub	sp, #12
34196ae6:	af00      	add	r7, sp, #0
34196ae8:	6078      	str	r0, [r7, #4]
34196aea:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
34196aec:	683b      	ldr	r3, [r7, #0]
34196aee:	2200      	movs	r2, #0
34196af0:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34196af2:	2300      	movs	r3, #0
}
34196af4:	4618      	mov	r0, r3
34196af6:	370c      	adds	r7, #12
34196af8:	46bd      	mov	sp, r7
34196afa:	f85d 7b04 	ldr.w	r7, [sp], #4
34196afe:	4770      	bx	lr

34196b00 <ISP_Algo_BadPixel_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_DeInit(void *hIsp, void *pAlgo)
{
34196b00:	b480      	push	{r7}
34196b02:	b083      	sub	sp, #12
34196b04:	af00      	add	r7, sp, #0
34196b06:	6078      	str	r0, [r7, #4]
34196b08:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
34196b0a:	2300      	movs	r3, #0
}
34196b0c:	4618      	mov	r0, r3
34196b0e:	370c      	adds	r7, #12
34196b10:	46bd      	mov	sp, r7
34196b12:	f85d 7b04 	ldr.w	r7, [sp], #4
34196b16:	4770      	bx	lr

34196b18 <ISP_Algo_BadPixel_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Process(void *hIsp, void *pAlgo)
{
34196b18:	b580      	push	{r7, lr}
34196b1a:	b088      	sub	sp, #32
34196b1c:	af00      	add	r7, sp, #0
34196b1e:	6078      	str	r0, [r7, #4]
34196b20:	6039      	str	r1, [r7, #0]
  uint32_t CurrentFrameId;
  ISP_BadPixelTypeDef BadPixelConfig;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34196b22:	6878      	ldr	r0, [r7, #4]
34196b24:	f002 ff0c 	bl	34199940 <ISP_SVC_IQParam_Get>
34196b28:	61f8      	str	r0, [r7, #28]

  if (IQParamConfig->badPixelAlgo.enable == false)
34196b2a:	69fb      	ldr	r3, [r7, #28]
34196b2c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34196b30:	2b00      	cmp	r3, #0
34196b32:	d101      	bne.n	34196b38 <ISP_Algo_BadPixel_Process+0x20>
  {
    return ISP_OK;
34196b34:	2300      	movs	r3, #0
34196b36:	e069      	b.n	34196c0c <ISP_Algo_BadPixel_Process+0xf4>
  }

  /* Wait for a new frame */
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
34196b38:	6878      	ldr	r0, [r7, #4]
34196b3a:	f002 fe3c 	bl	341997b6 <ISP_SVC_Misc_GetMainFrameId>
34196b3e:	61b8      	str	r0, [r7, #24]
  if (CurrentFrameId == LastFrameId)
34196b40:	4b34      	ldr	r3, [pc, #208]	@ (34196c14 <ISP_Algo_BadPixel_Process+0xfc>)
34196b42:	681b      	ldr	r3, [r3, #0]
34196b44:	69ba      	ldr	r2, [r7, #24]
34196b46:	429a      	cmp	r2, r3
34196b48:	d101      	bne.n	34196b4e <ISP_Algo_BadPixel_Process+0x36>
  {
    return ISP_OK;
34196b4a:	2300      	movs	r3, #0
34196b4c:	e05e      	b.n	34196c0c <ISP_Algo_BadPixel_Process+0xf4>
  }
  LastFrameId = CurrentFrameId;
34196b4e:	4a31      	ldr	r2, [pc, #196]	@ (34196c14 <ISP_Algo_BadPixel_Process+0xfc>)
34196b50:	69bb      	ldr	r3, [r7, #24]
34196b52:	6013      	str	r3, [r2, #0]

  if (Step++ >= 0)
34196b54:	4b30      	ldr	r3, [pc, #192]	@ (34196c18 <ISP_Algo_BadPixel_Process+0x100>)
34196b56:	f993 3000 	ldrsb.w	r3, [r3]
34196b5a:	b2da      	uxtb	r2, r3
34196b5c:	3201      	adds	r2, #1
34196b5e:	b2d2      	uxtb	r2, r2
34196b60:	b251      	sxtb	r1, r2
34196b62:	4a2d      	ldr	r2, [pc, #180]	@ (34196c18 <ISP_Algo_BadPixel_Process+0x100>)
34196b64:	7011      	strb	r1, [r2, #0]
34196b66:	2b00      	cmp	r3, #0
34196b68:	db12      	blt.n	34196b90 <ISP_Algo_BadPixel_Process+0x78>
  {
    /* Measure the number of bad pixels */
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
34196b6a:	f107 030c 	add.w	r3, r7, #12
34196b6e:	4619      	mov	r1, r3
34196b70:	6878      	ldr	r0, [r7, #4]
34196b72:	f002 face 	bl	34199112 <ISP_SVC_ISP_GetBadPixel>
34196b76:	4603      	mov	r3, r0
34196b78:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
34196b7a:	7dfb      	ldrb	r3, [r7, #23]
34196b7c:	2b00      	cmp	r3, #0
34196b7e:	d001      	beq.n	34196b84 <ISP_Algo_BadPixel_Process+0x6c>
    {
      return ret;
34196b80:	7dfb      	ldrb	r3, [r7, #23]
34196b82:	e043      	b.n	34196c0c <ISP_Algo_BadPixel_Process+0xf4>
    }
    BadPixelCount += BadPixelConfig.count;
34196b84:	693a      	ldr	r2, [r7, #16]
34196b86:	4b25      	ldr	r3, [pc, #148]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196b88:	681b      	ldr	r3, [r3, #0]
34196b8a:	4413      	add	r3, r2
34196b8c:	4a23      	ldr	r2, [pc, #140]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196b8e:	6013      	str	r3, [r2, #0]
  }

  if (Step == 10)
34196b90:	4b21      	ldr	r3, [pc, #132]	@ (34196c18 <ISP_Algo_BadPixel_Process+0x100>)
34196b92:	f993 3000 	ldrsb.w	r3, [r3]
34196b96:	2b0a      	cmp	r3, #10
34196b98:	d137      	bne.n	34196c0a <ISP_Algo_BadPixel_Process+0xf2>
  {
    /* All measures done : make an average and compare with threshold */
    BadPixelCount /= 10;
34196b9a:	4b20      	ldr	r3, [pc, #128]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196b9c:	681b      	ldr	r3, [r3, #0]
34196b9e:	4a20      	ldr	r2, [pc, #128]	@ (34196c20 <ISP_Algo_BadPixel_Process+0x108>)
34196ba0:	fba2 2303 	umull	r2, r3, r2, r3
34196ba4:	08db      	lsrs	r3, r3, #3
34196ba6:	4a1d      	ldr	r2, [pc, #116]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196ba8:	6013      	str	r3, [r2, #0]

    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34196baa:	69fb      	ldr	r3, [r7, #28]
34196bac:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
34196bae:	4b1b      	ldr	r3, [pc, #108]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196bb0:	681b      	ldr	r3, [r3, #0]
34196bb2:	429a      	cmp	r2, r3
34196bb4:	d207      	bcs.n	34196bc6 <ISP_Algo_BadPixel_Process+0xae>
34196bb6:	7b7b      	ldrb	r3, [r7, #13]
34196bb8:	2b00      	cmp	r3, #0
34196bba:	d004      	beq.n	34196bc6 <ISP_Algo_BadPixel_Process+0xae>
    {
      /* Bad pixel is above target : decrease strength */
      BadPixelConfig.strength--;
34196bbc:	7b7b      	ldrb	r3, [r7, #13]
34196bbe:	3b01      	subs	r3, #1
34196bc0:	b2db      	uxtb	r3, r3
34196bc2:	737b      	strb	r3, [r7, #13]
34196bc4:	e00c      	b.n	34196be0 <ISP_Algo_BadPixel_Process+0xc8>
    }
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
34196bc6:	69fb      	ldr	r3, [r7, #28]
34196bc8:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
34196bca:	4b14      	ldr	r3, [pc, #80]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196bcc:	681b      	ldr	r3, [r3, #0]
34196bce:	429a      	cmp	r2, r3
34196bd0:	d906      	bls.n	34196be0 <ISP_Algo_BadPixel_Process+0xc8>
34196bd2:	7b7b      	ldrb	r3, [r7, #13]
34196bd4:	2b05      	cmp	r3, #5
34196bd6:	d803      	bhi.n	34196be0 <ISP_Algo_BadPixel_Process+0xc8>
    {
      /* Bad pixel is below target : increase strength. (exclude ISP_BADPIXEL_STRENGTH_MAX which gives weird results) */
      BadPixelConfig.strength++;
34196bd8:	7b7b      	ldrb	r3, [r7, #13]
34196bda:	3301      	adds	r3, #1
34196bdc:	b2db      	uxtb	r3, r3
34196bde:	737b      	strb	r3, [r7, #13]
    }

    /* Set updated Strength */
    BadPixelConfig.enable = 1;
34196be0:	2301      	movs	r3, #1
34196be2:	733b      	strb	r3, [r7, #12]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34196be4:	f107 030c 	add.w	r3, r7, #12
34196be8:	4619      	mov	r1, r3
34196bea:	6878      	ldr	r0, [r7, #4]
34196bec:	f002 fa52 	bl	34199094 <ISP_SVC_ISP_SetBadPixel>
34196bf0:	4603      	mov	r3, r0
34196bf2:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
34196bf4:	7dfb      	ldrb	r3, [r7, #23]
34196bf6:	2b00      	cmp	r3, #0
34196bf8:	d001      	beq.n	34196bfe <ISP_Algo_BadPixel_Process+0xe6>
    {
      return ret;
34196bfa:	7dfb      	ldrb	r3, [r7, #23]
34196bfc:	e006      	b.n	34196c0c <ISP_Algo_BadPixel_Process+0xf4>
    }

    /* Set Step to -1 to wait for an extra frame before a new measurement (the ISP HW needs one frame to update after reconfig) */
    Step = -1;
34196bfe:	4b06      	ldr	r3, [pc, #24]	@ (34196c18 <ISP_Algo_BadPixel_Process+0x100>)
34196c00:	22ff      	movs	r2, #255	@ 0xff
34196c02:	701a      	strb	r2, [r3, #0]
    BadPixelCount = 0;
34196c04:	4b05      	ldr	r3, [pc, #20]	@ (34196c1c <ISP_Algo_BadPixel_Process+0x104>)
34196c06:	2200      	movs	r2, #0
34196c08:	601a      	str	r2, [r3, #0]
  }

  return ISP_OK;
34196c0a:	2300      	movs	r3, #0
}
34196c0c:	4618      	mov	r0, r3
34196c0e:	3720      	adds	r7, #32
34196c10:	46bd      	mov	sp, r7
34196c12:	bd80      	pop	{r7, pc}
34196c14:	341c11c4 	.word	0x341c11c4
34196c18:	341c11c8 	.word	0x341c11c8
34196c1c:	341c11cc 	.word	0x341c11cc
34196c20:	cccccccd 	.word	0xcccccccd

34196c24 <log_cb>:

#if defined(ISP_MW_SW_AEC_ALGO_SUPPORT) || defined(ISP_MW_SW_AWB_ALGO_SUPPORT)
static void log_cb(const char *const msg)
{
34196c24:	b580      	push	{r7, lr}
34196c26:	b082      	sub	sp, #8
34196c28:	af00      	add	r7, sp, #0
34196c2a:	6078      	str	r0, [r7, #4]
  printf("%s", msg);
34196c2c:	6879      	ldr	r1, [r7, #4]
34196c2e:	4805      	ldr	r0, [pc, #20]	@ (34196c44 <log_cb+0x20>)
34196c30:	f00c ff20 	bl	341a3a74 <iprintf>
  printf("\r\n");
34196c34:	4804      	ldr	r0, [pc, #16]	@ (34196c48 <log_cb+0x24>)
34196c36:	f00c ff85 	bl	341a3b44 <puts>
}
34196c3a:	bf00      	nop
34196c3c:	3708      	adds	r7, #8
34196c3e:	46bd      	mov	sp, r7
34196c40:	bd80      	pop	{r7, pc}
34196c42:	bf00      	nop
34196c44:	341a5cc8 	.word	0x341a5cc8
34196c48:	341a5ccc 	.word	0x341a5ccc
34196c4c:	00000000 	.word	0x00000000

34196c50 <ISP_Algo_AEC_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Init(void *hIsp, void *pAlgo)
{
34196c50:	b580      	push	{r7, lr}
34196c52:	b088      	sub	sp, #32
34196c54:	af00      	add	r7, sp, #0
34196c56:	6078      	str	r0, [r7, #4]
34196c58:	6039      	str	r1, [r7, #0]
  ISP_HandleTypeDef *pIsp_handle = (ISP_HandleTypeDef*) hIsp;
34196c5a:	687b      	ldr	r3, [r7, #4]
34196c5c:	61fb      	str	r3, [r7, #28]
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34196c5e:	683b      	ldr	r3, [r7, #0]
34196c60:	61bb      	str	r3, [r7, #24]
  ISP_SensorExposureTypeDef exposureConfig;
  ISP_SensorGainTypeDef gainConfig;
  ISP_IQParamTypeDef *IQParamConfig;
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34196c62:	6878      	ldr	r0, [r7, #4]
34196c64:	f002 fe6c 	bl	34199940 <ISP_SVC_IQParam_Get>
34196c68:	6178      	str	r0, [r7, #20]

  if (IQParamConfig->sensorDelay.delay == 0)
34196c6a:	697b      	ldr	r3, [r7, #20]
34196c6c:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
34196c70:	2b00      	cmp	r3, #0
34196c72:	d103      	bne.n	34196c7c <ISP_Algo_AEC_Init+0x2c>
  {
    /* A value of 0 is invalid, it would break the AEC algo */
    IQParamConfig->sensorDelay.delay = 1;
34196c74:	697b      	ldr	r3, [r7, #20]
34196c76:	2201      	movs	r2, #1
34196c78:	f883 2255 	strb.w	r2, [r3, #597]	@ 0x255
  }

  /* Create st_ae_process instance */
  pIspAEprocess = evision_api_st_ae_new(log_cb);
34196c7c:	4850      	ldr	r0, [pc, #320]	@ (34196dc0 <ISP_Algo_AEC_Init+0x170>)
34196c7e:	f7ea fbab 	bl	341813d8 <evision_api_st_ae_new>
34196c82:	4603      	mov	r3, r0
34196c84:	4a4f      	ldr	r2, [pc, #316]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196c86:	6013      	str	r3, [r2, #0]
  if (pIspAEprocess == NULL)
34196c88:	4b4e      	ldr	r3, [pc, #312]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196c8a:	681b      	ldr	r3, [r3, #0]
34196c8c:	2b00      	cmp	r3, #0
34196c8e:	d101      	bne.n	34196c94 <ISP_Algo_AEC_Init+0x44>
  {
    return ISP_ERR_ALGO;
34196c90:	23be      	movs	r3, #190	@ 0xbe
34196c92:	e087      	b.n	34196da4 <ISP_Algo_AEC_Init+0x154>
  }

  /* Initialize st_ae_process instance */
  e_ret = evision_api_st_ae_init(pIspAEprocess);
34196c94:	4b4b      	ldr	r3, [pc, #300]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196c96:	681b      	ldr	r3, [r3, #0]
34196c98:	4618      	mov	r0, r3
34196c9a:	f7ea fbf1 	bl	34181480 <evision_api_st_ae_init>
34196c9e:	4603      	mov	r3, r0
34196ca0:	74fb      	strb	r3, [r7, #19]
  if (e_ret != EVISION_RET_SUCCESS)
34196ca2:	f997 3013 	ldrsb.w	r3, [r7, #19]
34196ca6:	2b01      	cmp	r3, #1
34196ca8:	d006      	beq.n	34196cb8 <ISP_Algo_AEC_Init+0x68>
  {
    evision_api_st_ae_delete(pIspAEprocess);
34196caa:	4b46      	ldr	r3, [pc, #280]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cac:	681b      	ldr	r3, [r3, #0]
34196cae:	4618      	mov	r0, r3
34196cb0:	f7ea fbac 	bl	3418140c <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
34196cb4:	23be      	movs	r3, #190	@ 0xbe
34196cb6:	e075      	b.n	34196da4 <ISP_Algo_AEC_Init+0x154>
  }

  /* Configure algo (AEC target and anti-flicker setting) */
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34196cb8:	4b42      	ldr	r3, [pc, #264]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cba:	681b      	ldr	r3, [r3, #0]
34196cbc:	697a      	ldr	r2, [r7, #20]
34196cbe:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
34196cc0:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
34196cc2:	697b      	ldr	r3, [r7, #20]
34196cc4:	f893 2070 	ldrb.w	r2, [r3, #112]	@ 0x70
34196cc8:	4b3e      	ldr	r3, [pc, #248]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cca:	681b      	ldr	r3, [r3, #0]
34196ccc:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Configure algo (sensor config) */
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
34196cce:	4b3d      	ldr	r3, [pc, #244]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cd0:	681b      	ldr	r3, [r3, #0]
34196cd2:	69fa      	ldr	r2, [r7, #28]
34196cd4:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
34196cd8:	641a      	str	r2, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
34196cda:	4b3a      	ldr	r3, [pc, #232]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cdc:	681b      	ldr	r3, [r3, #0]
34196cde:	69fa      	ldr	r2, [r7, #28]
34196ce0:	f8d2 2084 	ldr.w	r2, [r2, #132]	@ 0x84
34196ce4:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
34196ce6:	4b37      	ldr	r3, [pc, #220]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196ce8:	681b      	ldr	r3, [r3, #0]
34196cea:	69fa      	ldr	r2, [r7, #28]
34196cec:	6f92      	ldr	r2, [r2, #120]	@ 0x78
34196cee:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
34196cf0:	4b34      	ldr	r3, [pc, #208]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cf2:	681b      	ldr	r3, [r3, #0]
34196cf4:	69fa      	ldr	r2, [r7, #28]
34196cf6:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34196cf8:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Force hyper parameters with configuration defined in evision-api-st-ae.h */
  pIspAEprocess->hyper_params.tolerance = HYPERPARAM_AEC_TOLERANCE;
34196cfa:	4b32      	ldr	r3, [pc, #200]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196cfc:	681b      	ldr	r3, [r3, #0]
34196cfe:	220a      	movs	r2, #10
34196d00:	615a      	str	r2, [r3, #20]
  pIspAEprocess->hyper_params.gain_increment_coeff = HYPERPARAM_AEC_GAIN_INCREMENT_COEFF;
34196d02:	4b30      	ldr	r3, [pc, #192]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d04:	681b      	ldr	r3, [r3, #0]
34196d06:	2264      	movs	r2, #100	@ 0x64
34196d08:	619a      	str	r2, [r3, #24]
  pIspAEprocess->hyper_params.gain_low_delta = HYPERPARAM_AEC_GAIN_LOW_DELTA;
34196d0a:	4b2e      	ldr	r3, [pc, #184]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d0c:	681b      	ldr	r3, [r3, #0]
34196d0e:	222d      	movs	r2, #45	@ 0x2d
34196d10:	61da      	str	r2, [r3, #28]
  pIspAEprocess->hyper_params.gain_high_delta = HYPERPARAM_AEC_GAIN_HIGH_DELTA;
34196d12:	4b2c      	ldr	r3, [pc, #176]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d14:	681b      	ldr	r3, [r3, #0]
34196d16:	2278      	movs	r2, #120	@ 0x78
34196d18:	621a      	str	r2, [r3, #32]
  pIspAEprocess->hyper_params.gain_low_increment_max = HYPERPARAM_AEC_GAIN_LOW_INC_MAX;
34196d1a:	4b2a      	ldr	r3, [pc, #168]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d1c:	681b      	ldr	r3, [r3, #0]
34196d1e:	f240 52dc 	movw	r2, #1500	@ 0x5dc
34196d22:	625a      	str	r2, [r3, #36]	@ 0x24
  pIspAEprocess->hyper_params.gain_medium_increment_max = HYPERPARAM_AEC_GAIN_MEDIUM_INC_MAX;
34196d24:	4b27      	ldr	r3, [pc, #156]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d26:	681b      	ldr	r3, [r3, #0]
34196d28:	f241 7270 	movw	r2, #6000	@ 0x1770
34196d2c:	629a      	str	r2, [r3, #40]	@ 0x28
  pIspAEprocess->hyper_params.gain_high_increment_max = HYPERPARAM_AEC_GAIN_HIGH_INC_MAX;
34196d2e:	4b25      	ldr	r3, [pc, #148]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d30:	681b      	ldr	r3, [r3, #0]
34196d32:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
34196d36:	62da      	str	r2, [r3, #44]	@ 0x2c
  pIspAEprocess->hyper_params.exposure_up_ratio = HYPERPARAM_AEC_EXPOSURE_UP_RATIO;
34196d38:	4b22      	ldr	r3, [pc, #136]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d3a:	6819      	ldr	r1, [r3, #0]
34196d3c:	a31c      	add	r3, pc, #112	@ (adr r3, 34196db0 <ISP_Algo_AEC_Init+0x160>)
34196d3e:	e9d3 2300 	ldrd	r2, r3, [r3]
34196d42:	e9c1 230c 	strd	r2, r3, [r1, #48]	@ 0x30
  pIspAEprocess->hyper_params.exposure_down_ratio = HYPERPARAM_AEC_EXPOSURE_DOWN_RATIO;
34196d46:	4b1f      	ldr	r3, [pc, #124]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d48:	6819      	ldr	r1, [r3, #0]
34196d4a:	a31b      	add	r3, pc, #108	@ (adr r3, 34196db8 <ISP_Algo_AEC_Init+0x168>)
34196d4c:	e9d3 2300 	ldrd	r2, r3, [r3]
34196d50:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
  pIspAEprocess->hyper_params.dark_zone_lum_limit = HYPERPARAM_AEC_DARKZONE_LUM_LIMIT;
34196d54:	4b1b      	ldr	r3, [pc, #108]	@ (34196dc4 <ISP_Algo_AEC_Init+0x174>)
34196d56:	681b      	ldr	r3, [r3, #0]
34196d58:	2205      	movs	r2, #5
34196d5a:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Initialize exposure and gain at min value */
  if (IQParamConfig->AECAlgo.enable == true)
34196d5c:	697b      	ldr	r3, [r7, #20]
34196d5e:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34196d62:	2b01      	cmp	r3, #1
34196d64:	d11a      	bne.n	34196d9c <ISP_Algo_AEC_Init+0x14c>
  {
    exposureConfig.exposure = pIsp_handle->sensorInfo.exposure_min;
34196d66:	69fb      	ldr	r3, [r7, #28]
34196d68:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34196d6c:	60fb      	str	r3, [r7, #12]
    gainConfig.gain = pIsp_handle->sensorInfo.gain_min;
34196d6e:	69fb      	ldr	r3, [r7, #28]
34196d70:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34196d72:	60bb      	str	r3, [r7, #8]
    if ((ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig) != ISP_OK) || (ISP_SVC_Sensor_SetGain(hIsp, &gainConfig)!= ISP_OK))
34196d74:	f107 030c 	add.w	r3, r7, #12
34196d78:	4619      	mov	r1, r3
34196d7a:	6878      	ldr	r0, [r7, #4]
34196d7c:	f002 fca8 	bl	341996d0 <ISP_SVC_Sensor_SetExposure>
34196d80:	4603      	mov	r3, r0
34196d82:	2b00      	cmp	r3, #0
34196d84:	d108      	bne.n	34196d98 <ISP_Algo_AEC_Init+0x148>
34196d86:	f107 0308 	add.w	r3, r7, #8
34196d8a:	4619      	mov	r1, r3
34196d8c:	6878      	ldr	r0, [r7, #4]
34196d8e:	f002 fc53 	bl	34199638 <ISP_SVC_Sensor_SetGain>
34196d92:	4603      	mov	r3, r0
34196d94:	2b00      	cmp	r3, #0
34196d96:	d001      	beq.n	34196d9c <ISP_Algo_AEC_Init+0x14c>
    {
      return ISP_ERR_ALGO;
34196d98:	23be      	movs	r3, #190	@ 0xbe
34196d9a:	e003      	b.n	34196da4 <ISP_Algo_AEC_Init+0x154>
    }
  }

  /* Update State */
  algo->state = ISP_ALGO_STATE_INIT;
34196d9c:	69bb      	ldr	r3, [r7, #24]
34196d9e:	2200      	movs	r2, #0
34196da0:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34196da2:	2300      	movs	r3, #0
}
34196da4:	4618      	mov	r0, r3
34196da6:	3720      	adds	r7, #32
34196da8:	46bd      	mov	sp, r7
34196daa:	bd80      	pop	{r7, pc}
34196dac:	f3af 8000 	nop.w
34196db0:	40000000 	.word	0x40000000
34196db4:	3f947ae1 	.word	0x3f947ae1
34196db8:	e0000000 	.word	0xe0000000
34196dbc:	3f70624d 	.word	0x3f70624d
34196dc0:	34196c25 	.word	0x34196c25
34196dc4:	341c11a4 	.word	0x341c11a4

34196dc8 <ISP_Algo_AEC_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_DeInit(void *hIsp, void *pAlgo)
{
34196dc8:	b580      	push	{r7, lr}
34196dca:	b082      	sub	sp, #8
34196dcc:	af00      	add	r7, sp, #0
34196dce:	6078      	str	r0, [r7, #4]
34196dd0:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAEprocess != NULL)
34196dd2:	4b07      	ldr	r3, [pc, #28]	@ (34196df0 <ISP_Algo_AEC_DeInit+0x28>)
34196dd4:	681b      	ldr	r3, [r3, #0]
34196dd6:	2b00      	cmp	r3, #0
34196dd8:	d004      	beq.n	34196de4 <ISP_Algo_AEC_DeInit+0x1c>
  {
    evision_api_st_ae_delete(pIspAEprocess);
34196dda:	4b05      	ldr	r3, [pc, #20]	@ (34196df0 <ISP_Algo_AEC_DeInit+0x28>)
34196ddc:	681b      	ldr	r3, [r3, #0]
34196dde:	4618      	mov	r0, r3
34196de0:	f7ea fb14 	bl	3418140c <evision_api_st_ae_delete>
  }
  return ISP_OK;
34196de4:	2300      	movs	r3, #0
}
34196de6:	4618      	mov	r0, r3
34196de8:	3708      	adds	r7, #8
34196dea:	46bd      	mov	sp, r7
34196dec:	bd80      	pop	{r7, pc}
34196dee:	bf00      	nop
34196df0:	341c11a4 	.word	0x341c11a4

34196df4 <ISP_Algo_AEC_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
34196df4:	b480      	push	{r7}
34196df6:	b083      	sub	sp, #12
34196df8:	af00      	add	r7, sp, #0
34196dfa:	6078      	str	r0, [r7, #4]
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
34196dfc:	687b      	ldr	r3, [r7, #4]
34196dfe:	2203      	movs	r2, #3
34196e00:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34196e02:	2300      	movs	r3, #0
}
34196e04:	4618      	mov	r0, r3
34196e06:	370c      	adds	r7, #12
34196e08:	46bd      	mov	sp, r7
34196e0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34196e0e:	4770      	bx	lr

34196e10 <ISP_Algo_AEC_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Process(void *hIsp, void *pAlgo)
{
34196e10:	b580      	push	{r7, lr}
34196e12:	b08e      	sub	sp, #56	@ 0x38
34196e14:	af04      	add	r7, sp, #16
34196e16:	6078      	str	r0, [r7, #4]
34196e18:	6039      	str	r1, [r7, #0]
  static ISP_SVC_StatStateTypeDef stats;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34196e1a:	683b      	ldr	r3, [r7, #0]
34196e1c:	623b      	str	r3, [r7, #32]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret = ISP_OK;
34196e1e:	2300      	movs	r3, #0
34196e20:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#ifdef ALGO_AEC_DBG_LOGS
  static uint32_t currentL;
#endif
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34196e24:	6878      	ldr	r0, [r7, #4]
34196e26:	f002 fd8b 	bl	34199940 <ISP_SVC_IQParam_Get>
34196e2a:	61f8      	str	r0, [r7, #28]
  if (IQParamConfig->AECAlgo.enable == false)
34196e2c:	69fb      	ldr	r3, [r7, #28]
34196e2e:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34196e32:	2b00      	cmp	r3, #0
34196e34:	d101      	bne.n	34196e3a <ISP_Algo_AEC_Process+0x2a>
  {
    return ISP_OK;
34196e36:	2300      	movs	r3, #0
34196e38:	e0c3      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
  }

  switch(algo->state)
34196e3a:	6a3b      	ldr	r3, [r7, #32]
34196e3c:	785b      	ldrb	r3, [r3, #1]
34196e3e:	2b03      	cmp	r3, #3
34196e40:	d027      	beq.n	34196e92 <ISP_Algo_AEC_Process+0x82>
34196e42:	2b03      	cmp	r3, #3
34196e44:	f300 80b3 	bgt.w	34196fae <ISP_Algo_AEC_Process+0x19e>
34196e48:	2b01      	cmp	r3, #1
34196e4a:	dc02      	bgt.n	34196e52 <ISP_Algo_AEC_Process+0x42>
34196e4c:	2b00      	cmp	r3, #0
34196e4e:	da04      	bge.n	34196e5a <ISP_Algo_AEC_Process+0x4a>
34196e50:	e0ad      	b.n	34196fae <ISP_Algo_AEC_Process+0x19e>
34196e52:	2b02      	cmp	r3, #2
34196e54:	f000 80b2 	beq.w	34196fbc <ISP_Algo_AEC_Process+0x1ac>
34196e58:	e0a9      	b.n	34196fae <ISP_Algo_AEC_Process+0x19e>
  {
  case ISP_ALGO_STATE_INIT:
  case ISP_ALGO_STATE_NEED_STAT:
    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
                                ISP_STAT_TYPE_AVG, IQParamConfig->sensorDelay.delay);
34196e5a:	69fb      	ldr	r3, [r7, #28]
34196e5c:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34196e60:	9302      	str	r3, [sp, #8]
34196e62:	2301      	movs	r3, #1
34196e64:	9301      	str	r3, [sp, #4]
34196e66:	2302      	movs	r3, #2
34196e68:	9300      	str	r3, [sp, #0]
34196e6a:	4b58      	ldr	r3, [pc, #352]	@ (34196fcc <ISP_Algo_AEC_Process+0x1bc>)
34196e6c:	683a      	ldr	r2, [r7, #0]
34196e6e:	4958      	ldr	r1, [pc, #352]	@ (34196fd0 <ISP_Algo_AEC_Process+0x1c0>)
34196e70:	6878      	ldr	r0, [r7, #4]
34196e72:	f003 f8cb 	bl	3419a00c <ISP_SVC_Stats_GetNext>
34196e76:	4603      	mov	r3, r0
34196e78:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
34196e7c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196e80:	2b00      	cmp	r3, #0
34196e82:	d002      	beq.n	34196e8a <ISP_Algo_AEC_Process+0x7a>
    {
      return ret;
34196e84:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196e88:	e09b      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34196e8a:	6a3b      	ldr	r3, [r7, #32]
34196e8c:	2202      	movs	r2, #2
34196e8e:	705a      	strb	r2, [r3, #1]
    break;
34196e90:	e095      	b.n	34196fbe <ISP_Algo_AEC_Process+0x1ae>
    /* Do nothing */
    break;

  case ISP_ALGO_STATE_STAT_READY:
    /* Align on the target update (may have been updated with ISP_SetExposureTarget()) */
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34196e92:	4b50      	ldr	r3, [pc, #320]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196e94:	681b      	ldr	r3, [r3, #0]
34196e96:	69fa      	ldr	r2, [r7, #28]
34196e98:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
34196e9a:	611a      	str	r2, [r3, #16]

    /* Align on the anti-flicker frequency (may have been updated by IQTune)*/
    pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
34196e9c:	69fb      	ldr	r3, [r7, #28]
34196e9e:	f893 2070 	ldrb.w	r2, [r3, #112]	@ 0x70
34196ea2:	4b4c      	ldr	r3, [pc, #304]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196ea4:	681b      	ldr	r3, [r3, #0]
34196ea6:	655a      	str	r2, [r3, #84]	@ 0x54

    avgL = stats.down.averageL;
34196ea8:	4b48      	ldr	r3, [pc, #288]	@ (34196fcc <ISP_Algo_AEC_Process+0x1bc>)
34196eaa:	f893 3037 	ldrb.w	r3, [r3, #55]	@ 0x37
34196eae:	61bb      	str	r3, [r7, #24]
      printf("L = %"PRIu32"\r\n", avgL);
      currentL = avgL;
    }
#endif
    /* Read the current sensor gain */
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34196eb0:	f107 0310 	add.w	r3, r7, #16
34196eb4:	4619      	mov	r1, r3
34196eb6:	6878      	ldr	r0, [r7, #4]
34196eb8:	f002 fbe8 	bl	3419968c <ISP_SVC_Sensor_GetGain>
34196ebc:	4603      	mov	r3, r0
34196ebe:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
34196ec2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196ec6:	2b00      	cmp	r3, #0
34196ec8:	d002      	beq.n	34196ed0 <ISP_Algo_AEC_Process+0xc0>
    {
      return ret;
34196eca:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196ece:	e078      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
    }

    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
34196ed0:	f107 030c 	add.w	r3, r7, #12
34196ed4:	4619      	mov	r1, r3
34196ed6:	6878      	ldr	r0, [r7, #4]
34196ed8:	f002 fc24 	bl	34199724 <ISP_SVC_Sensor_GetExposure>
34196edc:	4603      	mov	r3, r0
34196ede:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
34196ee2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196ee6:	2b00      	cmp	r3, #0
34196ee8:	d002      	beq.n	34196ef0 <ISP_Algo_AEC_Process+0xe0>
    {
      return ret;
34196eea:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196eee:	e068      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
    }

    /* Store meta data */
    Meta.averageL = (uint8_t)avgL;
34196ef0:	69bb      	ldr	r3, [r7, #24]
34196ef2:	b2da      	uxtb	r2, r3
34196ef4:	4b38      	ldr	r3, [pc, #224]	@ (34196fd8 <ISP_Algo_AEC_Process+0x1c8>)
34196ef6:	705a      	strb	r2, [r3, #1]
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
34196ef8:	69fb      	ldr	r3, [r7, #28]
34196efa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34196efc:	4a36      	ldr	r2, [pc, #216]	@ (34196fd8 <ISP_Algo_AEC_Process+0x1c8>)
34196efe:	6053      	str	r3, [r2, #4]

    /* Run algo to calculate new gain and exposure */
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, (uint8_t)avgL);
34196f00:	4b34      	ldr	r3, [pc, #208]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196f02:	6818      	ldr	r0, [r3, #0]
34196f04:	6939      	ldr	r1, [r7, #16]
34196f06:	68fa      	ldr	r2, [r7, #12]
34196f08:	69bb      	ldr	r3, [r7, #24]
34196f0a:	b2db      	uxtb	r3, r3
34196f0c:	f7ea fac3 	bl	34181496 <evision_api_st_ae_process>
34196f10:	4603      	mov	r3, r0
34196f12:	75fb      	strb	r3, [r7, #23]
    if (e_ret == EVISION_RET_SUCCESS)
34196f14:	f997 3017 	ldrsb.w	r3, [r7, #23]
34196f18:	2b01      	cmp	r3, #1
34196f1a:	d133      	bne.n	34196f84 <ISP_Algo_AEC_Process+0x174>
    {
      if (gainConfig.gain != pIspAEprocess->new_gain)
34196f1c:	693a      	ldr	r2, [r7, #16]
34196f1e:	4b2d      	ldr	r3, [pc, #180]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196f20:	681b      	ldr	r3, [r3, #0]
34196f22:	689b      	ldr	r3, [r3, #8]
34196f24:	429a      	cmp	r2, r3
34196f26:	d013      	beq.n	34196f50 <ISP_Algo_AEC_Process+0x140>
      {
        /* Set new gain */
        gainConfig.gain = pIspAEprocess->new_gain;
34196f28:	4b2a      	ldr	r3, [pc, #168]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196f2a:	681b      	ldr	r3, [r3, #0]
34196f2c:	689b      	ldr	r3, [r3, #8]
34196f2e:	613b      	str	r3, [r7, #16]

        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
34196f30:	f107 0310 	add.w	r3, r7, #16
34196f34:	4619      	mov	r1, r3
34196f36:	6878      	ldr	r0, [r7, #4]
34196f38:	f002 fb7e 	bl	34199638 <ISP_SVC_Sensor_SetGain>
34196f3c:	4603      	mov	r3, r0
34196f3e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
34196f42:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196f46:	2b00      	cmp	r3, #0
34196f48:	d002      	beq.n	34196f50 <ISP_Algo_AEC_Process+0x140>
        {
          return ret;
34196f4a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196f4e:	e038      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
#ifdef ALGO_AEC_DBG_LOGS
        printf("New gain = %"PRIu32"\r\n", gainConfig.gain);
#endif
      }

      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
34196f50:	68fa      	ldr	r2, [r7, #12]
34196f52:	4b20      	ldr	r3, [pc, #128]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196f54:	681b      	ldr	r3, [r3, #0]
34196f56:	685b      	ldr	r3, [r3, #4]
34196f58:	429a      	cmp	r2, r3
34196f5a:	d013      	beq.n	34196f84 <ISP_Algo_AEC_Process+0x174>
      {
        /* Set new exposure */
        exposureConfig.exposure = pIspAEprocess->new_exposure;
34196f5c:	4b1d      	ldr	r3, [pc, #116]	@ (34196fd4 <ISP_Algo_AEC_Process+0x1c4>)
34196f5e:	681b      	ldr	r3, [r3, #0]
34196f60:	685b      	ldr	r3, [r3, #4]
34196f62:	60fb      	str	r3, [r7, #12]

        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34196f64:	f107 030c 	add.w	r3, r7, #12
34196f68:	4619      	mov	r1, r3
34196f6a:	6878      	ldr	r0, [r7, #4]
34196f6c:	f002 fbb0 	bl	341996d0 <ISP_SVC_Sensor_SetExposure>
34196f70:	4603      	mov	r3, r0
34196f72:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
34196f76:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196f7a:	2b00      	cmp	r3, #0
34196f7c:	d002      	beq.n	34196f84 <ISP_Algo_AEC_Process+0x174>
        {
          return ret;
34196f7e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196f82:	e01e      	b.n	34196fc2 <ISP_Algo_AEC_Process+0x1b2>
      }
    }

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
                                ISP_STAT_TYPE_AVG, IQParamConfig->sensorDelay.delay);
34196f84:	69fb      	ldr	r3, [r7, #28]
34196f86:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34196f8a:	9302      	str	r3, [sp, #8]
34196f8c:	2301      	movs	r3, #1
34196f8e:	9301      	str	r3, [sp, #4]
34196f90:	2302      	movs	r3, #2
34196f92:	9300      	str	r3, [sp, #0]
34196f94:	4b0d      	ldr	r3, [pc, #52]	@ (34196fcc <ISP_Algo_AEC_Process+0x1bc>)
34196f96:	683a      	ldr	r2, [r7, #0]
34196f98:	490d      	ldr	r1, [pc, #52]	@ (34196fd0 <ISP_Algo_AEC_Process+0x1c0>)
34196f9a:	6878      	ldr	r0, [r7, #4]
34196f9c:	f003 f836 	bl	3419a00c <ISP_SVC_Stats_GetNext>
34196fa0:	4603      	mov	r3, r0
34196fa2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34196fa6:	6a3b      	ldr	r3, [r7, #32]
34196fa8:	2202      	movs	r2, #2
34196faa:	705a      	strb	r2, [r3, #1]
    break;
34196fac:	e007      	b.n	34196fbe <ISP_Algo_AEC_Process+0x1ae>

  default:
    printf("WARNING: Unknown AE algo state\r\n");
34196fae:	480b      	ldr	r0, [pc, #44]	@ (34196fdc <ISP_Algo_AEC_Process+0x1cc>)
34196fb0:	f00c fdc8 	bl	341a3b44 <puts>
    /* Reset state to ISP_ALGO_STATE_INIT */
    algo->state = ISP_ALGO_STATE_INIT;
34196fb4:	6a3b      	ldr	r3, [r7, #32]
34196fb6:	2200      	movs	r2, #0
34196fb8:	705a      	strb	r2, [r3, #1]
    break;
34196fba:	e000      	b.n	34196fbe <ISP_Algo_AEC_Process+0x1ae>
    break;
34196fbc:	bf00      	nop

  }

  return ret;
34196fbe:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
34196fc2:	4618      	mov	r0, r3
34196fc4:	3728      	adds	r7, #40	@ 0x28
34196fc6:	46bd      	mov	sp, r7
34196fc8:	bd80      	pop	{r7, pc}
34196fca:	bf00      	nop
34196fcc:	341c11d0 	.word	0x341c11d0
34196fd0:	34196df5 	.word	0x34196df5
34196fd4:	341c11a4 	.word	0x341c11a4
34196fd8:	341c11b0 	.word	0x341c11b0
34196fdc:	341a5cd0 	.word	0x341a5cd0

34196fe0 <ISP_Algo_ApplyGammaInverse>:
  * @param  hIsp:  ISP device handle.
  * @param  comp: component value
  * @retval gamma corrected value
  */
double ISP_Algo_ApplyGammaInverse(ISP_HandleTypeDef *hIsp, uint32_t comp)
{
34196fe0:	b580      	push	{r7, lr}
34196fe2:	b084      	sub	sp, #16
34196fe4:	af00      	add	r7, sp, #0
34196fe6:	6078      	str	r0, [r7, #4]
34196fe8:	6039      	str	r1, [r7, #0]
  double out;

  /* Check if gamma is enabled */
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
34196fea:	2101      	movs	r1, #1
34196fec:	6878      	ldr	r0, [r7, #4]
34196fee:	f002 fc1f 	bl	34199830 <ISP_SVC_Misc_IsGammaEnabled>
34196ff2:	4603      	mov	r3, r0
34196ff4:	2b00      	cmp	r3, #0
34196ff6:	d019      	beq.n	3419702c <ISP_Algo_ApplyGammaInverse+0x4c>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
34196ff8:	683b      	ldr	r3, [r7, #0]
34196ffa:	ee07 3a90 	vmov	s15, r3
34196ffe:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34197002:	eddf 6a17 	vldr	s13, [pc, #92]	@ 34197060 <ISP_Algo_ApplyGammaInverse+0x80>
34197006:	eec7 7a26 	vdiv.f32	s15, s14, s13
3419700a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419700e:	ed9f 1b10 	vldr	d1, [pc, #64]	@ 34197050 <ISP_Algo_ApplyGammaInverse+0x70>
34197012:	eeb0 0b47 	vmov.f64	d0, d7
34197016:	f00d fecf 	bl	341a4db8 <pow>
3419701a:	eeb0 7b40 	vmov.f64	d7, d0
3419701e:	ed9f 6b0e 	vldr	d6, [pc, #56]	@ 34197058 <ISP_Algo_ApplyGammaInverse+0x78>
34197022:	ee27 7b06 	vmul.f64	d7, d7, d6
34197026:	ed87 7b02 	vstr	d7, [r7, #8]
3419702a:	e006      	b.n	3419703a <ISP_Algo_ApplyGammaInverse+0x5a>
  }
  else
  {
    out = (double) comp;
3419702c:	683b      	ldr	r3, [r7, #0]
3419702e:	ee07 3a90 	vmov	s15, r3
34197032:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34197036:	ed87 7b02 	vstr	d7, [r7, #8]
  }
  return out;
3419703a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
3419703e:	ec43 2b17 	vmov	d7, r2, r3
}
34197042:	eeb0 0b47 	vmov.f64	d0, d7
34197046:	3710      	adds	r7, #16
34197048:	46bd      	mov	sp, r7
3419704a:	bd80      	pop	{r7, pc}
3419704c:	f3af 8000 	nop.w
34197050:	d1745d17 	.word	0xd1745d17
34197054:	3fdd1745 	.word	0x3fdd1745
34197058:	00000000 	.word	0x00000000
3419705c:	406fe000 	.word	0x406fe000
34197060:	437f0000 	.word	0x437f0000

34197064 <ISP_Algo_GetUpStat>:
  *         Recalculate average up statistics from collected down statistics
  * @param  hIsp:  ISP device handle.
  * @param  pStats: pointer to the statistics
  */
void ISP_Algo_GetUpStat(ISP_HandleTypeDef *hIsp, ISP_SVC_StatStateTypeDef *pStats)
{
34197064:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34197068:	b09a      	sub	sp, #104	@ 0x68
3419706a:	af00      	add	r7, sp, #0
3419706c:	6378      	str	r0, [r7, #52]	@ 0x34
3419706e:	6339      	str	r1, [r7, #48]	@ 0x30
  ISP_ISPGainTypeDef ISPGain;
  ISP_BlackLevelTypeDef BlackLevel;
  int64_t upR, upG, upB;

  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
34197070:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34197074:	4619      	mov	r1, r3
34197076:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34197078:	f002 f95a 	bl	34199330 <ISP_SVC_ISP_GetGain>
3419707c:	4603      	mov	r3, r0
3419707e:	2b00      	cmp	r3, #0
34197080:	f040 80a8 	bne.w	341971d4 <ISP_Algo_GetUpStat+0x170>
34197084:	f897 3040 	ldrb.w	r3, [r7, #64]	@ 0x40
34197088:	2b01      	cmp	r3, #1
3419708a:	f040 80a3 	bne.w	341971d4 <ISP_Algo_GetUpStat+0x170>
  {

    /* reverse gain */
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
3419708e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197090:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
34197094:	b2db      	uxtb	r3, r3
34197096:	2200      	movs	r2, #0
34197098:	461c      	mov	r4, r3
3419709a:	4615      	mov	r5, r2
3419709c:	4b58      	ldr	r3, [pc, #352]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
3419709e:	fb03 f205 	mul.w	r2, r3, r5
341970a2:	2300      	movs	r3, #0
341970a4:	fb04 f303 	mul.w	r3, r4, r3
341970a8:	441a      	add	r2, r3
341970aa:	4b55      	ldr	r3, [pc, #340]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
341970ac:	fba4 1303 	umull	r1, r3, r4, r3
341970b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
341970b2:	460b      	mov	r3, r1
341970b4:	62bb      	str	r3, [r7, #40]	@ 0x28
341970b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341970b8:	18d3      	adds	r3, r2, r3
341970ba:	62fb      	str	r3, [r7, #44]	@ 0x2c
341970bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
341970be:	2200      	movs	r2, #0
341970c0:	623b      	str	r3, [r7, #32]
341970c2:	627a      	str	r2, [r7, #36]	@ 0x24
341970c4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
341970c8:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
341970cc:	f7ea fb36 	bl	3418173c <__aeabi_ldivmod>
341970d0:	4602      	mov	r2, r0
341970d2:	460b      	mov	r3, r1
341970d4:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
341970d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341970da:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
341970de:	b2db      	uxtb	r3, r3
341970e0:	2200      	movs	r2, #0
341970e2:	61bb      	str	r3, [r7, #24]
341970e4:	61fa      	str	r2, [r7, #28]
341970e6:	4b46      	ldr	r3, [pc, #280]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
341970e8:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
341970ec:	462a      	mov	r2, r5
341970ee:	fb03 f202 	mul.w	r2, r3, r2
341970f2:	2300      	movs	r3, #0
341970f4:	4621      	mov	r1, r4
341970f6:	fb01 f303 	mul.w	r3, r1, r3
341970fa:	4413      	add	r3, r2
341970fc:	4a40      	ldr	r2, [pc, #256]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
341970fe:	4621      	mov	r1, r4
34197100:	fba1 ab02 	umull	sl, fp, r1, r2
34197104:	445b      	add	r3, fp
34197106:	469b      	mov	fp, r3
34197108:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419710a:	2200      	movs	r2, #0
3419710c:	613b      	str	r3, [r7, #16]
3419710e:	617a      	str	r2, [r7, #20]
34197110:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34197114:	4650      	mov	r0, sl
34197116:	4659      	mov	r1, fp
34197118:	f7ea fb10 	bl	3418173c <__aeabi_ldivmod>
3419711c:	4602      	mov	r2, r0
3419711e:	460b      	mov	r3, r1
34197120:	e9c7 2316 	strd	r2, r3, [r7, #88]	@ 0x58
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
34197124:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197126:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3419712a:	b2db      	uxtb	r3, r3
3419712c:	2200      	movs	r2, #0
3419712e:	60bb      	str	r3, [r7, #8]
34197130:	60fa      	str	r2, [r7, #12]
34197132:	4b33      	ldr	r3, [pc, #204]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
34197134:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
34197138:	462a      	mov	r2, r5
3419713a:	fb03 f202 	mul.w	r2, r3, r2
3419713e:	2300      	movs	r3, #0
34197140:	4621      	mov	r1, r4
34197142:	fb01 f303 	mul.w	r3, r1, r3
34197146:	4413      	add	r3, r2
34197148:	4a2d      	ldr	r2, [pc, #180]	@ (34197200 <ISP_Algo_GetUpStat+0x19c>)
3419714a:	4621      	mov	r1, r4
3419714c:	fba1 8902 	umull	r8, r9, r1, r2
34197150:	444b      	add	r3, r9
34197152:	4699      	mov	r9, r3
34197154:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34197156:	2200      	movs	r2, #0
34197158:	603b      	str	r3, [r7, #0]
3419715a:	607a      	str	r2, [r7, #4]
3419715c:	e9d7 2300 	ldrd	r2, r3, [r7]
34197160:	4640      	mov	r0, r8
34197162:	4649      	mov	r1, r9
34197164:	f7ea faea 	bl	3418173c <__aeabi_ldivmod>
34197168:	4602      	mov	r2, r0
3419716a:	460b      	mov	r3, r1
3419716c:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50

    pStats->up.averageR = (uint8_t) upR;
34197170:	f897 2060 	ldrb.w	r2, [r7, #96]	@ 0x60
34197174:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197176:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG = (uint8_t) upG;
34197178:	f897 2058 	ldrb.w	r2, [r7, #88]	@ 0x58
3419717c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419717e:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB = (uint8_t) upB;
34197180:	f897 2050 	ldrb.w	r2, [r7, #80]	@ 0x50
34197184:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34197186:	709a      	strb	r2, [r3, #2]

    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
34197188:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
3419718c:	4619      	mov	r1, r3
3419718e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34197190:	f002 f836 	bl	34199200 <ISP_SVC_ISP_GetBlackLevel>
34197194:	4603      	mov	r3, r0
34197196:	2b00      	cmp	r3, #0
34197198:	d12c      	bne.n	341971f4 <ISP_Algo_GetUpStat+0x190>
3419719a:	f897 303c 	ldrb.w	r3, [r7, #60]	@ 0x3c
3419719e:	2b01      	cmp	r3, #1
341971a0:	d128      	bne.n	341971f4 <ISP_Algo_GetUpStat+0x190>
    {
        /* reverse black level */
    pStats->up.averageR += BlackLevel.BLCR;
341971a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971a4:	781a      	ldrb	r2, [r3, #0]
341971a6:	f897 303d 	ldrb.w	r3, [r7, #61]	@ 0x3d
341971aa:	4413      	add	r3, r2
341971ac:	b2da      	uxtb	r2, r3
341971ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971b0:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG += BlackLevel.BLCG;
341971b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971b4:	785a      	ldrb	r2, [r3, #1]
341971b6:	f897 303e 	ldrb.w	r3, [r7, #62]	@ 0x3e
341971ba:	4413      	add	r3, r2
341971bc:	b2da      	uxtb	r2, r3
341971be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971c0:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB += BlackLevel.BLCB;
341971c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971c4:	789a      	ldrb	r2, [r3, #2]
341971c6:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
341971ca:	4413      	add	r3, r2
341971cc:	b2da      	uxtb	r2, r3
341971ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971d0:	709a      	strb	r2, [r3, #2]
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
341971d2:	e00f      	b.n	341971f4 <ISP_Algo_GetUpStat+0x190>
    }
  }
  else
  {
    pStats->up.averageR = pStats->down.averageR;
341971d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971d6:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
341971da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971dc:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG = pStats->down.averageG;
341971de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971e0:	f893 2035 	ldrb.w	r2, [r3, #53]	@ 0x35
341971e4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971e6:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB = pStats->down.averageB;
341971e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971ea:	f893 2036 	ldrb.w	r2, [r3, #54]	@ 0x36
341971ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341971f0:	709a      	strb	r2, [r3, #2]
  }
}
341971f2:	e000      	b.n	341971f6 <ISP_Algo_GetUpStat+0x192>
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
341971f4:	bf00      	nop
}
341971f6:	bf00      	nop
341971f8:	3768      	adds	r7, #104	@ 0x68
341971fa:	46bd      	mov	sp, r7
341971fc:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34197200:	05f5e100 	.word	0x05f5e100
34197204:	00000000 	.word	0x00000000

34197208 <ISP_Algo_ApplyCConv>:
  * @param  outG: pointer to Green component value after color conversion
  * @param  outB: pointer to Blue component value after color conversion
  * @retval None
  */
void ISP_Algo_ApplyCConv(ISP_HandleTypeDef *hIsp, uint32_t inR, uint32_t inG, uint32_t inB, uint32_t *outR, uint32_t *outG, uint32_t *outB)
{
34197208:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3419720c:	b0d0      	sub	sp, #320	@ 0x140
3419720e:	af00      	add	r7, sp, #0
34197210:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
34197214:	f8c7 10f8 	str.w	r1, [r7, #248]	@ 0xf8
34197218:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
3419721c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  ISP_ColorConvTypeDef colorConv;
  int64_t ccR, ccG, ccB;

  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
34197220:	f507 7380 	add.w	r3, r7, #256	@ 0x100
34197224:	4619      	mov	r1, r3
34197226:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
3419722a:	f002 f977 	bl	3419951c <ISP_SVC_ISP_GetColorConv>
3419722e:	4603      	mov	r3, r0
34197230:	2b00      	cmp	r3, #0
34197232:	f040 8216 	bne.w	34197662 <ISP_Algo_ApplyCConv+0x45a>
34197236:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
3419723a:	2b01      	cmp	r3, #1
3419723c:	f040 8211 	bne.w	34197662 <ISP_Algo_ApplyCConv+0x45a>
  {
    /* Apply ColorConversion matrix to the input components */
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
34197240:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
34197244:	2200      	movs	r2, #0
34197246:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
3419724a:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
3419724e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
34197252:	17da      	asrs	r2, r3, #31
34197254:	461c      	mov	r4, r3
34197256:	4615      	mov	r5, r2
34197258:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
3419725c:	460b      	mov	r3, r1
3419725e:	fb04 f203 	mul.w	r2, r4, r3
34197262:	4603      	mov	r3, r0
34197264:	fb03 f305 	mul.w	r3, r3, r5
34197268:	4413      	add	r3, r2
3419726a:	4602      	mov	r2, r0
3419726c:	fba2 ab04 	umull	sl, fp, r2, r4
34197270:	445b      	add	r3, fp
34197272:	469b      	mov	fp, r3
34197274:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
34197278:	2200      	movs	r2, #0
3419727a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
3419727e:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
34197282:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
34197286:	17da      	asrs	r2, r3, #31
34197288:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3419728c:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
34197290:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34197294:	460b      	mov	r3, r1
34197296:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
3419729a:	4622      	mov	r2, r4
3419729c:	fb02 f203 	mul.w	r2, r2, r3
341972a0:	e9c7 453a 	strd	r4, r5, [r7, #232]	@ 0xe8
341972a4:	462b      	mov	r3, r5
341972a6:	4604      	mov	r4, r0
341972a8:	460d      	mov	r5, r1
341972aa:	4621      	mov	r1, r4
341972ac:	fb01 f303 	mul.w	r3, r1, r3
341972b0:	4413      	add	r3, r2
341972b2:	4622      	mov	r2, r4
341972b4:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
341972b8:	fba2 8901 	umull	r8, r9, r2, r1
341972bc:	444b      	add	r3, r9
341972be:	4699      	mov	r9, r3
341972c0:	eb1a 0308 	adds.w	r3, sl, r8
341972c4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
341972c8:	eb4b 0309 	adc.w	r3, fp, r9
341972cc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
341972d0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
341972d4:	2200      	movs	r2, #0
341972d6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
341972da:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
341972de:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
341972e2:	17da      	asrs	r2, r3, #31
341972e4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
341972e8:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
341972ec:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
341972f0:	462b      	mov	r3, r5
341972f2:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	@ 0x88
341972f6:	4642      	mov	r2, r8
341972f8:	fb02 f203 	mul.w	r2, r2, r3
341972fc:	464b      	mov	r3, r9
341972fe:	4621      	mov	r1, r4
34197300:	fb01 f303 	mul.w	r3, r1, r3
34197304:	4413      	add	r3, r2
34197306:	4622      	mov	r2, r4
34197308:	4641      	mov	r1, r8
3419730a:	fba2 1201 	umull	r1, r2, r2, r1
3419730e:	f8c7 20e4 	str.w	r2, [r7, #228]	@ 0xe4
34197312:	460a      	mov	r2, r1
34197314:	f8c7 20e0 	str.w	r2, [r7, #224]	@ 0xe0
34197318:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
3419731c:	4413      	add	r3, r2
3419731e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34197322:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
34197326:	4623      	mov	r3, r4
34197328:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3419732c:	4602      	mov	r2, r0
3419732e:	189b      	adds	r3, r3, r2
34197330:	613b      	str	r3, [r7, #16]
34197332:	460b      	mov	r3, r1
34197334:	462a      	mov	r2, r5
34197336:	eb42 0303 	adc.w	r3, r2, r3
3419733a:	617b      	str	r3, [r7, #20]
3419733c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34197340:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
34197344:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
34197348:	2200      	movs	r2, #0
3419734a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
3419734e:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
34197352:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
34197356:	17da      	asrs	r2, r3, #31
34197358:	67bb      	str	r3, [r7, #120]	@ 0x78
3419735a:	67fa      	str	r2, [r7, #124]	@ 0x7c
3419735c:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
34197360:	462b      	mov	r3, r5
34197362:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
34197366:	4642      	mov	r2, r8
34197368:	fb02 f203 	mul.w	r2, r2, r3
3419736c:	464b      	mov	r3, r9
3419736e:	4621      	mov	r1, r4
34197370:	fb01 f303 	mul.w	r3, r1, r3
34197374:	4413      	add	r3, r2
34197376:	4622      	mov	r2, r4
34197378:	4641      	mov	r1, r8
3419737a:	fba2 1201 	umull	r1, r2, r2, r1
3419737e:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
34197382:	460a      	mov	r2, r1
34197384:	f8c7 20d8 	str.w	r2, [r7, #216]	@ 0xd8
34197388:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
3419738c:	4413      	add	r3, r2
3419738e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
34197392:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
34197396:	2200      	movs	r2, #0
34197398:	673b      	str	r3, [r7, #112]	@ 0x70
3419739a:	677a      	str	r2, [r7, #116]	@ 0x74
3419739c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
341973a0:	17da      	asrs	r2, r3, #31
341973a2:	66bb      	str	r3, [r7, #104]	@ 0x68
341973a4:	66fa      	str	r2, [r7, #108]	@ 0x6c
341973a6:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
341973aa:	462b      	mov	r3, r5
341973ac:	e9d7 891a 	ldrd	r8, r9, [r7, #104]	@ 0x68
341973b0:	4642      	mov	r2, r8
341973b2:	fb02 f203 	mul.w	r2, r2, r3
341973b6:	464b      	mov	r3, r9
341973b8:	4621      	mov	r1, r4
341973ba:	fb01 f303 	mul.w	r3, r1, r3
341973be:	4413      	add	r3, r2
341973c0:	4622      	mov	r2, r4
341973c2:	4641      	mov	r1, r8
341973c4:	fba2 1201 	umull	r1, r2, r2, r1
341973c8:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
341973cc:	460a      	mov	r2, r1
341973ce:	f8c7 20d0 	str.w	r2, [r7, #208]	@ 0xd0
341973d2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
341973d6:	4413      	add	r3, r2
341973d8:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
341973dc:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
341973e0:	4623      	mov	r3, r4
341973e2:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
341973e6:	4602      	mov	r2, r0
341973e8:	189b      	adds	r3, r3, r2
341973ea:	663b      	str	r3, [r7, #96]	@ 0x60
341973ec:	460b      	mov	r3, r1
341973ee:	462a      	mov	r2, r5
341973f0:	eb42 0303 	adc.w	r3, r2, r3
341973f4:	667b      	str	r3, [r7, #100]	@ 0x64
341973f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
341973fa:	2200      	movs	r2, #0
341973fc:	65bb      	str	r3, [r7, #88]	@ 0x58
341973fe:	65fa      	str	r2, [r7, #92]	@ 0x5c
34197400:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
34197404:	17da      	asrs	r2, r3, #31
34197406:	653b      	str	r3, [r7, #80]	@ 0x50
34197408:	657a      	str	r2, [r7, #84]	@ 0x54
3419740a:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
3419740e:	462b      	mov	r3, r5
34197410:	e9d7 8914 	ldrd	r8, r9, [r7, #80]	@ 0x50
34197414:	4642      	mov	r2, r8
34197416:	fb02 f203 	mul.w	r2, r2, r3
3419741a:	464b      	mov	r3, r9
3419741c:	4621      	mov	r1, r4
3419741e:	fb01 f303 	mul.w	r3, r1, r3
34197422:	4413      	add	r3, r2
34197424:	4622      	mov	r2, r4
34197426:	4641      	mov	r1, r8
34197428:	fba2 1201 	umull	r1, r2, r2, r1
3419742c:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
34197430:	460a      	mov	r2, r1
34197432:	f8c7 20c8 	str.w	r2, [r7, #200]	@ 0xc8
34197436:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
3419743a:	4413      	add	r3, r2
3419743c:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34197440:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
34197444:	4623      	mov	r3, r4
34197446:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
3419744a:	4602      	mov	r2, r0
3419744c:	189b      	adds	r3, r3, r2
3419744e:	60bb      	str	r3, [r7, #8]
34197450:	460b      	mov	r3, r1
34197452:	462a      	mov	r2, r5
34197454:	eb42 0303 	adc.w	r3, r2, r3
34197458:	60fb      	str	r3, [r7, #12]
3419745a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
3419745e:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34197462:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
34197466:	2200      	movs	r2, #0
34197468:	64bb      	str	r3, [r7, #72]	@ 0x48
3419746a:	64fa      	str	r2, [r7, #76]	@ 0x4c
3419746c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
34197470:	17da      	asrs	r2, r3, #31
34197472:	643b      	str	r3, [r7, #64]	@ 0x40
34197474:	647a      	str	r2, [r7, #68]	@ 0x44
34197476:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
3419747a:	462b      	mov	r3, r5
3419747c:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	@ 0x40
34197480:	4642      	mov	r2, r8
34197482:	fb02 f203 	mul.w	r2, r2, r3
34197486:	464b      	mov	r3, r9
34197488:	4621      	mov	r1, r4
3419748a:	fb01 f303 	mul.w	r3, r1, r3
3419748e:	4413      	add	r3, r2
34197490:	4622      	mov	r2, r4
34197492:	4641      	mov	r1, r8
34197494:	fba2 1201 	umull	r1, r2, r2, r1
34197498:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
3419749c:	460a      	mov	r2, r1
3419749e:	f8c7 20c0 	str.w	r2, [r7, #192]	@ 0xc0
341974a2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
341974a6:	4413      	add	r3, r2
341974a8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
341974ac:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
341974b0:	2200      	movs	r2, #0
341974b2:	63bb      	str	r3, [r7, #56]	@ 0x38
341974b4:	63fa      	str	r2, [r7, #60]	@ 0x3c
341974b6:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
341974ba:	17da      	asrs	r2, r3, #31
341974bc:	633b      	str	r3, [r7, #48]	@ 0x30
341974be:	637a      	str	r2, [r7, #52]	@ 0x34
341974c0:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
341974c4:	462b      	mov	r3, r5
341974c6:	e9d7 890c 	ldrd	r8, r9, [r7, #48]	@ 0x30
341974ca:	4642      	mov	r2, r8
341974cc:	fb02 f203 	mul.w	r2, r2, r3
341974d0:	464b      	mov	r3, r9
341974d2:	4621      	mov	r1, r4
341974d4:	fb01 f303 	mul.w	r3, r1, r3
341974d8:	4413      	add	r3, r2
341974da:	4622      	mov	r2, r4
341974dc:	4641      	mov	r1, r8
341974de:	fba2 1201 	umull	r1, r2, r2, r1
341974e2:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
341974e6:	460a      	mov	r2, r1
341974e8:	f8c7 20b8 	str.w	r2, [r7, #184]	@ 0xb8
341974ec:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
341974f0:	4413      	add	r3, r2
341974f2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
341974f6:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	@ 0xc0
341974fa:	4623      	mov	r3, r4
341974fc:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34197500:	4602      	mov	r2, r0
34197502:	189b      	adds	r3, r3, r2
34197504:	62bb      	str	r3, [r7, #40]	@ 0x28
34197506:	460b      	mov	r3, r1
34197508:	462a      	mov	r2, r5
3419750a:	eb42 0303 	adc.w	r3, r2, r3
3419750e:	62fb      	str	r3, [r7, #44]	@ 0x2c
34197510:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
34197514:	2200      	movs	r2, #0
34197516:	623b      	str	r3, [r7, #32]
34197518:	627a      	str	r2, [r7, #36]	@ 0x24
3419751a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3419751e:	17da      	asrs	r2, r3, #31
34197520:	61bb      	str	r3, [r7, #24]
34197522:	61fa      	str	r2, [r7, #28]
34197524:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
34197528:	462b      	mov	r3, r5
3419752a:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
3419752e:	4642      	mov	r2, r8
34197530:	fb02 f203 	mul.w	r2, r2, r3
34197534:	464b      	mov	r3, r9
34197536:	4621      	mov	r1, r4
34197538:	fb01 f303 	mul.w	r3, r1, r3
3419753c:	4413      	add	r3, r2
3419753e:	4622      	mov	r2, r4
34197540:	4641      	mov	r1, r8
34197542:	fba2 1201 	umull	r1, r2, r2, r1
34197546:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
3419754a:	460a      	mov	r2, r1
3419754c:	f8c7 20b0 	str.w	r2, [r7, #176]	@ 0xb0
34197550:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
34197554:	4413      	add	r3, r2
34197556:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3419755a:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
3419755e:	4623      	mov	r3, r4
34197560:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34197564:	4602      	mov	r2, r0
34197566:	189b      	adds	r3, r3, r2
34197568:	603b      	str	r3, [r7, #0]
3419756a:	460b      	mov	r3, r1
3419756c:	462a      	mov	r2, r5
3419756e:	eb42 0303 	adc.w	r3, r2, r3
34197572:	607b      	str	r3, [r7, #4]
34197574:	e9d7 2300 	ldrd	r2, r3, [r7]
34197578:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    ccR /= ISP_CCM_PRECISION_FACTOR;
3419757c:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34197580:	a343      	add	r3, pc, #268	@ (adr r3, 34197690 <ISP_Algo_ApplyCConv+0x488>)
34197582:	e9d3 2300 	ldrd	r2, r3, [r3]
34197586:	f7ea f8d9 	bl	3418173c <__aeabi_ldivmod>
3419758a:	4602      	mov	r2, r0
3419758c:	460b      	mov	r3, r1
3419758e:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG /= ISP_CCM_PRECISION_FACTOR;
34197592:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34197596:	a33e      	add	r3, pc, #248	@ (adr r3, 34197690 <ISP_Algo_ApplyCConv+0x488>)
34197598:	e9d3 2300 	ldrd	r2, r3, [r3]
3419759c:	f7ea f8ce 	bl	3418173c <__aeabi_ldivmod>
341975a0:	4602      	mov	r2, r0
341975a2:	460b      	mov	r3, r1
341975a4:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB /= ISP_CCM_PRECISION_FACTOR;
341975a8:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
341975ac:	a338      	add	r3, pc, #224	@ (adr r3, 34197690 <ISP_Algo_ApplyCConv+0x488>)
341975ae:	e9d3 2300 	ldrd	r2, r3, [r3]
341975b2:	f7ea f8c3 	bl	3418173c <__aeabi_ldivmod>
341975b6:	4602      	mov	r2, r0
341975b8:	460b      	mov	r3, r1
341975ba:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    /* Clamp values to 0-255 */
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
341975be:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
341975c2:	2b00      	cmp	r3, #0
341975c4:	db0b      	blt.n	341975de <ISP_Algo_ApplyCConv+0x3d6>
341975c6:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
341975ca:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
341975ce:	f173 0100 	sbcs.w	r1, r3, #0
341975d2:	db08      	blt.n	341975e6 <ISP_Algo_ApplyCConv+0x3de>
341975d4:	f04f 02ff 	mov.w	r2, #255	@ 0xff
341975d8:	f04f 0300 	mov.w	r3, #0
341975dc:	e003      	b.n	341975e6 <ISP_Algo_ApplyCConv+0x3de>
341975de:	f04f 0200 	mov.w	r2, #0
341975e2:	f04f 0300 	mov.w	r3, #0
341975e6:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
341975ea:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
341975ee:	2b00      	cmp	r3, #0
341975f0:	db0b      	blt.n	3419760a <ISP_Algo_ApplyCConv+0x402>
341975f2:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
341975f6:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
341975fa:	f173 0100 	sbcs.w	r1, r3, #0
341975fe:	db08      	blt.n	34197612 <ISP_Algo_ApplyCConv+0x40a>
34197600:	f04f 02ff 	mov.w	r2, #255	@ 0xff
34197604:	f04f 0300 	mov.w	r3, #0
34197608:	e003      	b.n	34197612 <ISP_Algo_ApplyCConv+0x40a>
3419760a:	f04f 0200 	mov.w	r2, #0
3419760e:	f04f 0300 	mov.w	r3, #0
34197612:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
34197616:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
3419761a:	2b00      	cmp	r3, #0
3419761c:	db0b      	blt.n	34197636 <ISP_Algo_ApplyCConv+0x42e>
3419761e:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
34197622:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
34197626:	f173 0100 	sbcs.w	r1, r3, #0
3419762a:	db08      	blt.n	3419763e <ISP_Algo_ApplyCConv+0x436>
3419762c:	f04f 02ff 	mov.w	r2, #255	@ 0xff
34197630:	f04f 0300 	mov.w	r3, #0
34197634:	e003      	b.n	3419763e <ISP_Algo_ApplyCConv+0x436>
34197636:	f04f 0200 	mov.w	r2, #0
3419763a:	f04f 0300 	mov.w	r3, #0
3419763e:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    *outR = (uint32_t) ccR;
34197642:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
34197646:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
3419764a:	601a      	str	r2, [r3, #0]
    *outG = (uint32_t) ccG;
3419764c:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
34197650:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
34197654:	601a      	str	r2, [r3, #0]
    *outB = (uint32_t) ccB;
34197656:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
3419765a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
3419765e:	601a      	str	r2, [r3, #0]
34197660:	e00f      	b.n	34197682 <ISP_Algo_ApplyCConv+0x47a>
  }
  else
  {
    *outR = inR;
34197662:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
34197666:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
3419766a:	601a      	str	r2, [r3, #0]
    *outG = inG;
3419766c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
34197670:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
34197674:	601a      	str	r2, [r3, #0]
    *outB = inB;
34197676:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
3419767a:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
3419767e:	601a      	str	r2, [r3, #0]
  }
}
34197680:	bf00      	nop
34197682:	bf00      	nop
34197684:	f507 77a0 	add.w	r7, r7, #320	@ 0x140
34197688:	46bd      	mov	sp, r7
3419768a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3419768e:	bf00      	nop
34197690:	05f5e100 	.word	0x05f5e100
34197694:	00000000 	.word	0x00000000

34197698 <ISP_Algo_AWB_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Init(void *hIsp, void *pAlgo)
{
34197698:	b580      	push	{r7, lr}
3419769a:	b084      	sub	sp, #16
3419769c:	af00      	add	r7, sp, #0
3419769e:	6078      	str	r0, [r7, #4]
341976a0:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
341976a2:	683b      	ldr	r3, [r7, #0]
341976a4:	60fb      	str	r3, [r7, #12]

  /* Create estimator */
  pIspAWBestimator = evision_api_awb_new(log_cb);
341976a6:	480a      	ldr	r0, [pc, #40]	@ (341976d0 <ISP_Algo_AWB_Init+0x38>)
341976a8:	f7e9 fae5 	bl	34180c76 <evision_api_awb_new>
341976ac:	4603      	mov	r3, r0
341976ae:	4a09      	ldr	r2, [pc, #36]	@ (341976d4 <ISP_Algo_AWB_Init+0x3c>)
341976b0:	6013      	str	r3, [r2, #0]
  if (pIspAWBestimator == NULL)
341976b2:	4b08      	ldr	r3, [pc, #32]	@ (341976d4 <ISP_Algo_AWB_Init+0x3c>)
341976b4:	681b      	ldr	r3, [r3, #0]
341976b6:	2b00      	cmp	r3, #0
341976b8:	d101      	bne.n	341976be <ISP_Algo_AWB_Init+0x26>
  {
    return ISP_ERR_ALGO;
341976ba:	23be      	movs	r3, #190	@ 0xbe
341976bc:	e003      	b.n	341976c6 <ISP_Algo_AWB_Init+0x2e>
  }

  /* Continue the initialization in ISP_Algo_AWB_Process() function when state is ISP_ALGO_STATE_INIT.
   * This allows to read the IQ params after an algo stop/start cycle */
  algo->state = ISP_ALGO_STATE_INIT;
341976be:	68fb      	ldr	r3, [r7, #12]
341976c0:	2200      	movs	r2, #0
341976c2:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
341976c4:	2300      	movs	r3, #0
}
341976c6:	4618      	mov	r0, r3
341976c8:	3710      	adds	r7, #16
341976ca:	46bd      	mov	sp, r7
341976cc:	bd80      	pop	{r7, pc}
341976ce:	bf00      	nop
341976d0:	34196c25 	.word	0x34196c25
341976d4:	341c11a8 	.word	0x341c11a8

341976d8 <ISP_Algo_AWB_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_DeInit(void *hIsp, void *pAlgo)
{
341976d8:	b580      	push	{r7, lr}
341976da:	b082      	sub	sp, #8
341976dc:	af00      	add	r7, sp, #0
341976de:	6078      	str	r0, [r7, #4]
341976e0:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAWBestimator != NULL)
341976e2:	4b07      	ldr	r3, [pc, #28]	@ (34197700 <ISP_Algo_AWB_DeInit+0x28>)
341976e4:	681b      	ldr	r3, [r3, #0]
341976e6:	2b00      	cmp	r3, #0
341976e8:	d004      	beq.n	341976f4 <ISP_Algo_AWB_DeInit+0x1c>
  {
    evision_api_awb_delete(pIspAWBestimator);
341976ea:	4b05      	ldr	r3, [pc, #20]	@ (34197700 <ISP_Algo_AWB_DeInit+0x28>)
341976ec:	681b      	ldr	r3, [r3, #0]
341976ee:	4618      	mov	r0, r3
341976f0:	f7e9 fadc 	bl	34180cac <evision_api_awb_delete>
  }

  return ISP_OK;
341976f4:	2300      	movs	r3, #0
}
341976f6:	4618      	mov	r0, r3
341976f8:	3708      	adds	r7, #8
341976fa:	46bd      	mov	sp, r7
341976fc:	bd80      	pop	{r7, pc}
341976fe:	bf00      	nop
34197700:	341c11a8 	.word	0x341c11a8

34197704 <ISP_Algo_AWB_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
34197704:	b480      	push	{r7}
34197706:	b083      	sub	sp, #12
34197708:	af00      	add	r7, sp, #0
3419770a:	6078      	str	r0, [r7, #4]
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
3419770c:	687b      	ldr	r3, [r7, #4]
3419770e:	785b      	ldrb	r3, [r3, #1]
34197710:	2b00      	cmp	r3, #0
34197712:	d002      	beq.n	3419771a <ISP_Algo_AWB_StatCb+0x16>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
34197714:	687b      	ldr	r3, [r7, #4]
34197716:	2203      	movs	r2, #3
34197718:	705a      	strb	r2, [r3, #1]
  }

  return ISP_OK;
3419771a:	2300      	movs	r3, #0
}
3419771c:	4618      	mov	r0, r3
3419771e:	370c      	adds	r7, #12
34197720:	46bd      	mov	sp, r7
34197722:	f85d 7b04 	ldr.w	r7, [sp], #4
34197726:	4770      	bx	lr

34197728 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
34197728:	b580      	push	{r7, lr}
3419772a:	b0b8      	sub	sp, #224	@ 0xe0
3419772c:	af04      	add	r7, sp, #16
3419772e:	6078      	str	r0, [r7, #4]
34197730:	6039      	str	r1, [r7, #0]
  static evision_awb_profile_t awbProfiles[ISP_AWB_COLORTEMP_REF];
  static float colorTempThresholds[ISP_AWB_COLORTEMP_REF - 1];
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_ColorConvTypeDef ColorConvConfig;
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34197732:	683b      	ldr	r3, [r7, #0]
34197734:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
34197738:	2300      	movs	r3, #0
3419773a:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
3419773e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34197742:	2200      	movs	r2, #0
34197744:	601a      	str	r2, [r3, #0]
34197746:	605a      	str	r2, [r3, #4]
34197748:	609a      	str	r2, [r3, #8]
  double meas[3];
  static uint32_t statsHistory[3][3] = { 0 };
  static uint32_t colorTempHistory[2] = { 0 };
  static uint8_t skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_INIT;
  uint8_t stat_has_changed = false;
3419774a:	2300      	movs	r3, #0
3419774c:	f887 30bb 	strb.w	r3, [r7, #187]	@ 0xbb

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34197750:	6878      	ldr	r0, [r7, #4]
34197752:	f002 f8f5 	bl	34199940 <ISP_SVC_IQParam_Get>
34197756:	f8c7 00b0 	str.w	r0, [r7, #176]	@ 0xb0

  if (IQParamConfig->AWBAlgo.enable == false)
3419775a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3419775e:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
34197762:	2b00      	cmp	r3, #0
34197764:	d104      	bne.n	34197770 <ISP_Algo_AWB_Process+0x48>
  {
    enableCurrent = false;
34197766:	4bcc      	ldr	r3, [pc, #816]	@ (34197a98 <ISP_Algo_AWB_Process+0x370>)
34197768:	2200      	movs	r2, #0
3419776a:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
3419776c:	2300      	movs	r3, #0
3419776e:	e3a6      	b.n	34197ebe <ISP_Algo_AWB_Process+0x796>
  }
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
34197770:	4bc9      	ldr	r3, [pc, #804]	@ (34197a98 <ISP_Algo_AWB_Process+0x370>)
34197772:	781b      	ldrb	r3, [r3, #0]
34197774:	2b00      	cmp	r3, #0
34197776:	d005      	beq.n	34197784 <ISP_Algo_AWB_Process+0x5c>
34197778:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3419777c:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
34197780:	2bff      	cmp	r3, #255	@ 0xff
34197782:	d111      	bne.n	341977a8 <ISP_Algo_AWB_Process+0x80>
  {
    /* Start or resume algo : set state to INIT in order to read the IQ params */
    algo->state = ISP_ALGO_STATE_INIT;
34197784:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34197788:	2200      	movs	r2, #0
3419778a:	705a      	strb	r2, [r3, #1]
    IQParamConfig->AWBAlgo.enable = true;
3419778c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
34197790:	2201      	movs	r2, #1
34197792:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
    reconfigureRequest = true;
34197796:	4bc1      	ldr	r3, [pc, #772]	@ (34197a9c <ISP_Algo_AWB_Process+0x374>)
34197798:	2201      	movs	r2, #1
3419779a:	701a      	strb	r2, [r3, #0]
    enableCurrent = true;
3419779c:	4bbe      	ldr	r3, [pc, #760]	@ (34197a98 <ISP_Algo_AWB_Process+0x370>)
3419779e:	2201      	movs	r2, #1
341977a0:	701a      	strb	r2, [r3, #0]
    skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
341977a2:	4bbf      	ldr	r3, [pc, #764]	@ (34197aa0 <ISP_Algo_AWB_Process+0x378>)
341977a4:	2206      	movs	r2, #6
341977a6:	701a      	strb	r2, [r3, #0]
  }

  switch(algo->state)
341977a8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
341977ac:	785b      	ldrb	r3, [r3, #1]
341977ae:	2b03      	cmp	r3, #3
341977b0:	f200 837a 	bhi.w	34197ea8 <ISP_Algo_AWB_Process+0x780>
341977b4:	a201      	add	r2, pc, #4	@ (adr r2, 341977bc <ISP_Algo_AWB_Process+0x94>)
341977b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341977ba:	bf00      	nop
341977bc:	341977cd 	.word	0x341977cd
341977c0:	34197ac5 	.word	0x34197ac5
341977c4:	34197eb9 	.word	0x34197eb9
341977c8:	34197afb 	.word	0x34197afb
  {
  case ISP_ALGO_STATE_INIT:
    profNb = 0;
341977cc:	2300      	movs	r3, #0
341977ce:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

    /* Reset color temperature history */
    for (i = 0; i < 2; i++)
341977d2:	2300      	movs	r3, #0
341977d4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
341977d8:	e00a      	b.n	341977f0 <ISP_Algo_AWB_Process+0xc8>
    {
      colorTempHistory[i] = 0;
341977da:	4ab2      	ldr	r2, [pc, #712]	@ (34197aa4 <ISP_Algo_AWB_Process+0x37c>)
341977dc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
341977e0:	2100      	movs	r1, #0
341977e2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (i = 0; i < 2; i++)
341977e6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
341977ea:	3301      	adds	r3, #1
341977ec:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
341977f0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
341977f4:	2b01      	cmp	r3, #1
341977f6:	d9f0      	bls.n	341977da <ISP_Algo_AWB_Process+0xb2>
    }

    /* Set profiles (color temperature, gains, color conv matrix) */
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
341977f8:	2300      	movs	r3, #0
341977fa:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
341977fe:	e0cc      	b.n	3419799a <ISP_Algo_AWB_Process+0x272>
    {
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
34197800:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197804:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197808:	3344      	adds	r3, #68	@ 0x44
3419780a:	009b      	lsls	r3, r3, #2
3419780c:	4413      	add	r3, r2
3419780e:	689b      	ldr	r3, [r3, #8]
34197810:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
      if (colorTemp == 0)
34197814:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
34197818:	2b00      	cmp	r3, #0
3419781a:	f000 80c4 	beq.w	341979a6 <ISP_Algo_AWB_Process+0x27e>
        break;

      if (profNb > 0)
3419781e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34197822:	2b00      	cmp	r3, #0
34197824:	d01b      	beq.n	3419785e <ISP_Algo_AWB_Process+0x136>
      {
        /* Profile decision threshold = lowest ref. temperature + 1/4 of the distance between two reference temperatures */
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
34197826:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3419782a:	3b01      	subs	r3, #1
3419782c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197830:	3344      	adds	r3, #68	@ 0x44
34197832:	009b      	lsls	r3, r3, #2
34197834:	4413      	add	r3, r2
34197836:	689a      	ldr	r2, [r3, #8]
34197838:	4613      	mov	r3, r2
3419783a:	005b      	lsls	r3, r3, #1
3419783c:	441a      	add	r2, r3
3419783e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
34197842:	4413      	add	r3, r2
34197844:	089a      	lsrs	r2, r3, #2
34197846:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
3419784a:	3b01      	subs	r3, #1
3419784c:	ee07 2a90 	vmov	s15, r2
34197850:	eef8 7a67 	vcvt.f32.u32	s15, s15
34197854:	4a94      	ldr	r2, [pc, #592]	@ (34197aa8 <ISP_Algo_AWB_Process+0x380>)
34197856:	009b      	lsls	r3, r3, #2
34197858:	4413      	add	r3, r2
3419785a:	edc3 7a00 	vstr	s15, [r3]
      }

      /* Set cfa gains (RGGB) */
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
3419785e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197862:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197866:	334a      	adds	r3, #74	@ 0x4a
34197868:	009b      	lsls	r3, r3, #2
3419786a:	4413      	add	r3, r2
3419786c:	685b      	ldr	r3, [r3, #4]
3419786e:	ee07 3a90 	vmov	s15, r3
34197872:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34197876:	eddf 6a8d 	vldr	s13, [pc, #564]	@ 34197aac <ISP_Algo_AWB_Process+0x384>
3419787a:	eec7 7a26 	vdiv.f32	s15, s14, s13
3419787e:	edc7 7a15 	vstr	s15, [r7, #84]	@ 0x54
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34197882:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197886:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3419788a:	334e      	adds	r3, #78	@ 0x4e
3419788c:	009b      	lsls	r3, r3, #2
3419788e:	4413      	add	r3, r2
34197890:	689b      	ldr	r3, [r3, #8]
34197892:	ee07 3a90 	vmov	s15, r3
34197896:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419789a:	eddf 6a84 	vldr	s13, [pc, #528]	@ 34197aac <ISP_Algo_AWB_Process+0x384>
3419789e:	eec7 7a26 	vdiv.f32	s15, s14, s13
341978a2:	edc7 7a16 	vstr	s15, [r7, #88]	@ 0x58
      cfaGains[2] = cfaGains[1];
341978a6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
341978a8:	65fb      	str	r3, [r7, #92]	@ 0x5c
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
341978aa:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
341978ae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
341978b2:	3354      	adds	r3, #84	@ 0x54
341978b4:	009b      	lsls	r3, r3, #2
341978b6:	4413      	add	r3, r2
341978b8:	685b      	ldr	r3, [r3, #4]
341978ba:	ee07 3a90 	vmov	s15, r3
341978be:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341978c2:	eddf 6a7a 	vldr	s13, [pc, #488]	@ 34197aac <ISP_Algo_AWB_Process+0x384>
341978c6:	eec7 7a26 	vdiv.f32	s15, s14, s13
341978ca:	edc7 7a18 	vstr	s15, [r7, #96]	@ 0x60

      /* Set CCM Coeff */
      for (i = 0; i < 3; i++)
341978ce:	2300      	movs	r3, #0
341978d0:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
341978d4:	e03b      	b.n	3419794e <ISP_Algo_AWB_Process+0x226>
      {
        for (j = 0; j < 3; j++)
341978d6:	2300      	movs	r3, #0
341978d8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
341978dc:	e02e      	b.n	3419793c <ISP_Algo_AWB_Process+0x214>
        {
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
341978de:	f8d7 00b0 	ldr.w	r0, [r7, #176]	@ 0xb0
341978e2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
341978e6:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
341978ea:	461a      	mov	r2, r3
341978ec:	0052      	lsls	r2, r2, #1
341978ee:	441a      	add	r2, r3
341978f0:	460b      	mov	r3, r1
341978f2:	00db      	lsls	r3, r3, #3
341978f4:	440b      	add	r3, r1
341978f6:	441a      	add	r2, r3
341978f8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
341978fc:	4413      	add	r3, r2
341978fe:	3358      	adds	r3, #88	@ 0x58
34197900:	009b      	lsls	r3, r3, #2
34197902:	4403      	add	r3, r0
34197904:	689b      	ldr	r3, [r3, #8]
34197906:	ee07 3a90 	vmov	s15, r3
3419790a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419790e:	eddf 6a67 	vldr	s13, [pc, #412]	@ 34197aac <ISP_Algo_AWB_Process+0x384>
34197912:	eec7 7a26 	vdiv.f32	s15, s14, s13
34197916:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
3419791a:	4613      	mov	r3, r2
3419791c:	005b      	lsls	r3, r3, #1
3419791e:	4413      	add	r3, r2
34197920:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
34197924:	4413      	add	r3, r2
34197926:	009b      	lsls	r3, r3, #2
34197928:	33d0      	adds	r3, #208	@ 0xd0
3419792a:	443b      	add	r3, r7
3419792c:	3ba0      	subs	r3, #160	@ 0xa0
3419792e:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < 3; j++)
34197932:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
34197936:	3301      	adds	r3, #1
34197938:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3419793c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
34197940:	2b02      	cmp	r3, #2
34197942:	d9cc      	bls.n	341978de <ISP_Algo_AWB_Process+0x1b6>
      for (i = 0; i < 3; i++)
34197944:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34197948:	3301      	adds	r3, #1
3419794a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3419794e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34197952:	2b02      	cmp	r3, #2
34197954:	d9bf      	bls.n	341978d6 <ISP_Algo_AWB_Process+0x1ae>
        }
      }

      /* Set profile */
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34197956:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
3419795a:	4613      	mov	r3, r2
3419795c:	011b      	lsls	r3, r3, #4
3419795e:	4413      	add	r3, r2
34197960:	009b      	lsls	r3, r3, #2
34197962:	4a53      	ldr	r2, [pc, #332]	@ (34197ab0 <ISP_Algo_AWB_Process+0x388>)
34197964:	1898      	adds	r0, r3, r2
34197966:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
3419796a:	ee07 3a90 	vmov	s15, r3
3419796e:	eef8 7a67 	vcvt.f32.u32	s15, s15
34197972:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34197976:	f107 0230 	add.w	r2, r7, #48	@ 0x30
3419797a:	f107 0154 	add.w	r1, r7, #84	@ 0x54
3419797e:	eeb0 0a67 	vmov.f32	s0, s15
34197982:	f7e9 f999 	bl	34180cb8 <evision_api_awb_set_profile>
      profNb++;
34197986:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
3419798a:	3301      	adds	r3, #1
3419798c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34197990:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197994:	3301      	adds	r3, #1
34197996:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3419799a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3419799e:	2b04      	cmp	r3, #4
341979a0:	f67f af2e 	bls.w	34197800 <ISP_Algo_AWB_Process+0xd8>
341979a4:	e000      	b.n	341979a8 <ISP_Algo_AWB_Process+0x280>
        break;
341979a6:	bf00      	nop
    }

    if (profNb == 0)
341979a8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
341979ac:	2b00      	cmp	r3, #0
341979ae:	d101      	bne.n	341979b4 <ISP_Algo_AWB_Process+0x28c>
    {
      return ISP_ERR_WB_COLORTEMP;
341979b0:	2396      	movs	r3, #150	@ 0x96
341979b2:	e284      	b.n	34197ebe <ISP_Algo_AWB_Process+0x796>
    }

    /* Register profiles */
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
341979b4:	4b3f      	ldr	r3, [pc, #252]	@ (34197ab4 <ISP_Algo_AWB_Process+0x38c>)
341979b6:	6818      	ldr	r0, [r3, #0]
341979b8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
341979bc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
341979c0:	ee07 3a90 	vmov	s15, r3
341979c4:	eeb8 7b67 	vcvt.f64.u32	d7, s15
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], (uint16_t)profNb,
341979c8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
341979cc:	3b01      	subs	r3, #1
341979ce:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
341979d2:	3344      	adds	r3, #68	@ 0x44
341979d4:	009b      	lsls	r3, r3, #2
341979d6:	4413      	add	r3, r2
341979d8:	689b      	ldr	r3, [r3, #8]
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
341979da:	ee06 3a90 	vmov	s13, r3
341979de:	eeb8 6b66 	vcvt.f64.u32	d6, s13
341979e2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
341979e6:	b299      	uxth	r1, r3
341979e8:	4b31      	ldr	r3, [pc, #196]	@ (34197ab0 <ISP_Algo_AWB_Process+0x388>)
341979ea:	4a2f      	ldr	r2, [pc, #188]	@ (34197aa8 <ISP_Algo_AWB_Process+0x380>)
341979ec:	eeb0 1b46 	vmov.f64	d1, d6
341979f0:	eeb0 0b47 	vmov.f64	d0, d7
341979f4:	f7e9 f980 	bl	34180cf8 <evision_api_awb_init_profiles>
341979f8:	4603      	mov	r3, r0
341979fa:	f887 30af 	strb.w	r3, [r7, #175]	@ 0xaf
                                          colorTempThresholds, awbProfiles);
    if (e_ret != EVISION_RET_SUCCESS)
341979fe:	f997 30af 	ldrsb.w	r3, [r7, #175]	@ 0xaf
34197a02:	2b01      	cmp	r3, #1
34197a04:	d001      	beq.n	34197a0a <ISP_Algo_AWB_Process+0x2e2>
    {
      return ISP_ERR_ALGO;
34197a06:	23be      	movs	r3, #190	@ 0xbe
34197a08:	e259      	b.n	34197ebe <ISP_Algo_AWB_Process+0x796>
    }

    /* Configure algo */
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34197a0a:	4b2a      	ldr	r3, [pc, #168]	@ (34197ab4 <ISP_Algo_AWB_Process+0x38c>)
34197a0c:	6819      	ldr	r1, [r3, #0]
34197a0e:	a31e      	add	r3, pc, #120	@ (adr r3, 34197a88 <ISP_Algo_AWB_Process+0x360>)
34197a10:	e9d3 2300 	ldrd	r2, r3, [r3]
34197a14:	e9c1 23a6 	strd	r2, r3, [r1, #664]	@ 0x298
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34197a18:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34197a1c:	2b03      	cmp	r3, #3
34197a1e:	d803      	bhi.n	34197a28 <ISP_Algo_AWB_Process+0x300>
34197a20:	a31b      	add	r3, pc, #108	@ (adr r3, 34197a90 <ISP_Algo_AWB_Process+0x368>)
34197a22:	e9d3 2300 	ldrd	r2, r3, [r3]
34197a26:	e003      	b.n	34197a30 <ISP_Algo_AWB_Process+0x308>
34197a28:	f04f 0200 	mov.w	r2, #0
34197a2c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
34197a30:	4920      	ldr	r1, [pc, #128]	@ (34197ab4 <ISP_Algo_AWB_Process+0x38c>)
34197a32:	6809      	ldr	r1, [r1, #0]
34197a34:	e9c1 23a8 	strd	r2, r3, [r1, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34197a38:	4b1e      	ldr	r3, [pc, #120]	@ (34197ab4 <ISP_Algo_AWB_Process+0x38c>)
34197a3a:	681b      	ldr	r3, [r3, #0]
34197a3c:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
34197a40:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34197a44:	4b1b      	ldr	r3, [pc, #108]	@ (34197ab4 <ISP_Algo_AWB_Process+0x38c>)
34197a46:	681b      	ldr	r3, [r3, #0]
34197a48:	4a1b      	ldr	r2, [pc, #108]	@ (34197ab8 <ISP_Algo_AWB_Process+0x390>)
34197a4a:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34197a4e:	2305      	movs	r3, #5
34197a50:	9302      	str	r3, [sp, #8]
34197a52:	2301      	movs	r3, #1
34197a54:	9301      	str	r3, [sp, #4]
34197a56:	2302      	movs	r3, #2
34197a58:	9300      	str	r3, [sp, #0]
34197a5a:	4b18      	ldr	r3, [pc, #96]	@ (34197abc <ISP_Algo_AWB_Process+0x394>)
34197a5c:	683a      	ldr	r2, [r7, #0]
34197a5e:	4918      	ldr	r1, [pc, #96]	@ (34197ac0 <ISP_Algo_AWB_Process+0x398>)
34197a60:	6878      	ldr	r0, [r7, #4]
34197a62:	f002 fad3 	bl	3419a00c <ISP_SVC_Stats_GetNext>
34197a66:	4603      	mov	r3, r0
34197a68:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
34197a6c:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197a70:	2b00      	cmp	r3, #0
34197a72:	d002      	beq.n	34197a7a <ISP_Algo_AWB_Process+0x352>
    {
      return ret;
34197a74:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197a78:	e221      	b.n	34197ebe <ISP_Algo_AWB_Process+0x796>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34197a7a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34197a7e:	2202      	movs	r2, #2
34197a80:	705a      	strb	r2, [r3, #1]
    break;
34197a82:	e21a      	b.n	34197eba <ISP_Algo_AWB_Process+0x792>
34197a84:	f3af 8000 	nop.w
34197a88:	9999999a 	.word	0x9999999a
34197a8c:	3ff59999 	.word	0x3ff59999
34197a90:	cccccccd 	.word	0xcccccccd
34197a94:	3ffccccc 	.word	0x3ffccccc
34197a98:	341c1248 	.word	0x341c1248
34197a9c:	341c1249 	.word	0x341c1249
34197aa0:	341c00f0 	.word	0x341c00f0
34197aa4:	341c124c 	.word	0x341c124c
34197aa8:	341c1254 	.word	0x341c1254
34197aac:	4cbebc20 	.word	0x4cbebc20
34197ab0:	341c1264 	.word	0x341c1264
34197ab4:	341c11a8 	.word	0x341c11a8
34197ab8:	40400000 	.word	0x40400000
34197abc:	341c13b8 	.word	0x341c13b8
34197ac0:	34197705 	.word	0x34197705

  case ISP_ALGO_STATE_NEED_STAT:
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34197ac4:	2305      	movs	r3, #5
34197ac6:	9302      	str	r3, [sp, #8]
34197ac8:	2301      	movs	r3, #1
34197aca:	9301      	str	r3, [sp, #4]
34197acc:	2302      	movs	r3, #2
34197ace:	9300      	str	r3, [sp, #0]
34197ad0:	4b94      	ldr	r3, [pc, #592]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197ad2:	683a      	ldr	r2, [r7, #0]
34197ad4:	4994      	ldr	r1, [pc, #592]	@ (34197d28 <ISP_Algo_AWB_Process+0x600>)
34197ad6:	6878      	ldr	r0, [r7, #4]
34197ad8:	f002 fa98 	bl	3419a00c <ISP_SVC_Stats_GetNext>
34197adc:	4603      	mov	r3, r0
34197ade:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
34197ae2:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197ae6:	2b00      	cmp	r3, #0
34197ae8:	d002      	beq.n	34197af0 <ISP_Algo_AWB_Process+0x3c8>
    {
      return ret;
34197aea:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197aee:	e1e6      	b.n	34197ebe <ISP_Algo_AWB_Process+0x796>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34197af0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34197af4:	2202      	movs	r2, #2
34197af6:	705a      	strb	r2, [r3, #1]
    break;
34197af8:	e1df      	b.n	34197eba <ISP_Algo_AWB_Process+0x792>
  case ISP_ALGO_STATE_WAITING_STAT:
    /* Do nothing */
    break;

  case ISP_ALGO_STATE_STAT_READY:
    ISP_Algo_GetUpStat(hIsp, &stats);
34197afa:	498a      	ldr	r1, [pc, #552]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197afc:	6878      	ldr	r0, [r7, #4]
34197afe:	f7ff fab1 	bl	34197064 <ISP_Algo_GetUpStat>

    for (i = 0; i < 3; i++)
34197b02:	2300      	movs	r3, #0
34197b04:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34197b08:	e03f      	b.n	34197b8a <ISP_Algo_AWB_Process+0x462>
    {
      if ((abs(stats.up.averageR - (int32_t)statsHistory[i][0]) > 2)
34197b0a:	4b86      	ldr	r3, [pc, #536]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197b0c:	781b      	ldrb	r3, [r3, #0]
34197b0e:	4618      	mov	r0, r3
34197b10:	4986      	ldr	r1, [pc, #536]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197b12:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34197b16:	4613      	mov	r3, r2
34197b18:	005b      	lsls	r3, r3, #1
34197b1a:	4413      	add	r3, r2
34197b1c:	009b      	lsls	r3, r3, #2
34197b1e:	440b      	add	r3, r1
34197b20:	681b      	ldr	r3, [r3, #0]
34197b22:	1ac3      	subs	r3, r0, r3
34197b24:	2b00      	cmp	r3, #0
34197b26:	bfb8      	it	lt
34197b28:	425b      	neglt	r3, r3
34197b2a:	2b02      	cmp	r3, #2
34197b2c:	dc25      	bgt.n	34197b7a <ISP_Algo_AWB_Process+0x452>
          || (abs(stats.up.averageG - (int32_t)statsHistory[i][1]) > 2)
34197b2e:	4b7d      	ldr	r3, [pc, #500]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197b30:	785b      	ldrb	r3, [r3, #1]
34197b32:	4618      	mov	r0, r3
34197b34:	497d      	ldr	r1, [pc, #500]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197b36:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34197b3a:	4613      	mov	r3, r2
34197b3c:	005b      	lsls	r3, r3, #1
34197b3e:	4413      	add	r3, r2
34197b40:	009b      	lsls	r3, r3, #2
34197b42:	440b      	add	r3, r1
34197b44:	3304      	adds	r3, #4
34197b46:	681b      	ldr	r3, [r3, #0]
34197b48:	1ac3      	subs	r3, r0, r3
34197b4a:	2b00      	cmp	r3, #0
34197b4c:	bfb8      	it	lt
34197b4e:	425b      	neglt	r3, r3
34197b50:	2b02      	cmp	r3, #2
34197b52:	dc12      	bgt.n	34197b7a <ISP_Algo_AWB_Process+0x452>
          || (abs(stats.up.averageB - (int32_t)statsHistory[i][2]) > 2))
34197b54:	4b73      	ldr	r3, [pc, #460]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197b56:	789b      	ldrb	r3, [r3, #2]
34197b58:	4618      	mov	r0, r3
34197b5a:	4974      	ldr	r1, [pc, #464]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197b5c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34197b60:	4613      	mov	r3, r2
34197b62:	005b      	lsls	r3, r3, #1
34197b64:	4413      	add	r3, r2
34197b66:	009b      	lsls	r3, r3, #2
34197b68:	440b      	add	r3, r1
34197b6a:	3308      	adds	r3, #8
34197b6c:	681b      	ldr	r3, [r3, #0]
34197b6e:	1ac3      	subs	r3, r0, r3
34197b70:	2b00      	cmp	r3, #0
34197b72:	bfb8      	it	lt
34197b74:	425b      	neglt	r3, r3
34197b76:	2b02      	cmp	r3, #2
34197b78:	dd02      	ble.n	34197b80 <ISP_Algo_AWB_Process+0x458>
      {
        stat_has_changed = true;
34197b7a:	2301      	movs	r3, #1
34197b7c:	f887 30bb 	strb.w	r3, [r7, #187]	@ 0xbb
    for (i = 0; i < 3; i++)
34197b80:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34197b84:	3301      	adds	r3, #1
34197b86:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34197b8a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34197b8e:	2b02      	cmp	r3, #2
34197b90:	d9bb      	bls.n	34197b0a <ISP_Algo_AWB_Process+0x3e2>
      }
    }

    if (skip_stat_check_count || stat_has_changed || reconfigureRequest)
34197b92:	4b67      	ldr	r3, [pc, #412]	@ (34197d30 <ISP_Algo_AWB_Process+0x608>)
34197b94:	781b      	ldrb	r3, [r3, #0]
34197b96:	2b00      	cmp	r3, #0
34197b98:	d108      	bne.n	34197bac <ISP_Algo_AWB_Process+0x484>
34197b9a:	f897 30bb 	ldrb.w	r3, [r7, #187]	@ 0xbb
34197b9e:	2b00      	cmp	r3, #0
34197ba0:	d104      	bne.n	34197bac <ISP_Algo_AWB_Process+0x484>
34197ba2:	4b64      	ldr	r3, [pc, #400]	@ (34197d34 <ISP_Algo_AWB_Process+0x60c>)
34197ba4:	781b      	ldrb	r3, [r3, #0]
34197ba6:	2b00      	cmp	r3, #0
34197ba8:	f000 812f 	beq.w	34197e0a <ISP_Algo_AWB_Process+0x6e2>
    {
        statsHistory[2][0] = stats.up.averageR;
34197bac:	4b5d      	ldr	r3, [pc, #372]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bae:	781b      	ldrb	r3, [r3, #0]
34197bb0:	461a      	mov	r2, r3
34197bb2:	4b5e      	ldr	r3, [pc, #376]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197bb4:	619a      	str	r2, [r3, #24]
        statsHistory[2][1] = stats.up.averageG;
34197bb6:	4b5b      	ldr	r3, [pc, #364]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bb8:	785b      	ldrb	r3, [r3, #1]
34197bba:	461a      	mov	r2, r3
34197bbc:	4b5b      	ldr	r3, [pc, #364]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197bbe:	61da      	str	r2, [r3, #28]
        statsHistory[2][2] = stats.up.averageB;
34197bc0:	4b58      	ldr	r3, [pc, #352]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bc2:	789b      	ldrb	r3, [r3, #2]
34197bc4:	461a      	mov	r2, r3
34197bc6:	4b59      	ldr	r3, [pc, #356]	@ (34197d2c <ISP_Algo_AWB_Process+0x604>)
34197bc8:	621a      	str	r2, [r3, #32]

        /* Get stats after color conversion */
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
34197bca:	4b56      	ldr	r3, [pc, #344]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bcc:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
34197bd0:	4619      	mov	r1, r3
34197bd2:	4b54      	ldr	r3, [pc, #336]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bd4:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34197bd8:	461a      	mov	r2, r3
34197bda:	4b52      	ldr	r3, [pc, #328]	@ (34197d24 <ISP_Algo_AWB_Process+0x5fc>)
34197bdc:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34197be0:	4618      	mov	r0, r3
34197be2:	f107 0364 	add.w	r3, r7, #100	@ 0x64
34197be6:	9302      	str	r3, [sp, #8]
34197be8:	f107 0368 	add.w	r3, r7, #104	@ 0x68
34197bec:	9301      	str	r3, [sp, #4]
34197bee:	f107 036c 	add.w	r3, r7, #108	@ 0x6c
34197bf2:	9300      	str	r3, [sp, #0]
34197bf4:	4603      	mov	r3, r0
34197bf6:	6878      	ldr	r0, [r7, #4]
34197bf8:	f7ff fb06 	bl	34197208 <ISP_Algo_ApplyCConv>

        /* Apply gamma */
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34197bfc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34197bfe:	4619      	mov	r1, r3
34197c00:	6878      	ldr	r0, [r7, #4]
34197c02:	f7ff f9ed 	bl	34196fe0 <ISP_Algo_ApplyGammaInverse>
34197c06:	eeb0 7b40 	vmov.f64	d7, d0
34197c0a:	ed87 7b02 	vstr	d7, [r7, #8]
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34197c0e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34197c10:	4619      	mov	r1, r3
34197c12:	6878      	ldr	r0, [r7, #4]
34197c14:	f7ff f9e4 	bl	34196fe0 <ISP_Algo_ApplyGammaInverse>
34197c18:	eeb0 7b40 	vmov.f64	d7, d0
34197c1c:	ed87 7b04 	vstr	d7, [r7, #16]
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34197c20:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34197c22:	4619      	mov	r1, r3
34197c24:	6878      	ldr	r0, [r7, #4]
34197c26:	f7ff f9db 	bl	34196fe0 <ISP_Algo_ApplyGammaInverse>
34197c2a:	eeb0 7b40 	vmov.f64	d7, d0
34197c2e:	ed87 7b06 	vstr	d7, [r7, #24]

        /* Run algo to estimate gain and color conversion to apply */
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34197c32:	4b41      	ldr	r3, [pc, #260]	@ (34197d38 <ISP_Algo_AWB_Process+0x610>)
34197c34:	6818      	ldr	r0, [r3, #0]
34197c36:	f107 0308 	add.w	r3, r7, #8
34197c3a:	2201      	movs	r2, #1
34197c3c:	2100      	movs	r1, #0
34197c3e:	f7e9 fa25 	bl	3418108c <evision_api_awb_run_average>
34197c42:	4603      	mov	r3, r0
34197c44:	f887 30af 	strb.w	r3, [r7, #175]	@ 0xaf
        if (e_ret == EVISION_RET_SUCCESS)
34197c48:	f997 30af 	ldrsb.w	r3, [r7, #175]	@ 0xaf
34197c4c:	2b01      	cmp	r3, #1
34197c4e:	f040 80d9 	bne.w	34197e04 <ISP_Algo_AWB_Process+0x6dc>
            for (int i = 0; i < ISP_AWB_COLORTEMP_REF; i++) {
              nb_colortemp_change[i] = 0;
            }
          }
#endif
          if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
34197c52:	4b39      	ldr	r3, [pc, #228]	@ (34197d38 <ISP_Algo_AWB_Process+0x610>)
34197c54:	681b      	ldr	r3, [r3, #0]
34197c56:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34197c5a:	4b38      	ldr	r3, [pc, #224]	@ (34197d3c <ISP_Algo_AWB_Process+0x614>)
34197c5c:	681b      	ldr	r3, [r3, #0]
34197c5e:	ee07 3a90 	vmov	s15, r3
34197c62:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34197c66:	eeb4 6b47 	vcmp.f64	d6, d7
34197c6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34197c6e:	d104      	bne.n	34197c7a <ISP_Algo_AWB_Process+0x552>
34197c70:	4b30      	ldr	r3, [pc, #192]	@ (34197d34 <ISP_Algo_AWB_Process+0x60c>)
34197c72:	781b      	ldrb	r3, [r3, #0]
34197c74:	2b01      	cmp	r3, #1
34197c76:	f040 80c8 	bne.w	34197e0a <ISP_Algo_AWB_Process+0x6e2>
          {
#ifdef ALGO_AWB_DBG_LOGS
            printf("Color temperature = %"PRIu32"\r\n", (uint32_t) pIspAWBestimator->out_temp);
#endif
            if ((pIspAWBestimator->out_temp == colorTempHistory[1]) && (reconfigureRequest != true))
34197c7a:	4b2f      	ldr	r3, [pc, #188]	@ (34197d38 <ISP_Algo_AWB_Process+0x610>)
34197c7c:	681b      	ldr	r3, [r3, #0]
34197c7e:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34197c82:	4b2f      	ldr	r3, [pc, #188]	@ (34197d40 <ISP_Algo_AWB_Process+0x618>)
34197c84:	685b      	ldr	r3, [r3, #4]
34197c86:	ee07 3a90 	vmov	s15, r3
34197c8a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34197c8e:	eeb4 6b47 	vcmp.f64	d6, d7
34197c92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34197c96:	d107      	bne.n	34197ca8 <ISP_Algo_AWB_Process+0x580>
34197c98:	4b26      	ldr	r3, [pc, #152]	@ (34197d34 <ISP_Algo_AWB_Process+0x60c>)
34197c9a:	781b      	ldrb	r3, [r3, #0]
34197c9c:	2b01      	cmp	r3, #1
34197c9e:	d003      	beq.n	34197ca8 <ISP_Algo_AWB_Process+0x580>
            {
              skip_stat_check_count = 0; //oscillation detected
34197ca0:	4b23      	ldr	r3, [pc, #140]	@ (34197d30 <ISP_Algo_AWB_Process+0x608>)
34197ca2:	2200      	movs	r2, #0
34197ca4:	701a      	strb	r2, [r3, #0]
34197ca6:	e0b0      	b.n	34197e0a <ISP_Algo_AWB_Process+0x6e2>
            }
            else
            {
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
34197ca8:	4b21      	ldr	r3, [pc, #132]	@ (34197d30 <ISP_Algo_AWB_Process+0x608>)
34197caa:	781b      	ldrb	r3, [r3, #0]
34197cac:	2b06      	cmp	r3, #6
34197cae:	d802      	bhi.n	34197cb6 <ISP_Algo_AWB_Process+0x58e>
34197cb0:	4b1f      	ldr	r3, [pc, #124]	@ (34197d30 <ISP_Algo_AWB_Process+0x608>)
34197cb2:	2206      	movs	r2, #6
34197cb4:	701a      	strb	r2, [r3, #0]

              /* Store meta data */
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
34197cb6:	4b20      	ldr	r3, [pc, #128]	@ (34197d38 <ISP_Algo_AWB_Process+0x610>)
34197cb8:	681b      	ldr	r3, [r3, #0]
34197cba:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
34197cbe:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34197cc2:	ee17 2a90 	vmov	r2, s15
34197cc6:	4b1f      	ldr	r3, [pc, #124]	@ (34197d44 <ISP_Algo_AWB_Process+0x61c>)
34197cc8:	611a      	str	r2, [r3, #16]

              /* Find the index profile for this referenceColorTemp */
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34197cca:	2300      	movs	r3, #0
34197ccc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34197cd0:	e019      	b.n	34197d06 <ISP_Algo_AWB_Process+0x5de>
              {
                if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
34197cd2:	4b19      	ldr	r3, [pc, #100]	@ (34197d38 <ISP_Algo_AWB_Process+0x610>)
34197cd4:	681b      	ldr	r3, [r3, #0]
34197cd6:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34197cda:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197cde:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197ce2:	3344      	adds	r3, #68	@ 0x44
34197ce4:	009b      	lsls	r3, r3, #2
34197ce6:	4413      	add	r3, r2
34197ce8:	689b      	ldr	r3, [r3, #8]
34197cea:	ee07 3a90 	vmov	s15, r3
34197cee:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34197cf2:	eeb4 6b47 	vcmp.f64	d6, d7
34197cf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34197cfa:	d009      	beq.n	34197d10 <ISP_Algo_AWB_Process+0x5e8>
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34197cfc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197d00:	3301      	adds	r3, #1
34197d02:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34197d06:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197d0a:	2b04      	cmp	r3, #4
34197d0c:	d9e1      	bls.n	34197cd2 <ISP_Algo_AWB_Process+0x5aa>
34197d0e:	e000      	b.n	34197d12 <ISP_Algo_AWB_Process+0x5ea>
                  break;
34197d10:	bf00      	nop
              }

              if (profId == ISP_AWB_COLORTEMP_REF)
34197d12:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197d16:	2b05      	cmp	r3, #5
34197d18:	d116      	bne.n	34197d48 <ISP_Algo_AWB_Process+0x620>
              {
                /* Unknown profile */
                ret  = ISP_ERR_WB_COLORTEMP;
34197d1a:	2396      	movs	r3, #150	@ 0x96
34197d1c:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
34197d20:	e073      	b.n	34197e0a <ISP_Algo_AWB_Process+0x6e2>
34197d22:	bf00      	nop
34197d24:	341c13b8 	.word	0x341c13b8
34197d28:	34197705 	.word	0x34197705
34197d2c:	341c1430 	.word	0x341c1430
34197d30:	341c00f0 	.word	0x341c00f0
34197d34:	341c1249 	.word	0x341c1249
34197d38:	341c11a8 	.word	0x341c11a8
34197d3c:	341c1454 	.word	0x341c1454
34197d40:	341c124c 	.word	0x341c124c
34197d44:	341c11b0 	.word	0x341c11b0
              }
              else
              {
                /* Apply Color Conversion */
                ColorConvConfig.enable = 1;
34197d48:	2301      	movs	r3, #1
34197d4a:	f887 3080 	strb.w	r3, [r7, #128]	@ 0x80
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
34197d4e:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
34197d52:	4613      	mov	r3, r2
34197d54:	00db      	lsls	r3, r3, #3
34197d56:	4413      	add	r3, r2
34197d58:	009b      	lsls	r3, r3, #2
34197d5a:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34197d5e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197d62:	4413      	add	r3, r2
34197d64:	f103 0108 	add.w	r1, r3, #8
34197d68:	f107 0380 	add.w	r3, r7, #128	@ 0x80
34197d6c:	3304      	adds	r3, #4
34197d6e:	2224      	movs	r2, #36	@ 0x24
34197d70:	4618      	mov	r0, r3
34197d72:	f00c f892 	bl	341a3e9a <memcpy>
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
34197d76:	f107 0380 	add.w	r3, r7, #128	@ 0x80
34197d7a:	4619      	mov	r1, r3
34197d7c:	6878      	ldr	r0, [r7, #4]
34197d7e:	f001 fb17 	bl	341993b0 <ISP_SVC_ISP_SetColorConv>
34197d82:	4603      	mov	r3, r0
34197d84:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf

                /* Apply gain */
                if (ret == ISP_OK)
34197d88:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197d8c:	2b00      	cmp	r3, #0
34197d8e:	d13c      	bne.n	34197e0a <ISP_Algo_AWB_Process+0x6e2>
                {
                  ISPGainConfig.enable = 1;
34197d90:	2301      	movs	r3, #1
34197d92:	f887 3070 	strb.w	r3, [r7, #112]	@ 0x70
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
34197d96:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197d9a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197d9e:	334a      	adds	r3, #74	@ 0x4a
34197da0:	009b      	lsls	r3, r3, #2
34197da2:	4413      	add	r3, r2
34197da4:	685b      	ldr	r3, [r3, #4]
34197da6:	677b      	str	r3, [r7, #116]	@ 0x74
                  ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
34197da8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197dac:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197db0:	334e      	adds	r3, #78	@ 0x4e
34197db2:	009b      	lsls	r3, r3, #2
34197db4:	4413      	add	r3, r2
34197db6:	689b      	ldr	r3, [r3, #8]
34197db8:	67bb      	str	r3, [r7, #120]	@ 0x78
                  ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
34197dba:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34197dbe:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197dc2:	3354      	adds	r3, #84	@ 0x54
34197dc4:	009b      	lsls	r3, r3, #2
34197dc6:	4413      	add	r3, r2
34197dc8:	685b      	ldr	r3, [r3, #4]
34197dca:	67fb      	str	r3, [r7, #124]	@ 0x7c
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
34197dcc:	f107 0370 	add.w	r3, r7, #112	@ 0x70
34197dd0:	4619      	mov	r1, r3
34197dd2:	6878      	ldr	r0, [r7, #4]
34197dd4:	f001 fa42 	bl	3419925c <ISP_SVC_ISP_SetGain>
34197dd8:	4603      	mov	r3, r0
34197dda:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                  if (ret == ISP_OK)
34197dde:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197de2:	2b00      	cmp	r3, #0
34197de4:	d111      	bne.n	34197e0a <ISP_Algo_AWB_Process+0x6e2>
                  {
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
34197de6:	4b38      	ldr	r3, [pc, #224]	@ (34197ec8 <ISP_Algo_AWB_Process+0x7a0>)
34197de8:	681b      	ldr	r3, [r3, #0]
34197dea:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
34197dee:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34197df2:	ee17 2a90 	vmov	r2, s15
34197df6:	4b35      	ldr	r3, [pc, #212]	@ (34197ecc <ISP_Algo_AWB_Process+0x7a4>)
34197df8:	601a      	str	r2, [r3, #0]
                    current_awb_profId = profId;
34197dfa:	4a35      	ldr	r2, [pc, #212]	@ (34197ed0 <ISP_Algo_AWB_Process+0x7a8>)
34197dfc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34197e00:	6013      	str	r3, [r2, #0]
34197e02:	e002      	b.n	34197e0a <ISP_Algo_AWB_Process+0x6e2>
            }
          }
        }
        else
        {
          ret = ISP_ERR_ALGO;
34197e04:	23be      	movs	r3, #190	@ 0xbe
34197e06:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
        }
    }

    /* Reset reconfigureRequest */
    reconfigureRequest = false;
34197e0a:	4b32      	ldr	r3, [pc, #200]	@ (34197ed4 <ISP_Algo_AWB_Process+0x7ac>)
34197e0c:	2200      	movs	r2, #0
34197e0e:	701a      	strb	r2, [r3, #0]

    /* Decrease counter to limit the number of estimations before reaching convergence */
    if (skip_stat_check_count > 0) skip_stat_check_count--;
34197e10:	4b31      	ldr	r3, [pc, #196]	@ (34197ed8 <ISP_Algo_AWB_Process+0x7b0>)
34197e12:	781b      	ldrb	r3, [r3, #0]
34197e14:	2b00      	cmp	r3, #0
34197e16:	d005      	beq.n	34197e24 <ISP_Algo_AWB_Process+0x6fc>
34197e18:	4b2f      	ldr	r3, [pc, #188]	@ (34197ed8 <ISP_Algo_AWB_Process+0x7b0>)
34197e1a:	781b      	ldrb	r3, [r3, #0]
34197e1c:	3b01      	subs	r3, #1
34197e1e:	b2da      	uxtb	r2, r3
34197e20:	4b2d      	ldr	r3, [pc, #180]	@ (34197ed8 <ISP_Algo_AWB_Process+0x7b0>)
34197e22:	701a      	strb	r2, [r3, #0]

    /* Store history to be able to detect variations*/
    statsHistory[1][0] = statsHistory[0][0];
34197e24:	4b2d      	ldr	r3, [pc, #180]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e26:	681b      	ldr	r3, [r3, #0]
34197e28:	4a2c      	ldr	r2, [pc, #176]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e2a:	60d3      	str	r3, [r2, #12]
    statsHistory[1][1] = statsHistory[0][1];
34197e2c:	4b2b      	ldr	r3, [pc, #172]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e2e:	685b      	ldr	r3, [r3, #4]
34197e30:	4a2a      	ldr	r2, [pc, #168]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e32:	6113      	str	r3, [r2, #16]
    statsHistory[1][2] = statsHistory[0][2];
34197e34:	4b29      	ldr	r3, [pc, #164]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e36:	689b      	ldr	r3, [r3, #8]
34197e38:	4a28      	ldr	r2, [pc, #160]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e3a:	6153      	str	r3, [r2, #20]
    statsHistory[0][0] = stats.up.averageR;
34197e3c:	4b28      	ldr	r3, [pc, #160]	@ (34197ee0 <ISP_Algo_AWB_Process+0x7b8>)
34197e3e:	781b      	ldrb	r3, [r3, #0]
34197e40:	461a      	mov	r2, r3
34197e42:	4b26      	ldr	r3, [pc, #152]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e44:	601a      	str	r2, [r3, #0]
    statsHistory[0][1] = stats.up.averageG;
34197e46:	4b26      	ldr	r3, [pc, #152]	@ (34197ee0 <ISP_Algo_AWB_Process+0x7b8>)
34197e48:	785b      	ldrb	r3, [r3, #1]
34197e4a:	461a      	mov	r2, r3
34197e4c:	4b23      	ldr	r3, [pc, #140]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e4e:	605a      	str	r2, [r3, #4]
    statsHistory[0][2] = stats.up.averageB;
34197e50:	4b23      	ldr	r3, [pc, #140]	@ (34197ee0 <ISP_Algo_AWB_Process+0x7b8>)
34197e52:	789b      	ldrb	r3, [r3, #2]
34197e54:	461a      	mov	r2, r3
34197e56:	4b21      	ldr	r3, [pc, #132]	@ (34197edc <ISP_Algo_AWB_Process+0x7b4>)
34197e58:	609a      	str	r2, [r3, #8]
    colorTempHistory[1] = colorTempHistory[0];
34197e5a:	4b22      	ldr	r3, [pc, #136]	@ (34197ee4 <ISP_Algo_AWB_Process+0x7bc>)
34197e5c:	681b      	ldr	r3, [r3, #0]
34197e5e:	4a21      	ldr	r2, [pc, #132]	@ (34197ee4 <ISP_Algo_AWB_Process+0x7bc>)
34197e60:	6053      	str	r3, [r2, #4]
    colorTempHistory[0] = currentColorTemp;
34197e62:	4b1a      	ldr	r3, [pc, #104]	@ (34197ecc <ISP_Algo_AWB_Process+0x7a4>)
34197e64:	681b      	ldr	r3, [r3, #0]
34197e66:	4a1f      	ldr	r2, [pc, #124]	@ (34197ee4 <ISP_Algo_AWB_Process+0x7bc>)
34197e68:	6013      	str	r3, [r2, #0]

    /* Ask for stats */
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34197e6a:	2305      	movs	r3, #5
34197e6c:	9302      	str	r3, [sp, #8]
34197e6e:	2301      	movs	r3, #1
34197e70:	9301      	str	r3, [sp, #4]
34197e72:	2302      	movs	r3, #2
34197e74:	9300      	str	r3, [sp, #0]
34197e76:	4b1a      	ldr	r3, [pc, #104]	@ (34197ee0 <ISP_Algo_AWB_Process+0x7b8>)
34197e78:	683a      	ldr	r2, [r7, #0]
34197e7a:	491b      	ldr	r1, [pc, #108]	@ (34197ee8 <ISP_Algo_AWB_Process+0x7c0>)
34197e7c:	6878      	ldr	r0, [r7, #4]
34197e7e:	f002 f8c5 	bl	3419a00c <ISP_SVC_Stats_GetNext>
34197e82:	4603      	mov	r3, r0
34197e84:	f887 30ae 	strb.w	r3, [r7, #174]	@ 0xae
                                     ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    ret = (ret != ISP_OK) ? ret : ret_stat;
34197e88:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197e8c:	2b00      	cmp	r3, #0
34197e8e:	d002      	beq.n	34197e96 <ISP_Algo_AWB_Process+0x76e>
34197e90:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34197e94:	e001      	b.n	34197e9a <ISP_Algo_AWB_Process+0x772>
34197e96:	f897 30ae 	ldrb.w	r3, [r7, #174]	@ 0xae
34197e9a:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34197e9e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34197ea2:	2202      	movs	r2, #2
34197ea4:	705a      	strb	r2, [r3, #1]
    break;
34197ea6:	e008      	b.n	34197eba <ISP_Algo_AWB_Process+0x792>

  default:
    printf("WARNING: Unknown AWB algo state\r\n");
34197ea8:	4810      	ldr	r0, [pc, #64]	@ (34197eec <ISP_Algo_AWB_Process+0x7c4>)
34197eaa:	f00b fe4b 	bl	341a3b44 <puts>
    /* Reset state to ISP_ALGO_STATE_INIT */
    algo->state = ISP_ALGO_STATE_INIT;
34197eae:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34197eb2:	2200      	movs	r2, #0
34197eb4:	705a      	strb	r2, [r3, #1]
    break;
34197eb6:	e000      	b.n	34197eba <ISP_Algo_AWB_Process+0x792>
    break;
34197eb8:	bf00      	nop
  }

  return ret;
34197eba:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
}
34197ebe:	4618      	mov	r0, r3
34197ec0:	37d0      	adds	r7, #208	@ 0xd0
34197ec2:	46bd      	mov	sp, r7
34197ec4:	bd80      	pop	{r7, pc}
34197ec6:	bf00      	nop
34197ec8:	341c11a8 	.word	0x341c11a8
34197ecc:	341c1454 	.word	0x341c1454
34197ed0:	341c11ac 	.word	0x341c11ac
34197ed4:	341c1249 	.word	0x341c1249
34197ed8:	341c00f0 	.word	0x341c00f0
34197edc:	341c1430 	.word	0x341c1430
34197ee0:	341c13b8 	.word	0x341c13b8
34197ee4:	341c124c 	.word	0x341c124c
34197ee8:	34197705 	.word	0x34197705
34197eec:	341a5cf0 	.word	0x341a5cf0

34197ef0 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
34197ef0:	b580      	push	{r7, lr}
34197ef2:	b086      	sub	sp, #24
34197ef4:	af00      	add	r7, sp, #0
34197ef6:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
34197ef8:	687b      	ldr	r3, [r7, #4]
34197efa:	4a15      	ldr	r2, [pc, #84]	@ (34197f50 <ISP_Algo_Init+0x60>)
34197efc:	619a      	str	r2, [r3, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197efe:	2300      	movs	r3, #0
34197f00:	75fb      	strb	r3, [r7, #23]
34197f02:	e01c      	b.n	34197f3e <ISP_Algo_Init+0x4e>
  {
    algo = hIsp->algorithm[i];
34197f04:	687b      	ldr	r3, [r7, #4]
34197f06:	699a      	ldr	r2, [r3, #24]
34197f08:	7dfb      	ldrb	r3, [r7, #23]
34197f0a:	009b      	lsls	r3, r3, #2
34197f0c:	4413      	add	r3, r2
34197f0e:	681b      	ldr	r3, [r3, #0]
34197f10:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Init != NULL))
34197f12:	693b      	ldr	r3, [r7, #16]
34197f14:	2b00      	cmp	r3, #0
34197f16:	d00f      	beq.n	34197f38 <ISP_Algo_Init+0x48>
34197f18:	693b      	ldr	r3, [r7, #16]
34197f1a:	685b      	ldr	r3, [r3, #4]
34197f1c:	2b00      	cmp	r3, #0
34197f1e:	d00b      	beq.n	34197f38 <ISP_Algo_Init+0x48>
    {
      ret = algo->Init((void*)hIsp, (void*)algo);
34197f20:	693b      	ldr	r3, [r7, #16]
34197f22:	685b      	ldr	r3, [r3, #4]
34197f24:	6939      	ldr	r1, [r7, #16]
34197f26:	6878      	ldr	r0, [r7, #4]
34197f28:	4798      	blx	r3
34197f2a:	4603      	mov	r3, r0
34197f2c:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
34197f2e:	7bfb      	ldrb	r3, [r7, #15]
34197f30:	2b00      	cmp	r3, #0
34197f32:	d001      	beq.n	34197f38 <ISP_Algo_Init+0x48>
      {
        return ret;
34197f34:	7bfb      	ldrb	r3, [r7, #15]
34197f36:	e006      	b.n	34197f46 <ISP_Algo_Init+0x56>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197f38:	7dfb      	ldrb	r3, [r7, #23]
34197f3a:	3301      	adds	r3, #1
34197f3c:	75fb      	strb	r3, [r7, #23]
34197f3e:	7dfb      	ldrb	r3, [r7, #23]
34197f40:	2b02      	cmp	r3, #2
34197f42:	d9df      	bls.n	34197f04 <ISP_Algo_Init+0x14>
      }
    }
  }

  return ISP_OK;
34197f44:	2300      	movs	r3, #0
}
34197f46:	4618      	mov	r0, r3
34197f48:	3718      	adds	r7, #24
34197f4a:	46bd      	mov	sp, r7
34197f4c:	bd80      	pop	{r7, pc}
34197f4e:	bf00      	nop
34197f50:	341c00e4 	.word	0x341c00e4

34197f54 <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
34197f54:	b580      	push	{r7, lr}
34197f56:	b086      	sub	sp, #24
34197f58:	af00      	add	r7, sp, #0
34197f5a:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197f5c:	2300      	movs	r3, #0
34197f5e:	75fb      	strb	r3, [r7, #23]
34197f60:	e01c      	b.n	34197f9c <ISP_Algo_DeInit+0x48>
  {
    algo = hIsp->algorithm[i];
34197f62:	687b      	ldr	r3, [r7, #4]
34197f64:	699a      	ldr	r2, [r3, #24]
34197f66:	7dfb      	ldrb	r3, [r7, #23]
34197f68:	009b      	lsls	r3, r3, #2
34197f6a:	4413      	add	r3, r2
34197f6c:	681b      	ldr	r3, [r3, #0]
34197f6e:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->DeInit != NULL))
34197f70:	693b      	ldr	r3, [r7, #16]
34197f72:	2b00      	cmp	r3, #0
34197f74:	d00f      	beq.n	34197f96 <ISP_Algo_DeInit+0x42>
34197f76:	693b      	ldr	r3, [r7, #16]
34197f78:	689b      	ldr	r3, [r3, #8]
34197f7a:	2b00      	cmp	r3, #0
34197f7c:	d00b      	beq.n	34197f96 <ISP_Algo_DeInit+0x42>
    {
      ret = algo->DeInit((void*)hIsp, (void*)algo);
34197f7e:	693b      	ldr	r3, [r7, #16]
34197f80:	689b      	ldr	r3, [r3, #8]
34197f82:	6939      	ldr	r1, [r7, #16]
34197f84:	6878      	ldr	r0, [r7, #4]
34197f86:	4798      	blx	r3
34197f88:	4603      	mov	r3, r0
34197f8a:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
34197f8c:	7bfb      	ldrb	r3, [r7, #15]
34197f8e:	2b00      	cmp	r3, #0
34197f90:	d001      	beq.n	34197f96 <ISP_Algo_DeInit+0x42>
      {
        return ret;
34197f92:	7bfb      	ldrb	r3, [r7, #15]
34197f94:	e006      	b.n	34197fa4 <ISP_Algo_DeInit+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197f96:	7dfb      	ldrb	r3, [r7, #23]
34197f98:	3301      	adds	r3, #1
34197f9a:	75fb      	strb	r3, [r7, #23]
34197f9c:	7dfb      	ldrb	r3, [r7, #23]
34197f9e:	2b02      	cmp	r3, #2
34197fa0:	d9df      	bls.n	34197f62 <ISP_Algo_DeInit+0xe>
      }
    }
  }

  return ISP_OK;
34197fa2:	2300      	movs	r3, #0
}
34197fa4:	4618      	mov	r0, r3
34197fa6:	3718      	adds	r7, #24
34197fa8:	46bd      	mov	sp, r7
34197faa:	bd80      	pop	{r7, pc}

34197fac <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
34197fac:	b580      	push	{r7, lr}
34197fae:	b086      	sub	sp, #24
34197fb0:	af00      	add	r7, sp, #0
34197fb2:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197fb4:	2300      	movs	r3, #0
34197fb6:	75fb      	strb	r3, [r7, #23]
34197fb8:	e01c      	b.n	34197ff4 <ISP_Algo_Process+0x48>
  {
    algo = hIsp->algorithm[i];
34197fba:	687b      	ldr	r3, [r7, #4]
34197fbc:	699a      	ldr	r2, [r3, #24]
34197fbe:	7dfb      	ldrb	r3, [r7, #23]
34197fc0:	009b      	lsls	r3, r3, #2
34197fc2:	4413      	add	r3, r2
34197fc4:	681b      	ldr	r3, [r3, #0]
34197fc6:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Process != NULL))
34197fc8:	693b      	ldr	r3, [r7, #16]
34197fca:	2b00      	cmp	r3, #0
34197fcc:	d00f      	beq.n	34197fee <ISP_Algo_Process+0x42>
34197fce:	693b      	ldr	r3, [r7, #16]
34197fd0:	68db      	ldr	r3, [r3, #12]
34197fd2:	2b00      	cmp	r3, #0
34197fd4:	d00b      	beq.n	34197fee <ISP_Algo_Process+0x42>
    {
#ifdef ALGO_PERF_DBG_LOGS
      uint32_t tickstart = HAL_GetTick();
#endif
      ret = algo->Process((void*)hIsp, (void*)algo);
34197fd6:	693b      	ldr	r3, [r7, #16]
34197fd8:	68db      	ldr	r3, [r3, #12]
34197fda:	6939      	ldr	r1, [r7, #16]
34197fdc:	6878      	ldr	r0, [r7, #4]
34197fde:	4798      	blx	r3
34197fe0:	4603      	mov	r3, r0
34197fe2:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
34197fe4:	7bfb      	ldrb	r3, [r7, #15]
34197fe6:	2b00      	cmp	r3, #0
34197fe8:	d001      	beq.n	34197fee <ISP_Algo_Process+0x42>
      {
        return ret;
34197fea:	7bfb      	ldrb	r3, [r7, #15]
34197fec:	e006      	b.n	34197ffc <ISP_Algo_Process+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34197fee:	7dfb      	ldrb	r3, [r7, #23]
34197ff0:	3301      	adds	r3, #1
34197ff2:	75fb      	strb	r3, [r7, #23]
34197ff4:	7dfb      	ldrb	r3, [r7, #23]
34197ff6:	2b02      	cmp	r3, #2
34197ff8:	d9df      	bls.n	34197fba <ISP_Algo_Process+0xe>
      }
#endif
    }
  }

  return ISP_OK;
34197ffa:	2300      	movs	r3, #0
}
34197ffc:	4618      	mov	r0, r3
34197ffe:	3718      	adds	r7, #24
34198000:	46bd      	mov	sp, r7
34198002:	bd80      	pop	{r7, pc}

34198004 <ISP_Init>:
ISP_StatusTypeDef ISP_Init(ISP_HandleTypeDef *hIsp,
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34198004:	b5b0      	push	{r4, r5, r7, lr}
34198006:	b086      	sub	sp, #24
34198008:	af00      	add	r7, sp, #0
3419800a:	60f8      	str	r0, [r7, #12]
3419800c:	60b9      	str	r1, [r7, #8]
3419800e:	607a      	str	r2, [r7, #4]
34198010:	603b      	str	r3, [r7, #0]
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
34198012:	68fb      	ldr	r3, [r7, #12]
34198014:	2b00      	cmp	r3, #0
34198016:	d005      	beq.n	34198024 <ISP_Init+0x20>
34198018:	68bb      	ldr	r3, [r7, #8]
3419801a:	2b00      	cmp	r3, #0
3419801c:	d002      	beq.n	34198024 <ISP_Init+0x20>
3419801e:	683b      	ldr	r3, [r7, #0]
34198020:	2b00      	cmp	r3, #0
34198022:	d101      	bne.n	34198028 <ISP_Init+0x24>
  {
    return ISP_ERR_EINVAL;
34198024:	2301      	movs	r3, #1
34198026:	e0a3      	b.n	34198170 <ISP_Init+0x16c>
  }

  memset(hIsp, 0, sizeof(*hIsp));
34198028:	2288      	movs	r2, #136	@ 0x88
3419802a:	2100      	movs	r1, #0
3419802c:	68f8      	ldr	r0, [r7, #12]
3419802e:	f00b feb9 	bl	341a3da4 <memset>

#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_ToolCom_Init();
#endif

  hIsp->hDcmipp = hDcmipp;
34198032:	68fb      	ldr	r3, [r7, #12]
34198034:	68ba      	ldr	r2, [r7, #8]
34198036:	601a      	str	r2, [r3, #0]
  hIsp->cameraInstance = CameraInstance;
34198038:	68fb      	ldr	r3, [r7, #12]
3419803a:	687a      	ldr	r2, [r7, #4]
3419803c:	605a      	str	r2, [r3, #4]
  hIsp->MainPipe_FrameCount = 0;
3419803e:	68fb      	ldr	r3, [r7, #12]
34198040:	2200      	movs	r2, #0
34198042:	641a      	str	r2, [r3, #64]	@ 0x40
  hIsp->AncillaryPipe_FrameCount = 0;
34198044:	68fb      	ldr	r3, [r7, #12]
34198046:	2200      	movs	r2, #0
34198048:	645a      	str	r2, [r3, #68]	@ 0x44
  hIsp->DumpPipe_FrameCount = 0;
3419804a:	68fb      	ldr	r3, [r7, #12]
3419804c:	2200      	movs	r2, #0
3419804e:	649a      	str	r2, [r3, #72]	@ 0x48

  hIsp->appliHelpers = *pAppliHelpers;
34198050:	68fb      	ldr	r3, [r7, #12]
34198052:	683a      	ldr	r2, [r7, #0]
34198054:	f103 041c 	add.w	r4, r3, #28
34198058:	4615      	mov	r5, r2
3419805a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419805c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419805e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34198060:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34198062:	682b      	ldr	r3, [r5, #0]
34198064:	6023      	str	r3, [r4, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
34198066:	68fb      	ldr	r3, [r7, #12]
34198068:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419806a:	2b00      	cmp	r3, #0
3419806c:	d104      	bne.n	34198078 <ISP_Init+0x74>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
3419806e:	4842      	ldr	r0, [pc, #264]	@ (34198178 <ISP_Init+0x174>)
34198070:	f00b fd68 	bl	341a3b44 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34198074:	23b4      	movs	r3, #180	@ 0xb4
34198076:	e07b      	b.n	34198170 <ISP_Init+0x16c>
   }
  if (hIsp->appliHelpers.SetSensorGain == NULL)
34198078:	68fb      	ldr	r3, [r7, #12]
3419807a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419807c:	2b00      	cmp	r3, #0
3419807e:	d104      	bne.n	3419808a <ISP_Init+0x86>
  {
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
34198080:	483e      	ldr	r0, [pc, #248]	@ (3419817c <ISP_Init+0x178>)
34198082:	f00b fd5f 	bl	341a3b44 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
34198086:	23b4      	movs	r3, #180	@ 0xb4
34198088:	e072      	b.n	34198170 <ISP_Init+0x16c>
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
3419808a:	68fb      	ldr	r3, [r7, #12]
3419808c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419808e:	2b00      	cmp	r3, #0
34198090:	d104      	bne.n	3419809c <ISP_Init+0x98>
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
34198092:	483b      	ldr	r0, [pc, #236]	@ (34198180 <ISP_Init+0x17c>)
34198094:	f00b fd56 	bl	341a3b44 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34198098:	23b4      	movs	r3, #180	@ 0xb4
3419809a:	e069      	b.n	34198170 <ISP_Init+0x16c>
   }
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
3419809c:	68fb      	ldr	r3, [r7, #12]
3419809e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341980a0:	2b00      	cmp	r3, #0
341980a2:	d104      	bne.n	341980ae <ISP_Init+0xaa>
  {
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
341980a4:	4837      	ldr	r0, [pc, #220]	@ (34198184 <ISP_Init+0x180>)
341980a6:	f00b fd4d 	bl	341a3b44 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
341980aa:	23b4      	movs	r3, #180	@ 0xb4
341980ac:	e060      	b.n	34198170 <ISP_Init+0x16c>
  }
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
341980ae:	68fb      	ldr	r3, [r7, #12]
341980b0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341980b2:	2b00      	cmp	r3, #0
341980b4:	d104      	bne.n	341980c0 <ISP_Init+0xbc>
  {
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
341980b6:	4834      	ldr	r0, [pc, #208]	@ (34198188 <ISP_Init+0x184>)
341980b8:	f00b fd44 	bl	341a3b44 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
341980bc:	23b4      	movs	r3, #180	@ 0xb4
341980be:	e057      	b.n	34198170 <ISP_Init+0x16c>
   }

  /* Initialize IQ param (read from non volatile memory) */
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
341980c0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
341980c2:	68f8      	ldr	r0, [r7, #12]
341980c4:	f001 fc26 	bl	34199914 <ISP_SVC_IQParam_Init>
341980c8:	4603      	mov	r3, r0
341980ca:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
341980cc:	7dfb      	ldrb	r3, [r7, #23]
341980ce:	2b00      	cmp	r3, #0
341980d0:	d001      	beq.n	341980d6 <ISP_Init+0xd2>
  {
    return ret;
341980d2:	7dfb      	ldrb	r3, [r7, #23]
341980d4:	e04c      	b.n	34198170 <ISP_Init+0x16c>
  }

  /* Set decimation configuration */
  /* Get Sensor Info */
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
341980d6:	68fb      	ldr	r3, [r7, #12]
341980d8:	334c      	adds	r3, #76	@ 0x4c
341980da:	4619      	mov	r1, r3
341980dc:	68f8      	ldr	r0, [r7, #12]
341980de:	f001 fa89 	bl	341995f4 <ISP_SVC_Sensor_GetInfo>
341980e2:	4603      	mov	r3, r0
341980e4:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
341980e6:	7dfb      	ldrb	r3, [r7, #23]
341980e8:	2b00      	cmp	r3, #0
341980ea:	d001      	beq.n	341980f0 <ISP_Init+0xec>
  {
    return ret;
341980ec:	7dfb      	ldrb	r3, [r7, #23]
341980ee:	e03f      	b.n	34198170 <ISP_Init+0x16c>
  }
  /* Compute the ISP decimation value according to the sensor resolution and the maximum ISP resolution */
  /* It is mandatory to ensure that RAW frame size does not exceed 2688 width prior to demosaicing */
  ISP_DecimationTypeDef decimation;
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
341980f0:	68fb      	ldr	r3, [r7, #12]
341980f2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341980f4:	f5b3 6f28 	cmp.w	r3, #2688	@ 0xa80
341980f8:	d202      	bcs.n	34198100 <ISP_Init+0xfc>
  {
    decimation.factor = ISP_DECIM_FACTOR_1;
341980fa:	2301      	movs	r3, #1
341980fc:	753b      	strb	r3, [r7, #20]
341980fe:	e01c      	b.n	3419813a <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
34198100:	68fb      	ldr	r3, [r7, #12]
34198102:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34198104:	f5b3 5fa8 	cmp.w	r3, #5376	@ 0x1500
34198108:	d202      	bcs.n	34198110 <ISP_Init+0x10c>
  {
    decimation.factor = ISP_DECIM_FACTOR_2;
3419810a:	2302      	movs	r3, #2
3419810c:	753b      	strb	r3, [r7, #20]
3419810e:	e014      	b.n	3419813a <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
34198110:	68fb      	ldr	r3, [r7, #12]
34198112:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34198114:	f5b3 5f28 	cmp.w	r3, #10752	@ 0x2a00
34198118:	d202      	bcs.n	34198120 <ISP_Init+0x11c>
  {
    decimation.factor = ISP_DECIM_FACTOR_4;
3419811a:	2304      	movs	r3, #4
3419811c:	753b      	strb	r3, [r7, #20]
3419811e:	e00c      	b.n	3419813a <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
34198120:	68fb      	ldr	r3, [r7, #12]
34198122:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34198124:	f5b3 4fa8 	cmp.w	r3, #21504	@ 0x5400
34198128:	d202      	bcs.n	34198130 <ISP_Init+0x12c>
  {
    decimation.factor = ISP_DECIM_FACTOR_8;
3419812a:	2308      	movs	r3, #8
3419812c:	753b      	strb	r3, [r7, #20]
3419812e:	e004      	b.n	3419813a <ISP_Init+0x136>
  }
  else
  {
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
34198130:	4816      	ldr	r0, [pc, #88]	@ (3419818c <ISP_Init+0x188>)
34198132:	f00b fd07 	bl	341a3b44 <puts>
    return ISP_ERR_DECIMATION_EINVAL;
34198136:	231e      	movs	r3, #30
34198138:	e01a      	b.n	34198170 <ISP_Init+0x16c>
  }
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
3419813a:	f107 0314 	add.w	r3, r7, #20
3419813e:	4619      	mov	r1, r3
34198140:	68f8      	ldr	r0, [r7, #12]
34198142:	f000 fe05 	bl	34198d50 <ISP_SVC_ISP_SetDecimation>
34198146:	4603      	mov	r3, r0
34198148:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3419814a:	7dfb      	ldrb	r3, [r7, #23]
3419814c:	2b00      	cmp	r3, #0
3419814e:	d001      	beq.n	34198154 <ISP_Init+0x150>
  {
    return ret;
34198150:	7dfb      	ldrb	r3, [r7, #23]
34198152:	e00d      	b.n	34198170 <ISP_Init+0x16c>
  }

  /* Initialize algorithms */
  ret = ISP_Algo_Init(hIsp);
34198154:	68f8      	ldr	r0, [r7, #12]
34198156:	f7ff fecb 	bl	34197ef0 <ISP_Algo_Init>
3419815a:	4603      	mov	r3, r0
3419815c:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3419815e:	7dfb      	ldrb	r3, [r7, #23]
34198160:	2b00      	cmp	r3, #0
34198162:	d001      	beq.n	34198168 <ISP_Init+0x164>
  {
    return ret;
34198164:	7dfb      	ldrb	r3, [r7, #23]
34198166:	e003      	b.n	34198170 <ISP_Init+0x16c>
  }

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);
34198168:	68f8      	ldr	r0, [r7, #12]
3419816a:	f001 fbf7 	bl	3419995c <ISP_SVC_Stats_Init>

  return ISP_OK;
3419816e:	2300      	movs	r3, #0
}
34198170:	4618      	mov	r0, r3
34198172:	3718      	adds	r7, #24
34198174:	46bd      	mov	sp, r7
34198176:	bdb0      	pop	{r4, r5, r7, pc}
34198178:	341a5d14 	.word	0x341a5d14
3419817c:	341a5d4c 	.word	0x341a5d4c
34198180:	341a5d84 	.word	0x341a5d84
34198184:	341a5dbc 	.word	0x341a5dbc
34198188:	341a5df8 	.word	0x341a5df8
3419818c:	341a5e34 	.word	0x341a5e34

34198190 <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
34198190:	b580      	push	{r7, lr}
34198192:	b084      	sub	sp, #16
34198194:	af00      	add	r7, sp, #0
34198196:	6078      	str	r0, [r7, #4]
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
34198198:	687b      	ldr	r3, [r7, #4]
3419819a:	2b00      	cmp	r3, #0
3419819c:	d101      	bne.n	341981a2 <ISP_DeInit+0x12>
  {
    return ISP_ERR_EINVAL;
3419819e:	2301      	movs	r3, #1
341981a0:	e00f      	b.n	341981c2 <ISP_DeInit+0x32>
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
341981a2:	6878      	ldr	r0, [r7, #4]
341981a4:	f7ff fed6 	bl	34197f54 <ISP_Algo_DeInit>
341981a8:	4603      	mov	r3, r0
341981aa:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
341981ac:	7bfb      	ldrb	r3, [r7, #15]
341981ae:	2b00      	cmp	r3, #0
341981b0:	d001      	beq.n	341981b6 <ISP_DeInit+0x26>
  {
    return ret;
341981b2:	7bfb      	ldrb	r3, [r7, #15]
341981b4:	e005      	b.n	341981c2 <ISP_DeInit+0x32>
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
341981b6:	2288      	movs	r2, #136	@ 0x88
341981b8:	2100      	movs	r1, #0
341981ba:	6878      	ldr	r0, [r7, #4]
341981bc:	f00b fdf2 	bl	341a3da4 <memset>

  return ISP_OK;
341981c0:	2300      	movs	r3, #0
}
341981c2:	4618      	mov	r0, r3
341981c4:	3710      	adds	r7, #16
341981c6:	46bd      	mov	sp, r7
341981c8:	bd80      	pop	{r7, pc}
341981ca:	0000      	movs	r0, r0
341981cc:	0000      	movs	r0, r0
	...

341981d0 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
341981d0:	b580      	push	{r7, lr}
341981d2:	b084      	sub	sp, #16
341981d4:	af00      	add	r7, sp, #0
341981d6:	6078      	str	r0, [r7, #4]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
341981d8:	687b      	ldr	r3, [r7, #4]
341981da:	2b00      	cmp	r3, #0
341981dc:	d101      	bne.n	341981e2 <ISP_Start+0x12>
  {
    return ISP_ERR_EINVAL;
341981de:	2301      	movs	r3, #1
341981e0:	e0f6      	b.n	341983d0 <ISP_Start+0x200>
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
341981e2:	6878      	ldr	r0, [r7, #4]
341981e4:	f001 fac0 	bl	34199768 <ISP_SVC_Misc_IsDCMIPPReady>
341981e8:	4603      	mov	r3, r0
341981ea:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
341981ec:	7bfb      	ldrb	r3, [r7, #15]
341981ee:	2b00      	cmp	r3, #0
341981f0:	d001      	beq.n	341981f6 <ISP_Start+0x26>
  {
    return ret;
341981f2:	7bfb      	ldrb	r3, [r7, #15]
341981f4:	e0ec      	b.n	341983d0 <ISP_Start+0x200>
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
341981f6:	6878      	ldr	r0, [r7, #4]
341981f8:	f001 fba2 	bl	34199940 <ISP_SVC_IQParam_Get>
341981fc:	60b8      	str	r0, [r7, #8]

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
341981fe:	68bb      	ldr	r3, [r7, #8]
34198200:	330c      	adds	r3, #12
34198202:	4619      	mov	r1, r3
34198204:	6878      	ldr	r0, [r7, #4]
34198206:	f000 fce7 	bl	34198bd8 <ISP_SVC_ISP_SetDemosaicing>
3419820a:	4603      	mov	r3, r0
3419820c:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3419820e:	7bfb      	ldrb	r3, [r7, #15]
34198210:	2b00      	cmp	r3, #0
34198212:	d001      	beq.n	34198218 <ISP_Start+0x48>
  {
    return ret;
34198214:	7bfb      	ldrb	r3, [r7, #15]
34198216:	e0db      	b.n	341983d0 <ISP_Start+0x200>
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
34198218:	68bb      	ldr	r3, [r7, #8]
3419821a:	4619      	mov	r1, r3
3419821c:	6878      	ldr	r0, [r7, #4]
3419821e:	f000 fd53 	bl	34198cc8 <ISP_SVC_ISP_SetStatRemoval>
34198222:	4603      	mov	r3, r0
34198224:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
34198226:	7bfb      	ldrb	r3, [r7, #15]
34198228:	2b00      	cmp	r3, #0
3419822a:	d001      	beq.n	34198230 <ISP_Start+0x60>
  {
    return ret;
3419822c:	7bfb      	ldrb	r3, [r7, #15]
3419822e:	e0cf      	b.n	341983d0 <ISP_Start+0x200>
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
34198230:	68bb      	ldr	r3, [r7, #8]
34198232:	3314      	adds	r3, #20
34198234:	4619      	mov	r1, r3
34198236:	6878      	ldr	r0, [r7, #4]
34198238:	f000 fdec 	bl	34198e14 <ISP_SVC_ISP_SetContrast>
3419823c:	4603      	mov	r3, r0
3419823e:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
34198240:	7bfb      	ldrb	r3, [r7, #15]
34198242:	2b00      	cmp	r3, #0
34198244:	d001      	beq.n	3419824a <ISP_Start+0x7a>
  {
    return ret;
34198246:	7bfb      	ldrb	r3, [r7, #15]
34198248:	e0c2      	b.n	341983d0 <ISP_Start+0x200>
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
3419824a:	68bb      	ldr	r3, [r7, #8]
3419824c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419824e:	2b00      	cmp	r3, #0
34198250:	d011      	beq.n	34198276 <ISP_Start+0xa6>
34198252:	68bb      	ldr	r3, [r7, #8]
34198254:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34198258:	2b00      	cmp	r3, #0
3419825a:	d10c      	bne.n	34198276 <ISP_Start+0xa6>
  {
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
3419825c:	68bb      	ldr	r3, [r7, #8]
3419825e:	334c      	adds	r3, #76	@ 0x4c
34198260:	4619      	mov	r1, r3
34198262:	6878      	ldr	r0, [r7, #4]
34198264:	f001 f9e8 	bl	34199638 <ISP_SVC_Sensor_SetGain>
34198268:	4603      	mov	r3, r0
3419826a:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3419826c:	7bfb      	ldrb	r3, [r7, #15]
3419826e:	2b00      	cmp	r3, #0
34198270:	d001      	beq.n	34198276 <ISP_Start+0xa6>
    {
      return ret;
34198272:	7bfb      	ldrb	r3, [r7, #15]
34198274:	e0ac      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
34198276:	68bb      	ldr	r3, [r7, #8]
34198278:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419827a:	2b00      	cmp	r3, #0
3419827c:	d011      	beq.n	341982a2 <ISP_Start+0xd2>
3419827e:	68bb      	ldr	r3, [r7, #8]
34198280:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34198284:	2b00      	cmp	r3, #0
34198286:	d10c      	bne.n	341982a2 <ISP_Start+0xd2>
  {
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
34198288:	68bb      	ldr	r3, [r7, #8]
3419828a:	3350      	adds	r3, #80	@ 0x50
3419828c:	4619      	mov	r1, r3
3419828e:	6878      	ldr	r0, [r7, #4]
34198290:	f001 fa1e 	bl	341996d0 <ISP_SVC_Sensor_SetExposure>
34198294:	4603      	mov	r3, r0
34198296:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
34198298:	7bfb      	ldrb	r3, [r7, #15]
3419829a:	2b00      	cmp	r3, #0
3419829c:	d001      	beq.n	341982a2 <ISP_Start+0xd2>
    {
      return ret;
3419829e:	7bfb      	ldrb	r3, [r7, #15]
341982a0:	e096      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
341982a2:	68bb      	ldr	r3, [r7, #8]
341982a4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341982a8:	2b00      	cmp	r3, #0
341982aa:	d00c      	beq.n	341982c6 <ISP_Start+0xf6>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
341982ac:	68bb      	ldr	r3, [r7, #8]
341982ae:	335c      	adds	r3, #92	@ 0x5c
341982b0:	4619      	mov	r1, r3
341982b2:	6878      	ldr	r0, [r7, #4]
341982b4:	f000 feee 	bl	34199094 <ISP_SVC_ISP_SetBadPixel>
341982b8:	4603      	mov	r3, r0
341982ba:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
341982bc:	7bfb      	ldrb	r3, [r7, #15]
341982be:	2b00      	cmp	r3, #0
341982c0:	d001      	beq.n	341982c6 <ISP_Start+0xf6>
    {
      return ret;
341982c2:	7bfb      	ldrb	r3, [r7, #15]
341982c4:	e084      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
341982c6:	68bb      	ldr	r3, [r7, #8]
341982c8:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341982cc:	2b00      	cmp	r3, #0
341982ce:	d00c      	beq.n	341982ea <ISP_Start+0x11a>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
341982d0:	68bb      	ldr	r3, [r7, #8]
341982d2:	3364      	adds	r3, #100	@ 0x64
341982d4:	4619      	mov	r1, r3
341982d6:	6878      	ldr	r0, [r7, #4]
341982d8:	f000 ff50 	bl	3419917c <ISP_SVC_ISP_SetBlackLevel>
341982dc:	4603      	mov	r3, r0
341982de:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
341982e0:	7bfb      	ldrb	r3, [r7, #15]
341982e2:	2b00      	cmp	r3, #0
341982e4:	d001      	beq.n	341982ea <ISP_Start+0x11a>
    {
      return ret;
341982e6:	7bfb      	ldrb	r3, [r7, #15]
341982e8:	e072      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
341982ea:	68bb      	ldr	r3, [r7, #8]
341982ec:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
341982f0:	2b00      	cmp	r3, #0
341982f2:	d012      	beq.n	3419831a <ISP_Start+0x14a>
341982f4:	68bb      	ldr	r3, [r7, #8]
341982f6:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
341982fa:	2b00      	cmp	r3, #0
341982fc:	d10d      	bne.n	3419831a <ISP_Start+0x14a>
  {
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
341982fe:	68bb      	ldr	r3, [r7, #8]
34198300:	f503 7307 	add.w	r3, r3, #540	@ 0x21c
34198304:	4619      	mov	r1, r3
34198306:	6878      	ldr	r0, [r7, #4]
34198308:	f000 ffa8 	bl	3419925c <ISP_SVC_ISP_SetGain>
3419830c:	4603      	mov	r3, r0
3419830e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
34198310:	7bfb      	ldrb	r3, [r7, #15]
34198312:	2b00      	cmp	r3, #0
34198314:	d001      	beq.n	3419831a <ISP_Start+0x14a>
    {
      return ret;
34198316:	7bfb      	ldrb	r3, [r7, #15]
34198318:	e05a      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3419831a:	68bb      	ldr	r3, [r7, #8]
3419831c:	f893 322c 	ldrb.w	r3, [r3, #556]	@ 0x22c
34198320:	2b00      	cmp	r3, #0
34198322:	d012      	beq.n	3419834a <ISP_Start+0x17a>
34198324:	68bb      	ldr	r3, [r7, #8]
34198326:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
3419832a:	2b00      	cmp	r3, #0
3419832c:	d10d      	bne.n	3419834a <ISP_Start+0x17a>
  {
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
3419832e:	68bb      	ldr	r3, [r7, #8]
34198330:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
34198334:	4619      	mov	r1, r3
34198336:	6878      	ldr	r0, [r7, #4]
34198338:	f001 f83a 	bl	341993b0 <ISP_SVC_ISP_SetColorConv>
3419833c:	4603      	mov	r3, r0
3419833e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
34198340:	7bfb      	ldrb	r3, [r7, #15]
34198342:	2b00      	cmp	r3, #0
34198344:	d001      	beq.n	3419834a <ISP_Start+0x17a>
    {
      return ret;
34198346:	7bfb      	ldrb	r3, [r7, #15]
34198348:	e042      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  /* Configure statistic area if not already configured by ISP_SetStatArea() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3419834a:	687b      	ldr	r3, [r7, #4]
3419834c:	691b      	ldr	r3, [r3, #16]
3419834e:	2b00      	cmp	r3, #0
34198350:	d003      	beq.n	3419835a <ISP_Start+0x18a>
34198352:	687b      	ldr	r3, [r7, #4]
34198354:	695b      	ldr	r3, [r3, #20]
34198356:	2b00      	cmp	r3, #0
34198358:	d10c      	bne.n	34198374 <ISP_Start+0x1a4>
  {
    /* Configure statistic area from IQ params */
    ret = ISP_SVC_ISP_SetStatArea(hIsp, &IQParamConfig->statAreaStatic);
3419835a:	68bb      	ldr	r3, [r7, #8]
3419835c:	333c      	adds	r3, #60	@ 0x3c
3419835e:	4619      	mov	r1, r3
34198360:	6878      	ldr	r0, [r7, #4]
34198362:	f000 fe11 	bl	34198f88 <ISP_SVC_ISP_SetStatArea>
34198366:	4603      	mov	r3, r0
34198368:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3419836a:	7bfb      	ldrb	r3, [r7, #15]
3419836c:	2b00      	cmp	r3, #0
3419836e:	d001      	beq.n	34198374 <ISP_Start+0x1a4>
    {
      return ret;
34198370:	7bfb      	ldrb	r3, [r7, #15]
34198372:	e02d      	b.n	341983d0 <ISP_Start+0x200>
    }
  }

  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
34198374:	68bb      	ldr	r3, [r7, #8]
34198376:	f503 7315 	add.w	r3, r3, #596	@ 0x254
3419837a:	4619      	mov	r1, r3
3419837c:	6878      	ldr	r0, [r7, #4]
3419837e:	f001 fa86 	bl	3419988e <ISP_SVC_ISP_SetGamma>
34198382:	4603      	mov	r3, r0
34198384:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
34198386:	7bfb      	ldrb	r3, [r7, #15]
34198388:	2b00      	cmp	r3, #0
3419838a:	d001      	beq.n	34198390 <ISP_Start+0x1c0>
  {
    return ret;
3419838c:	7bfb      	ldrb	r3, [r7, #15]
3419838e:	e01f      	b.n	341983d0 <ISP_Start+0x200>
  }

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
34198390:	68bb      	ldr	r3, [r7, #8]
34198392:	f993 3069 	ldrsb.w	r3, [r3, #105]	@ 0x69
34198396:	ee07 3a90 	vmov	s15, r3
3419839a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419839e:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
341983a2:	eec7 7a26 	vdiv.f32	s15, s14, s13
341983a6:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
341983aa:	eeb0 1b47 	vmov.f64	d1, d7
341983ae:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
341983b2:	f00c fd01 	bl	341a4db8 <pow>
341983b6:	eeb0 7b40 	vmov.f64	d7, d0
341983ba:	ed9f 6b07 	vldr	d6, [pc, #28]	@ 341983d8 <ISP_Start+0x208>
341983be:	ee27 7b06 	vmul.f64	d7, d7, d6
341983c2:	eefc 7bc7 	vcvt.u32.f64	s15, d7
341983c6:	ee17 2a90 	vmov	r2, s15
341983ca:	68bb      	ldr	r3, [r7, #8]
341983cc:	66da      	str	r2, [r3, #108]	@ 0x6c

  return ISP_OK;
341983ce:	2300      	movs	r3, #0
}
341983d0:	4618      	mov	r0, r3
341983d2:	3710      	adds	r7, #16
341983d4:	46bd      	mov	sp, r7
341983d6:	bd80      	pop	{r7, pc}
341983d8:	00000000 	.word	0x00000000
341983dc:	404c0000 	.word	0x404c0000

341983e0 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
341983e0:	b580      	push	{r7, lr}
341983e2:	b084      	sub	sp, #16
341983e4:	af00      	add	r7, sp, #0
341983e6:	6078      	str	r0, [r7, #4]
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
341983e8:	687b      	ldr	r3, [r7, #4]
341983ea:	2b00      	cmp	r3, #0
341983ec:	d101      	bne.n	341983f2 <ISP_BackgroundProcess+0x12>
  {
    return ISP_ERR_EINVAL;
341983ee:	2301      	movs	r3, #1
341983f0:	e014      	b.n	3419841c <ISP_BackgroundProcess+0x3c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
341983f2:	6878      	ldr	r0, [r7, #4]
341983f4:	f001 fda2 	bl	34199f3c <ISP_SVC_Stats_ProcessCallbacks>
341983f8:	4603      	mov	r3, r0
341983fa:	73fb      	strb	r3, [r7, #15]

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
341983fc:	6878      	ldr	r0, [r7, #4]
341983fe:	f7ff fdd5 	bl	34197fac <ISP_Algo_Process>
34198402:	4603      	mov	r3, r0
34198404:	73bb      	strb	r3, [r7, #14]
  if (retCmdParser != ISP_OK)
  {
    return retCmdParser;
  }
#endif
  if (retStats != ISP_OK)
34198406:	7bfb      	ldrb	r3, [r7, #15]
34198408:	2b00      	cmp	r3, #0
3419840a:	d001      	beq.n	34198410 <ISP_BackgroundProcess+0x30>
  {
    return retStats;
3419840c:	7bfb      	ldrb	r3, [r7, #15]
3419840e:	e005      	b.n	3419841c <ISP_BackgroundProcess+0x3c>
  }
  else if (retAlgo != ISP_OK)
34198410:	7bbb      	ldrb	r3, [r7, #14]
34198412:	2b00      	cmp	r3, #0
34198414:	d001      	beq.n	3419841a <ISP_BackgroundProcess+0x3a>
  {
    return retAlgo;
34198416:	7bbb      	ldrb	r3, [r7, #14]
34198418:	e000      	b.n	3419841c <ISP_BackgroundProcess+0x3c>
  }

  return ISP_OK;
3419841a:	2300      	movs	r3, #0
}
3419841c:	4618      	mov	r0, r3
3419841e:	3710      	adds	r7, #16
34198420:	46bd      	mov	sp, r7
34198422:	bd80      	pop	{r7, pc}

34198424 <ISP_ListWBRefModes>:
  * @param  hIsp: ISP device handle
  * @param  RefColorTemp: Array of reference color temperatures
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_ListWBRefModes(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp[])
{
34198424:	b580      	push	{r7, lr}
34198426:	b084      	sub	sp, #16
34198428:	af00      	add	r7, sp, #0
3419842a:	6078      	str	r0, [r7, #4]
3419842c:	6039      	str	r1, [r7, #0]
  ISP_IQParamTypeDef *IQParamConfig;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3419842e:	6878      	ldr	r0, [r7, #4]
34198430:	f001 fa86 	bl	34199940 <ISP_SVC_IQParam_Get>
34198434:	60f8      	str	r0, [r7, #12]

  memcpy(RefColorTemp, IQParamConfig->AWBAlgo.referenceColorTemp, sizeof(IQParamConfig->AWBAlgo.referenceColorTemp));
34198436:	68fb      	ldr	r3, [r7, #12]
34198438:	f503 738c 	add.w	r3, r3, #280	@ 0x118
3419843c:	2214      	movs	r2, #20
3419843e:	4619      	mov	r1, r3
34198440:	6838      	ldr	r0, [r7, #0]
34198442:	f00b fd2a 	bl	341a3e9a <memcpy>

  return ISP_OK;
34198446:	2300      	movs	r3, #0
}
34198448:	4618      	mov	r0, r3
3419844a:	3710      	adds	r7, #16
3419844c:	46bd      	mov	sp, r7
3419844e:	bd80      	pop	{r7, pc}

34198450 <ISP_SetWBRefMode>:
  * @param  Automatic: 'true' if the AWB automatic mode is requested
  * @param  RefColorTemp: Reference color temperature (manual mode). Not significant if Automatic is set to 'true'
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint8_t Automatic, uint32_t RefColorTemp)
{
34198450:	b580      	push	{r7, lr}
34198452:	b096      	sub	sp, #88	@ 0x58
34198454:	af00      	add	r7, sp, #0
34198456:	60f8      	str	r0, [r7, #12]
34198458:	460b      	mov	r3, r1
3419845a:	607a      	str	r2, [r7, #4]
3419845c:	72fb      	strb	r3, [r7, #11]
  ISP_ColorConvTypeDef ColorConv;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;
  uint32_t index;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3419845e:	68f8      	ldr	r0, [r7, #12]
34198460:	f001 fa6e 	bl	34199940 <ISP_SVC_IQParam_Get>
34198464:	6538      	str	r0, [r7, #80]	@ 0x50

  if (Automatic)
34198466:	7afb      	ldrb	r3, [r7, #11]
34198468:	2b00      	cmp	r3, #0
3419846a:	d004      	beq.n	34198476 <ISP_SetWBRefMode+0x26>
  {
    /* Start the AWB algorithm */
    IQParamConfig->AWBAlgo.enable = 1;
3419846c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419846e:	2201      	movs	r2, #1
34198470:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
34198474:	e076      	b.n	34198564 <ISP_SetWBRefMode+0x114>
  }
  else
  {
    /* Check the validity of RefColorTemp */
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
34198476:	2300      	movs	r3, #0
34198478:	657b      	str	r3, [r7, #84]	@ 0x54
3419847a:	e00b      	b.n	34198494 <ISP_SetWBRefMode+0x44>
    {
      if (IQParamConfig->AWBAlgo.referenceColorTemp[index] == RefColorTemp)
3419847c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419847e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34198480:	3344      	adds	r3, #68	@ 0x44
34198482:	009b      	lsls	r3, r3, #2
34198484:	4413      	add	r3, r2
34198486:	689b      	ldr	r3, [r3, #8]
34198488:	687a      	ldr	r2, [r7, #4]
3419848a:	429a      	cmp	r2, r3
3419848c:	d006      	beq.n	3419849c <ISP_SetWBRefMode+0x4c>
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
3419848e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34198490:	3301      	adds	r3, #1
34198492:	657b      	str	r3, [r7, #84]	@ 0x54
34198494:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34198496:	2b04      	cmp	r3, #4
34198498:	d9f0      	bls.n	3419847c <ISP_SetWBRefMode+0x2c>
3419849a:	e000      	b.n	3419849e <ISP_SetWBRefMode+0x4e>
        break;
3419849c:	bf00      	nop
    }

    if (index >= ISP_AWB_COLORTEMP_REF)
3419849e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341984a0:	2b04      	cmp	r3, #4
341984a2:	d901      	bls.n	341984a8 <ISP_SetWBRefMode+0x58>
    {
      /* Unknown reference color temperature */
      return ISP_ERR_WB_COLORTEMP;
341984a4:	2396      	movs	r3, #150	@ 0x96
341984a6:	e05e      	b.n	34198566 <ISP_SetWBRefMode+0x116>
    }

    /* Stop the AWB algorithm */
    IQParamConfig->AWBAlgo.enable = 0;
341984a8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341984aa:	2200      	movs	r2, #0
341984ac:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74

    /* Apply ISP RGB gains and Color Conversion */
    ISPGain.enable = 1;
341984b0:	2301      	movs	r3, #1
341984b2:	f887 303c 	strb.w	r3, [r7, #60]	@ 0x3c
    ISPGain.ispGainR = IQParamConfig->AWBAlgo.ispGainR[index];
341984b6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341984b8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341984ba:	334a      	adds	r3, #74	@ 0x4a
341984bc:	009b      	lsls	r3, r3, #2
341984be:	4413      	add	r3, r2
341984c0:	685b      	ldr	r3, [r3, #4]
341984c2:	643b      	str	r3, [r7, #64]	@ 0x40
    ISPGain.ispGainG = IQParamConfig->AWBAlgo.ispGainG[index];
341984c4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341984c6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341984c8:	334e      	adds	r3, #78	@ 0x4e
341984ca:	009b      	lsls	r3, r3, #2
341984cc:	4413      	add	r3, r2
341984ce:	689b      	ldr	r3, [r3, #8]
341984d0:	647b      	str	r3, [r7, #68]	@ 0x44
    ISPGain.ispGainB = IQParamConfig->AWBAlgo.ispGainB[index];
341984d2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341984d4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
341984d6:	3354      	adds	r3, #84	@ 0x54
341984d8:	009b      	lsls	r3, r3, #2
341984da:	4413      	add	r3, r2
341984dc:	685b      	ldr	r3, [r3, #4]
341984de:	64bb      	str	r3, [r7, #72]	@ 0x48
    ColorConv.enable = 1;
341984e0:	2301      	movs	r3, #1
341984e2:	753b      	strb	r3, [r7, #20]
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
341984e4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
341984e6:	4613      	mov	r3, r2
341984e8:	00db      	lsls	r3, r3, #3
341984ea:	4413      	add	r3, r2
341984ec:	009b      	lsls	r3, r3, #2
341984ee:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
341984f2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
341984f4:	4413      	add	r3, r2
341984f6:	f103 0108 	add.w	r1, r3, #8
341984fa:	f107 0314 	add.w	r3, r7, #20
341984fe:	3304      	adds	r3, #4
34198500:	2224      	movs	r2, #36	@ 0x24
34198502:	4618      	mov	r0, r3
34198504:	f00b fcc9 	bl	341a3e9a <memcpy>

    ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGain);
34198508:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
3419850c:	4619      	mov	r1, r3
3419850e:	68f8      	ldr	r0, [r7, #12]
34198510:	f000 fea4 	bl	3419925c <ISP_SVC_ISP_SetGain>
34198514:	4603      	mov	r3, r0
34198516:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
3419851a:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
3419851e:	2b00      	cmp	r3, #0
34198520:	d002      	beq.n	34198528 <ISP_SetWBRefMode+0xd8>
    {
      return ret;
34198522:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34198526:	e01e      	b.n	34198566 <ISP_SetWBRefMode+0x116>
    }

    ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConv);
34198528:	f107 0314 	add.w	r3, r7, #20
3419852c:	4619      	mov	r1, r3
3419852e:	68f8      	ldr	r0, [r7, #12]
34198530:	f000 ff3e 	bl	341993b0 <ISP_SVC_ISP_SetColorConv>
34198534:	4603      	mov	r3, r0
34198536:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
3419853a:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
3419853e:	2b00      	cmp	r3, #0
34198540:	d002      	beq.n	34198548 <ISP_SetWBRefMode+0xf8>
    {
      return ret;
34198542:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34198546:	e00e      	b.n	34198566 <ISP_SetWBRefMode+0x116>
    }

    /* Store the selected mode */
    ret = ISP_SVC_Misc_SetWBRefMode(hIsp, RefColorTemp);
34198548:	6879      	ldr	r1, [r7, #4]
3419854a:	68f8      	ldr	r0, [r7, #12]
3419854c:	f001 f95e 	bl	3419980c <ISP_SVC_Misc_SetWBRefMode>
34198550:	4603      	mov	r3, r0
34198552:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
34198556:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
3419855a:	2b00      	cmp	r3, #0
3419855c:	d002      	beq.n	34198564 <ISP_SetWBRefMode+0x114>
    {
      return ret;
3419855e:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34198562:	e000      	b.n	34198566 <ISP_SetWBRefMode+0x116>
    }
  }

  return ISP_OK;
34198564:	2300      	movs	r3, #0
}
34198566:	4618      	mov	r0, r3
34198568:	3758      	adds	r7, #88	@ 0x58
3419856a:	46bd      	mov	sp, r7
3419856c:	bd80      	pop	{r7, pc}

3419856e <ISP_GatherStatistics>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
3419856e:	b580      	push	{r7, lr}
34198570:	b082      	sub	sp, #8
34198572:	af00      	add	r7, sp, #0
34198574:	6078      	str	r0, [r7, #4]
  ISP_SVC_Stats_Gather(hIsp);
34198576:	6878      	ldr	r0, [r7, #4]
34198578:	f001 fa00 	bl	3419997c <ISP_SVC_Stats_Gather>
}
3419857c:	bf00      	nop
3419857e:	3708      	adds	r7, #8
34198580:	46bd      	mov	sp, r7
34198582:	bd80      	pop	{r7, pc}

34198584 <ISP_IncMainFrameId>:
  *         Increment the frame ID of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
34198584:	b580      	push	{r7, lr}
34198586:	b082      	sub	sp, #8
34198588:	af00      	add	r7, sp, #0
3419858a:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncMainFrameId(hIsp);
3419858c:	6878      	ldr	r0, [r7, #4]
3419858e:	f001 f903 	bl	34199798 <ISP_SVC_Misc_IncMainFrameId>
}
34198592:	bf00      	nop
34198594:	3708      	adds	r7, #8
34198596:	46bd      	mov	sp, r7
34198598:	bd80      	pop	{r7, pc}

3419859a <ISP_IncAncillaryFrameId>:
  *         Increment the frame ID of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
3419859a:	b580      	push	{r7, lr}
3419859c:	b082      	sub	sp, #8
3419859e:	af00      	add	r7, sp, #0
341985a0:	6078      	str	r0, [r7, #4]
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
341985a2:	6878      	ldr	r0, [r7, #4]
341985a4:	f001 f913 	bl	341997ce <ISP_SVC_Misc_IncAncillaryFrameId>
}
341985a8:	bf00      	nop
341985aa:	3708      	adds	r7, #8
341985ac:	46bd      	mov	sp, r7
341985ae:	bd80      	pop	{r7, pc}

341985b0 <ISP_IncDumpFrameId>:
  *         Increment the frame ID of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
341985b0:	b580      	push	{r7, lr}
341985b2:	b082      	sub	sp, #8
341985b4:	af00      	add	r7, sp, #0
341985b6:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
341985b8:	6878      	ldr	r0, [r7, #4]
341985ba:	f001 f917 	bl	341997ec <ISP_SVC_Misc_IncDumpFrameId>
}
341985be:	bf00      	nop
341985c0:	3708      	adds	r7, #8
341985c2:	46bd      	mov	sp, r7
341985c4:	bd80      	pop	{r7, pc}
	...

341985c8 <To_Shift_Multiplier>:
/* Exported variables --------------------------------------------------------*/
extern ISP_MetaTypeDef Meta;

/* Private functions ---------------------------------------------------------*/
static void To_Shift_Multiplier(uint32_t Factor, uint8_t *pShift, uint8_t *pMultiplier)
{
341985c8:	b5b0      	push	{r4, r5, r7, lr}
341985ca:	b086      	sub	sp, #24
341985cc:	af00      	add	r7, sp, #0
341985ce:	60f8      	str	r0, [r7, #12]
341985d0:	60b9      	str	r1, [r7, #8]
341985d2:	607a      	str	r2, [r7, #4]
  /* Convert Factor (Unit = 100000000 for "x1.0") to Multiplier (where 128 means "x1.0") */
  uint64_t Val = Factor;
341985d4:	68fb      	ldr	r3, [r7, #12]
341985d6:	2200      	movs	r2, #0
341985d8:	461c      	mov	r4, r3
341985da:	4615      	mov	r5, r2
341985dc:	e9c7 4504 	strd	r4, r5, [r7, #16]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
341985e0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
341985e4:	4610      	mov	r0, r2
341985e6:	4619      	mov	r1, r3
341985e8:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
341985ec:	a314      	add	r3, pc, #80	@ (adr r3, 34198640 <To_Shift_Multiplier+0x78>)
341985ee:	e9d3 2300 	ldrd	r2, r3, [r3]
341985f2:	f7e9 f8f3 	bl	341817dc <__aeabi_uldivmod>
341985f6:	4602      	mov	r2, r0
341985f8:	460b      	mov	r3, r1
341985fa:	e9c7 2304 	strd	r2, r3, [r7, #16]

  /* Get Shift + Multiplier where Multiplier < 256 */
  *pShift = 0;
341985fe:	68bb      	ldr	r3, [r7, #8]
34198600:	2200      	movs	r2, #0
34198602:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
34198604:	e00b      	b.n	3419861e <To_Shift_Multiplier+0x56>
  {
    Val /= 2;
34198606:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
3419860a:	ea52 035f 	orrs.w	r3, r2, pc, lsr #1
3419860e:	e9c7 2304 	strd	r2, r3, [r7, #16]
    (*pShift)++;
34198612:	68bb      	ldr	r3, [r7, #8]
34198614:	781b      	ldrb	r3, [r3, #0]
34198616:	3301      	adds	r3, #1
34198618:	b2da      	uxtb	r2, r3
3419861a:	68bb      	ldr	r3, [r7, #8]
3419861c:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
3419861e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34198622:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
34198626:	f173 0300 	sbcs.w	r3, r3, #0
3419862a:	d2ec      	bcs.n	34198606 <To_Shift_Multiplier+0x3e>
  }

  *pMultiplier = (uint8_t)Val;
3419862c:	7c3a      	ldrb	r2, [r7, #16]
3419862e:	687b      	ldr	r3, [r7, #4]
34198630:	701a      	strb	r2, [r3, #0]
}
34198632:	bf00      	nop
34198634:	3718      	adds	r7, #24
34198636:	46bd      	mov	sp, r7
34198638:	bdb0      	pop	{r4, r5, r7, pc}
3419863a:	bf00      	nop
3419863c:	f3af 8000 	nop.w
34198640:	05f5e100 	.word	0x05f5e100
34198644:	00000000 	.word	0x00000000

34198648 <From_Shift_Multiplier>:

static uint32_t From_Shift_Multiplier(uint8_t Shift, uint8_t Multiplier)
{
34198648:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
3419864c:	b084      	sub	sp, #16
3419864e:	af00      	add	r7, sp, #0
34198650:	4606      	mov	r6, r0
34198652:	4608      	mov	r0, r1
34198654:	4631      	mov	r1, r6
34198656:	71f9      	strb	r1, [r7, #7]
34198658:	4601      	mov	r1, r0
3419865a:	71b9      	strb	r1, [r7, #6]
  /* Convert Shift + Multiplier to Factor (Unit = 100000000 for "x1.0") */
  uint64_t Val = (1 << Shift);
3419865c:	79f9      	ldrb	r1, [r7, #7]
3419865e:	2001      	movs	r0, #1
34198660:	fa00 f101 	lsl.w	r1, r0, r1
34198664:	17c8      	asrs	r0, r1, #31
34198666:	468a      	mov	sl, r1
34198668:	4683      	mov	fp, r0
3419866a:	e9c7 ab02 	strd	sl, fp, [r7, #8]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
3419866e:	79b9      	ldrb	r1, [r7, #6]
34198670:	2000      	movs	r0, #0
34198672:	4688      	mov	r8, r1
34198674:	4681      	mov	r9, r0
34198676:	68b9      	ldr	r1, [r7, #8]
34198678:	fb09 f001 	mul.w	r0, r9, r1
3419867c:	68f9      	ldr	r1, [r7, #12]
3419867e:	fb08 f101 	mul.w	r1, r8, r1
34198682:	4401      	add	r1, r0
34198684:	68b8      	ldr	r0, [r7, #8]
34198686:	fba0 2308 	umull	r2, r3, r0, r8
3419868a:	4419      	add	r1, r3
3419868c:	460b      	mov	r3, r1
3419868e:	490c      	ldr	r1, [pc, #48]	@ (341986c0 <From_Shift_Multiplier+0x78>)
34198690:	fb01 f003 	mul.w	r0, r1, r3
34198694:	2100      	movs	r1, #0
34198696:	fb02 f101 	mul.w	r1, r2, r1
3419869a:	4401      	add	r1, r0
3419869c:	4808      	ldr	r0, [pc, #32]	@ (341986c0 <From_Shift_Multiplier+0x78>)
3419869e:	fba2 4500 	umull	r4, r5, r2, r0
341986a2:	194b      	adds	r3, r1, r5
341986a4:	461d      	mov	r5, r3
341986a6:	4622      	mov	r2, r4
341986a8:	462b      	mov	r3, r5
341986aa:	ea52 13df 	orrs.w	r3, r2, pc, lsr #7
341986ae:	e9c7 2302 	strd	r2, r3, [r7, #8]
  return (uint32_t) Val;
341986b2:	68bb      	ldr	r3, [r7, #8]
}
341986b4:	4618      	mov	r0, r3
341986b6:	3710      	adds	r7, #16
341986b8:	46bd      	mov	sp, r7
341986ba:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
341986be:	4770      	bx	lr
341986c0:	05f5e100 	.word	0x05f5e100

341986c4 <To_CConv_Reg>:

static int16_t To_CConv_Reg(int32_t Coeff)
{
341986c4:	b580      	push	{r7, lr}
341986c6:	b084      	sub	sp, #16
341986c8:	af00      	add	r7, sp, #0
341986ca:	6078      	str	r0, [r7, #4]
  /* Convert Coefficient (Unit = 100000000 for "x1.0") to register format */
  int64_t Val = Coeff;
341986cc:	6879      	ldr	r1, [r7, #4]
341986ce:	17c8      	asrs	r0, r1, #31
341986d0:	460a      	mov	r2, r1
341986d2:	4603      	mov	r3, r0
341986d4:	e9c7 2302 	strd	r2, r3, [r7, #8]

  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
341986d8:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
341986dc:	4a07      	ldr	r2, [pc, #28]	@ (341986fc <To_CConv_Reg+0x38>)
341986de:	f04f 0300 	mov.w	r3, #0
341986e2:	f7e9 f82b 	bl	3418173c <__aeabi_ldivmod>
341986e6:	4602      	mov	r2, r0
341986e8:	460b      	mov	r3, r1
341986ea:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int16_t) Val;
341986ee:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
}
341986f2:	4618      	mov	r0, r3
341986f4:	3710      	adds	r7, #16
341986f6:	46bd      	mov	sp, r7
341986f8:	bd80      	pop	{r7, pc}
341986fa:	bf00      	nop
341986fc:	0005f5e1 	.word	0x0005f5e1

34198700 <From_CConv_Reg>:

static int32_t From_CConv_Reg(int16_t Reg)
{
34198700:	b4b0      	push	{r4, r5, r7}
34198702:	b085      	sub	sp, #20
34198704:	af00      	add	r7, sp, #0
34198706:	4601      	mov	r1, r0
34198708:	80f9      	strh	r1, [r7, #6]
  /* Convert from register format to Coefficient (Unit = 100000000 for "x1.0") */
  int64_t Val = Reg;
3419870a:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
3419870e:	17c8      	asrs	r0, r1, #31
34198710:	460c      	mov	r4, r1
34198712:	4605      	mov	r5, r0
34198714:	e9c7 4502 	strd	r4, r5, [r7, #8]

  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34198718:	68f9      	ldr	r1, [r7, #12]
3419871a:	480c      	ldr	r0, [pc, #48]	@ (3419874c <From_CConv_Reg+0x4c>)
3419871c:	fb01 f000 	mul.w	r0, r1, r0
34198720:	68b9      	ldr	r1, [r7, #8]
34198722:	2400      	movs	r4, #0
34198724:	fb04 f101 	mul.w	r1, r4, r1
34198728:	4401      	add	r1, r0
3419872a:	68b8      	ldr	r0, [r7, #8]
3419872c:	4c07      	ldr	r4, [pc, #28]	@ (3419874c <From_CConv_Reg+0x4c>)
3419872e:	fba0 2304 	umull	r2, r3, r0, r4
34198732:	4419      	add	r1, r3
34198734:	460b      	mov	r3, r1
34198736:	e9c7 2302 	strd	r2, r3, [r7, #8]
3419873a:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int32_t) Val;
3419873e:	68bb      	ldr	r3, [r7, #8]
}
34198740:	4618      	mov	r0, r3
34198742:	3714      	adds	r7, #20
34198744:	46bd      	mov	sp, r7
34198746:	bcb0      	pop	{r4, r5, r7}
34198748:	4770      	bx	lr
3419874a:	bf00      	nop
3419874c:	0005f5e1 	.word	0x0005f5e1

34198750 <GetAvgStats>:

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
34198750:	b480      	push	{r7}
34198752:	b087      	sub	sp, #28
34198754:	af00      	add	r7, sp, #0
34198756:	60f8      	str	r0, [r7, #12]
34198758:	607b      	str	r3, [r7, #4]
3419875a:	460b      	mov	r3, r1
3419875c:	72fb      	strb	r3, [r7, #11]
3419875e:	4613      	mov	r3, r2
34198760:	72bb      	strb	r3, [r7, #10]
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
34198762:	68fb      	ldr	r3, [r7, #12]
34198764:	691b      	ldr	r3, [r3, #16]
34198766:	68fa      	ldr	r2, [r7, #12]
34198768:	6952      	ldr	r2, [r2, #20]
3419876a:	fb02 f303 	mul.w	r3, r2, r3
3419876e:	613b      	str	r3, [r7, #16]
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
34198770:	4b18      	ldr	r3, [pc, #96]	@ (341987d4 <GetAvgStats+0x84>)
34198772:	781b      	ldrb	r3, [r3, #0]
34198774:	461a      	mov	r2, r3
34198776:	4b17      	ldr	r3, [pc, #92]	@ (341987d4 <GetAvgStats+0x84>)
34198778:	781b      	ldrb	r3, [r3, #0]
3419877a:	fb02 f303 	mul.w	r3, r2, r3
3419877e:	461a      	mov	r2, r3
34198780:	693b      	ldr	r3, [r7, #16]
34198782:	fbb3 f3f2 	udiv	r3, r3, r2
34198786:	613b      	str	r3, [r7, #16]

  if (location == ISP_STAT_LOC_DOWN)
34198788:	7afb      	ldrb	r3, [r7, #11]
3419878a:	2b02      	cmp	r3, #2
3419878c:	d102      	bne.n	34198794 <GetAvgStats+0x44>
  {
    /* RGB format after demosaicing : 1 component per pixel */
    comp_divider = 1;
3419878e:	2301      	movs	r3, #1
34198790:	617b      	str	r3, [r7, #20]
34198792:	e006      	b.n	341987a2 <GetAvgStats+0x52>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
34198794:	7abb      	ldrb	r3, [r7, #10]
34198796:	2b01      	cmp	r3, #1
34198798:	d101      	bne.n	3419879e <GetAvgStats+0x4e>
3419879a:	2302      	movs	r3, #2
3419879c:	e000      	b.n	341987a0 <GetAvgStats+0x50>
3419879e:	2304      	movs	r3, #4
341987a0:	617b      	str	r3, [r7, #20]
  }

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;
341987a2:	693a      	ldr	r2, [r7, #16]
341987a4:	697b      	ldr	r3, [r7, #20]
341987a6:	fbb2 f3f3 	udiv	r3, r2, r3
341987aa:	613b      	str	r3, [r7, #16]

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
341987ac:	693b      	ldr	r3, [r7, #16]
341987ae:	2b00      	cmp	r3, #0
341987b0:	d101      	bne.n	341987b6 <GetAvgStats+0x66>
  {
    return 0;
341987b2:	2300      	movs	r3, #0
341987b4:	e008      	b.n	341987c8 <GetAvgStats+0x78>
  }

  return (uint8_t)(((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix);
341987b6:	687b      	ldr	r3, [r7, #4]
341987b8:	021a      	lsls	r2, r3, #8
341987ba:	693b      	ldr	r3, [r7, #16]
341987bc:	085b      	lsrs	r3, r3, #1
341987be:	441a      	add	r2, r3
341987c0:	693b      	ldr	r3, [r7, #16]
341987c2:	fbb2 f3f3 	udiv	r3, r2, r3
341987c6:	b2db      	uxtb	r3, r3
}
341987c8:	4618      	mov	r0, r3
341987ca:	371c      	adds	r7, #28
341987cc:	46bd      	mov	sp, r7
341987ce:	f85d 7b04 	ldr.w	r7, [sp], #4
341987d2:	4770      	bx	lr
341987d4:	341c00f4 	.word	0x341c00f4

341987d8 <ReadStatHistogram>:

static void ReadStatHistogram(ISP_HandleTypeDef *hIsp, uint32_t *histogram)
{
341987d8:	b580      	push	{r7, lr}
341987da:	b084      	sub	sp, #16
341987dc:	af00      	add	r7, sp, #0
341987de:	6078      	str	r0, [r7, #4]
341987e0:	6039      	str	r1, [r7, #0]
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
341987e2:	2301      	movs	r3, #1
341987e4:	73fb      	strb	r3, [r7, #15]
341987e6:	e00f      	b.n	34198808 <ReadStatHistogram+0x30>
  {
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
341987e8:	687b      	ldr	r3, [r7, #4]
341987ea:	6818      	ldr	r0, [r3, #0]
341987ec:	7bfb      	ldrb	r3, [r7, #15]
341987ee:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
341987f2:	3b01      	subs	r3, #1
341987f4:	009b      	lsls	r3, r3, #2
341987f6:	683a      	ldr	r2, [r7, #0]
341987f8:	4413      	add	r3, r2
341987fa:	7bfa      	ldrb	r2, [r7, #15]
341987fc:	2101      	movs	r1, #1
341987fe:	f7ef fb74 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34198802:	7bfb      	ldrb	r3, [r7, #15]
34198804:	3301      	adds	r3, #1
34198806:	73fb      	strb	r3, [r7, #15]
34198808:	7bfb      	ldrb	r3, [r7, #15]
3419880a:	2b03      	cmp	r3, #3
3419880c:	d9ec      	bls.n	341987e8 <ReadStatHistogram+0x10>
  }
}
3419880e:	bf00      	nop
34198810:	bf00      	nop
34198812:	3710      	adds	r7, #16
34198814:	46bd      	mov	sp, r7
34198816:	bd80      	pop	{r7, pc}

34198818 <SetStatConfig>:

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
34198818:	b480      	push	{r7}
3419881a:	b085      	sub	sp, #20
3419881c:	af00      	add	r7, sp, #0
3419881e:	6078      	str	r0, [r7, #4]
34198820:	6039      	str	r1, [r7, #0]
  for (int i = 0; i < 3; i++)
34198822:	2300      	movs	r3, #0
34198824:	60fb      	str	r3, [r7, #12]
34198826:	e00e      	b.n	34198846 <SetStatConfig+0x2e>
  {
    statConf[i] = *refConfig;
34198828:	68fa      	ldr	r2, [r7, #12]
3419882a:	4613      	mov	r3, r2
3419882c:	005b      	lsls	r3, r3, #1
3419882e:	4413      	add	r3, r2
34198830:	009b      	lsls	r3, r3, #2
34198832:	461a      	mov	r2, r3
34198834:	687b      	ldr	r3, [r7, #4]
34198836:	4413      	add	r3, r2
34198838:	683a      	ldr	r2, [r7, #0]
3419883a:	ca07      	ldmia	r2, {r0, r1, r2}
3419883c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
34198840:	68fb      	ldr	r3, [r7, #12]
34198842:	3301      	adds	r3, #1
34198844:	60fb      	str	r3, [r7, #12]
34198846:	68fb      	ldr	r3, [r7, #12]
34198848:	2b02      	cmp	r3, #2
3419884a:	dded      	ble.n	34198828 <SetStatConfig+0x10>
  }
}
3419884c:	bf00      	nop
3419884e:	bf00      	nop
34198850:	3714      	adds	r7, #20
34198852:	46bd      	mov	sp, r7
34198854:	f85d 7b04 	ldr.w	r7, [sp], #4
34198858:	4770      	bx	lr
	...

3419885c <GetNextStatStage>:

static ISP_SVC_StatEngineStage GetNextStatStage(ISP_SVC_StatEngineStage current)
{
3419885c:	b480      	push	{r7}
3419885e:	b085      	sub	sp, #20
34198860:	af00      	add	r7, sp, #0
34198862:	4603      	mov	r3, r0
34198864:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34198866:	2309      	movs	r3, #9
34198868:	73fb      	strb	r3, [r7, #15]

  /* Special mode for IQ tuning tool asking for all stats : go the the next step, no skip */
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3419886a:	4b73      	ldr	r3, [pc, #460]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419886c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198870:	f003 0304 	and.w	r3, r3, #4
34198874:	2b00      	cmp	r3, #0
34198876:	d106      	bne.n	34198886 <GetNextStatStage+0x2a>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34198878:	4b6f      	ldr	r3, [pc, #444]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419887a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419887e:	f003 0304 	and.w	r3, r3, #4
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34198882:	2b00      	cmp	r3, #0
34198884:	d00a      	beq.n	3419889c <GetNextStatStage+0x40>
  {
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34198886:	79fb      	ldrb	r3, [r7, #7]
34198888:	2b08      	cmp	r3, #8
3419888a:	d803      	bhi.n	34198894 <GetNextStatStage+0x38>
3419888c:	79fb      	ldrb	r3, [r7, #7]
3419888e:	3301      	adds	r3, #1
34198890:	b2db      	uxtb	r3, r3
34198892:	e000      	b.n	34198896 <GetNextStatStage+0x3a>
34198894:	2300      	movs	r3, #0
34198896:	73fb      	strb	r3, [r7, #15]
    return next;
34198898:	7bfb      	ldrb	r3, [r7, #15]
3419889a:	e0c7      	b.n	34198a2c <GetNextStatStage+0x1d0>
   * - ISP_STAT_CFG_UP_AVG
   * - ISP_STAT_CFG_UP_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
   * - ISP_STAT_CFG_DOWN_AVG
   * - ISP_STAT_CFG_DOWN_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
  */
  switch (current)
3419889c:	79fb      	ldrb	r3, [r7, #7]
3419889e:	2b09      	cmp	r3, #9
341988a0:	f200 80b8 	bhi.w	34198a14 <GetNextStatStage+0x1b8>
341988a4:	a201      	add	r2, pc, #4	@ (adr r2, 341988ac <GetNextStatStage+0x50>)
341988a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341988aa:	bf00      	nop
341988ac:	341988d5 	.word	0x341988d5
341988b0:	34198a15 	.word	0x34198a15
341988b4:	34198a15 	.word	0x34198a15
341988b8:	34198a15 	.word	0x34198a15
341988bc:	34198925 	.word	0x34198925
341988c0:	34198975 	.word	0x34198975
341988c4:	34198a15 	.word	0x34198a15
341988c8:	34198a15 	.word	0x34198a15
341988cc:	34198a15 	.word	0x34198a15
341988d0:	341989c5 	.word	0x341989c5
  {
  case ISP_STAT_CFG_UP_AVG:
    /* Try Up Bins */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
341988d4:	4b58      	ldr	r3, [pc, #352]	@ (34198a38 <GetNextStatStage+0x1dc>)
341988d6:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
341988da:	f003 0302 	and.w	r3, r3, #2
341988de:	2b00      	cmp	r3, #0
341988e0:	d002      	beq.n	341988e8 <GetNextStatStage+0x8c>
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
341988e2:	2301      	movs	r3, #1
341988e4:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Bins : try Up Avg */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_UP_AVG;
    }
    break;
341988e6:	e099      	b.n	34198a1c <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
341988e8:	4b53      	ldr	r3, [pc, #332]	@ (34198a38 <GetNextStatStage+0x1dc>)
341988ea:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
341988ee:	f003 0301 	and.w	r3, r3, #1
341988f2:	2b00      	cmp	r3, #0
341988f4:	d002      	beq.n	341988fc <GetNextStatStage+0xa0>
      next = ISP_STAT_CFG_DOWN_AVG;
341988f6:	2305      	movs	r3, #5
341988f8:	73fb      	strb	r3, [r7, #15]
    break;
341988fa:	e08f      	b.n	34198a1c <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
341988fc:	4b4e      	ldr	r3, [pc, #312]	@ (34198a38 <GetNextStatStage+0x1dc>)
341988fe:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198902:	f003 0302 	and.w	r3, r3, #2
34198906:	2b00      	cmp	r3, #0
34198908:	d002      	beq.n	34198910 <GetNextStatStage+0xb4>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3419890a:	2306      	movs	r3, #6
3419890c:	73fb      	strb	r3, [r7, #15]
    break;
3419890e:	e085      	b.n	34198a1c <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34198910:	4b49      	ldr	r3, [pc, #292]	@ (34198a38 <GetNextStatStage+0x1dc>)
34198912:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198916:	f003 0301 	and.w	r3, r3, #1
3419891a:	2b00      	cmp	r3, #0
3419891c:	d07e      	beq.n	34198a1c <GetNextStatStage+0x1c0>
      next = ISP_STAT_CFG_UP_AVG;
3419891e:	2300      	movs	r3, #0
34198920:	73fb      	strb	r3, [r7, #15]
    break;
34198922:	e07b      	b.n	34198a1c <GetNextStatStage+0x1c0>

  case ISP_STAT_CFG_UP_BINS_9_11:
    /* Try Down Avg */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34198924:	4b44      	ldr	r3, [pc, #272]	@ (34198a38 <GetNextStatStage+0x1dc>)
34198926:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419892a:	f003 0301 	and.w	r3, r3, #1
3419892e:	2b00      	cmp	r3, #0
34198930:	d002      	beq.n	34198938 <GetNextStatStage+0xdc>
    {
      next = ISP_STAT_CFG_DOWN_AVG;
34198932:	2305      	movs	r3, #5
34198934:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Avg : try on Up Bins */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
    }
    break;
34198936:	e073      	b.n	34198a20 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34198938:	4b3f      	ldr	r3, [pc, #252]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419893a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419893e:	f003 0302 	and.w	r3, r3, #2
34198942:	2b00      	cmp	r3, #0
34198944:	d002      	beq.n	3419894c <GetNextStatStage+0xf0>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34198946:	2306      	movs	r3, #6
34198948:	73fb      	strb	r3, [r7, #15]
    break;
3419894a:	e069      	b.n	34198a20 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3419894c:	4b3a      	ldr	r3, [pc, #232]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419894e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198952:	f003 0301 	and.w	r3, r3, #1
34198956:	2b00      	cmp	r3, #0
34198958:	d002      	beq.n	34198960 <GetNextStatStage+0x104>
      next = ISP_STAT_CFG_UP_AVG;
3419895a:	2300      	movs	r3, #0
3419895c:	73fb      	strb	r3, [r7, #15]
    break;
3419895e:	e05f      	b.n	34198a20 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34198960:	4b35      	ldr	r3, [pc, #212]	@ (34198a38 <GetNextStatStage+0x1dc>)
34198962:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198966:	f003 0302 	and.w	r3, r3, #2
3419896a:	2b00      	cmp	r3, #0
3419896c:	d058      	beq.n	34198a20 <GetNextStatStage+0x1c4>
      next = ISP_STAT_CFG_UP_BINS_0_2;
3419896e:	2301      	movs	r3, #1
34198970:	73fb      	strb	r3, [r7, #15]
    break;
34198972:	e055      	b.n	34198a20 <GetNextStatStage+0x1c4>

  case ISP_STAT_CFG_DOWN_AVG:
    /* Try Down Bins */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34198974:	4b30      	ldr	r3, [pc, #192]	@ (34198a38 <GetNextStatStage+0x1dc>)
34198976:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419897a:	f003 0302 	and.w	r3, r3, #2
3419897e:	2b00      	cmp	r3, #0
34198980:	d002      	beq.n	34198988 <GetNextStatStage+0x12c>
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34198982:	2306      	movs	r3, #6
34198984:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Bins : try Down Avg */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_DOWN_AVG;
    }
    break;
34198986:	e04d      	b.n	34198a24 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34198988:	4b2b      	ldr	r3, [pc, #172]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419898a:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3419898e:	f003 0301 	and.w	r3, r3, #1
34198992:	2b00      	cmp	r3, #0
34198994:	d002      	beq.n	3419899c <GetNextStatStage+0x140>
      next = ISP_STAT_CFG_UP_AVG;
34198996:	2300      	movs	r3, #0
34198998:	73fb      	strb	r3, [r7, #15]
    break;
3419899a:	e043      	b.n	34198a24 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3419899c:	4b26      	ldr	r3, [pc, #152]	@ (34198a38 <GetNextStatStage+0x1dc>)
3419899e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
341989a2:	f003 0302 	and.w	r3, r3, #2
341989a6:	2b00      	cmp	r3, #0
341989a8:	d002      	beq.n	341989b0 <GetNextStatStage+0x154>
      next = ISP_STAT_CFG_UP_BINS_0_2;
341989aa:	2301      	movs	r3, #1
341989ac:	73fb      	strb	r3, [r7, #15]
    break;
341989ae:	e039      	b.n	34198a24 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
341989b0:	4b21      	ldr	r3, [pc, #132]	@ (34198a38 <GetNextStatStage+0x1dc>)
341989b2:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
341989b6:	f003 0301 	and.w	r3, r3, #1
341989ba:	2b00      	cmp	r3, #0
341989bc:	d032      	beq.n	34198a24 <GetNextStatStage+0x1c8>
      next = ISP_STAT_CFG_DOWN_AVG;
341989be:	2305      	movs	r3, #5
341989c0:	73fb      	strb	r3, [r7, #15]
    break;
341989c2:	e02f      	b.n	34198a24 <GetNextStatStage+0x1c8>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    /* Try Up Avg */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
341989c4:	4b1c      	ldr	r3, [pc, #112]	@ (34198a38 <GetNextStatStage+0x1dc>)
341989c6:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
341989ca:	f003 0301 	and.w	r3, r3, #1
341989ce:	2b00      	cmp	r3, #0
341989d0:	d002      	beq.n	341989d8 <GetNextStatStage+0x17c>
    {
      next = ISP_STAT_CFG_UP_AVG;
341989d2:	2300      	movs	r3, #0
341989d4:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Avg : try Down Bins */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
    }
    break;
341989d6:	e027      	b.n	34198a28 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
341989d8:	4b17      	ldr	r3, [pc, #92]	@ (34198a38 <GetNextStatStage+0x1dc>)
341989da:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
341989de:	f003 0302 	and.w	r3, r3, #2
341989e2:	2b00      	cmp	r3, #0
341989e4:	d002      	beq.n	341989ec <GetNextStatStage+0x190>
      next = ISP_STAT_CFG_UP_BINS_0_2;
341989e6:	2301      	movs	r3, #1
341989e8:	73fb      	strb	r3, [r7, #15]
    break;
341989ea:	e01d      	b.n	34198a28 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
341989ec:	4b12      	ldr	r3, [pc, #72]	@ (34198a38 <GetNextStatStage+0x1dc>)
341989ee:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
341989f2:	f003 0301 	and.w	r3, r3, #1
341989f6:	2b00      	cmp	r3, #0
341989f8:	d002      	beq.n	34198a00 <GetNextStatStage+0x1a4>
      next = ISP_STAT_CFG_DOWN_AVG;
341989fa:	2305      	movs	r3, #5
341989fc:	73fb      	strb	r3, [r7, #15]
    break;
341989fe:	e013      	b.n	34198a28 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34198a00:	4b0d      	ldr	r3, [pc, #52]	@ (34198a38 <GetNextStatStage+0x1dc>)
34198a02:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198a06:	f003 0302 	and.w	r3, r3, #2
34198a0a:	2b00      	cmp	r3, #0
34198a0c:	d00c      	beq.n	34198a28 <GetNextStatStage+0x1cc>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34198a0e:	2306      	movs	r3, #6
34198a10:	73fb      	strb	r3, [r7, #15]
    break;
34198a12:	e009      	b.n	34198a28 <GetNextStatStage+0x1cc>

  default:
    /* In the middle of the bins measurement: continue with the next bins part */
    next = (ISP_SVC_StatEngineStage) (current + 1);
34198a14:	79fb      	ldrb	r3, [r7, #7]
34198a16:	3301      	adds	r3, #1
34198a18:	73fb      	strb	r3, [r7, #15]
    break;
34198a1a:	e006      	b.n	34198a2a <GetNextStatStage+0x1ce>
    break;
34198a1c:	bf00      	nop
34198a1e:	e004      	b.n	34198a2a <GetNextStatStage+0x1ce>
    break;
34198a20:	bf00      	nop
34198a22:	e002      	b.n	34198a2a <GetNextStatStage+0x1ce>
    break;
34198a24:	bf00      	nop
34198a26:	e000      	b.n	34198a2a <GetNextStatStage+0x1ce>
    break;
34198a28:	bf00      	nop
  }

  return next;
34198a2a:	7bfb      	ldrb	r3, [r7, #15]
}
34198a2c:	4618      	mov	r0, r3
34198a2e:	3714      	adds	r7, #20
34198a30:	46bd      	mov	sp, r7
34198a32:	f85d 7b04 	ldr.w	r7, [sp], #4
34198a36:	4770      	bx	lr
34198a38:	341c16b4 	.word	0x341c16b4

34198a3c <GetStatCycleStart>:

static ISP_SVC_StatEngineStage GetStatCycleStart(ISP_SVC_StatLocation location)
{
34198a3c:	b480      	push	{r7}
34198a3e:	b085      	sub	sp, #20
34198a40:	af00      	add	r7, sp, #0
34198a42:	4603      	mov	r3, r0
34198a44:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
34198a46:	79fb      	ldrb	r3, [r7, #7]
34198a48:	2b01      	cmp	r3, #1
34198a4a:	d113      	bne.n	34198a74 <GetStatCycleStart+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34198a4c:	4b16      	ldr	r3, [pc, #88]	@ (34198aa8 <GetStatCycleStart+0x6c>)
34198a4e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198a52:	f003 0301 	and.w	r3, r3, #1
34198a56:	2b00      	cmp	r3, #0
34198a58:	d106      	bne.n	34198a68 <GetStatCycleStart+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
34198a5a:	4b13      	ldr	r3, [pc, #76]	@ (34198aa8 <GetStatCycleStart+0x6c>)
34198a5c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198a60:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34198a64:	2b00      	cmp	r3, #0
34198a66:	d002      	beq.n	34198a6e <GetStatCycleStart+0x32>
    {
      /* Stat up cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
34198a68:	2300      	movs	r3, #0
34198a6a:	73fb      	strb	r3, [r7, #15]
34198a6c:	e015      	b.n	34198a9a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat up cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_UP_BINS_0_2;
34198a6e:	2301      	movs	r3, #1
34198a70:	73fb      	strb	r3, [r7, #15]
34198a72:	e012      	b.n	34198a9a <GetStatCycleStart+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34198a74:	4b0c      	ldr	r3, [pc, #48]	@ (34198aa8 <GetStatCycleStart+0x6c>)
34198a76:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198a7a:	f003 0301 	and.w	r3, r3, #1
34198a7e:	2b00      	cmp	r3, #0
34198a80:	d106      	bne.n	34198a90 <GetStatCycleStart+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34198a82:	4b09      	ldr	r3, [pc, #36]	@ (34198aa8 <GetStatCycleStart+0x6c>)
34198a84:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198a88:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34198a8c:	2b00      	cmp	r3, #0
34198a8e:	d002      	beq.n	34198a96 <GetStatCycleStart+0x5a>
    {
      /* Stat down cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
34198a90:	2305      	movs	r3, #5
34198a92:	73fb      	strb	r3, [r7, #15]
34198a94:	e001      	b.n	34198a9a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat down cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_0_2;
34198a96:	2306      	movs	r3, #6
34198a98:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
34198a9a:	7bfb      	ldrb	r3, [r7, #15]
}
34198a9c:	4618      	mov	r0, r3
34198a9e:	3714      	adds	r7, #20
34198aa0:	46bd      	mov	sp, r7
34198aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
34198aa6:	4770      	bx	lr
34198aa8:	341c16b4 	.word	0x341c16b4

34198aac <GetStatCycleEnd>:

static ISP_SVC_StatEngineStage GetStatCycleEnd(ISP_SVC_StatLocation location)
{
34198aac:	b480      	push	{r7}
34198aae:	b085      	sub	sp, #20
34198ab0:	af00      	add	r7, sp, #0
34198ab2:	4603      	mov	r3, r0
34198ab4:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
34198ab6:	79fb      	ldrb	r3, [r7, #7]
34198ab8:	2b01      	cmp	r3, #1
34198aba:	d113      	bne.n	34198ae4 <GetStatCycleEnd+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34198abc:	4b16      	ldr	r3, [pc, #88]	@ (34198b18 <GetStatCycleEnd+0x6c>)
34198abe:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198ac2:	f003 0302 	and.w	r3, r3, #2
34198ac6:	2b00      	cmp	r3, #0
34198ac8:	d106      	bne.n	34198ad8 <GetStatCycleEnd+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
34198aca:	4b13      	ldr	r3, [pc, #76]	@ (34198b18 <GetStatCycleEnd+0x6c>)
34198acc:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34198ad0:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34198ad4:	2b00      	cmp	r3, #0
34198ad6:	d002      	beq.n	34198ade <GetStatCycleEnd+0x32>
    {
      /* Stat up cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_UP_BINS_9_11;
34198ad8:	2304      	movs	r3, #4
34198ada:	73fb      	strb	r3, [r7, #15]
34198adc:	e015      	b.n	34198b0a <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat up cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
34198ade:	2300      	movs	r3, #0
34198ae0:	73fb      	strb	r3, [r7, #15]
34198ae2:	e012      	b.n	34198b0a <GetStatCycleEnd+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
34198ae4:	4b0c      	ldr	r3, [pc, #48]	@ (34198b18 <GetStatCycleEnd+0x6c>)
34198ae6:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198aea:	f003 0302 	and.w	r3, r3, #2
34198aee:	2b00      	cmp	r3, #0
34198af0:	d106      	bne.n	34198b00 <GetStatCycleEnd+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34198af2:	4b09      	ldr	r3, [pc, #36]	@ (34198b18 <GetStatCycleEnd+0x6c>)
34198af4:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34198af8:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
34198afc:	2b00      	cmp	r3, #0
34198afe:	d002      	beq.n	34198b06 <GetStatCycleEnd+0x5a>
    {
      /* Stat down cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
34198b00:	2309      	movs	r3, #9
34198b02:	73fb      	strb	r3, [r7, #15]
34198b04:	e001      	b.n	34198b0a <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat down cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
34198b06:	2305      	movs	r3, #5
34198b08:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
34198b0a:	7bfb      	ldrb	r3, [r7, #15]
}
34198b0c:	4618      	mov	r0, r3
34198b0e:	3714      	adds	r7, #20
34198b10:	46bd      	mov	sp, r7
34198b12:	f85d 7b04 	ldr.w	r7, [sp], #4
34198b16:	4770      	bx	lr
34198b18:	341c16b4 	.word	0x341c16b4
34198b1c:	00000000 	.word	0x00000000

34198b20 <LuminanceFromRGB>:

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
34198b20:	b480      	push	{r7}
34198b22:	b083      	sub	sp, #12
34198b24:	af00      	add	r7, sp, #0
34198b26:	4603      	mov	r3, r0
34198b28:	71fb      	strb	r3, [r7, #7]
34198b2a:	460b      	mov	r3, r1
34198b2c:	71bb      	strb	r3, [r7, #6]
34198b2e:	4613      	mov	r3, r2
34198b30:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34198b32:	79fb      	ldrb	r3, [r7, #7]
34198b34:	ee07 3a90 	vmov	s15, r3
34198b38:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34198b3c:	ed9f 6b12 	vldr	d6, [pc, #72]	@ 34198b88 <LuminanceFromRGB+0x68>
34198b40:	ee27 6b06 	vmul.f64	d6, d7, d6
34198b44:	79bb      	ldrb	r3, [r7, #6]
34198b46:	ee07 3a90 	vmov	s15, r3
34198b4a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34198b4e:	ed9f 5b10 	vldr	d5, [pc, #64]	@ 34198b90 <LuminanceFromRGB+0x70>
34198b52:	ee27 7b05 	vmul.f64	d7, d7, d5
34198b56:	ee36 6b07 	vadd.f64	d6, d6, d7
34198b5a:	797b      	ldrb	r3, [r7, #5]
34198b5c:	ee07 3a90 	vmov	s15, r3
34198b60:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34198b64:	ed9f 5b0c 	vldr	d5, [pc, #48]	@ 34198b98 <LuminanceFromRGB+0x78>
34198b68:	ee27 7b05 	vmul.f64	d7, d7, d5
34198b6c:	ee36 7b07 	vadd.f64	d7, d6, d7
34198b70:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34198b74:	edc7 7a00 	vstr	s15, [r7]
34198b78:	783b      	ldrb	r3, [r7, #0]
34198b7a:	b2db      	uxtb	r3, r3
}
34198b7c:	4618      	mov	r0, r3
34198b7e:	370c      	adds	r7, #12
34198b80:	46bd      	mov	sp, r7
34198b82:	f85d 7b04 	ldr.w	r7, [sp], #4
34198b86:	4770      	bx	lr
34198b88:	e5604189 	.word	0xe5604189
34198b8c:	3fd322d0 	.word	0x3fd322d0
34198b90:	39581062 	.word	0x39581062
34198b94:	3fe2c8b4 	.word	0x3fe2c8b4
34198b98:	9fbe76c9 	.word	0x9fbe76c9
34198b9c:	3fbd2f1a 	.word	0x3fbd2f1a

34198ba0 <LuminanceFromRGBMono>:

uint8_t LuminanceFromRGBMono(uint8_t r, uint8_t g, uint8_t b)
{
34198ba0:	b480      	push	{r7}
34198ba2:	b085      	sub	sp, #20
34198ba4:	af00      	add	r7, sp, #0
34198ba6:	4603      	mov	r3, r0
34198ba8:	71fb      	strb	r3, [r7, #7]
34198baa:	460b      	mov	r3, r1
34198bac:	71bb      	strb	r3, [r7, #6]
34198bae:	4613      	mov	r3, r2
34198bb0:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components
   * by adding together R, G, B components for monochrome sensor */
  uint32_t lum = (uint32_t)r + g + b;
34198bb2:	79fa      	ldrb	r2, [r7, #7]
34198bb4:	79bb      	ldrb	r3, [r7, #6]
34198bb6:	441a      	add	r2, r3
34198bb8:	797b      	ldrb	r3, [r7, #5]
34198bba:	4413      	add	r3, r2
34198bbc:	60fb      	str	r3, [r7, #12]
  return (uint8_t)((lum > 255)? 255 : lum);
34198bbe:	68fb      	ldr	r3, [r7, #12]
34198bc0:	2bff      	cmp	r3, #255	@ 0xff
34198bc2:	d802      	bhi.n	34198bca <LuminanceFromRGBMono+0x2a>
34198bc4:	68fb      	ldr	r3, [r7, #12]
34198bc6:	b2db      	uxtb	r3, r3
34198bc8:	e000      	b.n	34198bcc <LuminanceFromRGBMono+0x2c>
34198bca:	23ff      	movs	r3, #255	@ 0xff
}
34198bcc:	4618      	mov	r0, r3
34198bce:	3714      	adds	r7, #20
34198bd0:	46bd      	mov	sp, r7
34198bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34198bd6:	4770      	bx	lr

34198bd8 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
34198bd8:	b580      	push	{r7, lr}
34198bda:	b088      	sub	sp, #32
34198bdc:	af00      	add	r7, sp, #0
34198bde:	6078      	str	r0, [r7, #4]
34198be0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34198be2:	687b      	ldr	r3, [r7, #4]
34198be4:	2b00      	cmp	r3, #0
34198be6:	d012      	beq.n	34198c0e <ISP_SVC_ISP_SetDemosaicing+0x36>
34198be8:	683b      	ldr	r3, [r7, #0]
34198bea:	2b00      	cmp	r3, #0
34198bec:	d00f      	beq.n	34198c0e <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34198bee:	683b      	ldr	r3, [r7, #0]
34198bf0:	789b      	ldrb	r3, [r3, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34198bf2:	2b07      	cmp	r3, #7
34198bf4:	d80b      	bhi.n	34198c0e <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34198bf6:	683b      	ldr	r3, [r7, #0]
34198bf8:	78db      	ldrb	r3, [r3, #3]
34198bfa:	2b07      	cmp	r3, #7
34198bfc:	d807      	bhi.n	34198c0e <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34198bfe:	683b      	ldr	r3, [r7, #0]
34198c00:	791b      	ldrb	r3, [r3, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34198c02:	2b07      	cmp	r3, #7
34198c04:	d803      	bhi.n	34198c0e <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34198c06:	683b      	ldr	r3, [r7, #0]
34198c08:	795b      	ldrb	r3, [r3, #5]
34198c0a:	2b07      	cmp	r3, #7
34198c0c:	d901      	bls.n	34198c12 <ISP_SVC_ISP_SetDemosaicing+0x3a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
34198c0e:	230a      	movs	r3, #10
34198c10:	e056      	b.n	34198cc0 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
34198c12:	683b      	ldr	r3, [r7, #0]
34198c14:	781b      	ldrb	r3, [r3, #0]
34198c16:	2b00      	cmp	r3, #0
34198c18:	d003      	beq.n	34198c22 <ISP_SVC_ISP_SetDemosaicing+0x4a>
34198c1a:	683b      	ldr	r3, [r7, #0]
34198c1c:	785b      	ldrb	r3, [r3, #1]
34198c1e:	2b04      	cmp	r3, #4
34198c20:	d108      	bne.n	34198c34 <ISP_SVC_ISP_SetDemosaicing+0x5c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
34198c22:	687b      	ldr	r3, [r7, #4]
34198c24:	681b      	ldr	r3, [r3, #0]
34198c26:	2101      	movs	r1, #1
34198c28:	4618      	mov	r0, r3
34198c2a:	f7ee facf 	bl	341871cc <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
34198c2e:	4603      	mov	r3, r0
34198c30:	77fb      	strb	r3, [r7, #31]
34198c32:	e03f      	b.n	34198cb4 <ISP_SVC_ISP_SetDemosaicing+0xdc>
  }
  else
  {
    switch(pConfig->type)
34198c34:	683b      	ldr	r3, [r7, #0]
34198c36:	785b      	ldrb	r3, [r3, #1]
34198c38:	2b03      	cmp	r3, #3
34198c3a:	d817      	bhi.n	34198c6c <ISP_SVC_ISP_SetDemosaicing+0x94>
34198c3c:	a201      	add	r2, pc, #4	@ (adr r2, 34198c44 <ISP_SVC_ISP_SetDemosaicing+0x6c>)
34198c3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34198c42:	bf00      	nop
34198c44:	34198c55 	.word	0x34198c55
34198c48:	34198c5b 	.word	0x34198c5b
34198c4c:	34198c61 	.word	0x34198c61
34198c50:	34198c67 	.word	0x34198c67
    {
      case ISP_DEMOS_TYPE_RGGB:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
34198c54:	2300      	movs	r3, #0
34198c56:	613b      	str	r3, [r7, #16]
        break;
34198c58:	e00b      	b.n	34198c72 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GRBG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GRBG;
34198c5a:	2302      	movs	r3, #2
34198c5c:	613b      	str	r3, [r7, #16]
        break;
34198c5e:	e008      	b.n	34198c72 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GBRG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GBRG;
34198c60:	2304      	movs	r3, #4
34198c62:	613b      	str	r3, [r7, #16]
        break;
34198c64:	e005      	b.n	34198c72 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_BGGR:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_BGGR;
34198c66:	2306      	movs	r3, #6
34198c68:	613b      	str	r3, [r7, #16]
        break;
34198c6a:	e002      	b.n	34198c72 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      default:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
34198c6c:	2300      	movs	r3, #0
34198c6e:	613b      	str	r3, [r7, #16]
        break;
34198c70:	bf00      	nop
    }

    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
34198c72:	683b      	ldr	r3, [r7, #0]
34198c74:	789b      	ldrb	r3, [r3, #2]
34198c76:	617b      	str	r3, [r7, #20]
    rawBayerCfg.VLineStrength = (uint32_t) pConfig->lineV;
34198c78:	683b      	ldr	r3, [r7, #0]
34198c7a:	78db      	ldrb	r3, [r3, #3]
34198c7c:	60bb      	str	r3, [r7, #8]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
34198c7e:	683b      	ldr	r3, [r7, #0]
34198c80:	791b      	ldrb	r3, [r3, #4]
34198c82:	60fb      	str	r3, [r7, #12]
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
34198c84:	683b      	ldr	r3, [r7, #0]
34198c86:	795b      	ldrb	r3, [r3, #5]
34198c88:	61bb      	str	r3, [r7, #24]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
34198c8a:	687b      	ldr	r3, [r7, #4]
34198c8c:	681b      	ldr	r3, [r3, #0]
34198c8e:	f107 0208 	add.w	r2, r7, #8
34198c92:	2101      	movs	r1, #1
34198c94:	4618      	mov	r0, r3
34198c96:	f7ee fa3d 	bl	34187114 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
34198c9a:	4603      	mov	r3, r0
34198c9c:	77fb      	strb	r3, [r7, #31]

    if (halStatus == HAL_OK)
34198c9e:	7ffb      	ldrb	r3, [r7, #31]
34198ca0:	2b00      	cmp	r3, #0
34198ca2:	d107      	bne.n	34198cb4 <ISP_SVC_ISP_SetDemosaicing+0xdc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
34198ca4:	687b      	ldr	r3, [r7, #4]
34198ca6:	681b      	ldr	r3, [r3, #0]
34198ca8:	2101      	movs	r1, #1
34198caa:	4618      	mov	r0, r3
34198cac:	f7ee fa6e 	bl	3418718c <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
34198cb0:	4603      	mov	r3, r0
34198cb2:	77fb      	strb	r3, [r7, #31]
    }
  }

  if (halStatus != HAL_OK)
34198cb4:	7ffb      	ldrb	r3, [r7, #31]
34198cb6:	2b00      	cmp	r3, #0
34198cb8:	d001      	beq.n	34198cbe <ISP_SVC_ISP_SetDemosaicing+0xe6>
  {
    return ISP_ERR_DEMOSAICING_HAL;
34198cba:	230b      	movs	r3, #11
34198cbc:	e000      	b.n	34198cc0 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  return ISP_OK;
34198cbe:	2300      	movs	r3, #0
}
34198cc0:	4618      	mov	r0, r3
34198cc2:	3720      	adds	r7, #32
34198cc4:	46bd      	mov	sp, r7
34198cc6:	bd80      	pop	{r7, pc}

34198cc8 <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
34198cc8:	b580      	push	{r7, lr}
34198cca:	b084      	sub	sp, #16
34198ccc:	af00      	add	r7, sp, #0
34198cce:	6078      	str	r0, [r7, #4]
34198cd0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34198cd2:	687b      	ldr	r3, [r7, #4]
34198cd4:	2b00      	cmp	r3, #0
34198cd6:	d00c      	beq.n	34198cf2 <ISP_SVC_ISP_SetStatRemoval+0x2a>
34198cd8:	683b      	ldr	r3, [r7, #0]
34198cda:	2b00      	cmp	r3, #0
34198cdc:	d009      	beq.n	34198cf2 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
34198cde:	683b      	ldr	r3, [r7, #0]
34198ce0:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34198ce2:	2b07      	cmp	r3, #7
34198ce4:	d805      	bhi.n	34198cf2 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
34198ce6:	683b      	ldr	r3, [r7, #0]
34198ce8:	689b      	ldr	r3, [r3, #8]
34198cea:	f640 72fe 	movw	r2, #4094	@ 0xffe
34198cee:	4293      	cmp	r3, r2
34198cf0:	d901      	bls.n	34198cf6 <ISP_SVC_ISP_SetStatRemoval+0x2e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
34198cf2:	2314      	movs	r3, #20
34198cf4:	e028      	b.n	34198d48 <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  if (pConfig->enable == 0)
34198cf6:	683b      	ldr	r3, [r7, #0]
34198cf8:	781b      	ldrb	r3, [r3, #0]
34198cfa:	2b00      	cmp	r3, #0
34198cfc:	d108      	bne.n	34198d10 <ISP_SVC_ISP_SetStatRemoval+0x48>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34198cfe:	687b      	ldr	r3, [r7, #4]
34198d00:	681b      	ldr	r3, [r3, #0]
34198d02:	2101      	movs	r1, #1
34198d04:	4618      	mov	r0, r3
34198d06:	f7ee facc 	bl	341872a2 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
34198d0a:	4603      	mov	r3, r0
34198d0c:	73fb      	strb	r3, [r7, #15]
34198d0e:	e015      	b.n	34198d3c <ISP_SVC_ISP_SetStatRemoval+0x74>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
34198d10:	687b      	ldr	r3, [r7, #4]
34198d12:	6818      	ldr	r0, [r3, #0]
34198d14:	683b      	ldr	r3, [r7, #0]
34198d16:	685a      	ldr	r2, [r3, #4]
34198d18:	683b      	ldr	r3, [r7, #0]
34198d1a:	689b      	ldr	r3, [r3, #8]
34198d1c:	2101      	movs	r1, #1
34198d1e:	f7ee fa75 	bl	3418720c <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
34198d22:	4603      	mov	r3, r0
34198d24:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
34198d26:	7bfb      	ldrb	r3, [r7, #15]
34198d28:	2b00      	cmp	r3, #0
34198d2a:	d107      	bne.n	34198d3c <ISP_SVC_ISP_SetStatRemoval+0x74>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
34198d2c:	687b      	ldr	r3, [r7, #4]
34198d2e:	681b      	ldr	r3, [r3, #0]
34198d30:	2101      	movs	r1, #1
34198d32:	4618      	mov	r0, r3
34198d34:	f7ee fa95 	bl	34187262 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
34198d38:	4603      	mov	r3, r0
34198d3a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
34198d3c:	7bfb      	ldrb	r3, [r7, #15]
34198d3e:	2b00      	cmp	r3, #0
34198d40:	d001      	beq.n	34198d46 <ISP_SVC_ISP_SetStatRemoval+0x7e>
  {
    return ISP_ERR_STATREMOVAL_HAL;
34198d42:	2315      	movs	r3, #21
34198d44:	e000      	b.n	34198d48 <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  return ISP_OK;
34198d46:	2300      	movs	r3, #0
}
34198d48:	4618      	mov	r0, r3
34198d4a:	3710      	adds	r7, #16
34198d4c:	46bd      	mov	sp, r7
34198d4e:	bd80      	pop	{r7, pc}

34198d50 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
34198d50:	b580      	push	{r7, lr}
34198d52:	b086      	sub	sp, #24
34198d54:	af00      	add	r7, sp, #0
34198d56:	6078      	str	r0, [r7, #4]
34198d58:	6039      	str	r1, [r7, #0]
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;
34198d5a:	2300      	movs	r3, #0
34198d5c:	75fb      	strb	r3, [r7, #23]

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34198d5e:	687b      	ldr	r3, [r7, #4]
34198d60:	2b00      	cmp	r3, #0
34198d62:	d002      	beq.n	34198d6a <ISP_SVC_ISP_SetDecimation+0x1a>
34198d64:	683b      	ldr	r3, [r7, #0]
34198d66:	2b00      	cmp	r3, #0
34198d68:	d101      	bne.n	34198d6e <ISP_SVC_ISP_SetDecimation+0x1e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
34198d6a:	231e      	movs	r3, #30
34198d6c:	e04b      	b.n	34198e06 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  switch (pConfig->factor)
34198d6e:	683b      	ldr	r3, [r7, #0]
34198d70:	781b      	ldrb	r3, [r3, #0]
34198d72:	3b01      	subs	r3, #1
34198d74:	2b07      	cmp	r3, #7
34198d76:	d827      	bhi.n	34198dc8 <ISP_SVC_ISP_SetDecimation+0x78>
34198d78:	a201      	add	r2, pc, #4	@ (adr r2, 34198d80 <ISP_SVC_ISP_SetDecimation+0x30>)
34198d7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34198d7e:	bf00      	nop
34198d80:	34198da1 	.word	0x34198da1
34198d84:	34198dab 	.word	0x34198dab
34198d88:	34198dc9 	.word	0x34198dc9
34198d8c:	34198db5 	.word	0x34198db5
34198d90:	34198dc9 	.word	0x34198dc9
34198d94:	34198dc9 	.word	0x34198dc9
34198d98:	34198dc9 	.word	0x34198dc9
34198d9c:	34198dbf 	.word	0x34198dbf
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
34198da0:	2300      	movs	r3, #0
34198da2:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
34198da4:	2300      	movs	r3, #0
34198da6:	613b      	str	r3, [r7, #16]
    break;
34198da8:	e010      	b.n	34198dcc <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_2:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_2;
34198daa:	2308      	movs	r3, #8
34198dac:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_2;
34198dae:	2302      	movs	r3, #2
34198db0:	613b      	str	r3, [r7, #16]
    break;
34198db2:	e00b      	b.n	34198dcc <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_4:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_4;
34198db4:	2310      	movs	r3, #16
34198db6:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_4;
34198db8:	2304      	movs	r3, #4
34198dba:	613b      	str	r3, [r7, #16]
    break;
34198dbc:	e006      	b.n	34198dcc <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_8:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_8;
34198dbe:	2318      	movs	r3, #24
34198dc0:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_8;
34198dc2:	2306      	movs	r3, #6
34198dc4:	613b      	str	r3, [r7, #16]
    break;
34198dc6:	e001      	b.n	34198dcc <ISP_SVC_ISP_SetDecimation+0x7c>

  default:
    return ISP_ERR_DECIMATION_EINVAL;
34198dc8:	231e      	movs	r3, #30
34198dca:	e01c      	b.n	34198e06 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
34198dcc:	687b      	ldr	r3, [r7, #4]
34198dce:	681b      	ldr	r3, [r3, #0]
34198dd0:	f107 020c 	add.w	r2, r7, #12
34198dd4:	2101      	movs	r1, #1
34198dd6:	4618      	mov	r0, r3
34198dd8:	f7ed ff75 	bl	34186cc6 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
34198ddc:	4603      	mov	r3, r0
34198dde:	2b00      	cmp	r3, #0
34198de0:	d001      	beq.n	34198de6 <ISP_SVC_ISP_SetDecimation+0x96>
  {
    return ISP_ERR_DECIMATION_HAL;
34198de2:	231f      	movs	r3, #31
34198de4:	e00f      	b.n	34198e06 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
34198de6:	687b      	ldr	r3, [r7, #4]
34198de8:	681b      	ldr	r3, [r3, #0]
34198dea:	2101      	movs	r1, #1
34198dec:	4618      	mov	r0, r3
34198dee:	f7ed ff9b 	bl	34186d28 <HAL_DCMIPP_PIPE_EnableISPDecimation>
34198df2:	4603      	mov	r3, r0
34198df4:	2b00      	cmp	r3, #0
34198df6:	d001      	beq.n	34198dfc <ISP_SVC_ISP_SetDecimation+0xac>
  {
    return ISP_ERR_DECIMATION_HAL;
34198df8:	231f      	movs	r3, #31
34198dfa:	e004      	b.n	34198e06 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;
34198dfc:	683b      	ldr	r3, [r7, #0]
34198dfe:	781a      	ldrb	r2, [r3, #0]
34198e00:	4b03      	ldr	r3, [pc, #12]	@ (34198e10 <ISP_SVC_ISP_SetDecimation+0xc0>)
34198e02:	701a      	strb	r2, [r3, #0]

  return ret;
34198e04:	7dfb      	ldrb	r3, [r7, #23]
}
34198e06:	4618      	mov	r0, r3
34198e08:	3718      	adds	r7, #24
34198e0a:	46bd      	mov	sp, r7
34198e0c:	bd80      	pop	{r7, pc}
34198e0e:	bf00      	nop
34198e10:	341c00f4 	.word	0x341c00f4

34198e14 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
34198e14:	b580      	push	{r7, lr}
34198e16:	b086      	sub	sp, #24
34198e18:	af00      	add	r7, sp, #0
34198e1a:	6078      	str	r0, [r7, #4]
34198e1c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34198e1e:	687b      	ldr	r3, [r7, #4]
34198e20:	2b00      	cmp	r3, #0
34198e22:	d02f      	beq.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
34198e24:	683b      	ldr	r3, [r7, #0]
34198e26:	2b00      	cmp	r3, #0
34198e28:	d02c      	beq.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e2a:	683b      	ldr	r3, [r7, #0]
34198e2c:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34198e2e:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e32:	d827      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e34:	683b      	ldr	r3, [r7, #0]
34198e36:	689b      	ldr	r3, [r3, #8]
34198e38:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e3c:	d822      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e3e:	683b      	ldr	r3, [r7, #0]
34198e40:	68db      	ldr	r3, [r3, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e42:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e46:	d81d      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e48:	683b      	ldr	r3, [r7, #0]
34198e4a:	691b      	ldr	r3, [r3, #16]
34198e4c:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e50:	d818      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e52:	683b      	ldr	r3, [r7, #0]
34198e54:	695b      	ldr	r3, [r3, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e56:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e5a:	d813      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e5c:	683b      	ldr	r3, [r7, #0]
34198e5e:	699b      	ldr	r3, [r3, #24]
34198e60:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e64:	d80e      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e66:	683b      	ldr	r3, [r7, #0]
34198e68:	69db      	ldr	r3, [r3, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e6a:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e6e:	d809      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e70:	683b      	ldr	r3, [r7, #0]
34198e72:	6a1b      	ldr	r3, [r3, #32]
34198e74:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e78:	d804      	bhi.n	34198e84 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
34198e7a:	683b      	ldr	r3, [r7, #0]
34198e7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
34198e7e:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
34198e82:	d901      	bls.n	34198e88 <ISP_SVC_ISP_SetContrast+0x74>
  {
    return ISP_ERR_CONTRAST_EINVAL;
34198e84:	2328      	movs	r3, #40	@ 0x28
34198e86:	e078      	b.n	34198f7a <ISP_SVC_ISP_SetContrast+0x166>
  }

  if (pConfig->enable == 0)
34198e88:	683b      	ldr	r3, [r7, #0]
34198e8a:	781b      	ldrb	r3, [r3, #0]
34198e8c:	2b00      	cmp	r3, #0
34198e8e:	d108      	bne.n	34198ea2 <ISP_SVC_ISP_SetContrast+0x8e>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34198e90:	687b      	ldr	r3, [r7, #4]
34198e92:	681b      	ldr	r3, [r3, #0]
34198e94:	2101      	movs	r1, #1
34198e96:	4618      	mov	r0, r3
34198e98:	f7ee ff06 	bl	34187ca8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
34198e9c:	4603      	mov	r3, r0
34198e9e:	75fb      	strb	r3, [r7, #23]
34198ea0:	e065      	b.n	34198f6e <ISP_SVC_ISP_SetContrast+0x15a>
  }
  else
  {
    /* Convert coefficient unit from "percentage" to "6 bit" */
    contrast.LUM_0 = (uint8_t)((pConfig->coeff.LUM_0 * 16) / 100);
34198ea2:	683b      	ldr	r3, [r7, #0]
34198ea4:	685b      	ldr	r3, [r3, #4]
34198ea6:	011b      	lsls	r3, r3, #4
34198ea8:	4a36      	ldr	r2, [pc, #216]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198eaa:	fba2 2303 	umull	r2, r3, r2, r3
34198eae:	095b      	lsrs	r3, r3, #5
34198eb0:	b2db      	uxtb	r3, r3
34198eb2:	733b      	strb	r3, [r7, #12]
    contrast.LUM_32 = (uint8_t)((pConfig->coeff.LUM_32 * 16) / 100);
34198eb4:	683b      	ldr	r3, [r7, #0]
34198eb6:	689b      	ldr	r3, [r3, #8]
34198eb8:	011b      	lsls	r3, r3, #4
34198eba:	4a32      	ldr	r2, [pc, #200]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198ebc:	fba2 2303 	umull	r2, r3, r2, r3
34198ec0:	095b      	lsrs	r3, r3, #5
34198ec2:	b2db      	uxtb	r3, r3
34198ec4:	737b      	strb	r3, [r7, #13]
    contrast.LUM_64 = (uint8_t)((pConfig->coeff.LUM_64 * 16) / 100);
34198ec6:	683b      	ldr	r3, [r7, #0]
34198ec8:	68db      	ldr	r3, [r3, #12]
34198eca:	011b      	lsls	r3, r3, #4
34198ecc:	4a2d      	ldr	r2, [pc, #180]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198ece:	fba2 2303 	umull	r2, r3, r2, r3
34198ed2:	095b      	lsrs	r3, r3, #5
34198ed4:	b2db      	uxtb	r3, r3
34198ed6:	73bb      	strb	r3, [r7, #14]
    contrast.LUM_96 = (uint8_t)((pConfig->coeff.LUM_96 * 16) / 100);
34198ed8:	683b      	ldr	r3, [r7, #0]
34198eda:	691b      	ldr	r3, [r3, #16]
34198edc:	011b      	lsls	r3, r3, #4
34198ede:	4a29      	ldr	r2, [pc, #164]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198ee0:	fba2 2303 	umull	r2, r3, r2, r3
34198ee4:	095b      	lsrs	r3, r3, #5
34198ee6:	b2db      	uxtb	r3, r3
34198ee8:	73fb      	strb	r3, [r7, #15]
    contrast.LUM_128 = (uint8_t)((pConfig->coeff.LUM_128 * 16) / 100);
34198eea:	683b      	ldr	r3, [r7, #0]
34198eec:	695b      	ldr	r3, [r3, #20]
34198eee:	011b      	lsls	r3, r3, #4
34198ef0:	4a24      	ldr	r2, [pc, #144]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198ef2:	fba2 2303 	umull	r2, r3, r2, r3
34198ef6:	095b      	lsrs	r3, r3, #5
34198ef8:	b2db      	uxtb	r3, r3
34198efa:	743b      	strb	r3, [r7, #16]
    contrast.LUM_160 = (uint8_t)((pConfig->coeff.LUM_160 * 16) / 100);
34198efc:	683b      	ldr	r3, [r7, #0]
34198efe:	699b      	ldr	r3, [r3, #24]
34198f00:	011b      	lsls	r3, r3, #4
34198f02:	4a20      	ldr	r2, [pc, #128]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198f04:	fba2 2303 	umull	r2, r3, r2, r3
34198f08:	095b      	lsrs	r3, r3, #5
34198f0a:	b2db      	uxtb	r3, r3
34198f0c:	747b      	strb	r3, [r7, #17]
    contrast.LUM_192 = (uint8_t)((pConfig->coeff.LUM_192 * 16) / 100);
34198f0e:	683b      	ldr	r3, [r7, #0]
34198f10:	69db      	ldr	r3, [r3, #28]
34198f12:	011b      	lsls	r3, r3, #4
34198f14:	4a1b      	ldr	r2, [pc, #108]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198f16:	fba2 2303 	umull	r2, r3, r2, r3
34198f1a:	095b      	lsrs	r3, r3, #5
34198f1c:	b2db      	uxtb	r3, r3
34198f1e:	74bb      	strb	r3, [r7, #18]
    contrast.LUM_224 = (uint8_t)((pConfig->coeff.LUM_224 * 16) / 100);
34198f20:	683b      	ldr	r3, [r7, #0]
34198f22:	6a1b      	ldr	r3, [r3, #32]
34198f24:	011b      	lsls	r3, r3, #4
34198f26:	4a17      	ldr	r2, [pc, #92]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198f28:	fba2 2303 	umull	r2, r3, r2, r3
34198f2c:	095b      	lsrs	r3, r3, #5
34198f2e:	b2db      	uxtb	r3, r3
34198f30:	74fb      	strb	r3, [r7, #19]
    contrast.LUM_256 = (uint8_t)((pConfig->coeff.LUM_256 * 16) / 100);
34198f32:	683b      	ldr	r3, [r7, #0]
34198f34:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34198f36:	011b      	lsls	r3, r3, #4
34198f38:	4a12      	ldr	r2, [pc, #72]	@ (34198f84 <ISP_SVC_ISP_SetContrast+0x170>)
34198f3a:	fba2 2303 	umull	r2, r3, r2, r3
34198f3e:	095b      	lsrs	r3, r3, #5
34198f40:	b2db      	uxtb	r3, r3
34198f42:	753b      	strb	r3, [r7, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
34198f44:	687b      	ldr	r3, [r7, #4]
34198f46:	681b      	ldr	r3, [r3, #0]
34198f48:	f107 020c 	add.w	r2, r7, #12
34198f4c:	2101      	movs	r1, #1
34198f4e:	4618      	mov	r0, r3
34198f50:	f7ee fe3a 	bl	34187bc8 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
34198f54:	4603      	mov	r3, r0
34198f56:	75fb      	strb	r3, [r7, #23]

    if (halStatus == HAL_OK)
34198f58:	7dfb      	ldrb	r3, [r7, #23]
34198f5a:	2b00      	cmp	r3, #0
34198f5c:	d107      	bne.n	34198f6e <ISP_SVC_ISP_SetContrast+0x15a>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
34198f5e:	687b      	ldr	r3, [r7, #4]
34198f60:	681b      	ldr	r3, [r3, #0]
34198f62:	2101      	movs	r1, #1
34198f64:	4618      	mov	r0, r3
34198f66:	f7ee fe7f 	bl	34187c68 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
34198f6a:	4603      	mov	r3, r0
34198f6c:	75fb      	strb	r3, [r7, #23]
    }
  }

  if (halStatus != HAL_OK)
34198f6e:	7dfb      	ldrb	r3, [r7, #23]
34198f70:	2b00      	cmp	r3, #0
34198f72:	d001      	beq.n	34198f78 <ISP_SVC_ISP_SetContrast+0x164>
  {
    return ISP_ERR_CONTRAST_HAL;
34198f74:	2329      	movs	r3, #41	@ 0x29
34198f76:	e000      	b.n	34198f7a <ISP_SVC_ISP_SetContrast+0x166>
  }

  return ISP_OK;
34198f78:	2300      	movs	r3, #0
}
34198f7a:	4618      	mov	r0, r3
34198f7c:	3718      	adds	r7, #24
34198f7e:	46bd      	mov	sp, r7
34198f80:	bd80      	pop	{r7, pc}
34198f82:	bf00      	nop
34198f84:	51eb851f 	.word	0x51eb851f

34198f88 <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
34198f88:	b590      	push	{r4, r7, lr}
34198f8a:	b089      	sub	sp, #36	@ 0x24
34198f8c:	af00      	add	r7, sp, #0
34198f8e:	6078      	str	r0, [r7, #4]
34198f90:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;
34198f92:	2300      	movs	r3, #0
34198f94:	77fb      	strb	r3, [r7, #31]

  if ((hIsp == NULL) || (pConfig == NULL) ||
34198f96:	687b      	ldr	r3, [r7, #4]
34198f98:	2b00      	cmp	r3, #0
34198f9a:	d034      	beq.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
34198f9c:	683b      	ldr	r3, [r7, #0]
34198f9e:	2b00      	cmp	r3, #0
34198fa0:	d031      	beq.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
34198fa2:	683b      	ldr	r3, [r7, #0]
34198fa4:	681b      	ldr	r3, [r3, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34198fa6:	f640 72fe 	movw	r2, #4094	@ 0xffe
34198faa:	4293      	cmp	r3, r2
34198fac:	d82b      	bhi.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
34198fae:	683b      	ldr	r3, [r7, #0]
34198fb0:	685b      	ldr	r3, [r3, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
34198fb2:	f640 72fe 	movw	r2, #4094	@ 0xffe
34198fb6:	4293      	cmp	r3, r2
34198fb8:	d825      	bhi.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34198fba:	683b      	ldr	r3, [r7, #0]
34198fbc:	689b      	ldr	r3, [r3, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
34198fbe:	f640 72fe 	movw	r2, #4094	@ 0xffe
34198fc2:	4293      	cmp	r3, r2
34198fc4:	d81f      	bhi.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
34198fc6:	683b      	ldr	r3, [r7, #0]
34198fc8:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
34198fca:	f640 72fe 	movw	r2, #4094	@ 0xffe
34198fce:	4293      	cmp	r3, r2
34198fd0:	d819      	bhi.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
34198fd2:	683b      	ldr	r3, [r7, #0]
34198fd4:	689b      	ldr	r3, [r3, #8]
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
34198fd6:	2b03      	cmp	r3, #3
34198fd8:	d915      	bls.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
34198fda:	683b      	ldr	r3, [r7, #0]
34198fdc:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
34198fde:	2b03      	cmp	r3, #3
34198fe0:	d911      	bls.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
34198fe2:	683b      	ldr	r3, [r7, #0]
34198fe4:	681a      	ldr	r2, [r3, #0]
34198fe6:	683b      	ldr	r3, [r7, #0]
34198fe8:	689b      	ldr	r3, [r3, #8]
34198fea:	441a      	add	r2, r3
34198fec:	687b      	ldr	r3, [r7, #4]
34198fee:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
34198ff0:	429a      	cmp	r2, r3
34198ff2:	d808      	bhi.n	34199006 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
34198ff4:	683b      	ldr	r3, [r7, #0]
34198ff6:	685a      	ldr	r2, [r3, #4]
34198ff8:	683b      	ldr	r3, [r7, #0]
34198ffa:	68db      	ldr	r3, [r3, #12]
34198ffc:	441a      	add	r2, r3
34198ffe:	687b      	ldr	r3, [r7, #4]
34199000:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
34199002:	429a      	cmp	r2, r3
34199004:	d901      	bls.n	3419900a <ISP_SVC_ISP_SetStatArea+0x82>
  {
    return ISP_ERR_STATAREA_EINVAL;
34199006:	2332      	movs	r3, #50	@ 0x32
34199008:	e03e      	b.n	34199088 <ISP_SVC_ISP_SetStatArea+0x100>
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
3419900a:	683b      	ldr	r3, [r7, #0]
3419900c:	681b      	ldr	r3, [r3, #0]
3419900e:	4a20      	ldr	r2, [pc, #128]	@ (34199090 <ISP_SVC_ISP_SetStatArea+0x108>)
34199010:	7812      	ldrb	r2, [r2, #0]
34199012:	fbb3 f3f2 	udiv	r3, r3, r2
34199016:	613b      	str	r3, [r7, #16]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
34199018:	683b      	ldr	r3, [r7, #0]
3419901a:	685b      	ldr	r3, [r3, #4]
3419901c:	4a1c      	ldr	r2, [pc, #112]	@ (34199090 <ISP_SVC_ISP_SetStatArea+0x108>)
3419901e:	7812      	ldrb	r2, [r2, #0]
34199020:	fbb3 f3f2 	udiv	r3, r3, r2
34199024:	60fb      	str	r3, [r7, #12]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
34199026:	683b      	ldr	r3, [r7, #0]
34199028:	689b      	ldr	r3, [r3, #8]
3419902a:	4a19      	ldr	r2, [pc, #100]	@ (34199090 <ISP_SVC_ISP_SetStatArea+0x108>)
3419902c:	7812      	ldrb	r2, [r2, #0]
3419902e:	fbb3 f3f2 	udiv	r3, r3, r2
34199032:	61bb      	str	r3, [r7, #24]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
34199034:	683b      	ldr	r3, [r7, #0]
34199036:	68db      	ldr	r3, [r3, #12]
34199038:	4a15      	ldr	r2, [pc, #84]	@ (34199090 <ISP_SVC_ISP_SetStatArea+0x108>)
3419903a:	7812      	ldrb	r2, [r2, #0]
3419903c:	fbb3 f3f2 	udiv	r3, r3, r2
34199040:	617b      	str	r3, [r7, #20]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
34199042:	687b      	ldr	r3, [r7, #4]
34199044:	681b      	ldr	r3, [r3, #0]
34199046:	f107 020c 	add.w	r2, r7, #12
3419904a:	2101      	movs	r1, #1
3419904c:	4618      	mov	r0, r3
3419904e:	f7ee fc9e 	bl	3418798e <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
34199052:	4603      	mov	r3, r0
34199054:	2b00      	cmp	r3, #0
34199056:	d001      	beq.n	3419905c <ISP_SVC_ISP_SetStatArea+0xd4>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
34199058:	2333      	movs	r3, #51	@ 0x33
3419905a:	e015      	b.n	34199088 <ISP_SVC_ISP_SetStatArea+0x100>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
3419905c:	687b      	ldr	r3, [r7, #4]
3419905e:	681b      	ldr	r3, [r3, #0]
34199060:	2101      	movs	r1, #1
34199062:	4618      	mov	r0, r3
34199064:	f7ee fd0e 	bl	34187a84 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
34199068:	4603      	mov	r3, r0
3419906a:	77bb      	strb	r3, [r7, #30]
  }

  if (halStatus != HAL_OK)
3419906c:	7fbb      	ldrb	r3, [r7, #30]
3419906e:	2b00      	cmp	r3, #0
34199070:	d001      	beq.n	34199076 <ISP_SVC_ISP_SetStatArea+0xee>
  {
    return ISP_ERR_STATAREA_HAL;
34199072:	2333      	movs	r3, #51	@ 0x33
34199074:	e008      	b.n	34199088 <ISP_SVC_ISP_SetStatArea+0x100>
  }

  /* Update internal state */
  hIsp->statArea = *pConfig;
34199076:	687b      	ldr	r3, [r7, #4]
34199078:	683a      	ldr	r2, [r7, #0]
3419907a:	f103 0408 	add.w	r4, r3, #8
3419907e:	4613      	mov	r3, r2
34199080:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
34199082:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  return ret;
34199086:	7ffb      	ldrb	r3, [r7, #31]
}
34199088:	4618      	mov	r0, r3
3419908a:	3724      	adds	r7, #36	@ 0x24
3419908c:	46bd      	mov	sp, r7
3419908e:	bd90      	pop	{r4, r7, pc}
34199090:	341c00f4 	.word	0x341c00f4

34199094 <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34199094:	b580      	push	{r7, lr}
34199096:	b084      	sub	sp, #16
34199098:	af00      	add	r7, sp, #0
3419909a:	6078      	str	r0, [r7, #4]
3419909c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
3419909e:	687b      	ldr	r3, [r7, #4]
341990a0:	2b00      	cmp	r3, #0
341990a2:	d006      	beq.n	341990b2 <ISP_SVC_ISP_SetBadPixel+0x1e>
341990a4:	683b      	ldr	r3, [r7, #0]
341990a6:	2b00      	cmp	r3, #0
341990a8:	d003      	beq.n	341990b2 <ISP_SVC_ISP_SetBadPixel+0x1e>
341990aa:	683b      	ldr	r3, [r7, #0]
341990ac:	785b      	ldrb	r3, [r3, #1]
341990ae:	2b07      	cmp	r3, #7
341990b0:	d901      	bls.n	341990b6 <ISP_SVC_ISP_SetBadPixel+0x22>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
341990b2:	233c      	movs	r3, #60	@ 0x3c
341990b4:	e029      	b.n	3419910a <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  if (pConfig->enable == 0)
341990b6:	683b      	ldr	r3, [r7, #0]
341990b8:	781b      	ldrb	r3, [r3, #0]
341990ba:	2b00      	cmp	r3, #0
341990bc:	d108      	bne.n	341990d0 <ISP_SVC_ISP_SetBadPixel+0x3c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
341990be:	687b      	ldr	r3, [r7, #4]
341990c0:	681b      	ldr	r3, [r3, #0]
341990c2:	2101      	movs	r1, #1
341990c4:	4618      	mov	r0, r3
341990c6:	f7ee f950 	bl	3418736a <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
341990ca:	4603      	mov	r3, r0
341990cc:	73fb      	strb	r3, [r7, #15]
341990ce:	e016      	b.n	341990fe <ISP_SVC_ISP_SetBadPixel+0x6a>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
341990d0:	687b      	ldr	r3, [r7, #4]
341990d2:	6818      	ldr	r0, [r3, #0]
341990d4:	683b      	ldr	r3, [r7, #0]
341990d6:	785b      	ldrb	r3, [r3, #1]
341990d8:	461a      	mov	r2, r3
341990da:	2101      	movs	r1, #1
341990dc:	f7ee f901 	bl	341872e2 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
341990e0:	4603      	mov	r3, r0
341990e2:	73fb      	strb	r3, [r7, #15]

    if (halStatus != HAL_OK)
341990e4:	7bfb      	ldrb	r3, [r7, #15]
341990e6:	2b00      	cmp	r3, #0
341990e8:	d001      	beq.n	341990ee <ISP_SVC_ISP_SetBadPixel+0x5a>
    {
      return ISP_ERR_BADPIXEL_HAL;
341990ea:	233d      	movs	r3, #61	@ 0x3d
341990ec:	e00d      	b.n	3419910a <ISP_SVC_ISP_SetBadPixel+0x76>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
341990ee:	687b      	ldr	r3, [r7, #4]
341990f0:	681b      	ldr	r3, [r3, #0]
341990f2:	2101      	movs	r1, #1
341990f4:	4618      	mov	r0, r3
341990f6:	f7ee f918 	bl	3418732a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
341990fa:	4603      	mov	r3, r0
341990fc:	73fb      	strb	r3, [r7, #15]
  }

  if (halStatus != HAL_OK)
341990fe:	7bfb      	ldrb	r3, [r7, #15]
34199100:	2b00      	cmp	r3, #0
34199102:	d001      	beq.n	34199108 <ISP_SVC_ISP_SetBadPixel+0x74>
  {
    return ISP_ERR_BADPIXEL_HAL;
34199104:	233d      	movs	r3, #61	@ 0x3d
34199106:	e000      	b.n	3419910a <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  return ISP_OK;
34199108:	2300      	movs	r3, #0
}
3419910a:	4618      	mov	r0, r3
3419910c:	3710      	adds	r7, #16
3419910e:	46bd      	mov	sp, r7
34199110:	bd80      	pop	{r7, pc}

34199112 <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
34199112:	b580      	push	{r7, lr}
34199114:	b084      	sub	sp, #16
34199116:	af00      	add	r7, sp, #0
34199118:	6078      	str	r0, [r7, #4]
3419911a:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419911c:	687b      	ldr	r3, [r7, #4]
3419911e:	2b00      	cmp	r3, #0
34199120:	d002      	beq.n	34199128 <ISP_SVC_ISP_GetBadPixel+0x16>
34199122:	683b      	ldr	r3, [r7, #0]
34199124:	2b00      	cmp	r3, #0
34199126:	d101      	bne.n	3419912c <ISP_SVC_ISP_GetBadPixel+0x1a>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
34199128:	233c      	movs	r3, #60	@ 0x3c
3419912a:	e023      	b.n	34199174 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3419912c:	687b      	ldr	r3, [r7, #4]
3419912e:	681b      	ldr	r3, [r3, #0]
34199130:	2101      	movs	r1, #1
34199132:	4618      	mov	r0, r3
34199134:	f7ee f94b 	bl	341873ce <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
34199138:	4603      	mov	r3, r0
3419913a:	b2da      	uxtb	r2, r3
3419913c:	683b      	ldr	r3, [r7, #0]
3419913e:	701a      	strb	r2, [r3, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
34199140:	687b      	ldr	r3, [r7, #4]
34199142:	681b      	ldr	r3, [r3, #0]
34199144:	2101      	movs	r1, #1
34199146:	4618      	mov	r0, r3
34199148:	f7ee f92f 	bl	341873aa <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
3419914c:	4603      	mov	r3, r0
3419914e:	b2da      	uxtb	r2, r3
34199150:	683b      	ldr	r3, [r7, #0]
34199152:	705a      	strb	r2, [r3, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
34199154:	687b      	ldr	r3, [r7, #4]
34199156:	6818      	ldr	r0, [r3, #0]
34199158:	683b      	ldr	r3, [r7, #0]
3419915a:	3304      	adds	r3, #4
3419915c:	461a      	mov	r2, r3
3419915e:	2101      	movs	r1, #1
34199160:	f7ee f950 	bl	34187404 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>
34199164:	4603      	mov	r3, r0
34199166:	73fb      	strb	r3, [r7, #15]

  if (halStatus != HAL_OK)
34199168:	7bfb      	ldrb	r3, [r7, #15]
3419916a:	2b00      	cmp	r3, #0
3419916c:	d001      	beq.n	34199172 <ISP_SVC_ISP_GetBadPixel+0x60>
  {
    return ISP_ERR_BADPIXEL_HAL;
3419916e:	233d      	movs	r3, #61	@ 0x3d
34199170:	e000      	b.n	34199174 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  return ISP_OK;
34199172:	2300      	movs	r3, #0
}
34199174:	4618      	mov	r0, r3
34199176:	3710      	adds	r7, #16
34199178:	46bd      	mov	sp, r7
3419917a:	bd80      	pop	{r7, pc}

3419917c <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3419917c:	b580      	push	{r7, lr}
3419917e:	b084      	sub	sp, #16
34199180:	af00      	add	r7, sp, #0
34199182:	6078      	str	r0, [r7, #4]
34199184:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34199186:	687b      	ldr	r3, [r7, #4]
34199188:	2b00      	cmp	r3, #0
3419918a:	d002      	beq.n	34199192 <ISP_SVC_ISP_SetBlackLevel+0x16>
3419918c:	683b      	ldr	r3, [r7, #0]
3419918e:	2b00      	cmp	r3, #0
34199190:	d101      	bne.n	34199196 <ISP_SVC_ISP_SetBlackLevel+0x1a>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
34199192:	2346      	movs	r3, #70	@ 0x46
34199194:	e030      	b.n	341991f8 <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  if (pConfig->enable == 0)
34199196:	683b      	ldr	r3, [r7, #0]
34199198:	781b      	ldrb	r3, [r3, #0]
3419919a:	2b00      	cmp	r3, #0
3419919c:	d108      	bne.n	341991b0 <ISP_SVC_ISP_SetBlackLevel+0x34>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3419919e:	687b      	ldr	r3, [r7, #4]
341991a0:	681b      	ldr	r3, [r3, #0]
341991a2:	2101      	movs	r1, #1
341991a4:	4618      	mov	r0, r3
341991a6:	f7ee fb42 	bl	3418782e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
341991aa:	4603      	mov	r3, r0
341991ac:	73fb      	strb	r3, [r7, #15]
341991ae:	e01d      	b.n	341991ec <ISP_SVC_ISP_SetBlackLevel+0x70>
  }
  else
  {
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
341991b0:	683b      	ldr	r3, [r7, #0]
341991b2:	785b      	ldrb	r3, [r3, #1]
341991b4:	733b      	strb	r3, [r7, #12]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
341991b6:	683b      	ldr	r3, [r7, #0]
341991b8:	789b      	ldrb	r3, [r3, #2]
341991ba:	737b      	strb	r3, [r7, #13]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
341991bc:	683b      	ldr	r3, [r7, #0]
341991be:	78db      	ldrb	r3, [r3, #3]
341991c0:	73bb      	strb	r3, [r7, #14]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
341991c2:	687b      	ldr	r3, [r7, #4]
341991c4:	681b      	ldr	r3, [r3, #0]
341991c6:	f107 020c 	add.w	r2, r7, #12
341991ca:	2101      	movs	r1, #1
341991cc:	4618      	mov	r0, r3
341991ce:	f7ee fadf 	bl	34187790 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
341991d2:	4603      	mov	r3, r0
341991d4:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
341991d6:	7bfb      	ldrb	r3, [r7, #15]
341991d8:	2b00      	cmp	r3, #0
341991da:	d107      	bne.n	341991ec <ISP_SVC_ISP_SetBlackLevel+0x70>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
341991dc:	687b      	ldr	r3, [r7, #4]
341991de:	681b      	ldr	r3, [r3, #0]
341991e0:	2101      	movs	r1, #1
341991e2:	4618      	mov	r0, r3
341991e4:	f7ee fb03 	bl	341877ee <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
341991e8:	4603      	mov	r3, r0
341991ea:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
341991ec:	7bfb      	ldrb	r3, [r7, #15]
341991ee:	2b00      	cmp	r3, #0
341991f0:	d001      	beq.n	341991f6 <ISP_SVC_ISP_SetBlackLevel+0x7a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
341991f2:	2347      	movs	r3, #71	@ 0x47
341991f4:	e000      	b.n	341991f8 <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  return ISP_OK;
341991f6:	2300      	movs	r3, #0
}
341991f8:	4618      	mov	r0, r3
341991fa:	3710      	adds	r7, #16
341991fc:	46bd      	mov	sp, r7
341991fe:	bd80      	pop	{r7, pc}

34199200 <ISP_SVC_ISP_GetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
34199200:	b580      	push	{r7, lr}
34199202:	b084      	sub	sp, #16
34199204:	af00      	add	r7, sp, #0
34199206:	6078      	str	r0, [r7, #4]
34199208:	6039      	str	r1, [r7, #0]
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419920a:	687b      	ldr	r3, [r7, #4]
3419920c:	2b00      	cmp	r3, #0
3419920e:	d002      	beq.n	34199216 <ISP_SVC_ISP_GetBlackLevel+0x16>
34199210:	683b      	ldr	r3, [r7, #0]
34199212:	2b00      	cmp	r3, #0
34199214:	d101      	bne.n	3419921a <ISP_SVC_ISP_GetBlackLevel+0x1a>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
34199216:	2346      	movs	r3, #70	@ 0x46
34199218:	e01b      	b.n	34199252 <ISP_SVC_ISP_GetBlackLevel+0x52>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3419921a:	687b      	ldr	r3, [r7, #4]
3419921c:	681b      	ldr	r3, [r3, #0]
3419921e:	2101      	movs	r1, #1
34199220:	4618      	mov	r0, r3
34199222:	f7ee fb47 	bl	341878b4 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>
34199226:	4603      	mov	r3, r0
34199228:	b2da      	uxtb	r2, r3
3419922a:	683b      	ldr	r3, [r7, #0]
3419922c:	701a      	strb	r2, [r3, #0]

  HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3419922e:	687b      	ldr	r3, [r7, #4]
34199230:	681b      	ldr	r3, [r3, #0]
34199232:	f107 020c 	add.w	r2, r7, #12
34199236:	2101      	movs	r1, #1
34199238:	4618      	mov	r0, r3
3419923a:	f7ee fb18 	bl	3418786e <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>

  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
3419923e:	7b3a      	ldrb	r2, [r7, #12]
34199240:	683b      	ldr	r3, [r7, #0]
34199242:	705a      	strb	r2, [r3, #1]
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
34199244:	7b7a      	ldrb	r2, [r7, #13]
34199246:	683b      	ldr	r3, [r7, #0]
34199248:	709a      	strb	r2, [r3, #2]
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;
3419924a:	7bba      	ldrb	r2, [r7, #14]
3419924c:	683b      	ldr	r3, [r7, #0]
3419924e:	70da      	strb	r2, [r3, #3]

  return ISP_OK;
34199250:	2300      	movs	r3, #0
}
34199252:	4618      	mov	r0, r3
34199254:	3710      	adds	r7, #16
34199256:	46bd      	mov	sp, r7
34199258:	bd80      	pop	{r7, pc}
	...

3419925c <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3419925c:	b580      	push	{r7, lr}
3419925e:	b084      	sub	sp, #16
34199260:	af00      	add	r7, sp, #0
34199262:	6078      	str	r0, [r7, #4]
34199264:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34199266:	687b      	ldr	r3, [r7, #4]
34199268:	2b00      	cmp	r3, #0
3419926a:	d011      	beq.n	34199290 <ISP_SVC_ISP_SetGain+0x34>
3419926c:	683b      	ldr	r3, [r7, #0]
3419926e:	2b00      	cmp	r3, #0
34199270:	d00e      	beq.n	34199290 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
34199272:	683b      	ldr	r3, [r7, #0]
34199274:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34199276:	4a2d      	ldr	r2, [pc, #180]	@ (3419932c <ISP_SVC_ISP_SetGain+0xd0>)
34199278:	4293      	cmp	r3, r2
3419927a:	d809      	bhi.n	34199290 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3419927c:	683b      	ldr	r3, [r7, #0]
3419927e:	689b      	ldr	r3, [r3, #8]
34199280:	4a2a      	ldr	r2, [pc, #168]	@ (3419932c <ISP_SVC_ISP_SetGain+0xd0>)
34199282:	4293      	cmp	r3, r2
34199284:	d804      	bhi.n	34199290 <ISP_SVC_ISP_SetGain+0x34>
34199286:	683b      	ldr	r3, [r7, #0]
34199288:	68db      	ldr	r3, [r3, #12]
3419928a:	4a28      	ldr	r2, [pc, #160]	@ (3419932c <ISP_SVC_ISP_SetGain+0xd0>)
3419928c:	4293      	cmp	r3, r2
3419928e:	d901      	bls.n	34199294 <ISP_SVC_ISP_SetGain+0x38>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
34199290:	2350      	movs	r3, #80	@ 0x50
34199292:	e047      	b.n	34199324 <ISP_SVC_ISP_SetGain+0xc8>
  }

  if (pConfig->enable == 0)
34199294:	683b      	ldr	r3, [r7, #0]
34199296:	781b      	ldrb	r3, [r3, #0]
34199298:	2b00      	cmp	r3, #0
3419929a:	d108      	bne.n	341992ae <ISP_SVC_ISP_SetGain+0x52>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3419929c:	687b      	ldr	r3, [r7, #4]
3419929e:	681b      	ldr	r3, [r3, #0]
341992a0:	2101      	movs	r1, #1
341992a2:	4618      	mov	r0, r3
341992a4:	f7ee fc70 	bl	34187b88 <HAL_DCMIPP_PIPE_DisableISPExposure>
341992a8:	4603      	mov	r3, r0
341992aa:	73fb      	strb	r3, [r7, #15]
341992ac:	e034      	b.n	34199318 <ISP_SVC_ISP_SetGain+0xbc>
  }
  else
  {
    To_Shift_Multiplier(pConfig->ispGainR, &exposureConfig.ShiftRed, &exposureConfig.MultiplierRed);
341992ae:	683b      	ldr	r3, [r7, #0]
341992b0:	6858      	ldr	r0, [r3, #4]
341992b2:	f107 0308 	add.w	r3, r7, #8
341992b6:	1c5a      	adds	r2, r3, #1
341992b8:	f107 0308 	add.w	r3, r7, #8
341992bc:	4619      	mov	r1, r3
341992be:	f7ff f983 	bl	341985c8 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainG, &exposureConfig.ShiftGreen, &exposureConfig.MultiplierGreen);
341992c2:	683b      	ldr	r3, [r7, #0]
341992c4:	6898      	ldr	r0, [r3, #8]
341992c6:	f107 0308 	add.w	r3, r7, #8
341992ca:	1cda      	adds	r2, r3, #3
341992cc:	f107 0308 	add.w	r3, r7, #8
341992d0:	3302      	adds	r3, #2
341992d2:	4619      	mov	r1, r3
341992d4:	f7ff f978 	bl	341985c8 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainB, &exposureConfig.ShiftBlue, &exposureConfig.MultiplierBlue);
341992d8:	683b      	ldr	r3, [r7, #0]
341992da:	68d8      	ldr	r0, [r3, #12]
341992dc:	f107 0308 	add.w	r3, r7, #8
341992e0:	1d5a      	adds	r2, r3, #5
341992e2:	f107 0308 	add.w	r3, r7, #8
341992e6:	3304      	adds	r3, #4
341992e8:	4619      	mov	r1, r3
341992ea:	f7ff f96d 	bl	341985c8 <To_Shift_Multiplier>
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
341992ee:	687b      	ldr	r3, [r7, #4]
341992f0:	681b      	ldr	r3, [r3, #0]
341992f2:	f107 0208 	add.w	r2, r7, #8
341992f6:	2101      	movs	r1, #1
341992f8:	4618      	mov	r0, r3
341992fa:	f7ee fbe3 	bl	34187ac4 <HAL_DCMIPP_PIPE_SetISPExposureConfig>
341992fe:	4603      	mov	r3, r0
34199300:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
34199302:	7bfb      	ldrb	r3, [r7, #15]
34199304:	2b00      	cmp	r3, #0
34199306:	d107      	bne.n	34199318 <ISP_SVC_ISP_SetGain+0xbc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
34199308:	687b      	ldr	r3, [r7, #4]
3419930a:	681b      	ldr	r3, [r3, #0]
3419930c:	2101      	movs	r1, #1
3419930e:	4618      	mov	r0, r3
34199310:	f7ee fc1a 	bl	34187b48 <HAL_DCMIPP_PIPE_EnableISPExposure>
34199314:	4603      	mov	r3, r0
34199316:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
34199318:	7bfb      	ldrb	r3, [r7, #15]
3419931a:	2b00      	cmp	r3, #0
3419931c:	d001      	beq.n	34199322 <ISP_SVC_ISP_SetGain+0xc6>
  {
    return ISP_ERR_ISPGAIN_HAL;
3419931e:	2351      	movs	r3, #81	@ 0x51
34199320:	e000      	b.n	34199324 <ISP_SVC_ISP_SetGain+0xc8>
  }

  return ISP_OK;
34199322:	2300      	movs	r3, #0
}
34199324:	4618      	mov	r0, r3
34199326:	3710      	adds	r7, #16
34199328:	46bd      	mov	sp, r7
3419932a:	bd80      	pop	{r7, pc}
3419932c:	5f5e1000 	.word	0x5f5e1000

34199330 <ISP_SVC_ISP_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
34199330:	b580      	push	{r7, lr}
34199332:	b084      	sub	sp, #16
34199334:	af00      	add	r7, sp, #0
34199336:	6078      	str	r0, [r7, #4]
34199338:	6039      	str	r1, [r7, #0]
  DCMIPP_ExposureConfTypeDef exposureConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419933a:	687b      	ldr	r3, [r7, #4]
3419933c:	2b00      	cmp	r3, #0
3419933e:	d002      	beq.n	34199346 <ISP_SVC_ISP_GetGain+0x16>
34199340:	683b      	ldr	r3, [r7, #0]
34199342:	2b00      	cmp	r3, #0
34199344:	d101      	bne.n	3419934a <ISP_SVC_ISP_GetGain+0x1a>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
34199346:	2350      	movs	r3, #80	@ 0x50
34199348:	e02d      	b.n	341993a6 <ISP_SVC_ISP_GetGain+0x76>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3419934a:	687b      	ldr	r3, [r7, #4]
3419934c:	681b      	ldr	r3, [r3, #0]
3419934e:	2101      	movs	r1, #1
34199350:	4618      	mov	r0, r3
34199352:	f7ee ffa2 	bl	3418829a <HAL_DCMIPP_PIPE_IsEnabledISPExposure>
34199356:	4603      	mov	r3, r0
34199358:	b2da      	uxtb	r2, r3
3419935a:	683b      	ldr	r3, [r7, #0]
3419935c:	701a      	strb	r2, [r3, #0]
  HAL_DCMIPP_PIPE_GetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3419935e:	687b      	ldr	r3, [r7, #4]
34199360:	681b      	ldr	r3, [r3, #0]
34199362:	f107 0208 	add.w	r2, r7, #8
34199366:	2101      	movs	r1, #1
34199368:	4618      	mov	r0, r3
3419936a:	f7ee fe00 	bl	34187f6e <HAL_DCMIPP_PIPE_GetISPExposureConfig>

  pConfig->ispGainR = From_Shift_Multiplier(exposureConfig.ShiftRed, exposureConfig.MultiplierRed);
3419936e:	7a3b      	ldrb	r3, [r7, #8]
34199370:	7a7a      	ldrb	r2, [r7, #9]
34199372:	4611      	mov	r1, r2
34199374:	4618      	mov	r0, r3
34199376:	f7ff f967 	bl	34198648 <From_Shift_Multiplier>
3419937a:	4602      	mov	r2, r0
3419937c:	683b      	ldr	r3, [r7, #0]
3419937e:	605a      	str	r2, [r3, #4]
  pConfig->ispGainG = From_Shift_Multiplier(exposureConfig.ShiftGreen, exposureConfig.MultiplierGreen);
34199380:	7abb      	ldrb	r3, [r7, #10]
34199382:	7afa      	ldrb	r2, [r7, #11]
34199384:	4611      	mov	r1, r2
34199386:	4618      	mov	r0, r3
34199388:	f7ff f95e 	bl	34198648 <From_Shift_Multiplier>
3419938c:	4602      	mov	r2, r0
3419938e:	683b      	ldr	r3, [r7, #0]
34199390:	609a      	str	r2, [r3, #8]
  pConfig->ispGainB = From_Shift_Multiplier(exposureConfig.ShiftBlue, exposureConfig.MultiplierBlue);
34199392:	7b3b      	ldrb	r3, [r7, #12]
34199394:	7b7a      	ldrb	r2, [r7, #13]
34199396:	4611      	mov	r1, r2
34199398:	4618      	mov	r0, r3
3419939a:	f7ff f955 	bl	34198648 <From_Shift_Multiplier>
3419939e:	4602      	mov	r2, r0
341993a0:	683b      	ldr	r3, [r7, #0]
341993a2:	60da      	str	r2, [r3, #12]

  return ISP_OK;
341993a4:	2300      	movs	r3, #0
}
341993a6:	4618      	mov	r0, r3
341993a8:	3710      	adds	r7, #16
341993aa:	46bd      	mov	sp, r7
341993ac:	bd80      	pop	{r7, pc}
	...

341993b0 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
341993b0:	b580      	push	{r7, lr}
341993b2:	b08c      	sub	sp, #48	@ 0x30
341993b4:	af00      	add	r7, sp, #0
341993b6:	6078      	str	r0, [r7, #4]
341993b8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
341993ba:	f107 0308 	add.w	r3, r7, #8
341993be:	221a      	movs	r2, #26
341993c0:	2100      	movs	r1, #0
341993c2:	4618      	mov	r0, r3
341993c4:	f00a fcee 	bl	341a3da4 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
341993c8:	687b      	ldr	r3, [r7, #4]
341993ca:	2b00      	cmp	r3, #0
341993cc:	d002      	beq.n	341993d4 <ISP_SVC_ISP_SetColorConv+0x24>
341993ce:	683b      	ldr	r3, [r7, #0]
341993d0:	2b00      	cmp	r3, #0
341993d2:	d101      	bne.n	341993d8 <ISP_SVC_ISP_SetColorConv+0x28>
  {
    return ISP_ERR_COLORCONV_EINVAL;
341993d4:	235a      	movs	r3, #90	@ 0x5a
341993d6:	e099      	b.n	3419950c <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  for (i = 0; i < 3; i++)
341993d8:	2300      	movs	r3, #0
341993da:	62bb      	str	r3, [r7, #40]	@ 0x28
341993dc:	e027      	b.n	3419942e <ISP_SVC_ISP_SetColorConv+0x7e>
  {
    for (j = 0; j < 3; j++)
341993de:	2300      	movs	r3, #0
341993e0:	627b      	str	r3, [r7, #36]	@ 0x24
341993e2:	e01e      	b.n	34199422 <ISP_SVC_ISP_SetColorConv+0x72>
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
341993e4:	6839      	ldr	r1, [r7, #0]
341993e6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
341993e8:	4613      	mov	r3, r2
341993ea:	005b      	lsls	r3, r3, #1
341993ec:	4413      	add	r3, r2
341993ee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341993f0:	4413      	add	r3, r2
341993f2:	009b      	lsls	r3, r3, #2
341993f4:	440b      	add	r3, r1
341993f6:	685b      	ldr	r3, [r3, #4]
341993f8:	4a46      	ldr	r2, [pc, #280]	@ (34199514 <ISP_SVC_ISP_SetColorConv+0x164>)
341993fa:	4293      	cmp	r3, r2
341993fc:	dc0c      	bgt.n	34199418 <ISP_SVC_ISP_SetColorConv+0x68>
341993fe:	6839      	ldr	r1, [r7, #0]
34199400:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34199402:	4613      	mov	r3, r2
34199404:	005b      	lsls	r3, r3, #1
34199406:	4413      	add	r3, r2
34199408:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419940a:	4413      	add	r3, r2
3419940c:	009b      	lsls	r3, r3, #2
3419940e:	440b      	add	r3, r1
34199410:	685b      	ldr	r3, [r3, #4]
34199412:	4a41      	ldr	r2, [pc, #260]	@ (34199518 <ISP_SVC_ISP_SetColorConv+0x168>)
34199414:	4293      	cmp	r3, r2
34199416:	da01      	bge.n	3419941c <ISP_SVC_ISP_SetColorConv+0x6c>
      {
        return ISP_ERR_COLORCONV_EINVAL;
34199418:	235a      	movs	r3, #90	@ 0x5a
3419941a:	e077      	b.n	3419950c <ISP_SVC_ISP_SetColorConv+0x15c>
    for (j = 0; j < 3; j++)
3419941c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419941e:	3301      	adds	r3, #1
34199420:	627b      	str	r3, [r7, #36]	@ 0x24
34199422:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34199424:	2b02      	cmp	r3, #2
34199426:	d9dd      	bls.n	341993e4 <ISP_SVC_ISP_SetColorConv+0x34>
  for (i = 0; i < 3; i++)
34199428:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419942a:	3301      	adds	r3, #1
3419942c:	62bb      	str	r3, [r7, #40]	@ 0x28
3419942e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34199430:	2b02      	cmp	r3, #2
34199432:	d9d4      	bls.n	341993de <ISP_SVC_ISP_SetColorConv+0x2e>
      }
    }
  }

  if (pConfig->enable == 0)
34199434:	683b      	ldr	r3, [r7, #0]
34199436:	781b      	ldrb	r3, [r3, #0]
34199438:	2b00      	cmp	r3, #0
3419943a:	d109      	bne.n	34199450 <ISP_SVC_ISP_SetColorConv+0xa0>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3419943c:	687b      	ldr	r3, [r7, #4]
3419943e:	681b      	ldr	r3, [r3, #0]
34199440:	2101      	movs	r1, #1
34199442:	4618      	mov	r0, r3
34199444:	f7ee f984 	bl	34187750 <HAL_DCMIPP_PIPE_DisableISPColorConversion>
34199448:	4603      	mov	r3, r0
3419944a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3419944e:	e056      	b.n	341994fe <ISP_SVC_ISP_SetColorConv+0x14e>
  }
  else
  {
    colorConvConfig.RR = To_CConv_Reg(pConfig->coeff[0][0]);
34199450:	683b      	ldr	r3, [r7, #0]
34199452:	685b      	ldr	r3, [r3, #4]
34199454:	4618      	mov	r0, r3
34199456:	f7ff f935 	bl	341986c4 <To_CConv_Reg>
3419945a:	4603      	mov	r3, r0
3419945c:	817b      	strh	r3, [r7, #10]
    colorConvConfig.RG = To_CConv_Reg(pConfig->coeff[0][1]);
3419945e:	683b      	ldr	r3, [r7, #0]
34199460:	689b      	ldr	r3, [r3, #8]
34199462:	4618      	mov	r0, r3
34199464:	f7ff f92e 	bl	341986c4 <To_CConv_Reg>
34199468:	4603      	mov	r3, r0
3419946a:	81bb      	strh	r3, [r7, #12]
    colorConvConfig.RB = To_CConv_Reg(pConfig->coeff[0][2]);
3419946c:	683b      	ldr	r3, [r7, #0]
3419946e:	68db      	ldr	r3, [r3, #12]
34199470:	4618      	mov	r0, r3
34199472:	f7ff f927 	bl	341986c4 <To_CConv_Reg>
34199476:	4603      	mov	r3, r0
34199478:	81fb      	strh	r3, [r7, #14]
    colorConvConfig.GR = To_CConv_Reg(pConfig->coeff[1][0]);
3419947a:	683b      	ldr	r3, [r7, #0]
3419947c:	691b      	ldr	r3, [r3, #16]
3419947e:	4618      	mov	r0, r3
34199480:	f7ff f920 	bl	341986c4 <To_CConv_Reg>
34199484:	4603      	mov	r3, r0
34199486:	827b      	strh	r3, [r7, #18]
    colorConvConfig.GG = To_CConv_Reg(pConfig->coeff[1][1]);
34199488:	683b      	ldr	r3, [r7, #0]
3419948a:	695b      	ldr	r3, [r3, #20]
3419948c:	4618      	mov	r0, r3
3419948e:	f7ff f919 	bl	341986c4 <To_CConv_Reg>
34199492:	4603      	mov	r3, r0
34199494:	82bb      	strh	r3, [r7, #20]
    colorConvConfig.GB = To_CConv_Reg(pConfig->coeff[1][2]);
34199496:	683b      	ldr	r3, [r7, #0]
34199498:	699b      	ldr	r3, [r3, #24]
3419949a:	4618      	mov	r0, r3
3419949c:	f7ff f912 	bl	341986c4 <To_CConv_Reg>
341994a0:	4603      	mov	r3, r0
341994a2:	82fb      	strh	r3, [r7, #22]
    colorConvConfig.BR = To_CConv_Reg(pConfig->coeff[2][0]);
341994a4:	683b      	ldr	r3, [r7, #0]
341994a6:	69db      	ldr	r3, [r3, #28]
341994a8:	4618      	mov	r0, r3
341994aa:	f7ff f90b 	bl	341986c4 <To_CConv_Reg>
341994ae:	4603      	mov	r3, r0
341994b0:	837b      	strh	r3, [r7, #26]
    colorConvConfig.BG = To_CConv_Reg(pConfig->coeff[2][1]);
341994b2:	683b      	ldr	r3, [r7, #0]
341994b4:	6a1b      	ldr	r3, [r3, #32]
341994b6:	4618      	mov	r0, r3
341994b8:	f7ff f904 	bl	341986c4 <To_CConv_Reg>
341994bc:	4603      	mov	r3, r0
341994be:	83bb      	strh	r3, [r7, #28]
    colorConvConfig.BB = To_CConv_Reg(pConfig->coeff[2][2]);
341994c0:	683b      	ldr	r3, [r7, #0]
341994c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341994c4:	4618      	mov	r0, r3
341994c6:	f7ff f8fd 	bl	341986c4 <To_CConv_Reg>
341994ca:	4603      	mov	r3, r0
341994cc:	83fb      	strh	r3, [r7, #30]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
341994ce:	687b      	ldr	r3, [r7, #4]
341994d0:	681b      	ldr	r3, [r3, #0]
341994d2:	f107 0208 	add.w	r2, r7, #8
341994d6:	2101      	movs	r1, #1
341994d8:	4618      	mov	r0, r3
341994da:	f7ed ffb7 	bl	3418744c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
341994de:	4603      	mov	r3, r0
341994e0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    if (halStatus == HAL_OK)
341994e4:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
341994e8:	2b00      	cmp	r3, #0
341994ea:	d108      	bne.n	341994fe <ISP_SVC_ISP_SetColorConv+0x14e>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
341994ec:	687b      	ldr	r3, [r7, #4]
341994ee:	681b      	ldr	r3, [r3, #0]
341994f0:	2101      	movs	r1, #1
341994f2:	4618      	mov	r0, r3
341994f4:	f7ee f90c 	bl	34187710 <HAL_DCMIPP_PIPE_EnableISPColorConversion>
341994f8:	4603      	mov	r3, r0
341994fa:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }
  }

  if (halStatus != HAL_OK)
341994fe:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
34199502:	2b00      	cmp	r3, #0
34199504:	d001      	beq.n	3419950a <ISP_SVC_ISP_SetColorConv+0x15a>
  {
    return ISP_ERR_COLORCONV_HAL;
34199506:	235b      	movs	r3, #91	@ 0x5b
34199508:	e000      	b.n	3419950c <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  return ISP_OK;
3419950a:	2300      	movs	r3, #0
}
3419950c:	4618      	mov	r0, r3
3419950e:	3730      	adds	r7, #48	@ 0x30
34199510:	46bd      	mov	sp, r7
34199512:	bd80      	pop	{r7, pc}
34199514:	17c841c0 	.word	0x17c841c0
34199518:	e837be40 	.word	0xe837be40

3419951c <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3419951c:	b580      	push	{r7, lr}
3419951e:	b08a      	sub	sp, #40	@ 0x28
34199520:	af00      	add	r7, sp, #0
34199522:	6078      	str	r0, [r7, #4]
34199524:	6039      	str	r1, [r7, #0]
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34199526:	687b      	ldr	r3, [r7, #4]
34199528:	2b00      	cmp	r3, #0
3419952a:	d002      	beq.n	34199532 <ISP_SVC_ISP_GetColorConv+0x16>
3419952c:	683b      	ldr	r3, [r7, #0]
3419952e:	2b00      	cmp	r3, #0
34199530:	d101      	bne.n	34199536 <ISP_SVC_ISP_GetColorConv+0x1a>
  {
    return ISP_ERR_COLORCONV_EINVAL;
34199532:	235a      	movs	r3, #90	@ 0x5a
34199534:	e05a      	b.n	341995ec <ISP_SVC_ISP_GetColorConv+0xd0>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34199536:	687b      	ldr	r3, [r7, #4]
34199538:	681b      	ldr	r3, [r3, #0]
3419953a:	2101      	movs	r1, #1
3419953c:	4618      	mov	r0, r3
3419953e:	f7ee fec7 	bl	341882d0 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
34199542:	4603      	mov	r3, r0
34199544:	b2da      	uxtb	r2, r3
34199546:	683b      	ldr	r3, [r7, #0]
34199548:	701a      	strb	r2, [r3, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3419954a:	687b      	ldr	r3, [r7, #4]
3419954c:	681b      	ldr	r3, [r3, #0]
3419954e:	f107 020c 	add.w	r2, r7, #12
34199552:	2101      	movs	r1, #1
34199554:	4618      	mov	r0, r3
34199556:	f7ee fd4a 	bl	34187fee <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>

  pConfig->coeff[0][0] = From_CConv_Reg(colorConvConfig.RR);
3419955a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3419955e:	4618      	mov	r0, r3
34199560:	f7ff f8ce 	bl	34198700 <From_CConv_Reg>
34199564:	4602      	mov	r2, r0
34199566:	683b      	ldr	r3, [r7, #0]
34199568:	605a      	str	r2, [r3, #4]
  pConfig->coeff[0][1] = From_CConv_Reg(colorConvConfig.RG);
3419956a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
3419956e:	4618      	mov	r0, r3
34199570:	f7ff f8c6 	bl	34198700 <From_CConv_Reg>
34199574:	4602      	mov	r2, r0
34199576:	683b      	ldr	r3, [r7, #0]
34199578:	609a      	str	r2, [r3, #8]
  pConfig->coeff[0][2] = From_CConv_Reg(colorConvConfig.RB);
3419957a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
3419957e:	4618      	mov	r0, r3
34199580:	f7ff f8be 	bl	34198700 <From_CConv_Reg>
34199584:	4602      	mov	r2, r0
34199586:	683b      	ldr	r3, [r7, #0]
34199588:	60da      	str	r2, [r3, #12]
  pConfig->coeff[1][0] = From_CConv_Reg(colorConvConfig.GR);
3419958a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3419958e:	4618      	mov	r0, r3
34199590:	f7ff f8b6 	bl	34198700 <From_CConv_Reg>
34199594:	4602      	mov	r2, r0
34199596:	683b      	ldr	r3, [r7, #0]
34199598:	611a      	str	r2, [r3, #16]
  pConfig->coeff[1][1] = From_CConv_Reg(colorConvConfig.GG);
3419959a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
3419959e:	4618      	mov	r0, r3
341995a0:	f7ff f8ae 	bl	34198700 <From_CConv_Reg>
341995a4:	4602      	mov	r2, r0
341995a6:	683b      	ldr	r3, [r7, #0]
341995a8:	615a      	str	r2, [r3, #20]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
341995aa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
341995ae:	4618      	mov	r0, r3
341995b0:	f7ff f8a6 	bl	34198700 <From_CConv_Reg>
341995b4:	4602      	mov	r2, r0
341995b6:	683b      	ldr	r3, [r7, #0]
341995b8:	619a      	str	r2, [r3, #24]
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
341995ba:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
341995be:	4618      	mov	r0, r3
341995c0:	f7ff f89e 	bl	34198700 <From_CConv_Reg>
341995c4:	4602      	mov	r2, r0
341995c6:	683b      	ldr	r3, [r7, #0]
341995c8:	61da      	str	r2, [r3, #28]
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
341995ca:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
341995ce:	4618      	mov	r0, r3
341995d0:	f7ff f896 	bl	34198700 <From_CConv_Reg>
341995d4:	4602      	mov	r2, r0
341995d6:	683b      	ldr	r3, [r7, #0]
341995d8:	621a      	str	r2, [r3, #32]
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);
341995da:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
341995de:	4618      	mov	r0, r3
341995e0:	f7ff f88e 	bl	34198700 <From_CConv_Reg>
341995e4:	4602      	mov	r2, r0
341995e6:	683b      	ldr	r3, [r7, #0]
341995e8:	625a      	str	r2, [r3, #36]	@ 0x24

  return ISP_OK;
341995ea:	2300      	movs	r3, #0
}
341995ec:	4618      	mov	r0, r3
341995ee:	3728      	adds	r7, #40	@ 0x28
341995f0:	46bd      	mov	sp, r7
341995f2:	bd80      	pop	{r7, pc}

341995f4 <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
341995f4:	b580      	push	{r7, lr}
341995f6:	b082      	sub	sp, #8
341995f8:	af00      	add	r7, sp, #0
341995fa:	6078      	str	r0, [r7, #4]
341995fc:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
341995fe:	687b      	ldr	r3, [r7, #4]
34199600:	2b00      	cmp	r3, #0
34199602:	d002      	beq.n	3419960a <ISP_SVC_Sensor_GetInfo+0x16>
34199604:	683b      	ldr	r3, [r7, #0]
34199606:	2b00      	cmp	r3, #0
34199608:	d101      	bne.n	3419960e <ISP_SVC_Sensor_GetInfo+0x1a>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
3419960a:	236e      	movs	r3, #110	@ 0x6e
3419960c:	e010      	b.n	34199630 <ISP_SVC_Sensor_GetInfo+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
3419960e:	687b      	ldr	r3, [r7, #4]
34199610:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34199612:	2b00      	cmp	r3, #0
34199614:	d00b      	beq.n	3419962e <ISP_SVC_Sensor_GetInfo+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
34199616:	687b      	ldr	r3, [r7, #4]
34199618:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419961a:	687a      	ldr	r2, [r7, #4]
3419961c:	6852      	ldr	r2, [r2, #4]
3419961e:	6839      	ldr	r1, [r7, #0]
34199620:	4610      	mov	r0, r2
34199622:	4798      	blx	r3
34199624:	4603      	mov	r3, r0
34199626:	2b00      	cmp	r3, #0
34199628:	d001      	beq.n	3419962e <ISP_SVC_Sensor_GetInfo+0x3a>
    {
      return ISP_ERR_SENSORINFO;
3419962a:	236f      	movs	r3, #111	@ 0x6f
3419962c:	e000      	b.n	34199630 <ISP_SVC_Sensor_GetInfo+0x3c>
    }
  }

  return ISP_OK;
3419962e:	2300      	movs	r3, #0
}
34199630:	4618      	mov	r0, r3
34199632:	3708      	adds	r7, #8
34199634:	46bd      	mov	sp, r7
34199636:	bd80      	pop	{r7, pc}

34199638 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
34199638:	b580      	push	{r7, lr}
3419963a:	b082      	sub	sp, #8
3419963c:	af00      	add	r7, sp, #0
3419963e:	6078      	str	r0, [r7, #4]
34199640:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34199642:	687b      	ldr	r3, [r7, #4]
34199644:	2b00      	cmp	r3, #0
34199646:	d002      	beq.n	3419964e <ISP_SVC_Sensor_SetGain+0x16>
34199648:	683b      	ldr	r3, [r7, #0]
3419964a:	2b00      	cmp	r3, #0
3419964c:	d101      	bne.n	34199652 <ISP_SVC_Sensor_SetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
3419964e:	2378      	movs	r3, #120	@ 0x78
34199650:	e015      	b.n	3419967e <ISP_SVC_Sensor_SetGain+0x46>
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
34199652:	687b      	ldr	r3, [r7, #4]
34199654:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34199656:	2b00      	cmp	r3, #0
34199658:	d00c      	beq.n	34199674 <ISP_SVC_Sensor_SetGain+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, (int32_t)pConfig->gain) != 0)
3419965a:	687b      	ldr	r3, [r7, #4]
3419965c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419965e:	687a      	ldr	r2, [r7, #4]
34199660:	6850      	ldr	r0, [r2, #4]
34199662:	683a      	ldr	r2, [r7, #0]
34199664:	6812      	ldr	r2, [r2, #0]
34199666:	4611      	mov	r1, r2
34199668:	4798      	blx	r3
3419966a:	4603      	mov	r3, r0
3419966c:	2b00      	cmp	r3, #0
3419966e:	d001      	beq.n	34199674 <ISP_SVC_Sensor_SetGain+0x3c>
    {
      return ISP_ERR_SENSORGAIN;
34199670:	2379      	movs	r3, #121	@ 0x79
34199672:	e004      	b.n	3419967e <ISP_SVC_Sensor_SetGain+0x46>
    }
  }

  Meta.gain = pConfig->gain;
34199674:	683b      	ldr	r3, [r7, #0]
34199676:	681b      	ldr	r3, [r3, #0]
34199678:	4a03      	ldr	r2, [pc, #12]	@ (34199688 <ISP_SVC_Sensor_SetGain+0x50>)
3419967a:	6093      	str	r3, [r2, #8]

  return ISP_OK;
3419967c:	2300      	movs	r3, #0
}
3419967e:	4618      	mov	r0, r3
34199680:	3708      	adds	r7, #8
34199682:	46bd      	mov	sp, r7
34199684:	bd80      	pop	{r7, pc}
34199686:	bf00      	nop
34199688:	341c11b0 	.word	0x341c11b0

3419968c <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3419968c:	b580      	push	{r7, lr}
3419968e:	b082      	sub	sp, #8
34199690:	af00      	add	r7, sp, #0
34199692:	6078      	str	r0, [r7, #4]
34199694:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
34199696:	687b      	ldr	r3, [r7, #4]
34199698:	2b00      	cmp	r3, #0
3419969a:	d002      	beq.n	341996a2 <ISP_SVC_Sensor_GetGain+0x16>
3419969c:	683b      	ldr	r3, [r7, #0]
3419969e:	2b00      	cmp	r3, #0
341996a0:	d101      	bne.n	341996a6 <ISP_SVC_Sensor_GetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
341996a2:	2378      	movs	r3, #120	@ 0x78
341996a4:	e010      	b.n	341996c8 <ISP_SVC_Sensor_GetGain+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
341996a6:	687b      	ldr	r3, [r7, #4]
341996a8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341996aa:	2b00      	cmp	r3, #0
341996ac:	d00b      	beq.n	341996c6 <ISP_SVC_Sensor_GetGain+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
341996ae:	687b      	ldr	r3, [r7, #4]
341996b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341996b2:	687a      	ldr	r2, [r7, #4]
341996b4:	6852      	ldr	r2, [r2, #4]
341996b6:	6839      	ldr	r1, [r7, #0]
341996b8:	4610      	mov	r0, r2
341996ba:	4798      	blx	r3
341996bc:	4603      	mov	r3, r0
341996be:	2b00      	cmp	r3, #0
341996c0:	d001      	beq.n	341996c6 <ISP_SVC_Sensor_GetGain+0x3a>
    {
      return ISP_ERR_SENSORGAIN;
341996c2:	2379      	movs	r3, #121	@ 0x79
341996c4:	e000      	b.n	341996c8 <ISP_SVC_Sensor_GetGain+0x3c>
    }
  }

  return ISP_OK;
341996c6:	2300      	movs	r3, #0
}
341996c8:	4618      	mov	r0, r3
341996ca:	3708      	adds	r7, #8
341996cc:	46bd      	mov	sp, r7
341996ce:	bd80      	pop	{r7, pc}

341996d0 <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
341996d0:	b580      	push	{r7, lr}
341996d2:	b082      	sub	sp, #8
341996d4:	af00      	add	r7, sp, #0
341996d6:	6078      	str	r0, [r7, #4]
341996d8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
341996da:	687b      	ldr	r3, [r7, #4]
341996dc:	2b00      	cmp	r3, #0
341996de:	d002      	beq.n	341996e6 <ISP_SVC_Sensor_SetExposure+0x16>
341996e0:	683b      	ldr	r3, [r7, #0]
341996e2:	2b00      	cmp	r3, #0
341996e4:	d101      	bne.n	341996ea <ISP_SVC_Sensor_SetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
341996e6:	2382      	movs	r3, #130	@ 0x82
341996e8:	e015      	b.n	34199716 <ISP_SVC_Sensor_SetExposure+0x46>
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
341996ea:	687b      	ldr	r3, [r7, #4]
341996ec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341996ee:	2b00      	cmp	r3, #0
341996f0:	d00c      	beq.n	3419970c <ISP_SVC_Sensor_SetExposure+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, (int32_t)pConfig->exposure) != 0)
341996f2:	687b      	ldr	r3, [r7, #4]
341996f4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341996f6:	687a      	ldr	r2, [r7, #4]
341996f8:	6850      	ldr	r0, [r2, #4]
341996fa:	683a      	ldr	r2, [r7, #0]
341996fc:	6812      	ldr	r2, [r2, #0]
341996fe:	4611      	mov	r1, r2
34199700:	4798      	blx	r3
34199702:	4603      	mov	r3, r0
34199704:	2b00      	cmp	r3, #0
34199706:	d001      	beq.n	3419970c <ISP_SVC_Sensor_SetExposure+0x3c>
    {
      return ISP_ERR_SENSOREXPOSURE;
34199708:	2383      	movs	r3, #131	@ 0x83
3419970a:	e004      	b.n	34199716 <ISP_SVC_Sensor_SetExposure+0x46>
    }
  }

  Meta.exposure = pConfig->exposure;
3419970c:	683b      	ldr	r3, [r7, #0]
3419970e:	681b      	ldr	r3, [r3, #0]
34199710:	4a03      	ldr	r2, [pc, #12]	@ (34199720 <ISP_SVC_Sensor_SetExposure+0x50>)
34199712:	60d3      	str	r3, [r2, #12]

  return ISP_OK;
34199714:	2300      	movs	r3, #0
}
34199716:	4618      	mov	r0, r3
34199718:	3708      	adds	r7, #8
3419971a:	46bd      	mov	sp, r7
3419971c:	bd80      	pop	{r7, pc}
3419971e:	bf00      	nop
34199720:	341c11b0 	.word	0x341c11b0

34199724 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
34199724:	b580      	push	{r7, lr}
34199726:	b082      	sub	sp, #8
34199728:	af00      	add	r7, sp, #0
3419972a:	6078      	str	r0, [r7, #4]
3419972c:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419972e:	687b      	ldr	r3, [r7, #4]
34199730:	2b00      	cmp	r3, #0
34199732:	d002      	beq.n	3419973a <ISP_SVC_Sensor_GetExposure+0x16>
34199734:	683b      	ldr	r3, [r7, #0]
34199736:	2b00      	cmp	r3, #0
34199738:	d101      	bne.n	3419973e <ISP_SVC_Sensor_GetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3419973a:	2382      	movs	r3, #130	@ 0x82
3419973c:	e010      	b.n	34199760 <ISP_SVC_Sensor_GetExposure+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
3419973e:	687b      	ldr	r3, [r7, #4]
34199740:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34199742:	2b00      	cmp	r3, #0
34199744:	d00b      	beq.n	3419975e <ISP_SVC_Sensor_GetExposure+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
34199746:	687b      	ldr	r3, [r7, #4]
34199748:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419974a:	687a      	ldr	r2, [r7, #4]
3419974c:	6852      	ldr	r2, [r2, #4]
3419974e:	6839      	ldr	r1, [r7, #0]
34199750:	4610      	mov	r0, r2
34199752:	4798      	blx	r3
34199754:	4603      	mov	r3, r0
34199756:	2b00      	cmp	r3, #0
34199758:	d001      	beq.n	3419975e <ISP_SVC_Sensor_GetExposure+0x3a>
    {
      return ISP_ERR_SENSOREXPOSURE;
3419975a:	2383      	movs	r3, #131	@ 0x83
3419975c:	e000      	b.n	34199760 <ISP_SVC_Sensor_GetExposure+0x3c>
    }
  }

  return ISP_OK;
3419975e:	2300      	movs	r3, #0
}
34199760:	4618      	mov	r0, r3
34199762:	3708      	adds	r7, #8
34199764:	46bd      	mov	sp, r7
34199766:	bd80      	pop	{r7, pc}

34199768 <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
34199768:	b580      	push	{r7, lr}
3419976a:	b082      	sub	sp, #8
3419976c:	af00      	add	r7, sp, #0
3419976e:	6078      	str	r0, [r7, #4]
  /* Check handle validity */
  if (hIsp == NULL)
34199770:	687b      	ldr	r3, [r7, #4]
34199772:	2b00      	cmp	r3, #0
34199774:	d101      	bne.n	3419977a <ISP_SVC_Misc_IsDCMIPPReady+0x12>
  {
    return ISP_ERR_EINVAL;
34199776:	2301      	movs	r3, #1
34199778:	e00a      	b.n	34199790 <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
3419977a:	687b      	ldr	r3, [r7, #4]
3419977c:	681b      	ldr	r3, [r3, #0]
3419977e:	4618      	mov	r0, r3
34199780:	f7ee fdc1 	bl	34188306 <HAL_DCMIPP_GetState>
34199784:	4603      	mov	r3, r0
34199786:	2b02      	cmp	r3, #2
34199788:	d001      	beq.n	3419978e <ISP_SVC_Misc_IsDCMIPPReady+0x26>
  {
    return ISP_ERR_DCMIPP_STATE;
3419978a:	238c      	movs	r3, #140	@ 0x8c
3419978c:	e000      	b.n	34199790 <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  return ISP_OK;
3419978e:	2300      	movs	r3, #0
}
34199790:	4618      	mov	r0, r3
34199792:	3708      	adds	r7, #8
34199794:	46bd      	mov	sp, r7
34199796:	bd80      	pop	{r7, pc}

34199798 <ISP_SVC_Misc_IncMainFrameId>:
  *         Increment the id of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
34199798:	b480      	push	{r7}
3419979a:	b083      	sub	sp, #12
3419979c:	af00      	add	r7, sp, #0
3419979e:	6078      	str	r0, [r7, #4]
  hIsp->MainPipe_FrameCount++;
341997a0:	687b      	ldr	r3, [r7, #4]
341997a2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341997a4:	1c5a      	adds	r2, r3, #1
341997a6:	687b      	ldr	r3, [r7, #4]
341997a8:	641a      	str	r2, [r3, #64]	@ 0x40
}
341997aa:	bf00      	nop
341997ac:	370c      	adds	r7, #12
341997ae:	46bd      	mov	sp, r7
341997b0:	f85d 7b04 	ldr.w	r7, [sp], #4
341997b4:	4770      	bx	lr

341997b6 <ISP_SVC_Misc_GetMainFrameId>:
  *         Return the id of the last frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
341997b6:	b480      	push	{r7}
341997b8:	b083      	sub	sp, #12
341997ba:	af00      	add	r7, sp, #0
341997bc:	6078      	str	r0, [r7, #4]
  return hIsp->MainPipe_FrameCount;
341997be:	687b      	ldr	r3, [r7, #4]
341997c0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
341997c2:	4618      	mov	r0, r3
341997c4:	370c      	adds	r7, #12
341997c6:	46bd      	mov	sp, r7
341997c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341997cc:	4770      	bx	lr

341997ce <ISP_SVC_Misc_IncAncillaryFrameId>:
  *         Increment the id of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
341997ce:	b480      	push	{r7}
341997d0:	b083      	sub	sp, #12
341997d2:	af00      	add	r7, sp, #0
341997d4:	6078      	str	r0, [r7, #4]
  hIsp->AncillaryPipe_FrameCount++;
341997d6:	687b      	ldr	r3, [r7, #4]
341997d8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341997da:	1c5a      	adds	r2, r3, #1
341997dc:	687b      	ldr	r3, [r7, #4]
341997de:	645a      	str	r2, [r3, #68]	@ 0x44
}
341997e0:	bf00      	nop
341997e2:	370c      	adds	r7, #12
341997e4:	46bd      	mov	sp, r7
341997e6:	f85d 7b04 	ldr.w	r7, [sp], #4
341997ea:	4770      	bx	lr

341997ec <ISP_SVC_Misc_IncDumpFrameId>:
  *         Increment the id of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
341997ec:	b480      	push	{r7}
341997ee:	b083      	sub	sp, #12
341997f0:	af00      	add	r7, sp, #0
341997f2:	6078      	str	r0, [r7, #4]
  hIsp->DumpPipe_FrameCount++;
341997f4:	687b      	ldr	r3, [r7, #4]
341997f6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341997f8:	1c5a      	adds	r2, r3, #1
341997fa:	687b      	ldr	r3, [r7, #4]
341997fc:	649a      	str	r2, [r3, #72]	@ 0x48
}
341997fe:	bf00      	nop
34199800:	370c      	adds	r7, #12
34199802:	46bd      	mov	sp, r7
34199804:	f85d 7b04 	ldr.w	r7, [sp], #4
34199808:	4770      	bx	lr
	...

3419980c <ISP_SVC_Misc_SetWBRefMode>:
  * @param  hIsp: ISP device handle
  * @param  RefColorTemp: reference color temperature
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_SVC_Misc_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp)
{
3419980c:	b480      	push	{r7}
3419980e:	b083      	sub	sp, #12
34199810:	af00      	add	r7, sp, #0
34199812:	6078      	str	r0, [r7, #4]
34199814:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ISP_ManualWBRefColorTemp = RefColorTemp;
34199816:	4a05      	ldr	r2, [pc, #20]	@ (3419982c <ISP_SVC_Misc_SetWBRefMode+0x20>)
34199818:	683b      	ldr	r3, [r7, #0]
3419981a:	6013      	str	r3, [r2, #0]

  return ISP_OK;
3419981c:	2300      	movs	r3, #0
}
3419981e:	4618      	mov	r0, r3
34199820:	370c      	adds	r7, #12
34199822:	46bd      	mov	sp, r7
34199824:	f85d 7b04 	ldr.w	r7, [sp], #4
34199828:	4770      	bx	lr
3419982a:	bf00      	nop
3419982c:	341c1458 	.word	0x341c1458

34199830 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
34199830:	b580      	push	{r7, lr}
34199832:	b084      	sub	sp, #16
34199834:	af00      	add	r7, sp, #0
34199836:	6078      	str	r0, [r7, #4]
34199838:	6039      	str	r1, [r7, #0]
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
3419983a:	687b      	ldr	r3, [r7, #4]
3419983c:	2b00      	cmp	r3, #0
3419983e:	d101      	bne.n	34199844 <ISP_SVC_Misc_IsGammaEnabled+0x14>
  {
    return ISP_ERR_EINVAL;
34199840:	2301      	movs	r3, #1
34199842:	e020      	b.n	34199886 <ISP_SVC_Misc_IsGammaEnabled+0x56>
  }

  switch(Pipe)
34199844:	683b      	ldr	r3, [r7, #0]
34199846:	2b01      	cmp	r3, #1
34199848:	d003      	beq.n	34199852 <ISP_SVC_Misc_IsGammaEnabled+0x22>
3419984a:	683b      	ldr	r3, [r7, #0]
3419984c:	2b02      	cmp	r3, #2
3419984e:	d009      	beq.n	34199864 <ISP_SVC_Misc_IsGammaEnabled+0x34>
34199850:	e011      	b.n	34199876 <ISP_SVC_Misc_IsGammaEnabled+0x46>
  {
  case 1:
    ret = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
34199852:	687b      	ldr	r3, [r7, #4]
34199854:	681b      	ldr	r3, [r3, #0]
34199856:	2101      	movs	r1, #1
34199858:	4618      	mov	r0, r3
3419985a:	f7ed fc31 	bl	341870c0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3419985e:	4603      	mov	r3, r0
34199860:	73fb      	strb	r3, [r7, #15]
    break;
34199862:	e00a      	b.n	3419987a <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  case 2:
    ret = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
34199864:	687b      	ldr	r3, [r7, #4]
34199866:	681b      	ldr	r3, [r3, #0]
34199868:	2102      	movs	r1, #2
3419986a:	4618      	mov	r0, r3
3419986c:	f7ed fc28 	bl	341870c0 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
34199870:	4603      	mov	r3, r0
34199872:	73fb      	strb	r3, [r7, #15]
    break;
34199874:	e001      	b.n	3419987a <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  default:
    ret = 0; /*  No gamma on pipe 0 */
34199876:	2300      	movs	r3, #0
34199878:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
3419987a:	7bfb      	ldrb	r3, [r7, #15]
3419987c:	2b00      	cmp	r3, #0
3419987e:	bf14      	ite	ne
34199880:	2301      	movne	r3, #1
34199882:	2300      	moveq	r3, #0
34199884:	b2db      	uxtb	r3, r3
}
34199886:	4618      	mov	r0, r3
34199888:	3710      	adds	r7, #16
3419988a:	46bd      	mov	sp, r7
3419988c:	bd80      	pop	{r7, pc}

3419988e <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
3419988e:	b580      	push	{r7, lr}
34199890:	b082      	sub	sp, #8
34199892:	af00      	add	r7, sp, #0
34199894:	6078      	str	r0, [r7, #4]
34199896:	6039      	str	r1, [r7, #0]
  if ((hIsp == NULL) || (pConfig == NULL))
34199898:	687b      	ldr	r3, [r7, #4]
3419989a:	2b00      	cmp	r3, #0
3419989c:	d002      	beq.n	341998a4 <ISP_SVC_ISP_SetGamma+0x16>
3419989e:	683b      	ldr	r3, [r7, #0]
341998a0:	2b00      	cmp	r3, #0
341998a2:	d101      	bne.n	341998a8 <ISP_SVC_ISP_SetGamma+0x1a>
  {
    return ISP_ERR_DCMIPP_GAMMA;
341998a4:	2395      	movs	r3, #149	@ 0x95
341998a6:	e030      	b.n	3419990a <ISP_SVC_ISP_SetGamma+0x7c>
  }

  if (pConfig->enable == 0)
341998a8:	683b      	ldr	r3, [r7, #0]
341998aa:	781b      	ldrb	r3, [r3, #0]
341998ac:	2b00      	cmp	r3, #0
341998ae:	d115      	bne.n	341998dc <ISP_SVC_ISP_SetGamma+0x4e>
  {
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
341998b0:	687b      	ldr	r3, [r7, #4]
341998b2:	681b      	ldr	r3, [r3, #0]
341998b4:	2101      	movs	r1, #1
341998b6:	4618      	mov	r0, r3
341998b8:	f7ed fbd3 	bl	34187062 <HAL_DCMIPP_PIPE_DisableGammaConversion>
341998bc:	4603      	mov	r3, r0
341998be:	2b00      	cmp	r3, #0
341998c0:	d001      	beq.n	341998c6 <ISP_SVC_ISP_SetGamma+0x38>
    {
      return ISP_ERR_DCMIPP_GAMMA;
341998c2:	2395      	movs	r3, #149	@ 0x95
341998c4:	e021      	b.n	3419990a <ISP_SVC_ISP_SetGamma+0x7c>
    }
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
341998c6:	687b      	ldr	r3, [r7, #4]
341998c8:	681b      	ldr	r3, [r3, #0]
341998ca:	2102      	movs	r1, #2
341998cc:	4618      	mov	r0, r3
341998ce:	f7ed fbc8 	bl	34187062 <HAL_DCMIPP_PIPE_DisableGammaConversion>
341998d2:	4603      	mov	r3, r0
341998d4:	2b00      	cmp	r3, #0
341998d6:	d017      	beq.n	34199908 <ISP_SVC_ISP_SetGamma+0x7a>
    {
      return ISP_ERR_DCMIPP_GAMMA;
341998d8:	2395      	movs	r3, #149	@ 0x95
341998da:	e016      	b.n	3419990a <ISP_SVC_ISP_SetGamma+0x7c>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
341998dc:	687b      	ldr	r3, [r7, #4]
341998de:	681b      	ldr	r3, [r3, #0]
341998e0:	2101      	movs	r1, #1
341998e2:	4618      	mov	r0, r3
341998e4:	f7ed fb8e 	bl	34187004 <HAL_DCMIPP_PIPE_EnableGammaConversion>
341998e8:	4603      	mov	r3, r0
341998ea:	2b00      	cmp	r3, #0
341998ec:	d001      	beq.n	341998f2 <ISP_SVC_ISP_SetGamma+0x64>
    {
      return ISP_ERR_DCMIPP_GAMMA;
341998ee:	2395      	movs	r3, #149	@ 0x95
341998f0:	e00b      	b.n	3419990a <ISP_SVC_ISP_SetGamma+0x7c>
    }
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
341998f2:	687b      	ldr	r3, [r7, #4]
341998f4:	681b      	ldr	r3, [r3, #0]
341998f6:	2102      	movs	r1, #2
341998f8:	4618      	mov	r0, r3
341998fa:	f7ed fb83 	bl	34187004 <HAL_DCMIPP_PIPE_EnableGammaConversion>
341998fe:	4603      	mov	r3, r0
34199900:	2b00      	cmp	r3, #0
34199902:	d001      	beq.n	34199908 <ISP_SVC_ISP_SetGamma+0x7a>
    {
      return ISP_ERR_DCMIPP_GAMMA;
34199904:	2395      	movs	r3, #149	@ 0x95
34199906:	e000      	b.n	3419990a <ISP_SVC_ISP_SetGamma+0x7c>
    }
  }

  return ISP_OK;
34199908:	2300      	movs	r3, #0
}
3419990a:	4618      	mov	r0, r3
3419990c:	3708      	adds	r7, #8
3419990e:	46bd      	mov	sp, r7
34199910:	bd80      	pop	{r7, pc}
	...

34199914 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
34199914:	b580      	push	{r7, lr}
34199916:	b082      	sub	sp, #8
34199918:	af00      	add	r7, sp, #0
3419991a:	6078      	str	r0, [r7, #4]
3419991c:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
3419991e:	4a07      	ldr	r2, [pc, #28]	@ (3419993c <ISP_SVC_IQParam_Init+0x28>)
34199920:	683b      	ldr	r3, [r7, #0]
34199922:	4610      	mov	r0, r2
34199924:	4619      	mov	r1, r3
34199926:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419992a:	461a      	mov	r2, r3
3419992c:	f00a fab5 	bl	341a3e9a <memcpy>
  return ISP_OK;
34199930:	2300      	movs	r3, #0
}
34199932:	4618      	mov	r0, r3
34199934:	3708      	adds	r7, #8
34199936:	46bd      	mov	sp, r7
34199938:	bd80      	pop	{r7, pc}
3419993a:	bf00      	nop
3419993c:	341c145c 	.word	0x341c145c

34199940 <ISP_SVC_IQParam_Get>:
  *         Get the pointer to the IQ parameters cache
  * @param  hIsp: ISP device handle
  * @retval Pointer to the IQ Param config
  */
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
34199940:	b480      	push	{r7}
34199942:	b083      	sub	sp, #12
34199944:	af00      	add	r7, sp, #0
34199946:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
34199948:	4b03      	ldr	r3, [pc, #12]	@ (34199958 <ISP_SVC_IQParam_Get+0x18>)
}
3419994a:	4618      	mov	r0, r3
3419994c:	370c      	adds	r7, #12
3419994e:	46bd      	mov	sp, r7
34199950:	f85d 7b04 	ldr.w	r7, [sp], #4
34199954:	4770      	bx	lr
34199956:	bf00      	nop
34199958:	341c145c 	.word	0x341c145c

3419995c <ISP_SVC_Stats_Init>:
  *         Initialize the statistic engine
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
3419995c:	b580      	push	{r7, lr}
3419995e:	b082      	sub	sp, #8
34199960:	af00      	add	r7, sp, #0
34199962:	6078      	str	r0, [r7, #4]
  UNUSED(hIsp);
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
34199964:	f44f 72b0 	mov.w	r2, #352	@ 0x160
34199968:	2100      	movs	r1, #0
3419996a:	4803      	ldr	r0, [pc, #12]	@ (34199978 <ISP_SVC_Stats_Init+0x1c>)
3419996c:	f00a fa1a 	bl	341a3da4 <memset>
}
34199970:	bf00      	nop
34199972:	3708      	adds	r7, #8
34199974:	46bd      	mov	sp, r7
34199976:	bd80      	pop	{r7, pc}
34199978:	341c16b4 	.word	0x341c16b4

3419997c <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
3419997c:	b5b0      	push	{r4, r5, r7, lr}
3419997e:	b092      	sub	sp, #72	@ 0x48
34199980:	af00      	add	r7, sp, #0
34199982:	6078      	str	r0, [r7, #4]
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t avgR, avgG, avgB, frameId;
  uint8_t i;

  /* Check handle validity */
  if (hIsp == NULL)
34199984:	687b      	ldr	r3, [r7, #4]
34199986:	2b00      	cmp	r3, #0
34199988:	d103      	bne.n	34199992 <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
3419998a:	48bf      	ldr	r0, [pc, #764]	@ (34199c88 <ISP_SVC_Stats_Gather+0x30c>)
3419998c:	f00a f8da 	bl	341a3b44 <puts>
    return;
34199990:	e2bc      	b.n	34199f0c <ISP_SVC_Stats_Gather+0x590>
  }

  if (hIsp->hDcmipp == NULL)
34199992:	687b      	ldr	r3, [r7, #4]
34199994:	681b      	ldr	r3, [r3, #0]
34199996:	2b00      	cmp	r3, #0
34199998:	f000 82b7 	beq.w	34199f0a <ISP_SVC_Stats_Gather+0x58e>
  }

  /* Read the stats according to the configuration applied 2 VSYNC (shadow register + stat computation)
   * stages earlier.
   */
  ongoing = &ISP_SVC_StatEngine.ongoing;
3419999c:	4bbb      	ldr	r3, [pc, #748]	@ (34199c8c <ISP_SVC_Stats_Gather+0x310>)
3419999e:	643b      	str	r3, [r7, #64]	@ 0x40
  switch(stagePrevious2)
341999a0:	4bbb      	ldr	r3, [pc, #748]	@ (34199c90 <ISP_SVC_Stats_Gather+0x314>)
341999a2:	781b      	ldrb	r3, [r3, #0]
341999a4:	2b09      	cmp	r3, #9
341999a6:	f200 80fd 	bhi.w	34199ba4 <ISP_SVC_Stats_Gather+0x228>
341999aa:	a201      	add	r2, pc, #4	@ (adr r2, 341999b0 <ISP_SVC_Stats_Gather+0x34>)
341999ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341999b0:	341999d9 	.word	0x341999d9
341999b4:	34199a61 	.word	0x34199a61
341999b8:	34199a6f 	.word	0x34199a6f
341999bc:	34199a7d 	.word	0x34199a7d
341999c0:	34199a8b 	.word	0x34199a8b
341999c4:	34199a99 	.word	0x34199a99
341999c8:	34199b6d 	.word	0x34199b6d
341999cc:	34199b7b 	.word	0x34199b7b
341999d0:	34199b89 	.word	0x34199b89
341999d4:	34199b97 	.word	0x34199b97
  {
  case ISP_STAT_CFG_UP_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
341999d8:	687b      	ldr	r3, [r7, #4]
341999da:	6818      	ldr	r0, [r3, #0]
341999dc:	f107 0310 	add.w	r3, r7, #16
341999e0:	2201      	movs	r2, #1
341999e2:	2101      	movs	r1, #1
341999e4:	f7ee fa81 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
341999e8:	687b      	ldr	r3, [r7, #4]
341999ea:	6818      	ldr	r0, [r3, #0]
341999ec:	f107 030c 	add.w	r3, r7, #12
341999f0:	2202      	movs	r2, #2
341999f2:	2101      	movs	r1, #1
341999f4:	f7ee fa79 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
341999f8:	687b      	ldr	r3, [r7, #4]
341999fa:	6818      	ldr	r0, [r3, #0]
341999fc:	f107 0308 	add.w	r3, r7, #8
34199a00:	2203      	movs	r2, #3
34199a02:	2101      	movs	r1, #1
34199a04:	f7ee fa71 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
34199a08:	693b      	ldr	r3, [r7, #16]
34199a0a:	2200      	movs	r2, #0
34199a0c:	2101      	movs	r1, #1
34199a0e:	6878      	ldr	r0, [r7, #4]
34199a10:	f7fe fe9e 	bl	34198750 <GetAvgStats>
34199a14:	4603      	mov	r3, r0
34199a16:	461a      	mov	r2, r3
34199a18:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a1a:	701a      	strb	r2, [r3, #0]
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
34199a1c:	68fb      	ldr	r3, [r7, #12]
34199a1e:	2201      	movs	r2, #1
34199a20:	2101      	movs	r1, #1
34199a22:	6878      	ldr	r0, [r7, #4]
34199a24:	f7fe fe94 	bl	34198750 <GetAvgStats>
34199a28:	4603      	mov	r3, r0
34199a2a:	461a      	mov	r2, r3
34199a2c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a2e:	705a      	strb	r2, [r3, #1]
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
34199a30:	68bb      	ldr	r3, [r7, #8]
34199a32:	2202      	movs	r2, #2
34199a34:	2101      	movs	r1, #1
34199a36:	6878      	ldr	r0, [r7, #4]
34199a38:	f7fe fe8a 	bl	34198750 <GetAvgStats>
34199a3c:	4603      	mov	r3, r0
34199a3e:	461a      	mov	r2, r3
34199a40:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a42:	709a      	strb	r2, [r3, #2]
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
34199a44:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a46:	7818      	ldrb	r0, [r3, #0]
34199a48:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a4a:	7859      	ldrb	r1, [r3, #1]
34199a4c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a4e:	789b      	ldrb	r3, [r3, #2]
34199a50:	461a      	mov	r2, r3
34199a52:	f7ff f865 	bl	34198b20 <LuminanceFromRGB>
34199a56:	4603      	mov	r3, r0
34199a58:	461a      	mov	r2, r3
34199a5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a5c:	70da      	strb	r2, [r3, #3]
    break;
34199a5e:	e0a2      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
34199a60:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a62:	3304      	adds	r3, #4
34199a64:	4619      	mov	r1, r3
34199a66:	6878      	ldr	r0, [r7, #4]
34199a68:	f7fe feb6 	bl	341987d8 <ReadStatHistogram>
    break;
34199a6c:	e09b      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
34199a6e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a70:	3310      	adds	r3, #16
34199a72:	4619      	mov	r1, r3
34199a74:	6878      	ldr	r0, [r7, #4]
34199a76:	f7fe feaf 	bl	341987d8 <ReadStatHistogram>
    break;
34199a7a:	e094      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
34199a7c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a7e:	331c      	adds	r3, #28
34199a80:	4619      	mov	r1, r3
34199a82:	6878      	ldr	r0, [r7, #4]
34199a84:	f7fe fea8 	bl	341987d8 <ReadStatHistogram>
    break;
34199a88:	e08d      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
34199a8a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199a8c:	3328      	adds	r3, #40	@ 0x28
34199a8e:	4619      	mov	r1, r3
34199a90:	6878      	ldr	r0, [r7, #4]
34199a92:	f7fe fea1 	bl	341987d8 <ReadStatHistogram>
    break;
34199a96:	e086      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
34199a98:	687b      	ldr	r3, [r7, #4]
34199a9a:	6818      	ldr	r0, [r3, #0]
34199a9c:	f107 0310 	add.w	r3, r7, #16
34199aa0:	2201      	movs	r2, #1
34199aa2:	2101      	movs	r1, #1
34199aa4:	f7ee fa21 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
34199aa8:	687b      	ldr	r3, [r7, #4]
34199aaa:	6818      	ldr	r0, [r3, #0]
34199aac:	f107 030c 	add.w	r3, r7, #12
34199ab0:	2202      	movs	r2, #2
34199ab2:	2101      	movs	r1, #1
34199ab4:	f7ee fa19 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
34199ab8:	687b      	ldr	r3, [r7, #4]
34199aba:	6818      	ldr	r0, [r3, #0]
34199abc:	f107 0308 	add.w	r3, r7, #8
34199ac0:	2203      	movs	r2, #3
34199ac2:	2101      	movs	r1, #1
34199ac4:	f7ee fa11 	bl	34187eea <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
34199ac8:	693b      	ldr	r3, [r7, #16]
34199aca:	2200      	movs	r2, #0
34199acc:	2102      	movs	r1, #2
34199ace:	6878      	ldr	r0, [r7, #4]
34199ad0:	f7fe fe3e 	bl	34198750 <GetAvgStats>
34199ad4:	4603      	mov	r3, r0
34199ad6:	461a      	mov	r2, r3
34199ad8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199ada:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
34199ade:	68fb      	ldr	r3, [r7, #12]
34199ae0:	2201      	movs	r2, #1
34199ae2:	2102      	movs	r1, #2
34199ae4:	6878      	ldr	r0, [r7, #4]
34199ae6:	f7fe fe33 	bl	34198750 <GetAvgStats>
34199aea:	4603      	mov	r3, r0
34199aec:	461a      	mov	r2, r3
34199aee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199af0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
34199af4:	68bb      	ldr	r3, [r7, #8]
34199af6:	2202      	movs	r2, #2
34199af8:	2102      	movs	r1, #2
34199afa:	6878      	ldr	r0, [r7, #4]
34199afc:	f7fe fe28 	bl	34198750 <GetAvgStats>
34199b00:	4603      	mov	r3, r0
34199b02:	461a      	mov	r2, r3
34199b04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b06:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
    IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34199b0a:	6878      	ldr	r0, [r7, #4]
34199b0c:	f7ff ff18 	bl	34199940 <ISP_SVC_IQParam_Get>
34199b10:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
34199b12:	687b      	ldr	r3, [r7, #4]
34199b14:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
34199b18:	2b04      	cmp	r3, #4
34199b1a:	d003      	beq.n	34199b24 <ISP_SVC_Stats_Gather+0x1a8>
34199b1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34199b1e:	7b1b      	ldrb	r3, [r3, #12]
34199b20:	2b00      	cmp	r3, #0
34199b22:	d111      	bne.n	34199b48 <ISP_SVC_Stats_Gather+0x1cc>
    {
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34199b24:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b26:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
34199b2a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b2c:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
34199b30:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b32:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34199b36:	461a      	mov	r2, r3
34199b38:	f7ff f832 	bl	34198ba0 <LuminanceFromRGBMono>
34199b3c:	4603      	mov	r3, r0
34199b3e:	461a      	mov	r2, r3
34199b40:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b42:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    }
    else
    {
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
    }
    break;
34199b46:	e02e      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
34199b48:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b4a:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
34199b4e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b50:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
34199b54:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b56:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34199b5a:	461a      	mov	r2, r3
34199b5c:	f7fe ffe0 	bl	34198b20 <LuminanceFromRGB>
34199b60:	4603      	mov	r3, r0
34199b62:	461a      	mov	r2, r3
34199b64:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b66:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    break;
34199b6a:	e01c      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
34199b6c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b6e:	3338      	adds	r3, #56	@ 0x38
34199b70:	4619      	mov	r1, r3
34199b72:	6878      	ldr	r0, [r7, #4]
34199b74:	f7fe fe30 	bl	341987d8 <ReadStatHistogram>
    break;
34199b78:	e015      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
34199b7a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b7c:	3344      	adds	r3, #68	@ 0x44
34199b7e:	4619      	mov	r1, r3
34199b80:	6878      	ldr	r0, [r7, #4]
34199b82:	f7fe fe29 	bl	341987d8 <ReadStatHistogram>
    break;
34199b86:	e00e      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
34199b88:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b8a:	3350      	adds	r3, #80	@ 0x50
34199b8c:	4619      	mov	r1, r3
34199b8e:	6878      	ldr	r0, [r7, #4]
34199b90:	f7fe fe22 	bl	341987d8 <ReadStatHistogram>
    break;
34199b94:	e007      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
34199b96:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199b98:	335c      	adds	r3, #92	@ 0x5c
34199b9a:	4619      	mov	r1, r3
34199b9c:	6878      	ldr	r0, [r7, #4]
34199b9e:	f7fe fe1b 	bl	341987d8 <ReadStatHistogram>
    break;
34199ba2:	e000      	b.n	34199ba6 <ISP_SVC_Stats_Gather+0x22a>

  default:
    /* No Read */
    break;
34199ba4:	bf00      	nop
  }

  /* Configure stat for a new stage */
  switch(ISP_SVC_StatEngine.stage)
34199ba6:	4b3b      	ldr	r3, [pc, #236]	@ (34199c94 <ISP_SVC_Stats_Gather+0x318>)
34199ba8:	781b      	ldrb	r3, [r3, #0]
34199baa:	2b09      	cmp	r3, #9
34199bac:	f200 80c9 	bhi.w	34199d42 <ISP_SVC_Stats_Gather+0x3c6>
34199bb0:	a201      	add	r2, pc, #4	@ (adr r2, 34199bb8 <ISP_SVC_Stats_Gather+0x23c>)
34199bb2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34199bb6:	bf00      	nop
34199bb8:	34199be1 	.word	0x34199be1
34199bbc:	34199c47 	.word	0x34199c47
34199bc0:	34199c55 	.word	0x34199c55
34199bc4:	34199c63 	.word	0x34199c63
34199bc8:	34199c71 	.word	0x34199c71
34199bcc:	34199c7f 	.word	0x34199c7f
34199bd0:	34199d0b 	.word	0x34199d0b
34199bd4:	34199d19 	.word	0x34199d19
34199bd8:	34199d27 	.word	0x34199d27
34199bdc:	34199d35 	.word	0x34199d35
  {
  case ISP_STAT_CFG_UP_AVG:
    for (i = 0; i < 3; i++)
34199be0:	2300      	movs	r3, #0
34199be2:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199be6:	e029      	b.n	34199c3c <ISP_SVC_Stats_Gather+0x2c0>
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34199be8:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199bec:	4613      	mov	r3, r2
34199bee:	005b      	lsls	r3, r3, #1
34199bf0:	4413      	add	r3, r2
34199bf2:	009b      	lsls	r3, r3, #2
34199bf4:	3348      	adds	r3, #72	@ 0x48
34199bf6:	443b      	add	r3, r7
34199bf8:	3b34      	subs	r3, #52	@ 0x34
34199bfa:	2200      	movs	r2, #0
34199bfc:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBUp[i];
34199bfe:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199c02:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199c06:	4924      	ldr	r1, [pc, #144]	@ (34199c98 <ISP_SVC_Stats_Gather+0x31c>)
34199c08:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34199c0c:	4613      	mov	r3, r2
34199c0e:	005b      	lsls	r3, r3, #1
34199c10:	4413      	add	r3, r2
34199c12:	009b      	lsls	r3, r3, #2
34199c14:	3348      	adds	r3, #72	@ 0x48
34199c16:	443b      	add	r3, r7
34199c18:	3b30      	subs	r3, #48	@ 0x30
34199c1a:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34199c1c:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199c20:	4613      	mov	r3, r2
34199c22:	005b      	lsls	r3, r3, #1
34199c24:	4413      	add	r3, r2
34199c26:	009b      	lsls	r3, r3, #2
34199c28:	3348      	adds	r3, #72	@ 0x48
34199c2a:	443b      	add	r3, r7
34199c2c:	3b2c      	subs	r3, #44	@ 0x2c
34199c2e:	2200      	movs	r2, #0
34199c30:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
34199c32:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199c36:	3301      	adds	r3, #1
34199c38:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199c3c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199c40:	2b02      	cmp	r3, #2
34199c42:	d9d1      	bls.n	34199be8 <ISP_SVC_Stats_Gather+0x26c>
    }
    break;
34199c44:	e07e      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_0_2:
    SetStatConfig(statConf, &statConfUpBins_0_2);
34199c46:	f107 0314 	add.w	r3, r7, #20
34199c4a:	4914      	ldr	r1, [pc, #80]	@ (34199c9c <ISP_SVC_Stats_Gather+0x320>)
34199c4c:	4618      	mov	r0, r3
34199c4e:	f7fe fde3 	bl	34198818 <SetStatConfig>
    break;
34199c52:	e077      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_3_5:
    SetStatConfig(statConf, &statConfUpBins_3_5);
34199c54:	f107 0314 	add.w	r3, r7, #20
34199c58:	4911      	ldr	r1, [pc, #68]	@ (34199ca0 <ISP_SVC_Stats_Gather+0x324>)
34199c5a:	4618      	mov	r0, r3
34199c5c:	f7fe fddc 	bl	34198818 <SetStatConfig>
    break;
34199c60:	e070      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_6_8:
    SetStatConfig(statConf, &statConfUpBins_6_8);
34199c62:	f107 0314 	add.w	r3, r7, #20
34199c66:	490f      	ldr	r1, [pc, #60]	@ (34199ca4 <ISP_SVC_Stats_Gather+0x328>)
34199c68:	4618      	mov	r0, r3
34199c6a:	f7fe fdd5 	bl	34198818 <SetStatConfig>
    break;
34199c6e:	e069      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_9_11:
    SetStatConfig(statConf, &statConfUpBins_9_11);
34199c70:	f107 0314 	add.w	r3, r7, #20
34199c74:	490c      	ldr	r1, [pc, #48]	@ (34199ca8 <ISP_SVC_Stats_Gather+0x32c>)
34199c76:	4618      	mov	r0, r3
34199c78:	f7fe fdce 	bl	34198818 <SetStatConfig>
    break;
34199c7c:	e062      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_AVG:
    for (i = 0; i < 3; i++)
34199c7e:	2300      	movs	r3, #0
34199c80:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199c84:	e03c      	b.n	34199d00 <ISP_SVC_Stats_Gather+0x384>
34199c86:	bf00      	nop
34199c88:	341a5ebc 	.word	0x341a5ebc
34199c8c:	341c1730 	.word	0x341c1730
34199c90:	341c00f5 	.word	0x341c00f5
34199c94:	341c16b4 	.word	0x341c16b4
34199c98:	341b0f00 	.word	0x341b0f00
34199c9c:	341b0f18 	.word	0x341b0f18
34199ca0:	341b0f24 	.word	0x341b0f24
34199ca4:	341b0f30 	.word	0x341b0f30
34199ca8:	341b0f3c 	.word	0x341b0f3c
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
34199cac:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199cb0:	4613      	mov	r3, r2
34199cb2:	005b      	lsls	r3, r3, #1
34199cb4:	4413      	add	r3, r2
34199cb6:	009b      	lsls	r3, r3, #2
34199cb8:	3348      	adds	r3, #72	@ 0x48
34199cba:	443b      	add	r3, r7
34199cbc:	3b34      	subs	r3, #52	@ 0x34
34199cbe:	2200      	movs	r2, #0
34199cc0:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBDown[i];
34199cc2:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199cc6:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199cca:	4992      	ldr	r1, [pc, #584]	@ (34199f14 <ISP_SVC_Stats_Gather+0x598>)
34199ccc:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34199cd0:	4613      	mov	r3, r2
34199cd2:	005b      	lsls	r3, r3, #1
34199cd4:	4413      	add	r3, r2
34199cd6:	009b      	lsls	r3, r3, #2
34199cd8:	3348      	adds	r3, #72	@ 0x48
34199cda:	443b      	add	r3, r7
34199cdc:	3b30      	subs	r3, #48	@ 0x30
34199cde:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
34199ce0:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199ce4:	4613      	mov	r3, r2
34199ce6:	005b      	lsls	r3, r3, #1
34199ce8:	4413      	add	r3, r2
34199cea:	009b      	lsls	r3, r3, #2
34199cec:	3348      	adds	r3, #72	@ 0x48
34199cee:	443b      	add	r3, r7
34199cf0:	3b2c      	subs	r3, #44	@ 0x2c
34199cf2:	2200      	movs	r2, #0
34199cf4:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
34199cf6:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199cfa:	3301      	adds	r3, #1
34199cfc:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199d00:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199d04:	2b02      	cmp	r3, #2
34199d06:	d9d1      	bls.n	34199cac <ISP_SVC_Stats_Gather+0x330>
    }
    break;
34199d08:	e01c      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    SetStatConfig(statConf, &statConfDownBins_0_2);
34199d0a:	f107 0314 	add.w	r3, r7, #20
34199d0e:	4982      	ldr	r1, [pc, #520]	@ (34199f18 <ISP_SVC_Stats_Gather+0x59c>)
34199d10:	4618      	mov	r0, r3
34199d12:	f7fe fd81 	bl	34198818 <SetStatConfig>
    break;
34199d16:	e015      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    SetStatConfig(statConf, &statConfDownBins_3_5);
34199d18:	f107 0314 	add.w	r3, r7, #20
34199d1c:	497f      	ldr	r1, [pc, #508]	@ (34199f1c <ISP_SVC_Stats_Gather+0x5a0>)
34199d1e:	4618      	mov	r0, r3
34199d20:	f7fe fd7a 	bl	34198818 <SetStatConfig>
    break;
34199d24:	e00e      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    SetStatConfig(statConf, &statConfDownBins_6_8);
34199d26:	f107 0314 	add.w	r3, r7, #20
34199d2a:	497d      	ldr	r1, [pc, #500]	@ (34199f20 <ISP_SVC_Stats_Gather+0x5a4>)
34199d2c:	4618      	mov	r0, r3
34199d2e:	f7fe fd73 	bl	34198818 <SetStatConfig>
    break;
34199d32:	e007      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    SetStatConfig(statConf, &statConfDownBins_9_11);
34199d34:	f107 0314 	add.w	r3, r7, #20
34199d38:	497a      	ldr	r1, [pc, #488]	@ (34199f24 <ISP_SVC_Stats_Gather+0x5a8>)
34199d3a:	4618      	mov	r0, r3
34199d3c:	f7fe fd6c 	bl	34198818 <SetStatConfig>
    break;
34199d40:	e000      	b.n	34199d44 <ISP_SVC_Stats_Gather+0x3c8>

  default:
    /* Configure Unchanged */
    break;
34199d42:	bf00      	nop
  }

  /* Apply configuration (for an output result available 2 VSYNC later) */
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34199d44:	2301      	movs	r3, #1
34199d46:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199d4a:	e02b      	b.n	34199da4 <ISP_SVC_Stats_Gather+0x428>
  {
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
34199d4c:	687b      	ldr	r3, [r7, #4]
34199d4e:	6818      	ldr	r0, [r3, #0]
34199d50:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199d54:	1e5a      	subs	r2, r3, #1
34199d56:	f107 0114 	add.w	r1, r7, #20
34199d5a:	4613      	mov	r3, r2
34199d5c:	005b      	lsls	r3, r3, #1
34199d5e:	4413      	add	r3, r2
34199d60:	009b      	lsls	r3, r3, #2
34199d62:	440b      	add	r3, r1
34199d64:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199d68:	2101      	movs	r1, #1
34199d6a:	f7ed fdbe 	bl	341878ea <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
34199d6e:	4603      	mov	r3, r0
34199d70:	2b00      	cmp	r3, #0
34199d72:	d003      	beq.n	34199d7c <ISP_SVC_Stats_Gather+0x400>
    {
      printf("ERROR: can't set Statistic Extraction config\r\n");
34199d74:	486c      	ldr	r0, [pc, #432]	@ (34199f28 <ISP_SVC_Stats_Gather+0x5ac>)
34199d76:	f009 fee5 	bl	341a3b44 <puts>
      return;
34199d7a:	e0c7      	b.n	34199f0c <ISP_SVC_Stats_Gather+0x590>
    }

    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
34199d7c:	687b      	ldr	r3, [r7, #4]
34199d7e:	681b      	ldr	r3, [r3, #0]
34199d80:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
34199d84:	2101      	movs	r1, #1
34199d86:	4618      	mov	r0, r3
34199d88:	f7ed fe3d 	bl	34187a06 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
34199d8c:	4603      	mov	r3, r0
34199d8e:	2b00      	cmp	r3, #0
34199d90:	d003      	beq.n	34199d9a <ISP_SVC_Stats_Gather+0x41e>
    {
      printf("ERROR: can't enable Statistic Extraction config\r\n");
34199d92:	4866      	ldr	r0, [pc, #408]	@ (34199f2c <ISP_SVC_Stats_Gather+0x5b0>)
34199d94:	f009 fed6 	bl	341a3b44 <puts>
      return;
34199d98:	e0b8      	b.n	34199f0c <ISP_SVC_Stats_Gather+0x590>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34199d9a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199d9e:	3301      	adds	r3, #1
34199da0:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
34199da4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
34199da8:	2b03      	cmp	r3, #3
34199daa:	d9cf      	bls.n	34199d4c <ISP_SVC_Stats_Gather+0x3d0>
    }
  }

  /* Cycle start / end */
  frameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
34199dac:	6878      	ldr	r0, [r7, #4]
34199dae:	f7ff fd02 	bl	341997b6 <ISP_SVC_Misc_GetMainFrameId>
34199db2:	63b8      	str	r0, [r7, #56]	@ 0x38

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
34199db4:	2001      	movs	r0, #1
34199db6:	f7fe fe41 	bl	34198a3c <GetStatCycleStart>
34199dba:	4603      	mov	r3, r0
34199dbc:	461a      	mov	r2, r3
34199dbe:	4b5c      	ldr	r3, [pc, #368]	@ (34199f30 <ISP_SVC_Stats_Gather+0x5b4>)
34199dc0:	781b      	ldrb	r3, [r3, #0]
34199dc2:	429a      	cmp	r2, r3
34199dc4:	d102      	bne.n	34199dcc <ISP_SVC_Stats_Gather+0x450>
  {
    ongoing->upFrameIdStart = frameId;
34199dc6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199dc8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34199dca:	669a      	str	r2, [r3, #104]	@ 0x68
  }

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
34199dcc:	2002      	movs	r0, #2
34199dce:	f7fe fe35 	bl	34198a3c <GetStatCycleStart>
34199dd2:	4603      	mov	r3, r0
34199dd4:	461a      	mov	r2, r3
34199dd6:	4b56      	ldr	r3, [pc, #344]	@ (34199f30 <ISP_SVC_Stats_Gather+0x5b4>)
34199dd8:	781b      	ldrb	r3, [r3, #0]
34199dda:	429a      	cmp	r2, r3
34199ddc:	d102      	bne.n	34199de4 <ISP_SVC_Stats_Gather+0x468>
  {
    ongoing->downFrameIdStart = frameId;
34199dde:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199de0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34199de2:	671a      	str	r2, [r3, #112]	@ 0x70
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
34199de4:	2001      	movs	r0, #1
34199de6:	f7fe fe61 	bl	34198aac <GetStatCycleEnd>
34199dea:	4603      	mov	r3, r0
34199dec:	461a      	mov	r2, r3
34199dee:	4b50      	ldr	r3, [pc, #320]	@ (34199f30 <ISP_SVC_Stats_Gather+0x5b4>)
34199df0:	781b      	ldrb	r3, [r3, #0]
34199df2:	429a      	cmp	r2, r3
34199df4:	d122      	bne.n	34199e3c <ISP_SVC_Stats_Gather+0x4c0>
34199df6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199df8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34199dfa:	2b00      	cmp	r3, #0
34199dfc:	d01e      	beq.n	34199e3c <ISP_SVC_Stats_Gather+0x4c0>
  {
    /* Last measure of the up cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.up = ongoing->up;
34199dfe:	4b4d      	ldr	r3, [pc, #308]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e00:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34199e02:	1d1c      	adds	r4, r3, #4
34199e04:	4615      	mov	r5, r2
34199e06:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e08:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e0a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e0c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e12:	682b      	ldr	r3, [r5, #0]
34199e14:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.upFrameIdEnd = frameId;
34199e16:	4a47      	ldr	r2, [pc, #284]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34199e1a:	6713      	str	r3, [r2, #112]	@ 0x70
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
34199e1c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e1e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34199e20:	4a44      	ldr	r2, [pc, #272]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e22:	66d3      	str	r3, [r2, #108]	@ 0x6c

    memset(&ongoing->up, 0, sizeof(ongoing->up));
34199e24:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e26:	2234      	movs	r2, #52	@ 0x34
34199e28:	2100      	movs	r1, #0
34199e2a:	4618      	mov	r0, r3
34199e2c:	f009 ffba 	bl	341a3da4 <memset>
    ongoing->upFrameIdStart = 0;
34199e30:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e32:	2200      	movs	r2, #0
34199e34:	669a      	str	r2, [r3, #104]	@ 0x68
    ongoing->upFrameIdEnd = 0;
34199e36:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e38:	2200      	movs	r2, #0
34199e3a:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
34199e3c:	2002      	movs	r0, #2
34199e3e:	f7fe fe35 	bl	34198aac <GetStatCycleEnd>
34199e42:	4603      	mov	r3, r0
34199e44:	461a      	mov	r2, r3
34199e46:	4b3a      	ldr	r3, [pc, #232]	@ (34199f30 <ISP_SVC_Stats_Gather+0x5b4>)
34199e48:	781b      	ldrb	r3, [r3, #0]
34199e4a:	429a      	cmp	r2, r3
34199e4c:	d125      	bne.n	34199e9a <ISP_SVC_Stats_Gather+0x51e>
34199e4e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e50:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34199e52:	2b00      	cmp	r3, #0
34199e54:	d021      	beq.n	34199e9a <ISP_SVC_Stats_Gather+0x51e>
  {
    /* Last measure of the down cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.down = ongoing->down;
34199e56:	4a37      	ldr	r2, [pc, #220]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e58:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e5a:	f102 0438 	add.w	r4, r2, #56	@ 0x38
34199e5e:	f103 0534 	add.w	r5, r3, #52	@ 0x34
34199e62:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e64:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e66:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e68:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199e6c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199e6e:	682b      	ldr	r3, [r5, #0]
34199e70:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.downFrameIdEnd = frameId;
34199e72:	4a30      	ldr	r2, [pc, #192]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e74:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34199e76:	6793      	str	r3, [r2, #120]	@ 0x78
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
34199e78:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e7a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34199e7c:	4a2d      	ldr	r2, [pc, #180]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e7e:	6753      	str	r3, [r2, #116]	@ 0x74

    memset(&ongoing->down, 0, sizeof(ongoing->down));
34199e80:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e82:	3334      	adds	r3, #52	@ 0x34
34199e84:	2234      	movs	r2, #52	@ 0x34
34199e86:	2100      	movs	r1, #0
34199e88:	4618      	mov	r0, r3
34199e8a:	f009 ff8b 	bl	341a3da4 <memset>
    ongoing->downFrameIdStart = 0;
34199e8e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e90:	2200      	movs	r2, #0
34199e92:	671a      	str	r2, [r3, #112]	@ 0x70
    ongoing->downFrameIdEnd = 0;
34199e94:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34199e96:	2200      	movs	r2, #0
34199e98:	675a      	str	r2, [r3, #116]	@ 0x74
  }

  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34199e9a:	4b26      	ldr	r3, [pc, #152]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199e9c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199ea0:	f003 0304 	and.w	r3, r3, #4
34199ea4:	2b00      	cmp	r3, #0
34199ea6:	d106      	bne.n	34199eb6 <ISP_SVC_Stats_Gather+0x53a>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
34199ea8:	4b22      	ldr	r3, [pc, #136]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199eaa:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199eae:	f003 0304 	and.w	r3, r3, #4
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34199eb2:	2b00      	cmp	r3, #0
34199eb4:	d017      	beq.n	34199ee6 <ISP_SVC_Stats_Gather+0x56a>
      (frameId > ISP_SVC_StatEngine.requestAllCounter))
34199eb6:	4b1f      	ldr	r3, [pc, #124]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199eb8:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
34199ebc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34199ebe:	429a      	cmp	r2, r3
34199ec0:	d911      	bls.n	34199ee6 <ISP_SVC_Stats_Gather+0x56a>
  {
    /* Stop the special temporary mode "request all stats" when its delay expires */
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34199ec2:	4b1c      	ldr	r3, [pc, #112]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ec4:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199ec8:	f023 0304 	bic.w	r3, r3, #4
34199ecc:	b2da      	uxtb	r2, r3
34199ece:	4b19      	ldr	r3, [pc, #100]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ed0:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34199ed4:	4b17      	ldr	r3, [pc, #92]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ed6:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199eda:	f023 0304 	bic.w	r3, r3, #4
34199ede:	b2da      	uxtb	r2, r3
34199ee0:	4b14      	ldr	r3, [pc, #80]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ee2:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
34199ee6:	4b14      	ldr	r3, [pc, #80]	@ (34199f38 <ISP_SVC_Stats_Gather+0x5bc>)
34199ee8:	781a      	ldrb	r2, [r3, #0]
34199eea:	4b11      	ldr	r3, [pc, #68]	@ (34199f30 <ISP_SVC_Stats_Gather+0x5b4>)
34199eec:	701a      	strb	r2, [r3, #0]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
34199eee:	4b11      	ldr	r3, [pc, #68]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ef0:	781a      	ldrb	r2, [r3, #0]
34199ef2:	4b11      	ldr	r3, [pc, #68]	@ (34199f38 <ISP_SVC_Stats_Gather+0x5bc>)
34199ef4:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
34199ef6:	4b0f      	ldr	r3, [pc, #60]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199ef8:	781b      	ldrb	r3, [r3, #0]
34199efa:	4618      	mov	r0, r3
34199efc:	f7fe fcae 	bl	3419885c <GetNextStatStage>
34199f00:	4603      	mov	r3, r0
34199f02:	461a      	mov	r2, r3
34199f04:	4b0b      	ldr	r3, [pc, #44]	@ (34199f34 <ISP_SVC_Stats_Gather+0x5b8>)
34199f06:	701a      	strb	r2, [r3, #0]
34199f08:	e000      	b.n	34199f0c <ISP_SVC_Stats_Gather+0x590>
    return;
34199f0a:	bf00      	nop
}
34199f0c:	3748      	adds	r7, #72	@ 0x48
34199f0e:	46bd      	mov	sp, r7
34199f10:	bdb0      	pop	{r4, r5, r7, pc}
34199f12:	bf00      	nop
34199f14:	341b0f0c 	.word	0x341b0f0c
34199f18:	341b0f48 	.word	0x341b0f48
34199f1c:	341b0f54 	.word	0x341b0f54
34199f20:	341b0f60 	.word	0x341b0f60
34199f24:	341b0f6c 	.word	0x341b0f6c
34199f28:	341a5ed8 	.word	0x341a5ed8
34199f2c:	341a5f08 	.word	0x341a5f08
34199f30:	341c00f5 	.word	0x341c00f5
34199f34:	341c16b4 	.word	0x341c16b4
34199f38:	341c00f6 	.word	0x341c00f6

34199f3c <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
34199f3c:	b580      	push	{r7, lr}
34199f3e:	b088      	sub	sp, #32
34199f40:	af00      	add	r7, sp, #0
34199f42:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
34199f44:	2300      	movs	r3, #0
34199f46:	77fb      	strb	r3, [r7, #31]

  pLastStat = &ISP_SVC_StatEngine.last;
34199f48:	4b2e      	ldr	r3, [pc, #184]	@ (3419a004 <ISP_SVC_Stats_ProcessCallbacks+0xc8>)
34199f4a:	617b      	str	r3, [r7, #20]

  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34199f4c:	2300      	movs	r3, #0
34199f4e:	61bb      	str	r3, [r7, #24]
34199f50:	e04f      	b.n	34199ff2 <ISP_SVC_Stats_ProcessCallbacks+0xb6>
  {
    client = &ISP_SVC_StatEngine.client[i];
34199f52:	69ba      	ldr	r2, [r7, #24]
34199f54:	4613      	mov	r3, r2
34199f56:	009b      	lsls	r3, r3, #2
34199f58:	4413      	add	r3, r2
34199f5a:	009b      	lsls	r3, r3, #2
34199f5c:	33f0      	adds	r3, #240	@ 0xf0
34199f5e:	4a2a      	ldr	r2, [pc, #168]	@ (3419a008 <ISP_SVC_Stats_ProcessCallbacks+0xcc>)
34199f60:	4413      	add	r3, r2
34199f62:	3304      	adds	r3, #4
34199f64:	613b      	str	r3, [r7, #16]

    if (client->callback == NULL)
34199f66:	693b      	ldr	r3, [r7, #16]
34199f68:	681b      	ldr	r3, [r3, #0]
34199f6a:	2b00      	cmp	r3, #0
34199f6c:	d03d      	beq.n	34199fea <ISP_SVC_Stats_ProcessCallbacks+0xae>
      continue;

    /* Check if stats are available for a client, comparing the location and the specified frameId */
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
34199f6e:	693b      	ldr	r3, [r7, #16]
34199f70:	7c1b      	ldrb	r3, [r3, #16]
34199f72:	2b02      	cmp	r3, #2
34199f74:	d105      	bne.n	34199f82 <ISP_SVC_Stats_ProcessCallbacks+0x46>
34199f76:	693b      	ldr	r3, [r7, #16]
34199f78:	68da      	ldr	r2, [r3, #12]
34199f7a:	697b      	ldr	r3, [r7, #20]
34199f7c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34199f7e:	429a      	cmp	r2, r3
34199f80:	d919      	bls.n	34199fb6 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
34199f82:	693b      	ldr	r3, [r7, #16]
34199f84:	7c1b      	ldrb	r3, [r3, #16]
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
34199f86:	2b01      	cmp	r3, #1
34199f88:	d105      	bne.n	34199f96 <ISP_SVC_Stats_ProcessCallbacks+0x5a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
34199f8a:	693b      	ldr	r3, [r7, #16]
34199f8c:	68da      	ldr	r2, [r3, #12]
34199f8e:	697b      	ldr	r3, [r7, #20]
34199f90:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34199f92:	429a      	cmp	r2, r3
34199f94:	d90f      	bls.n	34199fb6 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34199f96:	693b      	ldr	r3, [r7, #16]
34199f98:	7c1b      	ldrb	r3, [r3, #16]
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
34199f9a:	2b03      	cmp	r3, #3
34199f9c:	d126      	bne.n	34199fec <ISP_SVC_Stats_ProcessCallbacks+0xb0>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
34199f9e:	693b      	ldr	r3, [r7, #16]
34199fa0:	68da      	ldr	r2, [r3, #12]
34199fa2:	697b      	ldr	r3, [r7, #20]
34199fa4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34199fa6:	429a      	cmp	r2, r3
34199fa8:	d820      	bhi.n	34199fec <ISP_SVC_Stats_ProcessCallbacks+0xb0>
34199faa:	693b      	ldr	r3, [r7, #16]
34199fac:	68da      	ldr	r2, [r3, #12]
34199fae:	697b      	ldr	r3, [r7, #20]
34199fb0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34199fb2:	429a      	cmp	r2, r3
34199fb4:	d81a      	bhi.n	34199fec <ISP_SVC_Stats_ProcessCallbacks+0xb0>
    {
      /* Copy the stats into the client buffer */
      *(client->pStats) = *pLastStat;
34199fb6:	693b      	ldr	r3, [r7, #16]
34199fb8:	689a      	ldr	r2, [r3, #8]
34199fba:	697b      	ldr	r3, [r7, #20]
34199fbc:	4610      	mov	r0, r2
34199fbe:	4619      	mov	r1, r3
34199fc0:	2378      	movs	r3, #120	@ 0x78
34199fc2:	461a      	mov	r2, r3
34199fc4:	f009 ff69 	bl	341a3e9a <memcpy>

      /* Call its callback */
      retcb = client->callback(client->pAlgo);
34199fc8:	693b      	ldr	r3, [r7, #16]
34199fca:	681b      	ldr	r3, [r3, #0]
34199fcc:	693a      	ldr	r2, [r7, #16]
34199fce:	6852      	ldr	r2, [r2, #4]
34199fd0:	4610      	mov	r0, r2
34199fd2:	4798      	blx	r3
34199fd4:	4603      	mov	r3, r0
34199fd6:	73fb      	strb	r3, [r7, #15]
      if (retcb != ISP_OK)
34199fd8:	7bfb      	ldrb	r3, [r7, #15]
34199fda:	2b00      	cmp	r3, #0
34199fdc:	d001      	beq.n	34199fe2 <ISP_SVC_Stats_ProcessCallbacks+0xa6>
      {
        ret = retcb;
34199fde:	7bfb      	ldrb	r3, [r7, #15]
34199fe0:	77fb      	strb	r3, [r7, #31]
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
34199fe2:	693b      	ldr	r3, [r7, #16]
34199fe4:	2200      	movs	r2, #0
34199fe6:	601a      	str	r2, [r3, #0]
34199fe8:	e000      	b.n	34199fec <ISP_SVC_Stats_ProcessCallbacks+0xb0>
      continue;
34199fea:	bf00      	nop
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34199fec:	69bb      	ldr	r3, [r7, #24]
34199fee:	3301      	adds	r3, #1
34199ff0:	61bb      	str	r3, [r7, #24]
34199ff2:	69bb      	ldr	r3, [r7, #24]
34199ff4:	2b04      	cmp	r3, #4
34199ff6:	d9ac      	bls.n	34199f52 <ISP_SVC_Stats_ProcessCallbacks+0x16>
    }
  }

  return ret;
34199ff8:	7ffb      	ldrb	r3, [r7, #31]
}
34199ffa:	4618      	mov	r0, r3
34199ffc:	3720      	adds	r7, #32
34199ffe:	46bd      	mov	sp, r7
3419a000:	bd80      	pop	{r7, pc}
3419a002:	bf00      	nop
3419a004:	341c16b8 	.word	0x341c16b8
3419a008:	341c16b4 	.word	0x341c16b4

3419a00c <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
3419a00c:	b580      	push	{r7, lr}
3419a00e:	b086      	sub	sp, #24
3419a010:	af00      	add	r7, sp, #0
3419a012:	60f8      	str	r0, [r7, #12]
3419a014:	60b9      	str	r1, [r7, #8]
3419a016:	607a      	str	r2, [r7, #4]
3419a018:	603b      	str	r3, [r7, #0]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
3419a01a:	68fb      	ldr	r3, [r7, #12]
3419a01c:	2b00      	cmp	r3, #0
3419a01e:	d002      	beq.n	3419a026 <ISP_SVC_Stats_GetNext+0x1a>
3419a020:	683b      	ldr	r3, [r7, #0]
3419a022:	2b00      	cmp	r3, #0
3419a024:	d101      	bne.n	3419a02a <ISP_SVC_Stats_GetNext+0x1e>
  {
    return ISP_ERR_EINVAL;
3419a026:	2301      	movs	r3, #1
3419a028:	e08f      	b.n	3419a14a <ISP_SVC_Stats_GetNext+0x13e>
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
3419a02a:	68f8      	ldr	r0, [r7, #12]
3419a02c:	f7ff fbc3 	bl	341997b6 <ISP_SVC_Misc_GetMainFrameId>
3419a030:	4602      	mov	r2, r0
3419a032:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419a034:	4413      	add	r3, r2
3419a036:	613b      	str	r3, [r7, #16]

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419a038:	2300      	movs	r3, #0
3419a03a:	617b      	str	r3, [r7, #20]
3419a03c:	e00d      	b.n	3419a05a <ISP_SVC_Stats_GetNext+0x4e>
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
3419a03e:	4945      	ldr	r1, [pc, #276]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a040:	697a      	ldr	r2, [r7, #20]
3419a042:	4613      	mov	r3, r2
3419a044:	009b      	lsls	r3, r3, #2
3419a046:	4413      	add	r3, r2
3419a048:	009b      	lsls	r3, r3, #2
3419a04a:	440b      	add	r3, r1
3419a04c:	33f4      	adds	r3, #244	@ 0xf4
3419a04e:	681b      	ldr	r3, [r3, #0]
3419a050:	2b00      	cmp	r3, #0
3419a052:	d006      	beq.n	3419a062 <ISP_SVC_Stats_GetNext+0x56>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419a054:	697b      	ldr	r3, [r7, #20]
3419a056:	3301      	adds	r3, #1
3419a058:	617b      	str	r3, [r7, #20]
3419a05a:	697b      	ldr	r3, [r7, #20]
3419a05c:	2b04      	cmp	r3, #4
3419a05e:	d9ee      	bls.n	3419a03e <ISP_SVC_Stats_GetNext+0x32>
3419a060:	e000      	b.n	3419a064 <ISP_SVC_Stats_GetNext+0x58>
      break;
3419a062:	bf00      	nop
  }

  if (i == ISP_SVC_STAT_MAX_CB)
3419a064:	697b      	ldr	r3, [r7, #20]
3419a066:	2b05      	cmp	r3, #5
3419a068:	d101      	bne.n	3419a06e <ISP_SVC_Stats_GetNext+0x62>
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
3419a06a:	23ac      	movs	r3, #172	@ 0xac
3419a06c:	e06d      	b.n	3419a14a <ISP_SVC_Stats_GetNext+0x13e>
  }

  /* Add this requested stat to the list of requested stats */
  if (location & ISP_STAT_LOC_UP)
3419a06e:	f897 3020 	ldrb.w	r3, [r7, #32]
3419a072:	f003 0301 	and.w	r3, r3, #1
3419a076:	2b00      	cmp	r3, #0
3419a078:	d009      	beq.n	3419a08e <ISP_SVC_Stats_GetNext+0x82>
  {
    ISP_SVC_StatEngine.upRequest |= type;
3419a07a:	4b36      	ldr	r3, [pc, #216]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a07c:	f893 2158 	ldrb.w	r2, [r3, #344]	@ 0x158
3419a080:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419a084:	4313      	orrs	r3, r2
3419a086:	b2da      	uxtb	r2, r3
3419a088:	4b32      	ldr	r3, [pc, #200]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a08a:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
  }
  if (location & ISP_STAT_LOC_DOWN)
3419a08e:	f897 3020 	ldrb.w	r3, [r7, #32]
3419a092:	f003 0302 	and.w	r3, r3, #2
3419a096:	2b00      	cmp	r3, #0
3419a098:	d009      	beq.n	3419a0ae <ISP_SVC_Stats_GetNext+0xa2>
  {
    ISP_SVC_StatEngine.downRequest |= type;
3419a09a:	4b2e      	ldr	r3, [pc, #184]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a09c:	f893 2159 	ldrb.w	r2, [r3, #345]	@ 0x159
3419a0a0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419a0a4:	4313      	orrs	r3, r2
3419a0a6:	b2da      	uxtb	r2, r3
3419a0a8:	4b2a      	ldr	r3, [pc, #168]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a0aa:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  if (type == ISP_STAT_TYPE_ALL_TMP)
3419a0ae:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419a0b2:	2b04      	cmp	r3, #4
3419a0b4:	d107      	bne.n	3419a0c6 <ISP_SVC_Stats_GetNext+0xba>
  {
    /* Special case: request all stats for a short time (3 cycle) */
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
3419a0b6:	68f8      	ldr	r0, [r7, #12]
3419a0b8:	f7ff fb7d 	bl	341997b6 <ISP_SVC_Misc_GetMainFrameId>
3419a0bc:	4603      	mov	r3, r0
3419a0be:	331e      	adds	r3, #30
3419a0c0:	4a24      	ldr	r2, [pc, #144]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a0c2:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  }

  /* Register client */
  ISP_SVC_StatEngine.client[i].callback = callback;
3419a0c6:	4923      	ldr	r1, [pc, #140]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a0c8:	697a      	ldr	r2, [r7, #20]
3419a0ca:	4613      	mov	r3, r2
3419a0cc:	009b      	lsls	r3, r3, #2
3419a0ce:	4413      	add	r3, r2
3419a0d0:	009b      	lsls	r3, r3, #2
3419a0d2:	440b      	add	r3, r1
3419a0d4:	33f4      	adds	r3, #244	@ 0xf4
3419a0d6:	68ba      	ldr	r2, [r7, #8]
3419a0d8:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
3419a0da:	491e      	ldr	r1, [pc, #120]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a0dc:	697a      	ldr	r2, [r7, #20]
3419a0de:	4613      	mov	r3, r2
3419a0e0:	009b      	lsls	r3, r3, #2
3419a0e2:	4413      	add	r3, r2
3419a0e4:	009b      	lsls	r3, r3, #2
3419a0e6:	440b      	add	r3, r1
3419a0e8:	33f8      	adds	r3, #248	@ 0xf8
3419a0ea:	687a      	ldr	r2, [r7, #4]
3419a0ec:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pStats = pStats;
3419a0ee:	4919      	ldr	r1, [pc, #100]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a0f0:	697a      	ldr	r2, [r7, #20]
3419a0f2:	4613      	mov	r3, r2
3419a0f4:	009b      	lsls	r3, r3, #2
3419a0f6:	4413      	add	r3, r2
3419a0f8:	009b      	lsls	r3, r3, #2
3419a0fa:	440b      	add	r3, r1
3419a0fc:	33fc      	adds	r3, #252	@ 0xfc
3419a0fe:	683a      	ldr	r2, [r7, #0]
3419a100:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].location = location;
3419a102:	4914      	ldr	r1, [pc, #80]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a104:	697a      	ldr	r2, [r7, #20]
3419a106:	4613      	mov	r3, r2
3419a108:	009b      	lsls	r3, r3, #2
3419a10a:	4413      	add	r3, r2
3419a10c:	009b      	lsls	r3, r3, #2
3419a10e:	440b      	add	r3, r1
3419a110:	f503 7382 	add.w	r3, r3, #260	@ 0x104
3419a114:	f897 2020 	ldrb.w	r2, [r7, #32]
3419a118:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].type = type;
3419a11a:	490e      	ldr	r1, [pc, #56]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a11c:	697a      	ldr	r2, [r7, #20]
3419a11e:	4613      	mov	r3, r2
3419a120:	009b      	lsls	r3, r3, #2
3419a122:	4413      	add	r3, r2
3419a124:	009b      	lsls	r3, r3, #2
3419a126:	440b      	add	r3, r1
3419a128:	f203 1305 	addw	r3, r3, #261	@ 0x105
3419a12c:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
3419a130:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
3419a132:	4908      	ldr	r1, [pc, #32]	@ (3419a154 <ISP_SVC_Stats_GetNext+0x148>)
3419a134:	697a      	ldr	r2, [r7, #20]
3419a136:	4613      	mov	r3, r2
3419a138:	009b      	lsls	r3, r3, #2
3419a13a:	4413      	add	r3, r2
3419a13c:	009b      	lsls	r3, r3, #2
3419a13e:	440b      	add	r3, r1
3419a140:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3419a144:	693a      	ldr	r2, [r7, #16]
3419a146:	601a      	str	r2, [r3, #0]

  return ISP_OK;
3419a148:	2300      	movs	r3, #0
}
3419a14a:	4618      	mov	r0, r3
3419a14c:	3718      	adds	r7, #24
3419a14e:	46bd      	mov	sp, r7
3419a150:	bd80      	pop	{r7, pc}
3419a152:	bf00      	nop
3419a154:	341c16b4 	.word	0x341c16b4

3419a158 <LL_AHB4_GRP1_EnableClock>:
{
3419a158:	b480      	push	{r7}
3419a15a:	b085      	sub	sp, #20
3419a15c:	af00      	add	r7, sp, #0
3419a15e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3419a160:	4a07      	ldr	r2, [pc, #28]	@ (3419a180 <LL_AHB4_GRP1_EnableClock+0x28>)
3419a162:	687b      	ldr	r3, [r7, #4]
3419a164:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3419a168:	4b05      	ldr	r3, [pc, #20]	@ (3419a180 <LL_AHB4_GRP1_EnableClock+0x28>)
3419a16a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3419a16e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3419a170:	68fb      	ldr	r3, [r7, #12]
}
3419a172:	bf00      	nop
3419a174:	3714      	adds	r7, #20
3419a176:	46bd      	mov	sp, r7
3419a178:	f85d 7b04 	ldr.w	r7, [sp], #4
3419a17c:	4770      	bx	lr
3419a17e:	bf00      	nop
3419a180:	56028000 	.word	0x56028000

3419a184 <CMW_CAMERA_SetPipeConfig>:
{
    return &hcamera_dcmipp;
}

int32_t CMW_CAMERA_SetPipeConfig(uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3419a184:	b580      	push	{r7, lr}
3419a186:	b084      	sub	sp, #16
3419a188:	af00      	add	r7, sp, #0
3419a18a:	60f8      	str	r0, [r7, #12]
3419a18c:	60b9      	str	r1, [r7, #8]
3419a18e:	607a      	str	r2, [r7, #4]
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
3419a190:	687b      	ldr	r3, [r7, #4]
3419a192:	68ba      	ldr	r2, [r7, #8]
3419a194:	68f9      	ldr	r1, [r7, #12]
3419a196:	4804      	ldr	r0, [pc, #16]	@ (3419a1a8 <CMW_CAMERA_SetPipeConfig+0x24>)
3419a198:	f000 fd06 	bl	3419aba8 <CMW_CAMERA_SetPipe>
3419a19c:	4603      	mov	r3, r0
}
3419a19e:	4618      	mov	r0, r3
3419a1a0:	3710      	adds	r7, #16
3419a1a2:	46bd      	mov	sp, r7
3419a1a4:	bd80      	pop	{r7, pc}
3419a1a6:	bf00      	nop
3419a1a8:	341c1870 	.word	0x341c1870

3419a1ac <CMW_CAMERA_Probe_Sensor>:
  * @param  initValues  Initialization values for the sensor
  * @param  sensorName  Camera sensor name
  * @retval CMW status
  */
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
{
3419a1ac:	b580      	push	{r7, lr}
3419a1ae:	b084      	sub	sp, #16
3419a1b0:	af00      	add	r7, sp, #0
3419a1b2:	6078      	str	r0, [r7, #4]
3419a1b4:	6039      	str	r1, [r7, #0]
  int ret;
#if defined(USE_VD55G1_SENSOR)
  ret = CMW_CAMERA_VD55G1_Init(initValues);
3419a1b6:	6878      	ldr	r0, [r7, #4]
3419a1b8:	f000 fa38 	bl	3419a62c <CMW_CAMERA_VD55G1_Init>
3419a1bc:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419a1be:	68fb      	ldr	r3, [r7, #12]
3419a1c0:	2b00      	cmp	r3, #0
3419a1c2:	d104      	bne.n	3419a1ce <CMW_CAMERA_Probe_Sensor+0x22>
  {
    *sensorName = CMW_VD55G1_Sensor;
3419a1c4:	683b      	ldr	r3, [r7, #0]
3419a1c6:	2203      	movs	r2, #3
3419a1c8:	701a      	strb	r2, [r3, #0]
    return ret;
3419a1ca:	68fb      	ldr	r3, [r7, #12]
3419a1cc:	e019      	b.n	3419a202 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
#if defined(USE_VD66GY_SENSOR)
  ret = CMW_CAMERA_VD66GY_Init(initValues);
3419a1ce:	6878      	ldr	r0, [r7, #4]
3419a1d0:	f000 faf2 	bl	3419a7b8 <CMW_CAMERA_VD66GY_Init>
3419a1d4:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419a1d6:	68fb      	ldr	r3, [r7, #12]
3419a1d8:	2b00      	cmp	r3, #0
3419a1da:	d104      	bne.n	3419a1e6 <CMW_CAMERA_Probe_Sensor+0x3a>
  {
    *sensorName = CMW_VD66GY_Sensor;
3419a1dc:	683b      	ldr	r3, [r7, #0]
3419a1de:	2201      	movs	r2, #1
3419a1e0:	701a      	strb	r2, [r3, #0]
    return ret;
3419a1e2:	68fb      	ldr	r3, [r7, #12]
3419a1e4:	e00d      	b.n	3419a202 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
#if defined(USE_IMX335_SENSOR)
  ret = CMW_CAMERA_IMX335_Init(initValues);
3419a1e6:	6878      	ldr	r0, [r7, #4]
3419a1e8:	f000 fbd2 	bl	3419a990 <CMW_CAMERA_IMX335_Init>
3419a1ec:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419a1ee:	68fb      	ldr	r3, [r7, #12]
3419a1f0:	2b00      	cmp	r3, #0
3419a1f2:	d104      	bne.n	3419a1fe <CMW_CAMERA_Probe_Sensor+0x52>
  {
    *sensorName = CMW_IMX335_Sensor;
3419a1f4:	683b      	ldr	r3, [r7, #0]
3419a1f6:	2202      	movs	r2, #2
3419a1f8:	701a      	strb	r2, [r3, #0]
    return ret;
3419a1fa:	68fb      	ldr	r3, [r7, #12]
3419a1fc:	e001      	b.n	3419a202 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
  else
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419a1fe:	f06f 0306 	mvn.w	r3, #6
  }
}
3419a202:	4618      	mov	r0, r3
3419a204:	3710      	adds	r7, #16
3419a206:	46bd      	mov	sp, r7
3419a208:	bd80      	pop	{r7, pc}
	...

3419a20c <CMW_CAMERA_Init>:
  * @param  initConf  Mandatory: General camera config
  * @param  sensor_config  Optional: Sensor specific configuration
  * @retval CMW status
  */
int32_t CMW_CAMERA_Init(CMW_CameraInit_t *initConf, CMW_Sensor_Config_t *sensor_config)
{
3419a20c:	b5b0      	push	{r4, r5, r7, lr}
3419a20e:	b098      	sub	sp, #96	@ 0x60
3419a210:	af00      	add	r7, sp, #0
3419a212:	6078      	str	r0, [r7, #4]
3419a214:	6039      	str	r1, [r7, #0]
  int32_t ret = CMW_ERROR_NONE;
3419a216:	2300      	movs	r3, #0
3419a218:	65fb      	str	r3, [r7, #92]	@ 0x5c
  CMW_Sensor_Init_t initValues = {0};
3419a21a:	f107 0344 	add.w	r3, r7, #68	@ 0x44
3419a21e:	2200      	movs	r2, #0
3419a220:	601a      	str	r2, [r3, #0]
3419a222:	605a      	str	r2, [r3, #4]
3419a224:	609a      	str	r2, [r3, #8]
3419a226:	60da      	str	r2, [r3, #12]
3419a228:	611a      	str	r2, [r3, #16]
3419a22a:	615a      	str	r2, [r3, #20]
  ISP_SensorInfoTypeDef info = {0};
3419a22c:	f107 0308 	add.w	r3, r7, #8
3419a230:	223c      	movs	r2, #60	@ 0x3c
3419a232:	2100      	movs	r1, #0
3419a234:	4618      	mov	r0, r3
3419a236:	f009 fdb5 	bl	341a3da4 <memset>

  initValues.width = initConf->width;
3419a23a:	687b      	ldr	r3, [r7, #4]
3419a23c:	681b      	ldr	r3, [r3, #0]
3419a23e:	647b      	str	r3, [r7, #68]	@ 0x44
  initValues.height = initConf->height;
3419a240:	687b      	ldr	r3, [r7, #4]
3419a242:	685b      	ldr	r3, [r3, #4]
3419a244:	64bb      	str	r3, [r7, #72]	@ 0x48
  initValues.fps = initConf->fps;
3419a246:	687b      	ldr	r3, [r7, #4]
3419a248:	689b      	ldr	r3, [r3, #8]
3419a24a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  initValues.pixel_format = initConf->pixel_format;
3419a24c:	687b      	ldr	r3, [r7, #4]
3419a24e:	68db      	ldr	r3, [r3, #12]
3419a250:	653b      	str	r3, [r7, #80]	@ 0x50
  initValues.mirrorFlip = initConf->mirror_flip;
3419a252:	687b      	ldr	r3, [r7, #4]
3419a254:	695b      	ldr	r3, [r3, #20]
3419a256:	657b      	str	r3, [r7, #84]	@ 0x54

  if ((sensor_config != NULL) && (sensor_config->selected_sensor != CMW_NOTKNOWN_Sensor))
3419a258:	683b      	ldr	r3, [r7, #0]
3419a25a:	2b00      	cmp	r3, #0
3419a25c:	d00b      	beq.n	3419a276 <CMW_CAMERA_Init+0x6a>
3419a25e:	683b      	ldr	r3, [r7, #0]
3419a260:	781b      	ldrb	r3, [r3, #0]
3419a262:	2b00      	cmp	r3, #0
3419a264:	d007      	beq.n	3419a276 <CMW_CAMERA_Init+0x6a>
  {
    connected_sensor = sensor_config->selected_sensor; // Assume The sensor is the one selected by the application. Check during probe
3419a266:	683b      	ldr	r3, [r7, #0]
3419a268:	781a      	ldrb	r2, [r3, #0]
3419a26a:	4b3a      	ldr	r3, [pc, #232]	@ (3419a354 <CMW_CAMERA_Init+0x148>)
3419a26c:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = (void *) &sensor_config->config;
3419a26e:	683b      	ldr	r3, [r7, #0]
3419a270:	3304      	adds	r3, #4
3419a272:	65bb      	str	r3, [r7, #88]	@ 0x58
3419a274:	e004      	b.n	3419a280 <CMW_CAMERA_Init+0x74>
  }
  else
  {
    connected_sensor = CMW_NOTKNOWN_Sensor;
3419a276:	4b37      	ldr	r3, [pc, #220]	@ (3419a354 <CMW_CAMERA_Init+0x148>)
3419a278:	2200      	movs	r2, #0
3419a27a:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = NULL;
3419a27c:	2300      	movs	r3, #0
3419a27e:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Set DCMIPP instance */
  hcamera_dcmipp.Instance = DCMIPP;
3419a280:	4b35      	ldr	r3, [pc, #212]	@ (3419a358 <CMW_CAMERA_Init+0x14c>)
3419a282:	4a36      	ldr	r2, [pc, #216]	@ (3419a35c <CMW_CAMERA_Init+0x150>)
3419a284:	601a      	str	r2, [r3, #0]

  /* Configure DCMIPP clock */
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
3419a286:	4834      	ldr	r0, [pc, #208]	@ (3419a358 <CMW_CAMERA_Init+0x14c>)
3419a288:	f000 f86e 	bl	3419a368 <MX_DCMIPP_ClockConfig>
3419a28c:	4603      	mov	r3, r0
3419a28e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3419a290:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a292:	2b00      	cmp	r3, #0
3419a294:	d002      	beq.n	3419a29c <CMW_CAMERA_Init+0x90>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a296:	f06f 0303 	mvn.w	r3, #3
3419a29a:	e056      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }
  /* Enable DCMIPP clock */
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
3419a29c:	482e      	ldr	r0, [pc, #184]	@ (3419a358 <CMW_CAMERA_Init+0x14c>)
3419a29e:	f7eb f9ff 	bl	341856a0 <HAL_DCMIPP_Init>
3419a2a2:	4603      	mov	r3, r0
3419a2a4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3419a2a6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a2a8:	2b00      	cmp	r3, #0
3419a2aa:	d002      	beq.n	3419a2b2 <CMW_CAMERA_Init+0xa6>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a2ac:	f06f 0303 	mvn.w	r3, #3
3419a2b0:	e04b      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }

  CMW_CAMERA_EnableGPIOs();
3419a2b2:	f000 f8f5 	bl	3419a4a0 <CMW_CAMERA_EnableGPIOs>

  ret = CMW_CAMERA_Probe_Sensor(&initValues, &connected_sensor);
3419a2b6:	f107 0344 	add.w	r3, r7, #68	@ 0x44
3419a2ba:	4926      	ldr	r1, [pc, #152]	@ (3419a354 <CMW_CAMERA_Init+0x148>)
3419a2bc:	4618      	mov	r0, r3
3419a2be:	f7ff ff75 	bl	3419a1ac <CMW_CAMERA_Probe_Sensor>
3419a2c2:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret != CMW_ERROR_NONE)
3419a2c4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a2c6:	2b00      	cmp	r3, #0
3419a2c8:	d002      	beq.n	3419a2d0 <CMW_CAMERA_Init+0xc4>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419a2ca:	f06f 0306 	mvn.w	r3, #6
3419a2ce:	e03c      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }

  /* Configure exposure and gain for a more suitable quality */
  ret = CMW_CAMERA_GetSensorInfo(&info);
3419a2d0:	f107 0308 	add.w	r3, r7, #8
3419a2d4:	4618      	mov	r0, r3
3419a2d6:	f000 f8c3 	bl	3419a460 <CMW_CAMERA_GetSensorInfo>
3419a2da:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419a2dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a2de:	f113 0f05 	cmn.w	r3, #5
3419a2e2:	d102      	bne.n	3419a2ea <CMW_CAMERA_Init+0xde>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419a2e4:	f06f 0306 	mvn.w	r3, #6
3419a2e8:	e02f      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
3419a2ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419a2ec:	4618      	mov	r0, r3
3419a2ee:	f000 f87f 	bl	3419a3f0 <CMW_CAMERA_SetExposure>
3419a2f2:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419a2f4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a2f6:	f113 0f05 	cmn.w	r3, #5
3419a2fa:	d102      	bne.n	3419a302 <CMW_CAMERA_Init+0xf6>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419a2fc:	f06f 0306 	mvn.w	r3, #6
3419a300:	e023      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }
  ret = CMW_CAMERA_SetGain(info.gain_min);
3419a302:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419a304:	4618      	mov	r0, r3
3419a306:	f000 f83b 	bl	3419a380 <CMW_CAMERA_SetGain>
3419a30a:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419a30c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419a30e:	f113 0f05 	cmn.w	r3, #5
3419a312:	d102      	bne.n	3419a31a <CMW_CAMERA_Init+0x10e>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419a314:	f06f 0306 	mvn.w	r3, #6
3419a318:	e017      	b.n	3419a34a <CMW_CAMERA_Init+0x13e>
  }

  /* Write back the initValue width and height that might be changed */
  initConf->width = initValues.width;
3419a31a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419a31c:	687b      	ldr	r3, [r7, #4]
3419a31e:	601a      	str	r2, [r3, #0]
  initConf->height = initValues.height ;
3419a320:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419a322:	687b      	ldr	r3, [r7, #4]
3419a324:	605a      	str	r2, [r3, #4]
  camera_conf = *initConf;
3419a326:	4a0e      	ldr	r2, [pc, #56]	@ (3419a360 <CMW_CAMERA_Init+0x154>)
3419a328:	687b      	ldr	r3, [r7, #4]
3419a32a:	4614      	mov	r4, r2
3419a32c:	461d      	mov	r5, r3
3419a32e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419a330:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419a332:	e895 0003 	ldmia.w	r5, {r0, r1}
3419a336:	e884 0003 	stmia.w	r4, {r0, r1}

  is_camera_init++;
3419a33a:	4b0a      	ldr	r3, [pc, #40]	@ (3419a364 <CMW_CAMERA_Init+0x158>)
3419a33c:	681b      	ldr	r3, [r3, #0]
3419a33e:	3301      	adds	r3, #1
3419a340:	4a08      	ldr	r2, [pc, #32]	@ (3419a364 <CMW_CAMERA_Init+0x158>)
3419a342:	6013      	str	r3, [r2, #0]
  /* CMW status */
  ret = CMW_ERROR_NONE;
3419a344:	2300      	movs	r3, #0
3419a346:	65fb      	str	r3, [r7, #92]	@ 0x5c
  return ret;
3419a348:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
3419a34a:	4618      	mov	r0, r3
3419a34c:	3760      	adds	r7, #96	@ 0x60
3419a34e:	46bd      	mov	sp, r7
3419a350:	bdb0      	pop	{r4, r5, r7, pc}
3419a352:	bf00      	nop
3419a354:	341c182c 	.word	0x341c182c
3419a358:	341c1870 	.word	0x341c1870
3419a35c:	58002000 	.word	0x58002000
3419a360:	341c1814 	.word	0x341c1814
3419a364:	341c1a24 	.word	0x341c1a24

3419a368 <MX_DCMIPP_ClockConfig>:
  * @param  hdcmipp  DCMIPP Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_DCMIPP_ClockConfig(DCMIPP_HandleTypeDef *hdcmipp)
{
3419a368:	b480      	push	{r7}
3419a36a:	b083      	sub	sp, #12
3419a36c:	af00      	add	r7, sp, #0
3419a36e:	6078      	str	r0, [r7, #4]
  UNUSED(hdcmipp);

  return HAL_OK;
3419a370:	2300      	movs	r3, #0
}
3419a372:	4618      	mov	r0, r3
3419a374:	370c      	adds	r7, #12
3419a376:	46bd      	mov	sp, r7
3419a378:	f85d 7b04 	ldr.w	r7, [sp], #4
3419a37c:	4770      	bx	lr
	...

3419a380 <CMW_CAMERA_SetGain>:
  * @brief  Set the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_SetGain(int32_t Gain)
{
3419a380:	b580      	push	{r7, lr}
3419a382:	b084      	sub	sp, #16
3419a384:	af00      	add	r7, sp, #0
3419a386:	6078      	str	r0, [r7, #4]
  int ret;
  if(Camera_Drv.SetGain == NULL)
3419a388:	4b0d      	ldr	r3, [pc, #52]	@ (3419a3c0 <CMW_CAMERA_SetGain+0x40>)
3419a38a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419a38c:	2b00      	cmp	r3, #0
3419a38e:	d102      	bne.n	3419a396 <CMW_CAMERA_SetGain+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419a390:	f06f 030a 	mvn.w	r3, #10
3419a394:	e00f      	b.n	3419a3b6 <CMW_CAMERA_SetGain+0x36>
  }

  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
3419a396:	4b0a      	ldr	r3, [pc, #40]	@ (3419a3c0 <CMW_CAMERA_SetGain+0x40>)
3419a398:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419a39a:	6879      	ldr	r1, [r7, #4]
3419a39c:	4809      	ldr	r0, [pc, #36]	@ (3419a3c4 <CMW_CAMERA_SetGain+0x44>)
3419a39e:	4798      	blx	r3
3419a3a0:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419a3a2:	68fb      	ldr	r3, [r7, #12]
3419a3a4:	2b00      	cmp	r3, #0
3419a3a6:	d002      	beq.n	3419a3ae <CMW_CAMERA_SetGain+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a3a8:	f06f 0304 	mvn.w	r3, #4
3419a3ac:	e003      	b.n	3419a3b6 <CMW_CAMERA_SetGain+0x36>
  }

  Camera_Ctx.Gain = Gain;
3419a3ae:	4a06      	ldr	r2, [pc, #24]	@ (3419a3c8 <CMW_CAMERA_SetGain+0x48>)
3419a3b0:	687b      	ldr	r3, [r7, #4]
3419a3b2:	6213      	str	r3, [r2, #32]
  return CMW_ERROR_NONE;
3419a3b4:	2300      	movs	r3, #0
}
3419a3b6:	4618      	mov	r0, r3
3419a3b8:	3710      	adds	r7, #16
3419a3ba:	46bd      	mov	sp, r7
3419a3bc:	bd80      	pop	{r7, pc}
3419a3be:	bf00      	nop
3419a3c0:	341c187c 	.word	0x341c187c
3419a3c4:	341c18e4 	.word	0x341c18e4
3419a3c8:	341c1830 	.word	0x341c1830

3419a3cc <CMW_CAMERA_GetGain>:
  * @brief  Get the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
3419a3cc:	b480      	push	{r7}
3419a3ce:	b083      	sub	sp, #12
3419a3d0:	af00      	add	r7, sp, #0
3419a3d2:	6078      	str	r0, [r7, #4]
  *Gain = Camera_Ctx.Gain;
3419a3d4:	4b05      	ldr	r3, [pc, #20]	@ (3419a3ec <CMW_CAMERA_GetGain+0x20>)
3419a3d6:	6a1a      	ldr	r2, [r3, #32]
3419a3d8:	687b      	ldr	r3, [r7, #4]
3419a3da:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3419a3dc:	2300      	movs	r3, #0
}
3419a3de:	4618      	mov	r0, r3
3419a3e0:	370c      	adds	r7, #12
3419a3e2:	46bd      	mov	sp, r7
3419a3e4:	f85d 7b04 	ldr.w	r7, [sp], #4
3419a3e8:	4770      	bx	lr
3419a3ea:	bf00      	nop
3419a3ec:	341c1830 	.word	0x341c1830

3419a3f0 <CMW_CAMERA_SetExposure>:
  * @brief  Set the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_SetExposure(int32_t exposure)
{
3419a3f0:	b580      	push	{r7, lr}
3419a3f2:	b084      	sub	sp, #16
3419a3f4:	af00      	add	r7, sp, #0
3419a3f6:	6078      	str	r0, [r7, #4]
  int ret;

  if(Camera_Drv.SetExposure == NULL)
3419a3f8:	4b0d      	ldr	r3, [pc, #52]	@ (3419a430 <CMW_CAMERA_SetExposure+0x40>)
3419a3fa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419a3fc:	2b00      	cmp	r3, #0
3419a3fe:	d102      	bne.n	3419a406 <CMW_CAMERA_SetExposure+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419a400:	f06f 030a 	mvn.w	r3, #10
3419a404:	e00f      	b.n	3419a426 <CMW_CAMERA_SetExposure+0x36>
  }

  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
3419a406:	4b0a      	ldr	r3, [pc, #40]	@ (3419a430 <CMW_CAMERA_SetExposure+0x40>)
3419a408:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419a40a:	6879      	ldr	r1, [r7, #4]
3419a40c:	4809      	ldr	r0, [pc, #36]	@ (3419a434 <CMW_CAMERA_SetExposure+0x44>)
3419a40e:	4798      	blx	r3
3419a410:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419a412:	68fb      	ldr	r3, [r7, #12]
3419a414:	2b00      	cmp	r3, #0
3419a416:	d002      	beq.n	3419a41e <CMW_CAMERA_SetExposure+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a418:	f06f 0304 	mvn.w	r3, #4
3419a41c:	e003      	b.n	3419a426 <CMW_CAMERA_SetExposure+0x36>
  }

  Camera_Ctx.Exposure = exposure;
3419a41e:	4a06      	ldr	r2, [pc, #24]	@ (3419a438 <CMW_CAMERA_SetExposure+0x48>)
3419a420:	687b      	ldr	r3, [r7, #4]
3419a422:	6253      	str	r3, [r2, #36]	@ 0x24
  return CMW_ERROR_NONE;
3419a424:	2300      	movs	r3, #0
}
3419a426:	4618      	mov	r0, r3
3419a428:	3710      	adds	r7, #16
3419a42a:	46bd      	mov	sp, r7
3419a42c:	bd80      	pop	{r7, pc}
3419a42e:	bf00      	nop
3419a430:	341c187c 	.word	0x341c187c
3419a434:	341c18e4 	.word	0x341c18e4
3419a438:	341c1830 	.word	0x341c1830

3419a43c <CMW_CAMERA_GetExposure>:
  * @brief  Get the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_GetExposure(int32_t *exposure)
{
3419a43c:	b480      	push	{r7}
3419a43e:	b083      	sub	sp, #12
3419a440:	af00      	add	r7, sp, #0
3419a442:	6078      	str	r0, [r7, #4]
  *exposure = Camera_Ctx.Exposure;
3419a444:	4b05      	ldr	r3, [pc, #20]	@ (3419a45c <CMW_CAMERA_GetExposure+0x20>)
3419a446:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3419a448:	687b      	ldr	r3, [r7, #4]
3419a44a:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3419a44c:	2300      	movs	r3, #0
}
3419a44e:	4618      	mov	r0, r3
3419a450:	370c      	adds	r7, #12
3419a452:	46bd      	mov	sp, r7
3419a454:	f85d 7b04 	ldr.w	r7, [sp], #4
3419a458:	4770      	bx	lr
3419a45a:	bf00      	nop
3419a45c:	341c1830 	.word	0x341c1830

3419a460 <CMW_CAMERA_GetSensorInfo>:
  * @note   This function should be called after the init. This to get Capabilities
  *         from the camera sensor
  * @retval Component status
  */
int32_t CMW_CAMERA_GetSensorInfo(ISP_SensorInfoTypeDef *info)
{
3419a460:	b580      	push	{r7, lr}
3419a462:	b084      	sub	sp, #16
3419a464:	af00      	add	r7, sp, #0
3419a466:	6078      	str	r0, [r7, #4]

  int32_t ret;

  if(Camera_Drv.GetSensorInfo == NULL)
3419a468:	4b0b      	ldr	r3, [pc, #44]	@ (3419a498 <CMW_CAMERA_GetSensorInfo+0x38>)
3419a46a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a46c:	2b00      	cmp	r3, #0
3419a46e:	d102      	bne.n	3419a476 <CMW_CAMERA_GetSensorInfo+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419a470:	f06f 030a 	mvn.w	r3, #10
3419a474:	e00c      	b.n	3419a490 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
3419a476:	4b08      	ldr	r3, [pc, #32]	@ (3419a498 <CMW_CAMERA_GetSensorInfo+0x38>)
3419a478:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a47a:	6879      	ldr	r1, [r7, #4]
3419a47c:	4807      	ldr	r0, [pc, #28]	@ (3419a49c <CMW_CAMERA_GetSensorInfo+0x3c>)
3419a47e:	4798      	blx	r3
3419a480:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419a482:	68fb      	ldr	r3, [r7, #12]
3419a484:	2b00      	cmp	r3, #0
3419a486:	d002      	beq.n	3419a48e <CMW_CAMERA_GetSensorInfo+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a488:	f06f 0304 	mvn.w	r3, #4
3419a48c:	e000      	b.n	3419a490 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  return CMW_ERROR_NONE;
3419a48e:	2300      	movs	r3, #0
}
3419a490:	4618      	mov	r0, r3
3419a492:	3710      	adds	r7, #16
3419a494:	46bd      	mov	sp, r7
3419a496:	bd80      	pop	{r7, pc}
3419a498:	341c187c 	.word	0x341c187c
3419a49c:	341c18e4 	.word	0x341c18e4

3419a4a0 <CMW_CAMERA_EnableGPIOs>:
/**
  * @brief  CAMERA hardware reset
  * @retval CMW status
  */
static void CMW_CAMERA_EnableGPIOs(void)
{
3419a4a0:	b580      	push	{r7, lr}
3419a4a2:	b086      	sub	sp, #24
3419a4a4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef gpio_init_structure = {0};
3419a4a6:	1d3b      	adds	r3, r7, #4
3419a4a8:	2200      	movs	r2, #0
3419a4aa:	601a      	str	r2, [r3, #0]
3419a4ac:	605a      	str	r2, [r3, #4]
3419a4ae:	609a      	str	r2, [r3, #8]
3419a4b0:	60da      	str	r2, [r3, #12]
3419a4b2:	611a      	str	r2, [r3, #16]

  /* Enable GPIO clocks */
  EN_CAM_GPIO_ENABLE_VDDIO();
  EN_CAM_GPIO_CLK_ENABLE();
3419a4b4:	2008      	movs	r0, #8
3419a4b6:	f7ff fe4f 	bl	3419a158 <LL_AHB4_GRP1_EnableClock>
  NRST_CAM_GPIO_ENABLE_VDDIO();
3419a4ba:	f7f1 f865 	bl	3418b588 <HAL_PWREx_EnableVddIO4>
  NRST_CAM_GPIO_CLK_ENABLE();
3419a4be:	2004      	movs	r0, #4
3419a4c0:	f7ff fe4a 	bl	3419a158 <LL_AHB4_GRP1_EnableClock>

  gpio_init_structure.Pin       = EN_CAM_PIN;
3419a4c4:	2304      	movs	r3, #4
3419a4c6:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3419a4c8:	2300      	movs	r3, #0
3419a4ca:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3419a4cc:	2301      	movs	r3, #1
3419a4ce:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3419a4d0:	2303      	movs	r3, #3
3419a4d2:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3419a4d4:	1d3b      	adds	r3, r7, #4
3419a4d6:	4619      	mov	r1, r3
3419a4d8:	480a      	ldr	r0, [pc, #40]	@ (3419a504 <CMW_CAMERA_EnableGPIOs+0x64>)
3419a4da:	f7ee f8d7 	bl	3418868c <HAL_GPIO_Init>

  gpio_init_structure.Pin       = NRST_CAM_PIN;
3419a4de:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419a4e2:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3419a4e4:	2300      	movs	r3, #0
3419a4e6:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3419a4e8:	2301      	movs	r3, #1
3419a4ea:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3419a4ec:	2303      	movs	r3, #3
3419a4ee:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3419a4f0:	1d3b      	adds	r3, r7, #4
3419a4f2:	4619      	mov	r1, r3
3419a4f4:	4804      	ldr	r0, [pc, #16]	@ (3419a508 <CMW_CAMERA_EnableGPIOs+0x68>)
3419a4f6:	f7ee f8c9 	bl	3418868c <HAL_GPIO_Init>
}
3419a4fa:	bf00      	nop
3419a4fc:	3718      	adds	r7, #24
3419a4fe:	46bd      	mov	sp, r7
3419a500:	bd80      	pop	{r7, pc}
3419a502:	bf00      	nop
3419a504:	56020c00 	.word	0x56020c00
3419a508:	56020800 	.word	0x56020800

3419a50c <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, GPIO_PIN_RESET);

}

static void CMW_CAMERA_ShutdownPin(int value)
{
3419a50c:	b580      	push	{r7, lr}
3419a50e:	b082      	sub	sp, #8
3419a510:	af00      	add	r7, sp, #0
3419a512:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3419a514:	687b      	ldr	r3, [r7, #4]
3419a516:	2b00      	cmp	r3, #0
3419a518:	bf14      	ite	ne
3419a51a:	2301      	movne	r3, #1
3419a51c:	2300      	moveq	r3, #0
3419a51e:	b2db      	uxtb	r3, r3
3419a520:	461a      	mov	r2, r3
3419a522:	f44f 7180 	mov.w	r1, #256	@ 0x100
3419a526:	4803      	ldr	r0, [pc, #12]	@ (3419a534 <CMW_CAMERA_ShutdownPin+0x28>)
3419a528:	f7ee fba2 	bl	34188c70 <HAL_GPIO_WritePin>
}
3419a52c:	bf00      	nop
3419a52e:	3708      	adds	r7, #8
3419a530:	46bd      	mov	sp, r7
3419a532:	bd80      	pop	{r7, pc}
3419a534:	56020800 	.word	0x56020800

3419a538 <CMW_CAMERA_EnablePin>:

static void CMW_CAMERA_EnablePin(int value)
{
3419a538:	b580      	push	{r7, lr}
3419a53a:	b082      	sub	sp, #8
3419a53c:	af00      	add	r7, sp, #0
3419a53e:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3419a540:	687b      	ldr	r3, [r7, #4]
3419a542:	2b00      	cmp	r3, #0
3419a544:	bf14      	ite	ne
3419a546:	2301      	movne	r3, #1
3419a548:	2300      	moveq	r3, #0
3419a54a:	b2db      	uxtb	r3, r3
3419a54c:	461a      	mov	r2, r3
3419a54e:	2104      	movs	r1, #4
3419a550:	4803      	ldr	r0, [pc, #12]	@ (3419a560 <CMW_CAMERA_EnablePin+0x28>)
3419a552:	f7ee fb8d 	bl	34188c70 <HAL_GPIO_WritePin>
}
3419a556:	bf00      	nop
3419a558:	3708      	adds	r7, #8
3419a55a:	46bd      	mov	sp, r7
3419a55c:	bd80      	pop	{r7, pc}
3419a55e:	bf00      	nop
3419a560:	56020c00 	.word	0x56020c00

3419a564 <CB_ISP_SetSensorGain>:

#if defined(USE_VD66GY_SENSOR) || defined(USE_IMX335_SENSOR)
static ISP_StatusTypeDef CB_ISP_SetSensorGain(uint32_t camera_instance, int32_t gain)
{
3419a564:	b580      	push	{r7, lr}
3419a566:	b082      	sub	sp, #8
3419a568:	af00      	add	r7, sp, #0
3419a56a:	6078      	str	r0, [r7, #4]
3419a56c:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
3419a56e:	6838      	ldr	r0, [r7, #0]
3419a570:	f7ff ff06 	bl	3419a380 <CMW_CAMERA_SetGain>
3419a574:	4603      	mov	r3, r0
3419a576:	2b00      	cmp	r3, #0
3419a578:	d001      	beq.n	3419a57e <CB_ISP_SetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3419a57a:	2379      	movs	r3, #121	@ 0x79
3419a57c:	e000      	b.n	3419a580 <CB_ISP_SetSensorGain+0x1c>

  return ISP_OK;
3419a57e:	2300      	movs	r3, #0
}
3419a580:	4618      	mov	r0, r3
3419a582:	3708      	adds	r7, #8
3419a584:	46bd      	mov	sp, r7
3419a586:	bd80      	pop	{r7, pc}

3419a588 <CB_ISP_GetSensorGain>:

static ISP_StatusTypeDef CB_ISP_GetSensorGain(uint32_t camera_instance, int32_t *gain)
{
3419a588:	b580      	push	{r7, lr}
3419a58a:	b082      	sub	sp, #8
3419a58c:	af00      	add	r7, sp, #0
3419a58e:	6078      	str	r0, [r7, #4]
3419a590:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
3419a592:	6838      	ldr	r0, [r7, #0]
3419a594:	f7ff ff1a 	bl	3419a3cc <CMW_CAMERA_GetGain>
3419a598:	4603      	mov	r3, r0
3419a59a:	2b00      	cmp	r3, #0
3419a59c:	d001      	beq.n	3419a5a2 <CB_ISP_GetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3419a59e:	2379      	movs	r3, #121	@ 0x79
3419a5a0:	e000      	b.n	3419a5a4 <CB_ISP_GetSensorGain+0x1c>

  return ISP_OK;
3419a5a2:	2300      	movs	r3, #0
}
3419a5a4:	4618      	mov	r0, r3
3419a5a6:	3708      	adds	r7, #8
3419a5a8:	46bd      	mov	sp, r7
3419a5aa:	bd80      	pop	{r7, pc}

3419a5ac <CB_ISP_SetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_SetSensorExposure(uint32_t camera_instance, int32_t exposure)
{
3419a5ac:	b580      	push	{r7, lr}
3419a5ae:	b082      	sub	sp, #8
3419a5b0:	af00      	add	r7, sp, #0
3419a5b2:	6078      	str	r0, [r7, #4]
3419a5b4:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3419a5b6:	6838      	ldr	r0, [r7, #0]
3419a5b8:	f7ff ff1a 	bl	3419a3f0 <CMW_CAMERA_SetExposure>
3419a5bc:	4603      	mov	r3, r0
3419a5be:	2b00      	cmp	r3, #0
3419a5c0:	d001      	beq.n	3419a5c6 <CB_ISP_SetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3419a5c2:	2383      	movs	r3, #131	@ 0x83
3419a5c4:	e000      	b.n	3419a5c8 <CB_ISP_SetSensorExposure+0x1c>

  return ISP_OK;
3419a5c6:	2300      	movs	r3, #0
}
3419a5c8:	4618      	mov	r0, r3
3419a5ca:	3708      	adds	r7, #8
3419a5cc:	46bd      	mov	sp, r7
3419a5ce:	bd80      	pop	{r7, pc}

3419a5d0 <CB_ISP_GetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_GetSensorExposure(uint32_t camera_instance, int32_t *exposure)
{
3419a5d0:	b580      	push	{r7, lr}
3419a5d2:	b082      	sub	sp, #8
3419a5d4:	af00      	add	r7, sp, #0
3419a5d6:	6078      	str	r0, [r7, #4]
3419a5d8:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
3419a5da:	6838      	ldr	r0, [r7, #0]
3419a5dc:	f7ff ff2e 	bl	3419a43c <CMW_CAMERA_GetExposure>
3419a5e0:	4603      	mov	r3, r0
3419a5e2:	2b00      	cmp	r3, #0
3419a5e4:	d001      	beq.n	3419a5ea <CB_ISP_GetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3419a5e6:	2383      	movs	r3, #131	@ 0x83
3419a5e8:	e000      	b.n	3419a5ec <CB_ISP_GetSensorExposure+0x1c>

  return ISP_OK;
3419a5ea:	2300      	movs	r3, #0
}
3419a5ec:	4618      	mov	r0, r3
3419a5ee:	3708      	adds	r7, #8
3419a5f0:	46bd      	mov	sp, r7
3419a5f2:	bd80      	pop	{r7, pc}

3419a5f4 <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
3419a5f4:	b580      	push	{r7, lr}
3419a5f6:	b082      	sub	sp, #8
3419a5f8:	af00      	add	r7, sp, #0
3419a5fa:	6078      	str	r0, [r7, #4]
3419a5fc:	6039      	str	r1, [r7, #0]
  if(Camera_Drv.GetSensorInfo != NULL)
3419a5fe:	4b09      	ldr	r3, [pc, #36]	@ (3419a624 <CB_ISP_GetSensorInfo+0x30>)
3419a600:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a602:	2b00      	cmp	r3, #0
3419a604:	d009      	beq.n	3419a61a <CB_ISP_GetSensorInfo+0x26>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
3419a606:	4b07      	ldr	r3, [pc, #28]	@ (3419a624 <CB_ISP_GetSensorInfo+0x30>)
3419a608:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a60a:	6839      	ldr	r1, [r7, #0]
3419a60c:	4806      	ldr	r0, [pc, #24]	@ (3419a628 <CB_ISP_GetSensorInfo+0x34>)
3419a60e:	4798      	blx	r3
3419a610:	4603      	mov	r3, r0
3419a612:	2b00      	cmp	r3, #0
3419a614:	d001      	beq.n	3419a61a <CB_ISP_GetSensorInfo+0x26>
      return ISP_ERR_SENSOREXPOSURE;
3419a616:	2383      	movs	r3, #131	@ 0x83
3419a618:	e000      	b.n	3419a61c <CB_ISP_GetSensorInfo+0x28>
  }
  return ISP_OK;
3419a61a:	2300      	movs	r3, #0
}
3419a61c:	4618      	mov	r0, r3
3419a61e:	3708      	adds	r7, #8
3419a620:	46bd      	mov	sp, r7
3419a622:	bd80      	pop	{r7, pc}
3419a624:	341c187c 	.word	0x341c187c
3419a628:	341c18e4 	.word	0x341c18e4

3419a62c <CMW_CAMERA_VD55G1_Init>:
#endif

#if defined(USE_VD55G1_SENSOR)
static int32_t CMW_CAMERA_VD55G1_Init( CMW_Sensor_Init_t *initSensors_params)
{
3419a62c:	b580      	push	{r7, lr}
3419a62e:	b09a      	sub	sp, #104	@ 0x68
3419a630:	af00      	add	r7, sp, #0
3419a632:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419a634:	2300      	movs	r3, #0
3419a636:	663b      	str	r3, [r7, #96]	@ 0x60
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419a638:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419a63c:	2200      	movs	r2, #0
3419a63e:	601a      	str	r2, [r3, #0]
3419a640:	605a      	str	r2, [r3, #4]
3419a642:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419a644:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419a648:	2200      	movs	r2, #0
3419a64a:	601a      	str	r2, [r3, #0]
3419a64c:	605a      	str	r2, [r3, #4]
3419a64e:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419a650:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419a654:	2100      	movs	r1, #0
3419a656:	484d      	ldr	r0, [pc, #308]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a658:	f009 fba4 	bl	341a3da4 <memset>
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
3419a65c:	4b4b      	ldr	r3, [pc, #300]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a65e:	2220      	movs	r2, #32
3419a660:	801a      	strh	r2, [r3, #0]
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
3419a662:	4b4a      	ldr	r3, [pc, #296]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a664:	4a4a      	ldr	r2, [pc, #296]	@ (3419a790 <CMW_CAMERA_VD55G1_Init+0x164>)
3419a666:	671a      	str	r2, [r3, #112]	@ 0x70
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
3419a668:	4b48      	ldr	r3, [pc, #288]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a66a:	4a4a      	ldr	r2, [pc, #296]	@ (3419a794 <CMW_CAMERA_VD55G1_Init+0x168>)
3419a66c:	675a      	str	r2, [r3, #116]	@ 0x74
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419a66e:	4b47      	ldr	r3, [pc, #284]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a670:	4a49      	ldr	r2, [pc, #292]	@ (3419a798 <CMW_CAMERA_VD55G1_Init+0x16c>)
3419a672:	679a      	str	r2, [r3, #120]	@ 0x78
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
3419a674:	4b45      	ldr	r3, [pc, #276]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a676:	4a49      	ldr	r2, [pc, #292]	@ (3419a79c <CMW_CAMERA_VD55G1_Init+0x170>)
3419a678:	67da      	str	r2, [r3, #124]	@ 0x7c
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
3419a67a:	4b44      	ldr	r3, [pc, #272]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a67c:	4a48      	ldr	r2, [pc, #288]	@ (3419a7a0 <CMW_CAMERA_VD55G1_Init+0x174>)
3419a67e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419a682:	4b42      	ldr	r3, [pc, #264]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a684:	4a47      	ldr	r2, [pc, #284]	@ (3419a7a4 <CMW_CAMERA_VD55G1_Init+0x178>)
3419a686:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419a68a:	4b40      	ldr	r3, [pc, #256]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a68c:	4a46      	ldr	r2, [pc, #280]	@ (3419a7a8 <CMW_CAMERA_VD55G1_Init+0x17c>)
3419a68e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
3419a692:	4946      	ldr	r1, [pc, #280]	@ (3419a7ac <CMW_CAMERA_VD55G1_Init+0x180>)
3419a694:	483d      	ldr	r0, [pc, #244]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a696:	f001 fce9 	bl	3419c06c <CMW_VD55G1_Probe>
3419a69a:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419a69c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a69e:	2b00      	cmp	r3, #0
3419a6a0:	d002      	beq.n	3419a6a8 <CMW_CAMERA_VD55G1_Init+0x7c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a6a2:	f06f 0304 	mvn.w	r3, #4
3419a6a6:	e06c      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  }

  if ((connected_sensor != CMW_VD55G1_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419a6a8:	4b41      	ldr	r3, [pc, #260]	@ (3419a7b0 <CMW_CAMERA_VD55G1_Init+0x184>)
3419a6aa:	781b      	ldrb	r3, [r3, #0]
3419a6ac:	2b03      	cmp	r3, #3
3419a6ae:	d006      	beq.n	3419a6be <CMW_CAMERA_VD55G1_Init+0x92>
3419a6b0:	4b3f      	ldr	r3, [pc, #252]	@ (3419a7b0 <CMW_CAMERA_VD55G1_Init+0x184>)
3419a6b2:	781b      	ldrb	r3, [r3, #0]
3419a6b4:	2b00      	cmp	r3, #0
3419a6b6:	d002      	beq.n	3419a6be <CMW_CAMERA_VD55G1_Init+0x92>
  {
    /* If the selected sensor in the application side has selected a different sensors than VD55G1 */
    return CMW_ERROR_COMPONENT_FAILURE;
3419a6b8:	f06f 0304 	mvn.w	r3, #4
3419a6bc:	e061      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419a6be:	687b      	ldr	r3, [r7, #4]
3419a6c0:	681b      	ldr	r3, [r3, #0]
3419a6c2:	2b00      	cmp	r3, #0
3419a6c4:	d003      	beq.n	3419a6ce <CMW_CAMERA_VD55G1_Init+0xa2>
3419a6c6:	687b      	ldr	r3, [r7, #4]
3419a6c8:	685b      	ldr	r3, [r3, #4]
3419a6ca:	2b00      	cmp	r3, #0
3419a6cc:	d10c      	bne.n	3419a6e8 <CMW_CAMERA_VD55G1_Init+0xbc>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419a6ce:	4b37      	ldr	r3, [pc, #220]	@ (3419a7ac <CMW_CAMERA_VD55G1_Init+0x180>)
3419a6d0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a6d2:	f107 020c 	add.w	r2, r7, #12
3419a6d6:	4611      	mov	r1, r2
3419a6d8:	482c      	ldr	r0, [pc, #176]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a6da:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419a6dc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419a6de:	687b      	ldr	r3, [r7, #4]
3419a6e0:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419a6e2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419a6e4:	687b      	ldr	r3, [r7, #4]
3419a6e6:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419a6e8:	4b30      	ldr	r3, [pc, #192]	@ (3419a7ac <CMW_CAMERA_VD55G1_Init+0x180>)
3419a6ea:	681b      	ldr	r3, [r3, #0]
3419a6ec:	6879      	ldr	r1, [r7, #4]
3419a6ee:	4827      	ldr	r0, [pc, #156]	@ (3419a78c <CMW_CAMERA_VD55G1_Init+0x160>)
3419a6f0:	4798      	blx	r3
3419a6f2:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419a6f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a6f6:	2b00      	cmp	r3, #0
3419a6f8:	d002      	beq.n	3419a700 <CMW_CAMERA_VD55G1_Init+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a6fa:	f06f 0304 	mvn.w	r3, #4
3419a6fe:	e040      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
3419a700:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419a704:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419a706:	2301      	movs	r3, #1
3419a708:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3419a70a:	231c      	movs	r3, #28
3419a70c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419a70e:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419a712:	4619      	mov	r1, r3
3419a714:	4827      	ldr	r0, [pc, #156]	@ (3419a7b4 <CMW_CAMERA_VD55G1_Init+0x188>)
3419a716:	f7ea fff1 	bl	341856fc <HAL_DCMIPP_CSI_SetConfig>
3419a71a:	4603      	mov	r3, r0
3419a71c:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419a71e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a720:	2b00      	cmp	r3, #0
3419a722:	d002      	beq.n	3419a72a <CMW_CAMERA_VD55G1_Init+0xfe>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a724:	f06f 0303 	mvn.w	r3, #3
3419a728:	e02b      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3419a72a:	2202      	movs	r2, #2
3419a72c:	2100      	movs	r1, #0
3419a72e:	4821      	ldr	r0, [pc, #132]	@ (3419a7b4 <CMW_CAMERA_VD55G1_Init+0x188>)
3419a730:	f7eb f9e8 	bl	34185b04 <HAL_DCMIPP_CSI_SetVCConfig>
3419a734:	4603      	mov	r3, r0
3419a736:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419a738:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a73a:	2b00      	cmp	r3, #0
3419a73c:	d002      	beq.n	3419a744 <CMW_CAMERA_VD55G1_Init+0x118>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a73e:	f06f 0303 	mvn.w	r3, #3
3419a742:	e01e      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419a744:	2300      	movs	r3, #0
3419a746:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
3419a748:	232a      	movs	r3, #42	@ 0x2a
3419a74a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419a74c:	2300      	movs	r3, #0
3419a74e:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419a750:	2300      	movs	r3, #0
3419a752:	667b      	str	r3, [r7, #100]	@ 0x64
3419a754:	e011      	b.n	3419a77a <CMW_CAMERA_VD55G1_Init+0x14e>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419a756:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419a75a:	461a      	mov	r2, r3
3419a75c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
3419a75e:	4815      	ldr	r0, [pc, #84]	@ (3419a7b4 <CMW_CAMERA_VD55G1_Init+0x188>)
3419a760:	f7eb f930 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419a764:	4603      	mov	r3, r0
3419a766:	663b      	str	r3, [r7, #96]	@ 0x60
    if (ret != HAL_OK)
3419a768:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a76a:	2b00      	cmp	r3, #0
3419a76c:	d002      	beq.n	3419a774 <CMW_CAMERA_VD55G1_Init+0x148>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419a76e:	f06f 0303 	mvn.w	r3, #3
3419a772:	e006      	b.n	3419a782 <CMW_CAMERA_VD55G1_Init+0x156>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419a774:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a776:	3301      	adds	r3, #1
3419a778:	667b      	str	r3, [r7, #100]	@ 0x64
3419a77a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a77c:	2b02      	cmp	r3, #2
3419a77e:	d9ea      	bls.n	3419a756 <CMW_CAMERA_VD55G1_Init+0x12a>
    }
  }

  return CMW_ERROR_NONE;
3419a780:	2300      	movs	r3, #0
}
3419a782:	4618      	mov	r0, r3
3419a784:	3768      	adds	r7, #104	@ 0x68
3419a786:	46bd      	mov	sp, r7
3419a788:	bd80      	pop	{r7, pc}
3419a78a:	bf00      	nop
3419a78c:	341c18e4 	.word	0x341c18e4
3419a790:	34183a05 	.word	0x34183a05
3419a794:	34183a79 	.word	0x34183a79
3419a798:	34183b45 	.word	0x34183b45
3419a79c:	34183ba1 	.word	0x34183ba1
3419a7a0:	34185369 	.word	0x34185369
3419a7a4:	3419a50d 	.word	0x3419a50d
3419a7a8:	3419a539 	.word	0x3419a539
3419a7ac:	341c187c 	.word	0x341c187c
3419a7b0:	341c182c 	.word	0x341c182c
3419a7b4:	341c1870 	.word	0x341c1870

3419a7b8 <CMW_CAMERA_VD66GY_Init>:
#endif

#if defined(USE_VD66GY_SENSOR)
static int32_t CMW_CAMERA_VD66GY_Init( CMW_Sensor_Init_t *initSensors_params)
{
3419a7b8:	b580      	push	{r7, lr}
3419a7ba:	b09a      	sub	sp, #104	@ 0x68
3419a7bc:	af00      	add	r7, sp, #0
3419a7be:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419a7c0:	2300      	movs	r3, #0
3419a7c2:	663b      	str	r3, [r7, #96]	@ 0x60
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419a7c4:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419a7c8:	2200      	movs	r2, #0
3419a7ca:	601a      	str	r2, [r3, #0]
3419a7cc:	605a      	str	r2, [r3, #4]
3419a7ce:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419a7d0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419a7d4:	2200      	movs	r2, #0
3419a7d6:	601a      	str	r2, [r3, #0]
3419a7d8:	605a      	str	r2, [r3, #4]
3419a7da:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419a7dc:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419a7e0:	2100      	movs	r1, #0
3419a7e2:	485b      	ldr	r0, [pc, #364]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a7e4:	f009 fade 	bl	341a3da4 <memset>
  camera_bsp.vd66gy_bsp.Address     = CAMERA_VD66GY_ADDRESS;
3419a7e8:	4b59      	ldr	r3, [pc, #356]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a7ea:	2220      	movs	r2, #32
3419a7ec:	801a      	strh	r2, [r3, #0]
  camera_bsp.vd66gy_bsp.Init        = CMW_I2C_INIT;
3419a7ee:	4b58      	ldr	r3, [pc, #352]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a7f0:	4a58      	ldr	r2, [pc, #352]	@ (3419a954 <CMW_CAMERA_VD66GY_Init+0x19c>)
3419a7f2:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
3419a7f6:	4b56      	ldr	r3, [pc, #344]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a7f8:	4a57      	ldr	r2, [pc, #348]	@ (3419a958 <CMW_CAMERA_VD66GY_Init+0x1a0>)
3419a7fa:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
  camera_bsp.vd66gy_bsp.ReadReg     = CMW_I2C_READREG16;
3419a7fe:	4b54      	ldr	r3, [pc, #336]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a800:	4a56      	ldr	r2, [pc, #344]	@ (3419a95c <CMW_CAMERA_VD66GY_Init+0x1a4>)
3419a802:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419a806:	4b52      	ldr	r3, [pc, #328]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a808:	4a55      	ldr	r2, [pc, #340]	@ (3419a960 <CMW_CAMERA_VD66GY_Init+0x1a8>)
3419a80a:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
  camera_bsp.vd66gy_bsp.Delay       = HAL_Delay;
3419a80e:	4b50      	ldr	r3, [pc, #320]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a810:	4a54      	ldr	r2, [pc, #336]	@ (3419a964 <CMW_CAMERA_VD66GY_Init+0x1ac>)
3419a812:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419a816:	4b4e      	ldr	r3, [pc, #312]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a818:	4a53      	ldr	r2, [pc, #332]	@ (3419a968 <CMW_CAMERA_VD66GY_Init+0x1b0>)
3419a81a:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419a81e:	4b4c      	ldr	r3, [pc, #304]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a820:	4a52      	ldr	r2, [pc, #328]	@ (3419a96c <CMW_CAMERA_VD66GY_Init+0x1b4>)
3419a822:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
3419a826:	4b4a      	ldr	r3, [pc, #296]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a828:	4a51      	ldr	r2, [pc, #324]	@ (3419a970 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419a82a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3419a82e:	4b48      	ldr	r3, [pc, #288]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a830:	4a50      	ldr	r2, [pc, #320]	@ (3419a974 <CMW_CAMERA_VD66GY_Init+0x1bc>)
3419a832:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3419a836:	4b46      	ldr	r3, [pc, #280]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a838:	4a4f      	ldr	r2, [pc, #316]	@ (3419a978 <CMW_CAMERA_VD66GY_Init+0x1c0>)
3419a83a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3419a83e:	4b44      	ldr	r3, [pc, #272]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a840:	4a4e      	ldr	r2, [pc, #312]	@ (3419a97c <CMW_CAMERA_VD66GY_Init+0x1c4>)
3419a842:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3419a846:	4b42      	ldr	r3, [pc, #264]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a848:	4a4d      	ldr	r2, [pc, #308]	@ (3419a980 <CMW_CAMERA_VD66GY_Init+0x1c8>)
3419a84a:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3419a84e:	4b40      	ldr	r3, [pc, #256]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a850:	4a4c      	ldr	r2, [pc, #304]	@ (3419a984 <CMW_CAMERA_VD66GY_Init+0x1cc>)
3419a852:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
3419a856:	494c      	ldr	r1, [pc, #304]	@ (3419a988 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419a858:	483d      	ldr	r0, [pc, #244]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a85a:	f002 fb5d 	bl	3419cf18 <CMW_VD66GY_Probe>
3419a85e:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419a860:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a862:	2b00      	cmp	r3, #0
3419a864:	d002      	beq.n	3419a86c <CMW_CAMERA_VD66GY_Init+0xb4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a866:	f06f 0304 	mvn.w	r3, #4
3419a86a:	e06c      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  if ((connected_sensor != CMW_VD66GY_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419a86c:	4b47      	ldr	r3, [pc, #284]	@ (3419a98c <CMW_CAMERA_VD66GY_Init+0x1d4>)
3419a86e:	781b      	ldrb	r3, [r3, #0]
3419a870:	2b01      	cmp	r3, #1
3419a872:	d006      	beq.n	3419a882 <CMW_CAMERA_VD66GY_Init+0xca>
3419a874:	4b45      	ldr	r3, [pc, #276]	@ (3419a98c <CMW_CAMERA_VD66GY_Init+0x1d4>)
3419a876:	781b      	ldrb	r3, [r3, #0]
3419a878:	2b00      	cmp	r3, #0
3419a87a:	d002      	beq.n	3419a882 <CMW_CAMERA_VD66GY_Init+0xca>
  {
    /* If the selected sensor in the application side has selected a different sensors than VD66GY */
    return CMW_ERROR_COMPONENT_FAILURE;
3419a87c:	f06f 0304 	mvn.w	r3, #4
3419a880:	e061      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419a882:	687b      	ldr	r3, [r7, #4]
3419a884:	681b      	ldr	r3, [r3, #0]
3419a886:	2b00      	cmp	r3, #0
3419a888:	d003      	beq.n	3419a892 <CMW_CAMERA_VD66GY_Init+0xda>
3419a88a:	687b      	ldr	r3, [r7, #4]
3419a88c:	685b      	ldr	r3, [r3, #4]
3419a88e:	2b00      	cmp	r3, #0
3419a890:	d10c      	bne.n	3419a8ac <CMW_CAMERA_VD66GY_Init+0xf4>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419a892:	4b3d      	ldr	r3, [pc, #244]	@ (3419a988 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419a894:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419a896:	f107 020c 	add.w	r2, r7, #12
3419a89a:	4611      	mov	r1, r2
3419a89c:	482c      	ldr	r0, [pc, #176]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a89e:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419a8a0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419a8a2:	687b      	ldr	r3, [r7, #4]
3419a8a4:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419a8a6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419a8a8:	687b      	ldr	r3, [r7, #4]
3419a8aa:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419a8ac:	4b36      	ldr	r3, [pc, #216]	@ (3419a988 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419a8ae:	681b      	ldr	r3, [r3, #0]
3419a8b0:	6879      	ldr	r1, [r7, #4]
3419a8b2:	4827      	ldr	r0, [pc, #156]	@ (3419a950 <CMW_CAMERA_VD66GY_Init+0x198>)
3419a8b4:	4798      	blx	r3
3419a8b6:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419a8b8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a8ba:	2b00      	cmp	r3, #0
3419a8bc:	d002      	beq.n	3419a8c4 <CMW_CAMERA_VD66GY_Init+0x10c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419a8be:	f06f 0304 	mvn.w	r3, #4
3419a8c2:	e040      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
3419a8c4:	f44f 7300 	mov.w	r3, #512	@ 0x200
3419a8c8:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419a8ca:	2301      	movs	r3, #1
3419a8cc:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3419a8ce:	231c      	movs	r3, #28
3419a8d0:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419a8d2:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419a8d6:	4619      	mov	r1, r3
3419a8d8:	4825      	ldr	r0, [pc, #148]	@ (3419a970 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419a8da:	f7ea ff0f 	bl	341856fc <HAL_DCMIPP_CSI_SetConfig>
3419a8de:	4603      	mov	r3, r0
3419a8e0:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419a8e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a8e4:	2b00      	cmp	r3, #0
3419a8e6:	d002      	beq.n	3419a8ee <CMW_CAMERA_VD66GY_Init+0x136>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a8e8:	f06f 0303 	mvn.w	r3, #3
3419a8ec:	e02b      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3419a8ee:	2202      	movs	r2, #2
3419a8f0:	2100      	movs	r1, #0
3419a8f2:	481f      	ldr	r0, [pc, #124]	@ (3419a970 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419a8f4:	f7eb f906 	bl	34185b04 <HAL_DCMIPP_CSI_SetVCConfig>
3419a8f8:	4603      	mov	r3, r0
3419a8fa:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419a8fc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a8fe:	2b00      	cmp	r3, #0
3419a900:	d002      	beq.n	3419a908 <CMW_CAMERA_VD66GY_Init+0x150>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419a902:	f06f 0303 	mvn.w	r3, #3
3419a906:	e01e      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419a908:	2300      	movs	r3, #0
3419a90a:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
3419a90c:	232a      	movs	r3, #42	@ 0x2a
3419a90e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419a910:	2300      	movs	r3, #0
3419a912:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419a914:	2300      	movs	r3, #0
3419a916:	667b      	str	r3, [r7, #100]	@ 0x64
3419a918:	e011      	b.n	3419a93e <CMW_CAMERA_VD66GY_Init+0x186>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419a91a:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419a91e:	461a      	mov	r2, r3
3419a920:	6e79      	ldr	r1, [r7, #100]	@ 0x64
3419a922:	4813      	ldr	r0, [pc, #76]	@ (3419a970 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419a924:	f7eb f84e 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419a928:	4603      	mov	r3, r0
3419a92a:	663b      	str	r3, [r7, #96]	@ 0x60
    if (ret != HAL_OK)
3419a92c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419a92e:	2b00      	cmp	r3, #0
3419a930:	d002      	beq.n	3419a938 <CMW_CAMERA_VD66GY_Init+0x180>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419a932:	f06f 0303 	mvn.w	r3, #3
3419a936:	e006      	b.n	3419a946 <CMW_CAMERA_VD66GY_Init+0x18e>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419a938:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a93a:	3301      	adds	r3, #1
3419a93c:	667b      	str	r3, [r7, #100]	@ 0x64
3419a93e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419a940:	2b02      	cmp	r3, #2
3419a942:	d9ea      	bls.n	3419a91a <CMW_CAMERA_VD66GY_Init+0x162>
    }
  }

  return CMW_ERROR_NONE;
3419a944:	2300      	movs	r3, #0
}
3419a946:	4618      	mov	r0, r3
3419a948:	3768      	adds	r7, #104	@ 0x68
3419a94a:	46bd      	mov	sp, r7
3419a94c:	bd80      	pop	{r7, pc}
3419a94e:	bf00      	nop
3419a950:	341c18e4 	.word	0x341c18e4
3419a954:	34183a05 	.word	0x34183a05
3419a958:	34183a79 	.word	0x34183a79
3419a95c:	34183ba1 	.word	0x34183ba1
3419a960:	34183b45 	.word	0x34183b45
3419a964:	34185369 	.word	0x34185369
3419a968:	3419a50d 	.word	0x3419a50d
3419a96c:	3419a539 	.word	0x3419a539
3419a970:	341c1870 	.word	0x341c1870
3419a974:	3419a565 	.word	0x3419a565
3419a978:	3419a589 	.word	0x3419a589
3419a97c:	3419a5ad 	.word	0x3419a5ad
3419a980:	3419a5d1 	.word	0x3419a5d1
3419a984:	3419a5f5 	.word	0x3419a5f5
3419a988:	341c187c 	.word	0x341c187c
3419a98c:	341c182c 	.word	0x341c182c

3419a990 <CMW_CAMERA_IMX335_Init>:
#endif

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init(CMW_Sensor_Init_t *initSensors_params)
{
3419a990:	b580      	push	{r7, lr}
3419a992:	b09a      	sub	sp, #104	@ 0x68
3419a994:	af00      	add	r7, sp, #0
3419a996:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419a998:	2300      	movs	r3, #0
3419a99a:	667b      	str	r3, [r7, #100]	@ 0x64
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419a99c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419a9a0:	2200      	movs	r2, #0
3419a9a2:	601a      	str	r2, [r3, #0]
3419a9a4:	605a      	str	r2, [r3, #4]
3419a9a6:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419a9a8:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419a9ac:	2200      	movs	r2, #0
3419a9ae:	601a      	str	r2, [r3, #0]
3419a9b0:	605a      	str	r2, [r3, #4]
3419a9b2:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419a9b4:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419a9b8:	2100      	movs	r1, #0
3419a9ba:	486a      	ldr	r0, [pc, #424]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9bc:	f009 f9f2 	bl	341a3da4 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
3419a9c0:	4b68      	ldr	r3, [pc, #416]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9c2:	2234      	movs	r2, #52	@ 0x34
3419a9c4:	801a      	strh	r2, [r3, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
3419a9c6:	4b67      	ldr	r3, [pc, #412]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9c8:	4a67      	ldr	r2, [pc, #412]	@ (3419ab68 <CMW_CAMERA_IMX335_Init+0x1d8>)
3419a9ca:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
3419a9ce:	4b65      	ldr	r3, [pc, #404]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9d0:	4a66      	ldr	r2, [pc, #408]	@ (3419ab6c <CMW_CAMERA_IMX335_Init+0x1dc>)
3419a9d2:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
3419a9d6:	4b63      	ldr	r3, [pc, #396]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9d8:	4a65      	ldr	r2, [pc, #404]	@ (3419ab70 <CMW_CAMERA_IMX335_Init+0x1e0>)
3419a9da:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419a9de:	4b61      	ldr	r3, [pc, #388]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9e0:	4a64      	ldr	r2, [pc, #400]	@ (3419ab74 <CMW_CAMERA_IMX335_Init+0x1e4>)
3419a9e2:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
3419a9e6:	4b5f      	ldr	r3, [pc, #380]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9e8:	4a63      	ldr	r2, [pc, #396]	@ (3419ab78 <CMW_CAMERA_IMX335_Init+0x1e8>)
3419a9ea:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
3419a9ee:	4b5d      	ldr	r3, [pc, #372]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9f0:	4a62      	ldr	r2, [pc, #392]	@ (3419ab7c <CMW_CAMERA_IMX335_Init+0x1ec>)
3419a9f2:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419a9f6:	4b5b      	ldr	r3, [pc, #364]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419a9f8:	4a61      	ldr	r2, [pc, #388]	@ (3419ab80 <CMW_CAMERA_IMX335_Init+0x1f0>)
3419a9fa:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419a9fe:	4b59      	ldr	r3, [pc, #356]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa00:	4a60      	ldr	r2, [pc, #384]	@ (3419ab84 <CMW_CAMERA_IMX335_Init+0x1f4>)
3419aa02:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
3419aa06:	4b57      	ldr	r3, [pc, #348]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa08:	4a5f      	ldr	r2, [pc, #380]	@ (3419ab88 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419aa0a:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3419aa0e:	4b55      	ldr	r3, [pc, #340]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa10:	4a5e      	ldr	r2, [pc, #376]	@ (3419ab8c <CMW_CAMERA_IMX335_Init+0x1fc>)
3419aa12:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3419aa16:	4b53      	ldr	r3, [pc, #332]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa18:	4a5d      	ldr	r2, [pc, #372]	@ (3419ab90 <CMW_CAMERA_IMX335_Init+0x200>)
3419aa1a:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3419aa1e:	4b51      	ldr	r3, [pc, #324]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa20:	4a5c      	ldr	r2, [pc, #368]	@ (3419ab94 <CMW_CAMERA_IMX335_Init+0x204>)
3419aa22:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3419aa26:	4b4f      	ldr	r3, [pc, #316]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa28:	4a5b      	ldr	r2, [pc, #364]	@ (3419ab98 <CMW_CAMERA_IMX335_Init+0x208>)
3419aa2a:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3419aa2e:	4b4d      	ldr	r3, [pc, #308]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa30:	4a5a      	ldr	r2, [pc, #360]	@ (3419ab9c <CMW_CAMERA_IMX335_Init+0x20c>)
3419aa32:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3419aa36:	495a      	ldr	r1, [pc, #360]	@ (3419aba0 <CMW_CAMERA_IMX335_Init+0x210>)
3419aa38:	484a      	ldr	r0, [pc, #296]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa3a:	f000 fed3 	bl	3419b7e4 <CMW_IMX335_Probe>
3419aa3e:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419aa40:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aa42:	2b00      	cmp	r3, #0
3419aa44:	d002      	beq.n	3419aa4c <CMW_CAMERA_IMX335_Init+0xbc>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419aa46:	f06f 0304 	mvn.w	r3, #4
3419aa4a:	e086      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  if ((connected_sensor != CMW_IMX335_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419aa4c:	4b55      	ldr	r3, [pc, #340]	@ (3419aba4 <CMW_CAMERA_IMX335_Init+0x214>)
3419aa4e:	781b      	ldrb	r3, [r3, #0]
3419aa50:	2b02      	cmp	r3, #2
3419aa52:	d006      	beq.n	3419aa62 <CMW_CAMERA_IMX335_Init+0xd2>
3419aa54:	4b53      	ldr	r3, [pc, #332]	@ (3419aba4 <CMW_CAMERA_IMX335_Init+0x214>)
3419aa56:	781b      	ldrb	r3, [r3, #0]
3419aa58:	2b00      	cmp	r3, #0
3419aa5a:	d002      	beq.n	3419aa62 <CMW_CAMERA_IMX335_Init+0xd2>
  {
    /* If the selected sensor in the application side has selected a different sensors than IMX335 */
    return CMW_ERROR_COMPONENT_FAILURE;
3419aa5c:	f06f 0304 	mvn.w	r3, #4
3419aa60:	e07b      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419aa62:	687b      	ldr	r3, [r7, #4]
3419aa64:	681b      	ldr	r3, [r3, #0]
3419aa66:	2b00      	cmp	r3, #0
3419aa68:	d003      	beq.n	3419aa72 <CMW_CAMERA_IMX335_Init+0xe2>
3419aa6a:	687b      	ldr	r3, [r7, #4]
3419aa6c:	685b      	ldr	r3, [r3, #4]
3419aa6e:	2b00      	cmp	r3, #0
3419aa70:	d10c      	bne.n	3419aa8c <CMW_CAMERA_IMX335_Init+0xfc>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419aa72:	4b4b      	ldr	r3, [pc, #300]	@ (3419aba0 <CMW_CAMERA_IMX335_Init+0x210>)
3419aa74:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419aa76:	f107 020c 	add.w	r2, r7, #12
3419aa7a:	4611      	mov	r1, r2
3419aa7c:	4839      	ldr	r0, [pc, #228]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa7e:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419aa80:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419aa82:	687b      	ldr	r3, [r7, #4]
3419aa84:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419aa86:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419aa88:	687b      	ldr	r3, [r7, #4]
3419aa8a:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419aa8c:	4b44      	ldr	r3, [pc, #272]	@ (3419aba0 <CMW_CAMERA_IMX335_Init+0x210>)
3419aa8e:	681b      	ldr	r3, [r3, #0]
3419aa90:	6879      	ldr	r1, [r7, #4]
3419aa92:	4834      	ldr	r0, [pc, #208]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aa94:	4798      	blx	r3
3419aa96:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419aa98:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aa9a:	2b00      	cmp	r3, #0
3419aa9c:	d002      	beq.n	3419aaa4 <CMW_CAMERA_IMX335_Init+0x114>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419aa9e:	f06f 0304 	mvn.w	r3, #4
3419aaa2:	e05a      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_24MHZ);
3419aaa4:	4b3e      	ldr	r3, [pc, #248]	@ (3419aba0 <CMW_CAMERA_IMX335_Init+0x210>)
3419aaa6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419aaa8:	2102      	movs	r1, #2
3419aaaa:	482e      	ldr	r0, [pc, #184]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aaac:	4798      	blx	r3
3419aaae:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419aab0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aab2:	2b00      	cmp	r3, #0
3419aab4:	d002      	beq.n	3419aabc <CMW_CAMERA_IMX335_Init+0x12c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419aab6:	f06f 0304 	mvn.w	r3, #4
3419aaba:	e04e      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = Camera_Drv.SetFramerate(&camera_bsp, initSensors_params->fps);
3419aabc:	4b38      	ldr	r3, [pc, #224]	@ (3419aba0 <CMW_CAMERA_IMX335_Init+0x210>)
3419aabe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419aac0:	687a      	ldr	r2, [r7, #4]
3419aac2:	6892      	ldr	r2, [r2, #8]
3419aac4:	4611      	mov	r1, r2
3419aac6:	4827      	ldr	r0, [pc, #156]	@ (3419ab64 <CMW_CAMERA_IMX335_Init+0x1d4>)
3419aac8:	4798      	blx	r3
3419aaca:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419aacc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aace:	2b00      	cmp	r3, #0
3419aad0:	d002      	beq.n	3419aad8 <CMW_CAMERA_IMX335_Init+0x148>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419aad2:	f06f 0304 	mvn.w	r3, #4
3419aad6:	e040      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
3419aad8:	f44f 7300 	mov.w	r3, #512	@ 0x200
3419aadc:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419aade:	2301      	movs	r3, #1
3419aae0:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3419aae2:	232c      	movs	r3, #44	@ 0x2c
3419aae4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419aae6:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419aaea:	4619      	mov	r1, r3
3419aaec:	4826      	ldr	r0, [pc, #152]	@ (3419ab88 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419aaee:	f7ea fe05 	bl	341856fc <HAL_DCMIPP_CSI_SetConfig>
3419aaf2:	4603      	mov	r3, r0
3419aaf4:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3419aaf6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419aaf8:	2b00      	cmp	r3, #0
3419aafa:	d002      	beq.n	3419ab02 <CMW_CAMERA_IMX335_Init+0x172>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419aafc:	f06f 0303 	mvn.w	r3, #3
3419ab00:	e02b      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
3419ab02:	2203      	movs	r2, #3
3419ab04:	2100      	movs	r1, #0
3419ab06:	4820      	ldr	r0, [pc, #128]	@ (3419ab88 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419ab08:	f7ea fffc 	bl	34185b04 <HAL_DCMIPP_CSI_SetVCConfig>
3419ab0c:	4603      	mov	r3, r0
3419ab0e:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3419ab10:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab12:	2b00      	cmp	r3, #0
3419ab14:	d002      	beq.n	3419ab1c <CMW_CAMERA_IMX335_Init+0x18c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419ab16:	f06f 0303 	mvn.w	r3, #3
3419ab1a:	e01e      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419ab1c:	2300      	movs	r3, #0
3419ab1e:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3419ab20:	232b      	movs	r3, #43	@ 0x2b
3419ab22:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419ab24:	2300      	movs	r3, #0
3419ab26:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419ab28:	2300      	movs	r3, #0
3419ab2a:	663b      	str	r3, [r7, #96]	@ 0x60
3419ab2c:	e011      	b.n	3419ab52 <CMW_CAMERA_IMX335_Init+0x1c2>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419ab2e:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419ab32:	461a      	mov	r2, r3
3419ab34:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3419ab36:	4814      	ldr	r0, [pc, #80]	@ (3419ab88 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419ab38:	f7ea ff44 	bl	341859c4 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419ab3c:	4603      	mov	r3, r0
3419ab3e:	667b      	str	r3, [r7, #100]	@ 0x64
    if (ret != HAL_OK)
3419ab40:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419ab42:	2b00      	cmp	r3, #0
3419ab44:	d002      	beq.n	3419ab4c <CMW_CAMERA_IMX335_Init+0x1bc>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419ab46:	f06f 0303 	mvn.w	r3, #3
3419ab4a:	e006      	b.n	3419ab5a <CMW_CAMERA_IMX335_Init+0x1ca>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419ab4c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ab4e:	3301      	adds	r3, #1
3419ab50:	663b      	str	r3, [r7, #96]	@ 0x60
3419ab52:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419ab54:	2b02      	cmp	r3, #2
3419ab56:	d9ea      	bls.n	3419ab2e <CMW_CAMERA_IMX335_Init+0x19e>
    }
  }


  return ret;
3419ab58:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
3419ab5a:	4618      	mov	r0, r3
3419ab5c:	3768      	adds	r7, #104	@ 0x68
3419ab5e:	46bd      	mov	sp, r7
3419ab60:	bd80      	pop	{r7, pc}
3419ab62:	bf00      	nop
3419ab64:	341c18e4 	.word	0x341c18e4
3419ab68:	34183a05 	.word	0x34183a05
3419ab6c:	34183a79 	.word	0x34183a79
3419ab70:	34183ba1 	.word	0x34183ba1
3419ab74:	34183b45 	.word	0x34183b45
3419ab78:	34183d59 	.word	0x34183d59
3419ab7c:	34185369 	.word	0x34185369
3419ab80:	3419a50d 	.word	0x3419a50d
3419ab84:	3419a539 	.word	0x3419a539
3419ab88:	341c1870 	.word	0x341c1870
3419ab8c:	3419a565 	.word	0x3419a565
3419ab90:	3419a589 	.word	0x3419a589
3419ab94:	3419a5ad 	.word	0x3419a5ad
3419ab98:	3419a5d1 	.word	0x3419a5d1
3419ab9c:	3419a5f5 	.word	0x3419a5f5
3419aba0:	341c187c 	.word	0x341c187c
3419aba4:	341c182c 	.word	0x341c182c

3419aba8 <CMW_CAMERA_SetPipe>:
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3419aba8:	b580      	push	{r7, lr}
3419abaa:	b098      	sub	sp, #96	@ 0x60
3419abac:	af02      	add	r7, sp, #8
3419abae:	60f8      	str	r0, [r7, #12]
3419abb0:	60b9      	str	r1, [r7, #8]
3419abb2:	607a      	str	r2, [r7, #4]
3419abb4:	603b      	str	r3, [r7, #0]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3419abb6:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419abba:	2200      	movs	r2, #0
3419abbc:	601a      	str	r2, [r3, #0]
3419abbe:	605a      	str	r2, [r3, #4]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3419abc0:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419abc4:	2200      	movs	r2, #0
3419abc6:	601a      	str	r2, [r3, #0]
3419abc8:	605a      	str	r2, [r3, #4]
3419abca:	609a      	str	r2, [r3, #8]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3419abcc:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419abd0:	2200      	movs	r2, #0
3419abd2:	601a      	str	r2, [r3, #0]
3419abd4:	605a      	str	r2, [r3, #4]
3419abd6:	609a      	str	r2, [r3, #8]
3419abd8:	60da      	str	r2, [r3, #12]
3419abda:	611a      	str	r2, [r3, #16]
3419abdc:	615a      	str	r2, [r3, #20]
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3419abde:	f107 0314 	add.w	r3, r7, #20
3419abe2:	2200      	movs	r2, #0
3419abe4:	601a      	str	r2, [r3, #0]
3419abe6:	605a      	str	r2, [r3, #4]
3419abe8:	609a      	str	r2, [r3, #8]
3419abea:	60da      	str	r2, [r3, #12]
3419abec:	611a      	str	r2, [r3, #16]
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
3419abee:	68bb      	ldr	r3, [r7, #8]
3419abf0:	2b00      	cmp	r3, #0
3419abf2:	d112      	bne.n	3419ac1a <CMW_CAMERA_SetPipe+0x72>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3419abf4:	2300      	movs	r3, #0
3419abf6:	643b      	str	r3, [r7, #64]	@ 0x40
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3419abf8:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419abfc:	461a      	mov	r2, r3
3419abfe:	68b9      	ldr	r1, [r7, #8]
3419ac00:	68f8      	ldr	r0, [r7, #12]
3419ac02:	f7ea ffc1 	bl	34185b88 <HAL_DCMIPP_PIPE_SetConfig>
3419ac06:	4603      	mov	r3, r0
3419ac08:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ac0a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ac0c:	2b00      	cmp	r3, #0
3419ac0e:	d002      	beq.n	3419ac16 <CMW_CAMERA_SetPipe+0x6e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ac10:	f06f 0304 	mvn.w	r3, #4
3419ac14:	e11e      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }

    return HAL_OK;
3419ac16:	2300      	movs	r3, #0
3419ac18:	e11c      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
3419ac1a:	4b90      	ldr	r3, [pc, #576]	@ (3419ae5c <CMW_CAMERA_SetPipe+0x2b4>)
3419ac1c:	6818      	ldr	r0, [r3, #0]
3419ac1e:	4b8f      	ldr	r3, [pc, #572]	@ (3419ae5c <CMW_CAMERA_SetPipe+0x2b4>)
3419ac20:	6859      	ldr	r1, [r3, #4]
3419ac22:	f107 0214 	add.w	r2, r7, #20
3419ac26:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419ac2a:	9301      	str	r3, [sp, #4]
3419ac2c:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419ac30:	9300      	str	r3, [sp, #0]
3419ac32:	4613      	mov	r3, r2
3419ac34:	687a      	ldr	r2, [r7, #4]
3419ac36:	f000 f917 	bl	3419ae68 <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
3419ac3a:	69fb      	ldr	r3, [r7, #28]
3419ac3c:	2b00      	cmp	r3, #0
3419ac3e:	d102      	bne.n	3419ac46 <CMW_CAMERA_SetPipe+0x9e>
3419ac40:	6a3b      	ldr	r3, [r7, #32]
3419ac42:	2b00      	cmp	r3, #0
3419ac44:	d01a      	beq.n	3419ac7c <CMW_CAMERA_SetPipe+0xd4>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
3419ac46:	f107 0314 	add.w	r3, r7, #20
3419ac4a:	461a      	mov	r2, r3
3419ac4c:	68b9      	ldr	r1, [r7, #8]
3419ac4e:	68f8      	ldr	r0, [r7, #12]
3419ac50:	f7eb fef6 	bl	34186a40 <HAL_DCMIPP_PIPE_SetCropConfig>
3419ac54:	4603      	mov	r3, r0
3419ac56:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ac58:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ac5a:	2b00      	cmp	r3, #0
3419ac5c:	d002      	beq.n	3419ac64 <CMW_CAMERA_SetPipe+0xbc>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ac5e:	f06f 0304 	mvn.w	r3, #4
3419ac62:	e0f7      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
3419ac64:	68b9      	ldr	r1, [r7, #8]
3419ac66:	68f8      	ldr	r0, [r7, #12]
3419ac68:	f7eb ff92 	bl	34186b90 <HAL_DCMIPP_PIPE_EnableCrop>
3419ac6c:	4603      	mov	r3, r0
3419ac6e:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ac70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ac72:	2b00      	cmp	r3, #0
3419ac74:	d00e      	beq.n	3419ac94 <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ac76:	f06f 0304 	mvn.w	r3, #4
3419ac7a:	e0eb      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
3419ac7c:	68b9      	ldr	r1, [r7, #8]
3419ac7e:	68f8      	ldr	r0, [r7, #12]
3419ac80:	f7eb ffe4 	bl	34186c4c <HAL_DCMIPP_PIPE_DisableCrop>
3419ac84:	4603      	mov	r3, r0
3419ac86:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ac88:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ac8a:	2b00      	cmp	r3, #0
3419ac8c:	d002      	beq.n	3419ac94 <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ac8e:	f06f 0304 	mvn.w	r3, #4
3419ac92:	e0df      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
3419ac94:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419ac96:	2b00      	cmp	r3, #0
3419ac98:	d102      	bne.n	3419aca0 <CMW_CAMERA_SetPipe+0xf8>
3419ac9a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419ac9c:	2b00      	cmp	r3, #0
3419ac9e:	d01a      	beq.n	3419acd6 <CMW_CAMERA_SetPipe+0x12e>
  {
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
3419aca0:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419aca4:	461a      	mov	r2, r3
3419aca6:	68b9      	ldr	r1, [r7, #8]
3419aca8:	68f8      	ldr	r0, [r7, #12]
3419acaa:	f7ec f85d 	bl	34186d68 <HAL_DCMIPP_PIPE_SetDecimationConfig>
3419acae:	4603      	mov	r3, r0
3419acb0:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419acb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419acb4:	2b00      	cmp	r3, #0
3419acb6:	d002      	beq.n	3419acbe <CMW_CAMERA_SetPipe+0x116>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419acb8:	f06f 0304 	mvn.w	r3, #4
3419acbc:	e0ca      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
3419acbe:	68b9      	ldr	r1, [r7, #8]
3419acc0:	68f8      	ldr	r0, [r7, #12]
3419acc2:	f7ec f894 	bl	34186dee <HAL_DCMIPP_PIPE_EnableDecimation>
3419acc6:	4603      	mov	r3, r0
3419acc8:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419acca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419accc:	2b00      	cmp	r3, #0
3419acce:	d00e      	beq.n	3419acee <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419acd0:	f06f 0304 	mvn.w	r3, #4
3419acd4:	e0be      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
3419acd6:	68b9      	ldr	r1, [r7, #8]
3419acd8:	68f8      	ldr	r0, [r7, #12]
3419acda:	f7ec f8b7 	bl	34186e4c <HAL_DCMIPP_PIPE_DisableDecimation>
3419acde:	4603      	mov	r3, r0
3419ace0:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ace2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ace4:	2b00      	cmp	r3, #0
3419ace6:	d002      	beq.n	3419acee <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ace8:	f06f 0304 	mvn.w	r3, #4
3419acec:	e0b2      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
3419acee:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419acf2:	461a      	mov	r2, r3
3419acf4:	68b9      	ldr	r1, [r7, #8]
3419acf6:	68f8      	ldr	r0, [r7, #12]
3419acf8:	f7ec f8d7 	bl	34186eaa <HAL_DCMIPP_PIPE_SetDownsizeConfig>
3419acfc:	4603      	mov	r3, r0
3419acfe:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3419ad00:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad02:	2b00      	cmp	r3, #0
3419ad04:	d002      	beq.n	3419ad0c <CMW_CAMERA_SetPipe+0x164>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419ad06:	f06f 0304 	mvn.w	r3, #4
3419ad0a:	e0a3      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
3419ad0c:	68b9      	ldr	r1, [r7, #8]
3419ad0e:	68f8      	ldr	r0, [r7, #12]
3419ad10:	f7ec f949 	bl	34186fa6 <HAL_DCMIPP_PIPE_EnableDownsize>
3419ad14:	4603      	mov	r3, r0
3419ad16:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3419ad18:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad1a:	2b00      	cmp	r3, #0
3419ad1c:	d002      	beq.n	3419ad24 <CMW_CAMERA_SetPipe+0x17c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419ad1e:	f06f 0304 	mvn.w	r3, #4
3419ad22:	e097      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
  }

  if (p_conf->enable_swap)
3419ad24:	687b      	ldr	r3, [r7, #4]
3419ad26:	691b      	ldr	r3, [r3, #16]
3419ad28:	2b00      	cmp	r3, #0
3419ad2a:	d00b      	beq.n	3419ad44 <CMW_CAMERA_SetPipe+0x19c>
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3419ad2c:	68b9      	ldr	r1, [r7, #8]
3419ad2e:	68f8      	ldr	r0, [r7, #12]
3419ad30:	f7ed f846 	bl	34187dc0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
3419ad34:	4603      	mov	r3, r0
3419ad36:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ad38:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad3a:	2b00      	cmp	r3, #0
3419ad3c:	d00e      	beq.n	3419ad5c <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ad3e:	f06f 0304 	mvn.w	r3, #4
3419ad42:	e087      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
3419ad44:	68b9      	ldr	r1, [r7, #8]
3419ad46:	68f8      	ldr	r0, [r7, #12]
3419ad48:	f7ed f86e 	bl	34187e28 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
3419ad4c:	4603      	mov	r3, r0
3419ad4e:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ad50:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad52:	2b00      	cmp	r3, #0
3419ad54:	d002      	beq.n	3419ad5c <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ad56:	f06f 0304 	mvn.w	r3, #4
3419ad5a:	e07b      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
3419ad5c:	687b      	ldr	r3, [r7, #4]
3419ad5e:	695b      	ldr	r3, [r3, #20]
3419ad60:	2b00      	cmp	r3, #0
3419ad62:	db1b      	blt.n	3419ad9c <CMW_CAMERA_SetPipe+0x1f4>
  {
    if (p_conf->enable_gamma_conversion)
3419ad64:	687b      	ldr	r3, [r7, #4]
3419ad66:	695b      	ldr	r3, [r3, #20]
3419ad68:	2b00      	cmp	r3, #0
3419ad6a:	d00b      	beq.n	3419ad84 <CMW_CAMERA_SetPipe+0x1dc>
    {
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
3419ad6c:	68b9      	ldr	r1, [r7, #8]
3419ad6e:	68f8      	ldr	r0, [r7, #12]
3419ad70:	f7ec f948 	bl	34187004 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3419ad74:	4603      	mov	r3, r0
3419ad76:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419ad78:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad7a:	2b00      	cmp	r3, #0
3419ad7c:	d00e      	beq.n	3419ad9c <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419ad7e:	f06f 0304 	mvn.w	r3, #4
3419ad82:	e067      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
    else
    {
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
3419ad84:	68b9      	ldr	r1, [r7, #8]
3419ad86:	68f8      	ldr	r0, [r7, #12]
3419ad88:	f7ec f96b 	bl	34187062 <HAL_DCMIPP_PIPE_DisableGammaConversion>
3419ad8c:	4603      	mov	r3, r0
3419ad8e:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419ad90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ad92:	2b00      	cmp	r3, #0
3419ad94:	d002      	beq.n	3419ad9c <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419ad96:	f06f 0304 	mvn.w	r3, #4
3419ad9a:	e05b      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
3419ad9c:	68bb      	ldr	r3, [r7, #8]
3419ad9e:	2b02      	cmp	r3, #2
3419ada0:	d114      	bne.n	3419adcc <CMW_CAMERA_SetPipe+0x224>
  {
    if (!is_pipe1_2_shared)
3419ada2:	4b2f      	ldr	r3, [pc, #188]	@ (3419ae60 <CMW_CAMERA_SetPipe+0x2b8>)
3419ada4:	681b      	ldr	r3, [r3, #0]
3419ada6:	2b00      	cmp	r3, #0
3419ada8:	d110      	bne.n	3419adcc <CMW_CAMERA_SetPipe+0x224>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
3419adaa:	68b9      	ldr	r1, [r7, #8]
3419adac:	68f8      	ldr	r0, [r7, #12]
3419adae:	f7ed f86f 	bl	34187e90 <HAL_DCMIPP_PIPE_CSI_EnableShare>
3419adb2:	4603      	mov	r3, r0
3419adb4:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419adb6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419adb8:	2b00      	cmp	r3, #0
3419adba:	d002      	beq.n	3419adc2 <CMW_CAMERA_SetPipe+0x21a>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419adbc:	f06f 0304 	mvn.w	r3, #4
3419adc0:	e048      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
      }
      is_pipe1_2_shared++;
3419adc2:	4b27      	ldr	r3, [pc, #156]	@ (3419ae60 <CMW_CAMERA_SetPipe+0x2b8>)
3419adc4:	681b      	ldr	r3, [r3, #0]
3419adc6:	3301      	adds	r3, #1
3419adc8:	4a25      	ldr	r2, [pc, #148]	@ (3419ae60 <CMW_CAMERA_SetPipe+0x2b8>)
3419adca:	6013      	str	r3, [r2, #0]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3419adcc:	2300      	movs	r3, #0
3419adce:	643b      	str	r3, [r7, #64]	@ 0x40
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3419add0:	687b      	ldr	r3, [r7, #4]
3419add2:	681b      	ldr	r3, [r3, #0]
3419add4:	687a      	ldr	r2, [r7, #4]
3419add6:	68d2      	ldr	r2, [r2, #12]
3419add8:	fb02 f303 	mul.w	r3, r2, r3
3419addc:	647b      	str	r3, [r7, #68]	@ 0x44
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3419adde:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419ade0:	330f      	adds	r3, #15
3419ade2:	f023 030f 	bic.w	r3, r3, #15
3419ade6:	647b      	str	r3, [r7, #68]	@ 0x44
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3419ade8:	687b      	ldr	r3, [r7, #4]
3419adea:	689b      	ldr	r3, [r3, #8]
3419adec:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3419adee:	4a1d      	ldr	r2, [pc, #116]	@ (3419ae64 <CMW_CAMERA_SetPipe+0x2bc>)
3419adf0:	68bb      	ldr	r3, [r7, #8]
3419adf2:	4413      	add	r3, r2
3419adf4:	3305      	adds	r3, #5
3419adf6:	781b      	ldrb	r3, [r3, #0]
3419adf8:	b2db      	uxtb	r3, r3
3419adfa:	2b00      	cmp	r3, #0
3419adfc:	d10e      	bne.n	3419ae1c <CMW_CAMERA_SetPipe+0x274>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3419adfe:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419ae02:	461a      	mov	r2, r3
3419ae04:	68b9      	ldr	r1, [r7, #8]
3419ae06:	68f8      	ldr	r0, [r7, #12]
3419ae08:	f7ea febe 	bl	34185b88 <HAL_DCMIPP_PIPE_SetConfig>
3419ae0c:	4603      	mov	r3, r0
3419ae0e:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419ae10:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419ae12:	2b00      	cmp	r3, #0
3419ae14:	d01a      	beq.n	3419ae4c <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ae16:	f06f 0304 	mvn.w	r3, #4
3419ae1a:	e01b      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
3419ae1c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419ae1e:	461a      	mov	r2, r3
3419ae20:	68b9      	ldr	r1, [r7, #8]
3419ae22:	68f8      	ldr	r0, [r7, #12]
3419ae24:	f7ec ff98 	bl	34187d58 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
3419ae28:	4603      	mov	r3, r0
3419ae2a:	2b00      	cmp	r3, #0
3419ae2c:	d002      	beq.n	3419ae34 <CMW_CAMERA_SetPipe+0x28c>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ae2e:	f06f 0304 	mvn.w	r3, #4
3419ae32:	e00f      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3419ae34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419ae36:	461a      	mov	r2, r3
3419ae38:	68b9      	ldr	r1, [r7, #8]
3419ae3a:	68f8      	ldr	r0, [r7, #12]
3419ae3c:	f7ec ff54 	bl	34187ce8 <HAL_DCMIPP_PIPE_SetPitch>
3419ae40:	4603      	mov	r3, r0
3419ae42:	2b00      	cmp	r3, #0
3419ae44:	d002      	beq.n	3419ae4c <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419ae46:	f06f 0304 	mvn.w	r3, #4
3419ae4a:	e003      	b.n	3419ae54 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
3419ae4c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419ae4e:	683b      	ldr	r3, [r7, #0]
3419ae50:	601a      	str	r2, [r3, #0]

  return HAL_OK;
3419ae52:	2300      	movs	r3, #0
}
3419ae54:	4618      	mov	r0, r3
3419ae56:	3758      	adds	r7, #88	@ 0x58
3419ae58:	46bd      	mov	sp, r7
3419ae5a:	bd80      	pop	{r7, pc}
3419ae5c:	341c1814 	.word	0x341c1814
3419ae60:	341c1a28 	.word	0x341c1a28
3419ae64:	341c1870 	.word	0x341c1870

3419ae68 <CMW_UTILS_GetPipeConfig>:
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down);

void CMW_UTILS_GetPipeConfig(uint32_t cam_width, uint32_t cam_height, CMW_DCMIPP_Conf_t *p_conf,
                             DCMIPP_CropConfTypeDef *crop, DCMIPP_DecimationConfTypeDef *dec,
                             DCMIPP_DownsizeTypeDef *down)
{
3419ae68:	b580      	push	{r7, lr}
3419ae6a:	b088      	sub	sp, #32
3419ae6c:	af02      	add	r7, sp, #8
3419ae6e:	60f8      	str	r0, [r7, #12]
3419ae70:	60b9      	str	r1, [r7, #8]
3419ae72:	607a      	str	r2, [r7, #4]
3419ae74:	603b      	str	r3, [r7, #0]
  float ratio_height = 0;
3419ae76:	f04f 0300 	mov.w	r3, #0
3419ae7a:	617b      	str	r3, [r7, #20]
  float ratio_width = 0;
3419ae7c:	f04f 0300 	mov.w	r3, #0
3419ae80:	613b      	str	r3, [r7, #16]

  if (p_conf->mode == CMW_Aspect_ratio_crop)
3419ae82:	687b      	ldr	r3, [r7, #4]
3419ae84:	699b      	ldr	r3, [r3, #24]
3419ae86:	2b00      	cmp	r3, #0
3419ae88:	d12b      	bne.n	3419aee2 <CMW_UTILS_GetPipeConfig+0x7a>
  {
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
3419ae8a:	687b      	ldr	r3, [r7, #4]
3419ae8c:	681a      	ldr	r2, [r3, #0]
3419ae8e:	687b      	ldr	r3, [r7, #4]
3419ae90:	6859      	ldr	r1, [r3, #4]
3419ae92:	683b      	ldr	r3, [r7, #0]
3419ae94:	9300      	str	r3, [sp, #0]
3419ae96:	460b      	mov	r3, r1
3419ae98:	68b9      	ldr	r1, [r7, #8]
3419ae9a:	68f8      	ldr	r0, [r7, #12]
3419ae9c:	f000 f88e 	bl	3419afbc <CMW_UTILS_get_crop_config>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3419aea0:	683b      	ldr	r3, [r7, #0]
3419aea2:	68db      	ldr	r3, [r3, #12]
3419aea4:	ee07 3a90 	vmov	s15, r3
3419aea8:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419aeac:	687b      	ldr	r3, [r7, #4]
3419aeae:	681b      	ldr	r3, [r3, #0]
3419aeb0:	ee07 3a90 	vmov	s15, r3
3419aeb4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419aeb8:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419aebc:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3419aec0:	683b      	ldr	r3, [r7, #0]
3419aec2:	689b      	ldr	r3, [r3, #8]
3419aec4:	ee07 3a90 	vmov	s15, r3
3419aec8:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419aecc:	687b      	ldr	r3, [r7, #4]
3419aece:	685b      	ldr	r3, [r3, #4]
3419aed0:	ee07 3a90 	vmov	s15, r3
3419aed4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419aed8:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419aedc:	edc7 7a05 	vstr	s15, [r7, #20]
3419aee0:	e05e      	b.n	3419afa0 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
3419aee2:	687b      	ldr	r3, [r7, #4]
3419aee4:	699b      	ldr	r3, [r3, #24]
3419aee6:	2b01      	cmp	r3, #1
3419aee8:	d11e      	bne.n	3419af28 <CMW_UTILS_GetPipeConfig+0xc0>
  {
    ratio_width = (float)cam_width / p_conf->output_width;
3419aeea:	68fb      	ldr	r3, [r7, #12]
3419aeec:	ee07 3a90 	vmov	s15, r3
3419aef0:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419aef4:	687b      	ldr	r3, [r7, #4]
3419aef6:	681b      	ldr	r3, [r3, #0]
3419aef8:	ee07 3a90 	vmov	s15, r3
3419aefc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419af00:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419af04:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)cam_height / p_conf->output_height;
3419af08:	68bb      	ldr	r3, [r7, #8]
3419af0a:	ee07 3a90 	vmov	s15, r3
3419af0e:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419af12:	687b      	ldr	r3, [r7, #4]
3419af14:	685b      	ldr	r3, [r3, #4]
3419af16:	ee07 3a90 	vmov	s15, r3
3419af1a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419af1e:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419af22:	edc7 7a05 	vstr	s15, [r7, #20]
3419af26:	e03b      	b.n	3419afa0 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
3419af28:	687b      	ldr	r3, [r7, #4]
3419af2a:	699b      	ldr	r3, [r3, #24]
3419af2c:	2b02      	cmp	r3, #2
3419af2e:	d111      	bne.n	3419af54 <CMW_UTILS_GetPipeConfig+0xec>
  {
    ratio_height = (float) cam_height / p_conf->output_height;
3419af30:	68bb      	ldr	r3, [r7, #8]
3419af32:	ee07 3a90 	vmov	s15, r3
3419af36:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419af3a:	687b      	ldr	r3, [r7, #4]
3419af3c:	685b      	ldr	r3, [r3, #4]
3419af3e:	ee07 3a90 	vmov	s15, r3
3419af42:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419af46:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419af4a:	edc7 7a05 	vstr	s15, [r7, #20]
    ratio_width = (float) ratio_height;
3419af4e:	697b      	ldr	r3, [r7, #20]
3419af50:	613b      	str	r3, [r7, #16]
3419af52:	e025      	b.n	3419afa0 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else
  {
    CMW_UTILS_get_crop_config_from_manual(&p_conf->manual_conf, crop);
3419af54:	687b      	ldr	r3, [r7, #4]
3419af56:	331c      	adds	r3, #28
3419af58:	6839      	ldr	r1, [r7, #0]
3419af5a:	4618      	mov	r0, r3
3419af5c:	f000 f8f0 	bl	3419b140 <CMW_UTILS_get_crop_config_from_manual>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3419af60:	683b      	ldr	r3, [r7, #0]
3419af62:	68db      	ldr	r3, [r3, #12]
3419af64:	ee07 3a90 	vmov	s15, r3
3419af68:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419af6c:	687b      	ldr	r3, [r7, #4]
3419af6e:	681b      	ldr	r3, [r3, #0]
3419af70:	ee07 3a90 	vmov	s15, r3
3419af74:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419af78:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419af7c:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3419af80:	683b      	ldr	r3, [r7, #0]
3419af82:	689b      	ldr	r3, [r3, #8]
3419af84:	ee07 3a90 	vmov	s15, r3
3419af88:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419af8c:	687b      	ldr	r3, [r7, #4]
3419af8e:	685b      	ldr	r3, [r3, #4]
3419af90:	ee07 3a90 	vmov	s15, r3
3419af94:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419af98:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419af9c:	edc7 7a05 	vstr	s15, [r7, #20]
  }

  CMW_UTILS_get_scale_configs(p_conf, ratio_width, ratio_height, dec, down);
3419afa0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419afa2:	6a39      	ldr	r1, [r7, #32]
3419afa4:	edd7 0a05 	vldr	s1, [r7, #20]
3419afa8:	ed97 0a04 	vldr	s0, [r7, #16]
3419afac:	6878      	ldr	r0, [r7, #4]
3419afae:	f000 f98f 	bl	3419b2d0 <CMW_UTILS_get_scale_configs>
}
3419afb2:	bf00      	nop
3419afb4:	3718      	adds	r7, #24
3419afb6:	46bd      	mov	sp, r7
3419afb8:	bd80      	pop	{r7, pc}
	...

3419afbc <CMW_UTILS_get_crop_config>:

static void CMW_UTILS_get_crop_config(uint32_t cam_width, uint32_t cam_height, uint32_t pipe_width, uint32_t pipe_height, DCMIPP_CropConfTypeDef *crop)
{
3419afbc:	b580      	push	{r7, lr}
3419afbe:	b088      	sub	sp, #32
3419afc0:	af00      	add	r7, sp, #0
3419afc2:	60f8      	str	r0, [r7, #12]
3419afc4:	60b9      	str	r1, [r7, #8]
3419afc6:	607a      	str	r2, [r7, #4]
3419afc8:	603b      	str	r3, [r7, #0]
  const float ratio_width = (float)cam_width / pipe_width ;
3419afca:	68fb      	ldr	r3, [r7, #12]
3419afcc:	ee07 3a90 	vmov	s15, r3
3419afd0:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419afd4:	687b      	ldr	r3, [r7, #4]
3419afd6:	ee07 3a90 	vmov	s15, r3
3419afda:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419afde:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419afe2:	edc7 7a07 	vstr	s15, [r7, #28]
  const float ratio_height = (float)cam_height / pipe_height;
3419afe6:	68bb      	ldr	r3, [r7, #8]
3419afe8:	ee07 3a90 	vmov	s15, r3
3419afec:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419aff0:	683b      	ldr	r3, [r7, #0]
3419aff2:	ee07 3a90 	vmov	s15, r3
3419aff6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419affa:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419affe:	edc7 7a06 	vstr	s15, [r7, #24]
  const float ratio = MIN(ratio_width, ratio_height);
3419b002:	ed97 7a07 	vldr	s14, [r7, #28]
3419b006:	edd7 7a06 	vldr	s15, [r7, #24]
3419b00a:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419b00e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b012:	d501      	bpl.n	3419b018 <CMW_UTILS_get_crop_config+0x5c>
3419b014:	69fb      	ldr	r3, [r7, #28]
3419b016:	e000      	b.n	3419b01a <CMW_UTILS_get_crop_config+0x5e>
3419b018:	69bb      	ldr	r3, [r7, #24]
3419b01a:	617b      	str	r3, [r7, #20]

  assert(ratio >= 1);
3419b01c:	edd7 7a05 	vldr	s15, [r7, #20]
3419b020:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3419b024:	eef4 7ac7 	vcmpe.f32	s15, s14
3419b028:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b02c:	da05      	bge.n	3419b03a <CMW_UTILS_get_crop_config+0x7e>
3419b02e:	4b3f      	ldr	r3, [pc, #252]	@ (3419b12c <CMW_UTILS_get_crop_config+0x170>)
3419b030:	4a3f      	ldr	r2, [pc, #252]	@ (3419b130 <CMW_UTILS_get_crop_config+0x174>)
3419b032:	214f      	movs	r1, #79	@ 0x4f
3419b034:	483f      	ldr	r0, [pc, #252]	@ (3419b134 <CMW_UTILS_get_crop_config+0x178>)
3419b036:	f008 fc2b 	bl	341a3890 <__assert_func>
  assert(ratio < 64);
3419b03a:	edd7 7a05 	vldr	s15, [r7, #20]
3419b03e:	ed9f 7a3e 	vldr	s14, [pc, #248]	@ 3419b138 <CMW_UTILS_get_crop_config+0x17c>
3419b042:	eef4 7ac7 	vcmpe.f32	s15, s14
3419b046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b04a:	d405      	bmi.n	3419b058 <CMW_UTILS_get_crop_config+0x9c>
3419b04c:	4b3b      	ldr	r3, [pc, #236]	@ (3419b13c <CMW_UTILS_get_crop_config+0x180>)
3419b04e:	4a38      	ldr	r2, [pc, #224]	@ (3419b130 <CMW_UTILS_get_crop_config+0x174>)
3419b050:	2150      	movs	r1, #80	@ 0x50
3419b052:	4838      	ldr	r0, [pc, #224]	@ (3419b134 <CMW_UTILS_get_crop_config+0x178>)
3419b054:	f008 fc1c 	bl	341a3890 <__assert_func>

  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3419b058:	687b      	ldr	r3, [r7, #4]
3419b05a:	ee07 3a90 	vmov	s15, r3
3419b05e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419b062:	edd7 7a05 	vldr	s15, [r7, #20]
3419b066:	ee27 7a27 	vmul.f32	s14, s14, s15
3419b06a:	68fb      	ldr	r3, [r7, #12]
3419b06c:	ee07 3a90 	vmov	s15, r3
3419b070:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419b074:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419b078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b07c:	d50b      	bpl.n	3419b096 <CMW_UTILS_get_crop_config+0xda>
3419b07e:	687b      	ldr	r3, [r7, #4]
3419b080:	ee07 3a90 	vmov	s15, r3
3419b084:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419b088:	edd7 7a05 	vldr	s15, [r7, #20]
3419b08c:	ee67 7a27 	vmul.f32	s15, s14, s15
3419b090:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b094:	e006      	b.n	3419b0a4 <CMW_UTILS_get_crop_config+0xe8>
3419b096:	68fb      	ldr	r3, [r7, #12]
3419b098:	ee07 3a90 	vmov	s15, r3
3419b09c:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419b0a0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b0a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b0a6:	edc3 7a03 	vstr	s15, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3419b0aa:	683b      	ldr	r3, [r7, #0]
3419b0ac:	ee07 3a90 	vmov	s15, r3
3419b0b0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419b0b4:	edd7 7a05 	vldr	s15, [r7, #20]
3419b0b8:	ee27 7a27 	vmul.f32	s14, s14, s15
3419b0bc:	68bb      	ldr	r3, [r7, #8]
3419b0be:	ee07 3a90 	vmov	s15, r3
3419b0c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419b0c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419b0ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b0ce:	d50b      	bpl.n	3419b0e8 <CMW_UTILS_get_crop_config+0x12c>
3419b0d0:	683b      	ldr	r3, [r7, #0]
3419b0d2:	ee07 3a90 	vmov	s15, r3
3419b0d6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419b0da:	edd7 7a05 	vldr	s15, [r7, #20]
3419b0de:	ee67 7a27 	vmul.f32	s15, s14, s15
3419b0e2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b0e6:	e006      	b.n	3419b0f6 <CMW_UTILS_get_crop_config+0x13a>
3419b0e8:	68bb      	ldr	r3, [r7, #8]
3419b0ea:	ee07 3a90 	vmov	s15, r3
3419b0ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419b0f2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b0f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b0f8:	edc3 7a02 	vstr	s15, [r3, #8]
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
3419b0fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b0fe:	68db      	ldr	r3, [r3, #12]
3419b100:	68fa      	ldr	r2, [r7, #12]
3419b102:	1ad3      	subs	r3, r2, r3
3419b104:	3301      	adds	r3, #1
3419b106:	085a      	lsrs	r2, r3, #1
3419b108:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b10a:	605a      	str	r2, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3419b10c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b10e:	689b      	ldr	r3, [r3, #8]
3419b110:	68ba      	ldr	r2, [r7, #8]
3419b112:	1ad3      	subs	r3, r2, r3
3419b114:	3301      	adds	r3, #1
3419b116:	085a      	lsrs	r2, r3, #1
3419b118:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b11a:	601a      	str	r2, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
3419b11c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b11e:	2200      	movs	r2, #0
3419b120:	611a      	str	r2, [r3, #16]
}
3419b122:	bf00      	nop
3419b124:	3720      	adds	r7, #32
3419b126:	46bd      	mov	sp, r7
3419b128:	bd80      	pop	{r7, pc}
3419b12a:	bf00      	nop
3419b12c:	341a5f3c 	.word	0x341a5f3c
3419b130:	341b0f78 	.word	0x341b0f78
3419b134:	341a5f48 	.word	0x341a5f48
3419b138:	42800000 	.word	0x42800000
3419b13c:	341a5f78 	.word	0x341a5f78

3419b140 <CMW_UTILS_get_crop_config_from_manual>:

static void CMW_UTILS_get_crop_config_from_manual(CMW_Manual_roi_area_t *roi, DCMIPP_CropConfTypeDef *crop)
{
3419b140:	b480      	push	{r7}
3419b142:	b083      	sub	sp, #12
3419b144:	af00      	add	r7, sp, #0
3419b146:	6078      	str	r0, [r7, #4]
3419b148:	6039      	str	r1, [r7, #0]
  crop->HSize = roi->width;
3419b14a:	687b      	ldr	r3, [r7, #4]
3419b14c:	681a      	ldr	r2, [r3, #0]
3419b14e:	683b      	ldr	r3, [r7, #0]
3419b150:	60da      	str	r2, [r3, #12]
  crop->VSize = roi->height;
3419b152:	687b      	ldr	r3, [r7, #4]
3419b154:	685a      	ldr	r2, [r3, #4]
3419b156:	683b      	ldr	r3, [r7, #0]
3419b158:	609a      	str	r2, [r3, #8]
  crop->HStart = roi->offset_x;
3419b15a:	687b      	ldr	r3, [r7, #4]
3419b15c:	689a      	ldr	r2, [r3, #8]
3419b15e:	683b      	ldr	r3, [r7, #0]
3419b160:	605a      	str	r2, [r3, #4]
  crop->VStart = roi->offset_y;
3419b162:	687b      	ldr	r3, [r7, #4]
3419b164:	68da      	ldr	r2, [r3, #12]
3419b166:	683b      	ldr	r3, [r7, #0]
3419b168:	601a      	str	r2, [r3, #0]
}
3419b16a:	bf00      	nop
3419b16c:	370c      	adds	r7, #12
3419b16e:	46bd      	mov	sp, r7
3419b170:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b174:	4770      	bx	lr
	...

3419b178 <CMW_UTILS_get_down_config>:

static void CMW_UTILS_get_down_config(float ratio_width, float ratio_height, int width, int height, DCMIPP_DownsizeTypeDef *down)
{
3419b178:	b480      	push	{r7}
3419b17a:	b087      	sub	sp, #28
3419b17c:	af00      	add	r7, sp, #0
3419b17e:	ed87 0a05 	vstr	s0, [r7, #20]
3419b182:	edc7 0a04 	vstr	s1, [r7, #16]
3419b186:	60f8      	str	r0, [r7, #12]
3419b188:	60b9      	str	r1, [r7, #8]
3419b18a:	607a      	str	r2, [r7, #4]
  down->HRatio = (uint32_t) (8192 * ratio_width);
3419b18c:	edd7 7a05 	vldr	s15, [r7, #20]
3419b190:	ed9f 7a17 	vldr	s14, [pc, #92]	@ 3419b1f0 <CMW_UTILS_get_down_config+0x78>
3419b194:	ee67 7a87 	vmul.f32	s15, s15, s14
3419b198:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b19c:	ee17 2a90 	vmov	r2, s15
3419b1a0:	687b      	ldr	r3, [r7, #4]
3419b1a2:	60da      	str	r2, [r3, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
3419b1a4:	edd7 7a04 	vldr	s15, [r7, #16]
3419b1a8:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 3419b1f0 <CMW_UTILS_get_down_config+0x78>
3419b1ac:	ee67 7a87 	vmul.f32	s15, s15, s14
3419b1b0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419b1b4:	ee17 2a90 	vmov	r2, s15
3419b1b8:	687b      	ldr	r3, [r7, #4]
3419b1ba:	609a      	str	r2, [r3, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3419b1bc:	687b      	ldr	r3, [r7, #4]
3419b1be:	68db      	ldr	r3, [r3, #12]
3419b1c0:	4a0c      	ldr	r2, [pc, #48]	@ (3419b1f4 <CMW_UTILS_get_down_config+0x7c>)
3419b1c2:	fbb2 f2f3 	udiv	r2, r2, r3
3419b1c6:	687b      	ldr	r3, [r7, #4]
3419b1c8:	615a      	str	r2, [r3, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
3419b1ca:	687b      	ldr	r3, [r7, #4]
3419b1cc:	689b      	ldr	r3, [r3, #8]
3419b1ce:	4a09      	ldr	r2, [pc, #36]	@ (3419b1f4 <CMW_UTILS_get_down_config+0x7c>)
3419b1d0:	fbb2 f2f3 	udiv	r2, r2, r3
3419b1d4:	687b      	ldr	r3, [r7, #4]
3419b1d6:	611a      	str	r2, [r3, #16]
  down->HSize = width;
3419b1d8:	68fa      	ldr	r2, [r7, #12]
3419b1da:	687b      	ldr	r3, [r7, #4]
3419b1dc:	605a      	str	r2, [r3, #4]
  down->VSize = height;
3419b1de:	68ba      	ldr	r2, [r7, #8]
3419b1e0:	687b      	ldr	r3, [r7, #4]
3419b1e2:	601a      	str	r2, [r3, #0]
}
3419b1e4:	bf00      	nop
3419b1e6:	371c      	adds	r7, #28
3419b1e8:	46bd      	mov	sp, r7
3419b1ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b1ee:	4770      	bx	lr
3419b1f0:	46000000 	.word	0x46000000
3419b1f4:	007fffff 	.word	0x007fffff

3419b1f8 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>:

static uint32_t CMW_UTILS_get_dec_ratio_from_decimal_ratio(int dec_ratio, int is_vertical)
{
3419b1f8:	b580      	push	{r7, lr}
3419b1fa:	b082      	sub	sp, #8
3419b1fc:	af00      	add	r7, sp, #0
3419b1fe:	6078      	str	r0, [r7, #4]
3419b200:	6039      	str	r1, [r7, #0]
  switch (dec_ratio) {
3419b202:	687b      	ldr	r3, [r7, #4]
3419b204:	3b01      	subs	r3, #1
3419b206:	2b07      	cmp	r3, #7
3419b208:	d829      	bhi.n	3419b25e <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x66>
3419b20a:	a201      	add	r2, pc, #4	@ (adr r2, 3419b210 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x18>)
3419b20c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419b210:	3419b231 	.word	0x3419b231
3419b214:	3419b235 	.word	0x3419b235
3419b218:	3419b25f 	.word	0x3419b25f
3419b21c:	3419b243 	.word	0x3419b243
3419b220:	3419b25f 	.word	0x3419b25f
3419b224:	3419b25f 	.word	0x3419b25f
3419b228:	3419b25f 	.word	0x3419b25f
3419b22c:	3419b251 	.word	0x3419b251
  case 1:
    return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
3419b230:	2300      	movs	r3, #0
3419b232:	e01a      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 2:
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
3419b234:	683b      	ldr	r3, [r7, #0]
3419b236:	2b00      	cmp	r3, #0
3419b238:	d001      	beq.n	3419b23e <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x46>
3419b23a:	2308      	movs	r3, #8
3419b23c:	e015      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419b23e:	2302      	movs	r3, #2
3419b240:	e013      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 4:
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
3419b242:	683b      	ldr	r3, [r7, #0]
3419b244:	2b00      	cmp	r3, #0
3419b246:	d001      	beq.n	3419b24c <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x54>
3419b248:	2310      	movs	r3, #16
3419b24a:	e00e      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419b24c:	2304      	movs	r3, #4
3419b24e:	e00c      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 8:
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
3419b250:	683b      	ldr	r3, [r7, #0]
3419b252:	2b00      	cmp	r3, #0
3419b254:	d001      	beq.n	3419b25a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x62>
3419b256:	2318      	movs	r3, #24
3419b258:	e007      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419b25a:	2306      	movs	r3, #6
3419b25c:	e005      	b.n	3419b26a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  default:
    assert(0);
3419b25e:	4b05      	ldr	r3, [pc, #20]	@ (3419b274 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x7c>)
3419b260:	4a05      	ldr	r2, [pc, #20]	@ (3419b278 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x80>)
3419b262:	2177      	movs	r1, #119	@ 0x77
3419b264:	4805      	ldr	r0, [pc, #20]	@ (3419b27c <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x84>)
3419b266:	f008 fb13 	bl	341a3890 <__assert_func>
  }

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}
3419b26a:	4618      	mov	r0, r3
3419b26c:	3708      	adds	r7, #8
3419b26e:	46bd      	mov	sp, r7
3419b270:	bd80      	pop	{r7, pc}
3419b272:	bf00      	nop
3419b274:	341a5f84 	.word	0x341a5f84
3419b278:	341b0f94 	.word	0x341b0f94
3419b27c:	341a5f48 	.word	0x341a5f48

3419b280 <CMW_UTILS_get_dec_ratio_and_update>:

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
3419b280:	b580      	push	{r7, lr}
3419b282:	b084      	sub	sp, #16
3419b284:	af00      	add	r7, sp, #0
3419b286:	6078      	str	r0, [r7, #4]
3419b288:	6039      	str	r1, [r7, #0]
  int dec_ratio = 1;
3419b28a:	2301      	movs	r3, #1
3419b28c:	60fb      	str	r3, [r7, #12]

  while (*ratio >= 8) {
3419b28e:	e00c      	b.n	3419b2aa <CMW_UTILS_get_dec_ratio_and_update+0x2a>
    dec_ratio *= 2;
3419b290:	68fb      	ldr	r3, [r7, #12]
3419b292:	005b      	lsls	r3, r3, #1
3419b294:	60fb      	str	r3, [r7, #12]
    *ratio /= 2;
3419b296:	687b      	ldr	r3, [r7, #4]
3419b298:	ed93 7a00 	vldr	s14, [r3]
3419b29c:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3419b2a0:	eec7 7a26 	vdiv.f32	s15, s14, s13
3419b2a4:	687b      	ldr	r3, [r7, #4]
3419b2a6:	edc3 7a00 	vstr	s15, [r3]
  while (*ratio >= 8) {
3419b2aa:	687b      	ldr	r3, [r7, #4]
3419b2ac:	edd3 7a00 	vldr	s15, [r3]
3419b2b0:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
3419b2b4:	eef4 7ac7 	vcmpe.f32	s15, s14
3419b2b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419b2bc:	dae8      	bge.n	3419b290 <CMW_UTILS_get_dec_ratio_and_update+0x10>
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
3419b2be:	6839      	ldr	r1, [r7, #0]
3419b2c0:	68f8      	ldr	r0, [r7, #12]
3419b2c2:	f7ff ff99 	bl	3419b1f8 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>
3419b2c6:	4603      	mov	r3, r0
}
3419b2c8:	4618      	mov	r0, r3
3419b2ca:	3710      	adds	r7, #16
3419b2cc:	46bd      	mov	sp, r7
3419b2ce:	bd80      	pop	{r7, pc}

3419b2d0 <CMW_UTILS_get_scale_configs>:

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
3419b2d0:	b580      	push	{r7, lr}
3419b2d2:	b086      	sub	sp, #24
3419b2d4:	af00      	add	r7, sp, #0
3419b2d6:	6178      	str	r0, [r7, #20]
3419b2d8:	ed87 0a04 	vstr	s0, [r7, #16]
3419b2dc:	edc7 0a03 	vstr	s1, [r7, #12]
3419b2e0:	60b9      	str	r1, [r7, #8]
3419b2e2:	607a      	str	r2, [r7, #4]
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
3419b2e4:	f107 0310 	add.w	r3, r7, #16
3419b2e8:	2100      	movs	r1, #0
3419b2ea:	4618      	mov	r0, r3
3419b2ec:	f7ff ffc8 	bl	3419b280 <CMW_UTILS_get_dec_ratio_and_update>
3419b2f0:	4602      	mov	r2, r0
3419b2f2:	68bb      	ldr	r3, [r7, #8]
3419b2f4:	605a      	str	r2, [r3, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3419b2f6:	f107 030c 	add.w	r3, r7, #12
3419b2fa:	2101      	movs	r1, #1
3419b2fc:	4618      	mov	r0, r3
3419b2fe:	f7ff ffbf 	bl	3419b280 <CMW_UTILS_get_dec_ratio_and_update>
3419b302:	4602      	mov	r2, r0
3419b304:	68bb      	ldr	r3, [r7, #8]
3419b306:	601a      	str	r2, [r3, #0]
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
3419b308:	edd7 7a04 	vldr	s15, [r7, #16]
3419b30c:	ed97 7a03 	vldr	s14, [r7, #12]
3419b310:	697b      	ldr	r3, [r7, #20]
3419b312:	681b      	ldr	r3, [r3, #0]
3419b314:	4618      	mov	r0, r3
3419b316:	697b      	ldr	r3, [r7, #20]
3419b318:	685b      	ldr	r3, [r3, #4]
3419b31a:	687a      	ldr	r2, [r7, #4]
3419b31c:	4619      	mov	r1, r3
3419b31e:	eef0 0a47 	vmov.f32	s1, s14
3419b322:	eeb0 0a67 	vmov.f32	s0, s15
3419b326:	f7ff ff27 	bl	3419b178 <CMW_UTILS_get_down_config>
}
3419b32a:	bf00      	nop
3419b32c:	3718      	adds	r7, #24
3419b32e:	46bd      	mov	sp, r7
3419b330:	bd80      	pop	{r7, pc}

3419b332 <CMW_IMX335_GetResType>:

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))


static int CMW_IMX335_GetResType(uint32_t width, uint32_t height, uint32_t*res)
{
3419b332:	b480      	push	{r7}
3419b334:	b085      	sub	sp, #20
3419b336:	af00      	add	r7, sp, #0
3419b338:	60f8      	str	r0, [r7, #12]
3419b33a:	60b9      	str	r1, [r7, #8]
3419b33c:	607a      	str	r2, [r7, #4]
  if (width == 2592 && height == 1944)
3419b33e:	68fb      	ldr	r3, [r7, #12]
3419b340:	f5b3 6f22 	cmp.w	r3, #2592	@ 0xa20
3419b344:	d108      	bne.n	3419b358 <CMW_IMX335_GetResType+0x26>
3419b346:	68bb      	ldr	r3, [r7, #8]
3419b348:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
3419b34c:	d104      	bne.n	3419b358 <CMW_IMX335_GetResType+0x26>
  {
    *res = IMX335_R2592_1944;
3419b34e:	687b      	ldr	r3, [r7, #4]
3419b350:	2206      	movs	r2, #6
3419b352:	601a      	str	r2, [r3, #0]
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
  }
  return 0;
3419b354:	2300      	movs	r3, #0
3419b356:	e001      	b.n	3419b35c <CMW_IMX335_GetResType+0x2a>
    return CMW_ERROR_WRONG_PARAM;
3419b358:	f06f 0301 	mvn.w	r3, #1
}
3419b35c:	4618      	mov	r0, r3
3419b35e:	3714      	adds	r7, #20
3419b360:	46bd      	mov	sp, r7
3419b362:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b366:	4770      	bx	lr

3419b368 <CMW_IMX335_getMirrorFlipConfig>:

static int32_t CMW_IMX335_getMirrorFlipConfig(uint32_t Config)
{
3419b368:	b480      	push	{r7}
3419b36a:	b085      	sub	sp, #20
3419b36c:	af00      	add	r7, sp, #0
3419b36e:	6078      	str	r0, [r7, #4]
  int32_t ret;

  switch (Config)
3419b370:	687b      	ldr	r3, [r7, #4]
3419b372:	2b02      	cmp	r3, #2
3419b374:	d00f      	beq.n	3419b396 <CMW_IMX335_getMirrorFlipConfig+0x2e>
3419b376:	687b      	ldr	r3, [r7, #4]
3419b378:	2b02      	cmp	r3, #2
3419b37a:	d80f      	bhi.n	3419b39c <CMW_IMX335_getMirrorFlipConfig+0x34>
3419b37c:	687b      	ldr	r3, [r7, #4]
3419b37e:	2b00      	cmp	r3, #0
3419b380:	d003      	beq.n	3419b38a <CMW_IMX335_getMirrorFlipConfig+0x22>
3419b382:	687b      	ldr	r3, [r7, #4]
3419b384:	2b01      	cmp	r3, #1
3419b386:	d003      	beq.n	3419b390 <CMW_IMX335_getMirrorFlipConfig+0x28>
3419b388:	e008      	b.n	3419b39c <CMW_IMX335_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = IMX335_MIRROR_FLIP_NONE;
3419b38a:	2300      	movs	r3, #0
3419b38c:	60fb      	str	r3, [r7, #12]
      break;
3419b38e:	e008      	b.n	3419b3a2 <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = IMX335_FLIP;
3419b390:	2301      	movs	r3, #1
3419b392:	60fb      	str	r3, [r7, #12]
      break;
3419b394:	e005      	b.n	3419b3a2 <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = IMX335_MIRROR;
3419b396:	2302      	movs	r3, #2
3419b398:	60fb      	str	r3, [r7, #12]
      break;
3419b39a:	e002      	b.n	3419b3a2 <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = IMX335_MIRROR_FLIP;
3419b39c:	2303      	movs	r3, #3
3419b39e:	60fb      	str	r3, [r7, #12]
      break;
3419b3a0:	bf00      	nop
  }

  return ret;
3419b3a2:	68fb      	ldr	r3, [r7, #12]
}
3419b3a4:	4618      	mov	r0, r3
3419b3a6:	3714      	adds	r7, #20
3419b3a8:	46bd      	mov	sp, r7
3419b3aa:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b3ae:	4770      	bx	lr

3419b3b0 <CMW_IMX335_DeInit>:

static int32_t CMW_IMX335_DeInit(void *io_ctx)
{
3419b3b0:	b580      	push	{r7, lr}
3419b3b2:	b084      	sub	sp, #16
3419b3b4:	af00      	add	r7, sp, #0
3419b3b6:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419b3b8:	2300      	movs	r3, #0
3419b3ba:	60fb      	str	r3, [r7, #12]
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b3bc:	687b      	ldr	r3, [r7, #4]
3419b3be:	3330      	adds	r3, #48	@ 0x30
3419b3c0:	4618      	mov	r0, r3
3419b3c2:	f7fc fee5 	bl	34198190 <ISP_DeInit>
3419b3c6:	4603      	mov	r3, r0
3419b3c8:	60fb      	str	r3, [r7, #12]
  if (ret)
3419b3ca:	68fb      	ldr	r3, [r7, #12]
3419b3cc:	2b00      	cmp	r3, #0
3419b3ce:	d002      	beq.n	3419b3d6 <CMW_IMX335_DeInit+0x26>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b3d0:	f06f 0304 	mvn.w	r3, #4
3419b3d4:	e00c      	b.n	3419b3f0 <CMW_IMX335_DeInit+0x40>
  }

  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3419b3d6:	687b      	ldr	r3, [r7, #4]
3419b3d8:	3308      	adds	r3, #8
3419b3da:	4618      	mov	r0, r3
3419b3dc:	f001 ff62 	bl	3419d2a4 <IMX335_DeInit>
3419b3e0:	60f8      	str	r0, [r7, #12]
  if (ret)
3419b3e2:	68fb      	ldr	r3, [r7, #12]
3419b3e4:	2b00      	cmp	r3, #0
3419b3e6:	d002      	beq.n	3419b3ee <CMW_IMX335_DeInit+0x3e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b3e8:	f06f 0304 	mvn.w	r3, #4
3419b3ec:	e000      	b.n	3419b3f0 <CMW_IMX335_DeInit+0x40>
  }
  return ret;
3419b3ee:	68fb      	ldr	r3, [r7, #12]
}
3419b3f0:	4618      	mov	r0, r3
3419b3f2:	3710      	adds	r7, #16
3419b3f4:	46bd      	mov	sp, r7
3419b3f6:	bd80      	pop	{r7, pc}

3419b3f8 <CMW_IMX335_ReadID>:

static int32_t CMW_IMX335_ReadID(void *io_ctx, uint32_t *Id)
{
3419b3f8:	b580      	push	{r7, lr}
3419b3fa:	b082      	sub	sp, #8
3419b3fc:	af00      	add	r7, sp, #0
3419b3fe:	6078      	str	r0, [r7, #4]
3419b400:	6039      	str	r1, [r7, #0]
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
3419b402:	687b      	ldr	r3, [r7, #4]
3419b404:	3308      	adds	r3, #8
3419b406:	6839      	ldr	r1, [r7, #0]
3419b408:	4618      	mov	r0, r3
3419b40a:	f001 ff5f 	bl	3419d2cc <IMX335_ReadID>
3419b40e:	4603      	mov	r3, r0
}
3419b410:	4618      	mov	r0, r3
3419b412:	3708      	adds	r7, #8
3419b414:	46bd      	mov	sp, r7
3419b416:	bd80      	pop	{r7, pc}

3419b418 <CMW_IMX335_SetGain>:

static int32_t CMW_IMX335_SetGain(void *io_ctx, int32_t gain)
{
3419b418:	b580      	push	{r7, lr}
3419b41a:	b082      	sub	sp, #8
3419b41c:	af00      	add	r7, sp, #0
3419b41e:	6078      	str	r0, [r7, #4]
3419b420:	6039      	str	r1, [r7, #0]
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
3419b422:	687b      	ldr	r3, [r7, #4]
3419b424:	3308      	adds	r3, #8
3419b426:	6839      	ldr	r1, [r7, #0]
3419b428:	4618      	mov	r0, r3
3419b42a:	f001 ff73 	bl	3419d314 <IMX335_SetGain>
3419b42e:	4603      	mov	r3, r0
}
3419b430:	4618      	mov	r0, r3
3419b432:	3708      	adds	r7, #8
3419b434:	46bd      	mov	sp, r7
3419b436:	bd80      	pop	{r7, pc}

3419b438 <CMW_IMX335_SetExposure>:

static int32_t CMW_IMX335_SetExposure(void *io_ctx, int32_t exposure)
{
3419b438:	b580      	push	{r7, lr}
3419b43a:	b082      	sub	sp, #8
3419b43c:	af00      	add	r7, sp, #0
3419b43e:	6078      	str	r0, [r7, #4]
3419b440:	6039      	str	r1, [r7, #0]
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
3419b442:	687b      	ldr	r3, [r7, #4]
3419b444:	3308      	adds	r3, #8
3419b446:	6839      	ldr	r1, [r7, #0]
3419b448:	4618      	mov	r0, r3
3419b44a:	f001 ffbb 	bl	3419d3c4 <IMX335_SetExposure>
3419b44e:	4603      	mov	r3, r0
}
3419b450:	4618      	mov	r0, r3
3419b452:	3708      	adds	r7, #8
3419b454:	46bd      	mov	sp, r7
3419b456:	bd80      	pop	{r7, pc}

3419b458 <CMW_IMX335_SetWBRefMode>:
  * @param  Automatic automatic mode enable/disable
  * @param  RefColorTemp color temperature if automatic mode is disabled
  * @retval Component status
  */
int32_t CMW_IMX335_SetWBRefMode(void *io_ctx, uint8_t Automatic, uint32_t RefColorTemp)
{
3419b458:	b580      	push	{r7, lr}
3419b45a:	b086      	sub	sp, #24
3419b45c:	af00      	add	r7, sp, #0
3419b45e:	60f8      	str	r0, [r7, #12]
3419b460:	460b      	mov	r3, r1
3419b462:	607a      	str	r2, [r7, #4]
3419b464:	72fb      	strb	r3, [r7, #11]
  int ret = CMW_ERROR_NONE;
3419b466:	2300      	movs	r3, #0
3419b468:	617b      	str	r3, [r7, #20]

  ret = ISP_SetWBRefMode(&((CMW_IMX335_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
3419b46a:	68fb      	ldr	r3, [r7, #12]
3419b46c:	3330      	adds	r3, #48	@ 0x30
3419b46e:	7af9      	ldrb	r1, [r7, #11]
3419b470:	687a      	ldr	r2, [r7, #4]
3419b472:	4618      	mov	r0, r3
3419b474:	f7fc ffec 	bl	34198450 <ISP_SetWBRefMode>
3419b478:	4603      	mov	r3, r0
3419b47a:	617b      	str	r3, [r7, #20]
  if (ret)
3419b47c:	697b      	ldr	r3, [r7, #20]
3419b47e:	2b00      	cmp	r3, #0
3419b480:	d002      	beq.n	3419b488 <CMW_IMX335_SetWBRefMode+0x30>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419b482:	f06f 0303 	mvn.w	r3, #3
3419b486:	e000      	b.n	3419b48a <CMW_IMX335_SetWBRefMode+0x32>
  }

  return CMW_ERROR_NONE;
3419b488:	2300      	movs	r3, #0
}
3419b48a:	4618      	mov	r0, r3
3419b48c:	3718      	adds	r7, #24
3419b48e:	46bd      	mov	sp, r7
3419b490:	bd80      	pop	{r7, pc}

3419b492 <CMW_IMX335_ListWBRefModes>:
  * @param  io_ctx  pointer to component object
  * @param  RefColorTemp color temperature list
  * @retval Component status
  */
int32_t CMW_IMX335_ListWBRefModes(void *io_ctx, uint32_t RefColorTemp[])
{
3419b492:	b580      	push	{r7, lr}
3419b494:	b084      	sub	sp, #16
3419b496:	af00      	add	r7, sp, #0
3419b498:	6078      	str	r0, [r7, #4]
3419b49a:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419b49c:	2300      	movs	r3, #0
3419b49e:	60fb      	str	r3, [r7, #12]

  ret = ISP_ListWBRefModes(&((CMW_IMX335_t *)io_ctx)->hIsp, RefColorTemp);
3419b4a0:	687b      	ldr	r3, [r7, #4]
3419b4a2:	3330      	adds	r3, #48	@ 0x30
3419b4a4:	6839      	ldr	r1, [r7, #0]
3419b4a6:	4618      	mov	r0, r3
3419b4a8:	f7fc ffbc 	bl	34198424 <ISP_ListWBRefModes>
3419b4ac:	4603      	mov	r3, r0
3419b4ae:	60fb      	str	r3, [r7, #12]
  if (ret)
3419b4b0:	68fb      	ldr	r3, [r7, #12]
3419b4b2:	2b00      	cmp	r3, #0
3419b4b4:	d002      	beq.n	3419b4bc <CMW_IMX335_ListWBRefModes+0x2a>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419b4b6:	f06f 0303 	mvn.w	r3, #3
3419b4ba:	e000      	b.n	3419b4be <CMW_IMX335_ListWBRefModes+0x2c>
  }

  return CMW_ERROR_NONE;
3419b4bc:	2300      	movs	r3, #0
}
3419b4be:	4618      	mov	r0, r3
3419b4c0:	3710      	adds	r7, #16
3419b4c2:	46bd      	mov	sp, r7
3419b4c4:	bd80      	pop	{r7, pc}

3419b4c6 <CMW_IMX335_SetFrequency>:

static int32_t CMW_IMX335_SetFrequency(void *io_ctx, int32_t frequency)
{
3419b4c6:	b580      	push	{r7, lr}
3419b4c8:	b082      	sub	sp, #8
3419b4ca:	af00      	add	r7, sp, #0
3419b4cc:	6078      	str	r0, [r7, #4]
3419b4ce:	6039      	str	r1, [r7, #0]
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
3419b4d0:	687b      	ldr	r3, [r7, #4]
3419b4d2:	3308      	adds	r3, #8
3419b4d4:	6839      	ldr	r1, [r7, #0]
3419b4d6:	4618      	mov	r0, r3
3419b4d8:	f001 ffe6 	bl	3419d4a8 <IMX335_SetFrequency>
3419b4dc:	4603      	mov	r3, r0
}
3419b4de:	4618      	mov	r0, r3
3419b4e0:	3708      	adds	r7, #8
3419b4e2:	46bd      	mov	sp, r7
3419b4e4:	bd80      	pop	{r7, pc}
	...

3419b4e8 <CMW_IMX335_SetFramerate>:

static int32_t CMW_IMX335_SetFramerate(void *io_ctx, int32_t framerate)
{
3419b4e8:	b5b0      	push	{r4, r5, r7, lr}
3419b4ea:	b088      	sub	sp, #32
3419b4ec:	af00      	add	r7, sp, #0
3419b4ee:	6078      	str	r0, [r7, #4]
3419b4f0:	6039      	str	r1, [r7, #0]
  const int32_t available_imx335_fps[] = {10, 15, 20, 25, 30};
3419b4f2:	4b14      	ldr	r3, [pc, #80]	@ (3419b544 <CMW_IMX335_SetFramerate+0x5c>)
3419b4f4:	f107 0408 	add.w	r4, r7, #8
3419b4f8:	461d      	mov	r5, r3
3419b4fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b4fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b4fe:	682b      	ldr	r3, [r5, #0]
3419b500:	6023      	str	r3, [r4, #0]

  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
3419b502:	2300      	movs	r3, #0
3419b504:	61fb      	str	r3, [r7, #28]
3419b506:	e013      	b.n	3419b530 <CMW_IMX335_SetFramerate+0x48>
    if (framerate == available_imx335_fps[i])
3419b508:	69fb      	ldr	r3, [r7, #28]
3419b50a:	009b      	lsls	r3, r3, #2
3419b50c:	3320      	adds	r3, #32
3419b50e:	443b      	add	r3, r7
3419b510:	f853 3c18 	ldr.w	r3, [r3, #-24]
3419b514:	683a      	ldr	r2, [r7, #0]
3419b516:	429a      	cmp	r2, r3
3419b518:	d107      	bne.n	3419b52a <CMW_IMX335_SetFramerate+0x42>
      return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
3419b51a:	687b      	ldr	r3, [r7, #4]
3419b51c:	3308      	adds	r3, #8
3419b51e:	6839      	ldr	r1, [r7, #0]
3419b520:	4618      	mov	r0, r3
3419b522:	f002 f82b 	bl	3419d57c <IMX335_SetFramerate>
3419b526:	4603      	mov	r3, r0
3419b528:	e007      	b.n	3419b53a <CMW_IMX335_SetFramerate+0x52>
  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
3419b52a:	69fb      	ldr	r3, [r7, #28]
3419b52c:	3301      	adds	r3, #1
3419b52e:	61fb      	str	r3, [r7, #28]
3419b530:	69fb      	ldr	r3, [r7, #28]
3419b532:	2b04      	cmp	r3, #4
3419b534:	d9e8      	bls.n	3419b508 <CMW_IMX335_SetFramerate+0x20>

  return CMW_ERROR_WRONG_PARAM;
3419b536:	f06f 0301 	mvn.w	r3, #1
}
3419b53a:	4618      	mov	r0, r3
3419b53c:	3720      	adds	r7, #32
3419b53e:	46bd      	mov	sp, r7
3419b540:	bdb0      	pop	{r4, r5, r7, pc}
3419b542:	bf00      	nop
3419b544:	341a5f88 	.word	0x341a5f88

3419b548 <CMW_IMX335_SetMirrorFlip>:

static int32_t CMW_IMX335_SetMirrorFlip(void *io_ctx, uint32_t config)
{
3419b548:	b580      	push	{r7, lr}
3419b54a:	b084      	sub	sp, #16
3419b54c:	af00      	add	r7, sp, #0
3419b54e:	6078      	str	r0, [r7, #4]
3419b550:	6039      	str	r1, [r7, #0]
  int32_t mirrorFlip = CMW_IMX335_getMirrorFlipConfig(config);
3419b552:	6838      	ldr	r0, [r7, #0]
3419b554:	f7ff ff08 	bl	3419b368 <CMW_IMX335_getMirrorFlipConfig>
3419b558:	60f8      	str	r0, [r7, #12]
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
3419b55a:	687b      	ldr	r3, [r7, #4]
3419b55c:	3308      	adds	r3, #8
3419b55e:	68fa      	ldr	r2, [r7, #12]
3419b560:	4611      	mov	r1, r2
3419b562:	4618      	mov	r0, r3
3419b564:	f002 f88c 	bl	3419d680 <IMX335_MirrorFlipConfig>
3419b568:	4603      	mov	r3, r0
}
3419b56a:	4618      	mov	r0, r3
3419b56c:	3710      	adds	r7, #16
3419b56e:	46bd      	mov	sp, r7
3419b570:	bd80      	pop	{r7, pc}
	...

3419b574 <CMW_IMX335_GetSensorInfo>:

static int32_t CMW_IMX335_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419b574:	b480      	push	{r7}
3419b576:	b083      	sub	sp, #12
3419b578:	af00      	add	r7, sp, #0
3419b57a:	6078      	str	r0, [r7, #4]
3419b57c:	6039      	str	r1, [r7, #0]
  if ((io_ctx ==  NULL) || (info == NULL))
3419b57e:	687b      	ldr	r3, [r7, #4]
3419b580:	2b00      	cmp	r3, #0
3419b582:	d002      	beq.n	3419b58a <CMW_IMX335_GetSensorInfo+0x16>
3419b584:	683b      	ldr	r3, [r7, #0]
3419b586:	2b00      	cmp	r3, #0
3419b588:	d102      	bne.n	3419b590 <CMW_IMX335_GetSensorInfo+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3419b58a:	f06f 0301 	mvn.w	r3, #1
3419b58e:	e025      	b.n	3419b5dc <CMW_IMX335_GetSensorInfo+0x68>
  }

  if (sizeof(info->name) >= strlen(IMX335_NAME) + 1)
  {
    strcpy(info->name, IMX335_NAME);
3419b590:	683b      	ldr	r3, [r7, #0]
3419b592:	4a15      	ldr	r2, [pc, #84]	@ (3419b5e8 <CMW_IMX335_GetSensorInfo+0x74>)
3419b594:	6810      	ldr	r0, [r2, #0]
3419b596:	6018      	str	r0, [r3, #0]
3419b598:	8891      	ldrh	r1, [r2, #4]
3419b59a:	7992      	ldrb	r2, [r2, #6]
3419b59c:	8099      	strh	r1, [r3, #4]
3419b59e:	719a      	strb	r2, [r3, #6]
  else
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  info->bayer_pattern = IMX335_BAYER_PATTERN;
3419b5a0:	683b      	ldr	r3, [r7, #0]
3419b5a2:	2200      	movs	r2, #0
3419b5a4:	f883 2020 	strb.w	r2, [r3, #32]
  info->color_depth = IMX335_COLOR_DEPTH;
3419b5a8:	683b      	ldr	r3, [r7, #0]
3419b5aa:	220a      	movs	r2, #10
3419b5ac:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
  info->width = IMX335_WIDTH;
3419b5b0:	683b      	ldr	r3, [r7, #0]
3419b5b2:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
3419b5b6:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = IMX335_HEIGHT;
3419b5b8:	683b      	ldr	r3, [r7, #0]
3419b5ba:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
3419b5be:	629a      	str	r2, [r3, #40]	@ 0x28
  info->gain_min = IMX335_GAIN_MIN;
3419b5c0:	683b      	ldr	r3, [r7, #0]
3419b5c2:	2200      	movs	r2, #0
3419b5c4:	62da      	str	r2, [r3, #44]	@ 0x2c
  info->gain_max = IMX335_GAIN_MAX;
3419b5c6:	683b      	ldr	r3, [r7, #0]
3419b5c8:	4a08      	ldr	r2, [pc, #32]	@ (3419b5ec <CMW_IMX335_GetSensorInfo+0x78>)
3419b5ca:	631a      	str	r2, [r3, #48]	@ 0x30
  info->exposure_min = IMX335_EXPOSURE_MIN;
3419b5cc:	683b      	ldr	r3, [r7, #0]
3419b5ce:	2208      	movs	r2, #8
3419b5d0:	635a      	str	r2, [r3, #52]	@ 0x34
  info->exposure_max = IMX335_EXPOSURE_MAX;
3419b5d2:	683b      	ldr	r3, [r7, #0]
3419b5d4:	f248 12f2 	movw	r2, #33266	@ 0x81f2
3419b5d8:	639a      	str	r2, [r3, #56]	@ 0x38

  return CMW_ERROR_NONE;
3419b5da:	2300      	movs	r3, #0
}
3419b5dc:	4618      	mov	r0, r3
3419b5de:	370c      	adds	r7, #12
3419b5e0:	46bd      	mov	sp, r7
3419b5e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b5e6:	4770      	bx	lr
3419b5e8:	341a5f9c 	.word	0x341a5f9c
3419b5ec:	00011940 	.word	0x00011940

3419b5f0 <CMW_IMX335_SetTestPattern>:

static int32_t CMW_IMX335_SetTestPattern(void *io_ctx, int32_t mode)
{
3419b5f0:	b580      	push	{r7, lr}
3419b5f2:	b082      	sub	sp, #8
3419b5f4:	af00      	add	r7, sp, #0
3419b5f6:	6078      	str	r0, [r7, #4]
3419b5f8:	6039      	str	r1, [r7, #0]
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
3419b5fa:	687b      	ldr	r3, [r7, #4]
3419b5fc:	3308      	adds	r3, #8
3419b5fe:	6839      	ldr	r1, [r7, #0]
3419b600:	4618      	mov	r0, r3
3419b602:	f002 f87b 	bl	3419d6fc <IMX335_SetTestPattern>
3419b606:	4603      	mov	r3, r0
}
3419b608:	4618      	mov	r0, r3
3419b60a:	3708      	adds	r7, #8
3419b60c:	46bd      	mov	sp, r7
3419b60e:	bd80      	pop	{r7, pc}

3419b610 <CMW_IMX335_Init>:

static int32_t CMW_IMX335_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419b610:	b580      	push	{r7, lr}
3419b612:	b084      	sub	sp, #16
3419b614:	af00      	add	r7, sp, #0
3419b616:	6078      	str	r0, [r7, #4]
3419b618:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419b61a:	2300      	movs	r3, #0
3419b61c:	60fb      	str	r3, [r7, #12]
  uint32_t resolution;

  ret = CMW_IMX335_GetResType(initSensor->width, initSensor->height, &resolution);
3419b61e:	683b      	ldr	r3, [r7, #0]
3419b620:	6818      	ldr	r0, [r3, #0]
3419b622:	683b      	ldr	r3, [r7, #0]
3419b624:	685b      	ldr	r3, [r3, #4]
3419b626:	f107 0208 	add.w	r2, r7, #8
3419b62a:	4619      	mov	r1, r3
3419b62c:	f7ff fe81 	bl	3419b332 <CMW_IMX335_GetResType>
3419b630:	60f8      	str	r0, [r7, #12]
  if (ret)
3419b632:	68fb      	ldr	r3, [r7, #12]
3419b634:	2b00      	cmp	r3, #0
3419b636:	d002      	beq.n	3419b63e <CMW_IMX335_Init+0x2e>
  {
    return CMW_ERROR_WRONG_PARAM;
3419b638:	f06f 0301 	mvn.w	r3, #1
3419b63c:	e01d      	b.n	3419b67a <CMW_IMX335_Init+0x6a>
  }

  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
3419b63e:	683b      	ldr	r3, [r7, #0]
3419b640:	691b      	ldr	r3, [r3, #16]
3419b642:	4619      	mov	r1, r3
3419b644:	6878      	ldr	r0, [r7, #4]
3419b646:	f7ff ff7f 	bl	3419b548 <CMW_IMX335_SetMirrorFlip>
3419b64a:	60f8      	str	r0, [r7, #12]
  if (ret)
3419b64c:	68fb      	ldr	r3, [r7, #12]
3419b64e:	2b00      	cmp	r3, #0
3419b650:	d002      	beq.n	3419b658 <CMW_IMX335_Init+0x48>
  {
    return CMW_ERROR_WRONG_PARAM;
3419b652:	f06f 0301 	mvn.w	r3, #1
3419b656:	e010      	b.n	3419b67a <CMW_IMX335_Init+0x6a>
  }

  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
3419b658:	687b      	ldr	r3, [r7, #4]
3419b65a:	f103 0008 	add.w	r0, r3, #8
3419b65e:	68b9      	ldr	r1, [r7, #8]
3419b660:	683b      	ldr	r3, [r7, #0]
3419b662:	68db      	ldr	r3, [r3, #12]
3419b664:	461a      	mov	r2, r3
3419b666:	f001 fdbd 	bl	3419d1e4 <IMX335_Init>
3419b66a:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419b66c:	68fb      	ldr	r3, [r7, #12]
3419b66e:	2b00      	cmp	r3, #0
3419b670:	d002      	beq.n	3419b678 <CMW_IMX335_Init+0x68>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b672:	f06f 0304 	mvn.w	r3, #4
3419b676:	e000      	b.n	3419b67a <CMW_IMX335_Init+0x6a>
  }

  return CMW_ERROR_NONE;
3419b678:	2300      	movs	r3, #0
}
3419b67a:	4618      	mov	r0, r3
3419b67c:	3710      	adds	r7, #16
3419b67e:	46bd      	mov	sp, r7
3419b680:	bd80      	pop	{r7, pc}
	...

3419b684 <CMW_IMX335_Start>:

static int32_t CMW_IMX335_Start(void *io_ctx)
{
3419b684:	b580      	push	{r7, lr}
3419b686:	b086      	sub	sp, #24
3419b688:	af02      	add	r7, sp, #8
3419b68a:	6078      	str	r0, [r7, #4]
  int ret;
  /* Statistic area is provided with null value so that it force the ISP Library to get the statistic
   * area information from the tuning file.
   */
  (void) ISP_IQParamCacheInit; /* unused */
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_IMX335);
3419b68c:	687b      	ldr	r3, [r7, #4]
3419b68e:	f103 0030 	add.w	r0, r3, #48	@ 0x30
3419b692:	687b      	ldr	r3, [r7, #4]
3419b694:	f8d3 10dc 	ldr.w	r1, [r3, #220]	@ 0xdc
3419b698:	687b      	ldr	r3, [r7, #4]
3419b69a:	33b8      	adds	r3, #184	@ 0xb8
3419b69c:	4a11      	ldr	r2, [pc, #68]	@ (3419b6e4 <CMW_IMX335_Start+0x60>)
3419b69e:	9200      	str	r2, [sp, #0]
3419b6a0:	2200      	movs	r2, #0
3419b6a2:	f7fc fcaf 	bl	34198004 <ISP_Init>
3419b6a6:	4603      	mov	r3, r0
3419b6a8:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419b6aa:	68fb      	ldr	r3, [r7, #12]
3419b6ac:	2b00      	cmp	r3, #0
3419b6ae:	d002      	beq.n	3419b6b6 <CMW_IMX335_Start+0x32>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b6b0:	f06f 0304 	mvn.w	r3, #4
3419b6b4:	e012      	b.n	3419b6dc <CMW_IMX335_Start+0x58>
  }

  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b6b6:	687b      	ldr	r3, [r7, #4]
3419b6b8:	3330      	adds	r3, #48	@ 0x30
3419b6ba:	4618      	mov	r0, r3
3419b6bc:	f7fc fd88 	bl	341981d0 <ISP_Start>
3419b6c0:	4603      	mov	r3, r0
3419b6c2:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419b6c4:	68fb      	ldr	r3, [r7, #12]
3419b6c6:	2b00      	cmp	r3, #0
3419b6c8:	d002      	beq.n	3419b6d0 <CMW_IMX335_Start+0x4c>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419b6ca:	f06f 0303 	mvn.w	r3, #3
3419b6ce:	e005      	b.n	3419b6dc <CMW_IMX335_Start+0x58>
  }
#endif
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3419b6d0:	687b      	ldr	r3, [r7, #4]
3419b6d2:	3308      	adds	r3, #8
3419b6d4:	4618      	mov	r0, r3
3419b6d6:	f001 fdc3 	bl	3419d260 <IMX335_Start>
3419b6da:	4603      	mov	r3, r0
}
3419b6dc:	4618      	mov	r0, r3
3419b6de:	3710      	adds	r7, #16
3419b6e0:	46bd      	mov	sp, r7
3419b6e2:	bd80      	pop	{r7, pc}
3419b6e4:	341b0fc0 	.word	0x341b0fc0

3419b6e8 <CMW_IMX335_Run>:

static int32_t CMW_IMX335_Run(void *io_ctx)
{
3419b6e8:	b580      	push	{r7, lr}
3419b6ea:	b084      	sub	sp, #16
3419b6ec:	af00      	add	r7, sp, #0
3419b6ee:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b6f0:	687b      	ldr	r3, [r7, #4]
3419b6f2:	3330      	adds	r3, #48	@ 0x30
3419b6f4:	4618      	mov	r0, r3
3419b6f6:	f7fc fe73 	bl	341983e0 <ISP_BackgroundProcess>
3419b6fa:	4603      	mov	r3, r0
3419b6fc:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419b6fe:	68fb      	ldr	r3, [r7, #12]
3419b700:	2b00      	cmp	r3, #0
3419b702:	d002      	beq.n	3419b70a <CMW_IMX335_Run+0x22>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419b704:	f06f 0303 	mvn.w	r3, #3
3419b708:	e000      	b.n	3419b70c <CMW_IMX335_Run+0x24>
  }
#endif
  return CMW_ERROR_NONE;
3419b70a:	2300      	movs	r3, #0
}
3419b70c:	4618      	mov	r0, r3
3419b70e:	3710      	adds	r7, #16
3419b710:	46bd      	mov	sp, r7
3419b712:	bd80      	pop	{r7, pc}

3419b714 <CMW_IMX335_PowerOn>:

static void CMW_IMX335_PowerOn(CMW_IMX335_t *io_ctx)
{
3419b714:	b580      	push	{r7, lr}
3419b716:	b082      	sub	sp, #8
3419b718:	af00      	add	r7, sp, #0
3419b71a:	6078      	str	r0, [r7, #4]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419b71c:	687b      	ldr	r3, [r7, #4]
3419b71e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419b722:	2000      	movs	r0, #0
3419b724:	4798      	blx	r3
  io_ctx->Delay(100);
3419b726:	687b      	ldr	r3, [r7, #4]
3419b728:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419b72c:	2064      	movs	r0, #100	@ 0x64
3419b72e:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
3419b730:	687b      	ldr	r3, [r7, #4]
3419b732:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419b736:	2000      	movs	r0, #0
3419b738:	4798      	blx	r3
  io_ctx->Delay(100);
3419b73a:	687b      	ldr	r3, [r7, #4]
3419b73c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419b740:	2064      	movs	r0, #100	@ 0x64
3419b742:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419b744:	687b      	ldr	r3, [r7, #4]
3419b746:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419b74a:	2001      	movs	r0, #1
3419b74c:	4798      	blx	r3
  io_ctx->Delay(100);
3419b74e:	687b      	ldr	r3, [r7, #4]
3419b750:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419b754:	2064      	movs	r0, #100	@ 0x64
3419b756:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
3419b758:	687b      	ldr	r3, [r7, #4]
3419b75a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419b75e:	2001      	movs	r0, #1
3419b760:	4798      	blx	r3
  io_ctx->Delay(100);
3419b762:	687b      	ldr	r3, [r7, #4]
3419b764:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419b768:	2064      	movs	r0, #100	@ 0x64
3419b76a:	4798      	blx	r3
}
3419b76c:	bf00      	nop
3419b76e:	3708      	adds	r7, #8
3419b770:	46bd      	mov	sp, r7
3419b772:	bd80      	pop	{r7, pc}

3419b774 <CMW_IMX335_VsyncEventCallback>:

static void CMW_IMX335_VsyncEventCallback(void *io_ctx, uint32_t pipe)
{
3419b774:	b580      	push	{r7, lr}
3419b776:	b082      	sub	sp, #8
3419b778:	af00      	add	r7, sp, #0
3419b77a:	6078      	str	r0, [r7, #4]
3419b77c:	6039      	str	r1, [r7, #0]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Update the ISP frame counter and call its statistics handler */
  switch (pipe)
3419b77e:	683b      	ldr	r3, [r7, #0]
3419b780:	2b02      	cmp	r3, #2
3419b782:	d01a      	beq.n	3419b7ba <CMW_IMX335_VsyncEventCallback+0x46>
3419b784:	683b      	ldr	r3, [r7, #0]
3419b786:	2b02      	cmp	r3, #2
3419b788:	d81d      	bhi.n	3419b7c6 <CMW_IMX335_VsyncEventCallback+0x52>
3419b78a:	683b      	ldr	r3, [r7, #0]
3419b78c:	2b00      	cmp	r3, #0
3419b78e:	d003      	beq.n	3419b798 <CMW_IMX335_VsyncEventCallback+0x24>
3419b790:	683b      	ldr	r3, [r7, #0]
3419b792:	2b01      	cmp	r3, #1
3419b794:	d006      	beq.n	3419b7a4 <CMW_IMX335_VsyncEventCallback+0x30>
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
      break;
  }
#endif
}
3419b796:	e016      	b.n	3419b7c6 <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b798:	687b      	ldr	r3, [r7, #4]
3419b79a:	3330      	adds	r3, #48	@ 0x30
3419b79c:	4618      	mov	r0, r3
3419b79e:	f7fc ff07 	bl	341985b0 <ISP_IncDumpFrameId>
      break;
3419b7a2:	e010      	b.n	3419b7c6 <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b7a4:	687b      	ldr	r3, [r7, #4]
3419b7a6:	3330      	adds	r3, #48	@ 0x30
3419b7a8:	4618      	mov	r0, r3
3419b7aa:	f7fc feeb 	bl	34198584 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b7ae:	687b      	ldr	r3, [r7, #4]
3419b7b0:	3330      	adds	r3, #48	@ 0x30
3419b7b2:	4618      	mov	r0, r3
3419b7b4:	f7fc fedb 	bl	3419856e <ISP_GatherStatistics>
      break;
3419b7b8:	e005      	b.n	3419b7c6 <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419b7ba:	687b      	ldr	r3, [r7, #4]
3419b7bc:	3330      	adds	r3, #48	@ 0x30
3419b7be:	4618      	mov	r0, r3
3419b7c0:	f7fc feeb 	bl	3419859a <ISP_IncAncillaryFrameId>
      break;
3419b7c4:	bf00      	nop
}
3419b7c6:	bf00      	nop
3419b7c8:	3708      	adds	r7, #8
3419b7ca:	46bd      	mov	sp, r7
3419b7cc:	bd80      	pop	{r7, pc}

3419b7ce <CMW_IMX335_FrameEventCallback>:

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
3419b7ce:	b480      	push	{r7}
3419b7d0:	b083      	sub	sp, #12
3419b7d2:	af00      	add	r7, sp, #0
3419b7d4:	6078      	str	r0, [r7, #4]
3419b7d6:	6039      	str	r1, [r7, #0]
}
3419b7d8:	bf00      	nop
3419b7da:	370c      	adds	r7, #12
3419b7dc:	46bd      	mov	sp, r7
3419b7de:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b7e2:	4770      	bx	lr

3419b7e4 <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
3419b7e4:	b580      	push	{r7, lr}
3419b7e6:	b084      	sub	sp, #16
3419b7e8:	af00      	add	r7, sp, #0
3419b7ea:	6078      	str	r0, [r7, #4]
3419b7ec:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419b7ee:	2300      	movs	r3, #0
3419b7f0:	60fb      	str	r3, [r7, #12]
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3419b7f2:	687b      	ldr	r3, [r7, #4]
3419b7f4:	881a      	ldrh	r2, [r3, #0]
3419b7f6:	687b      	ldr	r3, [r7, #4]
3419b7f8:	821a      	strh	r2, [r3, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3419b7fa:	687b      	ldr	r3, [r7, #4]
3419b7fc:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
3419b800:	687b      	ldr	r3, [r7, #4]
3419b802:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
3419b804:	687b      	ldr	r3, [r7, #4]
3419b806:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3419b80a:	687b      	ldr	r3, [r7, #4]
3419b80c:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
3419b80e:	687b      	ldr	r3, [r7, #4]
3419b810:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3419b814:	687b      	ldr	r3, [r7, #4]
3419b816:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
3419b818:	687b      	ldr	r3, [r7, #4]
3419b81a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3419b81e:	687b      	ldr	r3, [r7, #4]
3419b820:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
3419b822:	687b      	ldr	r3, [r7, #4]
3419b824:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3419b828:	687b      	ldr	r3, [r7, #4]
3419b82a:	615a      	str	r2, [r3, #20]

  CMW_IMX335_PowerOn(io_ctx);
3419b82c:	6878      	ldr	r0, [r7, #4]
3419b82e:	f7ff ff71 	bl	3419b714 <CMW_IMX335_PowerOn>

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3419b832:	687b      	ldr	r3, [r7, #4]
3419b834:	f103 0208 	add.w	r2, r3, #8
3419b838:	687b      	ldr	r3, [r7, #4]
3419b83a:	3308      	adds	r3, #8
3419b83c:	4619      	mov	r1, r3
3419b83e:	4610      	mov	r0, r2
3419b840:	f001 fc8e 	bl	3419d160 <IMX335_RegisterBusIO>
3419b844:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419b846:	68fb      	ldr	r3, [r7, #12]
3419b848:	2b00      	cmp	r3, #0
3419b84a:	d002      	beq.n	3419b852 <CMW_IMX335_Probe+0x6e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b84c:	f06f 0304 	mvn.w	r3, #4
3419b850:	e04a      	b.n	3419b8e8 <CMW_IMX335_Probe+0x104>
  }

  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
3419b852:	687b      	ldr	r3, [r7, #4]
3419b854:	3308      	adds	r3, #8
3419b856:	f107 0208 	add.w	r2, r7, #8
3419b85a:	4611      	mov	r1, r2
3419b85c:	4618      	mov	r0, r3
3419b85e:	f001 fd35 	bl	3419d2cc <IMX335_ReadID>
3419b862:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419b864:	68fb      	ldr	r3, [r7, #12]
3419b866:	2b00      	cmp	r3, #0
3419b868:	d002      	beq.n	3419b870 <CMW_IMX335_Probe+0x8c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b86a:	f06f 0304 	mvn.w	r3, #4
3419b86e:	e03b      	b.n	3419b8e8 <CMW_IMX335_Probe+0x104>
  }
  if (id != IMX335_CHIP_ID)
3419b870:	68bb      	ldr	r3, [r7, #8]
3419b872:	2b00      	cmp	r3, #0
3419b874:	d002      	beq.n	3419b87c <CMW_IMX335_Probe+0x98>
  {
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3419b876:	f06f 0306 	mvn.w	r3, #6
3419b87a:	60fb      	str	r3, [r7, #12]
  }

  memset(imx335_if, 0, sizeof(*imx335_if));
3419b87c:	2268      	movs	r2, #104	@ 0x68
3419b87e:	2100      	movs	r1, #0
3419b880:	6838      	ldr	r0, [r7, #0]
3419b882:	f008 fa8f 	bl	341a3da4 <memset>
  imx335_if->Init = CMW_IMX335_Init;
3419b886:	683b      	ldr	r3, [r7, #0]
3419b888:	4a19      	ldr	r2, [pc, #100]	@ (3419b8f0 <CMW_IMX335_Probe+0x10c>)
3419b88a:	601a      	str	r2, [r3, #0]
  imx335_if->Start = CMW_IMX335_Start;
3419b88c:	683b      	ldr	r3, [r7, #0]
3419b88e:	4a19      	ldr	r2, [pc, #100]	@ (3419b8f4 <CMW_IMX335_Probe+0x110>)
3419b890:	609a      	str	r2, [r3, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
3419b892:	683b      	ldr	r3, [r7, #0]
3419b894:	4a18      	ldr	r2, [pc, #96]	@ (3419b8f8 <CMW_IMX335_Probe+0x114>)
3419b896:	605a      	str	r2, [r3, #4]
  imx335_if->Run = CMW_IMX335_Run;
3419b898:	683b      	ldr	r3, [r7, #0]
3419b89a:	4a18      	ldr	r2, [pc, #96]	@ (3419b8fc <CMW_IMX335_Probe+0x118>)
3419b89c:	60da      	str	r2, [r3, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
3419b89e:	683b      	ldr	r3, [r7, #0]
3419b8a0:	4a17      	ldr	r2, [pc, #92]	@ (3419b900 <CMW_IMX335_Probe+0x11c>)
3419b8a2:	611a      	str	r2, [r3, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
3419b8a4:	683b      	ldr	r3, [r7, #0]
3419b8a6:	4a17      	ldr	r2, [pc, #92]	@ (3419b904 <CMW_IMX335_Probe+0x120>)
3419b8a8:	615a      	str	r2, [r3, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
3419b8aa:	683b      	ldr	r3, [r7, #0]
3419b8ac:	4a16      	ldr	r2, [pc, #88]	@ (3419b908 <CMW_IMX335_Probe+0x124>)
3419b8ae:	61da      	str	r2, [r3, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
3419b8b0:	683b      	ldr	r3, [r7, #0]
3419b8b2:	4a16      	ldr	r2, [pc, #88]	@ (3419b90c <CMW_IMX335_Probe+0x128>)
3419b8b4:	649a      	str	r2, [r3, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
3419b8b6:	683b      	ldr	r3, [r7, #0]
3419b8b8:	4a15      	ldr	r2, [pc, #84]	@ (3419b910 <CMW_IMX335_Probe+0x12c>)
3419b8ba:	64da      	str	r2, [r3, #76]	@ 0x4c
  imx335_if->SetWBRefMode = CMW_IMX335_SetWBRefMode;
3419b8bc:	683b      	ldr	r3, [r7, #0]
3419b8be:	4a15      	ldr	r2, [pc, #84]	@ (3419b914 <CMW_IMX335_Probe+0x130>)
3419b8c0:	655a      	str	r2, [r3, #84]	@ 0x54
  imx335_if->ListWBRefModes = CMW_IMX335_ListWBRefModes;
3419b8c2:	683b      	ldr	r3, [r7, #0]
3419b8c4:	4a14      	ldr	r2, [pc, #80]	@ (3419b918 <CMW_IMX335_Probe+0x134>)
3419b8c6:	659a      	str	r2, [r3, #88]	@ 0x58
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
3419b8c8:	683b      	ldr	r3, [r7, #0]
3419b8ca:	4a14      	ldr	r2, [pc, #80]	@ (3419b91c <CMW_IMX335_Probe+0x138>)
3419b8cc:	641a      	str	r2, [r3, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
3419b8ce:	683b      	ldr	r3, [r7, #0]
3419b8d0:	4a13      	ldr	r2, [pc, #76]	@ (3419b920 <CMW_IMX335_Probe+0x13c>)
3419b8d2:	645a      	str	r2, [r3, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
3419b8d4:	683b      	ldr	r3, [r7, #0]
3419b8d6:	4a13      	ldr	r2, [pc, #76]	@ (3419b924 <CMW_IMX335_Probe+0x140>)
3419b8d8:	62da      	str	r2, [r3, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
3419b8da:	683b      	ldr	r3, [r7, #0]
3419b8dc:	4a12      	ldr	r2, [pc, #72]	@ (3419b928 <CMW_IMX335_Probe+0x144>)
3419b8de:	661a      	str	r2, [r3, #96]	@ 0x60
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
3419b8e0:	683b      	ldr	r3, [r7, #0]
3419b8e2:	4a12      	ldr	r2, [pc, #72]	@ (3419b92c <CMW_IMX335_Probe+0x148>)
3419b8e4:	665a      	str	r2, [r3, #100]	@ 0x64
  return ret;
3419b8e6:	68fb      	ldr	r3, [r7, #12]
}
3419b8e8:	4618      	mov	r0, r3
3419b8ea:	3710      	adds	r7, #16
3419b8ec:	46bd      	mov	sp, r7
3419b8ee:	bd80      	pop	{r7, pc}
3419b8f0:	3419b611 	.word	0x3419b611
3419b8f4:	3419b685 	.word	0x3419b685
3419b8f8:	3419b3b1 	.word	0x3419b3b1
3419b8fc:	3419b6e9 	.word	0x3419b6e9
3419b900:	3419b775 	.word	0x3419b775
3419b904:	3419b7cf 	.word	0x3419b7cf
3419b908:	3419b3f9 	.word	0x3419b3f9
3419b90c:	3419b419 	.word	0x3419b419
3419b910:	3419b439 	.word	0x3419b439
3419b914:	3419b459 	.word	0x3419b459
3419b918:	3419b493 	.word	0x3419b493
3419b91c:	3419b4c7 	.word	0x3419b4c7
3419b920:	3419b4e9 	.word	0x3419b4e9
3419b924:	3419b549 	.word	0x3419b549
3419b928:	3419b575 	.word	0x3419b575
3419b92c:	3419b5f1 	.word	0x3419b5f1

3419b930 <CMW_VD55G1_Read8>:
#define MIN(a, b)       ((a) < (b) ?  (a) : (b))

#define VD55G1_REG_MODEL_ID                           0x0000

static int CMW_VD55G1_Read8(CMW_VD55G1_t *pObj, uint16_t addr, uint8_t *value)
{
3419b930:	b590      	push	{r4, r7, lr}
3419b932:	b085      	sub	sp, #20
3419b934:	af00      	add	r7, sp, #0
3419b936:	60f8      	str	r0, [r7, #12]
3419b938:	460b      	mov	r3, r1
3419b93a:	607a      	str	r2, [r7, #4]
3419b93c:	817b      	strh	r3, [r7, #10]
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3419b93e:	68fb      	ldr	r3, [r7, #12]
3419b940:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419b942:	68fb      	ldr	r3, [r7, #12]
3419b944:	8818      	ldrh	r0, [r3, #0]
3419b946:	8979      	ldrh	r1, [r7, #10]
3419b948:	2301      	movs	r3, #1
3419b94a:	687a      	ldr	r2, [r7, #4]
3419b94c:	47a0      	blx	r4
3419b94e:	4603      	mov	r3, r0
}
3419b950:	4618      	mov	r0, r3
3419b952:	3714      	adds	r7, #20
3419b954:	46bd      	mov	sp, r7
3419b956:	bd90      	pop	{r4, r7, pc}

3419b958 <CMW_VD55G1_Read16>:

static int CMW_VD55G1_Read16(CMW_VD55G1_t *pObj, uint16_t addr, uint16_t *value)
{
3419b958:	b590      	push	{r4, r7, lr}
3419b95a:	b087      	sub	sp, #28
3419b95c:	af00      	add	r7, sp, #0
3419b95e:	60f8      	str	r0, [r7, #12]
3419b960:	460b      	mov	r3, r1
3419b962:	607a      	str	r2, [r7, #4]
3419b964:	817b      	strh	r3, [r7, #10]
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3419b966:	68fb      	ldr	r3, [r7, #12]
3419b968:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419b96a:	68fb      	ldr	r3, [r7, #12]
3419b96c:	8818      	ldrh	r0, [r3, #0]
3419b96e:	f107 0210 	add.w	r2, r7, #16
3419b972:	8979      	ldrh	r1, [r7, #10]
3419b974:	2302      	movs	r3, #2
3419b976:	47a0      	blx	r4
3419b978:	6178      	str	r0, [r7, #20]
  if (ret)
3419b97a:	697b      	ldr	r3, [r7, #20]
3419b97c:	2b00      	cmp	r3, #0
3419b97e:	d001      	beq.n	3419b984 <CMW_VD55G1_Read16+0x2c>
    return ret;
3419b980:	697b      	ldr	r3, [r7, #20]
3419b982:	e00b      	b.n	3419b99c <CMW_VD55G1_Read16+0x44>

  *value = (data[1] << 8) | data[0];
3419b984:	7c7b      	ldrb	r3, [r7, #17]
3419b986:	b21b      	sxth	r3, r3
3419b988:	021b      	lsls	r3, r3, #8
3419b98a:	b21a      	sxth	r2, r3
3419b98c:	7c3b      	ldrb	r3, [r7, #16]
3419b98e:	b21b      	sxth	r3, r3
3419b990:	4313      	orrs	r3, r2
3419b992:	b21b      	sxth	r3, r3
3419b994:	b29a      	uxth	r2, r3
3419b996:	687b      	ldr	r3, [r7, #4]
3419b998:	801a      	strh	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419b99a:	2300      	movs	r3, #0
}
3419b99c:	4618      	mov	r0, r3
3419b99e:	371c      	adds	r7, #28
3419b9a0:	46bd      	mov	sp, r7
3419b9a2:	bd90      	pop	{r4, r7, pc}

3419b9a4 <CMW_VD55G1_Read32>:

static int CMW_VD55G1_Read32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t *value)
{
3419b9a4:	b590      	push	{r4, r7, lr}
3419b9a6:	b087      	sub	sp, #28
3419b9a8:	af00      	add	r7, sp, #0
3419b9aa:	60f8      	str	r0, [r7, #12]
3419b9ac:	460b      	mov	r3, r1
3419b9ae:	607a      	str	r2, [r7, #4]
3419b9b0:	817b      	strh	r3, [r7, #10]
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3419b9b2:	68fb      	ldr	r3, [r7, #12]
3419b9b4:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419b9b6:	68fb      	ldr	r3, [r7, #12]
3419b9b8:	8818      	ldrh	r0, [r3, #0]
3419b9ba:	f107 0210 	add.w	r2, r7, #16
3419b9be:	8979      	ldrh	r1, [r7, #10]
3419b9c0:	2304      	movs	r3, #4
3419b9c2:	47a0      	blx	r4
3419b9c4:	6178      	str	r0, [r7, #20]
  if (ret)
3419b9c6:	697b      	ldr	r3, [r7, #20]
3419b9c8:	2b00      	cmp	r3, #0
3419b9ca:	d001      	beq.n	3419b9d0 <CMW_VD55G1_Read32+0x2c>
    return ret;
3419b9cc:	697b      	ldr	r3, [r7, #20]
3419b9ce:	e00d      	b.n	3419b9ec <CMW_VD55G1_Read32+0x48>

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
3419b9d0:	7cfb      	ldrb	r3, [r7, #19]
3419b9d2:	061a      	lsls	r2, r3, #24
3419b9d4:	7cbb      	ldrb	r3, [r7, #18]
3419b9d6:	041b      	lsls	r3, r3, #16
3419b9d8:	431a      	orrs	r2, r3
3419b9da:	7c7b      	ldrb	r3, [r7, #17]
3419b9dc:	021b      	lsls	r3, r3, #8
3419b9de:	4313      	orrs	r3, r2
3419b9e0:	7c3a      	ldrb	r2, [r7, #16]
3419b9e2:	4313      	orrs	r3, r2
3419b9e4:	461a      	mov	r2, r3
3419b9e6:	687b      	ldr	r3, [r7, #4]
3419b9e8:	601a      	str	r2, [r3, #0]

  return 0;
3419b9ea:	2300      	movs	r3, #0
}
3419b9ec:	4618      	mov	r0, r3
3419b9ee:	371c      	adds	r7, #28
3419b9f0:	46bd      	mov	sp, r7
3419b9f2:	bd90      	pop	{r4, r7, pc}

3419b9f4 <CMW_VD55G1_Write8>:

static int CMW_VD55G1_Write8(CMW_VD55G1_t *pObj, uint16_t addr, uint8_t value)
{
3419b9f4:	b590      	push	{r4, r7, lr}
3419b9f6:	b083      	sub	sp, #12
3419b9f8:	af00      	add	r7, sp, #0
3419b9fa:	6078      	str	r0, [r7, #4]
3419b9fc:	460b      	mov	r3, r1
3419b9fe:	807b      	strh	r3, [r7, #2]
3419ba00:	4613      	mov	r3, r2
3419ba02:	707b      	strb	r3, [r7, #1]
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3419ba04:	687b      	ldr	r3, [r7, #4]
3419ba06:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419ba08:	687b      	ldr	r3, [r7, #4]
3419ba0a:	8818      	ldrh	r0, [r3, #0]
3419ba0c:	1c7a      	adds	r2, r7, #1
3419ba0e:	8879      	ldrh	r1, [r7, #2]
3419ba10:	2301      	movs	r3, #1
3419ba12:	47a0      	blx	r4
3419ba14:	4603      	mov	r3, r0
}
3419ba16:	4618      	mov	r0, r3
3419ba18:	370c      	adds	r7, #12
3419ba1a:	46bd      	mov	sp, r7
3419ba1c:	bd90      	pop	{r4, r7, pc}

3419ba1e <CMW_VD55G1_Write16>:

static int CMW_VD55G1_Write16(CMW_VD55G1_t *pObj, uint16_t addr, uint16_t value)
{
3419ba1e:	b590      	push	{r4, r7, lr}
3419ba20:	b083      	sub	sp, #12
3419ba22:	af00      	add	r7, sp, #0
3419ba24:	6078      	str	r0, [r7, #4]
3419ba26:	460b      	mov	r3, r1
3419ba28:	807b      	strh	r3, [r7, #2]
3419ba2a:	4613      	mov	r3, r2
3419ba2c:	803b      	strh	r3, [r7, #0]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
3419ba2e:	687b      	ldr	r3, [r7, #4]
3419ba30:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419ba32:	687b      	ldr	r3, [r7, #4]
3419ba34:	8818      	ldrh	r0, [r3, #0]
3419ba36:	463a      	mov	r2, r7
3419ba38:	8879      	ldrh	r1, [r7, #2]
3419ba3a:	2302      	movs	r3, #2
3419ba3c:	47a0      	blx	r4
3419ba3e:	4603      	mov	r3, r0
}
3419ba40:	4618      	mov	r0, r3
3419ba42:	370c      	adds	r7, #12
3419ba44:	46bd      	mov	sp, r7
3419ba46:	bd90      	pop	{r4, r7, pc}

3419ba48 <CMW_VD55G1_Write32>:

static int CMW_VD55G1_Write32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t value)
{
3419ba48:	b590      	push	{r4, r7, lr}
3419ba4a:	b085      	sub	sp, #20
3419ba4c:	af00      	add	r7, sp, #0
3419ba4e:	60f8      	str	r0, [r7, #12]
3419ba50:	460b      	mov	r3, r1
3419ba52:	607a      	str	r2, [r7, #4]
3419ba54:	817b      	strh	r3, [r7, #10]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3419ba56:	68fb      	ldr	r3, [r7, #12]
3419ba58:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419ba5a:	68fb      	ldr	r3, [r7, #12]
3419ba5c:	8818      	ldrh	r0, [r3, #0]
3419ba5e:	1d3a      	adds	r2, r7, #4
3419ba60:	8979      	ldrh	r1, [r7, #10]
3419ba62:	2304      	movs	r3, #4
3419ba64:	47a0      	blx	r4
3419ba66:	4603      	mov	r3, r0
}
3419ba68:	4618      	mov	r0, r3
3419ba6a:	3714      	adds	r7, #20
3419ba6c:	46bd      	mov	sp, r7
3419ba6e:	bd90      	pop	{r4, r7, pc}

3419ba70 <VD55G1_ShutdownPin>:

static void VD55G1_ShutdownPin(struct VD55G1_Ctx *ctx, int value)
{
3419ba70:	b580      	push	{r7, lr}
3419ba72:	b084      	sub	sp, #16
3419ba74:	af00      	add	r7, sp, #0
3419ba76:	6078      	str	r0, [r7, #4]
3419ba78:	6039      	str	r1, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419ba7a:	687b      	ldr	r3, [r7, #4]
3419ba7c:	3b04      	subs	r3, #4
3419ba7e:	60fb      	str	r3, [r7, #12]

  p_ctx->ShutdownPin(value);
3419ba80:	68fb      	ldr	r3, [r7, #12]
3419ba82:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419ba86:	6838      	ldr	r0, [r7, #0]
3419ba88:	4798      	blx	r3
}
3419ba8a:	bf00      	nop
3419ba8c:	3710      	adds	r7, #16
3419ba8e:	46bd      	mov	sp, r7
3419ba90:	bd80      	pop	{r7, pc}

3419ba92 <VD55G1_Read8>:

static int VD55G1_Read8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *value)
{
3419ba92:	b580      	push	{r7, lr}
3419ba94:	b086      	sub	sp, #24
3419ba96:	af00      	add	r7, sp, #0
3419ba98:	60f8      	str	r0, [r7, #12]
3419ba9a:	460b      	mov	r3, r1
3419ba9c:	607a      	str	r2, [r7, #4]
3419ba9e:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419baa0:	68fb      	ldr	r3, [r7, #12]
3419baa2:	3b04      	subs	r3, #4
3419baa4:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read8(p_ctx, addr, value);
3419baa6:	897b      	ldrh	r3, [r7, #10]
3419baa8:	687a      	ldr	r2, [r7, #4]
3419baaa:	4619      	mov	r1, r3
3419baac:	6978      	ldr	r0, [r7, #20]
3419baae:	f7ff ff3f 	bl	3419b930 <CMW_VD55G1_Read8>
3419bab2:	4603      	mov	r3, r0
}
3419bab4:	4618      	mov	r0, r3
3419bab6:	3718      	adds	r7, #24
3419bab8:	46bd      	mov	sp, r7
3419baba:	bd80      	pop	{r7, pc}

3419babc <VD55G1_Read16>:

static int VD55G1_Read16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t *value)
{
3419babc:	b580      	push	{r7, lr}
3419babe:	b086      	sub	sp, #24
3419bac0:	af00      	add	r7, sp, #0
3419bac2:	60f8      	str	r0, [r7, #12]
3419bac4:	460b      	mov	r3, r1
3419bac6:	607a      	str	r2, [r7, #4]
3419bac8:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419baca:	68fb      	ldr	r3, [r7, #12]
3419bacc:	3b04      	subs	r3, #4
3419bace:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read16(p_ctx, addr, value);
3419bad0:	897b      	ldrh	r3, [r7, #10]
3419bad2:	687a      	ldr	r2, [r7, #4]
3419bad4:	4619      	mov	r1, r3
3419bad6:	6978      	ldr	r0, [r7, #20]
3419bad8:	f7ff ff3e 	bl	3419b958 <CMW_VD55G1_Read16>
3419badc:	4603      	mov	r3, r0
}
3419bade:	4618      	mov	r0, r3
3419bae0:	3718      	adds	r7, #24
3419bae2:	46bd      	mov	sp, r7
3419bae4:	bd80      	pop	{r7, pc}

3419bae6 <VD55G1_Read32>:

static int VD55G1_Read32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t *value)
{
3419bae6:	b580      	push	{r7, lr}
3419bae8:	b086      	sub	sp, #24
3419baea:	af00      	add	r7, sp, #0
3419baec:	60f8      	str	r0, [r7, #12]
3419baee:	460b      	mov	r3, r1
3419baf0:	607a      	str	r2, [r7, #4]
3419baf2:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419baf4:	68fb      	ldr	r3, [r7, #12]
3419baf6:	3b04      	subs	r3, #4
3419baf8:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read32(p_ctx, addr, value);
3419bafa:	897b      	ldrh	r3, [r7, #10]
3419bafc:	687a      	ldr	r2, [r7, #4]
3419bafe:	4619      	mov	r1, r3
3419bb00:	6978      	ldr	r0, [r7, #20]
3419bb02:	f7ff ff4f 	bl	3419b9a4 <CMW_VD55G1_Read32>
3419bb06:	4603      	mov	r3, r0
}
3419bb08:	4618      	mov	r0, r3
3419bb0a:	3718      	adds	r7, #24
3419bb0c:	46bd      	mov	sp, r7
3419bb0e:	bd80      	pop	{r7, pc}

3419bb10 <VD55G1_Write8>:

static int VD55G1_Write8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t value)
{
3419bb10:	b580      	push	{r7, lr}
3419bb12:	b084      	sub	sp, #16
3419bb14:	af00      	add	r7, sp, #0
3419bb16:	6078      	str	r0, [r7, #4]
3419bb18:	460b      	mov	r3, r1
3419bb1a:	807b      	strh	r3, [r7, #2]
3419bb1c:	4613      	mov	r3, r2
3419bb1e:	707b      	strb	r3, [r7, #1]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419bb20:	687b      	ldr	r3, [r7, #4]
3419bb22:	3b04      	subs	r3, #4
3419bb24:	60fb      	str	r3, [r7, #12]

  return CMW_VD55G1_Write8(p_ctx, addr, value);
3419bb26:	787a      	ldrb	r2, [r7, #1]
3419bb28:	887b      	ldrh	r3, [r7, #2]
3419bb2a:	4619      	mov	r1, r3
3419bb2c:	68f8      	ldr	r0, [r7, #12]
3419bb2e:	f7ff ff61 	bl	3419b9f4 <CMW_VD55G1_Write8>
3419bb32:	4603      	mov	r3, r0
}
3419bb34:	4618      	mov	r0, r3
3419bb36:	3710      	adds	r7, #16
3419bb38:	46bd      	mov	sp, r7
3419bb3a:	bd80      	pop	{r7, pc}

3419bb3c <VD55G1_Write16>:

static int VD55G1_Write16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t value)
{
3419bb3c:	b580      	push	{r7, lr}
3419bb3e:	b084      	sub	sp, #16
3419bb40:	af00      	add	r7, sp, #0
3419bb42:	6078      	str	r0, [r7, #4]
3419bb44:	460b      	mov	r3, r1
3419bb46:	807b      	strh	r3, [r7, #2]
3419bb48:	4613      	mov	r3, r2
3419bb4a:	803b      	strh	r3, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419bb4c:	687b      	ldr	r3, [r7, #4]
3419bb4e:	3b04      	subs	r3, #4
3419bb50:	60fb      	str	r3, [r7, #12]

  return CMW_VD55G1_Write16(p_ctx, addr, value);
3419bb52:	883a      	ldrh	r2, [r7, #0]
3419bb54:	887b      	ldrh	r3, [r7, #2]
3419bb56:	4619      	mov	r1, r3
3419bb58:	68f8      	ldr	r0, [r7, #12]
3419bb5a:	f7ff ff60 	bl	3419ba1e <CMW_VD55G1_Write16>
3419bb5e:	4603      	mov	r3, r0
}
3419bb60:	4618      	mov	r0, r3
3419bb62:	3710      	adds	r7, #16
3419bb64:	46bd      	mov	sp, r7
3419bb66:	bd80      	pop	{r7, pc}

3419bb68 <VD55G1_Write32>:

static int VD55G1_Write32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t value)
{
3419bb68:	b580      	push	{r7, lr}
3419bb6a:	b086      	sub	sp, #24
3419bb6c:	af00      	add	r7, sp, #0
3419bb6e:	60f8      	str	r0, [r7, #12]
3419bb70:	460b      	mov	r3, r1
3419bb72:	607a      	str	r2, [r7, #4]
3419bb74:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419bb76:	68fb      	ldr	r3, [r7, #12]
3419bb78:	3b04      	subs	r3, #4
3419bb7a:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Write32(p_ctx, addr, value);
3419bb7c:	897b      	ldrh	r3, [r7, #10]
3419bb7e:	687a      	ldr	r2, [r7, #4]
3419bb80:	4619      	mov	r1, r3
3419bb82:	6978      	ldr	r0, [r7, #20]
3419bb84:	f7ff ff60 	bl	3419ba48 <CMW_VD55G1_Write32>
3419bb88:	4603      	mov	r3, r0
}
3419bb8a:	4618      	mov	r0, r3
3419bb8c:	3718      	adds	r7, #24
3419bb8e:	46bd      	mov	sp, r7
3419bb90:	bd80      	pop	{r7, pc}

3419bb92 <VD55G1_WriteArray>:

static int VD55G1_WriteArray(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
3419bb92:	b590      	push	{r4, r7, lr}
3419bb94:	b089      	sub	sp, #36	@ 0x24
3419bb96:	af00      	add	r7, sp, #0
3419bb98:	60f8      	str	r0, [r7, #12]
3419bb9a:	607a      	str	r2, [r7, #4]
3419bb9c:	603b      	str	r3, [r7, #0]
3419bb9e:	460b      	mov	r3, r1
3419bba0:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419bba2:	68fb      	ldr	r3, [r7, #12]
3419bba4:	3b04      	subs	r3, #4
3419bba6:	61fb      	str	r3, [r7, #28]
  const unsigned int chunk_size = 128;
3419bba8:	2380      	movs	r3, #128	@ 0x80
3419bbaa:	61bb      	str	r3, [r7, #24]
  uint16_t sz;
  int ret;

  while (data_len) {
3419bbac:	e01f      	b.n	3419bbee <VD55G1_WriteArray+0x5c>
    sz = MIN(data_len, chunk_size);
3419bbae:	683a      	ldr	r2, [r7, #0]
3419bbb0:	69bb      	ldr	r3, [r7, #24]
3419bbb2:	4293      	cmp	r3, r2
3419bbb4:	bf28      	it	cs
3419bbb6:	4613      	movcs	r3, r2
3419bbb8:	82fb      	strh	r3, [r7, #22]
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
3419bbba:	69fb      	ldr	r3, [r7, #28]
3419bbbc:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419bbbe:	69fb      	ldr	r3, [r7, #28]
3419bbc0:	8818      	ldrh	r0, [r3, #0]
3419bbc2:	8afb      	ldrh	r3, [r7, #22]
3419bbc4:	8979      	ldrh	r1, [r7, #10]
3419bbc6:	687a      	ldr	r2, [r7, #4]
3419bbc8:	47a0      	blx	r4
3419bbca:	6138      	str	r0, [r7, #16]
    if (ret)
3419bbcc:	693b      	ldr	r3, [r7, #16]
3419bbce:	2b00      	cmp	r3, #0
3419bbd0:	d001      	beq.n	3419bbd6 <VD55G1_WriteArray+0x44>
      return ret;
3419bbd2:	693b      	ldr	r3, [r7, #16]
3419bbd4:	e00f      	b.n	3419bbf6 <VD55G1_WriteArray+0x64>
    data_len -= sz;
3419bbd6:	8afb      	ldrh	r3, [r7, #22]
3419bbd8:	683a      	ldr	r2, [r7, #0]
3419bbda:	1ad3      	subs	r3, r2, r3
3419bbdc:	603b      	str	r3, [r7, #0]
    addr += sz;
3419bbde:	897a      	ldrh	r2, [r7, #10]
3419bbe0:	8afb      	ldrh	r3, [r7, #22]
3419bbe2:	4413      	add	r3, r2
3419bbe4:	817b      	strh	r3, [r7, #10]
    data += sz;
3419bbe6:	8afb      	ldrh	r3, [r7, #22]
3419bbe8:	687a      	ldr	r2, [r7, #4]
3419bbea:	4413      	add	r3, r2
3419bbec:	607b      	str	r3, [r7, #4]
  while (data_len) {
3419bbee:	683b      	ldr	r3, [r7, #0]
3419bbf0:	2b00      	cmp	r3, #0
3419bbf2:	d1dc      	bne.n	3419bbae <VD55G1_WriteArray+0x1c>
  }

  return 0;
3419bbf4:	2300      	movs	r3, #0
}
3419bbf6:	4618      	mov	r0, r3
3419bbf8:	3724      	adds	r7, #36	@ 0x24
3419bbfa:	46bd      	mov	sp, r7
3419bbfc:	bd90      	pop	{r4, r7, pc}

3419bbfe <VD55G1_Delay>:

static void VD55G1_Delay(struct VD55G1_Ctx *ctx, uint32_t delay_in_ms)
{
3419bbfe:	b580      	push	{r7, lr}
3419bc00:	b084      	sub	sp, #16
3419bc02:	af00      	add	r7, sp, #0
3419bc04:	6078      	str	r0, [r7, #4]
3419bc06:	6039      	str	r1, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419bc08:	687b      	ldr	r3, [r7, #4]
3419bc0a:	3b04      	subs	r3, #4
3419bc0c:	60fb      	str	r3, [r7, #12]

  p_ctx->Delay(delay_in_ms);
3419bc0e:	68fb      	ldr	r3, [r7, #12]
3419bc10:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419bc14:	6838      	ldr	r0, [r7, #0]
3419bc16:	4798      	blx	r3
}
3419bc18:	bf00      	nop
3419bc1a:	3710      	adds	r7, #16
3419bc1c:	46bd      	mov	sp, r7
3419bc1e:	bd80      	pop	{r7, pc}

3419bc20 <VD55G1_Log>:

static void VD55G1_Log(struct VD55G1_Ctx *ctx, int lvl, const char *format, va_list ap)
{
3419bc20:	b480      	push	{r7}
3419bc22:	b085      	sub	sp, #20
3419bc24:	af00      	add	r7, sp, #0
3419bc26:	60f8      	str	r0, [r7, #12]
3419bc28:	60b9      	str	r1, [r7, #8]
3419bc2a:	607a      	str	r2, [r7, #4]
3419bc2c:	603b      	str	r3, [r7, #0]
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3419bc2e:	bf00      	nop
3419bc30:	3714      	adds	r7, #20
3419bc32:	46bd      	mov	sp, r7
3419bc34:	f85d 7b04 	ldr.w	r7, [sp], #4
3419bc38:	4770      	bx	lr

3419bc3a <CMW_VD55G1_GetSensorInfo>:
  * @param  pObj  pointer to component object
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
static int32_t CMW_VD55G1_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419bc3a:	b480      	push	{r7}
3419bc3c:	b083      	sub	sp, #12
3419bc3e:	af00      	add	r7, sp, #0
3419bc40:	6078      	str	r0, [r7, #4]
3419bc42:	6039      	str	r1, [r7, #0]
  if ((io_ctx ==  NULL) || (info == NULL))
3419bc44:	687b      	ldr	r3, [r7, #4]
3419bc46:	2b00      	cmp	r3, #0
3419bc48:	d002      	beq.n	3419bc50 <CMW_VD55G1_GetSensorInfo+0x16>
3419bc4a:	683b      	ldr	r3, [r7, #0]
3419bc4c:	2b00      	cmp	r3, #0
3419bc4e:	d102      	bne.n	3419bc56 <CMW_VD55G1_GetSensorInfo+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3419bc50:	f06f 0301 	mvn.w	r3, #1
3419bc54:	e008      	b.n	3419bc68 <CMW_VD55G1_GetSensorInfo+0x2e>
  }

  /* Return the default full resolution */
  info->width = VD55G1_MAX_WIDTH;
3419bc56:	683b      	ldr	r3, [r7, #0]
3419bc58:	f44f 7249 	mov.w	r2, #804	@ 0x324
3419bc5c:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = VD55G1_MAX_HEIGHT;
3419bc5e:	683b      	ldr	r3, [r7, #0]
3419bc60:	f44f 7230 	mov.w	r2, #704	@ 0x2c0
3419bc64:	629a      	str	r2, [r3, #40]	@ 0x28

  return CMW_ERROR_NONE;
3419bc66:	2300      	movs	r3, #0
}
3419bc68:	4618      	mov	r0, r3
3419bc6a:	370c      	adds	r7, #12
3419bc6c:	46bd      	mov	sp, r7
3419bc6e:	f85d 7b04 	ldr.w	r7, [sp], #4
3419bc72:	4770      	bx	lr

3419bc74 <CMW_VD55G1_GetResType>:

static int CMW_VD55G1_GetResType(uint32_t width, uint32_t height, VD55G1_Res_t *res)
{
3419bc74:	b480      	push	{r7}
3419bc76:	b085      	sub	sp, #20
3419bc78:	af00      	add	r7, sp, #0
3419bc7a:	60f8      	str	r0, [r7, #12]
3419bc7c:	60b9      	str	r1, [r7, #8]
3419bc7e:	607a      	str	r2, [r7, #4]
  if (width == 320 && height == 240)
3419bc80:	68fb      	ldr	r3, [r7, #12]
3419bc82:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
3419bc86:	d106      	bne.n	3419bc96 <CMW_VD55G1_GetResType+0x22>
3419bc88:	68bb      	ldr	r3, [r7, #8]
3419bc8a:	2bf0      	cmp	r3, #240	@ 0xf0
3419bc8c:	d103      	bne.n	3419bc96 <CMW_VD55G1_GetResType+0x22>
  {
    *res = VD55G1_RES_QVGA_320_240;
3419bc8e:	687b      	ldr	r3, [r7, #4]
3419bc90:	2200      	movs	r2, #0
3419bc92:	701a      	strb	r2, [r3, #0]
3419bc94:	e026      	b.n	3419bce4 <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 640 && height == 480)
3419bc96:	68fb      	ldr	r3, [r7, #12]
3419bc98:	f5b3 7f20 	cmp.w	r3, #640	@ 0x280
3419bc9c:	d107      	bne.n	3419bcae <CMW_VD55G1_GetResType+0x3a>
3419bc9e:	68bb      	ldr	r3, [r7, #8]
3419bca0:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3419bca4:	d103      	bne.n	3419bcae <CMW_VD55G1_GetResType+0x3a>
  {
    *res = VD55G1_RES_VGA_640_480;
3419bca6:	687b      	ldr	r3, [r7, #4]
3419bca8:	2201      	movs	r2, #1
3419bcaa:	701a      	strb	r2, [r3, #0]
3419bcac:	e01a      	b.n	3419bce4 <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 800 && height == 600)
3419bcae:	68fb      	ldr	r3, [r7, #12]
3419bcb0:	f5b3 7f48 	cmp.w	r3, #800	@ 0x320
3419bcb4:	d107      	bne.n	3419bcc6 <CMW_VD55G1_GetResType+0x52>
3419bcb6:	68bb      	ldr	r3, [r7, #8]
3419bcb8:	f5b3 7f16 	cmp.w	r3, #600	@ 0x258
3419bcbc:	d103      	bne.n	3419bcc6 <CMW_VD55G1_GetResType+0x52>
  {
    *res = VD55G1_RES_SXGA_800_600;
3419bcbe:	687b      	ldr	r3, [r7, #4]
3419bcc0:	2202      	movs	r2, #2
3419bcc2:	701a      	strb	r2, [r3, #0]
3419bcc4:	e00e      	b.n	3419bce4 <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 804 && height == 704)
3419bcc6:	68fb      	ldr	r3, [r7, #12]
3419bcc8:	f5b3 7f49 	cmp.w	r3, #804	@ 0x324
3419bccc:	d107      	bne.n	3419bcde <CMW_VD55G1_GetResType+0x6a>
3419bcce:	68bb      	ldr	r3, [r7, #8]
3419bcd0:	f5b3 7f30 	cmp.w	r3, #704	@ 0x2c0
3419bcd4:	d103      	bne.n	3419bcde <CMW_VD55G1_GetResType+0x6a>
  {
      *res = VD55G1_RES_FULL_804_704;
3419bcd6:	687b      	ldr	r3, [r7, #4]
3419bcd8:	2203      	movs	r2, #3
3419bcda:	701a      	strb	r2, [r3, #0]
3419bcdc:	e002      	b.n	3419bce4 <CMW_VD55G1_GetResType+0x70>
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
3419bcde:	f06f 0301 	mvn.w	r3, #1
3419bce2:	e000      	b.n	3419bce6 <CMW_VD55G1_GetResType+0x72>
  }
  return 0;
3419bce4:	2300      	movs	r3, #0
}
3419bce6:	4618      	mov	r0, r3
3419bce8:	3714      	adds	r7, #20
3419bcea:	46bd      	mov	sp, r7
3419bcec:	f85d 7b04 	ldr.w	r7, [sp], #4
3419bcf0:	4770      	bx	lr

3419bcf2 <CMW_VD55G1_getMirrorFlipConfig>:

static VD55G1_MirrorFlip_t CMW_VD55G1_getMirrorFlipConfig(int32_t Config)
{
3419bcf2:	b480      	push	{r7}
3419bcf4:	b085      	sub	sp, #20
3419bcf6:	af00      	add	r7, sp, #0
3419bcf8:	6078      	str	r0, [r7, #4]
  VD55G1_MirrorFlip_t ret;

  switch (Config)
3419bcfa:	687b      	ldr	r3, [r7, #4]
3419bcfc:	2b02      	cmp	r3, #2
3419bcfe:	d00f      	beq.n	3419bd20 <CMW_VD55G1_getMirrorFlipConfig+0x2e>
3419bd00:	687b      	ldr	r3, [r7, #4]
3419bd02:	2b02      	cmp	r3, #2
3419bd04:	dc0f      	bgt.n	3419bd26 <CMW_VD55G1_getMirrorFlipConfig+0x34>
3419bd06:	687b      	ldr	r3, [r7, #4]
3419bd08:	2b00      	cmp	r3, #0
3419bd0a:	d003      	beq.n	3419bd14 <CMW_VD55G1_getMirrorFlipConfig+0x22>
3419bd0c:	687b      	ldr	r3, [r7, #4]
3419bd0e:	2b01      	cmp	r3, #1
3419bd10:	d003      	beq.n	3419bd1a <CMW_VD55G1_getMirrorFlipConfig+0x28>
3419bd12:	e008      	b.n	3419bd26 <CMW_VD55G1_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_MIRROR_FLIP_NONE;
3419bd14:	2300      	movs	r3, #0
3419bd16:	73fb      	strb	r3, [r7, #15]
      break;
3419bd18:	e008      	b.n	3419bd2c <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD55G1_FLIP;
3419bd1a:	2301      	movs	r3, #1
3419bd1c:	73fb      	strb	r3, [r7, #15]
      break;
3419bd1e:	e005      	b.n	3419bd2c <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_MIRROR;
3419bd20:	2302      	movs	r3, #2
3419bd22:	73fb      	strb	r3, [r7, #15]
      break;
3419bd24:	e002      	b.n	3419bd2c <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = VD55G1_MIRROR_FLIP;
3419bd26:	2303      	movs	r3, #3
3419bd28:	73fb      	strb	r3, [r7, #15]
      break;
3419bd2a:	bf00      	nop
  }

  return ret;
3419bd2c:	7bfb      	ldrb	r3, [r7, #15]
}
3419bd2e:	4618      	mov	r0, r3
3419bd30:	3714      	adds	r7, #20
3419bd32:	46bd      	mov	sp, r7
3419bd34:	f85d 7b04 	ldr.w	r7, [sp], #4
3419bd38:	4770      	bx	lr
	...

3419bd3c <CMW_VD55G1_Init>:

static int32_t CMW_VD55G1_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419bd3c:	b580      	push	{r7, lr}
3419bd3e:	b096      	sub	sp, #88	@ 0x58
3419bd40:	af00      	add	r7, sp, #0
3419bd42:	6078      	str	r0, [r7, #4]
3419bd44:	6039      	str	r1, [r7, #0]
  VD55G1_Config_t config = { 0 };
3419bd46:	f107 0318 	add.w	r3, r7, #24
3419bd4a:	2234      	movs	r2, #52	@ 0x34
3419bd4c:	2100      	movs	r1, #0
3419bd4e:	4618      	mov	r0, r3
3419bd50:	f008 f828 	bl	341a3da4 <memset>
  int ret;
  int i;

  assert(initSensor != NULL);
3419bd54:	683b      	ldr	r3, [r7, #0]
3419bd56:	2b00      	cmp	r3, #0
3419bd58:	d105      	bne.n	3419bd66 <CMW_VD55G1_Init+0x2a>
3419bd5a:	4b39      	ldr	r3, [pc, #228]	@ (3419be40 <CMW_VD55G1_Init+0x104>)
3419bd5c:	4a39      	ldr	r2, [pc, #228]	@ (3419be44 <CMW_VD55G1_Init+0x108>)
3419bd5e:	21f8      	movs	r1, #248	@ 0xf8
3419bd60:	4839      	ldr	r0, [pc, #228]	@ (3419be48 <CMW_VD55G1_Init+0x10c>)
3419bd62:	f007 fd95 	bl	341a3890 <__assert_func>

  if (((CMW_VD55G1_t *)io_ctx)->IsInitialized)
3419bd66:	687b      	ldr	r3, [r7, #4]
3419bd68:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
3419bd6c:	2b00      	cmp	r3, #0
3419bd6e:	d001      	beq.n	3419bd74 <CMW_VD55G1_Init+0x38>
  {
    return CMW_ERROR_NONE;
3419bd70:	2300      	movs	r3, #0
3419bd72:	e061      	b.n	3419be38 <CMW_VD55G1_Init+0xfc>
  }

  config.frame_rate = initSensor->fps;
3419bd74:	683b      	ldr	r3, [r7, #0]
3419bd76:	689b      	ldr	r3, [r3, #8]
3419bd78:	623b      	str	r3, [r7, #32]
  ret = CMW_VD55G1_GetResType(initSensor->width, initSensor->height, &config.resolution);
3419bd7a:	683b      	ldr	r3, [r7, #0]
3419bd7c:	6818      	ldr	r0, [r3, #0]
3419bd7e:	683b      	ldr	r3, [r7, #0]
3419bd80:	6859      	ldr	r1, [r3, #4]
3419bd82:	f107 0318 	add.w	r3, r7, #24
3419bd86:	3304      	adds	r3, #4
3419bd88:	461a      	mov	r2, r3
3419bd8a:	f7ff ff73 	bl	3419bc74 <CMW_VD55G1_GetResType>
3419bd8e:	6538      	str	r0, [r7, #80]	@ 0x50
  if (ret)
3419bd90:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419bd92:	2b00      	cmp	r3, #0
3419bd94:	d002      	beq.n	3419bd9c <CMW_VD55G1_Init+0x60>
  {
    return CMW_ERROR_WRONG_PARAM;
3419bd96:	f06f 0301 	mvn.w	r3, #1
3419bd9a:	e04d      	b.n	3419be38 <CMW_VD55G1_Init+0xfc>
  }

  CMW_VD55G1_config_t default_sensor_config;
  CMW_VD55G1_config_t *sensor_config;

  CMW_VD55G1_SetDefaultSensorValues(&default_sensor_config);
3419bd9c:	f107 0308 	add.w	r3, r7, #8
3419bda0:	4618      	mov	r0, r3
3419bda2:	f000 f853 	bl	3419be4c <CMW_VD55G1_SetDefaultSensorValues>
  sensor_config = initSensor->sensor_config ? (CMW_VD55G1_config_t*)(initSensor->sensor_config) : &default_sensor_config;
3419bda6:	683b      	ldr	r3, [r7, #0]
3419bda8:	695b      	ldr	r3, [r3, #20]
3419bdaa:	2b00      	cmp	r3, #0
3419bdac:	d002      	beq.n	3419bdb4 <CMW_VD55G1_Init+0x78>
3419bdae:	683b      	ldr	r3, [r7, #0]
3419bdb0:	695b      	ldr	r3, [r3, #20]
3419bdb2:	e001      	b.n	3419bdb8 <CMW_VD55G1_Init+0x7c>
3419bdb4:	f107 0308 	add.w	r3, r7, #8
3419bdb8:	64fb      	str	r3, [r7, #76]	@ 0x4c

  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3419bdba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419bdbc:	681b      	ldr	r3, [r3, #0]
3419bdbe:	61bb      	str	r3, [r7, #24]
  config.out_itf.data_rate_in_mps = sensor_config->csiconfig.data_rate_in_mps;
3419bdc0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419bdc2:	685b      	ldr	r3, [r3, #4]
3419bdc4:	62bb      	str	r3, [r7, #40]	@ 0x28
  config.out_itf.clock_lane_swap_enable =sensor_config->csiconfig.clock_lane_swap_enable;
3419bdc6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419bdc8:	689b      	ldr	r3, [r3, #8]
3419bdca:	62fb      	str	r3, [r7, #44]	@ 0x2c
  config.out_itf.data_lane_swap_enable = sensor_config->csiconfig.data_lane_swap_enable;
3419bdcc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419bdce:	68db      	ldr	r3, [r3, #12]
3419bdd0:	633b      	str	r3, [r7, #48]	@ 0x30

  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
3419bdd2:	683b      	ldr	r3, [r7, #0]
3419bdd4:	691b      	ldr	r3, [r3, #16]
3419bdd6:	4618      	mov	r0, r3
3419bdd8:	f7ff ff8b 	bl	3419bcf2 <CMW_VD55G1_getMirrorFlipConfig>
3419bddc:	4603      	mov	r3, r0
3419bdde:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  config.patgen = VD55G1_PATGEN_DISABLE;
3419bde2:	2300      	movs	r3, #0
3419bde4:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  config.flicker = VD55G1_FLICKER_FREE_NONE;
3419bde8:	2300      	movs	r3, #0
3419bdea:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  config.awu.is_enable = 0;
3419bdee:	2300      	movs	r3, #0
3419bdf0:	637b      	str	r3, [r7, #52]	@ 0x34

  for (i = 0; i < VD55G1_GPIO_NB; i++)
3419bdf2:	2300      	movs	r3, #0
3419bdf4:	657b      	str	r3, [r7, #84]	@ 0x54
3419bdf6:	e008      	b.n	3419be0a <CMW_VD55G1_Init+0xce>
  {
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
3419bdf8:	f107 0248 	add.w	r2, r7, #72	@ 0x48
3419bdfc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419bdfe:	4413      	add	r3, r2
3419be00:	2201      	movs	r2, #1
3419be02:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < VD55G1_GPIO_NB; i++)
3419be04:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419be06:	3301      	adds	r3, #1
3419be08:	657b      	str	r3, [r7, #84]	@ 0x54
3419be0a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419be0c:	2b03      	cmp	r3, #3
3419be0e:	ddf3      	ble.n	3419bdf8 <CMW_VD55G1_Init+0xbc>
  }

  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
3419be10:	687b      	ldr	r3, [r7, #4]
3419be12:	3304      	adds	r3, #4
3419be14:	f107 0218 	add.w	r2, r7, #24
3419be18:	4611      	mov	r1, r2
3419be1a:	4618      	mov	r0, r3
3419be1c:	f003 f850 	bl	3419eec0 <VD55G1_Init>
3419be20:	6538      	str	r0, [r7, #80]	@ 0x50
  if (ret)
3419be22:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419be24:	2b00      	cmp	r3, #0
3419be26:	d002      	beq.n	3419be2e <CMW_VD55G1_Init+0xf2>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419be28:	f06f 0303 	mvn.w	r3, #3
3419be2c:	e004      	b.n	3419be38 <CMW_VD55G1_Init+0xfc>
  }

  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 1;
3419be2e:	687b      	ldr	r3, [r7, #4]
3419be30:	2201      	movs	r2, #1
3419be32:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  return CMW_ERROR_NONE;
3419be36:	2300      	movs	r3, #0
}
3419be38:	4618      	mov	r0, r3
3419be3a:	3758      	adds	r7, #88	@ 0x58
3419be3c:	46bd      	mov	sp, r7
3419be3e:	bd80      	pop	{r7, pc}
3419be40:	341a5fa4 	.word	0x341a5fa4
3419be44:	341b1218 	.word	0x341b1218
3419be48:	341a5fb8 	.word	0x341a5fb8

3419be4c <CMW_VD55G1_SetDefaultSensorValues>:

void CMW_VD55G1_SetDefaultSensorValues( CMW_VD55G1_config_t *vd55g1_config)
{
3419be4c:	b580      	push	{r7, lr}
3419be4e:	b082      	sub	sp, #8
3419be50:	af00      	add	r7, sp, #0
3419be52:	6078      	str	r0, [r7, #4]
  assert(vd55g1_config != NULL);
3419be54:	687b      	ldr	r3, [r7, #4]
3419be56:	2b00      	cmp	r3, #0
3419be58:	d106      	bne.n	3419be68 <CMW_VD55G1_SetDefaultSensorValues+0x1c>
3419be5a:	4b0b      	ldr	r3, [pc, #44]	@ (3419be88 <CMW_VD55G1_SetDefaultSensorValues+0x3c>)
3419be5c:	4a0b      	ldr	r2, [pc, #44]	@ (3419be8c <CMW_VD55G1_SetDefaultSensorValues+0x40>)
3419be5e:	f240 1127 	movw	r1, #295	@ 0x127
3419be62:	480b      	ldr	r0, [pc, #44]	@ (3419be90 <CMW_VD55G1_SetDefaultSensorValues+0x44>)
3419be64:	f007 fd14 	bl	341a3890 <__assert_func>

  vd55g1_config->ext_clock_freq_in_hz = CAMERA_VD55G1_FREQ_IN_HZ; // Default clock frequency
3419be68:	687b      	ldr	r3, [r7, #4]
3419be6a:	4a0a      	ldr	r2, [pc, #40]	@ (3419be94 <CMW_VD55G1_SetDefaultSensorValues+0x48>)
3419be6c:	601a      	str	r2, [r3, #0]
  vd55g1_config->csiconfig.data_rate_in_mps = VD55G1_DEFAULT_DATARATE;
3419be6e:	687b      	ldr	r3, [r7, #4]
3419be70:	4a09      	ldr	r2, [pc, #36]	@ (3419be98 <CMW_VD55G1_SetDefaultSensorValues+0x4c>)
3419be72:	605a      	str	r2, [r3, #4]
  vd55g1_config->csiconfig.clock_lane_swap_enable = 1;
3419be74:	687b      	ldr	r3, [r7, #4]
3419be76:	2201      	movs	r2, #1
3419be78:	609a      	str	r2, [r3, #8]
  vd55g1_config->csiconfig.data_lane_swap_enable = 1;
3419be7a:	687b      	ldr	r3, [r7, #4]
3419be7c:	2201      	movs	r2, #1
3419be7e:	60da      	str	r2, [r3, #12]
}
3419be80:	bf00      	nop
3419be82:	3708      	adds	r7, #8
3419be84:	46bd      	mov	sp, r7
3419be86:	bd80      	pop	{r7, pc}
3419be88:	341a5ff0 	.word	0x341a5ff0
3419be8c:	341b1228 	.word	0x341b1228
3419be90:	341a5fb8 	.word	0x341a5fb8
3419be94:	00b71b00 	.word	0x00b71b00
3419be98:	2fec1100 	.word	0x2fec1100

3419be9c <CMW_VD55G1_Start>:

static int32_t CMW_VD55G1_Start(void *io_ctx)
{
3419be9c:	b580      	push	{r7, lr}
3419be9e:	b084      	sub	sp, #16
3419bea0:	af00      	add	r7, sp, #0
3419bea2:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419bea4:	2300      	movs	r3, #0
3419bea6:	60fb      	str	r3, [r7, #12]
  ret = VD55G1_Start(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419bea8:	687b      	ldr	r3, [r7, #4]
3419beaa:	3304      	adds	r3, #4
3419beac:	4618      	mov	r0, r3
3419beae:	f003 f898 	bl	3419efe2 <VD55G1_Start>
3419beb2:	60f8      	str	r0, [r7, #12]
  if (ret) {
3419beb4:	68fb      	ldr	r3, [r7, #12]
3419beb6:	2b00      	cmp	r3, #0
3419beb8:	d007      	beq.n	3419beca <CMW_VD55G1_Start+0x2e>
    VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419beba:	687b      	ldr	r3, [r7, #4]
3419bebc:	3304      	adds	r3, #4
3419bebe:	4618      	mov	r0, r3
3419bec0:	f003 f872 	bl	3419efa8 <VD55G1_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419bec4:	f06f 0303 	mvn.w	r3, #3
3419bec8:	e000      	b.n	3419becc <CMW_VD55G1_Start+0x30>
  }
  return CMW_ERROR_NONE;
3419beca:	2300      	movs	r3, #0
}
3419becc:	4618      	mov	r0, r3
3419bece:	3710      	adds	r7, #16
3419bed0:	46bd      	mov	sp, r7
3419bed2:	bd80      	pop	{r7, pc}

3419bed4 <CMW_VD55G1_Stop>:

static int32_t CMW_VD55G1_Stop(void *io_ctx)
{
3419bed4:	b580      	push	{r7, lr}
3419bed6:	b084      	sub	sp, #16
3419bed8:	af00      	add	r7, sp, #0
3419beda:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419bedc:	2300      	movs	r3, #0
3419bede:	60fb      	str	r3, [r7, #12]

  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419bee0:	687b      	ldr	r3, [r7, #4]
3419bee2:	3304      	adds	r3, #4
3419bee4:	4618      	mov	r0, r3
3419bee6:	f003 f89d 	bl	3419f024 <VD55G1_Stop>
3419beea:	60f8      	str	r0, [r7, #12]
  if (ret)
3419beec:	68fb      	ldr	r3, [r7, #12]
3419beee:	2b00      	cmp	r3, #0
3419bef0:	d002      	beq.n	3419bef8 <CMW_VD55G1_Stop+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bef2:	f06f 0303 	mvn.w	r3, #3
3419bef6:	e000      	b.n	3419befa <CMW_VD55G1_Stop+0x26>
  }
  return CMW_ERROR_NONE;
3419bef8:	2300      	movs	r3, #0
}
3419befa:	4618      	mov	r0, r3
3419befc:	3710      	adds	r7, #16
3419befe:	46bd      	mov	sp, r7
3419bf00:	bd80      	pop	{r7, pc}

3419bf02 <CMW_VD55G1_DeInit>:

static int32_t CMW_VD55G1_DeInit(void *io_ctx)
{
3419bf02:	b580      	push	{r7, lr}
3419bf04:	b084      	sub	sp, #16
3419bf06:	af00      	add	r7, sp, #0
3419bf08:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419bf0a:	2300      	movs	r3, #0
3419bf0c:	60fb      	str	r3, [r7, #12]

  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419bf0e:	687b      	ldr	r3, [r7, #4]
3419bf10:	3304      	adds	r3, #4
3419bf12:	4618      	mov	r0, r3
3419bf14:	f003 f886 	bl	3419f024 <VD55G1_Stop>
3419bf18:	60f8      	str	r0, [r7, #12]
  if (ret)
3419bf1a:	68fb      	ldr	r3, [r7, #12]
3419bf1c:	2b00      	cmp	r3, #0
3419bf1e:	d002      	beq.n	3419bf26 <CMW_VD55G1_DeInit+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bf20:	f06f 0303 	mvn.w	r3, #3
3419bf24:	e010      	b.n	3419bf48 <CMW_VD55G1_DeInit+0x46>
  }

  ret = VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419bf26:	687b      	ldr	r3, [r7, #4]
3419bf28:	3304      	adds	r3, #4
3419bf2a:	4618      	mov	r0, r3
3419bf2c:	f003 f83c 	bl	3419efa8 <VD55G1_DeInit>
3419bf30:	60f8      	str	r0, [r7, #12]
  if (ret)
3419bf32:	68fb      	ldr	r3, [r7, #12]
3419bf34:	2b00      	cmp	r3, #0
3419bf36:	d002      	beq.n	3419bf3e <CMW_VD55G1_DeInit+0x3c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bf38:	f06f 0303 	mvn.w	r3, #3
3419bf3c:	e004      	b.n	3419bf48 <CMW_VD55G1_DeInit+0x46>
  }

  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 0;
3419bf3e:	687b      	ldr	r3, [r7, #4]
3419bf40:	2200      	movs	r2, #0
3419bf42:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  return CMW_ERROR_NONE;
3419bf46:	2300      	movs	r3, #0
}
3419bf48:	4618      	mov	r0, r3
3419bf4a:	3710      	adds	r7, #16
3419bf4c:	46bd      	mov	sp, r7
3419bf4e:	bd80      	pop	{r7, pc}

3419bf50 <CMW_VD55G1_MirrorFlipConfig>:

static int32_t CMW_VD55G1_MirrorFlipConfig(void *io_ctx, uint32_t Config)
{
3419bf50:	b580      	push	{r7, lr}
3419bf52:	b084      	sub	sp, #16
3419bf54:	af00      	add	r7, sp, #0
3419bf56:	6078      	str	r0, [r7, #4]
3419bf58:	6039      	str	r1, [r7, #0]
  int32_t ret = CMW_ERROR_NONE;
3419bf5a:	2300      	movs	r3, #0
3419bf5c:	60fb      	str	r3, [r7, #12]

  switch (Config) {
3419bf5e:	683b      	ldr	r3, [r7, #0]
3419bf60:	2b03      	cmp	r3, #3
3419bf62:	d82b      	bhi.n	3419bfbc <CMW_VD55G1_MirrorFlipConfig+0x6c>
3419bf64:	a201      	add	r2, pc, #4	@ (adr r2, 3419bf6c <CMW_VD55G1_MirrorFlipConfig+0x1c>)
3419bf66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419bf6a:	bf00      	nop
3419bf6c:	3419bf7d 	.word	0x3419bf7d
3419bf70:	3419bf8d 	.word	0x3419bf8d
3419bf74:	3419bf9d 	.word	0x3419bf9d
3419bf78:	3419bfad 	.word	0x3419bfad
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP_NONE);
3419bf7c:	687b      	ldr	r3, [r7, #4]
3419bf7e:	3304      	adds	r3, #4
3419bf80:	2100      	movs	r1, #0
3419bf82:	4618      	mov	r0, r3
3419bf84:	f003 f866 	bl	3419f054 <VD55G1_SetFlipMirrorMode>
3419bf88:	60f8      	str	r0, [r7, #12]
      break;
3419bf8a:	e01a      	b.n	3419bfc2 <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_FLIP);
3419bf8c:	687b      	ldr	r3, [r7, #4]
3419bf8e:	3304      	adds	r3, #4
3419bf90:	2101      	movs	r1, #1
3419bf92:	4618      	mov	r0, r3
3419bf94:	f003 f85e 	bl	3419f054 <VD55G1_SetFlipMirrorMode>
3419bf98:	60f8      	str	r0, [r7, #12]
      break;
3419bf9a:	e012      	b.n	3419bfc2 <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
3419bf9c:	687b      	ldr	r3, [r7, #4]
3419bf9e:	3304      	adds	r3, #4
3419bfa0:	2102      	movs	r1, #2
3419bfa2:	4618      	mov	r0, r3
3419bfa4:	f003 f856 	bl	3419f054 <VD55G1_SetFlipMirrorMode>
3419bfa8:	60f8      	str	r0, [r7, #12]
      break;
3419bfaa:	e00a      	b.n	3419bfc2 <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
3419bfac:	687b      	ldr	r3, [r7, #4]
3419bfae:	3304      	adds	r3, #4
3419bfb0:	2103      	movs	r1, #3
3419bfb2:	4618      	mov	r0, r3
3419bfb4:	f003 f84e 	bl	3419f054 <VD55G1_SetFlipMirrorMode>
3419bfb8:	60f8      	str	r0, [r7, #12]
      break;
3419bfba:	e002      	b.n	3419bfc2 <CMW_VD55G1_MirrorFlipConfig+0x72>
    default:
      ret = CMW_ERROR_PERIPH_FAILURE;
3419bfbc:	f06f 0303 	mvn.w	r3, #3
3419bfc0:	60fb      	str	r3, [r7, #12]
  }

  return ret;
3419bfc2:	68fb      	ldr	r3, [r7, #12]
}
3419bfc4:	4618      	mov	r0, r3
3419bfc6:	3710      	adds	r7, #16
3419bfc8:	46bd      	mov	sp, r7
3419bfca:	bd80      	pop	{r7, pc}

3419bfcc <VD55G1_RegisterBusIO>:

static int32_t VD55G1_RegisterBusIO(CMW_VD55G1_t *io_ctx)
{
3419bfcc:	b580      	push	{r7, lr}
3419bfce:	b084      	sub	sp, #16
3419bfd0:	af00      	add	r7, sp, #0
3419bfd2:	6078      	str	r0, [r7, #4]
  int ret;

  if (!io_ctx)
3419bfd4:	687b      	ldr	r3, [r7, #4]
3419bfd6:	2b00      	cmp	r3, #0
3419bfd8:	d102      	bne.n	3419bfe0 <VD55G1_RegisterBusIO+0x14>
    return CMW_ERROR_COMPONENT_FAILURE;
3419bfda:	f06f 0304 	mvn.w	r3, #4
3419bfde:	e00b      	b.n	3419bff8 <VD55G1_RegisterBusIO+0x2c>

  if (!io_ctx->Init)
3419bfe0:	687b      	ldr	r3, [r7, #4]
3419bfe2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419bfe4:	2b00      	cmp	r3, #0
3419bfe6:	d102      	bne.n	3419bfee <VD55G1_RegisterBusIO+0x22>
    return CMW_ERROR_COMPONENT_FAILURE;
3419bfe8:	f06f 0304 	mvn.w	r3, #4
3419bfec:	e004      	b.n	3419bff8 <VD55G1_RegisterBusIO+0x2c>

  ret = io_ctx->Init();
3419bfee:	687b      	ldr	r3, [r7, #4]
3419bff0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419bff2:	4798      	blx	r3
3419bff4:	60f8      	str	r0, [r7, #12]
//  ret = BSP_ERROR_NONE;
  return ret;
3419bff6:	68fb      	ldr	r3, [r7, #12]
}
3419bff8:	4618      	mov	r0, r3
3419bffa:	3710      	adds	r7, #16
3419bffc:	46bd      	mov	sp, r7
3419bffe:	bd80      	pop	{r7, pc}

3419c000 <VD55G1_ReadID>:

static int32_t VD55G1_ReadID(CMW_VD55G1_t *io_ctx, uint32_t *Id)
{
3419c000:	b580      	push	{r7, lr}
3419c002:	b084      	sub	sp, #16
3419c004:	af00      	add	r7, sp, #0
3419c006:	6078      	str	r0, [r7, #4]
3419c008:	6039      	str	r1, [r7, #0]
  uint32_t reg32;
  int32_t ret;

  ret = CMW_VD55G1_Read32(io_ctx, VD55G1_REG_MODEL_ID, &reg32);
3419c00a:	f107 0308 	add.w	r3, r7, #8
3419c00e:	461a      	mov	r2, r3
3419c010:	2100      	movs	r1, #0
3419c012:	6878      	ldr	r0, [r7, #4]
3419c014:	f7ff fcc6 	bl	3419b9a4 <CMW_VD55G1_Read32>
3419c018:	60f8      	str	r0, [r7, #12]
  if (ret)
3419c01a:	68fb      	ldr	r3, [r7, #12]
3419c01c:	2b00      	cmp	r3, #0
3419c01e:	d001      	beq.n	3419c024 <VD55G1_ReadID+0x24>
    return ret;
3419c020:	68fb      	ldr	r3, [r7, #12]
3419c022:	e003      	b.n	3419c02c <VD55G1_ReadID+0x2c>

  *Id = reg32;
3419c024:	68ba      	ldr	r2, [r7, #8]
3419c026:	683b      	ldr	r3, [r7, #0]
3419c028:	601a      	str	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419c02a:	2300      	movs	r3, #0
}
3419c02c:	4618      	mov	r0, r3
3419c02e:	3710      	adds	r7, #16
3419c030:	46bd      	mov	sp, r7
3419c032:	bd80      	pop	{r7, pc}

3419c034 <CMW_VD55G1_PowerOn>:

static void CMW_VD55G1_PowerOn(CMW_VD55G1_t *io_ctx)
{
3419c034:	b580      	push	{r7, lr}
3419c036:	b082      	sub	sp, #8
3419c038:	af00      	add	r7, sp, #0
3419c03a:	6078      	str	r0, [r7, #4]
  /* Camera sensor Power-On sequence */
  /* Assert the camera  NRST pins */
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419c03c:	687b      	ldr	r3, [r7, #4]
3419c03e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419c042:	2000      	movs	r0, #0
3419c044:	4798      	blx	r3
  io_ctx->Delay(200); /* NRST signals asserted during 200ms */
3419c046:	687b      	ldr	r3, [r7, #4]
3419c048:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419c04c:	20c8      	movs	r0, #200	@ 0xc8
3419c04e:	4798      	blx	r3
  /* De-assert the camera STANDBY pin (active high) */
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419c050:	687b      	ldr	r3, [r7, #4]
3419c052:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419c056:	2001      	movs	r0, #1
3419c058:	4798      	blx	r3
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
3419c05a:	687b      	ldr	r3, [r7, #4]
3419c05c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419c060:	2014      	movs	r0, #20
3419c062:	4798      	blx	r3
}
3419c064:	bf00      	nop
3419c066:	3708      	adds	r7, #8
3419c068:	46bd      	mov	sp, r7
3419c06a:	bd80      	pop	{r7, pc}

3419c06c <CMW_VD55G1_Probe>:

int CMW_VD55G1_Probe(CMW_VD55G1_t *io_ctx, CMW_Sensor_if_t *vd55g1_if)
{
3419c06c:	b580      	push	{r7, lr}
3419c06e:	b084      	sub	sp, #16
3419c070:	af00      	add	r7, sp, #0
3419c072:	6078      	str	r0, [r7, #4]
3419c074:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419c076:	2300      	movs	r3, #0
3419c078:	60fb      	str	r3, [r7, #12]
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
3419c07a:	687b      	ldr	r3, [r7, #4]
3419c07c:	4a2c      	ldr	r2, [pc, #176]	@ (3419c130 <CMW_VD55G1_Probe+0xc4>)
3419c07e:	605a      	str	r2, [r3, #4]
  io_ctx->ctx_driver.read8 = VD55G1_Read8;
3419c080:	687b      	ldr	r3, [r7, #4]
3419c082:	4a2c      	ldr	r2, [pc, #176]	@ (3419c134 <CMW_VD55G1_Probe+0xc8>)
3419c084:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.read16 = VD55G1_Read16;
3419c086:	687b      	ldr	r3, [r7, #4]
3419c088:	4a2b      	ldr	r2, [pc, #172]	@ (3419c138 <CMW_VD55G1_Probe+0xcc>)
3419c08a:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.read32 = VD55G1_Read32;
3419c08c:	687b      	ldr	r3, [r7, #4]
3419c08e:	4a2b      	ldr	r2, [pc, #172]	@ (3419c13c <CMW_VD55G1_Probe+0xd0>)
3419c090:	611a      	str	r2, [r3, #16]
  io_ctx->ctx_driver.write8 = VD55G1_Write8;
3419c092:	687b      	ldr	r3, [r7, #4]
3419c094:	4a2a      	ldr	r2, [pc, #168]	@ (3419c140 <CMW_VD55G1_Probe+0xd4>)
3419c096:	615a      	str	r2, [r3, #20]
  io_ctx->ctx_driver.write16 = VD55G1_Write16;
3419c098:	687b      	ldr	r3, [r7, #4]
3419c09a:	4a2a      	ldr	r2, [pc, #168]	@ (3419c144 <CMW_VD55G1_Probe+0xd8>)
3419c09c:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.write32 = VD55G1_Write32;
3419c09e:	687b      	ldr	r3, [r7, #4]
3419c0a0:	4a29      	ldr	r2, [pc, #164]	@ (3419c148 <CMW_VD55G1_Probe+0xdc>)
3419c0a2:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.write_array = VD55G1_WriteArray;
3419c0a4:	687b      	ldr	r3, [r7, #4]
3419c0a6:	4a29      	ldr	r2, [pc, #164]	@ (3419c14c <CMW_VD55G1_Probe+0xe0>)
3419c0a8:	621a      	str	r2, [r3, #32]
  io_ctx->ctx_driver.delay = VD55G1_Delay;
3419c0aa:	687b      	ldr	r3, [r7, #4]
3419c0ac:	4a28      	ldr	r2, [pc, #160]	@ (3419c150 <CMW_VD55G1_Probe+0xe4>)
3419c0ae:	625a      	str	r2, [r3, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD55G1_Log;
3419c0b0:	687b      	ldr	r3, [r7, #4]
3419c0b2:	4a28      	ldr	r2, [pc, #160]	@ (3419c154 <CMW_VD55G1_Probe+0xe8>)
3419c0b4:	629a      	str	r2, [r3, #40]	@ 0x28

  CMW_VD55G1_PowerOn(io_ctx);
3419c0b6:	6878      	ldr	r0, [r7, #4]
3419c0b8:	f7ff ffbc 	bl	3419c034 <CMW_VD55G1_PowerOn>

  ret = VD55G1_RegisterBusIO(io_ctx);
3419c0bc:	6878      	ldr	r0, [r7, #4]
3419c0be:	f7ff ff85 	bl	3419bfcc <VD55G1_RegisterBusIO>
3419c0c2:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419c0c4:	68fb      	ldr	r3, [r7, #12]
3419c0c6:	2b00      	cmp	r3, #0
3419c0c8:	d002      	beq.n	3419c0d0 <CMW_VD55G1_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c0ca:	f06f 0304 	mvn.w	r3, #4
3419c0ce:	e02b      	b.n	3419c128 <CMW_VD55G1_Probe+0xbc>
  }

  ret = VD55G1_ReadID(io_ctx, &id);
3419c0d0:	f107 0308 	add.w	r3, r7, #8
3419c0d4:	4619      	mov	r1, r3
3419c0d6:	6878      	ldr	r0, [r7, #4]
3419c0d8:	f7ff ff92 	bl	3419c000 <VD55G1_ReadID>
3419c0dc:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419c0de:	68fb      	ldr	r3, [r7, #12]
3419c0e0:	2b00      	cmp	r3, #0
3419c0e2:	d002      	beq.n	3419c0ea <CMW_VD55G1_Probe+0x7e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c0e4:	f06f 0304 	mvn.w	r3, #4
3419c0e8:	e01e      	b.n	3419c128 <CMW_VD55G1_Probe+0xbc>
  }
  if (id != VD55G1_CHIP_ID)
3419c0ea:	68bb      	ldr	r3, [r7, #8]
3419c0ec:	4a1a      	ldr	r2, [pc, #104]	@ (3419c158 <CMW_VD55G1_Probe+0xec>)
3419c0ee:	4293      	cmp	r3, r2
3419c0f0:	d002      	beq.n	3419c0f8 <CMW_VD55G1_Probe+0x8c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c0f2:	f06f 0304 	mvn.w	r3, #4
3419c0f6:	e017      	b.n	3419c128 <CMW_VD55G1_Probe+0xbc>
  }

  memset(vd55g1_if, 0, sizeof(*vd55g1_if));
3419c0f8:	2268      	movs	r2, #104	@ 0x68
3419c0fa:	2100      	movs	r1, #0
3419c0fc:	6838      	ldr	r0, [r7, #0]
3419c0fe:	f007 fe51 	bl	341a3da4 <memset>
  vd55g1_if->Init = CMW_VD55G1_Init;
3419c102:	683b      	ldr	r3, [r7, #0]
3419c104:	4a15      	ldr	r2, [pc, #84]	@ (3419c15c <CMW_VD55G1_Probe+0xf0>)
3419c106:	601a      	str	r2, [r3, #0]
  vd55g1_if->DeInit = CMW_VD55G1_DeInit;
3419c108:	683b      	ldr	r3, [r7, #0]
3419c10a:	4a15      	ldr	r2, [pc, #84]	@ (3419c160 <CMW_VD55G1_Probe+0xf4>)
3419c10c:	605a      	str	r2, [r3, #4]
  vd55g1_if->Start = CMW_VD55G1_Start;
3419c10e:	683b      	ldr	r3, [r7, #0]
3419c110:	4a14      	ldr	r2, [pc, #80]	@ (3419c164 <CMW_VD55G1_Probe+0xf8>)
3419c112:	609a      	str	r2, [r3, #8]
  vd55g1_if->Stop = CMW_VD55G1_Stop;
3419c114:	683b      	ldr	r3, [r7, #0]
3419c116:	4a14      	ldr	r2, [pc, #80]	@ (3419c168 <CMW_VD55G1_Probe+0xfc>)
3419c118:	619a      	str	r2, [r3, #24]
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
3419c11a:	683b      	ldr	r3, [r7, #0]
3419c11c:	4a13      	ldr	r2, [pc, #76]	@ (3419c16c <CMW_VD55G1_Probe+0x100>)
3419c11e:	62da      	str	r2, [r3, #44]	@ 0x2c
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
3419c120:	683b      	ldr	r3, [r7, #0]
3419c122:	4a13      	ldr	r2, [pc, #76]	@ (3419c170 <CMW_VD55G1_Probe+0x104>)
3419c124:	661a      	str	r2, [r3, #96]	@ 0x60
  return ret;
3419c126:	68fb      	ldr	r3, [r7, #12]
}
3419c128:	4618      	mov	r0, r3
3419c12a:	3710      	adds	r7, #16
3419c12c:	46bd      	mov	sp, r7
3419c12e:	bd80      	pop	{r7, pc}
3419c130:	3419ba71 	.word	0x3419ba71
3419c134:	3419ba93 	.word	0x3419ba93
3419c138:	3419babd 	.word	0x3419babd
3419c13c:	3419bae7 	.word	0x3419bae7
3419c140:	3419bb11 	.word	0x3419bb11
3419c144:	3419bb3d 	.word	0x3419bb3d
3419c148:	3419bb69 	.word	0x3419bb69
3419c14c:	3419bb93 	.word	0x3419bb93
3419c150:	3419bbff 	.word	0x3419bbff
3419c154:	3419bc21 	.word	0x3419bc21
3419c158:	53354731 	.word	0x53354731
3419c15c:	3419bd3d 	.word	0x3419bd3d
3419c160:	3419bf03 	.word	0x3419bf03
3419c164:	3419be9d 	.word	0x3419be9d
3419c168:	3419bed5 	.word	0x3419bed5
3419c16c:	3419bf51 	.word	0x3419bf51
3419c170:	3419bc3b 	.word	0x3419bc3b

3419c174 <CMW_VD66GY_Read8>:
#define LINEAR_TO_MDECIBEL(linearValue)     (1000 * (20.0 * log10(linearValue)))
#define FLOAT_TO_FP58(x)                    (((uint16_t)(x) << 8) | ((uint16_t)((x - (uint16_t)(x)) * 256.0f) & 0xFF))
#define FP58_TO_FLOAT(fp)                   (((fp) >> 8) + ((fp) & 0xFF) / 256.0f)

static int CMW_VD66GY_Read8(CMW_VD66GY_t *pObj, uint16_t addr, uint8_t *value)
{
3419c174:	b590      	push	{r4, r7, lr}
3419c176:	b085      	sub	sp, #20
3419c178:	af00      	add	r7, sp, #0
3419c17a:	60f8      	str	r0, [r7, #12]
3419c17c:	460b      	mov	r3, r1
3419c17e:	607a      	str	r2, [r7, #4]
3419c180:	817b      	strh	r3, [r7, #10]
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3419c182:	68fb      	ldr	r3, [r7, #12]
3419c184:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419c188:	68fb      	ldr	r3, [r7, #12]
3419c18a:	8818      	ldrh	r0, [r3, #0]
3419c18c:	8979      	ldrh	r1, [r7, #10]
3419c18e:	2301      	movs	r3, #1
3419c190:	687a      	ldr	r2, [r7, #4]
3419c192:	47a0      	blx	r4
3419c194:	4603      	mov	r3, r0
}
3419c196:	4618      	mov	r0, r3
3419c198:	3714      	adds	r7, #20
3419c19a:	46bd      	mov	sp, r7
3419c19c:	bd90      	pop	{r4, r7, pc}

3419c19e <CMW_VD66GY_Read16>:

static int CMW_VD66GY_Read16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t *value)
{
3419c19e:	b590      	push	{r4, r7, lr}
3419c1a0:	b087      	sub	sp, #28
3419c1a2:	af00      	add	r7, sp, #0
3419c1a4:	60f8      	str	r0, [r7, #12]
3419c1a6:	460b      	mov	r3, r1
3419c1a8:	607a      	str	r2, [r7, #4]
3419c1aa:	817b      	strh	r3, [r7, #10]
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3419c1ac:	68fb      	ldr	r3, [r7, #12]
3419c1ae:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419c1b2:	68fb      	ldr	r3, [r7, #12]
3419c1b4:	8818      	ldrh	r0, [r3, #0]
3419c1b6:	f107 0210 	add.w	r2, r7, #16
3419c1ba:	8979      	ldrh	r1, [r7, #10]
3419c1bc:	2302      	movs	r3, #2
3419c1be:	47a0      	blx	r4
3419c1c0:	6178      	str	r0, [r7, #20]
  if (ret)
3419c1c2:	697b      	ldr	r3, [r7, #20]
3419c1c4:	2b00      	cmp	r3, #0
3419c1c6:	d001      	beq.n	3419c1cc <CMW_VD66GY_Read16+0x2e>
    return ret;
3419c1c8:	697b      	ldr	r3, [r7, #20]
3419c1ca:	e00b      	b.n	3419c1e4 <CMW_VD66GY_Read16+0x46>

  *value = (data[1] << 8) | data[0];
3419c1cc:	7c7b      	ldrb	r3, [r7, #17]
3419c1ce:	b21b      	sxth	r3, r3
3419c1d0:	021b      	lsls	r3, r3, #8
3419c1d2:	b21a      	sxth	r2, r3
3419c1d4:	7c3b      	ldrb	r3, [r7, #16]
3419c1d6:	b21b      	sxth	r3, r3
3419c1d8:	4313      	orrs	r3, r2
3419c1da:	b21b      	sxth	r3, r3
3419c1dc:	b29a      	uxth	r2, r3
3419c1de:	687b      	ldr	r3, [r7, #4]
3419c1e0:	801a      	strh	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419c1e2:	2300      	movs	r3, #0
}
3419c1e4:	4618      	mov	r0, r3
3419c1e6:	371c      	adds	r7, #28
3419c1e8:	46bd      	mov	sp, r7
3419c1ea:	bd90      	pop	{r4, r7, pc}

3419c1ec <CMW_VD66GY_Read32>:

static int CMW_VD66GY_Read32(CMW_VD66GY_t *pObj, uint16_t addr, uint32_t *value)
{
3419c1ec:	b590      	push	{r4, r7, lr}
3419c1ee:	b087      	sub	sp, #28
3419c1f0:	af00      	add	r7, sp, #0
3419c1f2:	60f8      	str	r0, [r7, #12]
3419c1f4:	460b      	mov	r3, r1
3419c1f6:	607a      	str	r2, [r7, #4]
3419c1f8:	817b      	strh	r3, [r7, #10]
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3419c1fa:	68fb      	ldr	r3, [r7, #12]
3419c1fc:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419c200:	68fb      	ldr	r3, [r7, #12]
3419c202:	8818      	ldrh	r0, [r3, #0]
3419c204:	f107 0210 	add.w	r2, r7, #16
3419c208:	8979      	ldrh	r1, [r7, #10]
3419c20a:	2304      	movs	r3, #4
3419c20c:	47a0      	blx	r4
3419c20e:	6178      	str	r0, [r7, #20]
  if (ret)
3419c210:	697b      	ldr	r3, [r7, #20]
3419c212:	2b00      	cmp	r3, #0
3419c214:	d001      	beq.n	3419c21a <CMW_VD66GY_Read32+0x2e>
    return ret;
3419c216:	697b      	ldr	r3, [r7, #20]
3419c218:	e00d      	b.n	3419c236 <CMW_VD66GY_Read32+0x4a>

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
3419c21a:	7cfb      	ldrb	r3, [r7, #19]
3419c21c:	061a      	lsls	r2, r3, #24
3419c21e:	7cbb      	ldrb	r3, [r7, #18]
3419c220:	041b      	lsls	r3, r3, #16
3419c222:	431a      	orrs	r2, r3
3419c224:	7c7b      	ldrb	r3, [r7, #17]
3419c226:	021b      	lsls	r3, r3, #8
3419c228:	4313      	orrs	r3, r2
3419c22a:	7c3a      	ldrb	r2, [r7, #16]
3419c22c:	4313      	orrs	r3, r2
3419c22e:	461a      	mov	r2, r3
3419c230:	687b      	ldr	r3, [r7, #4]
3419c232:	601a      	str	r2, [r3, #0]

  return 0;
3419c234:	2300      	movs	r3, #0
}
3419c236:	4618      	mov	r0, r3
3419c238:	371c      	adds	r7, #28
3419c23a:	46bd      	mov	sp, r7
3419c23c:	bd90      	pop	{r4, r7, pc}

3419c23e <CMW_VD66GY_Write8>:

static int CMW_VD66GY_Write8(CMW_VD66GY_t *pObj, uint16_t addr, uint8_t value)
{
3419c23e:	b590      	push	{r4, r7, lr}
3419c240:	b083      	sub	sp, #12
3419c242:	af00      	add	r7, sp, #0
3419c244:	6078      	str	r0, [r7, #4]
3419c246:	460b      	mov	r3, r1
3419c248:	807b      	strh	r3, [r7, #2]
3419c24a:	4613      	mov	r3, r2
3419c24c:	707b      	strb	r3, [r7, #1]
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3419c24e:	687b      	ldr	r3, [r7, #4]
3419c250:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419c254:	687b      	ldr	r3, [r7, #4]
3419c256:	8818      	ldrh	r0, [r3, #0]
3419c258:	1c7a      	adds	r2, r7, #1
3419c25a:	8879      	ldrh	r1, [r7, #2]
3419c25c:	2301      	movs	r3, #1
3419c25e:	47a0      	blx	r4
3419c260:	4603      	mov	r3, r0
}
3419c262:	4618      	mov	r0, r3
3419c264:	370c      	adds	r7, #12
3419c266:	46bd      	mov	sp, r7
3419c268:	bd90      	pop	{r4, r7, pc}

3419c26a <CMW_VD66GY_Write16>:

static int CMW_VD66GY_Write16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t value)
{
3419c26a:	b590      	push	{r4, r7, lr}
3419c26c:	b083      	sub	sp, #12
3419c26e:	af00      	add	r7, sp, #0
3419c270:	6078      	str	r0, [r7, #4]
3419c272:	460b      	mov	r3, r1
3419c274:	807b      	strh	r3, [r7, #2]
3419c276:	4613      	mov	r3, r2
3419c278:	803b      	strh	r3, [r7, #0]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
3419c27a:	687b      	ldr	r3, [r7, #4]
3419c27c:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419c280:	687b      	ldr	r3, [r7, #4]
3419c282:	8818      	ldrh	r0, [r3, #0]
3419c284:	463a      	mov	r2, r7
3419c286:	8879      	ldrh	r1, [r7, #2]
3419c288:	2302      	movs	r3, #2
3419c28a:	47a0      	blx	r4
3419c28c:	4603      	mov	r3, r0
}
3419c28e:	4618      	mov	r0, r3
3419c290:	370c      	adds	r7, #12
3419c292:	46bd      	mov	sp, r7
3419c294:	bd90      	pop	{r4, r7, pc}

3419c296 <CMW_VD66GY_Write32>:

static int CMW_VD66GY_Write32(CMW_VD66GY_t *pObj, uint16_t addr, uint32_t value)
{
3419c296:	b590      	push	{r4, r7, lr}
3419c298:	b085      	sub	sp, #20
3419c29a:	af00      	add	r7, sp, #0
3419c29c:	60f8      	str	r0, [r7, #12]
3419c29e:	460b      	mov	r3, r1
3419c2a0:	607a      	str	r2, [r7, #4]
3419c2a2:	817b      	strh	r3, [r7, #10]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3419c2a4:	68fb      	ldr	r3, [r7, #12]
3419c2a6:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419c2aa:	68fb      	ldr	r3, [r7, #12]
3419c2ac:	8818      	ldrh	r0, [r3, #0]
3419c2ae:	1d3a      	adds	r2, r7, #4
3419c2b0:	8979      	ldrh	r1, [r7, #10]
3419c2b2:	2304      	movs	r3, #4
3419c2b4:	47a0      	blx	r4
3419c2b6:	4603      	mov	r3, r0
}
3419c2b8:	4618      	mov	r0, r3
3419c2ba:	3714      	adds	r7, #20
3419c2bc:	46bd      	mov	sp, r7
3419c2be:	bd90      	pop	{r4, r7, pc}

3419c2c0 <VD6G_ShutdownPin>:

static void VD6G_ShutdownPin(struct VD6G_Ctx *ctx, int value)
{
3419c2c0:	b580      	push	{r7, lr}
3419c2c2:	b084      	sub	sp, #16
3419c2c4:	af00      	add	r7, sp, #0
3419c2c6:	6078      	str	r0, [r7, #4]
3419c2c8:	6039      	str	r1, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c2ca:	687b      	ldr	r3, [r7, #4]
3419c2cc:	3b04      	subs	r3, #4
3419c2ce:	60fb      	str	r3, [r7, #12]

  p_ctx->ShutdownPin(value);
3419c2d0:	68fb      	ldr	r3, [r7, #12]
3419c2d2:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419c2d6:	6838      	ldr	r0, [r7, #0]
3419c2d8:	4798      	blx	r3
}
3419c2da:	bf00      	nop
3419c2dc:	3710      	adds	r7, #16
3419c2de:	46bd      	mov	sp, r7
3419c2e0:	bd80      	pop	{r7, pc}

3419c2e2 <VD6G_Read8>:

static int VD6G_Read8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *value)
{
3419c2e2:	b580      	push	{r7, lr}
3419c2e4:	b086      	sub	sp, #24
3419c2e6:	af00      	add	r7, sp, #0
3419c2e8:	60f8      	str	r0, [r7, #12]
3419c2ea:	460b      	mov	r3, r1
3419c2ec:	607a      	str	r2, [r7, #4]
3419c2ee:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c2f0:	68fb      	ldr	r3, [r7, #12]
3419c2f2:	3b04      	subs	r3, #4
3419c2f4:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read8(p_ctx, addr, value);
3419c2f6:	897b      	ldrh	r3, [r7, #10]
3419c2f8:	687a      	ldr	r2, [r7, #4]
3419c2fa:	4619      	mov	r1, r3
3419c2fc:	6978      	ldr	r0, [r7, #20]
3419c2fe:	f7ff ff39 	bl	3419c174 <CMW_VD66GY_Read8>
3419c302:	4603      	mov	r3, r0
}
3419c304:	4618      	mov	r0, r3
3419c306:	3718      	adds	r7, #24
3419c308:	46bd      	mov	sp, r7
3419c30a:	bd80      	pop	{r7, pc}

3419c30c <VD6G_Read16>:

static int VD6G_Read16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t *value)
{
3419c30c:	b580      	push	{r7, lr}
3419c30e:	b086      	sub	sp, #24
3419c310:	af00      	add	r7, sp, #0
3419c312:	60f8      	str	r0, [r7, #12]
3419c314:	460b      	mov	r3, r1
3419c316:	607a      	str	r2, [r7, #4]
3419c318:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c31a:	68fb      	ldr	r3, [r7, #12]
3419c31c:	3b04      	subs	r3, #4
3419c31e:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read16(p_ctx, addr, value);
3419c320:	897b      	ldrh	r3, [r7, #10]
3419c322:	687a      	ldr	r2, [r7, #4]
3419c324:	4619      	mov	r1, r3
3419c326:	6978      	ldr	r0, [r7, #20]
3419c328:	f7ff ff39 	bl	3419c19e <CMW_VD66GY_Read16>
3419c32c:	4603      	mov	r3, r0
}
3419c32e:	4618      	mov	r0, r3
3419c330:	3718      	adds	r7, #24
3419c332:	46bd      	mov	sp, r7
3419c334:	bd80      	pop	{r7, pc}

3419c336 <VD6G_Read32>:

static int VD6G_Read32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t *value)
{
3419c336:	b580      	push	{r7, lr}
3419c338:	b086      	sub	sp, #24
3419c33a:	af00      	add	r7, sp, #0
3419c33c:	60f8      	str	r0, [r7, #12]
3419c33e:	460b      	mov	r3, r1
3419c340:	607a      	str	r2, [r7, #4]
3419c342:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c344:	68fb      	ldr	r3, [r7, #12]
3419c346:	3b04      	subs	r3, #4
3419c348:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read32(p_ctx, addr, value);
3419c34a:	897b      	ldrh	r3, [r7, #10]
3419c34c:	687a      	ldr	r2, [r7, #4]
3419c34e:	4619      	mov	r1, r3
3419c350:	6978      	ldr	r0, [r7, #20]
3419c352:	f7ff ff4b 	bl	3419c1ec <CMW_VD66GY_Read32>
3419c356:	4603      	mov	r3, r0
}
3419c358:	4618      	mov	r0, r3
3419c35a:	3718      	adds	r7, #24
3419c35c:	46bd      	mov	sp, r7
3419c35e:	bd80      	pop	{r7, pc}

3419c360 <VD6G_Write8>:

static int VD6G_Write8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t value)
{
3419c360:	b580      	push	{r7, lr}
3419c362:	b084      	sub	sp, #16
3419c364:	af00      	add	r7, sp, #0
3419c366:	6078      	str	r0, [r7, #4]
3419c368:	460b      	mov	r3, r1
3419c36a:	807b      	strh	r3, [r7, #2]
3419c36c:	4613      	mov	r3, r2
3419c36e:	707b      	strb	r3, [r7, #1]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c370:	687b      	ldr	r3, [r7, #4]
3419c372:	3b04      	subs	r3, #4
3419c374:	60fb      	str	r3, [r7, #12]

  return CMW_VD66GY_Write8(p_ctx, addr, value);
3419c376:	787a      	ldrb	r2, [r7, #1]
3419c378:	887b      	ldrh	r3, [r7, #2]
3419c37a:	4619      	mov	r1, r3
3419c37c:	68f8      	ldr	r0, [r7, #12]
3419c37e:	f7ff ff5e 	bl	3419c23e <CMW_VD66GY_Write8>
3419c382:	4603      	mov	r3, r0
}
3419c384:	4618      	mov	r0, r3
3419c386:	3710      	adds	r7, #16
3419c388:	46bd      	mov	sp, r7
3419c38a:	bd80      	pop	{r7, pc}

3419c38c <VD6G_Write16>:

static int VD6G_Write16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t value)
{
3419c38c:	b580      	push	{r7, lr}
3419c38e:	b084      	sub	sp, #16
3419c390:	af00      	add	r7, sp, #0
3419c392:	6078      	str	r0, [r7, #4]
3419c394:	460b      	mov	r3, r1
3419c396:	807b      	strh	r3, [r7, #2]
3419c398:	4613      	mov	r3, r2
3419c39a:	803b      	strh	r3, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c39c:	687b      	ldr	r3, [r7, #4]
3419c39e:	3b04      	subs	r3, #4
3419c3a0:	60fb      	str	r3, [r7, #12]

  return CMW_VD66GY_Write16(p_ctx, addr, value);
3419c3a2:	883a      	ldrh	r2, [r7, #0]
3419c3a4:	887b      	ldrh	r3, [r7, #2]
3419c3a6:	4619      	mov	r1, r3
3419c3a8:	68f8      	ldr	r0, [r7, #12]
3419c3aa:	f7ff ff5e 	bl	3419c26a <CMW_VD66GY_Write16>
3419c3ae:	4603      	mov	r3, r0
}
3419c3b0:	4618      	mov	r0, r3
3419c3b2:	3710      	adds	r7, #16
3419c3b4:	46bd      	mov	sp, r7
3419c3b6:	bd80      	pop	{r7, pc}

3419c3b8 <VD6G_Write32>:

static int VD6G_Write32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t value)
{
3419c3b8:	b580      	push	{r7, lr}
3419c3ba:	b086      	sub	sp, #24
3419c3bc:	af00      	add	r7, sp, #0
3419c3be:	60f8      	str	r0, [r7, #12]
3419c3c0:	460b      	mov	r3, r1
3419c3c2:	607a      	str	r2, [r7, #4]
3419c3c4:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c3c6:	68fb      	ldr	r3, [r7, #12]
3419c3c8:	3b04      	subs	r3, #4
3419c3ca:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Write32(p_ctx, addr, value);
3419c3cc:	897b      	ldrh	r3, [r7, #10]
3419c3ce:	687a      	ldr	r2, [r7, #4]
3419c3d0:	4619      	mov	r1, r3
3419c3d2:	6978      	ldr	r0, [r7, #20]
3419c3d4:	f7ff ff5f 	bl	3419c296 <CMW_VD66GY_Write32>
3419c3d8:	4603      	mov	r3, r0
}
3419c3da:	4618      	mov	r0, r3
3419c3dc:	3718      	adds	r7, #24
3419c3de:	46bd      	mov	sp, r7
3419c3e0:	bd80      	pop	{r7, pc}

3419c3e2 <VD6G_WriteArray>:

static int VD6G_WriteArray(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
3419c3e2:	b590      	push	{r4, r7, lr}
3419c3e4:	b089      	sub	sp, #36	@ 0x24
3419c3e6:	af00      	add	r7, sp, #0
3419c3e8:	60f8      	str	r0, [r7, #12]
3419c3ea:	607a      	str	r2, [r7, #4]
3419c3ec:	603b      	str	r3, [r7, #0]
3419c3ee:	460b      	mov	r3, r1
3419c3f0:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c3f2:	68fb      	ldr	r3, [r7, #12]
3419c3f4:	3b04      	subs	r3, #4
3419c3f6:	61fb      	str	r3, [r7, #28]
  const unsigned int chunk_size = 128;
3419c3f8:	2380      	movs	r3, #128	@ 0x80
3419c3fa:	61bb      	str	r3, [r7, #24]
  uint16_t sz;
  int ret;

  while (data_len) {
3419c3fc:	e020      	b.n	3419c440 <VD6G_WriteArray+0x5e>
    sz = MIN(data_len, chunk_size);
3419c3fe:	683a      	ldr	r2, [r7, #0]
3419c400:	69bb      	ldr	r3, [r7, #24]
3419c402:	4293      	cmp	r3, r2
3419c404:	bf28      	it	cs
3419c406:	4613      	movcs	r3, r2
3419c408:	82fb      	strh	r3, [r7, #22]
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
3419c40a:	69fb      	ldr	r3, [r7, #28]
3419c40c:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419c410:	69fb      	ldr	r3, [r7, #28]
3419c412:	8818      	ldrh	r0, [r3, #0]
3419c414:	8afb      	ldrh	r3, [r7, #22]
3419c416:	8979      	ldrh	r1, [r7, #10]
3419c418:	687a      	ldr	r2, [r7, #4]
3419c41a:	47a0      	blx	r4
3419c41c:	6138      	str	r0, [r7, #16]
    if (ret)
3419c41e:	693b      	ldr	r3, [r7, #16]
3419c420:	2b00      	cmp	r3, #0
3419c422:	d001      	beq.n	3419c428 <VD6G_WriteArray+0x46>
      return ret;
3419c424:	693b      	ldr	r3, [r7, #16]
3419c426:	e00f      	b.n	3419c448 <VD6G_WriteArray+0x66>
    data_len -= sz;
3419c428:	8afb      	ldrh	r3, [r7, #22]
3419c42a:	683a      	ldr	r2, [r7, #0]
3419c42c:	1ad3      	subs	r3, r2, r3
3419c42e:	603b      	str	r3, [r7, #0]
    addr += sz;
3419c430:	897a      	ldrh	r2, [r7, #10]
3419c432:	8afb      	ldrh	r3, [r7, #22]
3419c434:	4413      	add	r3, r2
3419c436:	817b      	strh	r3, [r7, #10]
    data += sz;
3419c438:	8afb      	ldrh	r3, [r7, #22]
3419c43a:	687a      	ldr	r2, [r7, #4]
3419c43c:	4413      	add	r3, r2
3419c43e:	607b      	str	r3, [r7, #4]
  while (data_len) {
3419c440:	683b      	ldr	r3, [r7, #0]
3419c442:	2b00      	cmp	r3, #0
3419c444:	d1db      	bne.n	3419c3fe <VD6G_WriteArray+0x1c>
  }

  return 0;
3419c446:	2300      	movs	r3, #0
}
3419c448:	4618      	mov	r0, r3
3419c44a:	3724      	adds	r7, #36	@ 0x24
3419c44c:	46bd      	mov	sp, r7
3419c44e:	bd90      	pop	{r4, r7, pc}

3419c450 <VD6G_Delay>:

static void VD6G_Delay(struct VD6G_Ctx *ctx, uint32_t delay_in_ms)
{
3419c450:	b580      	push	{r7, lr}
3419c452:	b084      	sub	sp, #16
3419c454:	af00      	add	r7, sp, #0
3419c456:	6078      	str	r0, [r7, #4]
3419c458:	6039      	str	r1, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419c45a:	687b      	ldr	r3, [r7, #4]
3419c45c:	3b04      	subs	r3, #4
3419c45e:	60fb      	str	r3, [r7, #12]

  p_ctx->Delay(delay_in_ms);
3419c460:	68fb      	ldr	r3, [r7, #12]
3419c462:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
3419c466:	6838      	ldr	r0, [r7, #0]
3419c468:	4798      	blx	r3
}
3419c46a:	bf00      	nop
3419c46c:	3710      	adds	r7, #16
3419c46e:	46bd      	mov	sp, r7
3419c470:	bd80      	pop	{r7, pc}

3419c472 <VD6G_Log>:

static void VD6G_Log(struct VD6G_Ctx *ctx, int lvl, const char *format, va_list ap)
{
3419c472:	b480      	push	{r7}
3419c474:	b085      	sub	sp, #20
3419c476:	af00      	add	r7, sp, #0
3419c478:	60f8      	str	r0, [r7, #12]
3419c47a:	60b9      	str	r1, [r7, #8]
3419c47c:	607a      	str	r2, [r7, #4]
3419c47e:	603b      	str	r3, [r7, #0]
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3419c480:	bf00      	nop
3419c482:	3714      	adds	r7, #20
3419c484:	46bd      	mov	sp, r7
3419c486:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c48a:	4770      	bx	lr

3419c48c <CMW_VD66GY_GetResType>:

static int CMW_VD66GY_GetResType(uint32_t width, uint32_t height, VD6G_Res_t *res)
{
3419c48c:	b480      	push	{r7}
3419c48e:	b085      	sub	sp, #20
3419c490:	af00      	add	r7, sp, #0
3419c492:	60f8      	str	r0, [r7, #12]
3419c494:	60b9      	str	r1, [r7, #8]
3419c496:	607a      	str	r2, [r7, #4]
  if (width == 320 && height == 240)
3419c498:	68fb      	ldr	r3, [r7, #12]
3419c49a:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
3419c49e:	d106      	bne.n	3419c4ae <CMW_VD66GY_GetResType+0x22>
3419c4a0:	68bb      	ldr	r3, [r7, #8]
3419c4a2:	2bf0      	cmp	r3, #240	@ 0xf0
3419c4a4:	d103      	bne.n	3419c4ae <CMW_VD66GY_GetResType+0x22>
  {
    *res = VD6G_RES_QVGA_320_240;
3419c4a6:	687b      	ldr	r3, [r7, #4]
3419c4a8:	2200      	movs	r2, #0
3419c4aa:	701a      	strb	r2, [r3, #0]
3419c4ac:	e033      	b.n	3419c516 <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 640 && height == 480)
3419c4ae:	68fb      	ldr	r3, [r7, #12]
3419c4b0:	f5b3 7f20 	cmp.w	r3, #640	@ 0x280
3419c4b4:	d107      	bne.n	3419c4c6 <CMW_VD66GY_GetResType+0x3a>
3419c4b6:	68bb      	ldr	r3, [r7, #8]
3419c4b8:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3419c4bc:	d103      	bne.n	3419c4c6 <CMW_VD66GY_GetResType+0x3a>
  {
    *res = VD6G_RES_VGA_640_480;
3419c4be:	687b      	ldr	r3, [r7, #4]
3419c4c0:	2201      	movs	r2, #1
3419c4c2:	701a      	strb	r2, [r3, #0]
3419c4c4:	e027      	b.n	3419c516 <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1024 && height == 768)
3419c4c6:	68fb      	ldr	r3, [r7, #12]
3419c4c8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419c4cc:	d107      	bne.n	3419c4de <CMW_VD66GY_GetResType+0x52>
3419c4ce:	68bb      	ldr	r3, [r7, #8]
3419c4d0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3419c4d4:	d103      	bne.n	3419c4de <CMW_VD66GY_GetResType+0x52>
  {
    *res = VD6G_RES_XGA_1024_768;
3419c4d6:	687b      	ldr	r3, [r7, #4]
3419c4d8:	2203      	movs	r2, #3
3419c4da:	701a      	strb	r2, [r3, #0]
3419c4dc:	e01b      	b.n	3419c516 <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1120 && height == 720)
3419c4de:	68fb      	ldr	r3, [r7, #12]
3419c4e0:	f5b3 6f8c 	cmp.w	r3, #1120	@ 0x460
3419c4e4:	d107      	bne.n	3419c4f6 <CMW_VD66GY_GetResType+0x6a>
3419c4e6:	68bb      	ldr	r3, [r7, #8]
3419c4e8:	f5b3 7f34 	cmp.w	r3, #720	@ 0x2d0
3419c4ec:	d103      	bne.n	3419c4f6 <CMW_VD66GY_GetResType+0x6a>
  {
    *res = VD6G_RES_PORTRAIT_1120_720;
3419c4ee:	687b      	ldr	r3, [r7, #4]
3419c4f0:	2207      	movs	r2, #7
3419c4f2:	701a      	strb	r2, [r3, #0]
3419c4f4:	e00f      	b.n	3419c516 <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1120 && height == 1364)
3419c4f6:	68fb      	ldr	r3, [r7, #12]
3419c4f8:	f5b3 6f8c 	cmp.w	r3, #1120	@ 0x460
3419c4fc:	d108      	bne.n	3419c510 <CMW_VD66GY_GetResType+0x84>
3419c4fe:	68bb      	ldr	r3, [r7, #8]
3419c500:	f240 5254 	movw	r2, #1364	@ 0x554
3419c504:	4293      	cmp	r3, r2
3419c506:	d103      	bne.n	3419c510 <CMW_VD66GY_GetResType+0x84>
  {
    *res = VD6G_RES_FULL_1120_1364;
3419c508:	687b      	ldr	r3, [r7, #4]
3419c50a:	2208      	movs	r2, #8
3419c50c:	701a      	strb	r2, [r3, #0]
3419c50e:	e002      	b.n	3419c516 <CMW_VD66GY_GetResType+0x8a>
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
3419c510:	f06f 0301 	mvn.w	r3, #1
3419c514:	e000      	b.n	3419c518 <CMW_VD66GY_GetResType+0x8c>
  }
  return 0;
3419c516:	2300      	movs	r3, #0
}
3419c518:	4618      	mov	r0, r3
3419c51a:	3714      	adds	r7, #20
3419c51c:	46bd      	mov	sp, r7
3419c51e:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c522:	4770      	bx	lr

3419c524 <CMW_VD66GY_getMirrorFlipConfig>:

static VD6G_MirrorFlip_t CMW_VD66GY_getMirrorFlipConfig(uint32_t Config)
{
3419c524:	b480      	push	{r7}
3419c526:	b085      	sub	sp, #20
3419c528:	af00      	add	r7, sp, #0
3419c52a:	6078      	str	r0, [r7, #4]
  VD6G_MirrorFlip_t ret;

  switch (Config)
3419c52c:	687b      	ldr	r3, [r7, #4]
3419c52e:	2b02      	cmp	r3, #2
3419c530:	d00f      	beq.n	3419c552 <CMW_VD66GY_getMirrorFlipConfig+0x2e>
3419c532:	687b      	ldr	r3, [r7, #4]
3419c534:	2b02      	cmp	r3, #2
3419c536:	d80f      	bhi.n	3419c558 <CMW_VD66GY_getMirrorFlipConfig+0x34>
3419c538:	687b      	ldr	r3, [r7, #4]
3419c53a:	2b00      	cmp	r3, #0
3419c53c:	d003      	beq.n	3419c546 <CMW_VD66GY_getMirrorFlipConfig+0x22>
3419c53e:	687b      	ldr	r3, [r7, #4]
3419c540:	2b01      	cmp	r3, #1
3419c542:	d003      	beq.n	3419c54c <CMW_VD66GY_getMirrorFlipConfig+0x28>
3419c544:	e008      	b.n	3419c558 <CMW_VD66GY_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = VD6G_MIRROR_FLIP_NONE;
3419c546:	2300      	movs	r3, #0
3419c548:	73fb      	strb	r3, [r7, #15]
      break;
3419c54a:	e008      	b.n	3419c55e <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD6G_FLIP;
3419c54c:	2301      	movs	r3, #1
3419c54e:	73fb      	strb	r3, [r7, #15]
      break;
3419c550:	e005      	b.n	3419c55e <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD6G_MIRROR;
3419c552:	2302      	movs	r3, #2
3419c554:	73fb      	strb	r3, [r7, #15]
      break;
3419c556:	e002      	b.n	3419c55e <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = VD6G_MIRROR_FLIP;
3419c558:	2303      	movs	r3, #3
3419c55a:	73fb      	strb	r3, [r7, #15]
      break;
3419c55c:	bf00      	nop
  }

  return ret;
3419c55e:	7bfb      	ldrb	r3, [r7, #15]
}
3419c560:	4618      	mov	r0, r3
3419c562:	3714      	adds	r7, #20
3419c564:	46bd      	mov	sp, r7
3419c566:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c56a:	4770      	bx	lr

3419c56c <CMW_VD66GY_Init>:

static int32_t CMW_VD66GY_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419c56c:	b580      	push	{r7, lr}
3419c56e:	b09a      	sub	sp, #104	@ 0x68
3419c570:	af00      	add	r7, sp, #0
3419c572:	6078      	str	r0, [r7, #4]
3419c574:	6039      	str	r1, [r7, #0]
  VD6G_Config_t config = { 0 };
3419c576:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419c57a:	2238      	movs	r2, #56	@ 0x38
3419c57c:	2100      	movs	r1, #0
3419c57e:	4618      	mov	r0, r3
3419c580:	f007 fc10 	bl	341a3da4 <memset>
  int ret;
  int i;

  assert(initSensor != NULL);
3419c584:	683b      	ldr	r3, [r7, #0]
3419c586:	2b00      	cmp	r3, #0
3419c588:	d105      	bne.n	3419c596 <CMW_VD66GY_Init+0x2a>
3419c58a:	4b43      	ldr	r3, [pc, #268]	@ (3419c698 <CMW_VD66GY_Init+0x12c>)
3419c58c:	4a43      	ldr	r2, [pc, #268]	@ (3419c69c <CMW_VD66GY_Init+0x130>)
3419c58e:	21ee      	movs	r1, #238	@ 0xee
3419c590:	4843      	ldr	r0, [pc, #268]	@ (3419c6a0 <CMW_VD66GY_Init+0x134>)
3419c592:	f007 f97d 	bl	341a3890 <__assert_func>

  if (((CMW_VD66GY_t *)io_ctx)->IsInitialized)
3419c596:	687b      	ldr	r3, [r7, #4]
3419c598:	f893 311c 	ldrb.w	r3, [r3, #284]	@ 0x11c
3419c59c:	2b00      	cmp	r3, #0
3419c59e:	d001      	beq.n	3419c5a4 <CMW_VD66GY_Init+0x38>
  {
    return CMW_ERROR_NONE;
3419c5a0:	2300      	movs	r3, #0
3419c5a2:	e075      	b.n	3419c690 <CMW_VD66GY_Init+0x124>
  }

  config.frame_rate = initSensor->fps;
3419c5a4:	683b      	ldr	r3, [r7, #0]
3419c5a6:	689b      	ldr	r3, [r3, #8]
3419c5a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ret = CMW_VD66GY_GetResType(initSensor->width, initSensor->height, &config.resolution);
3419c5aa:	683b      	ldr	r3, [r7, #0]
3419c5ac:	6818      	ldr	r0, [r3, #0]
3419c5ae:	683b      	ldr	r3, [r7, #0]
3419c5b0:	6859      	ldr	r1, [r3, #4]
3419c5b2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419c5b6:	3304      	adds	r3, #4
3419c5b8:	461a      	mov	r2, r3
3419c5ba:	f7ff ff67 	bl	3419c48c <CMW_VD66GY_GetResType>
3419c5be:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret)
3419c5c0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419c5c2:	2b00      	cmp	r3, #0
3419c5c4:	d002      	beq.n	3419c5cc <CMW_VD66GY_Init+0x60>
  {
    return CMW_ERROR_WRONG_PARAM;
3419c5c6:	f06f 0301 	mvn.w	r3, #1
3419c5ca:	e061      	b.n	3419c690 <CMW_VD66GY_Init+0x124>
  }

  CMW_VD66GY_config_t default_sensor_config;
  CMW_VD66GY_config_t *sensor_config;

  CMW_VD66GY_SetDefaultSensorValues(&default_sensor_config);
3419c5cc:	f107 0308 	add.w	r3, r7, #8
3419c5d0:	4618      	mov	r0, r3
3419c5d2:	f000 f867 	bl	3419c6a4 <CMW_VD66GY_SetDefaultSensorValues>
  sensor_config = initSensor->sensor_config ? (CMW_VD66GY_config_t*)(initSensor->sensor_config) : &default_sensor_config;
3419c5d6:	683b      	ldr	r3, [r7, #0]
3419c5d8:	695b      	ldr	r3, [r3, #20]
3419c5da:	2b00      	cmp	r3, #0
3419c5dc:	d002      	beq.n	3419c5e4 <CMW_VD66GY_Init+0x78>
3419c5de:	683b      	ldr	r3, [r7, #0]
3419c5e0:	695b      	ldr	r3, [r3, #20]
3419c5e2:	e001      	b.n	3419c5e8 <CMW_VD66GY_Init+0x7c>
3419c5e4:	f107 0308 	add.w	r3, r7, #8
3419c5e8:	65fb      	str	r3, [r7, #92]	@ 0x5c

  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3419c5ea:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c5ec:	681b      	ldr	r3, [r3, #0]
3419c5ee:	627b      	str	r3, [r7, #36]	@ 0x24
  config.line_len = sensor_config->line_len;
3419c5f0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c5f2:	685b      	ldr	r3, [r3, #4]
3419c5f4:	637b      	str	r3, [r7, #52]	@ 0x34
  config.out_itf.datalane_nb = sensor_config->csiconfig.datalane_nb;
3419c5f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c5f8:	689b      	ldr	r3, [r3, #8]
3419c5fa:	63fb      	str	r3, [r7, #60]	@ 0x3c
  config.out_itf.clock_lane_swap_enable = sensor_config->csiconfig.clock_lane_swap_enable;
3419c5fc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c5fe:	68db      	ldr	r3, [r3, #12]
3419c600:	643b      	str	r3, [r7, #64]	@ 0x40
  config.out_itf.data_lane0_swap_enable = sensor_config->csiconfig.data_lane0_swap_enable;
3419c602:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c604:	691b      	ldr	r3, [r3, #16]
3419c606:	647b      	str	r3, [r7, #68]	@ 0x44
  config.out_itf.data_lane1_swap_enable = sensor_config->csiconfig.data_lane1_swap_enable;
3419c608:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c60a:	695b      	ldr	r3, [r3, #20]
3419c60c:	64bb      	str	r3, [r7, #72]	@ 0x48
  config.out_itf.data_lanes_mapping_swap_enable = sensor_config->csiconfig.data_lanes_mapping_swap_enable;
3419c60e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419c610:	699b      	ldr	r3, [r3, #24]
3419c612:	64fb      	str	r3, [r7, #76]	@ 0x4c

  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
3419c614:	683b      	ldr	r3, [r7, #0]
3419c616:	691b      	ldr	r3, [r3, #16]
3419c618:	4618      	mov	r0, r3
3419c61a:	f7ff ff83 	bl	3419c524 <CMW_VD66GY_getMirrorFlipConfig>
3419c61e:	4603      	mov	r3, r0
3419c620:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  config.patgen = VD6G_PATGEN_DISABLE;
3419c624:	2300      	movs	r3, #0
3419c626:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  config.flicker = VD6G_FLICKER_FREE_NONE;
3419c62a:	2300      	movs	r3, #0
3419c62c:	f887 3039 	strb.w	r3, [r7, #57]	@ 0x39

  for (i = 0; i < VD6G_GPIO_NB; i++)
3419c630:	2300      	movs	r3, #0
3419c632:	667b      	str	r3, [r7, #100]	@ 0x64
3419c634:	e008      	b.n	3419c648 <CMW_VD66GY_Init+0xdc>
  {
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
3419c636:	f107 0250 	add.w	r2, r7, #80	@ 0x50
3419c63a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419c63c:	4413      	add	r3, r2
3419c63e:	2201      	movs	r2, #1
3419c640:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < VD6G_GPIO_NB; i++)
3419c642:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419c644:	3301      	adds	r3, #1
3419c646:	667b      	str	r3, [r7, #100]	@ 0x64
3419c648:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419c64a:	2b07      	cmp	r3, #7
3419c64c:	ddf3      	ble.n	3419c636 <CMW_VD66GY_Init+0xca>
  }

  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
3419c64e:	687b      	ldr	r3, [r7, #4]
3419c650:	3304      	adds	r3, #4
3419c652:	f107 0224 	add.w	r2, r7, #36	@ 0x24
3419c656:	4611      	mov	r1, r2
3419c658:	4618      	mov	r0, r3
3419c65a:	f004 f973 	bl	341a0944 <VD6G_Init>
3419c65e:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret)
3419c660:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419c662:	2b00      	cmp	r3, #0
3419c664:	d002      	beq.n	3419c66c <CMW_VD66GY_Init+0x100>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c666:	f06f 0303 	mvn.w	r3, #3
3419c66a:	e011      	b.n	3419c690 <CMW_VD66GY_Init+0x124>
  }

  if (((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer == VD6G_BAYER_NONE)
3419c66c:	687b      	ldr	r3, [r7, #4]
3419c66e:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
3419c672:	2b00      	cmp	r3, #0
3419c674:	d107      	bne.n	3419c686 <CMW_VD66GY_Init+0x11a>
  {
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c676:	687b      	ldr	r3, [r7, #4]
3419c678:	3304      	adds	r3, #4
3419c67a:	4618      	mov	r0, r3
3419c67c:	f004 f9ee 	bl	341a0a5c <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419c680:	f06f 0303 	mvn.w	r3, #3
3419c684:	e004      	b.n	3419c690 <CMW_VD66GY_Init+0x124>
  }

  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 1;
3419c686:	687b      	ldr	r3, [r7, #4]
3419c688:	2201      	movs	r2, #1
3419c68a:	f883 211c 	strb.w	r2, [r3, #284]	@ 0x11c
  return CMW_ERROR_NONE;
3419c68e:	2300      	movs	r3, #0
}
3419c690:	4618      	mov	r0, r3
3419c692:	3768      	adds	r7, #104	@ 0x68
3419c694:	46bd      	mov	sp, r7
3419c696:	bd80      	pop	{r7, pc}
3419c698:	341a6008 	.word	0x341a6008
3419c69c:	341b14a4 	.word	0x341b14a4
3419c6a0:	341a601c 	.word	0x341a601c

3419c6a4 <CMW_VD66GY_SetDefaultSensorValues>:

void CMW_VD66GY_SetDefaultSensorValues(CMW_VD66GY_config_t *vd66gy_config)
{
3419c6a4:	b580      	push	{r7, lr}
3419c6a6:	b082      	sub	sp, #8
3419c6a8:	af00      	add	r7, sp, #0
3419c6aa:	6078      	str	r0, [r7, #4]
  assert(vd66gy_config != NULL);
3419c6ac:	687b      	ldr	r3, [r7, #4]
3419c6ae:	2b00      	cmp	r3, #0
3419c6b0:	d106      	bne.n	3419c6c0 <CMW_VD66GY_SetDefaultSensorValues+0x1c>
3419c6b2:	4b10      	ldr	r3, [pc, #64]	@ (3419c6f4 <CMW_VD66GY_SetDefaultSensorValues+0x50>)
3419c6b4:	4a10      	ldr	r2, [pc, #64]	@ (3419c6f8 <CMW_VD66GY_SetDefaultSensorValues+0x54>)
3419c6b6:	f240 1125 	movw	r1, #293	@ 0x125
3419c6ba:	4810      	ldr	r0, [pc, #64]	@ (3419c6fc <CMW_VD66GY_SetDefaultSensorValues+0x58>)
3419c6bc:	f007 f8e8 	bl	341a3890 <__assert_func>

  vd66gy_config->ext_clock_freq_in_hz = CAMERA_VD66GY_FREQ_IN_HZ; // Default clock frequency
3419c6c0:	687b      	ldr	r3, [r7, #4]
3419c6c2:	4a0f      	ldr	r2, [pc, #60]	@ (3419c700 <CMW_VD66GY_SetDefaultSensorValues+0x5c>)
3419c6c4:	601a      	str	r2, [r3, #0]
  vd66gy_config->line_len = 0; // Default line length
3419c6c6:	687b      	ldr	r3, [r7, #4]
3419c6c8:	2200      	movs	r2, #0
3419c6ca:	605a      	str	r2, [r3, #4]
  vd66gy_config->csiconfig.datalane_nb = 2;
3419c6cc:	687b      	ldr	r3, [r7, #4]
3419c6ce:	2202      	movs	r2, #2
3419c6d0:	609a      	str	r2, [r3, #8]
  vd66gy_config->csiconfig.clock_lane_swap_enable = 1;
3419c6d2:	687b      	ldr	r3, [r7, #4]
3419c6d4:	2201      	movs	r2, #1
3419c6d6:	60da      	str	r2, [r3, #12]
  vd66gy_config->csiconfig.data_lane0_swap_enable = 1;
3419c6d8:	687b      	ldr	r3, [r7, #4]
3419c6da:	2201      	movs	r2, #1
3419c6dc:	611a      	str	r2, [r3, #16]
  vd66gy_config->csiconfig.data_lane1_swap_enable = 1;
3419c6de:	687b      	ldr	r3, [r7, #4]
3419c6e0:	2201      	movs	r2, #1
3419c6e2:	615a      	str	r2, [r3, #20]
  vd66gy_config->csiconfig.data_lanes_mapping_swap_enable = 0;
3419c6e4:	687b      	ldr	r3, [r7, #4]
3419c6e6:	2200      	movs	r2, #0
3419c6e8:	619a      	str	r2, [r3, #24]
}
3419c6ea:	bf00      	nop
3419c6ec:	3708      	adds	r7, #8
3419c6ee:	46bd      	mov	sp, r7
3419c6f0:	bd80      	pop	{r7, pc}
3419c6f2:	bf00      	nop
3419c6f4:	341a6054 	.word	0x341a6054
3419c6f8:	341b14b4 	.word	0x341b14b4
3419c6fc:	341a601c 	.word	0x341a601c
3419c700:	00b71b00 	.word	0x00b71b00

3419c704 <CMW_VD66GY_Start>:

static int32_t CMW_VD66GY_Start(void *io_ctx)
{
3419c704:	b580      	push	{r7, lr}
3419c706:	b086      	sub	sp, #24
3419c708:	af02      	add	r7, sp, #8
3419c70a:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419c70c:	2300      	movs	r3, #0
3419c70e:	60fb      	str	r3, [r7, #12]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Statistic area is provided with null value so that it force the ISP Library to get the statistic
   * area information from the tuning file.
   */
  (void) ISP_IQParamCacheInit; /* unused */
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_VD66GY);
3419c710:	687b      	ldr	r3, [r7, #4]
3419c712:	f103 006c 	add.w	r0, r3, #108	@ 0x6c
3419c716:	687b      	ldr	r3, [r7, #4]
3419c718:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
3419c71c:	687b      	ldr	r3, [r7, #4]
3419c71e:	33f4      	adds	r3, #244	@ 0xf4
3419c720:	4a17      	ldr	r2, [pc, #92]	@ (3419c780 <CMW_VD66GY_Start+0x7c>)
3419c722:	9200      	str	r2, [sp, #0]
3419c724:	2200      	movs	r2, #0
3419c726:	f7fb fc6d 	bl	34198004 <ISP_Init>
3419c72a:	4603      	mov	r3, r0
3419c72c:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419c72e:	68fb      	ldr	r3, [r7, #12]
3419c730:	2b00      	cmp	r3, #0
3419c732:	d002      	beq.n	3419c73a <CMW_VD66GY_Start+0x36>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c734:	f06f 0304 	mvn.w	r3, #4
3419c738:	e01e      	b.n	3419c778 <CMW_VD66GY_Start+0x74>
  }

  ret = ISP_Start(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419c73a:	687b      	ldr	r3, [r7, #4]
3419c73c:	336c      	adds	r3, #108	@ 0x6c
3419c73e:	4618      	mov	r0, r3
3419c740:	f7fb fd46 	bl	341981d0 <ISP_Start>
3419c744:	4603      	mov	r3, r0
3419c746:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419c748:	68fb      	ldr	r3, [r7, #12]
3419c74a:	2b00      	cmp	r3, #0
3419c74c:	d002      	beq.n	3419c754 <CMW_VD66GY_Start+0x50>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419c74e:	f06f 0303 	mvn.w	r3, #3
3419c752:	e011      	b.n	3419c778 <CMW_VD66GY_Start+0x74>
  }
#endif
  ret = VD6G_Start(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c754:	687b      	ldr	r3, [r7, #4]
3419c756:	3304      	adds	r3, #4
3419c758:	4618      	mov	r0, r3
3419c75a:	f004 f99c 	bl	341a0a96 <VD6G_Start>
3419c75e:	60f8      	str	r0, [r7, #12]
  if (ret) {
3419c760:	68fb      	ldr	r3, [r7, #12]
3419c762:	2b00      	cmp	r3, #0
3419c764:	d007      	beq.n	3419c776 <CMW_VD66GY_Start+0x72>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c766:	687b      	ldr	r3, [r7, #4]
3419c768:	3304      	adds	r3, #4
3419c76a:	4618      	mov	r0, r3
3419c76c:	f004 f976 	bl	341a0a5c <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419c770:	f06f 0303 	mvn.w	r3, #3
3419c774:	e000      	b.n	3419c778 <CMW_VD66GY_Start+0x74>
  }
  return CMW_ERROR_NONE;
3419c776:	2300      	movs	r3, #0
}
3419c778:	4618      	mov	r0, r3
3419c77a:	3710      	adds	r7, #16
3419c77c:	46bd      	mov	sp, r7
3419c77e:	bd80      	pop	{r7, pc}
3419c780:	341b124c 	.word	0x341b124c

3419c784 <CMW_VD66GY_Run>:

static int32_t CMW_VD66GY_Run(void *io_ctx)
{
3419c784:	b580      	push	{r7, lr}
3419c786:	b084      	sub	sp, #16
3419c788:	af00      	add	r7, sp, #0
3419c78a:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  ret = ISP_BackgroundProcess(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419c78c:	687b      	ldr	r3, [r7, #4]
3419c78e:	336c      	adds	r3, #108	@ 0x6c
3419c790:	4618      	mov	r0, r3
3419c792:	f7fb fe25 	bl	341983e0 <ISP_BackgroundProcess>
3419c796:	4603      	mov	r3, r0
3419c798:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419c79a:	68fb      	ldr	r3, [r7, #12]
3419c79c:	2b00      	cmp	r3, #0
3419c79e:	d002      	beq.n	3419c7a6 <CMW_VD66GY_Run+0x22>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419c7a0:	f06f 0303 	mvn.w	r3, #3
3419c7a4:	e000      	b.n	3419c7a8 <CMW_VD66GY_Run+0x24>
  }
#endif
  return CMW_ERROR_NONE;
3419c7a6:	2300      	movs	r3, #0
}
3419c7a8:	4618      	mov	r0, r3
3419c7aa:	3710      	adds	r7, #16
3419c7ac:	46bd      	mov	sp, r7
3419c7ae:	bd80      	pop	{r7, pc}

3419c7b0 <CMW_VD66GY_Stop>:

static int32_t CMW_VD66GY_Stop(void *io_ctx)
{
3419c7b0:	b580      	push	{r7, lr}
3419c7b2:	b084      	sub	sp, #16
3419c7b4:	af00      	add	r7, sp, #0
3419c7b6:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419c7b8:	2300      	movs	r3, #0
3419c7ba:	60fb      	str	r3, [r7, #12]

  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c7bc:	687b      	ldr	r3, [r7, #4]
3419c7be:	3304      	adds	r3, #4
3419c7c0:	4618      	mov	r0, r3
3419c7c2:	f004 f989 	bl	341a0ad8 <VD6G_Stop>
3419c7c6:	60f8      	str	r0, [r7, #12]
  if (ret)
3419c7c8:	68fb      	ldr	r3, [r7, #12]
3419c7ca:	2b00      	cmp	r3, #0
3419c7cc:	d002      	beq.n	3419c7d4 <CMW_VD66GY_Stop+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c7ce:	f06f 0303 	mvn.w	r3, #3
3419c7d2:	e000      	b.n	3419c7d6 <CMW_VD66GY_Stop+0x26>
  }
  return CMW_ERROR_NONE;
3419c7d4:	2300      	movs	r3, #0
}
3419c7d6:	4618      	mov	r0, r3
3419c7d8:	3710      	adds	r7, #16
3419c7da:	46bd      	mov	sp, r7
3419c7dc:	bd80      	pop	{r7, pc}

3419c7de <CMW_VD66GY_DeInit>:

static int32_t CMW_VD66GY_DeInit(void *io_ctx)
{
3419c7de:	b580      	push	{r7, lr}
3419c7e0:	b084      	sub	sp, #16
3419c7e2:	af00      	add	r7, sp, #0
3419c7e4:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419c7e6:	2300      	movs	r3, #0
3419c7e8:	60fb      	str	r3, [r7, #12]

  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c7ea:	687b      	ldr	r3, [r7, #4]
3419c7ec:	3304      	adds	r3, #4
3419c7ee:	4618      	mov	r0, r3
3419c7f0:	f004 f972 	bl	341a0ad8 <VD6G_Stop>
3419c7f4:	60f8      	str	r0, [r7, #12]
  if (ret)
3419c7f6:	68fb      	ldr	r3, [r7, #12]
3419c7f8:	2b00      	cmp	r3, #0
3419c7fa:	d002      	beq.n	3419c802 <CMW_VD66GY_DeInit+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c7fc:	f06f 0303 	mvn.w	r3, #3
3419c800:	e010      	b.n	3419c824 <CMW_VD66GY_DeInit+0x46>
  }

  ret = VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419c802:	687b      	ldr	r3, [r7, #4]
3419c804:	3304      	adds	r3, #4
3419c806:	4618      	mov	r0, r3
3419c808:	f004 f928 	bl	341a0a5c <VD6G_DeInit>
3419c80c:	60f8      	str	r0, [r7, #12]
  if (ret)
3419c80e:	68fb      	ldr	r3, [r7, #12]
3419c810:	2b00      	cmp	r3, #0
3419c812:	d002      	beq.n	3419c81a <CMW_VD66GY_DeInit+0x3c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c814:	f06f 0303 	mvn.w	r3, #3
3419c818:	e004      	b.n	3419c824 <CMW_VD66GY_DeInit+0x46>
  }

  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 0;
3419c81a:	687b      	ldr	r3, [r7, #4]
3419c81c:	2200      	movs	r2, #0
3419c81e:	f883 211c 	strb.w	r2, [r3, #284]	@ 0x11c
  return CMW_ERROR_NONE;
3419c822:	2300      	movs	r3, #0
}
3419c824:	4618      	mov	r0, r3
3419c826:	3710      	adds	r7, #16
3419c828:	46bd      	mov	sp, r7
3419c82a:	bd80      	pop	{r7, pc}
3419c82c:	0000      	movs	r0, r0
	...

3419c830 <CMW_VD66GY_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t CMW_VD66GY_SetGain(void *io_ctx, int32_t gain)
{
3419c830:	b580      	push	{r7, lr}
3419c832:	b08e      	sub	sp, #56	@ 0x38
3419c834:	af00      	add	r7, sp, #0
3419c836:	6078      	str	r0, [r7, #4]
3419c838:	6039      	str	r1, [r7, #0]
  uint16_t dgain_regmin, dgain_regmax;
  uint32_t again_min_mdB, again_max_mdB;
  uint32_t dgain_min_mdB, dgain_max_mdB;
  double analog_linear_gain, digital_linear_gain;

  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3419c83a:	687b      	ldr	r3, [r7, #4]
3419c83c:	3304      	adds	r3, #4
3419c83e:	f107 0212 	add.w	r2, r7, #18
3419c842:	f107 0113 	add.w	r1, r7, #19
3419c846:	4618      	mov	r0, r3
3419c848:	f004 f97c 	bl	341a0b44 <VD6G_GetAnalogGainRegRange>
3419c84c:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419c84e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c850:	2b00      	cmp	r3, #0
3419c852:	d001      	beq.n	3419c858 <CMW_VD66GY_SetGain+0x28>
    return ret;
3419c854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c856:	e14b      	b.n	3419caf0 <CMW_VD66GY_SetGain+0x2c0>

  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
3419c858:	687b      	ldr	r3, [r7, #4]
3419c85a:	3304      	adds	r3, #4
3419c85c:	f107 020e 	add.w	r2, r7, #14
3419c860:	f107 0110 	add.w	r1, r7, #16
3419c864:	4618      	mov	r0, r3
3419c866:	f004 fa21 	bl	341a0cac <VD6G_GetDigitalGainRegRange>
3419c86a:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419c86c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c86e:	2b00      	cmp	r3, #0
3419c870:	d001      	beq.n	3419c876 <CMW_VD66GY_SetGain+0x46>
    return ret;
3419c872:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419c874:	e13c      	b.n	3419caf0 <CMW_VD66GY_SetGain+0x2c0>

  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3419c876:	7cfb      	ldrb	r3, [r7, #19]
3419c878:	f1c3 0320 	rsb	r3, r3, #32
3419c87c:	2220      	movs	r2, #32
3419c87e:	fb92 f3f3 	sdiv	r3, r2, r3
3419c882:	ee07 3a90 	vmov	s15, r3
3419c886:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419c88a:	eeb0 0b47 	vmov.f64	d0, d7
3419c88e:	f008 fa03 	bl	341a4c98 <log10>
3419c892:	eeb0 7b40 	vmov.f64	d7, d0
3419c896:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419c89a:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c89e:	ed9f 6b96 	vldr	d6, [pc, #600]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c8a2:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c8a6:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419c8aa:	ee17 3a90 	vmov	r3, s15
3419c8ae:	623b      	str	r3, [r7, #32]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3419c8b0:	7cbb      	ldrb	r3, [r7, #18]
3419c8b2:	f1c3 0320 	rsb	r3, r3, #32
3419c8b6:	2220      	movs	r2, #32
3419c8b8:	fb92 f3f3 	sdiv	r3, r2, r3
3419c8bc:	ee07 3a90 	vmov	s15, r3
3419c8c0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419c8c4:	eeb0 0b47 	vmov.f64	d0, d7
3419c8c8:	f008 f9e6 	bl	341a4c98 <log10>
3419c8cc:	eeb0 7b40 	vmov.f64	d7, d0
3419c8d0:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419c8d4:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c8d8:	ed9f 6b87 	vldr	d6, [pc, #540]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c8dc:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c8e0:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419c8e4:	ee17 3a90 	vmov	r3, s15
3419c8e8:	61fb      	str	r3, [r7, #28]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3419c8ea:	8a3b      	ldrh	r3, [r7, #16]
3419c8ec:	0a1b      	lsrs	r3, r3, #8
3419c8ee:	b29b      	uxth	r3, r3
3419c8f0:	ee07 3a90 	vmov	s15, r3
3419c8f4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419c8f8:	8a3b      	ldrh	r3, [r7, #16]
3419c8fa:	b2db      	uxtb	r3, r3
3419c8fc:	ee07 3a90 	vmov	s15, r3
3419c900:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419c904:	ed9f 6a82 	vldr	s12, [pc, #520]	@ 3419cb10 <CMW_VD66GY_SetGain+0x2e0>
3419c908:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419c90c:	ee77 7a27 	vadd.f32	s15, s14, s15
3419c910:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419c914:	eeb0 0b47 	vmov.f64	d0, d7
3419c918:	f008 f9be 	bl	341a4c98 <log10>
3419c91c:	eeb0 7b40 	vmov.f64	d7, d0
3419c920:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419c924:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c928:	ed9f 6b73 	vldr	d6, [pc, #460]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c92c:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c930:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419c934:	ee17 3a90 	vmov	r3, s15
3419c938:	61bb      	str	r3, [r7, #24]
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3419c93a:	89fb      	ldrh	r3, [r7, #14]
3419c93c:	0a1b      	lsrs	r3, r3, #8
3419c93e:	b29b      	uxth	r3, r3
3419c940:	ee07 3a90 	vmov	s15, r3
3419c944:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419c948:	89fb      	ldrh	r3, [r7, #14]
3419c94a:	b2db      	uxtb	r3, r3
3419c94c:	ee07 3a90 	vmov	s15, r3
3419c950:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419c954:	ed9f 6a6e 	vldr	s12, [pc, #440]	@ 3419cb10 <CMW_VD66GY_SetGain+0x2e0>
3419c958:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419c95c:	ee77 7a27 	vadd.f32	s15, s14, s15
3419c960:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419c964:	eeb0 0b47 	vmov.f64	d0, d7
3419c968:	f008 f996 	bl	341a4c98 <log10>
3419c96c:	eeb0 7b40 	vmov.f64	d7, d0
3419c970:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419c974:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c978:	ed9f 6b5f 	vldr	d6, [pc, #380]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c97c:	ee27 7b06 	vmul.f64	d7, d7, d6
3419c980:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419c984:	ee17 3a90 	vmov	r3, s15
3419c988:	617b      	str	r3, [r7, #20]

  if ((gain < dgain_min_mdB + again_min_mdB)
3419c98a:	69ba      	ldr	r2, [r7, #24]
3419c98c:	6a3b      	ldr	r3, [r7, #32]
3419c98e:	441a      	add	r2, r3
3419c990:	683b      	ldr	r3, [r7, #0]
3419c992:	429a      	cmp	r2, r3
3419c994:	d805      	bhi.n	3419c9a2 <CMW_VD66GY_SetGain+0x172>
      || (gain > dgain_max_mdB + again_max_mdB))
3419c996:	697a      	ldr	r2, [r7, #20]
3419c998:	69fb      	ldr	r3, [r7, #28]
3419c99a:	441a      	add	r2, r3
3419c99c:	683b      	ldr	r3, [r7, #0]
3419c99e:	429a      	cmp	r2, r3
3419c9a0:	d202      	bcs.n	3419c9a8 <CMW_VD66GY_SetGain+0x178>
    return -1;
3419c9a2:	f04f 33ff 	mov.w	r3, #4294967295
3419c9a6:	e0a3      	b.n	3419caf0 <CMW_VD66GY_SetGain+0x2c0>

  if (gain <= again_max_mdB)
3419c9a8:	683b      	ldr	r3, [r7, #0]
3419c9aa:	69fa      	ldr	r2, [r7, #28]
3419c9ac:	429a      	cmp	r2, r3
3419c9ae:	d32c      	bcc.n	3419ca0a <CMW_VD66GY_SetGain+0x1da>
  {
    /* Use analog gain only and set digital gain to its minimum */
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
3419c9b0:	683a      	ldr	r2, [r7, #0]
3419c9b2:	69bb      	ldr	r3, [r7, #24]
3419c9b4:	1ad3      	subs	r3, r2, r3
3419c9b6:	ee07 3a90 	vmov	s15, r3
3419c9ba:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419c9be:	ed9f 5b4e 	vldr	d5, [pc, #312]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c9c2:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419c9c6:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419c9ca:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419c9ce:	eeb0 1b46 	vmov.f64	d1, d6
3419c9d2:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419c9d6:	f008 f9ef 	bl	341a4db8 <pow>
3419c9da:	ed87 0b0c 	vstr	d0, [r7, #48]	@ 0x30
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)dgain_min_mdB);
3419c9de:	69bb      	ldr	r3, [r7, #24]
3419c9e0:	ee07 3a90 	vmov	s15, r3
3419c9e4:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419c9e8:	ed9f 5b43 	vldr	d5, [pc, #268]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419c9ec:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419c9f0:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419c9f4:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419c9f8:	eeb0 1b46 	vmov.f64	d1, d6
3419c9fc:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419ca00:	f008 f9da 	bl	341a4db8 <pow>
3419ca04:	ed87 0b0a 	vstr	d0, [r7, #40]	@ 0x28
3419ca08:	e02b      	b.n	3419ca62 <CMW_VD66GY_SetGain+0x232>
  }
  else
  {
    /* For higher gain values, add digital gain */
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
3419ca0a:	69fb      	ldr	r3, [r7, #28]
3419ca0c:	ee07 3a90 	vmov	s15, r3
3419ca10:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419ca14:	ed9f 5b38 	vldr	d5, [pc, #224]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419ca18:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419ca1c:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419ca20:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419ca24:	eeb0 1b46 	vmov.f64	d1, d6
3419ca28:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419ca2c:	f008 f9c4 	bl	341a4db8 <pow>
3419ca30:	ed87 0b0c 	vstr	d0, [r7, #48]	@ 0x30
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
3419ca34:	683a      	ldr	r2, [r7, #0]
3419ca36:	69fb      	ldr	r3, [r7, #28]
3419ca38:	1ad3      	subs	r3, r2, r3
3419ca3a:	ee07 3a90 	vmov	s15, r3
3419ca3e:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419ca42:	ed9f 5b2d 	vldr	d5, [pc, #180]	@ 3419caf8 <CMW_VD66GY_SetGain+0x2c8>
3419ca46:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419ca4a:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419ca4e:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419ca52:	eeb0 1b46 	vmov.f64	d1, d6
3419ca56:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419ca5a:	f008 f9ad 	bl	341a4db8 <pow>
3419ca5e:	ed87 0b0a 	vstr	d0, [r7, #40]	@ 0x28
  }

  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
3419ca62:	687b      	ldr	r3, [r7, #4]
3419ca64:	3304      	adds	r3, #4
3419ca66:	ed9f 5b26 	vldr	d5, [pc, #152]	@ 3419cb00 <CMW_VD66GY_SetGain+0x2d0>
3419ca6a:	ed97 6b0c 	vldr	d6, [r7, #48]	@ 0x30
3419ca6e:	ee85 7b06 	vdiv.f64	d7, d5, d6
3419ca72:	ed9f 6b23 	vldr	d6, [pc, #140]	@ 3419cb00 <CMW_VD66GY_SetGain+0x2d0>
3419ca76:	ee36 7b47 	vsub.f64	d7, d6, d7
3419ca7a:	eefd 7bc7 	vcvt.s32.f64	s15, d7
3419ca7e:	ee17 1a90 	vmov	r1, s15
3419ca82:	4618      	mov	r0, r3
3419ca84:	f004 f8c2 	bl	341a0c0c <VD6G_SetAnalogGain>
3419ca88:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419ca8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ca8c:	2b00      	cmp	r3, #0
3419ca8e:	d001      	beq.n	3419ca94 <CMW_VD66GY_SetGain+0x264>
    return ret;
3419ca90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ca92:	e02d      	b.n	3419caf0 <CMW_VD66GY_SetGain+0x2c0>

  ret = VD6G_SetDigitalGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, FLOAT_TO_FP58(digital_linear_gain));
3419ca94:	687b      	ldr	r3, [r7, #4]
3419ca96:	1d18      	adds	r0, r3, #4
3419ca98:	ed97 7b0a 	vldr	d7, [r7, #40]	@ 0x28
3419ca9c:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419caa0:	ee17 3990 	vmov.f16	r3, s15
3419caa4:	b29b      	uxth	r3, r3
3419caa6:	021a      	lsls	r2, r3, #8
3419caa8:	ed97 7b0a 	vldr	d7, [r7, #40]	@ 0x28
3419caac:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cab0:	ee17 3990 	vmov.f16	r3, s15
3419cab4:	b29b      	uxth	r3, r3
3419cab6:	ee07 3a90 	vmov	s15, r3
3419caba:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419cabe:	ed97 6b0a 	vldr	d6, [r7, #40]	@ 0x28
3419cac2:	ee36 7b47 	vsub.f64	d7, d6, d7
3419cac6:	ed9f 6b10 	vldr	d6, [pc, #64]	@ 3419cb08 <CMW_VD66GY_SetGain+0x2d8>
3419caca:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cace:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cad2:	ee17 3990 	vmov.f16	r3, s15
3419cad6:	b29b      	uxth	r3, r3
3419cad8:	b2db      	uxtb	r3, r3
3419cada:	4313      	orrs	r3, r2
3419cadc:	4619      	mov	r1, r3
3419cade:	f004 f93b 	bl	341a0d58 <VD6G_SetDigitalGain>
3419cae2:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419cae4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cae6:	2b00      	cmp	r3, #0
3419cae8:	d001      	beq.n	3419caee <CMW_VD66GY_SetGain+0x2be>
    return ret;
3419caea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419caec:	e000      	b.n	3419caf0 <CMW_VD66GY_SetGain+0x2c0>

  return 0;
3419caee:	2300      	movs	r3, #0
}
3419caf0:	4618      	mov	r0, r3
3419caf2:	3738      	adds	r7, #56	@ 0x38
3419caf4:	46bd      	mov	sp, r7
3419caf6:	bd80      	pop	{r7, pc}
3419caf8:	00000000 	.word	0x00000000
3419cafc:	408f4000 	.word	0x408f4000
3419cb00:	00000000 	.word	0x00000000
3419cb04:	40400000 	.word	0x40400000
3419cb08:	00000000 	.word	0x00000000
3419cb0c:	40700000 	.word	0x40700000
3419cb10:	43800000 	.word	0x43800000

3419cb14 <CMW_VD66GY_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t CMW_VD66GY_SetExposure(void *io_ctx, int32_t exposure)
{
3419cb14:	b580      	push	{r7, lr}
3419cb16:	b082      	sub	sp, #8
3419cb18:	af00      	add	r7, sp, #0
3419cb1a:	6078      	str	r0, [r7, #4]
3419cb1c:	6039      	str	r1, [r7, #0]
  return VD6G_SetExposureTime(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, exposure);
3419cb1e:	687b      	ldr	r3, [r7, #4]
3419cb20:	3304      	adds	r3, #4
3419cb22:	6839      	ldr	r1, [r7, #0]
3419cb24:	4618      	mov	r0, r3
3419cb26:	f004 fa45 	bl	341a0fb4 <VD6G_SetExposureTime>
3419cb2a:	4603      	mov	r3, r0
}
3419cb2c:	4618      	mov	r0, r3
3419cb2e:	3708      	adds	r7, #8
3419cb30:	46bd      	mov	sp, r7
3419cb32:	bd80      	pop	{r7, pc}

3419cb34 <CMW_VD66GY_SetExposureMode>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure mode
  * @retval Component status
  */
int32_t CMW_VD66GY_SetExposureMode(void *io_ctx, int32_t mode)
{
3419cb34:	b580      	push	{r7, lr}
3419cb36:	b084      	sub	sp, #16
3419cb38:	af00      	add	r7, sp, #0
3419cb3a:	6078      	str	r0, [r7, #4]
3419cb3c:	6039      	str	r1, [r7, #0]
  int ret = -1;
3419cb3e:	f04f 33ff 	mov.w	r3, #4294967295
3419cb42:	60fb      	str	r3, [r7, #12]

  switch (mode)
3419cb44:	683b      	ldr	r3, [r7, #0]
3419cb46:	2b01      	cmp	r3, #1
3419cb48:	d00a      	beq.n	3419cb60 <CMW_VD66GY_SetExposureMode+0x2c>
3419cb4a:	683b      	ldr	r3, [r7, #0]
3419cb4c:	2b02      	cmp	r3, #2
3419cb4e:	d10f      	bne.n	3419cb70 <CMW_VD66GY_SetExposureMode+0x3c>
  {
    case CMW_EXPOSUREMODE_MANUAL:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_MANUAL);
3419cb50:	687b      	ldr	r3, [r7, #4]
3419cb52:	3304      	adds	r3, #4
3419cb54:	2102      	movs	r1, #2
3419cb56:	4618      	mov	r0, r3
3419cb58:	f003 ffd6 	bl	341a0b08 <VD6G_SetExposureMode>
3419cb5c:	60f8      	str	r0, [r7, #12]
      break;
3419cb5e:	e00f      	b.n	3419cb80 <CMW_VD66GY_SetExposureMode+0x4c>
    case CMW_EXPOSUREMODE_AUTOFREEZE:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_FREEZE_AEALGO);
3419cb60:	687b      	ldr	r3, [r7, #4]
3419cb62:	3304      	adds	r3, #4
3419cb64:	2101      	movs	r1, #1
3419cb66:	4618      	mov	r0, r3
3419cb68:	f003 ffce 	bl	341a0b08 <VD6G_SetExposureMode>
3419cb6c:	60f8      	str	r0, [r7, #12]
      break;
3419cb6e:	e007      	b.n	3419cb80 <CMW_VD66GY_SetExposureMode+0x4c>
    case CMW_EXPOSUREMODE_AUTO:
    default:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_AUTO);
3419cb70:	687b      	ldr	r3, [r7, #4]
3419cb72:	3304      	adds	r3, #4
3419cb74:	2100      	movs	r1, #0
3419cb76:	4618      	mov	r0, r3
3419cb78:	f003 ffc6 	bl	341a0b08 <VD6G_SetExposureMode>
3419cb7c:	60f8      	str	r0, [r7, #12]
      break;
3419cb7e:	bf00      	nop
  }

  return (ret == 0) ? CMW_ERROR_NONE : CMW_ERROR_UNKNOWN_FAILURE;
3419cb80:	68fb      	ldr	r3, [r7, #12]
3419cb82:	2b00      	cmp	r3, #0
3419cb84:	d101      	bne.n	3419cb8a <CMW_VD66GY_SetExposureMode+0x56>
3419cb86:	2300      	movs	r3, #0
3419cb88:	e001      	b.n	3419cb8e <CMW_VD66GY_SetExposureMode+0x5a>
3419cb8a:	f06f 0305 	mvn.w	r3, #5
}
3419cb8e:	4618      	mov	r0, r3
3419cb90:	3710      	adds	r7, #16
3419cb92:	46bd      	mov	sp, r7
3419cb94:	bd80      	pop	{r7, pc}

3419cb96 <CMW_VD66GY_SetWBRefMode>:
  * @param  Automatic automatic mode enable/disable
  * @param  RefColorTemp color temperature if automatic mode is disabled
  * @retval Component status
  */
int32_t CMW_VD66GY_SetWBRefMode(void *io_ctx, uint8_t Automatic, uint32_t RefColorTemp)
{
3419cb96:	b580      	push	{r7, lr}
3419cb98:	b086      	sub	sp, #24
3419cb9a:	af00      	add	r7, sp, #0
3419cb9c:	60f8      	str	r0, [r7, #12]
3419cb9e:	460b      	mov	r3, r1
3419cba0:	607a      	str	r2, [r7, #4]
3419cba2:	72fb      	strb	r3, [r7, #11]
  int ret = CMW_ERROR_NONE;
3419cba4:	2300      	movs	r3, #0
3419cba6:	617b      	str	r3, [r7, #20]

  ret = ISP_SetWBRefMode(&((CMW_VD66GY_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
3419cba8:	68fb      	ldr	r3, [r7, #12]
3419cbaa:	336c      	adds	r3, #108	@ 0x6c
3419cbac:	7af9      	ldrb	r1, [r7, #11]
3419cbae:	687a      	ldr	r2, [r7, #4]
3419cbb0:	4618      	mov	r0, r3
3419cbb2:	f7fb fc4d 	bl	34198450 <ISP_SetWBRefMode>
3419cbb6:	4603      	mov	r3, r0
3419cbb8:	617b      	str	r3, [r7, #20]
  if (ret)
3419cbba:	697b      	ldr	r3, [r7, #20]
3419cbbc:	2b00      	cmp	r3, #0
3419cbbe:	d002      	beq.n	3419cbc6 <CMW_VD66GY_SetWBRefMode+0x30>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419cbc0:	f06f 0303 	mvn.w	r3, #3
3419cbc4:	e000      	b.n	3419cbc8 <CMW_VD66GY_SetWBRefMode+0x32>
  }

  return CMW_ERROR_NONE;
3419cbc6:	2300      	movs	r3, #0
}
3419cbc8:	4618      	mov	r0, r3
3419cbca:	3718      	adds	r7, #24
3419cbcc:	46bd      	mov	sp, r7
3419cbce:	bd80      	pop	{r7, pc}

3419cbd0 <CMW_VD66GY_ListWBRefModes>:
  * @param  io_ctx  pointer to component object
  * @param  RefColorTemp color temperature list
  * @retval Component status
  */
int32_t CMW_VD66GY_ListWBRefModes(void *io_ctx, uint32_t RefColorTemp[])
{
3419cbd0:	b580      	push	{r7, lr}
3419cbd2:	b084      	sub	sp, #16
3419cbd4:	af00      	add	r7, sp, #0
3419cbd6:	6078      	str	r0, [r7, #4]
3419cbd8:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419cbda:	2300      	movs	r3, #0
3419cbdc:	60fb      	str	r3, [r7, #12]

  ret = ISP_ListWBRefModes(&((CMW_VD66GY_t *)io_ctx)->hIsp, RefColorTemp);
3419cbde:	687b      	ldr	r3, [r7, #4]
3419cbe0:	336c      	adds	r3, #108	@ 0x6c
3419cbe2:	6839      	ldr	r1, [r7, #0]
3419cbe4:	4618      	mov	r0, r3
3419cbe6:	f7fb fc1d 	bl	34198424 <ISP_ListWBRefModes>
3419cbea:	4603      	mov	r3, r0
3419cbec:	60fb      	str	r3, [r7, #12]
  if (ret)
3419cbee:	68fb      	ldr	r3, [r7, #12]
3419cbf0:	2b00      	cmp	r3, #0
3419cbf2:	d002      	beq.n	3419cbfa <CMW_VD66GY_ListWBRefModes+0x2a>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419cbf4:	f06f 0303 	mvn.w	r3, #3
3419cbf8:	e000      	b.n	3419cbfc <CMW_VD66GY_ListWBRefModes+0x2c>
  }

  return CMW_ERROR_NONE;
3419cbfa:	2300      	movs	r3, #0
}
3419cbfc:	4618      	mov	r0, r3
3419cbfe:	3710      	adds	r7, #16
3419cc00:	46bd      	mov	sp, r7
3419cc02:	bd80      	pop	{r7, pc}
3419cc04:	0000      	movs	r0, r0
	...

3419cc08 <CMW_VD66GY_GetSensorInfo>:
  * @param  pObj  pointer to component object
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
int32_t CMW_VD66GY_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419cc08:	b580      	push	{r7, lr}
3419cc0a:	b08a      	sub	sp, #40	@ 0x28
3419cc0c:	af00      	add	r7, sp, #0
3419cc0e:	6078      	str	r0, [r7, #4]
3419cc10:	6039      	str	r1, [r7, #0]
  uint32_t again_min_mdB, again_max_mdB;
  uint32_t dgain_min_mdB, dgain_max_mdB;

  int ret;

  if ((!io_ctx) || (info == NULL))
3419cc12:	687b      	ldr	r3, [r7, #4]
3419cc14:	2b00      	cmp	r3, #0
3419cc16:	d002      	beq.n	3419cc1e <CMW_VD66GY_GetSensorInfo+0x16>
3419cc18:	683b      	ldr	r3, [r7, #0]
3419cc1a:	2b00      	cmp	r3, #0
3419cc1c:	d102      	bne.n	3419cc24 <CMW_VD66GY_GetSensorInfo+0x1c>
    return CMW_ERROR_WRONG_PARAM;
3419cc1e:	f06f 0301 	mvn.w	r3, #1
3419cc22:	e0de      	b.n	3419cde2 <CMW_VD66GY_GetSensorInfo+0x1da>

  /* Get sensor name */
  if (sizeof(info->name) >= strlen(VD66GY_NAME) + 1)
  {
    strcpy(info->name, VD66GY_NAME);
3419cc24:	683b      	ldr	r3, [r7, #0]
3419cc26:	4a74      	ldr	r2, [pc, #464]	@ (3419cdf8 <CMW_VD66GY_GetSensorInfo+0x1f0>)
3419cc28:	6810      	ldr	r0, [r2, #0]
3419cc2a:	6018      	str	r0, [r3, #0]
3419cc2c:	8891      	ldrh	r1, [r2, #4]
3419cc2e:	7992      	ldrb	r2, [r2, #6]
3419cc30:	8099      	strh	r1, [r3, #4]
3419cc32:	719a      	strb	r2, [r3, #6]
  {
    return CMW_ERROR_WRONG_PARAM;
  }

  /* Get isp bayer pattern info */
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
3419cc34:	687b      	ldr	r3, [r7, #4]
3419cc36:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
3419cc3a:	3b01      	subs	r3, #1
3419cc3c:	b2da      	uxtb	r2, r3
3419cc3e:	683b      	ldr	r3, [r7, #0]
3419cc40:	f883 2020 	strb.w	r2, [r3, #32]

  /* Get color depth */
  info->color_depth = VD6G_COLOR_DEPTH_RAW8;
3419cc44:	683b      	ldr	r3, [r7, #0]
3419cc46:	2208      	movs	r2, #8
3419cc48:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  /* Get resolution info */
  info->width = VD6G_MAX_WIDTH;
3419cc4c:	683b      	ldr	r3, [r7, #0]
3419cc4e:	f44f 628c 	mov.w	r2, #1120	@ 0x460
3419cc52:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = VD6G_MAX_HEIGHT;
3419cc54:	683b      	ldr	r3, [r7, #0]
3419cc56:	f240 5254 	movw	r2, #1364	@ 0x554
3419cc5a:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Get gain range */
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3419cc5c:	687b      	ldr	r3, [r7, #4]
3419cc5e:	3304      	adds	r3, #4
3419cc60:	f107 0212 	add.w	r2, r7, #18
3419cc64:	f107 0113 	add.w	r1, r7, #19
3419cc68:	4618      	mov	r0, r3
3419cc6a:	f003 ff6b 	bl	341a0b44 <VD6G_GetAnalogGainRegRange>
3419cc6e:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419cc70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cc72:	2b00      	cmp	r3, #0
3419cc74:	d001      	beq.n	3419cc7a <CMW_VD66GY_GetSensorInfo+0x72>
    return ret;
3419cc76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cc78:	e0b3      	b.n	3419cde2 <CMW_VD66GY_GetSensorInfo+0x1da>

  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
3419cc7a:	687b      	ldr	r3, [r7, #4]
3419cc7c:	3304      	adds	r3, #4
3419cc7e:	f107 020e 	add.w	r2, r7, #14
3419cc82:	f107 0110 	add.w	r1, r7, #16
3419cc86:	4618      	mov	r0, r3
3419cc88:	f004 f810 	bl	341a0cac <VD6G_GetDigitalGainRegRange>
3419cc8c:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419cc8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cc90:	2b00      	cmp	r3, #0
3419cc92:	d001      	beq.n	3419cc98 <CMW_VD66GY_GetSensorInfo+0x90>
    return ret;
3419cc94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cc96:	e0a4      	b.n	3419cde2 <CMW_VD66GY_GetSensorInfo+0x1da>

  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3419cc98:	7cfb      	ldrb	r3, [r7, #19]
3419cc9a:	f1c3 0320 	rsb	r3, r3, #32
3419cc9e:	2220      	movs	r2, #32
3419cca0:	fb92 f3f3 	sdiv	r3, r2, r3
3419cca4:	ee07 3a90 	vmov	s15, r3
3419cca8:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419ccac:	eeb0 0b47 	vmov.f64	d0, d7
3419ccb0:	f007 fff2 	bl	341a4c98 <log10>
3419ccb4:	eeb0 7b40 	vmov.f64	d7, d0
3419ccb8:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419ccbc:	ee27 7b06 	vmul.f64	d7, d7, d6
3419ccc0:	ed9f 6b4b 	vldr	d6, [pc, #300]	@ 3419cdf0 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419ccc4:	ee27 7b06 	vmul.f64	d7, d7, d6
3419ccc8:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cccc:	ee17 3a90 	vmov	r3, s15
3419ccd0:	623b      	str	r3, [r7, #32]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3419ccd2:	7cbb      	ldrb	r3, [r7, #18]
3419ccd4:	f1c3 0320 	rsb	r3, r3, #32
3419ccd8:	2220      	movs	r2, #32
3419ccda:	fb92 f3f3 	sdiv	r3, r2, r3
3419ccde:	ee07 3a90 	vmov	s15, r3
3419cce2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419cce6:	eeb0 0b47 	vmov.f64	d0, d7
3419ccea:	f007 ffd5 	bl	341a4c98 <log10>
3419ccee:	eeb0 7b40 	vmov.f64	d7, d0
3419ccf2:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419ccf6:	ee27 7b06 	vmul.f64	d7, d7, d6
3419ccfa:	ed9f 6b3d 	vldr	d6, [pc, #244]	@ 3419cdf0 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419ccfe:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cd02:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cd06:	ee17 3a90 	vmov	r3, s15
3419cd0a:	61fb      	str	r3, [r7, #28]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3419cd0c:	8a3b      	ldrh	r3, [r7, #16]
3419cd0e:	0a1b      	lsrs	r3, r3, #8
3419cd10:	b29b      	uxth	r3, r3
3419cd12:	ee07 3a90 	vmov	s15, r3
3419cd16:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419cd1a:	8a3b      	ldrh	r3, [r7, #16]
3419cd1c:	b2db      	uxtb	r3, r3
3419cd1e:	ee07 3a90 	vmov	s15, r3
3419cd22:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419cd26:	ed9f 6a35 	vldr	s12, [pc, #212]	@ 3419cdfc <CMW_VD66GY_GetSensorInfo+0x1f4>
3419cd2a:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419cd2e:	ee77 7a27 	vadd.f32	s15, s14, s15
3419cd32:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419cd36:	eeb0 0b47 	vmov.f64	d0, d7
3419cd3a:	f007 ffad 	bl	341a4c98 <log10>
3419cd3e:	eeb0 7b40 	vmov.f64	d7, d0
3419cd42:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419cd46:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cd4a:	ed9f 6b29 	vldr	d6, [pc, #164]	@ 3419cdf0 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419cd4e:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cd52:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cd56:	ee17 3a90 	vmov	r3, s15
3419cd5a:	61bb      	str	r3, [r7, #24]
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3419cd5c:	89fb      	ldrh	r3, [r7, #14]
3419cd5e:	0a1b      	lsrs	r3, r3, #8
3419cd60:	b29b      	uxth	r3, r3
3419cd62:	ee07 3a90 	vmov	s15, r3
3419cd66:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419cd6a:	89fb      	ldrh	r3, [r7, #14]
3419cd6c:	b2db      	uxtb	r3, r3
3419cd6e:	ee07 3a90 	vmov	s15, r3
3419cd72:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419cd76:	ed9f 6a21 	vldr	s12, [pc, #132]	@ 3419cdfc <CMW_VD66GY_GetSensorInfo+0x1f4>
3419cd7a:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419cd7e:	ee77 7a27 	vadd.f32	s15, s14, s15
3419cd82:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419cd86:	eeb0 0b47 	vmov.f64	d0, d7
3419cd8a:	f007 ff85 	bl	341a4c98 <log10>
3419cd8e:	eeb0 7b40 	vmov.f64	d7, d0
3419cd92:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419cd96:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cd9a:	ed9f 6b15 	vldr	d6, [pc, #84]	@ 3419cdf0 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419cd9e:	ee27 7b06 	vmul.f64	d7, d7, d6
3419cda2:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419cda6:	ee17 3a90 	vmov	r3, s15
3419cdaa:	617b      	str	r3, [r7, #20]

  info->gain_min = again_min_mdB + dgain_min_mdB;
3419cdac:	6a3a      	ldr	r2, [r7, #32]
3419cdae:	69bb      	ldr	r3, [r7, #24]
3419cdb0:	441a      	add	r2, r3
3419cdb2:	683b      	ldr	r3, [r7, #0]
3419cdb4:	62da      	str	r2, [r3, #44]	@ 0x2c
  info->gain_max = again_max_mdB + dgain_max_mdB;
3419cdb6:	69fa      	ldr	r2, [r7, #28]
3419cdb8:	697b      	ldr	r3, [r7, #20]
3419cdba:	441a      	add	r2, r3
3419cdbc:	683b      	ldr	r3, [r7, #0]
3419cdbe:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Get exposure range */
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
3419cdc0:	687b      	ldr	r3, [r7, #4]
3419cdc2:	1d18      	adds	r0, r3, #4
3419cdc4:	683b      	ldr	r3, [r7, #0]
3419cdc6:	f103 0134 	add.w	r1, r3, #52	@ 0x34
3419cdca:	683b      	ldr	r3, [r7, #0]
3419cdcc:	3338      	adds	r3, #56	@ 0x38
3419cdce:	461a      	mov	r2, r3
3419cdd0:	f004 f872 	bl	341a0eb8 <VD6G_GetExposureRegRange>
3419cdd4:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419cdd6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cdd8:	2b00      	cmp	r3, #0
3419cdda:	d001      	beq.n	3419cde0 <CMW_VD66GY_GetSensorInfo+0x1d8>
    return ret;
3419cddc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419cdde:	e000      	b.n	3419cde2 <CMW_VD66GY_GetSensorInfo+0x1da>

  return CMW_ERROR_NONE;
3419cde0:	2300      	movs	r3, #0
}
3419cde2:	4618      	mov	r0, r3
3419cde4:	3728      	adds	r7, #40	@ 0x28
3419cde6:	46bd      	mov	sp, r7
3419cde8:	bd80      	pop	{r7, pc}
3419cdea:	bf00      	nop
3419cdec:	f3af 8000 	nop.w
3419cdf0:	00000000 	.word	0x00000000
3419cdf4:	408f4000 	.word	0x408f4000
3419cdf8:	341a606c 	.word	0x341a606c
3419cdfc:	43800000 	.word	0x43800000

3419ce00 <CMW_VD66GY_VsyncEventCallback>:

static void CMW_VD66GY_VsyncEventCallback(void *io_ctx, uint32_t pipe)
{
3419ce00:	b580      	push	{r7, lr}
3419ce02:	b082      	sub	sp, #8
3419ce04:	af00      	add	r7, sp, #0
3419ce06:	6078      	str	r0, [r7, #4]
3419ce08:	6039      	str	r1, [r7, #0]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Update the ISP frame counter and call its statistics handler */
  switch (pipe)
3419ce0a:	683b      	ldr	r3, [r7, #0]
3419ce0c:	2b02      	cmp	r3, #2
3419ce0e:	d01a      	beq.n	3419ce46 <CMW_VD66GY_VsyncEventCallback+0x46>
3419ce10:	683b      	ldr	r3, [r7, #0]
3419ce12:	2b02      	cmp	r3, #2
3419ce14:	d81d      	bhi.n	3419ce52 <CMW_VD66GY_VsyncEventCallback+0x52>
3419ce16:	683b      	ldr	r3, [r7, #0]
3419ce18:	2b00      	cmp	r3, #0
3419ce1a:	d003      	beq.n	3419ce24 <CMW_VD66GY_VsyncEventCallback+0x24>
3419ce1c:	683b      	ldr	r3, [r7, #0]
3419ce1e:	2b01      	cmp	r3, #1
3419ce20:	d006      	beq.n	3419ce30 <CMW_VD66GY_VsyncEventCallback+0x30>
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
      break;
  }
#endif
}
3419ce22:	e016      	b.n	3419ce52 <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncDumpFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419ce24:	687b      	ldr	r3, [r7, #4]
3419ce26:	336c      	adds	r3, #108	@ 0x6c
3419ce28:	4618      	mov	r0, r3
3419ce2a:	f7fb fbc1 	bl	341985b0 <ISP_IncDumpFrameId>
      break;
3419ce2e:	e010      	b.n	3419ce52 <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncMainFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419ce30:	687b      	ldr	r3, [r7, #4]
3419ce32:	336c      	adds	r3, #108	@ 0x6c
3419ce34:	4618      	mov	r0, r3
3419ce36:	f7fb fba5 	bl	34198584 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419ce3a:	687b      	ldr	r3, [r7, #4]
3419ce3c:	336c      	adds	r3, #108	@ 0x6c
3419ce3e:	4618      	mov	r0, r3
3419ce40:	f7fb fb95 	bl	3419856e <ISP_GatherStatistics>
      break;
3419ce44:	e005      	b.n	3419ce52 <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419ce46:	687b      	ldr	r3, [r7, #4]
3419ce48:	336c      	adds	r3, #108	@ 0x6c
3419ce4a:	4618      	mov	r0, r3
3419ce4c:	f7fb fba5 	bl	3419859a <ISP_IncAncillaryFrameId>
      break;
3419ce50:	bf00      	nop
}
3419ce52:	bf00      	nop
3419ce54:	3708      	adds	r7, #8
3419ce56:	46bd      	mov	sp, r7
3419ce58:	bd80      	pop	{r7, pc}

3419ce5a <CMW_VD66GY_FrameEventCallback>:

static void CMW_VD66GY_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
3419ce5a:	b480      	push	{r7}
3419ce5c:	b083      	sub	sp, #12
3419ce5e:	af00      	add	r7, sp, #0
3419ce60:	6078      	str	r0, [r7, #4]
3419ce62:	6039      	str	r1, [r7, #0]
}
3419ce64:	bf00      	nop
3419ce66:	370c      	adds	r7, #12
3419ce68:	46bd      	mov	sp, r7
3419ce6a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ce6e:	4770      	bx	lr

3419ce70 <VD66GY_RegisterBusIO>:

int32_t VD66GY_RegisterBusIO(CMW_VD66GY_t *io_ctx)
{
3419ce70:	b580      	push	{r7, lr}
3419ce72:	b084      	sub	sp, #16
3419ce74:	af00      	add	r7, sp, #0
3419ce76:	6078      	str	r0, [r7, #4]
  int ret;

  if (!io_ctx)
3419ce78:	687b      	ldr	r3, [r7, #4]
3419ce7a:	2b00      	cmp	r3, #0
3419ce7c:	d102      	bne.n	3419ce84 <VD66GY_RegisterBusIO+0x14>
    return CMW_ERROR_COMPONENT_FAILURE;
3419ce7e:	f06f 0304 	mvn.w	r3, #4
3419ce82:	e00d      	b.n	3419cea0 <VD66GY_RegisterBusIO+0x30>

  if (!io_ctx->Init)
3419ce84:	687b      	ldr	r3, [r7, #4]
3419ce86:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3419ce8a:	2b00      	cmp	r3, #0
3419ce8c:	d102      	bne.n	3419ce94 <VD66GY_RegisterBusIO+0x24>
    return CMW_ERROR_COMPONENT_FAILURE;
3419ce8e:	f06f 0304 	mvn.w	r3, #4
3419ce92:	e005      	b.n	3419cea0 <VD66GY_RegisterBusIO+0x30>

  ret = io_ctx->Init();
3419ce94:	687b      	ldr	r3, [r7, #4]
3419ce96:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3419ce9a:	4798      	blx	r3
3419ce9c:	60f8      	str	r0, [r7, #12]

  return ret;
3419ce9e:	68fb      	ldr	r3, [r7, #12]
}
3419cea0:	4618      	mov	r0, r3
3419cea2:	3710      	adds	r7, #16
3419cea4:	46bd      	mov	sp, r7
3419cea6:	bd80      	pop	{r7, pc}

3419cea8 <VD66GY_ReadID>:

int32_t VD66GY_ReadID(CMW_VD66GY_t *io_ctx, uint32_t *Id)
{
3419cea8:	b580      	push	{r7, lr}
3419ceaa:	b084      	sub	sp, #16
3419ceac:	af00      	add	r7, sp, #0
3419ceae:	6078      	str	r0, [r7, #4]
3419ceb0:	6039      	str	r1, [r7, #0]
  uint16_t reg16;
  int32_t ret;

  ret = CMW_VD66GY_Read16(io_ctx, VD66GY_REG_MODEL_ID, &reg16);
3419ceb2:	f107 030a 	add.w	r3, r7, #10
3419ceb6:	461a      	mov	r2, r3
3419ceb8:	2100      	movs	r1, #0
3419ceba:	6878      	ldr	r0, [r7, #4]
3419cebc:	f7ff f96f 	bl	3419c19e <CMW_VD66GY_Read16>
3419cec0:	60f8      	str	r0, [r7, #12]
  if (ret)
3419cec2:	68fb      	ldr	r3, [r7, #12]
3419cec4:	2b00      	cmp	r3, #0
3419cec6:	d001      	beq.n	3419cecc <VD66GY_ReadID+0x24>
    return ret;
3419cec8:	68fb      	ldr	r3, [r7, #12]
3419ceca:	e004      	b.n	3419ced6 <VD66GY_ReadID+0x2e>

  *Id = reg16;
3419cecc:	897b      	ldrh	r3, [r7, #10]
3419cece:	461a      	mov	r2, r3
3419ced0:	683b      	ldr	r3, [r7, #0]
3419ced2:	601a      	str	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419ced4:	2300      	movs	r3, #0
}
3419ced6:	4618      	mov	r0, r3
3419ced8:	3710      	adds	r7, #16
3419ceda:	46bd      	mov	sp, r7
3419cedc:	bd80      	pop	{r7, pc}

3419cede <CMW_VD66GY_PowerOn>:

static void CMW_VD66GY_PowerOn(CMW_VD66GY_t *io_ctx)
{
3419cede:	b580      	push	{r7, lr}
3419cee0:	b082      	sub	sp, #8
3419cee2:	af00      	add	r7, sp, #0
3419cee4:	6078      	str	r0, [r7, #4]
  /* Camera sensor Power-On sequence */
  /* Assert the camera  NRST pins */
  io_ctx->EnablePin(1);
3419cee6:	687b      	ldr	r3, [r7, #4]
3419cee8:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3419ceec:	2001      	movs	r0, #1
3419ceee:	4798      	blx	r3
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419cef0:	687b      	ldr	r3, [r7, #4]
3419cef2:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419cef6:	2000      	movs	r0, #0
3419cef8:	4798      	blx	r3
  HAL_Delay(200);   /* NRST signals asserted during 200ms */
3419cefa:	20c8      	movs	r0, #200	@ 0xc8
3419cefc:	f7e8 fa34 	bl	34185368 <HAL_Delay>
  /* De-assert the camera STANDBY pin (active high) */
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419cf00:	687b      	ldr	r3, [r7, #4]
3419cf02:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419cf06:	2001      	movs	r0, #1
3419cf08:	4798      	blx	r3
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
3419cf0a:	2014      	movs	r0, #20
3419cf0c:	f7e8 fa2c 	bl	34185368 <HAL_Delay>
}
3419cf10:	bf00      	nop
3419cf12:	3708      	adds	r7, #8
3419cf14:	46bd      	mov	sp, r7
3419cf16:	bd80      	pop	{r7, pc}

3419cf18 <CMW_VD66GY_Probe>:

int CMW_VD66GY_Probe(CMW_VD66GY_t *io_ctx, CMW_Sensor_if_t *vd6g_if)
{
3419cf18:	b580      	push	{r7, lr}
3419cf1a:	b084      	sub	sp, #16
3419cf1c:	af00      	add	r7, sp, #0
3419cf1e:	6078      	str	r0, [r7, #4]
3419cf20:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419cf22:	2300      	movs	r3, #0
3419cf24:	60fb      	str	r3, [r7, #12]
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
3419cf26:	687b      	ldr	r3, [r7, #4]
3419cf28:	4a37      	ldr	r2, [pc, #220]	@ (3419d008 <CMW_VD66GY_Probe+0xf0>)
3419cf2a:	605a      	str	r2, [r3, #4]
  io_ctx->ctx_driver.read8 = VD6G_Read8;
3419cf2c:	687b      	ldr	r3, [r7, #4]
3419cf2e:	4a37      	ldr	r2, [pc, #220]	@ (3419d00c <CMW_VD66GY_Probe+0xf4>)
3419cf30:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.read16 = VD6G_Read16;
3419cf32:	687b      	ldr	r3, [r7, #4]
3419cf34:	4a36      	ldr	r2, [pc, #216]	@ (3419d010 <CMW_VD66GY_Probe+0xf8>)
3419cf36:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.read32 = VD6G_Read32;
3419cf38:	687b      	ldr	r3, [r7, #4]
3419cf3a:	4a36      	ldr	r2, [pc, #216]	@ (3419d014 <CMW_VD66GY_Probe+0xfc>)
3419cf3c:	611a      	str	r2, [r3, #16]
  io_ctx->ctx_driver.write8 = VD6G_Write8;
3419cf3e:	687b      	ldr	r3, [r7, #4]
3419cf40:	4a35      	ldr	r2, [pc, #212]	@ (3419d018 <CMW_VD66GY_Probe+0x100>)
3419cf42:	615a      	str	r2, [r3, #20]
  io_ctx->ctx_driver.write16 = VD6G_Write16;
3419cf44:	687b      	ldr	r3, [r7, #4]
3419cf46:	4a35      	ldr	r2, [pc, #212]	@ (3419d01c <CMW_VD66GY_Probe+0x104>)
3419cf48:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.write32 = VD6G_Write32;
3419cf4a:	687b      	ldr	r3, [r7, #4]
3419cf4c:	4a34      	ldr	r2, [pc, #208]	@ (3419d020 <CMW_VD66GY_Probe+0x108>)
3419cf4e:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.write_array = VD6G_WriteArray;
3419cf50:	687b      	ldr	r3, [r7, #4]
3419cf52:	4a34      	ldr	r2, [pc, #208]	@ (3419d024 <CMW_VD66GY_Probe+0x10c>)
3419cf54:	621a      	str	r2, [r3, #32]
  io_ctx->ctx_driver.delay = VD6G_Delay;
3419cf56:	687b      	ldr	r3, [r7, #4]
3419cf58:	4a33      	ldr	r2, [pc, #204]	@ (3419d028 <CMW_VD66GY_Probe+0x110>)
3419cf5a:	625a      	str	r2, [r3, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD6G_Log;
3419cf5c:	687b      	ldr	r3, [r7, #4]
3419cf5e:	4a33      	ldr	r2, [pc, #204]	@ (3419d02c <CMW_VD66GY_Probe+0x114>)
3419cf60:	629a      	str	r2, [r3, #40]	@ 0x28

  CMW_VD66GY_PowerOn(io_ctx);
3419cf62:	6878      	ldr	r0, [r7, #4]
3419cf64:	f7ff ffbb 	bl	3419cede <CMW_VD66GY_PowerOn>

  ret = VD66GY_RegisterBusIO(io_ctx);
3419cf68:	6878      	ldr	r0, [r7, #4]
3419cf6a:	f7ff ff81 	bl	3419ce70 <VD66GY_RegisterBusIO>
3419cf6e:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419cf70:	68fb      	ldr	r3, [r7, #12]
3419cf72:	2b00      	cmp	r3, #0
3419cf74:	d002      	beq.n	3419cf7c <CMW_VD66GY_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419cf76:	f06f 0304 	mvn.w	r3, #4
3419cf7a:	e041      	b.n	3419d000 <CMW_VD66GY_Probe+0xe8>
  }

  ret = VD66GY_ReadID(io_ctx, &id);
3419cf7c:	f107 0308 	add.w	r3, r7, #8
3419cf80:	4619      	mov	r1, r3
3419cf82:	6878      	ldr	r0, [r7, #4]
3419cf84:	f7ff ff90 	bl	3419cea8 <VD66GY_ReadID>
3419cf88:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419cf8a:	68fb      	ldr	r3, [r7, #12]
3419cf8c:	2b00      	cmp	r3, #0
3419cf8e:	d002      	beq.n	3419cf96 <CMW_VD66GY_Probe+0x7e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419cf90:	f06f 0304 	mvn.w	r3, #4
3419cf94:	e034      	b.n	3419d000 <CMW_VD66GY_Probe+0xe8>
  }
  if (id != VD66GY_CHIP_ID)
3419cf96:	68bb      	ldr	r3, [r7, #8]
3419cf98:	f245 6203 	movw	r2, #22019	@ 0x5603
3419cf9c:	4293      	cmp	r3, r2
3419cf9e:	d002      	beq.n	3419cfa6 <CMW_VD66GY_Probe+0x8e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419cfa0:	f06f 0304 	mvn.w	r3, #4
3419cfa4:	e02c      	b.n	3419d000 <CMW_VD66GY_Probe+0xe8>
  }

  memset(vd6g_if, 0, sizeof(*vd6g_if));
3419cfa6:	2268      	movs	r2, #104	@ 0x68
3419cfa8:	2100      	movs	r1, #0
3419cfaa:	6838      	ldr	r0, [r7, #0]
3419cfac:	f006 fefa 	bl	341a3da4 <memset>
  vd6g_if->Init = CMW_VD66GY_Init;
3419cfb0:	683b      	ldr	r3, [r7, #0]
3419cfb2:	4a1f      	ldr	r2, [pc, #124]	@ (3419d030 <CMW_VD66GY_Probe+0x118>)
3419cfb4:	601a      	str	r2, [r3, #0]
  vd6g_if->DeInit = CMW_VD66GY_DeInit;
3419cfb6:	683b      	ldr	r3, [r7, #0]
3419cfb8:	4a1e      	ldr	r2, [pc, #120]	@ (3419d034 <CMW_VD66GY_Probe+0x11c>)
3419cfba:	605a      	str	r2, [r3, #4]
  vd6g_if->Run = CMW_VD66GY_Run;
3419cfbc:	683b      	ldr	r3, [r7, #0]
3419cfbe:	4a1e      	ldr	r2, [pc, #120]	@ (3419d038 <CMW_VD66GY_Probe+0x120>)
3419cfc0:	60da      	str	r2, [r3, #12]
  vd6g_if->VsyncEventCallback = CMW_VD66GY_VsyncEventCallback;
3419cfc2:	683b      	ldr	r3, [r7, #0]
3419cfc4:	4a1d      	ldr	r2, [pc, #116]	@ (3419d03c <CMW_VD66GY_Probe+0x124>)
3419cfc6:	611a      	str	r2, [r3, #16]
  vd6g_if->FrameEventCallback = CMW_VD66GY_FrameEventCallback;
3419cfc8:	683b      	ldr	r3, [r7, #0]
3419cfca:	4a1d      	ldr	r2, [pc, #116]	@ (3419d040 <CMW_VD66GY_Probe+0x128>)
3419cfcc:	615a      	str	r2, [r3, #20]
  vd6g_if->Start = CMW_VD66GY_Start;
3419cfce:	683b      	ldr	r3, [r7, #0]
3419cfd0:	4a1c      	ldr	r2, [pc, #112]	@ (3419d044 <CMW_VD66GY_Probe+0x12c>)
3419cfd2:	609a      	str	r2, [r3, #8]
  vd6g_if->Stop = CMW_VD66GY_Stop;
3419cfd4:	683b      	ldr	r3, [r7, #0]
3419cfd6:	4a1c      	ldr	r2, [pc, #112]	@ (3419d048 <CMW_VD66GY_Probe+0x130>)
3419cfd8:	619a      	str	r2, [r3, #24]
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
3419cfda:	683b      	ldr	r3, [r7, #0]
3419cfdc:	4a1b      	ldr	r2, [pc, #108]	@ (3419d04c <CMW_VD66GY_Probe+0x134>)
3419cfde:	649a      	str	r2, [r3, #72]	@ 0x48
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
3419cfe0:	683b      	ldr	r3, [r7, #0]
3419cfe2:	4a1b      	ldr	r2, [pc, #108]	@ (3419d050 <CMW_VD66GY_Probe+0x138>)
3419cfe4:	64da      	str	r2, [r3, #76]	@ 0x4c
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
3419cfe6:	683b      	ldr	r3, [r7, #0]
3419cfe8:	4a1a      	ldr	r2, [pc, #104]	@ (3419d054 <CMW_VD66GY_Probe+0x13c>)
3419cfea:	651a      	str	r2, [r3, #80]	@ 0x50
  vd6g_if->SetWBRefMode = CMW_VD66GY_SetWBRefMode;
3419cfec:	683b      	ldr	r3, [r7, #0]
3419cfee:	4a1a      	ldr	r2, [pc, #104]	@ (3419d058 <CMW_VD66GY_Probe+0x140>)
3419cff0:	655a      	str	r2, [r3, #84]	@ 0x54
  vd6g_if->ListWBRefModes = CMW_VD66GY_ListWBRefModes;
3419cff2:	683b      	ldr	r3, [r7, #0]
3419cff4:	4a19      	ldr	r2, [pc, #100]	@ (3419d05c <CMW_VD66GY_Probe+0x144>)
3419cff6:	659a      	str	r2, [r3, #88]	@ 0x58
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
3419cff8:	683b      	ldr	r3, [r7, #0]
3419cffa:	4a19      	ldr	r2, [pc, #100]	@ (3419d060 <CMW_VD66GY_Probe+0x148>)
3419cffc:	661a      	str	r2, [r3, #96]	@ 0x60
  return ret;
3419cffe:	68fb      	ldr	r3, [r7, #12]
}
3419d000:	4618      	mov	r0, r3
3419d002:	3710      	adds	r7, #16
3419d004:	46bd      	mov	sp, r7
3419d006:	bd80      	pop	{r7, pc}
3419d008:	3419c2c1 	.word	0x3419c2c1
3419d00c:	3419c2e3 	.word	0x3419c2e3
3419d010:	3419c30d 	.word	0x3419c30d
3419d014:	3419c337 	.word	0x3419c337
3419d018:	3419c361 	.word	0x3419c361
3419d01c:	3419c38d 	.word	0x3419c38d
3419d020:	3419c3b9 	.word	0x3419c3b9
3419d024:	3419c3e3 	.word	0x3419c3e3
3419d028:	3419c451 	.word	0x3419c451
3419d02c:	3419c473 	.word	0x3419c473
3419d030:	3419c56d 	.word	0x3419c56d
3419d034:	3419c7df 	.word	0x3419c7df
3419d038:	3419c785 	.word	0x3419c785
3419d03c:	3419ce01 	.word	0x3419ce01
3419d040:	3419ce5b 	.word	0x3419ce5b
3419d044:	3419c705 	.word	0x3419c705
3419d048:	3419c7b1 	.word	0x3419c7b1
3419d04c:	3419c831 	.word	0x3419c831
3419d050:	3419cb15 	.word	0x3419cb15
3419d054:	3419cb35 	.word	0x3419cb35
3419d058:	3419cb97 	.word	0x3419cb97
3419d05c:	3419cbd1 	.word	0x3419cbd1
3419d060:	3419cc09 	.word	0x3419cc09

3419d064 <IMX335_WriteTable>:

/** @defgroup IMX335_Private_Functions Private Functions
  * @{
  */
static int32_t IMX335_WriteTable(IMX335_Object_t *pObj, const struct regval *regs, uint32_t size)
{
3419d064:	b580      	push	{r7, lr}
3419d066:	b086      	sub	sp, #24
3419d068:	af00      	add	r7, sp, #0
3419d06a:	60f8      	str	r0, [r7, #12]
3419d06c:	60b9      	str	r1, [r7, #8]
3419d06e:	607a      	str	r2, [r7, #4]
  uint32_t index;
  int32_t ret = IMX335_OK;
3419d070:	2300      	movs	r3, #0
3419d072:	613b      	str	r3, [r7, #16]

  /* Set registers */
  for(index=0; index<size ; index++)
3419d074:	2300      	movs	r3, #0
3419d076:	617b      	str	r3, [r7, #20]
3419d078:	e01c      	b.n	3419d0b4 <IMX335_WriteTable+0x50>
  {
    if(ret != IMX335_ERROR)
3419d07a:	693b      	ldr	r3, [r7, #16]
3419d07c:	f1b3 3fff 	cmp.w	r3, #4294967295
3419d080:	d015      	beq.n	3419d0ae <IMX335_WriteTable+0x4a>
    {
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
3419d082:	68fb      	ldr	r3, [r7, #12]
3419d084:	f103 0018 	add.w	r0, r3, #24
3419d088:	697b      	ldr	r3, [r7, #20]
3419d08a:	009b      	lsls	r3, r3, #2
3419d08c:	68ba      	ldr	r2, [r7, #8]
3419d08e:	4413      	add	r3, r2
3419d090:	8819      	ldrh	r1, [r3, #0]
3419d092:	697b      	ldr	r3, [r7, #20]
3419d094:	009b      	lsls	r3, r3, #2
3419d096:	68ba      	ldr	r2, [r7, #8]
3419d098:	4413      	add	r3, r2
3419d09a:	1c9a      	adds	r2, r3, #2
3419d09c:	2301      	movs	r3, #1
3419d09e:	f000 fb80 	bl	3419d7a2 <imx335_write_reg>
3419d0a2:	4603      	mov	r3, r0
3419d0a4:	2b00      	cmp	r3, #0
3419d0a6:	d002      	beq.n	3419d0ae <IMX335_WriteTable+0x4a>
      {
        ret = IMX335_ERROR;
3419d0a8:	f04f 33ff 	mov.w	r3, #4294967295
3419d0ac:	613b      	str	r3, [r7, #16]
  for(index=0; index<size ; index++)
3419d0ae:	697b      	ldr	r3, [r7, #20]
3419d0b0:	3301      	adds	r3, #1
3419d0b2:	617b      	str	r3, [r7, #20]
3419d0b4:	697a      	ldr	r2, [r7, #20]
3419d0b6:	687b      	ldr	r3, [r7, #4]
3419d0b8:	429a      	cmp	r2, r3
3419d0ba:	d3de      	bcc.n	3419d07a <IMX335_WriteTable+0x16>
      }
    }
  }
  return ret;
3419d0bc:	693b      	ldr	r3, [r7, #16]
}
3419d0be:	4618      	mov	r0, r3
3419d0c0:	3718      	adds	r7, #24
3419d0c2:	46bd      	mov	sp, r7
3419d0c4:	bd80      	pop	{r7, pc}

3419d0c6 <IMX335_Delay>:
  * @param pObj   pointer to component object
  * @param Delay  specifies the delay time length, in milliseconds
  * @retval IMX335_OK
  */
static int32_t IMX335_Delay(IMX335_Object_t *pObj, uint32_t Delay)
{
3419d0c6:	b580      	push	{r7, lr}
3419d0c8:	b084      	sub	sp, #16
3419d0ca:	af00      	add	r7, sp, #0
3419d0cc:	6078      	str	r0, [r7, #4]
3419d0ce:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  tickstart = pObj->IO.GetTick();
3419d0d0:	687b      	ldr	r3, [r7, #4]
3419d0d2:	695b      	ldr	r3, [r3, #20]
3419d0d4:	4798      	blx	r3
3419d0d6:	4603      	mov	r3, r0
3419d0d8:	60fb      	str	r3, [r7, #12]
  while((pObj->IO.GetTick() - tickstart) < Delay)
3419d0da:	bf00      	nop
3419d0dc:	687b      	ldr	r3, [r7, #4]
3419d0de:	695b      	ldr	r3, [r3, #20]
3419d0e0:	4798      	blx	r3
3419d0e2:	4603      	mov	r3, r0
3419d0e4:	461a      	mov	r2, r3
3419d0e6:	68fb      	ldr	r3, [r7, #12]
3419d0e8:	1ad3      	subs	r3, r2, r3
3419d0ea:	683a      	ldr	r2, [r7, #0]
3419d0ec:	429a      	cmp	r2, r3
3419d0ee:	d8f5      	bhi.n	3419d0dc <IMX335_Delay+0x16>
  {
  }
  return IMX335_OK;
3419d0f0:	2300      	movs	r3, #0
}
3419d0f2:	4618      	mov	r0, r3
3419d0f4:	3710      	adds	r7, #16
3419d0f6:	46bd      	mov	sp, r7
3419d0f8:	bd80      	pop	{r7, pc}

3419d0fa <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3419d0fa:	b590      	push	{r4, r7, lr}
3419d0fc:	b087      	sub	sp, #28
3419d0fe:	af00      	add	r7, sp, #0
3419d100:	60f8      	str	r0, [r7, #12]
3419d102:	607a      	str	r2, [r7, #4]
3419d104:	461a      	mov	r2, r3
3419d106:	460b      	mov	r3, r1
3419d108:	817b      	strh	r3, [r7, #10]
3419d10a:	4613      	mov	r3, r2
3419d10c:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3419d10e:	68fb      	ldr	r3, [r7, #12]
3419d110:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
3419d112:	697b      	ldr	r3, [r7, #20]
3419d114:	691c      	ldr	r4, [r3, #16]
3419d116:	697b      	ldr	r3, [r7, #20]
3419d118:	8918      	ldrh	r0, [r3, #8]
3419d11a:	893b      	ldrh	r3, [r7, #8]
3419d11c:	8979      	ldrh	r1, [r7, #10]
3419d11e:	687a      	ldr	r2, [r7, #4]
3419d120:	47a0      	blx	r4
3419d122:	4603      	mov	r3, r0
}
3419d124:	4618      	mov	r0, r3
3419d126:	371c      	adds	r7, #28
3419d128:	46bd      	mov	sp, r7
3419d12a:	bd90      	pop	{r4, r7, pc}

3419d12c <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3419d12c:	b590      	push	{r4, r7, lr}
3419d12e:	b087      	sub	sp, #28
3419d130:	af00      	add	r7, sp, #0
3419d132:	60f8      	str	r0, [r7, #12]
3419d134:	607a      	str	r2, [r7, #4]
3419d136:	461a      	mov	r2, r3
3419d138:	460b      	mov	r3, r1
3419d13a:	817b      	strh	r3, [r7, #10]
3419d13c:	4613      	mov	r3, r2
3419d13e:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3419d140:	68fb      	ldr	r3, [r7, #12]
3419d142:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3419d144:	697b      	ldr	r3, [r7, #20]
3419d146:	68dc      	ldr	r4, [r3, #12]
3419d148:	697b      	ldr	r3, [r7, #20]
3419d14a:	8918      	ldrh	r0, [r3, #8]
3419d14c:	893b      	ldrh	r3, [r7, #8]
3419d14e:	8979      	ldrh	r1, [r7, #10]
3419d150:	687a      	ldr	r2, [r7, #4]
3419d152:	47a0      	blx	r4
3419d154:	4603      	mov	r3, r0
}
3419d156:	4618      	mov	r0, r3
3419d158:	371c      	adds	r7, #28
3419d15a:	46bd      	mov	sp, r7
3419d15c:	bd90      	pop	{r4, r7, pc}
	...

3419d160 <IMX335_RegisterBusIO>:
  * @brief  Register component IO bus
  * @param  Component object pointer
  * @retval Component status
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
3419d160:	b580      	push	{r7, lr}
3419d162:	b084      	sub	sp, #16
3419d164:	af00      	add	r7, sp, #0
3419d166:	6078      	str	r0, [r7, #4]
3419d168:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
3419d16a:	687b      	ldr	r3, [r7, #4]
3419d16c:	2b00      	cmp	r3, #0
3419d16e:	d103      	bne.n	3419d178 <IMX335_RegisterBusIO+0x18>
  {
    ret = IMX335_ERROR;
3419d170:	f04f 33ff 	mov.w	r3, #4294967295
3419d174:	60fb      	str	r3, [r7, #12]
3419d176:	e02c      	b.n	3419d1d2 <IMX335_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
3419d178:	683b      	ldr	r3, [r7, #0]
3419d17a:	681a      	ldr	r2, [r3, #0]
3419d17c:	687b      	ldr	r3, [r7, #4]
3419d17e:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
3419d180:	683b      	ldr	r3, [r7, #0]
3419d182:	685a      	ldr	r2, [r3, #4]
3419d184:	687b      	ldr	r3, [r7, #4]
3419d186:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
3419d188:	683b      	ldr	r3, [r7, #0]
3419d18a:	891a      	ldrh	r2, [r3, #8]
3419d18c:	687b      	ldr	r3, [r7, #4]
3419d18e:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
3419d190:	683b      	ldr	r3, [r7, #0]
3419d192:	68da      	ldr	r2, [r3, #12]
3419d194:	687b      	ldr	r3, [r7, #4]
3419d196:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
3419d198:	683b      	ldr	r3, [r7, #0]
3419d19a:	691a      	ldr	r2, [r3, #16]
3419d19c:	687b      	ldr	r3, [r7, #4]
3419d19e:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
3419d1a0:	683b      	ldr	r3, [r7, #0]
3419d1a2:	695a      	ldr	r2, [r3, #20]
3419d1a4:	687b      	ldr	r3, [r7, #4]
3419d1a6:	615a      	str	r2, [r3, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
3419d1a8:	687b      	ldr	r3, [r7, #4]
3419d1aa:	4a0c      	ldr	r2, [pc, #48]	@ (3419d1dc <IMX335_RegisterBusIO+0x7c>)
3419d1ac:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
3419d1ae:	687b      	ldr	r3, [r7, #4]
3419d1b0:	4a0b      	ldr	r2, [pc, #44]	@ (3419d1e0 <IMX335_RegisterBusIO+0x80>)
3419d1b2:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
3419d1b4:	687b      	ldr	r3, [r7, #4]
3419d1b6:	687a      	ldr	r2, [r7, #4]
3419d1b8:	621a      	str	r2, [r3, #32]

    if(pObj->IO.Init != NULL)
3419d1ba:	687b      	ldr	r3, [r7, #4]
3419d1bc:	681b      	ldr	r3, [r3, #0]
3419d1be:	2b00      	cmp	r3, #0
3419d1c0:	d004      	beq.n	3419d1cc <IMX335_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
3419d1c2:	687b      	ldr	r3, [r7, #4]
3419d1c4:	681b      	ldr	r3, [r3, #0]
3419d1c6:	4798      	blx	r3
3419d1c8:	60f8      	str	r0, [r7, #12]
3419d1ca:	e002      	b.n	3419d1d2 <IMX335_RegisterBusIO+0x72>
    }
    else
    {
      ret = IMX335_ERROR;
3419d1cc:	f04f 33ff 	mov.w	r3, #4294967295
3419d1d0:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
3419d1d2:	68fb      	ldr	r3, [r7, #12]
}
3419d1d4:	4618      	mov	r0, r3
3419d1d6:	3710      	adds	r7, #16
3419d1d8:	46bd      	mov	sp, r7
3419d1da:	bd80      	pop	{r7, pc}
3419d1dc:	3419d0fb 	.word	0x3419d0fb
3419d1e0:	3419d12d 	.word	0x3419d12d

3419d1e4 <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
3419d1e4:	b580      	push	{r7, lr}
3419d1e6:	b086      	sub	sp, #24
3419d1e8:	af00      	add	r7, sp, #0
3419d1ea:	60f8      	str	r0, [r7, #12]
3419d1ec:	60b9      	str	r1, [r7, #8]
3419d1ee:	607a      	str	r2, [r7, #4]
  int32_t ret = IMX335_OK;
3419d1f0:	2300      	movs	r3, #0
3419d1f2:	617b      	str	r3, [r7, #20]

  if(pObj->IsInitialized == 0U)
3419d1f4:	68fb      	ldr	r3, [r7, #12]
3419d1f6:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3419d1fa:	2b00      	cmp	r3, #0
3419d1fc:	d126      	bne.n	3419d24c <IMX335_Init+0x68>
  {
    switch (Resolution)
3419d1fe:	68bb      	ldr	r3, [r7, #8]
3419d200:	2b06      	cmp	r3, #6
3419d202:	d10b      	bne.n	3419d21c <IMX335_Init+0x38>
    {
      case IMX335_R2592_1944:
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
3419d204:	2254      	movs	r2, #84	@ 0x54
3419d206:	4914      	ldr	r1, [pc, #80]	@ (3419d258 <IMX335_Init+0x74>)
3419d208:	68f8      	ldr	r0, [r7, #12]
3419d20a:	f7ff ff2b 	bl	3419d064 <IMX335_WriteTable>
3419d20e:	4603      	mov	r3, r0
3419d210:	2b00      	cmp	r3, #0
3419d212:	d007      	beq.n	3419d224 <IMX335_Init+0x40>
        {
          ret = IMX335_ERROR;
3419d214:	f04f 33ff 	mov.w	r3, #4294967295
3419d218:	617b      	str	r3, [r7, #20]
        }
        break;
3419d21a:	e003      	b.n	3419d224 <IMX335_Init+0x40>
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
3419d21c:	f04f 33ff 	mov.w	r3, #4294967295
3419d220:	617b      	str	r3, [r7, #20]
3419d222:	e000      	b.n	3419d226 <IMX335_Init+0x42>
        break;
3419d224:	bf00      	nop
    }

    if(!ret)
3419d226:	697b      	ldr	r3, [r7, #20]
3419d228:	2b00      	cmp	r3, #0
3419d22a:	d10f      	bne.n	3419d24c <IMX335_Init+0x68>
    {
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
3419d22c:	2205      	movs	r2, #5
3419d22e:	490b      	ldr	r1, [pc, #44]	@ (3419d25c <IMX335_Init+0x78>)
3419d230:	68f8      	ldr	r0, [r7, #12]
3419d232:	f7ff ff17 	bl	3419d064 <IMX335_WriteTable>
3419d236:	4603      	mov	r3, r0
3419d238:	2b00      	cmp	r3, #0
3419d23a:	d003      	beq.n	3419d244 <IMX335_Init+0x60>
      {
        ret = IMX335_ERROR;
3419d23c:	f04f 33ff 	mov.w	r3, #4294967295
3419d240:	617b      	str	r3, [r7, #20]
3419d242:	e003      	b.n	3419d24c <IMX335_Init+0x68>
      }
      else
      {
        pObj->IsInitialized = 1U;
3419d244:	68fb      	ldr	r3, [r7, #12]
3419d246:	2201      	movs	r2, #1
3419d248:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
      }
    }
  }

  return ret;
3419d24c:	697b      	ldr	r3, [r7, #20]
}
3419d24e:	4618      	mov	r0, r3
3419d250:	3718      	adds	r7, #24
3419d252:	46bd      	mov	sp, r7
3419d254:	bd80      	pop	{r7, pc}
3419d256:	bf00      	nop
3419d258:	341b14d8 	.word	0x341b14d8
3419d25c:	341b1628 	.word	0x341b1628

3419d260 <IMX335_Start>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
3419d260:	b580      	push	{r7, lr}
3419d262:	b084      	sub	sp, #16
3419d264:	af00      	add	r7, sp, #0
3419d266:	6078      	str	r0, [r7, #4]
  uint8_t tmp;
  int32_t ret = IMX335_OK;
3419d268:	2300      	movs	r3, #0
3419d26a:	60fb      	str	r3, [r7, #12]
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
3419d26c:	2300      	movs	r3, #0
3419d26e:	72fb      	strb	r3, [r7, #11]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
3419d270:	687b      	ldr	r3, [r7, #4]
3419d272:	f103 0018 	add.w	r0, r3, #24
3419d276:	f107 020b 	add.w	r2, r7, #11
3419d27a:	2301      	movs	r3, #1
3419d27c:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
3419d280:	f000 fa8f 	bl	3419d7a2 <imx335_write_reg>
3419d284:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419d286:	68fb      	ldr	r3, [r7, #12]
3419d288:	2b00      	cmp	r3, #0
3419d28a:	d002      	beq.n	3419d292 <IMX335_Start+0x32>
  {
    return IMX335_ERROR;
3419d28c:	f04f 33ff 	mov.w	r3, #4294967295
3419d290:	e004      	b.n	3419d29c <IMX335_Start+0x3c>
  }
  IMX335_Delay(pObj, 20);
3419d292:	2114      	movs	r1, #20
3419d294:	6878      	ldr	r0, [r7, #4]
3419d296:	f7ff ff16 	bl	3419d0c6 <IMX335_Delay>
  return ret;
3419d29a:	68fb      	ldr	r3, [r7, #12]
}
3419d29c:	4618      	mov	r0, r3
3419d29e:	3710      	adds	r7, #16
3419d2a0:	46bd      	mov	sp, r7
3419d2a2:	bd80      	pop	{r7, pc}

3419d2a4 <IMX335_DeInit>:
  * @brief  De-initializes the camera sensor.
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
3419d2a4:	b480      	push	{r7}
3419d2a6:	b083      	sub	sp, #12
3419d2a8:	af00      	add	r7, sp, #0
3419d2aa:	6078      	str	r0, [r7, #4]
  if(pObj->IsInitialized == 1U)
3419d2ac:	687b      	ldr	r3, [r7, #4]
3419d2ae:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3419d2b2:	2b01      	cmp	r3, #1
3419d2b4:	d103      	bne.n	3419d2be <IMX335_DeInit+0x1a>
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
3419d2b6:	687b      	ldr	r3, [r7, #4]
3419d2b8:	2200      	movs	r2, #0
3419d2ba:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  }

  return IMX335_OK;
3419d2be:	2300      	movs	r3, #0
}
3419d2c0:	4618      	mov	r0, r3
3419d2c2:	370c      	adds	r7, #12
3419d2c4:	46bd      	mov	sp, r7
3419d2c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d2ca:	4770      	bx	lr

3419d2cc <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
3419d2cc:	b580      	push	{r7, lr}
3419d2ce:	b084      	sub	sp, #16
3419d2d0:	af00      	add	r7, sp, #0
3419d2d2:	6078      	str	r0, [r7, #4]
3419d2d4:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
3419d2d6:	687b      	ldr	r3, [r7, #4]
3419d2d8:	681b      	ldr	r3, [r3, #0]
3419d2da:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
3419d2dc:	687b      	ldr	r3, [r7, #4]
3419d2de:	f103 0018 	add.w	r0, r3, #24
3419d2e2:	f107 020b 	add.w	r2, r7, #11
3419d2e6:	2301      	movs	r3, #1
3419d2e8:	f643 1112 	movw	r1, #14610	@ 0x3912
3419d2ec:	f000 fa42 	bl	3419d774 <imx335_read_reg>
3419d2f0:	4603      	mov	r3, r0
3419d2f2:	2b00      	cmp	r3, #0
3419d2f4:	d003      	beq.n	3419d2fe <IMX335_ReadID+0x32>
  {
    ret = IMX335_ERROR;
3419d2f6:	f04f 33ff 	mov.w	r3, #4294967295
3419d2fa:	60fb      	str	r3, [r7, #12]
3419d2fc:	e005      	b.n	3419d30a <IMX335_ReadID+0x3e>
  }
  else
  {
    *Id = tmp;
3419d2fe:	7afb      	ldrb	r3, [r7, #11]
3419d300:	461a      	mov	r2, r3
3419d302:	683b      	ldr	r3, [r7, #0]
3419d304:	601a      	str	r2, [r3, #0]
    ret = IMX335_OK;
3419d306:	2300      	movs	r3, #0
3419d308:	60fb      	str	r3, [r7, #12]
  }

  /* Component status */
  return ret;
3419d30a:	68fb      	ldr	r3, [r7, #12]
}
3419d30c:	4618      	mov	r0, r3
3419d30e:	3710      	adds	r7, #16
3419d310:	46bd      	mov	sp, r7
3419d312:	bd80      	pop	{r7, pc}

3419d314 <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
3419d314:	b580      	push	{r7, lr}
3419d316:	b084      	sub	sp, #16
3419d318:	af00      	add	r7, sp, #0
3419d31a:	6078      	str	r0, [r7, #4]
3419d31c:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419d31e:	2300      	movs	r3, #0
3419d320:	60fb      	str	r3, [r7, #12]
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
3419d322:	683b      	ldr	r3, [r7, #0]
3419d324:	4a25      	ldr	r2, [pc, #148]	@ (3419d3bc <IMX335_SetGain+0xa8>)
3419d326:	4293      	cmp	r3, r2
3419d328:	dc02      	bgt.n	3419d330 <IMX335_SetGain+0x1c>
3419d32a:	683b      	ldr	r3, [r7, #0]
3419d32c:	2b00      	cmp	r3, #0
3419d32e:	da03      	bge.n	3419d338 <IMX335_SetGain+0x24>
  {
    ret = IMX335_ERROR;
3419d330:	f04f 33ff 	mov.w	r3, #4294967295
3419d334:	60fb      	str	r3, [r7, #12]
3419d336:	e03c      	b.n	3419d3b2 <IMX335_SetGain+0x9e>
  }
  else
  {
    /* Convert to IMX335 gain unit (0.3 dB = 300 mdB) */
    gain /= IMX335_GAIN_UNIT_MDB;
3419d338:	683b      	ldr	r3, [r7, #0]
3419d33a:	4a21      	ldr	r2, [pc, #132]	@ (3419d3c0 <IMX335_SetGain+0xac>)
3419d33c:	fb82 1203 	smull	r1, r2, r2, r3
3419d340:	1152      	asrs	r2, r2, #5
3419d342:	17db      	asrs	r3, r3, #31
3419d344:	1ad3      	subs	r3, r2, r3
3419d346:	603b      	str	r3, [r7, #0]

    hold = 1;
3419d348:	2301      	movs	r3, #1
3419d34a:	72fb      	strb	r3, [r7, #11]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419d34c:	687b      	ldr	r3, [r7, #4]
3419d34e:	f103 0018 	add.w	r0, r3, #24
3419d352:	f107 020b 	add.w	r2, r7, #11
3419d356:	2301      	movs	r3, #1
3419d358:	f243 0101 	movw	r1, #12289	@ 0x3001
3419d35c:	f000 fa21 	bl	3419d7a2 <imx335_write_reg>
3419d360:	4603      	mov	r3, r0
3419d362:	2b00      	cmp	r3, #0
3419d364:	d003      	beq.n	3419d36e <IMX335_SetGain+0x5a>
    {
      ret = IMX335_ERROR;
3419d366:	f04f 33ff 	mov.w	r3, #4294967295
3419d36a:	60fb      	str	r3, [r7, #12]
3419d36c:	e021      	b.n	3419d3b2 <IMX335_SetGain+0x9e>
    }
    else
    {
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
3419d36e:	687b      	ldr	r3, [r7, #4]
3419d370:	f103 0018 	add.w	r0, r3, #24
3419d374:	463a      	mov	r2, r7
3419d376:	2302      	movs	r3, #2
3419d378:	f243 01e8 	movw	r1, #12520	@ 0x30e8
3419d37c:	f000 fa11 	bl	3419d7a2 <imx335_write_reg>
3419d380:	4603      	mov	r3, r0
3419d382:	2b00      	cmp	r3, #0
3419d384:	d003      	beq.n	3419d38e <IMX335_SetGain+0x7a>
      {
        ret = IMX335_ERROR;
3419d386:	f04f 33ff 	mov.w	r3, #4294967295
3419d38a:	60fb      	str	r3, [r7, #12]
3419d38c:	e011      	b.n	3419d3b2 <IMX335_SetGain+0x9e>
      }
      else
      {
        hold = 0;
3419d38e:	2300      	movs	r3, #0
3419d390:	72fb      	strb	r3, [r7, #11]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419d392:	687b      	ldr	r3, [r7, #4]
3419d394:	f103 0018 	add.w	r0, r3, #24
3419d398:	f107 020b 	add.w	r2, r7, #11
3419d39c:	2301      	movs	r3, #1
3419d39e:	f243 0101 	movw	r1, #12289	@ 0x3001
3419d3a2:	f000 f9fe 	bl	3419d7a2 <imx335_write_reg>
3419d3a6:	4603      	mov	r3, r0
3419d3a8:	2b00      	cmp	r3, #0
3419d3aa:	d002      	beq.n	3419d3b2 <IMX335_SetGain+0x9e>
        {
          ret = IMX335_ERROR;
3419d3ac:	f04f 33ff 	mov.w	r3, #4294967295
3419d3b0:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

return ret;
3419d3b2:	68fb      	ldr	r3, [r7, #12]
}
3419d3b4:	4618      	mov	r0, r3
3419d3b6:	3710      	adds	r7, #16
3419d3b8:	46bd      	mov	sp, r7
3419d3ba:	bd80      	pop	{r7, pc}
3419d3bc:	00011940 	.word	0x00011940
3419d3c0:	1b4e81b5 	.word	0x1b4e81b5

3419d3c4 <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
3419d3c4:	b580      	push	{r7, lr}
3419d3c6:	b086      	sub	sp, #24
3419d3c8:	af00      	add	r7, sp, #0
3419d3ca:	6078      	str	r0, [r7, #4]
3419d3cc:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419d3ce:	2300      	movs	r3, #0
3419d3d0:	617b      	str	r3, [r7, #20]
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
3419d3d2:	687b      	ldr	r3, [r7, #4]
3419d3d4:	f103 0018 	add.w	r0, r3, #24
3419d3d8:	f107 0210 	add.w	r2, r7, #16
3419d3dc:	2304      	movs	r3, #4
3419d3de:	f243 0130 	movw	r1, #12336	@ 0x3030
3419d3e2:	f000 f9c7 	bl	3419d774 <imx335_read_reg>
3419d3e6:	4603      	mov	r3, r0
3419d3e8:	2b00      	cmp	r3, #0
3419d3ea:	d003      	beq.n	3419d3f4 <IMX335_SetExposure+0x30>
  {
    ret = IMX335_ERROR;
3419d3ec:	f04f 33ff 	mov.w	r3, #4294967295
3419d3f0:	617b      	str	r3, [r7, #20]
3419d3f2:	e051      	b.n	3419d498 <IMX335_SetExposure+0xd4>
  }
  else
  {
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
3419d3f4:	693b      	ldr	r3, [r7, #16]
3419d3f6:	ee07 3a90 	vmov	s15, r3
3419d3fa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419d3fe:	683b      	ldr	r3, [r7, #0]
3419d400:	ee07 3a90 	vmov	s15, r3
3419d404:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419d408:	ed9f 6a26 	vldr	s12, [pc, #152]	@ 3419d4a4 <IMX335_SetExposure+0xe0>
3419d40c:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419d410:	ee77 7a67 	vsub.f32	s15, s14, s15
3419d414:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419d418:	ee17 3a90 	vmov	r3, s15
3419d41c:	60fb      	str	r3, [r7, #12]

    if (shutter < IMX335_SHUTTER_MIN)
3419d41e:	68fb      	ldr	r3, [r7, #12]
3419d420:	2b08      	cmp	r3, #8
3419d422:	d803      	bhi.n	3419d42c <IMX335_SetExposure+0x68>
    {
      ret = IMX335_ERROR;
3419d424:	f04f 33ff 	mov.w	r3, #4294967295
3419d428:	617b      	str	r3, [r7, #20]
3419d42a:	e035      	b.n	3419d498 <IMX335_SetExposure+0xd4>
    }
    else
    {
      hold = 1;
3419d42c:	2301      	movs	r3, #1
3419d42e:	72fb      	strb	r3, [r7, #11]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419d430:	687b      	ldr	r3, [r7, #4]
3419d432:	f103 0018 	add.w	r0, r3, #24
3419d436:	f107 020b 	add.w	r2, r7, #11
3419d43a:	2301      	movs	r3, #1
3419d43c:	f243 0101 	movw	r1, #12289	@ 0x3001
3419d440:	f000 f9af 	bl	3419d7a2 <imx335_write_reg>
3419d444:	4603      	mov	r3, r0
3419d446:	2b00      	cmp	r3, #0
3419d448:	d003      	beq.n	3419d452 <IMX335_SetExposure+0x8e>
      {
        ret = IMX335_ERROR;
3419d44a:	f04f 33ff 	mov.w	r3, #4294967295
3419d44e:	617b      	str	r3, [r7, #20]
3419d450:	e022      	b.n	3419d498 <IMX335_SetExposure+0xd4>
      }
      else
      {
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
3419d452:	687b      	ldr	r3, [r7, #4]
3419d454:	f103 0018 	add.w	r0, r3, #24
3419d458:	f107 020c 	add.w	r2, r7, #12
3419d45c:	2303      	movs	r3, #3
3419d45e:	f243 0158 	movw	r1, #12376	@ 0x3058
3419d462:	f000 f99e 	bl	3419d7a2 <imx335_write_reg>
3419d466:	4603      	mov	r3, r0
3419d468:	2b00      	cmp	r3, #0
3419d46a:	d003      	beq.n	3419d474 <IMX335_SetExposure+0xb0>
        {
          ret = IMX335_ERROR;
3419d46c:	f04f 33ff 	mov.w	r3, #4294967295
3419d470:	617b      	str	r3, [r7, #20]
3419d472:	e011      	b.n	3419d498 <IMX335_SetExposure+0xd4>
        }
        else
        {
          hold = 0;
3419d474:	2300      	movs	r3, #0
3419d476:	72fb      	strb	r3, [r7, #11]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419d478:	687b      	ldr	r3, [r7, #4]
3419d47a:	f103 0018 	add.w	r0, r3, #24
3419d47e:	f107 020b 	add.w	r2, r7, #11
3419d482:	2301      	movs	r3, #1
3419d484:	f243 0101 	movw	r1, #12289	@ 0x3001
3419d488:	f000 f98b 	bl	3419d7a2 <imx335_write_reg>
3419d48c:	4603      	mov	r3, r0
3419d48e:	2b00      	cmp	r3, #0
3419d490:	d002      	beq.n	3419d498 <IMX335_SetExposure+0xd4>
          {
            ret = IMX335_ERROR;
3419d492:	f04f 33ff 	mov.w	r3, #4294967295
3419d496:	617b      	str	r3, [r7, #20]
        }
      }
    }
  }

  return ret;
3419d498:	697b      	ldr	r3, [r7, #20]
}
3419d49a:	4618      	mov	r0, r3
3419d49c:	3718      	adds	r7, #24
3419d49e:	46bd      	mov	sp, r7
3419d4a0:	bd80      	pop	{r7, pc}
3419d4a2:	bf00      	nop
3419d4a4:	40ed097c 	.word	0x40ed097c

3419d4a8 <IMX335_SetFrequency>:
  * @param  pObj  pointer to component object
  * @param  frequency in Mhz
  * @retval Component status
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
3419d4a8:	b580      	push	{r7, lr}
3419d4aa:	b084      	sub	sp, #16
3419d4ac:	af00      	add	r7, sp, #0
3419d4ae:	6078      	str	r0, [r7, #4]
3419d4b0:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3419d4b2:	2300      	movs	r3, #0
3419d4b4:	60fb      	str	r3, [r7, #12]

  switch (frequency)
3419d4b6:	683b      	ldr	r3, [r7, #0]
3419d4b8:	3b01      	subs	r3, #1
3419d4ba:	2b03      	cmp	r3, #3
3419d4bc:	d83a      	bhi.n	3419d534 <IMX335_SetFrequency+0x8c>
3419d4be:	a201      	add	r2, pc, #4	@ (adr r2, 3419d4c4 <IMX335_SetFrequency+0x1c>)
3419d4c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419d4c4:	3419d51d 	.word	0x3419d51d
3419d4c8:	3419d505 	.word	0x3419d505
3419d4cc:	3419d4ed 	.word	0x3419d4ed
3419d4d0:	3419d4d5 	.word	0x3419d4d5
  {
    case IMX335_INCK_74MHZ:
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
3419d4d4:	2207      	movs	r2, #7
3419d4d6:	4924      	ldr	r1, [pc, #144]	@ (3419d568 <IMX335_SetFrequency+0xc0>)
3419d4d8:	6878      	ldr	r0, [r7, #4]
3419d4da:	f7ff fdc3 	bl	3419d064 <IMX335_WriteTable>
3419d4de:	4603      	mov	r3, r0
3419d4e0:	2b00      	cmp	r3, #0
3419d4e2:	d033      	beq.n	3419d54c <IMX335_SetFrequency+0xa4>
      {
        ret = IMX335_ERROR;
3419d4e4:	f04f 33ff 	mov.w	r3, #4294967295
3419d4e8:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d4ea:	e02f      	b.n	3419d54c <IMX335_SetFrequency+0xa4>
    case IMX335_INCK_27MHZ:
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
3419d4ec:	2207      	movs	r2, #7
3419d4ee:	491f      	ldr	r1, [pc, #124]	@ (3419d56c <IMX335_SetFrequency+0xc4>)
3419d4f0:	6878      	ldr	r0, [r7, #4]
3419d4f2:	f7ff fdb7 	bl	3419d064 <IMX335_WriteTable>
3419d4f6:	4603      	mov	r3, r0
3419d4f8:	2b00      	cmp	r3, #0
3419d4fa:	d029      	beq.n	3419d550 <IMX335_SetFrequency+0xa8>
      {
        ret = IMX335_ERROR;
3419d4fc:	f04f 33ff 	mov.w	r3, #4294967295
3419d500:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d502:	e025      	b.n	3419d550 <IMX335_SetFrequency+0xa8>
    case IMX335_INCK_24MHZ:
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
3419d504:	2207      	movs	r2, #7
3419d506:	491a      	ldr	r1, [pc, #104]	@ (3419d570 <IMX335_SetFrequency+0xc8>)
3419d508:	6878      	ldr	r0, [r7, #4]
3419d50a:	f7ff fdab 	bl	3419d064 <IMX335_WriteTable>
3419d50e:	4603      	mov	r3, r0
3419d510:	2b00      	cmp	r3, #0
3419d512:	d01f      	beq.n	3419d554 <IMX335_SetFrequency+0xac>
      {
        ret = IMX335_ERROR;
3419d514:	f04f 33ff 	mov.w	r3, #4294967295
3419d518:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d51a:	e01b      	b.n	3419d554 <IMX335_SetFrequency+0xac>
    case IMX335_INCK_18MHZ:
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
3419d51c:	2207      	movs	r2, #7
3419d51e:	4915      	ldr	r1, [pc, #84]	@ (3419d574 <IMX335_SetFrequency+0xcc>)
3419d520:	6878      	ldr	r0, [r7, #4]
3419d522:	f7ff fd9f 	bl	3419d064 <IMX335_WriteTable>
3419d526:	4603      	mov	r3, r0
3419d528:	2b00      	cmp	r3, #0
3419d52a:	d015      	beq.n	3419d558 <IMX335_SetFrequency+0xb0>
      {
        ret = IMX335_ERROR;
3419d52c:	f04f 33ff 	mov.w	r3, #4294967295
3419d530:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d532:	e011      	b.n	3419d558 <IMX335_SetFrequency+0xb0>
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3419d534:	2207      	movs	r2, #7
3419d536:	4910      	ldr	r1, [pc, #64]	@ (3419d578 <IMX335_SetFrequency+0xd0>)
3419d538:	6878      	ldr	r0, [r7, #4]
3419d53a:	f7ff fd93 	bl	3419d064 <IMX335_WriteTable>
3419d53e:	4603      	mov	r3, r0
3419d540:	2b00      	cmp	r3, #0
3419d542:	d00b      	beq.n	3419d55c <IMX335_SetFrequency+0xb4>
      {
        ret = IMX335_ERROR;
3419d544:	f04f 33ff 	mov.w	r3, #4294967295
3419d548:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d54a:	e007      	b.n	3419d55c <IMX335_SetFrequency+0xb4>
      break;
3419d54c:	bf00      	nop
3419d54e:	e006      	b.n	3419d55e <IMX335_SetFrequency+0xb6>
      break;
3419d550:	bf00      	nop
3419d552:	e004      	b.n	3419d55e <IMX335_SetFrequency+0xb6>
      break;
3419d554:	bf00      	nop
3419d556:	e002      	b.n	3419d55e <IMX335_SetFrequency+0xb6>
      break;
3419d558:	bf00      	nop
3419d55a:	e000      	b.n	3419d55e <IMX335_SetFrequency+0xb6>
      break;
3419d55c:	bf00      	nop
  };

  return ret;
3419d55e:	68fb      	ldr	r3, [r7, #12]
}
3419d560:	4618      	mov	r0, r3
3419d562:	3710      	adds	r7, #16
3419d564:	46bd      	mov	sp, r7
3419d566:	bd80      	pop	{r7, pc}
3419d568:	341b163c 	.word	0x341b163c
3419d56c:	341b1658 	.word	0x341b1658
3419d570:	341b1674 	.word	0x341b1674
3419d574:	341b1690 	.word	0x341b1690
3419d578:	341b16ac 	.word	0x341b16ac

3419d57c <IMX335_SetFramerate>:
  * @param  pObj  pointer to component object
  * @param  framerate 10, 15, 20, 25 or 30fps
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
3419d57c:	b580      	push	{r7, lr}
3419d57e:	b084      	sub	sp, #16
3419d580:	af00      	add	r7, sp, #0
3419d582:	6078      	str	r0, [r7, #4]
3419d584:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3419d586:	2300      	movs	r3, #0
3419d588:	60fb      	str	r3, [r7, #12]
  switch (framerate)
3419d58a:	683b      	ldr	r3, [r7, #0]
3419d58c:	3b0a      	subs	r3, #10
3419d58e:	2b0f      	cmp	r3, #15
3419d590:	d852      	bhi.n	3419d638 <IMX335_SetFramerate+0xbc>
3419d592:	a201      	add	r2, pc, #4	@ (adr r2, 3419d598 <IMX335_SetFramerate+0x1c>)
3419d594:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419d598:	3419d5d9 	.word	0x3419d5d9
3419d59c:	3419d639 	.word	0x3419d639
3419d5a0:	3419d639 	.word	0x3419d639
3419d5a4:	3419d639 	.word	0x3419d639
3419d5a8:	3419d639 	.word	0x3419d639
3419d5ac:	3419d5f1 	.word	0x3419d5f1
3419d5b0:	3419d639 	.word	0x3419d639
3419d5b4:	3419d639 	.word	0x3419d639
3419d5b8:	3419d639 	.word	0x3419d639
3419d5bc:	3419d639 	.word	0x3419d639
3419d5c0:	3419d609 	.word	0x3419d609
3419d5c4:	3419d639 	.word	0x3419d639
3419d5c8:	3419d639 	.word	0x3419d639
3419d5cc:	3419d639 	.word	0x3419d639
3419d5d0:	3419d639 	.word	0x3419d639
3419d5d4:	3419d621 	.word	0x3419d621
  {
    case 10:
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
3419d5d8:	2202      	movs	r2, #2
3419d5da:	4924      	ldr	r1, [pc, #144]	@ (3419d66c <IMX335_SetFramerate+0xf0>)
3419d5dc:	6878      	ldr	r0, [r7, #4]
3419d5de:	f7ff fd41 	bl	3419d064 <IMX335_WriteTable>
3419d5e2:	4603      	mov	r3, r0
3419d5e4:	2b00      	cmp	r3, #0
3419d5e6:	d033      	beq.n	3419d650 <IMX335_SetFramerate+0xd4>
      {
        ret = IMX335_ERROR;
3419d5e8:	f04f 33ff 	mov.w	r3, #4294967295
3419d5ec:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d5ee:	e02f      	b.n	3419d650 <IMX335_SetFramerate+0xd4>
    case 15:
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
3419d5f0:	2202      	movs	r2, #2
3419d5f2:	491f      	ldr	r1, [pc, #124]	@ (3419d670 <IMX335_SetFramerate+0xf4>)
3419d5f4:	6878      	ldr	r0, [r7, #4]
3419d5f6:	f7ff fd35 	bl	3419d064 <IMX335_WriteTable>
3419d5fa:	4603      	mov	r3, r0
3419d5fc:	2b00      	cmp	r3, #0
3419d5fe:	d029      	beq.n	3419d654 <IMX335_SetFramerate+0xd8>
      {
        ret = IMX335_ERROR;
3419d600:	f04f 33ff 	mov.w	r3, #4294967295
3419d604:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d606:	e025      	b.n	3419d654 <IMX335_SetFramerate+0xd8>
    case 20:
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
3419d608:	2202      	movs	r2, #2
3419d60a:	491a      	ldr	r1, [pc, #104]	@ (3419d674 <IMX335_SetFramerate+0xf8>)
3419d60c:	6878      	ldr	r0, [r7, #4]
3419d60e:	f7ff fd29 	bl	3419d064 <IMX335_WriteTable>
3419d612:	4603      	mov	r3, r0
3419d614:	2b00      	cmp	r3, #0
3419d616:	d01f      	beq.n	3419d658 <IMX335_SetFramerate+0xdc>
      {
       ret = IMX335_ERROR;
3419d618:	f04f 33ff 	mov.w	r3, #4294967295
3419d61c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d61e:	e01b      	b.n	3419d658 <IMX335_SetFramerate+0xdc>
    case 25:
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
3419d620:	2202      	movs	r2, #2
3419d622:	4915      	ldr	r1, [pc, #84]	@ (3419d678 <IMX335_SetFramerate+0xfc>)
3419d624:	6878      	ldr	r0, [r7, #4]
3419d626:	f7ff fd1d 	bl	3419d064 <IMX335_WriteTable>
3419d62a:	4603      	mov	r3, r0
3419d62c:	2b00      	cmp	r3, #0
3419d62e:	d015      	beq.n	3419d65c <IMX335_SetFramerate+0xe0>
      {
        ret = IMX335_ERROR;
3419d630:	f04f 33ff 	mov.w	r3, #4294967295
3419d634:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d636:	e011      	b.n	3419d65c <IMX335_SetFramerate+0xe0>
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
3419d638:	2202      	movs	r2, #2
3419d63a:	4910      	ldr	r1, [pc, #64]	@ (3419d67c <IMX335_SetFramerate+0x100>)
3419d63c:	6878      	ldr	r0, [r7, #4]
3419d63e:	f7ff fd11 	bl	3419d064 <IMX335_WriteTable>
3419d642:	4603      	mov	r3, r0
3419d644:	2b00      	cmp	r3, #0
3419d646:	d00b      	beq.n	3419d660 <IMX335_SetFramerate+0xe4>
      {
        ret = IMX335_ERROR;
3419d648:	f04f 33ff 	mov.w	r3, #4294967295
3419d64c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419d64e:	e007      	b.n	3419d660 <IMX335_SetFramerate+0xe4>
      break;
3419d650:	bf00      	nop
3419d652:	e006      	b.n	3419d662 <IMX335_SetFramerate+0xe6>
      break;
3419d654:	bf00      	nop
3419d656:	e004      	b.n	3419d662 <IMX335_SetFramerate+0xe6>
      break;
3419d658:	bf00      	nop
3419d65a:	e002      	b.n	3419d662 <IMX335_SetFramerate+0xe6>
      break;
3419d65c:	bf00      	nop
3419d65e:	e000      	b.n	3419d662 <IMX335_SetFramerate+0xe6>
      break;
3419d660:	bf00      	nop
  };

  return ret;
3419d662:	68fb      	ldr	r3, [r7, #12]
}
3419d664:	4618      	mov	r0, r3
3419d666:	3710      	adds	r7, #16
3419d668:	46bd      	mov	sp, r7
3419d66a:	bd80      	pop	{r7, pc}
3419d66c:	341b16c8 	.word	0x341b16c8
3419d670:	341b16d0 	.word	0x341b16d0
3419d674:	341b16d8 	.word	0x341b16d8
3419d678:	341b16e0 	.word	0x341b16e0
3419d67c:	341b16e8 	.word	0x341b16e8

3419d680 <IMX335_MirrorFlipConfig>:
  * @param  pObj  pointer to component object
  * @param  Config To configure mirror, flip, both or none
  * @retval Component status
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
3419d680:	b580      	push	{r7, lr}
3419d682:	b084      	sub	sp, #16
3419d684:	af00      	add	r7, sp, #0
3419d686:	6078      	str	r0, [r7, #4]
3419d688:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419d68a:	2300      	movs	r3, #0
3419d68c:	60fb      	str	r3, [r7, #12]

  switch (Config)
3419d68e:	683b      	ldr	r3, [r7, #0]
3419d690:	2b03      	cmp	r3, #3
3419d692:	d017      	beq.n	3419d6c4 <IMX335_MirrorFlipConfig+0x44>
3419d694:	683b      	ldr	r3, [r7, #0]
3419d696:	2b03      	cmp	r3, #3
3419d698:	d81b      	bhi.n	3419d6d2 <IMX335_MirrorFlipConfig+0x52>
3419d69a:	683b      	ldr	r3, [r7, #0]
3419d69c:	2b01      	cmp	r3, #1
3419d69e:	d003      	beq.n	3419d6a8 <IMX335_MirrorFlipConfig+0x28>
3419d6a0:	683b      	ldr	r3, [r7, #0]
3419d6a2:	2b02      	cmp	r3, #2
3419d6a4:	d007      	beq.n	3419d6b6 <IMX335_MirrorFlipConfig+0x36>
3419d6a6:	e014      	b.n	3419d6d2 <IMX335_MirrorFlipConfig+0x52>
  {
    case IMX335_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
3419d6a8:	220a      	movs	r2, #10
3419d6aa:	4910      	ldr	r1, [pc, #64]	@ (3419d6ec <IMX335_MirrorFlipConfig+0x6c>)
3419d6ac:	6878      	ldr	r0, [r7, #4]
3419d6ae:	f7ff fcd9 	bl	3419d064 <IMX335_WriteTable>
3419d6b2:	60f8      	str	r0, [r7, #12]
      break;
3419d6b4:	e014      	b.n	3419d6e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
3419d6b6:	220a      	movs	r2, #10
3419d6b8:	490d      	ldr	r1, [pc, #52]	@ (3419d6f0 <IMX335_MirrorFlipConfig+0x70>)
3419d6ba:	6878      	ldr	r0, [r7, #4]
3419d6bc:	f7ff fcd2 	bl	3419d064 <IMX335_WriteTable>
3419d6c0:	60f8      	str	r0, [r7, #12]
      break;
3419d6c2:	e00d      	b.n	3419d6e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
3419d6c4:	220a      	movs	r2, #10
3419d6c6:	490b      	ldr	r1, [pc, #44]	@ (3419d6f4 <IMX335_MirrorFlipConfig+0x74>)
3419d6c8:	6878      	ldr	r0, [r7, #4]
3419d6ca:	f7ff fccb 	bl	3419d064 <IMX335_WriteTable>
3419d6ce:	60f8      	str	r0, [r7, #12]
      break;
3419d6d0:	e006      	b.n	3419d6e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3419d6d2:	220a      	movs	r2, #10
3419d6d4:	4908      	ldr	r1, [pc, #32]	@ (3419d6f8 <IMX335_MirrorFlipConfig+0x78>)
3419d6d6:	6878      	ldr	r0, [r7, #4]
3419d6d8:	f7ff fcc4 	bl	3419d064 <IMX335_WriteTable>
3419d6dc:	60f8      	str	r0, [r7, #12]
      break;
3419d6de:	bf00      	nop
  }
  return ret;
3419d6e0:	68fb      	ldr	r3, [r7, #12]
}
3419d6e2:	4618      	mov	r0, r3
3419d6e4:	3710      	adds	r7, #16
3419d6e6:	46bd      	mov	sp, r7
3419d6e8:	bd80      	pop	{r7, pc}
3419d6ea:	bf00      	nop
3419d6ec:	341b1718 	.word	0x341b1718
3419d6f0:	341b1740 	.word	0x341b1740
3419d6f4:	341b1768 	.word	0x341b1768
3419d6f8:	341b16f0 	.word	0x341b16f0

3419d6fc <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
3419d6fc:	b580      	push	{r7, lr}
3419d6fe:	b084      	sub	sp, #16
3419d700:	af00      	add	r7, sp, #0
3419d702:	6078      	str	r0, [r7, #4]
3419d704:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419d706:	2300      	movs	r3, #0
3419d708:	60fb      	str	r3, [r7, #12]
  uint8_t val;

  if (mode >= 0)
3419d70a:	683b      	ldr	r3, [r7, #0]
3419d70c:	2b00      	cmp	r3, #0
3419d70e:	db1d      	blt.n	3419d74c <IMX335_SetTestPattern+0x50>
  {
    /* Enable Test Pattern #mode */
    val = mode;
3419d710:	683b      	ldr	r3, [r7, #0]
3419d712:	b2db      	uxtb	r3, r3
3419d714:	72fb      	strb	r3, [r7, #11]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
3419d716:	687b      	ldr	r3, [r7, #4]
3419d718:	f103 0018 	add.w	r0, r3, #24
3419d71c:	f107 020b 	add.w	r2, r7, #11
3419d720:	2301      	movs	r3, #1
3419d722:	f243 219e 	movw	r1, #12958	@ 0x329e
3419d726:	f000 f83c 	bl	3419d7a2 <imx335_write_reg>
3419d72a:	4603      	mov	r3, r0
3419d72c:	2b00      	cmp	r3, #0
3419d72e:	d002      	beq.n	3419d736 <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
3419d730:	f04f 33ff 	mov.w	r3, #4294967295
3419d734:	e016      	b.n	3419d764 <IMX335_SetTestPattern+0x68>
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
3419d736:	2207      	movs	r2, #7
3419d738:	490c      	ldr	r1, [pc, #48]	@ (3419d76c <IMX335_SetTestPattern+0x70>)
3419d73a:	6878      	ldr	r0, [r7, #4]
3419d73c:	f7ff fc92 	bl	3419d064 <IMX335_WriteTable>
3419d740:	4603      	mov	r3, r0
3419d742:	2b00      	cmp	r3, #0
3419d744:	d00d      	beq.n	3419d762 <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3419d746:	f04f 33ff 	mov.w	r3, #4294967295
3419d74a:	e00b      	b.n	3419d764 <IMX335_SetTestPattern+0x68>
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
3419d74c:	2207      	movs	r2, #7
3419d74e:	4908      	ldr	r1, [pc, #32]	@ (3419d770 <IMX335_SetTestPattern+0x74>)
3419d750:	6878      	ldr	r0, [r7, #4]
3419d752:	f7ff fc87 	bl	3419d064 <IMX335_WriteTable>
3419d756:	4603      	mov	r3, r0
3419d758:	2b00      	cmp	r3, #0
3419d75a:	d002      	beq.n	3419d762 <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3419d75c:	f04f 33ff 	mov.w	r3, #4294967295
3419d760:	e000      	b.n	3419d764 <IMX335_SetTestPattern+0x68>
    }
  }

  return ret;
3419d762:	68fb      	ldr	r3, [r7, #12]
}
3419d764:	4618      	mov	r0, r3
3419d766:	3710      	adds	r7, #16
3419d768:	46bd      	mov	sp, r7
3419d76a:	bd80      	pop	{r7, pc}
3419d76c:	341b1790 	.word	0x341b1790
3419d770:	341b17ac 	.word	0x341b17ac

3419d774 <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
3419d774:	b590      	push	{r4, r7, lr}
3419d776:	b085      	sub	sp, #20
3419d778:	af00      	add	r7, sp, #0
3419d77a:	60f8      	str	r0, [r7, #12]
3419d77c:	607a      	str	r2, [r7, #4]
3419d77e:	461a      	mov	r2, r3
3419d780:	460b      	mov	r3, r1
3419d782:	817b      	strh	r3, [r7, #10]
3419d784:	4613      	mov	r3, r2
3419d786:	813b      	strh	r3, [r7, #8]
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
3419d788:	68fb      	ldr	r3, [r7, #12]
3419d78a:	685c      	ldr	r4, [r3, #4]
3419d78c:	68fb      	ldr	r3, [r7, #12]
3419d78e:	6898      	ldr	r0, [r3, #8]
3419d790:	893b      	ldrh	r3, [r7, #8]
3419d792:	8979      	ldrh	r1, [r7, #10]
3419d794:	687a      	ldr	r2, [r7, #4]
3419d796:	47a0      	blx	r4
3419d798:	4603      	mov	r3, r0
}
3419d79a:	4618      	mov	r0, r3
3419d79c:	3714      	adds	r7, #20
3419d79e:	46bd      	mov	sp, r7
3419d7a0:	bd90      	pop	{r4, r7, pc}

3419d7a2 <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
3419d7a2:	b590      	push	{r4, r7, lr}
3419d7a4:	b085      	sub	sp, #20
3419d7a6:	af00      	add	r7, sp, #0
3419d7a8:	60f8      	str	r0, [r7, #12]
3419d7aa:	607a      	str	r2, [r7, #4]
3419d7ac:	461a      	mov	r2, r3
3419d7ae:	460b      	mov	r3, r1
3419d7b0:	817b      	strh	r3, [r7, #10]
3419d7b2:	4613      	mov	r3, r2
3419d7b4:	813b      	strh	r3, [r7, #8]
  return ctx->WriteReg(ctx->handle, reg, data, length);
3419d7b6:	68fb      	ldr	r3, [r7, #12]
3419d7b8:	681c      	ldr	r4, [r3, #0]
3419d7ba:	68fb      	ldr	r3, [r7, #12]
3419d7bc:	6898      	ldr	r0, [r3, #8]
3419d7be:	893b      	ldrh	r3, [r7, #8]
3419d7c0:	8979      	ldrh	r1, [r7, #10]
3419d7c2:	687a      	ldr	r2, [r7, #4]
3419d7c4:	47a0      	blx	r4
3419d7c6:	4603      	mov	r3, r0
}
3419d7c8:	4618      	mov	r0, r3
3419d7ca:	3714      	adds	r7, #20
3419d7cc:	46bd      	mov	sp, r7
3419d7ce:	bd90      	pop	{r4, r7, pc}

3419d7d0 <VD55G1_Resolution2Mode>:
  if (_ret_) display_error(_ctx_); \
  if (_ret_) return _ret_; \
} while(0)

static const struct vd55g1_mode *VD55G1_Resolution2Mode(VD55G1_Res_t resolution)
{
3419d7d0:	b480      	push	{r7}
3419d7d2:	b083      	sub	sp, #12
3419d7d4:	af00      	add	r7, sp, #0
3419d7d6:	4603      	mov	r3, r0
3419d7d8:	71fb      	strb	r3, [r7, #7]
  switch (resolution) {
3419d7da:	79fb      	ldrb	r3, [r7, #7]
3419d7dc:	2b03      	cmp	r3, #3
3419d7de:	d813      	bhi.n	3419d808 <VD55G1_Resolution2Mode+0x38>
3419d7e0:	a201      	add	r2, pc, #4	@ (adr r2, 3419d7e8 <VD55G1_Resolution2Mode+0x18>)
3419d7e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419d7e6:	bf00      	nop
3419d7e8:	3419d7f9 	.word	0x3419d7f9
3419d7ec:	3419d7fd 	.word	0x3419d7fd
3419d7f0:	3419d801 	.word	0x3419d801
3419d7f4:	3419d805 	.word	0x3419d805
  case VD55G1_RES_QVGA_320_240:
    return &vd55g1_supported_modes[3];
3419d7f8:	4b07      	ldr	r3, [pc, #28]	@ (3419d818 <VD55G1_Resolution2Mode+0x48>)
3419d7fa:	e006      	b.n	3419d80a <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_VGA_640_480:
    return &vd55g1_supported_modes[2];
3419d7fc:	4b07      	ldr	r3, [pc, #28]	@ (3419d81c <VD55G1_Resolution2Mode+0x4c>)
3419d7fe:	e004      	b.n	3419d80a <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_SXGA_800_600:
    return &vd55g1_supported_modes[1];
3419d800:	4b07      	ldr	r3, [pc, #28]	@ (3419d820 <VD55G1_Resolution2Mode+0x50>)
3419d802:	e002      	b.n	3419d80a <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_FULL_804_704:
    return &vd55g1_supported_modes[0];
3419d804:	4b07      	ldr	r3, [pc, #28]	@ (3419d824 <VD55G1_Resolution2Mode+0x54>)
3419d806:	e000      	b.n	3419d80a <VD55G1_Resolution2Mode+0x3a>
    break;
  default:
    return NULL;
3419d808:	2300      	movs	r3, #0
  }
}
3419d80a:	4618      	mov	r0, r3
3419d80c:	370c      	adds	r7, #12
3419d80e:	46bd      	mov	sp, r7
3419d810:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d814:	4770      	bx	lr
3419d816:	bf00      	nop
3419d818:	341b2ec8 	.word	0x341b2ec8
3419d81c:	341b2eac 	.word	0x341b2eac
3419d820:	341b2e90 	.word	0x341b2e90
3419d824:	341b2e74 	.word	0x341b2e74

3419d828 <VD55G1_log_impl>:

static void VD55G1_log_impl(VD55G1_Ctx_t *ctx, int lvl, const char *format, ...)
{
3419d828:	b40c      	push	{r2, r3}
3419d82a:	b590      	push	{r4, r7, lr}
3419d82c:	b085      	sub	sp, #20
3419d82e:	af00      	add	r7, sp, #0
3419d830:	6078      	str	r0, [r7, #4]
3419d832:	6039      	str	r1, [r7, #0]
  va_list ap;

  if (!ctx->log)
3419d834:	687b      	ldr	r3, [r7, #4]
3419d836:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419d838:	2b00      	cmp	r3, #0
3419d83a:	d00a      	beq.n	3419d852 <VD55G1_log_impl+0x2a>
    return ;

  va_start(ap, format);
3419d83c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419d840:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, lvl, format, ap);
3419d842:	687b      	ldr	r3, [r7, #4]
3419d844:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419d846:	68fb      	ldr	r3, [r7, #12]
3419d848:	6a3a      	ldr	r2, [r7, #32]
3419d84a:	6839      	ldr	r1, [r7, #0]
3419d84c:	6878      	ldr	r0, [r7, #4]
3419d84e:	47a0      	blx	r4
3419d850:	e000      	b.n	3419d854 <VD55G1_log_impl+0x2c>
    return ;
3419d852:	bf00      	nop
  va_end(ap);
}
3419d854:	3714      	adds	r7, #20
3419d856:	46bd      	mov	sp, r7
3419d858:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419d85c:	b002      	add	sp, #8
3419d85e:	4770      	bx	lr

3419d860 <display_error>:
#define VD55G1_error(_ctx_, _fmt_, ...) do { \
  VD55G1_log_impl(_ctx_, VD55G1_LVL_ERROR, "VD55G1_ERR-%d : " _fmt_, __LINE__, ##__VA_ARGS__); \
} while(0)

static void display_error(VD55G1_Ctx_t *ctx)
{
3419d860:	b580      	push	{r7, lr}
3419d862:	b086      	sub	sp, #24
3419d864:	af02      	add	r7, sp, #8
3419d866:	6078      	str	r0, [r7, #4]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
3419d868:	687b      	ldr	r3, [r7, #4]
3419d86a:	689b      	ldr	r3, [r3, #8]
3419d86c:	f107 020a 	add.w	r2, r7, #10
3419d870:	2110      	movs	r1, #16
3419d872:	6878      	ldr	r0, [r7, #4]
3419d874:	4798      	blx	r3
3419d876:	60f8      	str	r0, [r7, #12]
  assert(ret == 0);
3419d878:	68fb      	ldr	r3, [r7, #12]
3419d87a:	2b00      	cmp	r3, #0
3419d87c:	d005      	beq.n	3419d88a <display_error+0x2a>
3419d87e:	4b09      	ldr	r3, [pc, #36]	@ (3419d8a4 <display_error+0x44>)
3419d880:	4a09      	ldr	r2, [pc, #36]	@ (3419d8a8 <display_error+0x48>)
3419d882:	21fc      	movs	r1, #252	@ 0xfc
3419d884:	4809      	ldr	r0, [pc, #36]	@ (3419d8ac <display_error+0x4c>)
3419d886:	f006 f803 	bl	341a3890 <__assert_func>
  VD55G1_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
3419d88a:	897b      	ldrh	r3, [r7, #10]
3419d88c:	9300      	str	r3, [sp, #0]
3419d88e:	23fd      	movs	r3, #253	@ 0xfd
3419d890:	4a07      	ldr	r2, [pc, #28]	@ (3419d8b0 <display_error+0x50>)
3419d892:	2100      	movs	r1, #0
3419d894:	6878      	ldr	r0, [r7, #4]
3419d896:	f7ff ffc7 	bl	3419d828 <VD55G1_log_impl>
}
3419d89a:	bf00      	nop
3419d89c:	3710      	adds	r7, #16
3419d89e:	46bd      	mov	sp, r7
3419d8a0:	bd80      	pop	{r7, pc}
3419d8a2:	bf00      	nop
3419d8a4:	341a6074 	.word	0x341a6074
3419d8a8:	341b2ee4 	.word	0x341b2ee4
3419d8ac:	341a6080 	.word	0x341a6080
3419d8b0:	341a60bc 	.word	0x341a60bc

3419d8b4 <VD55G1_PollReg8>:

  return 0;
}

static int VD55G1_PollReg8(VD55G1_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
3419d8b4:	b580      	push	{r7, lr}
3419d8b6:	b08a      	sub	sp, #40	@ 0x28
3419d8b8:	af02      	add	r7, sp, #8
3419d8ba:	6078      	str	r0, [r7, #4]
3419d8bc:	460b      	mov	r3, r1
3419d8be:	807b      	strh	r3, [r7, #2]
3419d8c0:	4613      	mov	r3, r2
3419d8c2:	707b      	strb	r3, [r7, #1]
  const unsigned int loop_delay_ms = 10;
3419d8c4:	230a      	movs	r3, #10
3419d8c6:	61bb      	str	r3, [r7, #24]
  const unsigned int timeout_ms = 500;
3419d8c8:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
3419d8cc:	617b      	str	r3, [r7, #20]
  int loop_nb = timeout_ms / loop_delay_ms;
3419d8ce:	697a      	ldr	r2, [r7, #20]
3419d8d0:	69bb      	ldr	r3, [r7, #24]
3419d8d2:	fbb2 f3f3 	udiv	r3, r2, r3
3419d8d6:	61fb      	str	r3, [r7, #28]
  uint8_t val;
  int ret;

  while (--loop_nb) {
3419d8d8:	e017      	b.n	3419d90a <VD55G1_PollReg8+0x56>
    ret = ctx->read8(ctx, addr, &val);
3419d8da:	687b      	ldr	r3, [r7, #4]
3419d8dc:	685b      	ldr	r3, [r3, #4]
3419d8de:	f107 020f 	add.w	r2, r7, #15
3419d8e2:	8879      	ldrh	r1, [r7, #2]
3419d8e4:	6878      	ldr	r0, [r7, #4]
3419d8e6:	4798      	blx	r3
3419d8e8:	6138      	str	r0, [r7, #16]
    if (ret < 0)
3419d8ea:	693b      	ldr	r3, [r7, #16]
3419d8ec:	2b00      	cmp	r3, #0
3419d8ee:	da01      	bge.n	3419d8f4 <VD55G1_PollReg8+0x40>
      return ret;
3419d8f0:	693b      	ldr	r3, [r7, #16]
3419d8f2:	e01d      	b.n	3419d930 <VD55G1_PollReg8+0x7c>
    if (val == poll_val)
3419d8f4:	7bfb      	ldrb	r3, [r7, #15]
3419d8f6:	787a      	ldrb	r2, [r7, #1]
3419d8f8:	429a      	cmp	r2, r3
3419d8fa:	d101      	bne.n	3419d900 <VD55G1_PollReg8+0x4c>
      return 0;
3419d8fc:	2300      	movs	r3, #0
3419d8fe:	e017      	b.n	3419d930 <VD55G1_PollReg8+0x7c>
    ctx->delay(ctx, loop_delay_ms);
3419d900:	687b      	ldr	r3, [r7, #4]
3419d902:	6a1b      	ldr	r3, [r3, #32]
3419d904:	69b9      	ldr	r1, [r7, #24]
3419d906:	6878      	ldr	r0, [r7, #4]
3419d908:	4798      	blx	r3
  while (--loop_nb) {
3419d90a:	69fb      	ldr	r3, [r7, #28]
3419d90c:	3b01      	subs	r3, #1
3419d90e:	61fb      	str	r3, [r7, #28]
3419d910:	69fb      	ldr	r3, [r7, #28]
3419d912:	2b00      	cmp	r3, #0
3419d914:	d1e1      	bne.n	3419d8da <VD55G1_PollReg8+0x26>
  }

  VD55G1_dbg(ctx, 0, "current state %d\n", val);
3419d916:	7bfb      	ldrb	r3, [r7, #15]
3419d918:	9301      	str	r3, [sp, #4]
3419d91a:	f240 132b 	movw	r3, #299	@ 0x12b
3419d91e:	9300      	str	r3, [sp, #0]
3419d920:	2300      	movs	r3, #0
3419d922:	4a05      	ldr	r2, [pc, #20]	@ (3419d938 <VD55G1_PollReg8+0x84>)
3419d924:	2103      	movs	r1, #3
3419d926:	6878      	ldr	r0, [r7, #4]
3419d928:	f7ff ff7e 	bl	3419d828 <VD55G1_log_impl>

  return -1;
3419d92c:	f04f 33ff 	mov.w	r3, #4294967295
}
3419d930:	4618      	mov	r0, r3
3419d932:	3720      	adds	r7, #32
3419d934:	46bd      	mov	sp, r7
3419d936:	bd80      	pop	{r7, pc}
3419d938:	341a610c 	.word	0x341a610c

3419d93c <VD55G1_IsStreaming>:

static int VD55G1_IsStreaming(VD55G1_Ctx_t *ctx)
{
3419d93c:	b580      	push	{r7, lr}
3419d93e:	b084      	sub	sp, #16
3419d940:	af00      	add	r7, sp, #0
3419d942:	6078      	str	r0, [r7, #4]
  uint8_t state;
  int ret;

  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
3419d944:	687b      	ldr	r3, [r7, #4]
3419d946:	685b      	ldr	r3, [r3, #4]
3419d948:	f107 020b 	add.w	r2, r7, #11
3419d94c:	211c      	movs	r1, #28
3419d94e:	6878      	ldr	r0, [r7, #4]
3419d950:	4798      	blx	r3
3419d952:	60f8      	str	r0, [r7, #12]
  if (ret)
3419d954:	68fb      	ldr	r3, [r7, #12]
3419d956:	2b00      	cmp	r3, #0
3419d958:	d001      	beq.n	3419d95e <VD55G1_IsStreaming+0x22>
    return ret;
3419d95a:	68fb      	ldr	r3, [r7, #12]
3419d95c:	e005      	b.n	3419d96a <VD55G1_IsStreaming+0x2e>

  return state == VD55G1_SYSTEM_FSM_STREAMING;
3419d95e:	7afb      	ldrb	r3, [r7, #11]
3419d960:	2b03      	cmp	r3, #3
3419d962:	bf0c      	ite	eq
3419d964:	2301      	moveq	r3, #1
3419d966:	2300      	movne	r3, #0
3419d968:	b2db      	uxtb	r3, r3
}
3419d96a:	4618      	mov	r0, r3
3419d96c:	3710      	adds	r7, #16
3419d96e:	46bd      	mov	sp, r7
3419d970:	bd80      	pop	{r7, pc}
	...

3419d974 <VD55G1_WaitState>:

static int VD55G1_WaitState(VD55G1_Ctx_t *ctx, int state)
{
3419d974:	b580      	push	{r7, lr}
3419d976:	b086      	sub	sp, #24
3419d978:	af02      	add	r7, sp, #8
3419d97a:	6078      	str	r0, [r7, #4]
3419d97c:	6039      	str	r1, [r7, #0]
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
3419d97e:	683b      	ldr	r3, [r7, #0]
3419d980:	b2db      	uxtb	r3, r3
3419d982:	461a      	mov	r2, r3
3419d984:	211c      	movs	r1, #28
3419d986:	6878      	ldr	r0, [r7, #4]
3419d988:	f7ff ff94 	bl	3419d8b4 <VD55G1_PollReg8>
3419d98c:	60f8      	str	r0, [r7, #12]

  if (ret)
3419d98e:	68fb      	ldr	r3, [r7, #12]
3419d990:	2b00      	cmp	r3, #0
3419d992:	d009      	beq.n	3419d9a8 <VD55G1_WaitState+0x34>
    VD55G1_warn(ctx, "Unable to reach state %d\n", state);
3419d994:	683b      	ldr	r3, [r7, #0]
3419d996:	9300      	str	r3, [sp, #0]
3419d998:	f240 1341 	movw	r3, #321	@ 0x141
3419d99c:	4a0a      	ldr	r2, [pc, #40]	@ (3419d9c8 <VD55G1_WaitState+0x54>)
3419d99e:	2101      	movs	r1, #1
3419d9a0:	6878      	ldr	r0, [r7, #4]
3419d9a2:	f7ff ff41 	bl	3419d828 <VD55G1_log_impl>
3419d9a6:	e00a      	b.n	3419d9be <VD55G1_WaitState+0x4a>
  else
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);
3419d9a8:	683b      	ldr	r3, [r7, #0]
3419d9aa:	9301      	str	r3, [sp, #4]
3419d9ac:	f240 1343 	movw	r3, #323	@ 0x143
3419d9b0:	9300      	str	r3, [sp, #0]
3419d9b2:	2300      	movs	r3, #0
3419d9b4:	4a05      	ldr	r2, [pc, #20]	@ (3419d9cc <VD55G1_WaitState+0x58>)
3419d9b6:	2103      	movs	r1, #3
3419d9b8:	6878      	ldr	r0, [r7, #4]
3419d9ba:	f7ff ff35 	bl	3419d828 <VD55G1_log_impl>

  return ret;
3419d9be:	68fb      	ldr	r3, [r7, #12]
}
3419d9c0:	4618      	mov	r0, r3
3419d9c2:	3710      	adds	r7, #16
3419d9c4:	46bd      	mov	sp, r7
3419d9c6:	bd80      	pop	{r7, pc}
3419d9c8:	341a6130 	.word	0x341a6130
3419d9cc:	341a615c 	.word	0x341a615c

3419d9d0 <VD55G1_CheckModelId>:

static int VD55G1_CheckModelId(VD55G1_Ctx_t *ctx)
{
3419d9d0:	b580      	push	{r7, lr}
3419d9d2:	b08a      	sub	sp, #40	@ 0x28
3419d9d4:	af04      	add	r7, sp, #16
3419d9d6:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419d9d8:	687b      	ldr	r3, [r7, #4]
3419d9da:	3328      	adds	r3, #40	@ 0x28
3419d9dc:	617b      	str	r3, [r7, #20]
  uint32_t reg32;
  uint16_t reg16;
  int ret;

  ret = ctx->read32(ctx, VD55G1_REG_MODEL_ID, &reg32);
3419d9de:	687b      	ldr	r3, [r7, #4]
3419d9e0:	68db      	ldr	r3, [r3, #12]
3419d9e2:	f107 020c 	add.w	r2, r7, #12
3419d9e6:	2100      	movs	r1, #0
3419d9e8:	6878      	ldr	r0, [r7, #4]
3419d9ea:	4798      	blx	r3
3419d9ec:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419d9ee:	693b      	ldr	r3, [r7, #16]
3419d9f0:	2b00      	cmp	r3, #0
3419d9f2:	d00d      	beq.n	3419da10 <VD55G1_CheckModelId+0x40>
3419d9f4:	693b      	ldr	r3, [r7, #16]
3419d9f6:	9302      	str	r3, [sp, #8]
3419d9f8:	f44f 73a8 	mov.w	r3, #336	@ 0x150
3419d9fc:	9301      	str	r3, [sp, #4]
3419d9fe:	4b5a      	ldr	r3, [pc, #360]	@ (3419db68 <VD55G1_CheckModelId+0x198>)
3419da00:	9300      	str	r3, [sp, #0]
3419da02:	f44f 73a8 	mov.w	r3, #336	@ 0x150
3419da06:	4a59      	ldr	r2, [pc, #356]	@ (3419db6c <VD55G1_CheckModelId+0x19c>)
3419da08:	2100      	movs	r1, #0
3419da0a:	6878      	ldr	r0, [r7, #4]
3419da0c:	f7ff ff0c 	bl	3419d828 <VD55G1_log_impl>
3419da10:	693b      	ldr	r3, [r7, #16]
3419da12:	2b00      	cmp	r3, #0
3419da14:	d002      	beq.n	3419da1c <VD55G1_CheckModelId+0x4c>
3419da16:	6878      	ldr	r0, [r7, #4]
3419da18:	f7ff ff22 	bl	3419d860 <display_error>
3419da1c:	693b      	ldr	r3, [r7, #16]
3419da1e:	2b00      	cmp	r3, #0
3419da20:	d001      	beq.n	3419da26 <VD55G1_CheckModelId+0x56>
3419da22:	693b      	ldr	r3, [r7, #16]
3419da24:	e09b      	b.n	3419db5e <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "model_id = 0x%04x\n", reg32);
3419da26:	68fb      	ldr	r3, [r7, #12]
3419da28:	9301      	str	r3, [sp, #4]
3419da2a:	f240 1351 	movw	r3, #337	@ 0x151
3419da2e:	9300      	str	r3, [sp, #0]
3419da30:	2300      	movs	r3, #0
3419da32:	4a4f      	ldr	r2, [pc, #316]	@ (3419db70 <VD55G1_CheckModelId+0x1a0>)
3419da34:	2103      	movs	r1, #3
3419da36:	6878      	ldr	r0, [r7, #4]
3419da38:	f7ff fef6 	bl	3419d828 <VD55G1_log_impl>
  if (reg32 != VD55G1_MODEL_ID) {
3419da3c:	68fb      	ldr	r3, [r7, #12]
3419da3e:	4a4d      	ldr	r2, [pc, #308]	@ (3419db74 <VD55G1_CheckModelId+0x1a4>)
3419da40:	4293      	cmp	r3, r2
3419da42:	d00d      	beq.n	3419da60 <VD55G1_CheckModelId+0x90>
    VD55G1_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD55G1_MODEL_ID, reg32);
3419da44:	68fb      	ldr	r3, [r7, #12]
3419da46:	9301      	str	r3, [sp, #4]
3419da48:	4b4a      	ldr	r3, [pc, #296]	@ (3419db74 <VD55G1_CheckModelId+0x1a4>)
3419da4a:	9300      	str	r3, [sp, #0]
3419da4c:	f240 1353 	movw	r3, #339	@ 0x153
3419da50:	4a49      	ldr	r2, [pc, #292]	@ (3419db78 <VD55G1_CheckModelId+0x1a8>)
3419da52:	2100      	movs	r1, #0
3419da54:	6878      	ldr	r0, [r7, #4]
3419da56:	f7ff fee7 	bl	3419d828 <VD55G1_log_impl>
    return -1;
3419da5a:	f04f 33ff 	mov.w	r3, #4294967295
3419da5e:	e07e      	b.n	3419db5e <VD55G1_CheckModelId+0x18e>
  }

  ret = ctx->read16(ctx, VD55G1_REG_REVISION, &reg16);
3419da60:	687b      	ldr	r3, [r7, #4]
3419da62:	689b      	ldr	r3, [r3, #8]
3419da64:	f107 020a 	add.w	r2, r7, #10
3419da68:	2104      	movs	r1, #4
3419da6a:	6878      	ldr	r0, [r7, #4]
3419da6c:	4798      	blx	r3
3419da6e:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419da70:	693b      	ldr	r3, [r7, #16]
3419da72:	2b00      	cmp	r3, #0
3419da74:	d00d      	beq.n	3419da92 <VD55G1_CheckModelId+0xc2>
3419da76:	693b      	ldr	r3, [r7, #16]
3419da78:	9302      	str	r3, [sp, #8]
3419da7a:	f44f 73ac 	mov.w	r3, #344	@ 0x158
3419da7e:	9301      	str	r3, [sp, #4]
3419da80:	4b39      	ldr	r3, [pc, #228]	@ (3419db68 <VD55G1_CheckModelId+0x198>)
3419da82:	9300      	str	r3, [sp, #0]
3419da84:	f44f 73ac 	mov.w	r3, #344	@ 0x158
3419da88:	4a38      	ldr	r2, [pc, #224]	@ (3419db6c <VD55G1_CheckModelId+0x19c>)
3419da8a:	2100      	movs	r1, #0
3419da8c:	6878      	ldr	r0, [r7, #4]
3419da8e:	f7ff fecb 	bl	3419d828 <VD55G1_log_impl>
3419da92:	693b      	ldr	r3, [r7, #16]
3419da94:	2b00      	cmp	r3, #0
3419da96:	d002      	beq.n	3419da9e <VD55G1_CheckModelId+0xce>
3419da98:	6878      	ldr	r0, [r7, #4]
3419da9a:	f7ff fee1 	bl	3419d860 <display_error>
3419da9e:	693b      	ldr	r3, [r7, #16]
3419daa0:	2b00      	cmp	r3, #0
3419daa2:	d001      	beq.n	3419daa8 <VD55G1_CheckModelId+0xd8>
3419daa4:	693b      	ldr	r3, [r7, #16]
3419daa6:	e05a      	b.n	3419db5e <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
3419daa8:	897b      	ldrh	r3, [r7, #10]
3419daaa:	9301      	str	r3, [sp, #4]
3419daac:	f240 1359 	movw	r3, #345	@ 0x159
3419dab0:	9300      	str	r3, [sp, #0]
3419dab2:	2300      	movs	r3, #0
3419dab4:	4a31      	ldr	r2, [pc, #196]	@ (3419db7c <VD55G1_CheckModelId+0x1ac>)
3419dab6:	2103      	movs	r1, #3
3419dab8:	6878      	ldr	r0, [r7, #4]
3419daba:	f7ff feb5 	bl	3419d828 <VD55G1_log_impl>
  switch (reg16) {
3419dabe:	897b      	ldrh	r3, [r7, #10]
3419dac0:	f241 0210 	movw	r2, #4112	@ 0x1010
3419dac4:	4293      	cmp	r3, r2
3419dac6:	d004      	beq.n	3419dad2 <VD55G1_CheckModelId+0x102>
3419dac8:	f242 0220 	movw	r2, #8224	@ 0x2020
3419dacc:	4293      	cmp	r3, r2
3419dace:	d005      	beq.n	3419dadc <VD55G1_CheckModelId+0x10c>
3419dad0:	e009      	b.n	3419dae6 <VD55G1_CheckModelId+0x116>
  case VD55G1_REVISION_CUT_1:
    drv_ctx->cut_version = VD55G1_REVISION_CUT_1;
3419dad2:	697b      	ldr	r3, [r7, #20]
3419dad4:	f241 0210 	movw	r2, #4112	@ 0x1010
3419dad8:	605a      	str	r2, [r3, #4]
    break;
3419dada:	e010      	b.n	3419dafe <VD55G1_CheckModelId+0x12e>
  case VD55G1_REVISION_CUT_2:
    drv_ctx->cut_version = VD55G1_REVISION_CUT_2;
3419dadc:	697b      	ldr	r3, [r7, #20]
3419dade:	f242 0220 	movw	r2, #8224	@ 0x2020
3419dae2:	605a      	str	r2, [r3, #4]
    break;
3419dae4:	e00b      	b.n	3419dafe <VD55G1_CheckModelId+0x12e>
  default:
    VD55G1_error(ctx, "Unsupported revision0x%04x\n", reg16);
3419dae6:	897b      	ldrh	r3, [r7, #10]
3419dae8:	9300      	str	r3, [sp, #0]
3419daea:	f44f 73b1 	mov.w	r3, #354	@ 0x162
3419daee:	4a24      	ldr	r2, [pc, #144]	@ (3419db80 <VD55G1_CheckModelId+0x1b0>)
3419daf0:	2100      	movs	r1, #0
3419daf2:	6878      	ldr	r0, [r7, #4]
3419daf4:	f7ff fe98 	bl	3419d828 <VD55G1_log_impl>
    return -1;
3419daf8:	f04f 33ff 	mov.w	r3, #4294967295
3419dafc:	e02f      	b.n	3419db5e <VD55G1_CheckModelId+0x18e>
  }

  ret = ctx->read32(ctx, VD55G1_REG_ROM_REVISION, &reg32);
3419dafe:	687b      	ldr	r3, [r7, #4]
3419db00:	68db      	ldr	r3, [r3, #12]
3419db02:	f107 020c 	add.w	r2, r7, #12
3419db06:	2108      	movs	r1, #8
3419db08:	6878      	ldr	r0, [r7, #4]
3419db0a:	4798      	blx	r3
3419db0c:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419db0e:	693b      	ldr	r3, [r7, #16]
3419db10:	2b00      	cmp	r3, #0
3419db12:	d00d      	beq.n	3419db30 <VD55G1_CheckModelId+0x160>
3419db14:	693b      	ldr	r3, [r7, #16]
3419db16:	9302      	str	r3, [sp, #8]
3419db18:	f240 1367 	movw	r3, #359	@ 0x167
3419db1c:	9301      	str	r3, [sp, #4]
3419db1e:	4b12      	ldr	r3, [pc, #72]	@ (3419db68 <VD55G1_CheckModelId+0x198>)
3419db20:	9300      	str	r3, [sp, #0]
3419db22:	f240 1367 	movw	r3, #359	@ 0x167
3419db26:	4a11      	ldr	r2, [pc, #68]	@ (3419db6c <VD55G1_CheckModelId+0x19c>)
3419db28:	2100      	movs	r1, #0
3419db2a:	6878      	ldr	r0, [r7, #4]
3419db2c:	f7ff fe7c 	bl	3419d828 <VD55G1_log_impl>
3419db30:	693b      	ldr	r3, [r7, #16]
3419db32:	2b00      	cmp	r3, #0
3419db34:	d002      	beq.n	3419db3c <VD55G1_CheckModelId+0x16c>
3419db36:	6878      	ldr	r0, [r7, #4]
3419db38:	f7ff fe92 	bl	3419d860 <display_error>
3419db3c:	693b      	ldr	r3, [r7, #16]
3419db3e:	2b00      	cmp	r3, #0
3419db40:	d001      	beq.n	3419db46 <VD55G1_CheckModelId+0x176>
3419db42:	693b      	ldr	r3, [r7, #16]
3419db44:	e00b      	b.n	3419db5e <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "rom = 0x%04x\n", reg32);
3419db46:	68fb      	ldr	r3, [r7, #12]
3419db48:	9301      	str	r3, [sp, #4]
3419db4a:	f44f 73b4 	mov.w	r3, #360	@ 0x168
3419db4e:	9300      	str	r3, [sp, #0]
3419db50:	2300      	movs	r3, #0
3419db52:	4a0c      	ldr	r2, [pc, #48]	@ (3419db84 <VD55G1_CheckModelId+0x1b4>)
3419db54:	2103      	movs	r1, #3
3419db56:	6878      	ldr	r0, [r7, #4]
3419db58:	f7ff fe66 	bl	3419d828 <VD55G1_log_impl>

  return 0;
3419db5c:	2300      	movs	r3, #0
}
3419db5e:	4618      	mov	r0, r3
3419db60:	3718      	adds	r7, #24
3419db62:	46bd      	mov	sp, r7
3419db64:	bd80      	pop	{r7, pc}
3419db66:	bf00      	nop
3419db68:	341b2ef4 	.word	0x341b2ef4
3419db6c:	341a60e4 	.word	0x341a60e4
3419db70:	341a6180 	.word	0x341a6180
3419db74:	53354731 	.word	0x53354731
3419db78:	341a61a4 	.word	0x341a61a4
3419db7c:	341a61e0 	.word	0x341a61e0
3419db80:	341a6204 	.word	0x341a6204
3419db84:	341a6230 	.word	0x341a6230

3419db88 <VD55G1_ApplyPatchCommon>:

static int VD55G1_ApplyPatchCommon(VD55G1_Ctx_t *ctx, uint8_t *patch_array, int patch_len, uint8_t patch_major,
                                   uint8_t patch_minor)
{
3419db88:	b590      	push	{r4, r7, lr}
3419db8a:	b08b      	sub	sp, #44	@ 0x2c
3419db8c:	af04      	add	r7, sp, #16
3419db8e:	60f8      	str	r0, [r7, #12]
3419db90:	60b9      	str	r1, [r7, #8]
3419db92:	607a      	str	r2, [r7, #4]
3419db94:	70fb      	strb	r3, [r7, #3]
  uint16_t reg16;
  int ret;

  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
3419db96:	68fb      	ldr	r3, [r7, #12]
3419db98:	69dc      	ldr	r4, [r3, #28]
3419db9a:	687b      	ldr	r3, [r7, #4]
3419db9c:	68ba      	ldr	r2, [r7, #8]
3419db9e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
3419dba2:	68f8      	ldr	r0, [r7, #12]
3419dba4:	47a0      	blx	r4
3419dba6:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419dba8:	697b      	ldr	r3, [r7, #20]
3419dbaa:	2b00      	cmp	r3, #0
3419dbac:	d00d      	beq.n	3419dbca <VD55G1_ApplyPatchCommon+0x42>
3419dbae:	697b      	ldr	r3, [r7, #20]
3419dbb0:	9302      	str	r3, [sp, #8]
3419dbb2:	f44f 73ba 	mov.w	r3, #372	@ 0x174
3419dbb6:	9301      	str	r3, [sp, #4]
3419dbb8:	4b72      	ldr	r3, [pc, #456]	@ (3419dd84 <VD55G1_ApplyPatchCommon+0x1fc>)
3419dbba:	9300      	str	r3, [sp, #0]
3419dbbc:	f44f 73ba 	mov.w	r3, #372	@ 0x174
3419dbc0:	4a71      	ldr	r2, [pc, #452]	@ (3419dd88 <VD55G1_ApplyPatchCommon+0x200>)
3419dbc2:	2100      	movs	r1, #0
3419dbc4:	68f8      	ldr	r0, [r7, #12]
3419dbc6:	f7ff fe2f 	bl	3419d828 <VD55G1_log_impl>
3419dbca:	697b      	ldr	r3, [r7, #20]
3419dbcc:	2b00      	cmp	r3, #0
3419dbce:	d002      	beq.n	3419dbd6 <VD55G1_ApplyPatchCommon+0x4e>
3419dbd0:	68f8      	ldr	r0, [r7, #12]
3419dbd2:	f7ff fe45 	bl	3419d860 <display_error>
3419dbd6:	697b      	ldr	r3, [r7, #20]
3419dbd8:	2b00      	cmp	r3, #0
3419dbda:	d001      	beq.n	3419dbe0 <VD55G1_ApplyPatchCommon+0x58>
3419dbdc:	697b      	ldr	r3, [r7, #20]
3419dbde:	e0cd      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>

  ret = ctx->write8(ctx, VD55G1_REG_BOOT, VD55G1_BOOT_PATCH_AND_BOOT);
3419dbe0:	68fb      	ldr	r3, [r7, #12]
3419dbe2:	691b      	ldr	r3, [r3, #16]
3419dbe4:	2202      	movs	r2, #2
3419dbe6:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419dbea:	68f8      	ldr	r0, [r7, #12]
3419dbec:	4798      	blx	r3
3419dbee:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419dbf0:	697b      	ldr	r3, [r7, #20]
3419dbf2:	2b00      	cmp	r3, #0
3419dbf4:	d00d      	beq.n	3419dc12 <VD55G1_ApplyPatchCommon+0x8a>
3419dbf6:	697b      	ldr	r3, [r7, #20]
3419dbf8:	9302      	str	r3, [sp, #8]
3419dbfa:	f240 1377 	movw	r3, #375	@ 0x177
3419dbfe:	9301      	str	r3, [sp, #4]
3419dc00:	4b60      	ldr	r3, [pc, #384]	@ (3419dd84 <VD55G1_ApplyPatchCommon+0x1fc>)
3419dc02:	9300      	str	r3, [sp, #0]
3419dc04:	f240 1377 	movw	r3, #375	@ 0x177
3419dc08:	4a5f      	ldr	r2, [pc, #380]	@ (3419dd88 <VD55G1_ApplyPatchCommon+0x200>)
3419dc0a:	2100      	movs	r1, #0
3419dc0c:	68f8      	ldr	r0, [r7, #12]
3419dc0e:	f7ff fe0b 	bl	3419d828 <VD55G1_log_impl>
3419dc12:	697b      	ldr	r3, [r7, #20]
3419dc14:	2b00      	cmp	r3, #0
3419dc16:	d002      	beq.n	3419dc1e <VD55G1_ApplyPatchCommon+0x96>
3419dc18:	68f8      	ldr	r0, [r7, #12]
3419dc1a:	f7ff fe21 	bl	3419d860 <display_error>
3419dc1e:	697b      	ldr	r3, [r7, #20]
3419dc20:	2b00      	cmp	r3, #0
3419dc22:	d001      	beq.n	3419dc28 <VD55G1_ApplyPatchCommon+0xa0>
3419dc24:	697b      	ldr	r3, [r7, #20]
3419dc26:	e0a9      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_BOOT, VD55G1_CMD_ACK);
3419dc28:	2200      	movs	r2, #0
3419dc2a:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419dc2e:	68f8      	ldr	r0, [r7, #12]
3419dc30:	f7ff fe40 	bl	3419d8b4 <VD55G1_PollReg8>
3419dc34:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419dc36:	697b      	ldr	r3, [r7, #20]
3419dc38:	2b00      	cmp	r3, #0
3419dc3a:	d00d      	beq.n	3419dc58 <VD55G1_ApplyPatchCommon+0xd0>
3419dc3c:	697b      	ldr	r3, [r7, #20]
3419dc3e:	9302      	str	r3, [sp, #8]
3419dc40:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3419dc44:	9301      	str	r3, [sp, #4]
3419dc46:	4b4f      	ldr	r3, [pc, #316]	@ (3419dd84 <VD55G1_ApplyPatchCommon+0x1fc>)
3419dc48:	9300      	str	r3, [sp, #0]
3419dc4a:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3419dc4e:	4a4e      	ldr	r2, [pc, #312]	@ (3419dd88 <VD55G1_ApplyPatchCommon+0x200>)
3419dc50:	2100      	movs	r1, #0
3419dc52:	68f8      	ldr	r0, [r7, #12]
3419dc54:	f7ff fde8 	bl	3419d828 <VD55G1_log_impl>
3419dc58:	697b      	ldr	r3, [r7, #20]
3419dc5a:	2b00      	cmp	r3, #0
3419dc5c:	d002      	beq.n	3419dc64 <VD55G1_ApplyPatchCommon+0xdc>
3419dc5e:	68f8      	ldr	r0, [r7, #12]
3419dc60:	f7ff fdfe 	bl	3419d860 <display_error>
3419dc64:	697b      	ldr	r3, [r7, #20]
3419dc66:	2b00      	cmp	r3, #0
3419dc68:	d001      	beq.n	3419dc6e <VD55G1_ApplyPatchCommon+0xe6>
3419dc6a:	697b      	ldr	r3, [r7, #20]
3419dc6c:	e086      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>

  ret = ctx->read16(ctx, VD55G1_REG_FWPATCH_REVISION, &reg16);
3419dc6e:	68fb      	ldr	r3, [r7, #12]
3419dc70:	689b      	ldr	r3, [r3, #8]
3419dc72:	f107 0212 	add.w	r2, r7, #18
3419dc76:	2112      	movs	r1, #18
3419dc78:	68f8      	ldr	r0, [r7, #12]
3419dc7a:	4798      	blx	r3
3419dc7c:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419dc7e:	697b      	ldr	r3, [r7, #20]
3419dc80:	2b00      	cmp	r3, #0
3419dc82:	d00d      	beq.n	3419dca0 <VD55G1_ApplyPatchCommon+0x118>
3419dc84:	697b      	ldr	r3, [r7, #20]
3419dc86:	9302      	str	r3, [sp, #8]
3419dc88:	f240 137d 	movw	r3, #381	@ 0x17d
3419dc8c:	9301      	str	r3, [sp, #4]
3419dc8e:	4b3d      	ldr	r3, [pc, #244]	@ (3419dd84 <VD55G1_ApplyPatchCommon+0x1fc>)
3419dc90:	9300      	str	r3, [sp, #0]
3419dc92:	f240 137d 	movw	r3, #381	@ 0x17d
3419dc96:	4a3c      	ldr	r2, [pc, #240]	@ (3419dd88 <VD55G1_ApplyPatchCommon+0x200>)
3419dc98:	2100      	movs	r1, #0
3419dc9a:	68f8      	ldr	r0, [r7, #12]
3419dc9c:	f7ff fdc4 	bl	3419d828 <VD55G1_log_impl>
3419dca0:	697b      	ldr	r3, [r7, #20]
3419dca2:	2b00      	cmp	r3, #0
3419dca4:	d002      	beq.n	3419dcac <VD55G1_ApplyPatchCommon+0x124>
3419dca6:	68f8      	ldr	r0, [r7, #12]
3419dca8:	f7ff fdda 	bl	3419d860 <display_error>
3419dcac:	697b      	ldr	r3, [r7, #20]
3419dcae:	2b00      	cmp	r3, #0
3419dcb0:	d001      	beq.n	3419dcb6 <VD55G1_ApplyPatchCommon+0x12e>
3419dcb2:	697b      	ldr	r3, [r7, #20]
3419dcb4:	e062      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>
  VD55G1_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
3419dcb6:	8a7b      	ldrh	r3, [r7, #18]
3419dcb8:	9301      	str	r3, [sp, #4]
3419dcba:	f44f 73bf 	mov.w	r3, #382	@ 0x17e
3419dcbe:	9300      	str	r3, [sp, #0]
3419dcc0:	2300      	movs	r3, #0
3419dcc2:	4a32      	ldr	r2, [pc, #200]	@ (3419dd8c <VD55G1_ApplyPatchCommon+0x204>)
3419dcc4:	2103      	movs	r1, #3
3419dcc6:	68f8      	ldr	r0, [r7, #12]
3419dcc8:	f7ff fdae 	bl	3419d828 <VD55G1_log_impl>

  if (reg16 != (patch_major << 8) + patch_minor) {
3419dccc:	8a7b      	ldrh	r3, [r7, #18]
3419dcce:	4619      	mov	r1, r3
3419dcd0:	78fb      	ldrb	r3, [r7, #3]
3419dcd2:	021a      	lsls	r2, r3, #8
3419dcd4:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
3419dcd8:	4413      	add	r3, r2
3419dcda:	4299      	cmp	r1, r3
3419dcdc:	d016      	beq.n	3419dd0c <VD55G1_ApplyPatchCommon+0x184>
    VD55G1_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor, reg16 >> 8, reg16 & 0xff);
3419dcde:	78fb      	ldrb	r3, [r7, #3]
3419dce0:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
3419dce4:	8a79      	ldrh	r1, [r7, #18]
3419dce6:	0a09      	lsrs	r1, r1, #8
3419dce8:	b289      	uxth	r1, r1
3419dcea:	4608      	mov	r0, r1
3419dcec:	8a79      	ldrh	r1, [r7, #18]
3419dcee:	b2c9      	uxtb	r1, r1
3419dcf0:	9103      	str	r1, [sp, #12]
3419dcf2:	9002      	str	r0, [sp, #8]
3419dcf4:	9201      	str	r2, [sp, #4]
3419dcf6:	9300      	str	r3, [sp, #0]
3419dcf8:	f240 1381 	movw	r3, #385	@ 0x181
3419dcfc:	4a24      	ldr	r2, [pc, #144]	@ (3419dd90 <VD55G1_ApplyPatchCommon+0x208>)
3419dcfe:	2100      	movs	r1, #0
3419dd00:	68f8      	ldr	r0, [r7, #12]
3419dd02:	f7ff fd91 	bl	3419d828 <VD55G1_log_impl>
    return -1;
3419dd06:	f04f 33ff 	mov.w	r3, #4294967295
3419dd0a:	e037      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>
  }
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
3419dd0c:	8a7b      	ldrh	r3, [r7, #18]
3419dd0e:	0a1b      	lsrs	r3, r3, #8
3419dd10:	b29b      	uxth	r3, r3
3419dd12:	461a      	mov	r2, r3
3419dd14:	8a7b      	ldrh	r3, [r7, #18]
3419dd16:	b2db      	uxtb	r3, r3
3419dd18:	9301      	str	r3, [sp, #4]
3419dd1a:	9200      	str	r2, [sp, #0]
3419dd1c:	f44f 73c2 	mov.w	r3, #388	@ 0x184
3419dd20:	4a1c      	ldr	r2, [pc, #112]	@ (3419dd94 <VD55G1_ApplyPatchCommon+0x20c>)
3419dd22:	2102      	movs	r1, #2
3419dd24:	68f8      	ldr	r0, [r7, #12]
3419dd26:	f7ff fd7f 	bl	3419d828 <VD55G1_log_impl>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
3419dd2a:	2102      	movs	r1, #2
3419dd2c:	68f8      	ldr	r0, [r7, #12]
3419dd2e:	f7ff fe21 	bl	3419d974 <VD55G1_WaitState>
3419dd32:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419dd34:	697b      	ldr	r3, [r7, #20]
3419dd36:	2b00      	cmp	r3, #0
3419dd38:	d00d      	beq.n	3419dd56 <VD55G1_ApplyPatchCommon+0x1ce>
3419dd3a:	697b      	ldr	r3, [r7, #20]
3419dd3c:	9302      	str	r3, [sp, #8]
3419dd3e:	f240 1387 	movw	r3, #391	@ 0x187
3419dd42:	9301      	str	r3, [sp, #4]
3419dd44:	4b0f      	ldr	r3, [pc, #60]	@ (3419dd84 <VD55G1_ApplyPatchCommon+0x1fc>)
3419dd46:	9300      	str	r3, [sp, #0]
3419dd48:	f240 1387 	movw	r3, #391	@ 0x187
3419dd4c:	4a0e      	ldr	r2, [pc, #56]	@ (3419dd88 <VD55G1_ApplyPatchCommon+0x200>)
3419dd4e:	2100      	movs	r1, #0
3419dd50:	68f8      	ldr	r0, [r7, #12]
3419dd52:	f7ff fd69 	bl	3419d828 <VD55G1_log_impl>
3419dd56:	697b      	ldr	r3, [r7, #20]
3419dd58:	2b00      	cmp	r3, #0
3419dd5a:	d002      	beq.n	3419dd62 <VD55G1_ApplyPatchCommon+0x1da>
3419dd5c:	68f8      	ldr	r0, [r7, #12]
3419dd5e:	f7ff fd7f 	bl	3419d860 <display_error>
3419dd62:	697b      	ldr	r3, [r7, #20]
3419dd64:	2b00      	cmp	r3, #0
3419dd66:	d001      	beq.n	3419dd6c <VD55G1_ApplyPatchCommon+0x1e4>
3419dd68:	697b      	ldr	r3, [r7, #20]
3419dd6a:	e007      	b.n	3419dd7c <VD55G1_ApplyPatchCommon+0x1f4>

  VD55G1_notice(ctx, "sensor boot successfully\n");
3419dd6c:	f240 1389 	movw	r3, #393	@ 0x189
3419dd70:	4a09      	ldr	r2, [pc, #36]	@ (3419dd98 <VD55G1_ApplyPatchCommon+0x210>)
3419dd72:	2102      	movs	r1, #2
3419dd74:	68f8      	ldr	r0, [r7, #12]
3419dd76:	f7ff fd57 	bl	3419d828 <VD55G1_log_impl>

  return 0;
3419dd7a:	2300      	movs	r3, #0
}
3419dd7c:	4618      	mov	r0, r3
3419dd7e:	371c      	adds	r7, #28
3419dd80:	46bd      	mov	sp, r7
3419dd82:	bd90      	pop	{r4, r7, pc}
3419dd84:	341b2f08 	.word	0x341b2f08
3419dd88:	341a60e4 	.word	0x341a60e4
3419dd8c:	341a6250 	.word	0x341a6250
3419dd90:	341a6274 	.word	0x341a6274
3419dd94:	341a62b0 	.word	0x341a62b0
3419dd98:	341a62d8 	.word	0x341a62d8

3419dd9c <VD55G1_ApplyPatch>:

static int VD55G1_ApplyPatch(VD55G1_Ctx_t *ctx)
{
3419dd9c:	b580      	push	{r7, lr}
3419dd9e:	b086      	sub	sp, #24
3419dda0:	af02      	add	r7, sp, #8
3419dda2:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419dda4:	687b      	ldr	r3, [r7, #4]
3419dda6:	3328      	adds	r3, #40	@ 0x28
3419dda8:	60fb      	str	r3, [r7, #12]

  switch (drv_ctx->cut_version) {
3419ddaa:	68fb      	ldr	r3, [r7, #12]
3419ddac:	685b      	ldr	r3, [r3, #4]
3419ddae:	f241 0210 	movw	r2, #4112	@ 0x1010
3419ddb2:	4293      	cmp	r3, r2
3419ddb4:	d004      	beq.n	3419ddc0 <VD55G1_ApplyPatch+0x24>
3419ddb6:	f242 0220 	movw	r2, #8224	@ 0x2020
3419ddba:	4293      	cmp	r3, r2
3419ddbc:	d00b      	beq.n	3419ddd6 <VD55G1_ApplyPatch+0x3a>
3419ddbe:	e015      	b.n	3419ddec <VD55G1_ApplyPatch+0x50>
  case VD55G1_REVISION_CUT_1:
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_1, sizeof(patch_array_cut_1),
3419ddc0:	2316      	movs	r3, #22
3419ddc2:	9300      	str	r3, [sp, #0]
3419ddc4:	2301      	movs	r3, #1
3419ddc6:	f241 22e4 	movw	r2, #4836	@ 0x12e4
3419ddca:	490e      	ldr	r1, [pc, #56]	@ (3419de04 <VD55G1_ApplyPatch+0x68>)
3419ddcc:	6878      	ldr	r0, [r7, #4]
3419ddce:	f7ff fedb 	bl	3419db88 <VD55G1_ApplyPatchCommon>
3419ddd2:	4603      	mov	r3, r0
3419ddd4:	e011      	b.n	3419ddfa <VD55G1_ApplyPatch+0x5e>
                                   VD55G1_FWPATCH_REVISION_MAJOR_CUT_1, VD55G1_FWPATCH_REVISION_MINOR_CUT_1);
  case VD55G1_REVISION_CUT_2:
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
3419ddd6:	2302      	movs	r3, #2
3419ddd8:	9300      	str	r3, [sp, #0]
3419ddda:	2302      	movs	r3, #2
3419dddc:	f44f 7272 	mov.w	r2, #968	@ 0x3c8
3419dde0:	4909      	ldr	r1, [pc, #36]	@ (3419de08 <VD55G1_ApplyPatch+0x6c>)
3419dde2:	6878      	ldr	r0, [r7, #4]
3419dde4:	f7ff fed0 	bl	3419db88 <VD55G1_ApplyPatchCommon>
3419dde8:	4603      	mov	r3, r0
3419ddea:	e006      	b.n	3419ddfa <VD55G1_ApplyPatch+0x5e>
                                   VD55G1_FWPATCH_REVISION_MAJOR_CUT_2, VD55G1_FWPATCH_REVISION_MINOR_CUT_2);
  default:
    assert(0);
3419ddec:	4b07      	ldr	r3, [pc, #28]	@ (3419de0c <VD55G1_ApplyPatch+0x70>)
3419ddee:	4a08      	ldr	r2, [pc, #32]	@ (3419de10 <VD55G1_ApplyPatch+0x74>)
3419ddf0:	f44f 71cd 	mov.w	r1, #410	@ 0x19a
3419ddf4:	4807      	ldr	r0, [pc, #28]	@ (3419de14 <VD55G1_ApplyPatch+0x78>)
3419ddf6:	f005 fd4b 	bl	341a3890 <__assert_func>
  }

  return -1;
}
3419ddfa:	4618      	mov	r0, r3
3419ddfc:	3710      	adds	r7, #16
3419ddfe:	46bd      	mov	sp, r7
3419de00:	bd80      	pop	{r7, pc}
3419de02:	bf00      	nop
3419de04:	341b17c8 	.word	0x341b17c8
3419de08:	341b2aac 	.word	0x341b2aac
3419de0c:	341a6304 	.word	0x341a6304
3419de10:	341b2f20 	.word	0x341b2f20
3419de14:	341a6080 	.word	0x341a6080

3419de18 <VD55G1_Gpios>:

static int VD55G1_Gpios(VD55G1_Ctx_t *ctx)
 {
3419de18:	b580      	push	{r7, lr}
3419de1a:	b08a      	sub	sp, #40	@ 0x28
3419de1c:	af04      	add	r7, sp, #16
3419de1e:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419de20:	687b      	ldr	r3, [r7, #4]
3419de22:	3328      	adds	r3, #40	@ 0x28
3419de24:	613b      	str	r3, [r7, #16]
  int ret;
  int i;

  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3419de26:	2300      	movs	r3, #0
3419de28:	617b      	str	r3, [r7, #20]
3419de2a:	e02e      	b.n	3419de8a <VD55G1_Gpios+0x72>
  {
    ret = ctx->write8(ctx, VD55G1_REG_GPIO_x(i), drv_ctx->config_save.gpio_ctrl[i]);
3419de2c:	687b      	ldr	r3, [r7, #4]
3419de2e:	691b      	ldr	r3, [r3, #16]
3419de30:	697a      	ldr	r2, [r7, #20]
3419de32:	b292      	uxth	r2, r2
3419de34:	f202 521d 	addw	r2, r2, #1309	@ 0x51d
3419de38:	b290      	uxth	r0, r2
3419de3a:	6939      	ldr	r1, [r7, #16]
3419de3c:	697a      	ldr	r2, [r7, #20]
3419de3e:	440a      	add	r2, r1
3419de40:	323c      	adds	r2, #60	@ 0x3c
3419de42:	7812      	ldrb	r2, [r2, #0]
3419de44:	4601      	mov	r1, r0
3419de46:	6878      	ldr	r0, [r7, #4]
3419de48:	4798      	blx	r3
3419de4a:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419de4c:	68fb      	ldr	r3, [r7, #12]
3419de4e:	2b00      	cmp	r3, #0
3419de50:	d00d      	beq.n	3419de6e <VD55G1_Gpios+0x56>
3419de52:	68fb      	ldr	r3, [r7, #12]
3419de54:	9302      	str	r3, [sp, #8]
3419de56:	f240 13a9 	movw	r3, #425	@ 0x1a9
3419de5a:	9301      	str	r3, [sp, #4]
3419de5c:	4b0f      	ldr	r3, [pc, #60]	@ (3419de9c <VD55G1_Gpios+0x84>)
3419de5e:	9300      	str	r3, [sp, #0]
3419de60:	f240 13a9 	movw	r3, #425	@ 0x1a9
3419de64:	4a0e      	ldr	r2, [pc, #56]	@ (3419dea0 <VD55G1_Gpios+0x88>)
3419de66:	2100      	movs	r1, #0
3419de68:	6878      	ldr	r0, [r7, #4]
3419de6a:	f7ff fcdd 	bl	3419d828 <VD55G1_log_impl>
3419de6e:	68fb      	ldr	r3, [r7, #12]
3419de70:	2b00      	cmp	r3, #0
3419de72:	d002      	beq.n	3419de7a <VD55G1_Gpios+0x62>
3419de74:	6878      	ldr	r0, [r7, #4]
3419de76:	f7ff fcf3 	bl	3419d860 <display_error>
3419de7a:	68fb      	ldr	r3, [r7, #12]
3419de7c:	2b00      	cmp	r3, #0
3419de7e:	d001      	beq.n	3419de84 <VD55G1_Gpios+0x6c>
3419de80:	68fb      	ldr	r3, [r7, #12]
3419de82:	e006      	b.n	3419de92 <VD55G1_Gpios+0x7a>
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3419de84:	697b      	ldr	r3, [r7, #20]
3419de86:	3301      	adds	r3, #1
3419de88:	617b      	str	r3, [r7, #20]
3419de8a:	697b      	ldr	r3, [r7, #20]
3419de8c:	2b03      	cmp	r3, #3
3419de8e:	ddcd      	ble.n	3419de2c <VD55G1_Gpios+0x14>
  }

  return 0;
3419de90:	2300      	movs	r3, #0
}
3419de92:	4618      	mov	r0, r3
3419de94:	3718      	adds	r7, #24
3419de96:	46bd      	mov	sp, r7
3419de98:	bd80      	pop	{r7, pc}
3419de9a:	bf00      	nop
3419de9c:	341b2f34 	.word	0x341b2f34
3419dea0:	341a60e4 	.word	0x341a60e4

3419dea4 <VD55G1_Boot>:

static int VD55G1_Boot(VD55G1_Ctx_t *ctx)
{
3419dea4:	b580      	push	{r7, lr}
3419dea6:	b084      	sub	sp, #16
3419dea8:	af00      	add	r7, sp, #0
3419deaa:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_READY_TO_BOOT);
3419deac:	2101      	movs	r1, #1
3419deae:	6878      	ldr	r0, [r7, #4]
3419deb0:	f7ff fd60 	bl	3419d974 <VD55G1_WaitState>
3419deb4:	60f8      	str	r0, [r7, #12]
  if (ret)
3419deb6:	68fb      	ldr	r3, [r7, #12]
3419deb8:	2b00      	cmp	r3, #0
3419deba:	d001      	beq.n	3419dec0 <VD55G1_Boot+0x1c>
    return ret;
3419debc:	68fb      	ldr	r3, [r7, #12]
3419debe:	e01b      	b.n	3419def8 <VD55G1_Boot+0x54>

  ret = VD55G1_CheckModelId(ctx);
3419dec0:	6878      	ldr	r0, [r7, #4]
3419dec2:	f7ff fd85 	bl	3419d9d0 <VD55G1_CheckModelId>
3419dec6:	60f8      	str	r0, [r7, #12]
  if (ret)
3419dec8:	68fb      	ldr	r3, [r7, #12]
3419deca:	2b00      	cmp	r3, #0
3419decc:	d001      	beq.n	3419ded2 <VD55G1_Boot+0x2e>
    return ret;
3419dece:	68fb      	ldr	r3, [r7, #12]
3419ded0:	e012      	b.n	3419def8 <VD55G1_Boot+0x54>

  ret = VD55G1_ApplyPatch(ctx);
3419ded2:	6878      	ldr	r0, [r7, #4]
3419ded4:	f7ff ff62 	bl	3419dd9c <VD55G1_ApplyPatch>
3419ded8:	60f8      	str	r0, [r7, #12]
  if (ret)
3419deda:	68fb      	ldr	r3, [r7, #12]
3419dedc:	2b00      	cmp	r3, #0
3419dede:	d001      	beq.n	3419dee4 <VD55G1_Boot+0x40>
    return ret;
3419dee0:	68fb      	ldr	r3, [r7, #12]
3419dee2:	e009      	b.n	3419def8 <VD55G1_Boot+0x54>

  ret = VD55G1_Gpios(ctx);
3419dee4:	6878      	ldr	r0, [r7, #4]
3419dee6:	f7ff ff97 	bl	3419de18 <VD55G1_Gpios>
3419deea:	60f8      	str	r0, [r7, #12]
  if (ret)
3419deec:	68fb      	ldr	r3, [r7, #12]
3419deee:	2b00      	cmp	r3, #0
3419def0:	d001      	beq.n	3419def6 <VD55G1_Boot+0x52>
    return ret;
3419def2:	68fb      	ldr	r3, [r7, #12]
3419def4:	e000      	b.n	3419def8 <VD55G1_Boot+0x54>

  return 0;
3419def6:	2300      	movs	r3, #0
}
3419def8:	4618      	mov	r0, r3
3419defa:	3710      	adds	r7, #16
3419defc:	46bd      	mov	sp, r7
3419defe:	bd80      	pop	{r7, pc}

3419df00 <VD55G1_GetSystemClock>:

static uint32_t VD55G1_GetSystemClock(VD55G1_Ctx_t *ctx)
{
3419df00:	b580      	push	{r7, lr}
3419df02:	b084      	sub	sp, #16
3419df04:	af00      	add	r7, sp, #0
3419df06:	6078      	str	r0, [r7, #4]
  uint32_t mipi_data_rate;
  int ret;

  ret = ctx->read32(ctx, VD55G1_REG_MIPI_DATA_RATE, &mipi_data_rate);
3419df08:	687b      	ldr	r3, [r7, #4]
3419df0a:	68db      	ldr	r3, [r3, #12]
3419df0c:	f107 0208 	add.w	r2, r7, #8
3419df10:	f44f 7109 	mov.w	r1, #548	@ 0x224
3419df14:	6878      	ldr	r0, [r7, #4]
3419df16:	4798      	blx	r3
3419df18:	60f8      	str	r0, [r7, #12]
  if (ret)
3419df1a:	68fb      	ldr	r3, [r7, #12]
3419df1c:	2b00      	cmp	r3, #0
3419df1e:	d001      	beq.n	3419df24 <VD55G1_GetSystemClock+0x24>
    return 0;
3419df20:	2300      	movs	r3, #0
3419df22:	e020      	b.n	3419df66 <VD55G1_GetSystemClock+0x66>

  if (mipi_data_rate <= 1200000000 && mipi_data_rate > 600000000)
3419df24:	68bb      	ldr	r3, [r7, #8]
3419df26:	4a12      	ldr	r2, [pc, #72]	@ (3419df70 <VD55G1_GetSystemClock+0x70>)
3419df28:	4293      	cmp	r3, r2
3419df2a:	d805      	bhi.n	3419df38 <VD55G1_GetSystemClock+0x38>
3419df2c:	68bb      	ldr	r3, [r7, #8]
3419df2e:	4a11      	ldr	r2, [pc, #68]	@ (3419df74 <VD55G1_GetSystemClock+0x74>)
3419df30:	4293      	cmp	r3, r2
3419df32:	d901      	bls.n	3419df38 <VD55G1_GetSystemClock+0x38>
    return mipi_data_rate;
3419df34:	68bb      	ldr	r3, [r7, #8]
3419df36:	e016      	b.n	3419df66 <VD55G1_GetSystemClock+0x66>
  else if (mipi_data_rate <= 600000000 && mipi_data_rate > 300000000)
3419df38:	68bb      	ldr	r3, [r7, #8]
3419df3a:	4a0e      	ldr	r2, [pc, #56]	@ (3419df74 <VD55G1_GetSystemClock+0x74>)
3419df3c:	4293      	cmp	r3, r2
3419df3e:	d806      	bhi.n	3419df4e <VD55G1_GetSystemClock+0x4e>
3419df40:	68bb      	ldr	r3, [r7, #8]
3419df42:	4a0d      	ldr	r2, [pc, #52]	@ (3419df78 <VD55G1_GetSystemClock+0x78>)
3419df44:	4293      	cmp	r3, r2
3419df46:	d902      	bls.n	3419df4e <VD55G1_GetSystemClock+0x4e>
    return mipi_data_rate * 2;
3419df48:	68bb      	ldr	r3, [r7, #8]
3419df4a:	005b      	lsls	r3, r3, #1
3419df4c:	e00b      	b.n	3419df66 <VD55G1_GetSystemClock+0x66>
  else if (mipi_data_rate <= 300000000 && mipi_data_rate >= 250000000)
3419df4e:	68bb      	ldr	r3, [r7, #8]
3419df50:	4a09      	ldr	r2, [pc, #36]	@ (3419df78 <VD55G1_GetSystemClock+0x78>)
3419df52:	4293      	cmp	r3, r2
3419df54:	d806      	bhi.n	3419df64 <VD55G1_GetSystemClock+0x64>
3419df56:	68bb      	ldr	r3, [r7, #8]
3419df58:	4a08      	ldr	r2, [pc, #32]	@ (3419df7c <VD55G1_GetSystemClock+0x7c>)
3419df5a:	4293      	cmp	r3, r2
3419df5c:	d902      	bls.n	3419df64 <VD55G1_GetSystemClock+0x64>
    return mipi_data_rate * 4;
3419df5e:	68bb      	ldr	r3, [r7, #8]
3419df60:	009b      	lsls	r3, r3, #2
3419df62:	e000      	b.n	3419df66 <VD55G1_GetSystemClock+0x66>

  return 0;
3419df64:	2300      	movs	r3, #0
}
3419df66:	4618      	mov	r0, r3
3419df68:	3710      	adds	r7, #16
3419df6a:	46bd      	mov	sp, r7
3419df6c:	bd80      	pop	{r7, pc}
3419df6e:	bf00      	nop
3419df70:	47868c00 	.word	0x47868c00
3419df74:	23c34600 	.word	0x23c34600
3419df78:	11e1a300 	.word	0x11e1a300
3419df7c:	0ee6b27f 	.word	0x0ee6b27f

3419df80 <VD55G1_GetPixelClock>:

static uint32_t VD55G1_GetPixelClock(VD55G1_Ctx_t *ctx)
{
3419df80:	b580      	push	{r7, lr}
3419df82:	b084      	sub	sp, #16
3419df84:	af00      	add	r7, sp, #0
3419df86:	6078      	str	r0, [r7, #4]
  uint32_t system_clk;

  system_clk = VD55G1_GetSystemClock(ctx);
3419df88:	6878      	ldr	r0, [r7, #4]
3419df8a:	f7ff ffb9 	bl	3419df00 <VD55G1_GetSystemClock>
3419df8e:	60f8      	str	r0, [r7, #12]
  if (!system_clk)
3419df90:	68fb      	ldr	r3, [r7, #12]
3419df92:	2b00      	cmp	r3, #0
3419df94:	d101      	bne.n	3419df9a <VD55G1_GetPixelClock+0x1a>
    return 0;
3419df96:	2300      	movs	r3, #0
3419df98:	e027      	b.n	3419dfea <VD55G1_GetPixelClock+0x6a>

  if (system_clk <= 1200000000 && system_clk > 900000000)
3419df9a:	68fb      	ldr	r3, [r7, #12]
3419df9c:	4a15      	ldr	r2, [pc, #84]	@ (3419dff4 <VD55G1_GetPixelClock+0x74>)
3419df9e:	4293      	cmp	r3, r2
3419dfa0:	d806      	bhi.n	3419dfb0 <VD55G1_GetPixelClock+0x30>
3419dfa2:	68fb      	ldr	r3, [r7, #12]
3419dfa4:	4a14      	ldr	r2, [pc, #80]	@ (3419dff8 <VD55G1_GetPixelClock+0x78>)
3419dfa6:	4293      	cmp	r3, r2
3419dfa8:	d902      	bls.n	3419dfb0 <VD55G1_GetPixelClock+0x30>
    return system_clk / 8;
3419dfaa:	68fb      	ldr	r3, [r7, #12]
3419dfac:	08db      	lsrs	r3, r3, #3
3419dfae:	e01c      	b.n	3419dfea <VD55G1_GetPixelClock+0x6a>
  else if (system_clk <= 900000000 && system_clk > 780000000)
3419dfb0:	68fb      	ldr	r3, [r7, #12]
3419dfb2:	4a11      	ldr	r2, [pc, #68]	@ (3419dff8 <VD55G1_GetPixelClock+0x78>)
3419dfb4:	4293      	cmp	r3, r2
3419dfb6:	d809      	bhi.n	3419dfcc <VD55G1_GetPixelClock+0x4c>
3419dfb8:	68fb      	ldr	r3, [r7, #12]
3419dfba:	4a10      	ldr	r2, [pc, #64]	@ (3419dffc <VD55G1_GetPixelClock+0x7c>)
3419dfbc:	4293      	cmp	r3, r2
3419dfbe:	d905      	bls.n	3419dfcc <VD55G1_GetPixelClock+0x4c>
    return system_clk / 6;
3419dfc0:	68fb      	ldr	r3, [r7, #12]
3419dfc2:	4a0f      	ldr	r2, [pc, #60]	@ (3419e000 <VD55G1_GetPixelClock+0x80>)
3419dfc4:	fba2 2303 	umull	r2, r3, r2, r3
3419dfc8:	089b      	lsrs	r3, r3, #2
3419dfca:	e00e      	b.n	3419dfea <VD55G1_GetPixelClock+0x6a>
  else if (system_clk <= 780000000 && system_clk >= 600000000)
3419dfcc:	68fb      	ldr	r3, [r7, #12]
3419dfce:	4a0b      	ldr	r2, [pc, #44]	@ (3419dffc <VD55G1_GetPixelClock+0x7c>)
3419dfd0:	4293      	cmp	r3, r2
3419dfd2:	d809      	bhi.n	3419dfe8 <VD55G1_GetPixelClock+0x68>
3419dfd4:	68fb      	ldr	r3, [r7, #12]
3419dfd6:	4a0b      	ldr	r2, [pc, #44]	@ (3419e004 <VD55G1_GetPixelClock+0x84>)
3419dfd8:	4293      	cmp	r3, r2
3419dfda:	d905      	bls.n	3419dfe8 <VD55G1_GetPixelClock+0x68>
    return system_clk / 5;
3419dfdc:	68fb      	ldr	r3, [r7, #12]
3419dfde:	4a0a      	ldr	r2, [pc, #40]	@ (3419e008 <VD55G1_GetPixelClock+0x88>)
3419dfe0:	fba2 2303 	umull	r2, r3, r2, r3
3419dfe4:	089b      	lsrs	r3, r3, #2
3419dfe6:	e000      	b.n	3419dfea <VD55G1_GetPixelClock+0x6a>

  return 0;
3419dfe8:	2300      	movs	r3, #0
}
3419dfea:	4618      	mov	r0, r3
3419dfec:	3710      	adds	r7, #16
3419dfee:	46bd      	mov	sp, r7
3419dff0:	bd80      	pop	{r7, pc}
3419dff2:	bf00      	nop
3419dff4:	47868c00 	.word	0x47868c00
3419dff8:	35a4e900 	.word	0x35a4e900
3419dffc:	2e7ddb00 	.word	0x2e7ddb00
3419e000:	aaaaaaab 	.word	0xaaaaaaab
3419e004:	23c345ff 	.word	0x23c345ff
3419e008:	cccccccd 	.word	0xcccccccd

3419e00c <VD55G1_SetupClocks>:

static int VD55G1_SetupClocks(VD55G1_Ctx_t *ctx)
{
3419e00c:	b580      	push	{r7, lr}
3419e00e:	b088      	sub	sp, #32
3419e010:	af04      	add	r7, sp, #16
3419e012:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e014:	687b      	ldr	r3, [r7, #4]
3419e016:	3328      	adds	r3, #40	@ 0x28
3419e018:	60fb      	str	r3, [r7, #12]
  int ret;

  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
3419e01a:	68fb      	ldr	r3, [r7, #12]
3419e01c:	69db      	ldr	r3, [r3, #28]
3419e01e:	4a33      	ldr	r2, [pc, #204]	@ (3419e0ec <VD55G1_SetupClocks+0xe0>)
3419e020:	4293      	cmp	r3, r2
3419e022:	dd04      	ble.n	3419e02e <VD55G1_SetupClocks+0x22>
      drv_ctx->config_save.out_itf.data_rate_in_mps > VD55G1_MAX_DATARATE)
3419e024:	68fb      	ldr	r3, [r7, #12]
3419e026:	69db      	ldr	r3, [r3, #28]
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
3419e028:	4a31      	ldr	r2, [pc, #196]	@ (3419e0f0 <VD55G1_SetupClocks+0xe4>)
3419e02a:	4293      	cmp	r3, r2
3419e02c:	dd02      	ble.n	3419e034 <VD55G1_SetupClocks+0x28>
    return -1;
3419e02e:	f04f 33ff 	mov.w	r3, #4294967295
3419e032:	e057      	b.n	3419e0e4 <VD55G1_SetupClocks+0xd8>

  ret = ctx->write32(ctx, VD55G1_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
3419e034:	687b      	ldr	r3, [r7, #4]
3419e036:	699b      	ldr	r3, [r3, #24]
3419e038:	68fa      	ldr	r2, [r7, #12]
3419e03a:	68d2      	ldr	r2, [r2, #12]
3419e03c:	f44f 7108 	mov.w	r1, #544	@ 0x220
3419e040:	6878      	ldr	r0, [r7, #4]
3419e042:	4798      	blx	r3
3419e044:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419e046:	68bb      	ldr	r3, [r7, #8]
3419e048:	2b00      	cmp	r3, #0
3419e04a:	d00d      	beq.n	3419e068 <VD55G1_SetupClocks+0x5c>
3419e04c:	68bb      	ldr	r3, [r7, #8]
3419e04e:	9302      	str	r3, [sp, #8]
3419e050:	f240 13f5 	movw	r3, #501	@ 0x1f5
3419e054:	9301      	str	r3, [sp, #4]
3419e056:	4b27      	ldr	r3, [pc, #156]	@ (3419e0f4 <VD55G1_SetupClocks+0xe8>)
3419e058:	9300      	str	r3, [sp, #0]
3419e05a:	f240 13f5 	movw	r3, #501	@ 0x1f5
3419e05e:	4a26      	ldr	r2, [pc, #152]	@ (3419e0f8 <VD55G1_SetupClocks+0xec>)
3419e060:	2100      	movs	r1, #0
3419e062:	6878      	ldr	r0, [r7, #4]
3419e064:	f7ff fbe0 	bl	3419d828 <VD55G1_log_impl>
3419e068:	68bb      	ldr	r3, [r7, #8]
3419e06a:	2b00      	cmp	r3, #0
3419e06c:	d002      	beq.n	3419e074 <VD55G1_SetupClocks+0x68>
3419e06e:	6878      	ldr	r0, [r7, #4]
3419e070:	f7ff fbf6 	bl	3419d860 <display_error>
3419e074:	68bb      	ldr	r3, [r7, #8]
3419e076:	2b00      	cmp	r3, #0
3419e078:	d001      	beq.n	3419e07e <VD55G1_SetupClocks+0x72>
3419e07a:	68bb      	ldr	r3, [r7, #8]
3419e07c:	e032      	b.n	3419e0e4 <VD55G1_SetupClocks+0xd8>

  ret = ctx->write32(ctx, VD55G1_REG_MIPI_DATA_RATE, drv_ctx->config_save.out_itf.data_rate_in_mps);
3419e07e:	687b      	ldr	r3, [r7, #4]
3419e080:	699b      	ldr	r3, [r3, #24]
3419e082:	68fa      	ldr	r2, [r7, #12]
3419e084:	69d2      	ldr	r2, [r2, #28]
3419e086:	f44f 7109 	mov.w	r1, #548	@ 0x224
3419e08a:	6878      	ldr	r0, [r7, #4]
3419e08c:	4798      	blx	r3
3419e08e:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419e090:	68bb      	ldr	r3, [r7, #8]
3419e092:	2b00      	cmp	r3, #0
3419e094:	d00d      	beq.n	3419e0b2 <VD55G1_SetupClocks+0xa6>
3419e096:	68bb      	ldr	r3, [r7, #8]
3419e098:	9302      	str	r3, [sp, #8]
3419e09a:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
3419e09e:	9301      	str	r3, [sp, #4]
3419e0a0:	4b14      	ldr	r3, [pc, #80]	@ (3419e0f4 <VD55G1_SetupClocks+0xe8>)
3419e0a2:	9300      	str	r3, [sp, #0]
3419e0a4:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
3419e0a8:	4a13      	ldr	r2, [pc, #76]	@ (3419e0f8 <VD55G1_SetupClocks+0xec>)
3419e0aa:	2100      	movs	r1, #0
3419e0ac:	6878      	ldr	r0, [r7, #4]
3419e0ae:	f7ff fbbb 	bl	3419d828 <VD55G1_log_impl>
3419e0b2:	68bb      	ldr	r3, [r7, #8]
3419e0b4:	2b00      	cmp	r3, #0
3419e0b6:	d002      	beq.n	3419e0be <VD55G1_SetupClocks+0xb2>
3419e0b8:	6878      	ldr	r0, [r7, #4]
3419e0ba:	f7ff fbd1 	bl	3419d860 <display_error>
3419e0be:	68bb      	ldr	r3, [r7, #8]
3419e0c0:	2b00      	cmp	r3, #0
3419e0c2:	d001      	beq.n	3419e0c8 <VD55G1_SetupClocks+0xbc>
3419e0c4:	68bb      	ldr	r3, [r7, #8]
3419e0c6:	e00d      	b.n	3419e0e4 <VD55G1_SetupClocks+0xd8>

  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
3419e0c8:	6878      	ldr	r0, [r7, #4]
3419e0ca:	f7ff ff59 	bl	3419df80 <VD55G1_GetPixelClock>
3419e0ce:	4602      	mov	r2, r0
3419e0d0:	68fb      	ldr	r3, [r7, #12]
3419e0d2:	609a      	str	r2, [r3, #8]
  if (!drv_ctx->pclk)
3419e0d4:	68fb      	ldr	r3, [r7, #12]
3419e0d6:	689b      	ldr	r3, [r3, #8]
3419e0d8:	2b00      	cmp	r3, #0
3419e0da:	d102      	bne.n	3419e0e2 <VD55G1_SetupClocks+0xd6>
    return -1;
3419e0dc:	f04f 33ff 	mov.w	r3, #4294967295
3419e0e0:	e000      	b.n	3419e0e4 <VD55G1_SetupClocks+0xd8>

  return 0;
3419e0e2:	2300      	movs	r3, #0
}
3419e0e4:	4618      	mov	r0, r3
3419e0e6:	3710      	adds	r7, #16
3419e0e8:	46bd      	mov	sp, r7
3419e0ea:	bd80      	pop	{r7, pc}
3419e0ec:	0ee6b27f 	.word	0x0ee6b27f
3419e0f0:	47868c00 	.word	0x47868c00
3419e0f4:	341b2f44 	.word	0x341b2f44
3419e0f8:	341a60e4 	.word	0x341a60e4

3419e0fc <VD55G1_SetupOutput>:

static int VD55G1_SetupOutput(VD55G1_Ctx_t *ctx)
{
3419e0fc:	b580      	push	{r7, lr}
3419e0fe:	b08a      	sub	sp, #40	@ 0x28
3419e100:	af04      	add	r7, sp, #16
3419e102:	6078      	str	r0, [r7, #4]
  VD55G1_OutItf_Config_t *out_itf = &ctx->ctx.config_save.out_itf;
3419e104:	687b      	ldr	r3, [r7, #4]
3419e106:	3344      	adds	r3, #68	@ 0x44
3419e108:	617b      	str	r3, [r7, #20]
  uint16_t oif_ctrl;
  int ret;

  /* Be sure we got value 0 or 1 */
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
3419e10a:	697b      	ldr	r3, [r7, #20]
3419e10c:	685b      	ldr	r3, [r3, #4]
3419e10e:	2b00      	cmp	r3, #0
3419e110:	bf14      	ite	ne
3419e112:	2301      	movne	r3, #1
3419e114:	2300      	moveq	r3, #0
3419e116:	b2db      	uxtb	r3, r3
3419e118:	461a      	mov	r2, r3
3419e11a:	697b      	ldr	r3, [r7, #20]
3419e11c:	605a      	str	r2, [r3, #4]
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
3419e11e:	697b      	ldr	r3, [r7, #20]
3419e120:	689b      	ldr	r3, [r3, #8]
3419e122:	2b00      	cmp	r3, #0
3419e124:	bf14      	ite	ne
3419e126:	2301      	movne	r3, #1
3419e128:	2300      	moveq	r3, #0
3419e12a:	b2db      	uxtb	r3, r3
3419e12c:	461a      	mov	r2, r3
3419e12e:	697b      	ldr	r3, [r7, #20]
3419e130:	609a      	str	r2, [r3, #8]

  /* raw8 */
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3419e132:	687b      	ldr	r3, [r7, #4]
3419e134:	691b      	ldr	r3, [r3, #16]
3419e136:	2208      	movs	r2, #8
3419e138:	f240 310a 	movw	r1, #778	@ 0x30a
3419e13c:	6878      	ldr	r0, [r7, #4]
3419e13e:	4798      	blx	r3
3419e140:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e142:	693b      	ldr	r3, [r7, #16]
3419e144:	2b00      	cmp	r3, #0
3419e146:	d00d      	beq.n	3419e164 <VD55G1_SetupOutput+0x68>
3419e148:	693b      	ldr	r3, [r7, #16]
3419e14a:	9302      	str	r3, [sp, #8]
3419e14c:	f240 230d 	movw	r3, #525	@ 0x20d
3419e150:	9301      	str	r3, [sp, #4]
3419e152:	4b37      	ldr	r3, [pc, #220]	@ (3419e230 <VD55G1_SetupOutput+0x134>)
3419e154:	9300      	str	r3, [sp, #0]
3419e156:	f240 230d 	movw	r3, #525	@ 0x20d
3419e15a:	4a36      	ldr	r2, [pc, #216]	@ (3419e234 <VD55G1_SetupOutput+0x138>)
3419e15c:	2100      	movs	r1, #0
3419e15e:	6878      	ldr	r0, [r7, #4]
3419e160:	f7ff fb62 	bl	3419d828 <VD55G1_log_impl>
3419e164:	693b      	ldr	r3, [r7, #16]
3419e166:	2b00      	cmp	r3, #0
3419e168:	d002      	beq.n	3419e170 <VD55G1_SetupOutput+0x74>
3419e16a:	6878      	ldr	r0, [r7, #4]
3419e16c:	f7ff fb78 	bl	3419d860 <display_error>
3419e170:	693b      	ldr	r3, [r7, #16]
3419e172:	2b00      	cmp	r3, #0
3419e174:	d001      	beq.n	3419e17a <VD55G1_SetupOutput+0x7e>
3419e176:	693b      	ldr	r3, [r7, #16]
3419e178:	e055      	b.n	3419e226 <VD55G1_SetupOutput+0x12a>

  /* csi lanes */
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
3419e17a:	697b      	ldr	r3, [r7, #20]
3419e17c:	689b      	ldr	r3, [r3, #8]
3419e17e:	b21b      	sxth	r3, r3
3419e180:	019b      	lsls	r3, r3, #6
3419e182:	b21a      	sxth	r2, r3
             out_itf->clock_lane_swap_enable << 3;
3419e184:	697b      	ldr	r3, [r7, #20]
3419e186:	685b      	ldr	r3, [r3, #4]
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
3419e188:	b21b      	sxth	r3, r3
3419e18a:	00db      	lsls	r3, r3, #3
3419e18c:	b21b      	sxth	r3, r3
3419e18e:	4313      	orrs	r3, r2
3419e190:	b21b      	sxth	r3, r3
3419e192:	81fb      	strh	r3, [r7, #14]
  ret = ctx->write16(ctx, VD55G1_REG_OIF_CTRL, oif_ctrl);
3419e194:	687b      	ldr	r3, [r7, #4]
3419e196:	695b      	ldr	r3, [r3, #20]
3419e198:	89fa      	ldrh	r2, [r7, #14]
3419e19a:	f44f 7143 	mov.w	r1, #780	@ 0x30c
3419e19e:	6878      	ldr	r0, [r7, #4]
3419e1a0:	4798      	blx	r3
3419e1a2:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e1a4:	693b      	ldr	r3, [r7, #16]
3419e1a6:	2b00      	cmp	r3, #0
3419e1a8:	d00d      	beq.n	3419e1c6 <VD55G1_SetupOutput+0xca>
3419e1aa:	693b      	ldr	r3, [r7, #16]
3419e1ac:	9302      	str	r3, [sp, #8]
3419e1ae:	f240 2313 	movw	r3, #531	@ 0x213
3419e1b2:	9301      	str	r3, [sp, #4]
3419e1b4:	4b1e      	ldr	r3, [pc, #120]	@ (3419e230 <VD55G1_SetupOutput+0x134>)
3419e1b6:	9300      	str	r3, [sp, #0]
3419e1b8:	f240 2313 	movw	r3, #531	@ 0x213
3419e1bc:	4a1d      	ldr	r2, [pc, #116]	@ (3419e234 <VD55G1_SetupOutput+0x138>)
3419e1be:	2100      	movs	r1, #0
3419e1c0:	6878      	ldr	r0, [r7, #4]
3419e1c2:	f7ff fb31 	bl	3419d828 <VD55G1_log_impl>
3419e1c6:	693b      	ldr	r3, [r7, #16]
3419e1c8:	2b00      	cmp	r3, #0
3419e1ca:	d002      	beq.n	3419e1d2 <VD55G1_SetupOutput+0xd6>
3419e1cc:	6878      	ldr	r0, [r7, #4]
3419e1ce:	f7ff fb47 	bl	3419d860 <display_error>
3419e1d2:	693b      	ldr	r3, [r7, #16]
3419e1d4:	2b00      	cmp	r3, #0
3419e1d6:	d001      	beq.n	3419e1dc <VD55G1_SetupOutput+0xe0>
3419e1d8:	693b      	ldr	r3, [r7, #16]
3419e1da:	e024      	b.n	3419e226 <VD55G1_SetupOutput+0x12a>

  /* data type */
  ret = ctx->write8(ctx, VD55G1_REG_OIF_IMG_CTRL, 0x2a);
3419e1dc:	687b      	ldr	r3, [r7, #4]
3419e1de:	691b      	ldr	r3, [r3, #16]
3419e1e0:	222a      	movs	r2, #42	@ 0x2a
3419e1e2:	f240 310f 	movw	r1, #783	@ 0x30f
3419e1e6:	6878      	ldr	r0, [r7, #4]
3419e1e8:	4798      	blx	r3
3419e1ea:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e1ec:	693b      	ldr	r3, [r7, #16]
3419e1ee:	2b00      	cmp	r3, #0
3419e1f0:	d00d      	beq.n	3419e20e <VD55G1_SetupOutput+0x112>
3419e1f2:	693b      	ldr	r3, [r7, #16]
3419e1f4:	9302      	str	r3, [sp, #8]
3419e1f6:	f240 2317 	movw	r3, #535	@ 0x217
3419e1fa:	9301      	str	r3, [sp, #4]
3419e1fc:	4b0c      	ldr	r3, [pc, #48]	@ (3419e230 <VD55G1_SetupOutput+0x134>)
3419e1fe:	9300      	str	r3, [sp, #0]
3419e200:	f240 2317 	movw	r3, #535	@ 0x217
3419e204:	4a0b      	ldr	r2, [pc, #44]	@ (3419e234 <VD55G1_SetupOutput+0x138>)
3419e206:	2100      	movs	r1, #0
3419e208:	6878      	ldr	r0, [r7, #4]
3419e20a:	f7ff fb0d 	bl	3419d828 <VD55G1_log_impl>
3419e20e:	693b      	ldr	r3, [r7, #16]
3419e210:	2b00      	cmp	r3, #0
3419e212:	d002      	beq.n	3419e21a <VD55G1_SetupOutput+0x11e>
3419e214:	6878      	ldr	r0, [r7, #4]
3419e216:	f7ff fb23 	bl	3419d860 <display_error>
3419e21a:	693b      	ldr	r3, [r7, #16]
3419e21c:	2b00      	cmp	r3, #0
3419e21e:	d001      	beq.n	3419e224 <VD55G1_SetupOutput+0x128>
3419e220:	693b      	ldr	r3, [r7, #16]
3419e222:	e000      	b.n	3419e226 <VD55G1_SetupOutput+0x12a>

  return 0;
3419e224:	2300      	movs	r3, #0
}
3419e226:	4618      	mov	r0, r3
3419e228:	3718      	adds	r7, #24
3419e22a:	46bd      	mov	sp, r7
3419e22c:	bd80      	pop	{r7, pc}
3419e22e:	bf00      	nop
3419e230:	341b2f58 	.word	0x341b2f58
3419e234:	341a60e4 	.word	0x341a60e4

3419e238 <VD55G1_SetupSize>:

static int VD55G1_SetupSize(VD55G1_Ctx_t *ctx)
{
3419e238:	b580      	push	{r7, lr}
3419e23a:	b08a      	sub	sp, #40	@ 0x28
3419e23c:	af04      	add	r7, sp, #16
3419e23e:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e240:	687b      	ldr	r3, [r7, #4]
3419e242:	3328      	adds	r3, #40	@ 0x28
3419e244:	617b      	str	r3, [r7, #20]
  const struct vd55g1_mode *mode;
  int ret;

  mode = VD55G1_Resolution2Mode(drv_ctx->config_save.resolution);
3419e246:	697b      	ldr	r3, [r7, #20]
3419e248:	7c1b      	ldrb	r3, [r3, #16]
3419e24a:	4618      	mov	r0, r3
3419e24c:	f7ff fac0 	bl	3419d7d0 <VD55G1_Resolution2Mode>
3419e250:	6138      	str	r0, [r7, #16]
  if (!mode)
3419e252:	693b      	ldr	r3, [r7, #16]
3419e254:	2b00      	cmp	r3, #0
3419e256:	d102      	bne.n	3419e25e <VD55G1_SetupSize+0x26>
    return -1;
3419e258:	f04f 33ff 	mov.w	r3, #4294967295
3419e25c:	e0bd      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>

  ret = ctx->write8(ctx, VD55G1_REG_READOUT_CTRL, mode->bin_mode);
3419e25e:	687b      	ldr	r3, [r7, #4]
3419e260:	691b      	ldr	r3, [r3, #16]
3419e262:	693a      	ldr	r2, [r7, #16]
3419e264:	7a12      	ldrb	r2, [r2, #8]
3419e266:	f240 512e 	movw	r1, #1326	@ 0x52e
3419e26a:	6878      	ldr	r0, [r7, #4]
3419e26c:	4798      	blx	r3
3419e26e:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e270:	68fb      	ldr	r3, [r7, #12]
3419e272:	2b00      	cmp	r3, #0
3419e274:	d00d      	beq.n	3419e292 <VD55G1_SetupSize+0x5a>
3419e276:	68fb      	ldr	r3, [r7, #12]
3419e278:	9302      	str	r3, [sp, #8]
3419e27a:	f240 2327 	movw	r3, #551	@ 0x227
3419e27e:	9301      	str	r3, [sp, #4]
3419e280:	4b58      	ldr	r3, [pc, #352]	@ (3419e3e4 <VD55G1_SetupSize+0x1ac>)
3419e282:	9300      	str	r3, [sp, #0]
3419e284:	f240 2327 	movw	r3, #551	@ 0x227
3419e288:	4a57      	ldr	r2, [pc, #348]	@ (3419e3e8 <VD55G1_SetupSize+0x1b0>)
3419e28a:	2100      	movs	r1, #0
3419e28c:	6878      	ldr	r0, [r7, #4]
3419e28e:	f7ff facb 	bl	3419d828 <VD55G1_log_impl>
3419e292:	68fb      	ldr	r3, [r7, #12]
3419e294:	2b00      	cmp	r3, #0
3419e296:	d002      	beq.n	3419e29e <VD55G1_SetupSize+0x66>
3419e298:	6878      	ldr	r0, [r7, #4]
3419e29a:	f7ff fae1 	bl	3419d860 <display_error>
3419e29e:	68fb      	ldr	r3, [r7, #12]
3419e2a0:	2b00      	cmp	r3, #0
3419e2a2:	d001      	beq.n	3419e2a8 <VD55G1_SetupSize+0x70>
3419e2a4:	68fb      	ldr	r3, [r7, #12]
3419e2a6:	e098      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>

  ret = ctx->write16(ctx, VD55G1_REG_X_START, mode->crop.left);
3419e2a8:	687b      	ldr	r3, [r7, #4]
3419e2aa:	695b      	ldr	r3, [r3, #20]
3419e2ac:	693a      	ldr	r2, [r7, #16]
3419e2ae:	68d2      	ldr	r2, [r2, #12]
3419e2b0:	b292      	uxth	r2, r2
3419e2b2:	f240 5114 	movw	r1, #1300	@ 0x514
3419e2b6:	6878      	ldr	r0, [r7, #4]
3419e2b8:	4798      	blx	r3
3419e2ba:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e2bc:	68fb      	ldr	r3, [r7, #12]
3419e2be:	2b00      	cmp	r3, #0
3419e2c0:	d00d      	beq.n	3419e2de <VD55G1_SetupSize+0xa6>
3419e2c2:	68fb      	ldr	r3, [r7, #12]
3419e2c4:	9302      	str	r3, [sp, #8]
3419e2c6:	f240 232a 	movw	r3, #554	@ 0x22a
3419e2ca:	9301      	str	r3, [sp, #4]
3419e2cc:	4b45      	ldr	r3, [pc, #276]	@ (3419e3e4 <VD55G1_SetupSize+0x1ac>)
3419e2ce:	9300      	str	r3, [sp, #0]
3419e2d0:	f240 232a 	movw	r3, #554	@ 0x22a
3419e2d4:	4a44      	ldr	r2, [pc, #272]	@ (3419e3e8 <VD55G1_SetupSize+0x1b0>)
3419e2d6:	2100      	movs	r1, #0
3419e2d8:	6878      	ldr	r0, [r7, #4]
3419e2da:	f7ff faa5 	bl	3419d828 <VD55G1_log_impl>
3419e2de:	68fb      	ldr	r3, [r7, #12]
3419e2e0:	2b00      	cmp	r3, #0
3419e2e2:	d002      	beq.n	3419e2ea <VD55G1_SetupSize+0xb2>
3419e2e4:	6878      	ldr	r0, [r7, #4]
3419e2e6:	f7ff fabb 	bl	3419d860 <display_error>
3419e2ea:	68fb      	ldr	r3, [r7, #12]
3419e2ec:	2b00      	cmp	r3, #0
3419e2ee:	d001      	beq.n	3419e2f4 <VD55G1_SetupSize+0xbc>
3419e2f0:	68fb      	ldr	r3, [r7, #12]
3419e2f2:	e072      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_X_WIDTH, mode->crop.width);
3419e2f4:	687b      	ldr	r3, [r7, #4]
3419e2f6:	695b      	ldr	r3, [r3, #20]
3419e2f8:	693a      	ldr	r2, [r7, #16]
3419e2fa:	6952      	ldr	r2, [r2, #20]
3419e2fc:	b292      	uxth	r2, r2
3419e2fe:	f240 5116 	movw	r1, #1302	@ 0x516
3419e302:	6878      	ldr	r0, [r7, #4]
3419e304:	4798      	blx	r3
3419e306:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e308:	68fb      	ldr	r3, [r7, #12]
3419e30a:	2b00      	cmp	r3, #0
3419e30c:	d00d      	beq.n	3419e32a <VD55G1_SetupSize+0xf2>
3419e30e:	68fb      	ldr	r3, [r7, #12]
3419e310:	9302      	str	r3, [sp, #8]
3419e312:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3419e316:	9301      	str	r3, [sp, #4]
3419e318:	4b32      	ldr	r3, [pc, #200]	@ (3419e3e4 <VD55G1_SetupSize+0x1ac>)
3419e31a:	9300      	str	r3, [sp, #0]
3419e31c:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3419e320:	4a31      	ldr	r2, [pc, #196]	@ (3419e3e8 <VD55G1_SetupSize+0x1b0>)
3419e322:	2100      	movs	r1, #0
3419e324:	6878      	ldr	r0, [r7, #4]
3419e326:	f7ff fa7f 	bl	3419d828 <VD55G1_log_impl>
3419e32a:	68fb      	ldr	r3, [r7, #12]
3419e32c:	2b00      	cmp	r3, #0
3419e32e:	d002      	beq.n	3419e336 <VD55G1_SetupSize+0xfe>
3419e330:	6878      	ldr	r0, [r7, #4]
3419e332:	f7ff fa95 	bl	3419d860 <display_error>
3419e336:	68fb      	ldr	r3, [r7, #12]
3419e338:	2b00      	cmp	r3, #0
3419e33a:	d001      	beq.n	3419e340 <VD55G1_SetupSize+0x108>
3419e33c:	68fb      	ldr	r3, [r7, #12]
3419e33e:	e04c      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_Y_START, mode->crop.top);
3419e340:	687b      	ldr	r3, [r7, #4]
3419e342:	695b      	ldr	r3, [r3, #20]
3419e344:	693a      	ldr	r2, [r7, #16]
3419e346:	6912      	ldr	r2, [r2, #16]
3419e348:	b292      	uxth	r2, r2
3419e34a:	f44f 61a2 	mov.w	r1, #1296	@ 0x510
3419e34e:	6878      	ldr	r0, [r7, #4]
3419e350:	4798      	blx	r3
3419e352:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e354:	68fb      	ldr	r3, [r7, #12]
3419e356:	2b00      	cmp	r3, #0
3419e358:	d00d      	beq.n	3419e376 <VD55G1_SetupSize+0x13e>
3419e35a:	68fb      	ldr	r3, [r7, #12]
3419e35c:	9302      	str	r3, [sp, #8]
3419e35e:	f240 232e 	movw	r3, #558	@ 0x22e
3419e362:	9301      	str	r3, [sp, #4]
3419e364:	4b1f      	ldr	r3, [pc, #124]	@ (3419e3e4 <VD55G1_SetupSize+0x1ac>)
3419e366:	9300      	str	r3, [sp, #0]
3419e368:	f240 232e 	movw	r3, #558	@ 0x22e
3419e36c:	4a1e      	ldr	r2, [pc, #120]	@ (3419e3e8 <VD55G1_SetupSize+0x1b0>)
3419e36e:	2100      	movs	r1, #0
3419e370:	6878      	ldr	r0, [r7, #4]
3419e372:	f7ff fa59 	bl	3419d828 <VD55G1_log_impl>
3419e376:	68fb      	ldr	r3, [r7, #12]
3419e378:	2b00      	cmp	r3, #0
3419e37a:	d002      	beq.n	3419e382 <VD55G1_SetupSize+0x14a>
3419e37c:	6878      	ldr	r0, [r7, #4]
3419e37e:	f7ff fa6f 	bl	3419d860 <display_error>
3419e382:	68fb      	ldr	r3, [r7, #12]
3419e384:	2b00      	cmp	r3, #0
3419e386:	d001      	beq.n	3419e38c <VD55G1_SetupSize+0x154>
3419e388:	68fb      	ldr	r3, [r7, #12]
3419e38a:	e026      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_Y_HEIGHT, mode->crop.height);
3419e38c:	687b      	ldr	r3, [r7, #4]
3419e38e:	695b      	ldr	r3, [r3, #20]
3419e390:	693a      	ldr	r2, [r7, #16]
3419e392:	6992      	ldr	r2, [r2, #24]
3419e394:	b292      	uxth	r2, r2
3419e396:	f240 5112 	movw	r1, #1298	@ 0x512
3419e39a:	6878      	ldr	r0, [r7, #4]
3419e39c:	4798      	blx	r3
3419e39e:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e3a0:	68fb      	ldr	r3, [r7, #12]
3419e3a2:	2b00      	cmp	r3, #0
3419e3a4:	d00d      	beq.n	3419e3c2 <VD55G1_SetupSize+0x18a>
3419e3a6:	68fb      	ldr	r3, [r7, #12]
3419e3a8:	9302      	str	r3, [sp, #8]
3419e3aa:	f44f 730c 	mov.w	r3, #560	@ 0x230
3419e3ae:	9301      	str	r3, [sp, #4]
3419e3b0:	4b0c      	ldr	r3, [pc, #48]	@ (3419e3e4 <VD55G1_SetupSize+0x1ac>)
3419e3b2:	9300      	str	r3, [sp, #0]
3419e3b4:	f44f 730c 	mov.w	r3, #560	@ 0x230
3419e3b8:	4a0b      	ldr	r2, [pc, #44]	@ (3419e3e8 <VD55G1_SetupSize+0x1b0>)
3419e3ba:	2100      	movs	r1, #0
3419e3bc:	6878      	ldr	r0, [r7, #4]
3419e3be:	f7ff fa33 	bl	3419d828 <VD55G1_log_impl>
3419e3c2:	68fb      	ldr	r3, [r7, #12]
3419e3c4:	2b00      	cmp	r3, #0
3419e3c6:	d002      	beq.n	3419e3ce <VD55G1_SetupSize+0x196>
3419e3c8:	6878      	ldr	r0, [r7, #4]
3419e3ca:	f7ff fa49 	bl	3419d860 <display_error>
3419e3ce:	68fb      	ldr	r3, [r7, #12]
3419e3d0:	2b00      	cmp	r3, #0
3419e3d2:	d001      	beq.n	3419e3d8 <VD55G1_SetupSize+0x1a0>
3419e3d4:	68fb      	ldr	r3, [r7, #12]
3419e3d6:	e000      	b.n	3419e3da <VD55G1_SetupSize+0x1a2>

  return 0;
3419e3d8:	2300      	movs	r3, #0
}
3419e3da:	4618      	mov	r0, r3
3419e3dc:	3718      	adds	r7, #24
3419e3de:	46bd      	mov	sp, r7
3419e3e0:	bd80      	pop	{r7, pc}
3419e3e2:	bf00      	nop
3419e3e4:	341b2f6c 	.word	0x341b2f6c
3419e3e8:	341a60e4 	.word	0x341a60e4
3419e3ec:	00000000 	.word	0x00000000

3419e3f0 <VD55G1_SetupLineLen>:

static int VD55G1_SetupLineLen(VD55G1_Ctx_t *ctx)
{
3419e3f0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3419e3f4:	b08a      	sub	sp, #40	@ 0x28
3419e3f6:	af04      	add	r7, sp, #16
3419e3f8:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e3fa:	687b      	ldr	r3, [r7, #4]
3419e3fc:	3328      	adds	r3, #40	@ 0x28
3419e3fe:	617b      	str	r3, [r7, #20]
  int min_line_len_mipi;
  uint16_t line_len;
  uint16_t width;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_X_WIDTH, &width);
3419e400:	687b      	ldr	r3, [r7, #4]
3419e402:	689b      	ldr	r3, [r3, #8]
3419e404:	f107 0208 	add.w	r2, r7, #8
3419e408:	f240 5116 	movw	r1, #1302	@ 0x516
3419e40c:	6878      	ldr	r0, [r7, #4]
3419e40e:	4798      	blx	r3
3419e410:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e412:	693b      	ldr	r3, [r7, #16]
3419e414:	2b00      	cmp	r3, #0
3419e416:	d00d      	beq.n	3419e434 <VD55G1_SetupLineLen+0x44>
3419e418:	693b      	ldr	r3, [r7, #16]
3419e41a:	9302      	str	r3, [sp, #8]
3419e41c:	f240 233e 	movw	r3, #574	@ 0x23e
3419e420:	9301      	str	r3, [sp, #4]
3419e422:	4b3b      	ldr	r3, [pc, #236]	@ (3419e510 <VD55G1_SetupLineLen+0x120>)
3419e424:	9300      	str	r3, [sp, #0]
3419e426:	f240 233e 	movw	r3, #574	@ 0x23e
3419e42a:	4a3a      	ldr	r2, [pc, #232]	@ (3419e514 <VD55G1_SetupLineLen+0x124>)
3419e42c:	2100      	movs	r1, #0
3419e42e:	6878      	ldr	r0, [r7, #4]
3419e430:	f7ff f9fa 	bl	3419d828 <VD55G1_log_impl>
3419e434:	693b      	ldr	r3, [r7, #16]
3419e436:	2b00      	cmp	r3, #0
3419e438:	d002      	beq.n	3419e440 <VD55G1_SetupLineLen+0x50>
3419e43a:	6878      	ldr	r0, [r7, #4]
3419e43c:	f7ff fa10 	bl	3419d860 <display_error>
3419e440:	693b      	ldr	r3, [r7, #16]
3419e442:	2b00      	cmp	r3, #0
3419e444:	d001      	beq.n	3419e44a <VD55G1_SetupLineLen+0x5a>
3419e446:	693b      	ldr	r3, [r7, #16]
3419e448:	e056      	b.n	3419e4f8 <VD55G1_SetupLineLen+0x108>

  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
3419e44a:	893b      	ldrh	r3, [r7, #8]
3419e44c:	00db      	lsls	r3, r3, #3
3419e44e:	f503 7361 	add.w	r3, r3, #900	@ 0x384
3419e452:	17da      	asrs	r2, r3, #31
3419e454:	469a      	mov	sl, r3
3419e456:	4693      	mov	fp, r2
3419e458:	697b      	ldr	r3, [r7, #20]
3419e45a:	689b      	ldr	r3, [r3, #8]
3419e45c:	2200      	movs	r2, #0
3419e45e:	4698      	mov	r8, r3
3419e460:	4691      	mov	r9, r2
3419e462:	fb08 f20b 	mul.w	r2, r8, fp
3419e466:	fb0a f309 	mul.w	r3, sl, r9
3419e46a:	4413      	add	r3, r2
3419e46c:	fbaa 4508 	umull	r4, r5, sl, r8
3419e470:	442b      	add	r3, r5
3419e472:	461d      	mov	r5, r3
                      / VD55G1_MIPI_DATA_RATE_HZ;
3419e474:	a324      	add	r3, pc, #144	@ (adr r3, 3419e508 <VD55G1_SetupLineLen+0x118>)
3419e476:	e9d3 2300 	ldrd	r2, r3, [r3]
3419e47a:	4620      	mov	r0, r4
3419e47c:	4629      	mov	r1, r5
3419e47e:	f7e3 f9ad 	bl	341817dc <__aeabi_uldivmod>
3419e482:	4602      	mov	r2, r0
3419e484:	460b      	mov	r3, r1
  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
3419e486:	4613      	mov	r3, r2
3419e488:	60fb      	str	r3, [r7, #12]
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3419e48a:	68fb      	ldr	r3, [r7, #12]
3419e48c:	f5b3 6f8d 	cmp.w	r3, #1128	@ 0x468
3419e490:	bfb8      	it	lt
3419e492:	f44f 638d 	movlt.w	r3, #1128	@ 0x468
3419e496:	817b      	strh	r3, [r7, #10]

  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
3419e498:	687b      	ldr	r3, [r7, #4]
3419e49a:	695b      	ldr	r3, [r3, #20]
3419e49c:	897a      	ldrh	r2, [r7, #10]
3419e49e:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419e4a2:	6878      	ldr	r0, [r7, #4]
3419e4a4:	4798      	blx	r3
3419e4a6:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e4a8:	693b      	ldr	r3, [r7, #16]
3419e4aa:	2b00      	cmp	r3, #0
3419e4ac:	d00d      	beq.n	3419e4ca <VD55G1_SetupLineLen+0xda>
3419e4ae:	693b      	ldr	r3, [r7, #16]
3419e4b0:	9302      	str	r3, [sp, #8]
3419e4b2:	f240 2345 	movw	r3, #581	@ 0x245
3419e4b6:	9301      	str	r3, [sp, #4]
3419e4b8:	4b15      	ldr	r3, [pc, #84]	@ (3419e510 <VD55G1_SetupLineLen+0x120>)
3419e4ba:	9300      	str	r3, [sp, #0]
3419e4bc:	f240 2345 	movw	r3, #581	@ 0x245
3419e4c0:	4a14      	ldr	r2, [pc, #80]	@ (3419e514 <VD55G1_SetupLineLen+0x124>)
3419e4c2:	2100      	movs	r1, #0
3419e4c4:	6878      	ldr	r0, [r7, #4]
3419e4c6:	f7ff f9af 	bl	3419d828 <VD55G1_log_impl>
3419e4ca:	693b      	ldr	r3, [r7, #16]
3419e4cc:	2b00      	cmp	r3, #0
3419e4ce:	d002      	beq.n	3419e4d6 <VD55G1_SetupLineLen+0xe6>
3419e4d0:	6878      	ldr	r0, [r7, #4]
3419e4d2:	f7ff f9c5 	bl	3419d860 <display_error>
3419e4d6:	693b      	ldr	r3, [r7, #16]
3419e4d8:	2b00      	cmp	r3, #0
3419e4da:	d001      	beq.n	3419e4e0 <VD55G1_SetupLineLen+0xf0>
3419e4dc:	693b      	ldr	r3, [r7, #16]
3419e4de:	e00b      	b.n	3419e4f8 <VD55G1_SetupLineLen+0x108>
  VD55G1_dbg(ctx, 1, "line_length = %d\n", line_len);
3419e4e0:	897b      	ldrh	r3, [r7, #10]
3419e4e2:	9301      	str	r3, [sp, #4]
3419e4e4:	f240 2346 	movw	r3, #582	@ 0x246
3419e4e8:	9300      	str	r3, [sp, #0]
3419e4ea:	2301      	movs	r3, #1
3419e4ec:	4a0a      	ldr	r2, [pc, #40]	@ (3419e518 <VD55G1_SetupLineLen+0x128>)
3419e4ee:	2104      	movs	r1, #4
3419e4f0:	6878      	ldr	r0, [r7, #4]
3419e4f2:	f7ff f999 	bl	3419d828 <VD55G1_log_impl>

  return 0;
3419e4f6:	2300      	movs	r3, #0
}
3419e4f8:	4618      	mov	r0, r3
3419e4fa:	3718      	adds	r7, #24
3419e4fc:	46bd      	mov	sp, r7
3419e4fe:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3419e502:	bf00      	nop
3419e504:	f3af 8000 	nop.w
3419e508:	2fec1100 	.word	0x2fec1100
3419e50c:	00000000 	.word	0x00000000
3419e510:	341b2f80 	.word	0x341b2f80
3419e514:	341a60e4 	.word	0x341a60e4
3419e518:	341a6308 	.word	0x341a6308

3419e51c <VD55G1_ComputeFrameLength>:

static int VD55G1_ComputeFrameLength(VD55G1_Ctx_t *ctx, int fps, uint16_t *frame_length)
{
3419e51c:	b580      	push	{r7, lr}
3419e51e:	b090      	sub	sp, #64	@ 0x40
3419e520:	af06      	add	r7, sp, #24
3419e522:	60f8      	str	r0, [r7, #12]
3419e524:	60b9      	str	r1, [r7, #8]
3419e526:	607a      	str	r2, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e528:	68fb      	ldr	r3, [r7, #12]
3419e52a:	3328      	adds	r3, #40	@ 0x28
3419e52c:	627b      	str	r3, [r7, #36]	@ 0x24
  int req_frame_length;
  uint16_t line_length;
  uint16_t height;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
3419e52e:	68fb      	ldr	r3, [r7, #12]
3419e530:	689b      	ldr	r3, [r3, #8]
3419e532:	f107 0216 	add.w	r2, r7, #22
3419e536:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419e53a:	68f8      	ldr	r0, [r7, #12]
3419e53c:	4798      	blx	r3
3419e53e:	6238      	str	r0, [r7, #32]
  VD55G1_TraceError(ctx, ret);
3419e540:	6a3b      	ldr	r3, [r7, #32]
3419e542:	2b00      	cmp	r3, #0
3419e544:	d00d      	beq.n	3419e562 <VD55G1_ComputeFrameLength+0x46>
3419e546:	6a3b      	ldr	r3, [r7, #32]
3419e548:	9302      	str	r3, [sp, #8]
3419e54a:	f240 2355 	movw	r3, #597	@ 0x255
3419e54e:	9301      	str	r3, [sp, #4]
3419e550:	4b35      	ldr	r3, [pc, #212]	@ (3419e628 <VD55G1_ComputeFrameLength+0x10c>)
3419e552:	9300      	str	r3, [sp, #0]
3419e554:	f240 2355 	movw	r3, #597	@ 0x255
3419e558:	4a34      	ldr	r2, [pc, #208]	@ (3419e62c <VD55G1_ComputeFrameLength+0x110>)
3419e55a:	2100      	movs	r1, #0
3419e55c:	68f8      	ldr	r0, [r7, #12]
3419e55e:	f7ff f963 	bl	3419d828 <VD55G1_log_impl>
3419e562:	6a3b      	ldr	r3, [r7, #32]
3419e564:	2b00      	cmp	r3, #0
3419e566:	d002      	beq.n	3419e56e <VD55G1_ComputeFrameLength+0x52>
3419e568:	68f8      	ldr	r0, [r7, #12]
3419e56a:	f7ff f979 	bl	3419d860 <display_error>
3419e56e:	6a3b      	ldr	r3, [r7, #32]
3419e570:	2b00      	cmp	r3, #0
3419e572:	d001      	beq.n	3419e578 <VD55G1_ComputeFrameLength+0x5c>
3419e574:	6a3b      	ldr	r3, [r7, #32]
3419e576:	e052      	b.n	3419e61e <VD55G1_ComputeFrameLength+0x102>

  ret = ctx->read16(ctx, VD55G1_REG_Y_HEIGHT, &height);
3419e578:	68fb      	ldr	r3, [r7, #12]
3419e57a:	689b      	ldr	r3, [r3, #8]
3419e57c:	f107 0214 	add.w	r2, r7, #20
3419e580:	f240 5112 	movw	r1, #1298	@ 0x512
3419e584:	68f8      	ldr	r0, [r7, #12]
3419e586:	4798      	blx	r3
3419e588:	6238      	str	r0, [r7, #32]
  VD55G1_TraceError(ctx, ret);
3419e58a:	6a3b      	ldr	r3, [r7, #32]
3419e58c:	2b00      	cmp	r3, #0
3419e58e:	d00d      	beq.n	3419e5ac <VD55G1_ComputeFrameLength+0x90>
3419e590:	6a3b      	ldr	r3, [r7, #32]
3419e592:	9302      	str	r3, [sp, #8]
3419e594:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419e598:	9301      	str	r3, [sp, #4]
3419e59a:	4b23      	ldr	r3, [pc, #140]	@ (3419e628 <VD55G1_ComputeFrameLength+0x10c>)
3419e59c:	9300      	str	r3, [sp, #0]
3419e59e:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419e5a2:	4a22      	ldr	r2, [pc, #136]	@ (3419e62c <VD55G1_ComputeFrameLength+0x110>)
3419e5a4:	2100      	movs	r1, #0
3419e5a6:	68f8      	ldr	r0, [r7, #12]
3419e5a8:	f7ff f93e 	bl	3419d828 <VD55G1_log_impl>
3419e5ac:	6a3b      	ldr	r3, [r7, #32]
3419e5ae:	2b00      	cmp	r3, #0
3419e5b0:	d002      	beq.n	3419e5b8 <VD55G1_ComputeFrameLength+0x9c>
3419e5b2:	68f8      	ldr	r0, [r7, #12]
3419e5b4:	f7ff f954 	bl	3419d860 <display_error>
3419e5b8:	6a3b      	ldr	r3, [r7, #32]
3419e5ba:	2b00      	cmp	r3, #0
3419e5bc:	d001      	beq.n	3419e5c2 <VD55G1_ComputeFrameLength+0xa6>
3419e5be:	6a3b      	ldr	r3, [r7, #32]
3419e5c0:	e02d      	b.n	3419e61e <VD55G1_ComputeFrameLength+0x102>

  min_frame_length = height + VD55G1_MIN_VBLANK;
3419e5c2:	8abb      	ldrh	r3, [r7, #20]
3419e5c4:	3356      	adds	r3, #86	@ 0x56
3419e5c6:	61fb      	str	r3, [r7, #28]
  req_frame_length = drv_ctx->pclk / (line_length * fps);
3419e5c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e5ca:	689b      	ldr	r3, [r3, #8]
3419e5cc:	8afa      	ldrh	r2, [r7, #22]
3419e5ce:	4611      	mov	r1, r2
3419e5d0:	68ba      	ldr	r2, [r7, #8]
3419e5d2:	fb01 f202 	mul.w	r2, r1, r2
3419e5d6:	fbb3 f3f2 	udiv	r3, r3, r2
3419e5da:	61bb      	str	r3, [r7, #24]
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
3419e5dc:	69ba      	ldr	r2, [r7, #24]
3419e5de:	69fb      	ldr	r3, [r7, #28]
3419e5e0:	4293      	cmp	r3, r2
3419e5e2:	bfb8      	it	lt
3419e5e4:	4613      	movlt	r3, r2
3419e5e6:	f64f 72ff 	movw	r2, #65535	@ 0xffff
3419e5ea:	4293      	cmp	r3, r2
3419e5ec:	bfa8      	it	ge
3419e5ee:	4613      	movge	r3, r2
3419e5f0:	b29a      	uxth	r2, r3
3419e5f2:	687b      	ldr	r3, [r7, #4]
3419e5f4:	801a      	strh	r2, [r3, #0]

  VD55G1_dbg(ctx, 1, "frame_length to MAX(%d, %d) = %d to reach %d fps\n", min_frame_length, req_frame_length,
3419e5f6:	687b      	ldr	r3, [r7, #4]
3419e5f8:	881b      	ldrh	r3, [r3, #0]
3419e5fa:	461a      	mov	r2, r3
3419e5fc:	68bb      	ldr	r3, [r7, #8]
3419e5fe:	9304      	str	r3, [sp, #16]
3419e600:	9203      	str	r2, [sp, #12]
3419e602:	69bb      	ldr	r3, [r7, #24]
3419e604:	9302      	str	r3, [sp, #8]
3419e606:	69fb      	ldr	r3, [r7, #28]
3419e608:	9301      	str	r3, [sp, #4]
3419e60a:	f240 235e 	movw	r3, #606	@ 0x25e
3419e60e:	9300      	str	r3, [sp, #0]
3419e610:	2301      	movs	r3, #1
3419e612:	4a07      	ldr	r2, [pc, #28]	@ (3419e630 <VD55G1_ComputeFrameLength+0x114>)
3419e614:	2104      	movs	r1, #4
3419e616:	68f8      	ldr	r0, [r7, #12]
3419e618:	f7ff f906 	bl	3419d828 <VD55G1_log_impl>
             *frame_length, fps);

  return 0;
3419e61c:	2300      	movs	r3, #0
}
3419e61e:	4618      	mov	r0, r3
3419e620:	3728      	adds	r7, #40	@ 0x28
3419e622:	46bd      	mov	sp, r7
3419e624:	bd80      	pop	{r7, pc}
3419e626:	bf00      	nop
3419e628:	341b2f94 	.word	0x341b2f94
3419e62c:	341a60e4 	.word	0x341a60e4
3419e630:	341a632c 	.word	0x341a632c

3419e634 <VD55G1_SetupFrameRate>:

static int VD55G1_SetupFrameRate(VD55G1_Ctx_t *ctx)
{
3419e634:	b580      	push	{r7, lr}
3419e636:	b08a      	sub	sp, #40	@ 0x28
3419e638:	af04      	add	r7, sp, #16
3419e63a:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e63c:	687b      	ldr	r3, [r7, #4]
3419e63e:	3328      	adds	r3, #40	@ 0x28
3419e640:	617b      	str	r3, [r7, #20]
  uint16_t frame_length;
  int ret;

  ret = VD55G1_SetupLineLen(ctx);
3419e642:	6878      	ldr	r0, [r7, #4]
3419e644:	f7ff fed4 	bl	3419e3f0 <VD55G1_SetupLineLen>
3419e648:	6138      	str	r0, [r7, #16]
  if (ret)
3419e64a:	693b      	ldr	r3, [r7, #16]
3419e64c:	2b00      	cmp	r3, #0
3419e64e:	d001      	beq.n	3419e654 <VD55G1_SetupFrameRate+0x20>
    return ret;
3419e650:	693b      	ldr	r3, [r7, #16]
3419e652:	e041      	b.n	3419e6d8 <VD55G1_SetupFrameRate+0xa4>

  ret = VD55G1_ComputeFrameLength(ctx, drv_ctx->config_save.frame_rate, &frame_length);
3419e654:	697b      	ldr	r3, [r7, #20]
3419e656:	695b      	ldr	r3, [r3, #20]
3419e658:	f107 020e 	add.w	r2, r7, #14
3419e65c:	4619      	mov	r1, r3
3419e65e:	6878      	ldr	r0, [r7, #4]
3419e660:	f7ff ff5c 	bl	3419e51c <VD55G1_ComputeFrameLength>
3419e664:	6138      	str	r0, [r7, #16]
  if (ret)
3419e666:	693b      	ldr	r3, [r7, #16]
3419e668:	2b00      	cmp	r3, #0
3419e66a:	d001      	beq.n	3419e670 <VD55G1_SetupFrameRate+0x3c>
    return ret;
3419e66c:	693b      	ldr	r3, [r7, #16]
3419e66e:	e033      	b.n	3419e6d8 <VD55G1_SetupFrameRate+0xa4>

  VD55G1_dbg(ctx, 1, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
3419e670:	89fb      	ldrh	r3, [r7, #14]
3419e672:	461a      	mov	r2, r3
3419e674:	697b      	ldr	r3, [r7, #20]
3419e676:	695b      	ldr	r3, [r3, #20]
3419e678:	9302      	str	r3, [sp, #8]
3419e67a:	9201      	str	r2, [sp, #4]
3419e67c:	f240 2372 	movw	r3, #626	@ 0x272
3419e680:	9300      	str	r3, [sp, #0]
3419e682:	2301      	movs	r3, #1
3419e684:	4a16      	ldr	r2, [pc, #88]	@ (3419e6e0 <VD55G1_SetupFrameRate+0xac>)
3419e686:	2104      	movs	r1, #4
3419e688:	6878      	ldr	r0, [r7, #4]
3419e68a:	f7ff f8cd 	bl	3419d828 <VD55G1_log_impl>
  ret = ctx->write16(ctx, VD55G1_REG_FRAME_LENGTH, frame_length);
3419e68e:	687b      	ldr	r3, [r7, #4]
3419e690:	695b      	ldr	r3, [r3, #20]
3419e692:	89fa      	ldrh	r2, [r7, #14]
3419e694:	f240 510c 	movw	r1, #1292	@ 0x50c
3419e698:	6878      	ldr	r0, [r7, #4]
3419e69a:	4798      	blx	r3
3419e69c:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e69e:	693b      	ldr	r3, [r7, #16]
3419e6a0:	2b00      	cmp	r3, #0
3419e6a2:	d00d      	beq.n	3419e6c0 <VD55G1_SetupFrameRate+0x8c>
3419e6a4:	693b      	ldr	r3, [r7, #16]
3419e6a6:	9302      	str	r3, [sp, #8]
3419e6a8:	f44f 731d 	mov.w	r3, #628	@ 0x274
3419e6ac:	9301      	str	r3, [sp, #4]
3419e6ae:	4b0d      	ldr	r3, [pc, #52]	@ (3419e6e4 <VD55G1_SetupFrameRate+0xb0>)
3419e6b0:	9300      	str	r3, [sp, #0]
3419e6b2:	f44f 731d 	mov.w	r3, #628	@ 0x274
3419e6b6:	4a0c      	ldr	r2, [pc, #48]	@ (3419e6e8 <VD55G1_SetupFrameRate+0xb4>)
3419e6b8:	2100      	movs	r1, #0
3419e6ba:	6878      	ldr	r0, [r7, #4]
3419e6bc:	f7ff f8b4 	bl	3419d828 <VD55G1_log_impl>
3419e6c0:	693b      	ldr	r3, [r7, #16]
3419e6c2:	2b00      	cmp	r3, #0
3419e6c4:	d002      	beq.n	3419e6cc <VD55G1_SetupFrameRate+0x98>
3419e6c6:	6878      	ldr	r0, [r7, #4]
3419e6c8:	f7ff f8ca 	bl	3419d860 <display_error>
3419e6cc:	693b      	ldr	r3, [r7, #16]
3419e6ce:	2b00      	cmp	r3, #0
3419e6d0:	d001      	beq.n	3419e6d6 <VD55G1_SetupFrameRate+0xa2>
3419e6d2:	693b      	ldr	r3, [r7, #16]
3419e6d4:	e000      	b.n	3419e6d8 <VD55G1_SetupFrameRate+0xa4>

  return 0;
3419e6d6:	2300      	movs	r3, #0
}
3419e6d8:	4618      	mov	r0, r3
3419e6da:	3718      	adds	r7, #24
3419e6dc:	46bd      	mov	sp, r7
3419e6de:	bd80      	pop	{r7, pc}
3419e6e0:	341a6370 	.word	0x341a6370
3419e6e4:	341b2fb0 	.word	0x341b2fb0
3419e6e8:	341a60e4 	.word	0x341a60e4

3419e6ec <VD55G1_SetupExposure>:

static int VD55G1_SetupExposure(VD55G1_Ctx_t *ctx)
{
3419e6ec:	b580      	push	{r7, lr}
3419e6ee:	b08c      	sub	sp, #48	@ 0x30
3419e6f0:	af04      	add	r7, sp, #16
3419e6f2:	6078      	str	r0, [r7, #4]
  VD55G1_AWUConfig_t *awu = &ctx->ctx.config_save.awu;
3419e6f4:	687b      	ldr	r3, [r7, #4]
3419e6f6:	3350      	adds	r3, #80	@ 0x50
3419e6f8:	61bb      	str	r3, [r7, #24]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e6fa:	687b      	ldr	r3, [r7, #4]
3419e6fc:	3328      	adds	r3, #40	@ 0x28
3419e6fe:	617b      	str	r3, [r7, #20]
  uint8_t reg;
  int ret;

  /* max integration lines */
   /* first get minimum frame len */
  max_fps = drv_ctx->config_save.frame_rate;
3419e700:	697b      	ldr	r3, [r7, #20]
3419e702:	695b      	ldr	r3, [r3, #20]
3419e704:	61fb      	str	r3, [r7, #28]
  if (awu->is_enable)
3419e706:	69bb      	ldr	r3, [r7, #24]
3419e708:	681b      	ldr	r3, [r3, #0]
3419e70a:	2b00      	cmp	r3, #0
3419e70c:	d00d      	beq.n	3419e72a <VD55G1_SetupExposure+0x3e>
  {
    max_fps = MAX(max_fps, awu->convergence_frame_rate);
3419e70e:	69bb      	ldr	r3, [r7, #24]
3419e710:	685b      	ldr	r3, [r3, #4]
3419e712:	69fa      	ldr	r2, [r7, #28]
3419e714:	4293      	cmp	r3, r2
3419e716:	bfb8      	it	lt
3419e718:	4613      	movlt	r3, r2
3419e71a:	61fb      	str	r3, [r7, #28]
    max_fps = MAX(max_fps, awu->awu_frame_rate);
3419e71c:	69bb      	ldr	r3, [r7, #24]
3419e71e:	689b      	ldr	r3, [r3, #8]
3419e720:	69fa      	ldr	r2, [r7, #28]
3419e722:	4293      	cmp	r3, r2
3419e724:	bfb8      	it	lt
3419e726:	4613      	movlt	r3, r2
3419e728:	61fb      	str	r3, [r7, #28]
  }
  ret = VD55G1_ComputeFrameLength(ctx, max_fps, &frame_length);
3419e72a:	f107 030c 	add.w	r3, r7, #12
3419e72e:	461a      	mov	r2, r3
3419e730:	69f9      	ldr	r1, [r7, #28]
3419e732:	6878      	ldr	r0, [r7, #4]
3419e734:	f7ff fef2 	bl	3419e51c <VD55G1_ComputeFrameLength>
3419e738:	6138      	str	r0, [r7, #16]
  if (ret)
3419e73a:	693b      	ldr	r3, [r7, #16]
3419e73c:	2b00      	cmp	r3, #0
3419e73e:	d001      	beq.n	3419e744 <VD55G1_SetupExposure+0x58>
    return ret;
3419e740:	693b      	ldr	r3, [r7, #16]
3419e742:	e05e      	b.n	3419e802 <VD55G1_SetupExposure+0x116>
   /* set max integration lines to this value minus 10 lines */
  ret = ctx->write16(ctx, VD55G1_REG_MAX_COARSE_INTEGRATION_LINES, frame_length - 10);
3419e744:	687b      	ldr	r3, [r7, #4]
3419e746:	695b      	ldr	r3, [r3, #20]
3419e748:	89ba      	ldrh	r2, [r7, #12]
3419e74a:	3a0a      	subs	r2, #10
3419e74c:	b292      	uxth	r2, r2
3419e74e:	f240 3172 	movw	r1, #882	@ 0x372
3419e752:	6878      	ldr	r0, [r7, #4]
3419e754:	4798      	blx	r3
3419e756:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e758:	693b      	ldr	r3, [r7, #16]
3419e75a:	2b00      	cmp	r3, #0
3419e75c:	d00d      	beq.n	3419e77a <VD55G1_SetupExposure+0x8e>
3419e75e:	693b      	ldr	r3, [r7, #16]
3419e760:	9302      	str	r3, [sp, #8]
3419e762:	f240 238f 	movw	r3, #655	@ 0x28f
3419e766:	9301      	str	r3, [sp, #4]
3419e768:	4b28      	ldr	r3, [pc, #160]	@ (3419e80c <VD55G1_SetupExposure+0x120>)
3419e76a:	9300      	str	r3, [sp, #0]
3419e76c:	f240 238f 	movw	r3, #655	@ 0x28f
3419e770:	4a27      	ldr	r2, [pc, #156]	@ (3419e810 <VD55G1_SetupExposure+0x124>)
3419e772:	2100      	movs	r1, #0
3419e774:	6878      	ldr	r0, [r7, #4]
3419e776:	f7ff f857 	bl	3419d828 <VD55G1_log_impl>
3419e77a:	693b      	ldr	r3, [r7, #16]
3419e77c:	2b00      	cmp	r3, #0
3419e77e:	d002      	beq.n	3419e786 <VD55G1_SetupExposure+0x9a>
3419e780:	6878      	ldr	r0, [r7, #4]
3419e782:	f7ff f86d 	bl	3419d860 <display_error>
3419e786:	693b      	ldr	r3, [r7, #16]
3419e788:	2b00      	cmp	r3, #0
3419e78a:	d001      	beq.n	3419e790 <VD55G1_SetupExposure+0xa4>
3419e78c:	693b      	ldr	r3, [r7, #16]
3419e78e:	e038      	b.n	3419e802 <VD55G1_SetupExposure+0x116>
  VD55G1_dbg(ctx, 1, "Max coarse lines = %d\n", frame_length - 10);
3419e790:	89bb      	ldrh	r3, [r7, #12]
3419e792:	3b0a      	subs	r3, #10
3419e794:	9301      	str	r3, [sp, #4]
3419e796:	f44f 7324 	mov.w	r3, #656	@ 0x290
3419e79a:	9300      	str	r3, [sp, #0]
3419e79c:	2301      	movs	r3, #1
3419e79e:	4a1d      	ldr	r2, [pc, #116]	@ (3419e814 <VD55G1_SetupExposure+0x128>)
3419e7a0:	2104      	movs	r1, #4
3419e7a2:	6878      	ldr	r0, [r7, #4]
3419e7a4:	f7ff f840 	bl	3419d828 <VD55G1_log_impl>

  /* turn on auto exposure except when patgen is active */
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
3419e7a8:	697b      	ldr	r3, [r7, #20]
3419e7aa:	7e5b      	ldrb	r3, [r3, #25]
3419e7ac:	2b00      	cmp	r3, #0
3419e7ae:	d001      	beq.n	3419e7b4 <VD55G1_SetupExposure+0xc8>
3419e7b0:	2302      	movs	r3, #2
3419e7b2:	e000      	b.n	3419e7b6 <VD55G1_SetupExposure+0xca>
3419e7b4:	2300      	movs	r3, #0
3419e7b6:	73fb      	strb	r3, [r7, #15]
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
3419e7b8:	687b      	ldr	r3, [r7, #4]
3419e7ba:	691b      	ldr	r3, [r3, #16]
3419e7bc:	7bfa      	ldrb	r2, [r7, #15]
3419e7be:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
3419e7c2:	6878      	ldr	r0, [r7, #4]
3419e7c4:	4798      	blx	r3
3419e7c6:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419e7c8:	693b      	ldr	r3, [r7, #16]
3419e7ca:	2b00      	cmp	r3, #0
3419e7cc:	d00d      	beq.n	3419e7ea <VD55G1_SetupExposure+0xfe>
3419e7ce:	693b      	ldr	r3, [r7, #16]
3419e7d0:	9302      	str	r3, [sp, #8]
3419e7d2:	f240 2395 	movw	r3, #661	@ 0x295
3419e7d6:	9301      	str	r3, [sp, #4]
3419e7d8:	4b0c      	ldr	r3, [pc, #48]	@ (3419e80c <VD55G1_SetupExposure+0x120>)
3419e7da:	9300      	str	r3, [sp, #0]
3419e7dc:	f240 2395 	movw	r3, #661	@ 0x295
3419e7e0:	4a0b      	ldr	r2, [pc, #44]	@ (3419e810 <VD55G1_SetupExposure+0x124>)
3419e7e2:	2100      	movs	r1, #0
3419e7e4:	6878      	ldr	r0, [r7, #4]
3419e7e6:	f7ff f81f 	bl	3419d828 <VD55G1_log_impl>
3419e7ea:	693b      	ldr	r3, [r7, #16]
3419e7ec:	2b00      	cmp	r3, #0
3419e7ee:	d002      	beq.n	3419e7f6 <VD55G1_SetupExposure+0x10a>
3419e7f0:	6878      	ldr	r0, [r7, #4]
3419e7f2:	f7ff f835 	bl	3419d860 <display_error>
3419e7f6:	693b      	ldr	r3, [r7, #16]
3419e7f8:	2b00      	cmp	r3, #0
3419e7fa:	d001      	beq.n	3419e800 <VD55G1_SetupExposure+0x114>
3419e7fc:	693b      	ldr	r3, [r7, #16]
3419e7fe:	e000      	b.n	3419e802 <VD55G1_SetupExposure+0x116>

  return 0;
3419e800:	2300      	movs	r3, #0
}
3419e802:	4618      	mov	r0, r3
3419e804:	3720      	adds	r7, #32
3419e806:	46bd      	mov	sp, r7
3419e808:	bd80      	pop	{r7, pc}
3419e80a:	bf00      	nop
3419e80c:	341b2fc8 	.word	0x341b2fc8
3419e810:	341a60e4 	.word	0x341a60e4
3419e814:	341a63ac 	.word	0x341a63ac

3419e818 <VD55G1_SetupMirrorFlip>:

static int VD55G1_SetupMirrorFlip(VD55G1_Ctx_t *ctx)
{
3419e818:	b580      	push	{r7, lr}
3419e81a:	b08a      	sub	sp, #40	@ 0x28
3419e81c:	af04      	add	r7, sp, #16
3419e81e:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e820:	687b      	ldr	r3, [r7, #4]
3419e822:	3328      	adds	r3, #40	@ 0x28
3419e824:	613b      	str	r3, [r7, #16]
  uint8_t mode;
  int ret;

  switch (drv_ctx->config_save.flip_mirror_mode) {
3419e826:	693b      	ldr	r3, [r7, #16]
3419e828:	7e1b      	ldrb	r3, [r3, #24]
3419e82a:	2b03      	cmp	r3, #3
3419e82c:	d816      	bhi.n	3419e85c <VD55G1_SetupMirrorFlip+0x44>
3419e82e:	a201      	add	r2, pc, #4	@ (adr r2, 3419e834 <VD55G1_SetupMirrorFlip+0x1c>)
3419e830:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419e834:	3419e845 	.word	0x3419e845
3419e838:	3419e84b 	.word	0x3419e84b
3419e83c:	3419e851 	.word	0x3419e851
3419e840:	3419e857 	.word	0x3419e857
  case VD55G1_MIRROR_FLIP_NONE:
    mode = 0;
3419e844:	2300      	movs	r3, #0
3419e846:	75fb      	strb	r3, [r7, #23]
    break;
3419e848:	e00b      	b.n	3419e862 <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_FLIP:
    mode = 2;
3419e84a:	2302      	movs	r3, #2
3419e84c:	75fb      	strb	r3, [r7, #23]
    break;
3419e84e:	e008      	b.n	3419e862 <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_MIRROR:
    mode = 1;
3419e850:	2301      	movs	r3, #1
3419e852:	75fb      	strb	r3, [r7, #23]
    break;
3419e854:	e005      	b.n	3419e862 <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_MIRROR_FLIP:
    mode = 3;
3419e856:	2303      	movs	r3, #3
3419e858:	75fb      	strb	r3, [r7, #23]
    break;
3419e85a:	e002      	b.n	3419e862 <VD55G1_SetupMirrorFlip+0x4a>
  default:
    return -1;
3419e85c:	f04f 33ff 	mov.w	r3, #4294967295
3419e860:	e024      	b.n	3419e8ac <VD55G1_SetupMirrorFlip+0x94>
  }

  ret = ctx->write8(ctx, VD55G1_REG_ORIENTATION, mode);
3419e862:	687b      	ldr	r3, [r7, #4]
3419e864:	691b      	ldr	r3, [r3, #16]
3419e866:	7dfa      	ldrb	r2, [r7, #23]
3419e868:	f240 3102 	movw	r1, #770	@ 0x302
3419e86c:	6878      	ldr	r0, [r7, #4]
3419e86e:	4798      	blx	r3
3419e870:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e872:	68fb      	ldr	r3, [r7, #12]
3419e874:	2b00      	cmp	r3, #0
3419e876:	d00d      	beq.n	3419e894 <VD55G1_SetupMirrorFlip+0x7c>
3419e878:	68fb      	ldr	r3, [r7, #12]
3419e87a:	9302      	str	r3, [sp, #8]
3419e87c:	f240 23b2 	movw	r3, #690	@ 0x2b2
3419e880:	9301      	str	r3, [sp, #4]
3419e882:	4b0c      	ldr	r3, [pc, #48]	@ (3419e8b4 <VD55G1_SetupMirrorFlip+0x9c>)
3419e884:	9300      	str	r3, [sp, #0]
3419e886:	f240 23b2 	movw	r3, #690	@ 0x2b2
3419e88a:	4a0b      	ldr	r2, [pc, #44]	@ (3419e8b8 <VD55G1_SetupMirrorFlip+0xa0>)
3419e88c:	2100      	movs	r1, #0
3419e88e:	6878      	ldr	r0, [r7, #4]
3419e890:	f7fe ffca 	bl	3419d828 <VD55G1_log_impl>
3419e894:	68fb      	ldr	r3, [r7, #12]
3419e896:	2b00      	cmp	r3, #0
3419e898:	d002      	beq.n	3419e8a0 <VD55G1_SetupMirrorFlip+0x88>
3419e89a:	6878      	ldr	r0, [r7, #4]
3419e89c:	f7fe ffe0 	bl	3419d860 <display_error>
3419e8a0:	68fb      	ldr	r3, [r7, #12]
3419e8a2:	2b00      	cmp	r3, #0
3419e8a4:	d001      	beq.n	3419e8aa <VD55G1_SetupMirrorFlip+0x92>
3419e8a6:	68fb      	ldr	r3, [r7, #12]
3419e8a8:	e000      	b.n	3419e8ac <VD55G1_SetupMirrorFlip+0x94>

  return 0;
3419e8aa:	2300      	movs	r3, #0
}
3419e8ac:	4618      	mov	r0, r3
3419e8ae:	3718      	adds	r7, #24
3419e8b0:	46bd      	mov	sp, r7
3419e8b2:	bd80      	pop	{r7, pc}
3419e8b4:	341b2fe0 	.word	0x341b2fe0
3419e8b8:	341a60e4 	.word	0x341a60e4

3419e8bc <VD55G1_SetupPatGen>:

static int VD55G1_SetupPatGen(VD55G1_Ctx_t *ctx)
{
3419e8bc:	b580      	push	{r7, lr}
3419e8be:	b08a      	sub	sp, #40	@ 0x28
3419e8c0:	af04      	add	r7, sp, #16
3419e8c2:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419e8c4:	687b      	ldr	r3, [r7, #4]
3419e8c6:	3328      	adds	r3, #40	@ 0x28
3419e8c8:	613b      	str	r3, [r7, #16]
  uint16_t value = VD55G1_PATGEN_CTRL_DISABLE;
3419e8ca:	2300      	movs	r3, #0
3419e8cc:	82fb      	strh	r3, [r7, #22]
  int ret;

  switch (drv_ctx->config_save.patgen) {
3419e8ce:	693b      	ldr	r3, [r7, #16]
3419e8d0:	7e5b      	ldrb	r3, [r3, #25]
3419e8d2:	2b02      	cmp	r3, #2
3419e8d4:	d00d      	beq.n	3419e8f2 <VD55G1_SetupPatGen+0x36>
3419e8d6:	2b02      	cmp	r3, #2
3419e8d8:	dc0f      	bgt.n	3419e8fa <VD55G1_SetupPatGen+0x3e>
3419e8da:	2b00      	cmp	r3, #0
3419e8dc:	d002      	beq.n	3419e8e4 <VD55G1_SetupPatGen+0x28>
3419e8de:	2b01      	cmp	r3, #1
3419e8e0:	d003      	beq.n	3419e8ea <VD55G1_SetupPatGen+0x2e>
3419e8e2:	e00a      	b.n	3419e8fa <VD55G1_SetupPatGen+0x3e>
  case VD55G1_PATGEN_DISABLE:
    value = VD55G1_PATGEN_CTRL_DISABLE;
3419e8e4:	2300      	movs	r3, #0
3419e8e6:	82fb      	strh	r3, [r7, #22]
    break;
3419e8e8:	e00a      	b.n	3419e900 <VD55G1_SetupPatGen+0x44>
  case VD55G1_PATGEN_DIAGONAL_GRAYSCALE:
    value = VD55G1_PATGEN_CTRL_DIAG_GRAY;
3419e8ea:	f240 2321 	movw	r3, #545	@ 0x221
3419e8ee:	82fb      	strh	r3, [r7, #22]
    break;
3419e8f0:	e006      	b.n	3419e900 <VD55G1_SetupPatGen+0x44>
  case VD55G1_PATGEN_PSEUDO_RANDOM:
    value = VD55G1_PATGEN_CTRL_PSN;
3419e8f2:	f240 2381 	movw	r3, #641	@ 0x281
3419e8f6:	82fb      	strh	r3, [r7, #22]
    break;
3419e8f8:	e002      	b.n	3419e900 <VD55G1_SetupPatGen+0x44>
  default:
    return -1;
3419e8fa:	f04f 33ff 	mov.w	r3, #4294967295
3419e8fe:	e070      	b.n	3419e9e2 <VD55G1_SetupPatGen+0x126>
  }

  if (drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE)
3419e900:	693b      	ldr	r3, [r7, #16]
3419e902:	7e5b      	ldrb	r3, [r3, #25]
3419e904:	2b00      	cmp	r3, #0
3419e906:	d047      	beq.n	3419e998 <VD55G1_SetupPatGen+0xdc>
  {
    ret = ctx->write8(ctx, VD55G1_REG_DUSTER_CTRL, VD55G1_DUSTER_DISABLE);
3419e908:	687b      	ldr	r3, [r7, #4]
3419e90a:	691b      	ldr	r3, [r3, #16]
3419e90c:	2200      	movs	r2, #0
3419e90e:	f240 31ae 	movw	r1, #942	@ 0x3ae
3419e912:	6878      	ldr	r0, [r7, #4]
3419e914:	4798      	blx	r3
3419e916:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419e918:	68fb      	ldr	r3, [r7, #12]
3419e91a:	2b00      	cmp	r3, #0
3419e91c:	d00d      	beq.n	3419e93a <VD55G1_SetupPatGen+0x7e>
3419e91e:	68fb      	ldr	r3, [r7, #12]
3419e920:	9302      	str	r3, [sp, #8]
3419e922:	f240 23ce 	movw	r3, #718	@ 0x2ce
3419e926:	9301      	str	r3, [sp, #4]
3419e928:	4b30      	ldr	r3, [pc, #192]	@ (3419e9ec <VD55G1_SetupPatGen+0x130>)
3419e92a:	9300      	str	r3, [sp, #0]
3419e92c:	f240 23ce 	movw	r3, #718	@ 0x2ce
3419e930:	4a2f      	ldr	r2, [pc, #188]	@ (3419e9f0 <VD55G1_SetupPatGen+0x134>)
3419e932:	2100      	movs	r1, #0
3419e934:	6878      	ldr	r0, [r7, #4]
3419e936:	f7fe ff77 	bl	3419d828 <VD55G1_log_impl>
3419e93a:	68fb      	ldr	r3, [r7, #12]
3419e93c:	2b00      	cmp	r3, #0
3419e93e:	d002      	beq.n	3419e946 <VD55G1_SetupPatGen+0x8a>
3419e940:	6878      	ldr	r0, [r7, #4]
3419e942:	f7fe ff8d 	bl	3419d860 <display_error>
3419e946:	68fb      	ldr	r3, [r7, #12]
3419e948:	2b00      	cmp	r3, #0
3419e94a:	d001      	beq.n	3419e950 <VD55G1_SetupPatGen+0x94>
3419e94c:	68fb      	ldr	r3, [r7, #12]
3419e94e:	e048      	b.n	3419e9e2 <VD55G1_SetupPatGen+0x126>
    ret = ctx->write8(ctx, VD55G1_REG_DARKCAL_CTRL, VD55G1_DARKCAL_BYPASS_DARKAVG);
3419e950:	687b      	ldr	r3, [r7, #4]
3419e952:	691b      	ldr	r3, [r3, #16]
3419e954:	2202      	movs	r2, #2
3419e956:	f240 312a 	movw	r1, #810	@ 0x32a
3419e95a:	6878      	ldr	r0, [r7, #4]
3419e95c:	4798      	blx	r3
3419e95e:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419e960:	68fb      	ldr	r3, [r7, #12]
3419e962:	2b00      	cmp	r3, #0
3419e964:	d00d      	beq.n	3419e982 <VD55G1_SetupPatGen+0xc6>
3419e966:	68fb      	ldr	r3, [r7, #12]
3419e968:	9302      	str	r3, [sp, #8]
3419e96a:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
3419e96e:	9301      	str	r3, [sp, #4]
3419e970:	4b1e      	ldr	r3, [pc, #120]	@ (3419e9ec <VD55G1_SetupPatGen+0x130>)
3419e972:	9300      	str	r3, [sp, #0]
3419e974:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
3419e978:	4a1d      	ldr	r2, [pc, #116]	@ (3419e9f0 <VD55G1_SetupPatGen+0x134>)
3419e97a:	2100      	movs	r1, #0
3419e97c:	6878      	ldr	r0, [r7, #4]
3419e97e:	f7fe ff53 	bl	3419d828 <VD55G1_log_impl>
3419e982:	68fb      	ldr	r3, [r7, #12]
3419e984:	2b00      	cmp	r3, #0
3419e986:	d002      	beq.n	3419e98e <VD55G1_SetupPatGen+0xd2>
3419e988:	6878      	ldr	r0, [r7, #4]
3419e98a:	f7fe ff69 	bl	3419d860 <display_error>
3419e98e:	68fb      	ldr	r3, [r7, #12]
3419e990:	2b00      	cmp	r3, #0
3419e992:	d001      	beq.n	3419e998 <VD55G1_SetupPatGen+0xdc>
3419e994:	68fb      	ldr	r3, [r7, #12]
3419e996:	e024      	b.n	3419e9e2 <VD55G1_SetupPatGen+0x126>
  }

  ret = ctx->write16(ctx, VD55G1_REG_PATGEN_CTRL, value);
3419e998:	687b      	ldr	r3, [r7, #4]
3419e99a:	695b      	ldr	r3, [r3, #20]
3419e99c:	8afa      	ldrh	r2, [r7, #22]
3419e99e:	f44f 7141 	mov.w	r1, #772	@ 0x304
3419e9a2:	6878      	ldr	r0, [r7, #4]
3419e9a4:	4798      	blx	r3
3419e9a6:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419e9a8:	68fb      	ldr	r3, [r7, #12]
3419e9aa:	2b00      	cmp	r3, #0
3419e9ac:	d00d      	beq.n	3419e9ca <VD55G1_SetupPatGen+0x10e>
3419e9ae:	68fb      	ldr	r3, [r7, #12]
3419e9b0:	9302      	str	r3, [sp, #8]
3419e9b2:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
3419e9b6:	9301      	str	r3, [sp, #4]
3419e9b8:	4b0c      	ldr	r3, [pc, #48]	@ (3419e9ec <VD55G1_SetupPatGen+0x130>)
3419e9ba:	9300      	str	r3, [sp, #0]
3419e9bc:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
3419e9c0:	4a0b      	ldr	r2, [pc, #44]	@ (3419e9f0 <VD55G1_SetupPatGen+0x134>)
3419e9c2:	2100      	movs	r1, #0
3419e9c4:	6878      	ldr	r0, [r7, #4]
3419e9c6:	f7fe ff2f 	bl	3419d828 <VD55G1_log_impl>
3419e9ca:	68fb      	ldr	r3, [r7, #12]
3419e9cc:	2b00      	cmp	r3, #0
3419e9ce:	d002      	beq.n	3419e9d6 <VD55G1_SetupPatGen+0x11a>
3419e9d0:	6878      	ldr	r0, [r7, #4]
3419e9d2:	f7fe ff45 	bl	3419d860 <display_error>
3419e9d6:	68fb      	ldr	r3, [r7, #12]
3419e9d8:	2b00      	cmp	r3, #0
3419e9da:	d001      	beq.n	3419e9e0 <VD55G1_SetupPatGen+0x124>
3419e9dc:	68fb      	ldr	r3, [r7, #12]
3419e9de:	e000      	b.n	3419e9e2 <VD55G1_SetupPatGen+0x126>

  return 0;
3419e9e0:	2300      	movs	r3, #0
}
3419e9e2:	4618      	mov	r0, r3
3419e9e4:	3718      	adds	r7, #24
3419e9e6:	46bd      	mov	sp, r7
3419e9e8:	bd80      	pop	{r7, pc}
3419e9ea:	bf00      	nop
3419e9ec:	341b2ff8 	.word	0x341b2ff8
3419e9f0:	341a60e4 	.word	0x341a60e4

3419e9f4 <VD55G1_SetFlicker>:

static int VD55G1_SetFlicker(VD55G1_Ctx_t *ctx, VD55G1_Flicker_t flicker)
{
3419e9f4:	b580      	push	{r7, lr}
3419e9f6:	b088      	sub	sp, #32
3419e9f8:	af04      	add	r7, sp, #16
3419e9fa:	6078      	str	r0, [r7, #4]
3419e9fc:	460b      	mov	r3, r1
3419e9fe:	70fb      	strb	r3, [r7, #3]
  uint16_t mode;
  int ret;

  switch (flicker) {
3419ea00:	78fb      	ldrb	r3, [r7, #3]
3419ea02:	2b02      	cmp	r3, #2
3419ea04:	d00c      	beq.n	3419ea20 <VD55G1_SetFlicker+0x2c>
3419ea06:	2b02      	cmp	r3, #2
3419ea08:	dc0d      	bgt.n	3419ea26 <VD55G1_SetFlicker+0x32>
3419ea0a:	2b00      	cmp	r3, #0
3419ea0c:	d002      	beq.n	3419ea14 <VD55G1_SetFlicker+0x20>
3419ea0e:	2b01      	cmp	r3, #1
3419ea10:	d003      	beq.n	3419ea1a <VD55G1_SetFlicker+0x26>
3419ea12:	e008      	b.n	3419ea26 <VD55G1_SetFlicker+0x32>
  case VD55G1_FLICKER_FREE_NONE:
    mode = 0;
3419ea14:	2300      	movs	r3, #0
3419ea16:	81fb      	strh	r3, [r7, #14]
    break;
3419ea18:	e008      	b.n	3419ea2c <VD55G1_SetFlicker+0x38>
  case VD55G1_FLICKER_FREE_50HZ:
    mode = 1;
3419ea1a:	2301      	movs	r3, #1
3419ea1c:	81fb      	strh	r3, [r7, #14]
    break;
3419ea1e:	e005      	b.n	3419ea2c <VD55G1_SetFlicker+0x38>
  case VD55G1_FLICKER_FREE_60HZ:
    mode = 3;
3419ea20:	2303      	movs	r3, #3
3419ea22:	81fb      	strh	r3, [r7, #14]
    break;
3419ea24:	e002      	b.n	3419ea2c <VD55G1_SetFlicker+0x38>
  default:
    return -1;
3419ea26:	f04f 33ff 	mov.w	r3, #4294967295
3419ea2a:	e024      	b.n	3419ea76 <VD55G1_SetFlicker+0x82>
  }

  ret = ctx->write16(ctx, VD55G1_REG_EXPOSURE_COMPILER_CONTROL_A, mode);
3419ea2c:	687b      	ldr	r3, [r7, #4]
3419ea2e:	695b      	ldr	r3, [r3, #20]
3419ea30:	89fa      	ldrh	r2, [r7, #14]
3419ea32:	f240 4182 	movw	r1, #1154	@ 0x482
3419ea36:	6878      	ldr	r0, [r7, #4]
3419ea38:	4798      	blx	r3
3419ea3a:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419ea3c:	68bb      	ldr	r3, [r7, #8]
3419ea3e:	2b00      	cmp	r3, #0
3419ea40:	d00d      	beq.n	3419ea5e <VD55G1_SetFlicker+0x6a>
3419ea42:	68bb      	ldr	r3, [r7, #8]
3419ea44:	9302      	str	r3, [sp, #8]
3419ea46:	f240 23ed 	movw	r3, #749	@ 0x2ed
3419ea4a:	9301      	str	r3, [sp, #4]
3419ea4c:	4b0c      	ldr	r3, [pc, #48]	@ (3419ea80 <VD55G1_SetFlicker+0x8c>)
3419ea4e:	9300      	str	r3, [sp, #0]
3419ea50:	f240 23ed 	movw	r3, #749	@ 0x2ed
3419ea54:	4a0b      	ldr	r2, [pc, #44]	@ (3419ea84 <VD55G1_SetFlicker+0x90>)
3419ea56:	2100      	movs	r1, #0
3419ea58:	6878      	ldr	r0, [r7, #4]
3419ea5a:	f7fe fee5 	bl	3419d828 <VD55G1_log_impl>
3419ea5e:	68bb      	ldr	r3, [r7, #8]
3419ea60:	2b00      	cmp	r3, #0
3419ea62:	d002      	beq.n	3419ea6a <VD55G1_SetFlicker+0x76>
3419ea64:	6878      	ldr	r0, [r7, #4]
3419ea66:	f7fe fefb 	bl	3419d860 <display_error>
3419ea6a:	68bb      	ldr	r3, [r7, #8]
3419ea6c:	2b00      	cmp	r3, #0
3419ea6e:	d001      	beq.n	3419ea74 <VD55G1_SetFlicker+0x80>
3419ea70:	68bb      	ldr	r3, [r7, #8]
3419ea72:	e000      	b.n	3419ea76 <VD55G1_SetFlicker+0x82>

  return 0;
3419ea74:	2300      	movs	r3, #0
}
3419ea76:	4618      	mov	r0, r3
3419ea78:	3710      	adds	r7, #16
3419ea7a:	46bd      	mov	sp, r7
3419ea7c:	bd80      	pop	{r7, pc}
3419ea7e:	bf00      	nop
3419ea80:	341b300c 	.word	0x341b300c
3419ea84:	341a60e4 	.word	0x341a60e4

3419ea88 <VD55G1_Flicker>:

static int VD55G1_Flicker(VD55G1_Ctx_t *ctx)
{
3419ea88:	b580      	push	{r7, lr}
3419ea8a:	b084      	sub	sp, #16
3419ea8c:	af00      	add	r7, sp, #0
3419ea8e:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419ea90:	687b      	ldr	r3, [r7, #4]
3419ea92:	3328      	adds	r3, #40	@ 0x28
3419ea94:	60fb      	str	r3, [r7, #12]

  return VD55G1_SetFlicker(ctx, drv_ctx->config_save.flicker);
3419ea96:	68fb      	ldr	r3, [r7, #12]
3419ea98:	7e9b      	ldrb	r3, [r3, #26]
3419ea9a:	4619      	mov	r1, r3
3419ea9c:	6878      	ldr	r0, [r7, #4]
3419ea9e:	f7ff ffa9 	bl	3419e9f4 <VD55G1_SetFlicker>
3419eaa2:	4603      	mov	r3, r0
}
3419eaa4:	4618      	mov	r0, r3
3419eaa6:	3710      	adds	r7, #16
3419eaa8:	46bd      	mov	sp, r7
3419eaaa:	bd80      	pop	{r7, pc}

3419eaac <VD55G1_Setup>:

static int VD55G1_Setup(VD55G1_Ctx_t *ctx)
{
3419eaac:	b580      	push	{r7, lr}
3419eaae:	b088      	sub	sp, #32
3419eab0:	af04      	add	r7, sp, #16
3419eab2:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD55G1_SetupClocks(ctx);
3419eab4:	6878      	ldr	r0, [r7, #4]
3419eab6:	f7ff faa9 	bl	3419e00c <VD55G1_SetupClocks>
3419eaba:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419eabc:	68fb      	ldr	r3, [r7, #12]
3419eabe:	2b00      	cmp	r3, #0
3419eac0:	d00d      	beq.n	3419eade <VD55G1_Setup+0x32>
3419eac2:	68fb      	ldr	r3, [r7, #12]
3419eac4:	9302      	str	r3, [sp, #8]
3419eac6:	f240 23fe 	movw	r3, #766	@ 0x2fe
3419eaca:	9301      	str	r3, [sp, #4]
3419eacc:	4b7c      	ldr	r3, [pc, #496]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419eace:	9300      	str	r3, [sp, #0]
3419ead0:	f240 23fe 	movw	r3, #766	@ 0x2fe
3419ead4:	4a7b      	ldr	r2, [pc, #492]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419ead6:	2100      	movs	r1, #0
3419ead8:	6878      	ldr	r0, [r7, #4]
3419eada:	f7fe fea5 	bl	3419d828 <VD55G1_log_impl>
3419eade:	68fb      	ldr	r3, [r7, #12]
3419eae0:	2b00      	cmp	r3, #0
3419eae2:	d002      	beq.n	3419eaea <VD55G1_Setup+0x3e>
3419eae4:	6878      	ldr	r0, [r7, #4]
3419eae6:	f7fe febb 	bl	3419d860 <display_error>
3419eaea:	68fb      	ldr	r3, [r7, #12]
3419eaec:	2b00      	cmp	r3, #0
3419eaee:	d001      	beq.n	3419eaf4 <VD55G1_Setup+0x48>
3419eaf0:	68fb      	ldr	r3, [r7, #12]
3419eaf2:	e0e0      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupOutput(ctx);
3419eaf4:	6878      	ldr	r0, [r7, #4]
3419eaf6:	f7ff fb01 	bl	3419e0fc <VD55G1_SetupOutput>
3419eafa:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419eafc:	68fb      	ldr	r3, [r7, #12]
3419eafe:	2b00      	cmp	r3, #0
3419eb00:	d00d      	beq.n	3419eb1e <VD55G1_Setup+0x72>
3419eb02:	68fb      	ldr	r3, [r7, #12]
3419eb04:	9302      	str	r3, [sp, #8]
3419eb06:	f240 3301 	movw	r3, #769	@ 0x301
3419eb0a:	9301      	str	r3, [sp, #4]
3419eb0c:	4b6c      	ldr	r3, [pc, #432]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419eb0e:	9300      	str	r3, [sp, #0]
3419eb10:	f240 3301 	movw	r3, #769	@ 0x301
3419eb14:	4a6b      	ldr	r2, [pc, #428]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419eb16:	2100      	movs	r1, #0
3419eb18:	6878      	ldr	r0, [r7, #4]
3419eb1a:	f7fe fe85 	bl	3419d828 <VD55G1_log_impl>
3419eb1e:	68fb      	ldr	r3, [r7, #12]
3419eb20:	2b00      	cmp	r3, #0
3419eb22:	d002      	beq.n	3419eb2a <VD55G1_Setup+0x7e>
3419eb24:	6878      	ldr	r0, [r7, #4]
3419eb26:	f7fe fe9b 	bl	3419d860 <display_error>
3419eb2a:	68fb      	ldr	r3, [r7, #12]
3419eb2c:	2b00      	cmp	r3, #0
3419eb2e:	d001      	beq.n	3419eb34 <VD55G1_Setup+0x88>
3419eb30:	68fb      	ldr	r3, [r7, #12]
3419eb32:	e0c0      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupSize(ctx);
3419eb34:	6878      	ldr	r0, [r7, #4]
3419eb36:	f7ff fb7f 	bl	3419e238 <VD55G1_SetupSize>
3419eb3a:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419eb3c:	68fb      	ldr	r3, [r7, #12]
3419eb3e:	2b00      	cmp	r3, #0
3419eb40:	d00d      	beq.n	3419eb5e <VD55G1_Setup+0xb2>
3419eb42:	68fb      	ldr	r3, [r7, #12]
3419eb44:	9302      	str	r3, [sp, #8]
3419eb46:	f44f 7341 	mov.w	r3, #772	@ 0x304
3419eb4a:	9301      	str	r3, [sp, #4]
3419eb4c:	4b5c      	ldr	r3, [pc, #368]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419eb4e:	9300      	str	r3, [sp, #0]
3419eb50:	f44f 7341 	mov.w	r3, #772	@ 0x304
3419eb54:	4a5b      	ldr	r2, [pc, #364]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419eb56:	2100      	movs	r1, #0
3419eb58:	6878      	ldr	r0, [r7, #4]
3419eb5a:	f7fe fe65 	bl	3419d828 <VD55G1_log_impl>
3419eb5e:	68fb      	ldr	r3, [r7, #12]
3419eb60:	2b00      	cmp	r3, #0
3419eb62:	d002      	beq.n	3419eb6a <VD55G1_Setup+0xbe>
3419eb64:	6878      	ldr	r0, [r7, #4]
3419eb66:	f7fe fe7b 	bl	3419d860 <display_error>
3419eb6a:	68fb      	ldr	r3, [r7, #12]
3419eb6c:	2b00      	cmp	r3, #0
3419eb6e:	d001      	beq.n	3419eb74 <VD55G1_Setup+0xc8>
3419eb70:	68fb      	ldr	r3, [r7, #12]
3419eb72:	e0a0      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupFrameRate(ctx);
3419eb74:	6878      	ldr	r0, [r7, #4]
3419eb76:	f7ff fd5d 	bl	3419e634 <VD55G1_SetupFrameRate>
3419eb7a:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419eb7c:	68fb      	ldr	r3, [r7, #12]
3419eb7e:	2b00      	cmp	r3, #0
3419eb80:	d00d      	beq.n	3419eb9e <VD55G1_Setup+0xf2>
3419eb82:	68fb      	ldr	r3, [r7, #12]
3419eb84:	9302      	str	r3, [sp, #8]
3419eb86:	f240 3307 	movw	r3, #775	@ 0x307
3419eb8a:	9301      	str	r3, [sp, #4]
3419eb8c:	4b4c      	ldr	r3, [pc, #304]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419eb8e:	9300      	str	r3, [sp, #0]
3419eb90:	f240 3307 	movw	r3, #775	@ 0x307
3419eb94:	4a4b      	ldr	r2, [pc, #300]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419eb96:	2100      	movs	r1, #0
3419eb98:	6878      	ldr	r0, [r7, #4]
3419eb9a:	f7fe fe45 	bl	3419d828 <VD55G1_log_impl>
3419eb9e:	68fb      	ldr	r3, [r7, #12]
3419eba0:	2b00      	cmp	r3, #0
3419eba2:	d002      	beq.n	3419ebaa <VD55G1_Setup+0xfe>
3419eba4:	6878      	ldr	r0, [r7, #4]
3419eba6:	f7fe fe5b 	bl	3419d860 <display_error>
3419ebaa:	68fb      	ldr	r3, [r7, #12]
3419ebac:	2b00      	cmp	r3, #0
3419ebae:	d001      	beq.n	3419ebb4 <VD55G1_Setup+0x108>
3419ebb0:	68fb      	ldr	r3, [r7, #12]
3419ebb2:	e080      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupExposure(ctx);
3419ebb4:	6878      	ldr	r0, [r7, #4]
3419ebb6:	f7ff fd99 	bl	3419e6ec <VD55G1_SetupExposure>
3419ebba:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ebbc:	68fb      	ldr	r3, [r7, #12]
3419ebbe:	2b00      	cmp	r3, #0
3419ebc0:	d00d      	beq.n	3419ebde <VD55G1_Setup+0x132>
3419ebc2:	68fb      	ldr	r3, [r7, #12]
3419ebc4:	9302      	str	r3, [sp, #8]
3419ebc6:	f240 330a 	movw	r3, #778	@ 0x30a
3419ebca:	9301      	str	r3, [sp, #4]
3419ebcc:	4b3c      	ldr	r3, [pc, #240]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419ebce:	9300      	str	r3, [sp, #0]
3419ebd0:	f240 330a 	movw	r3, #778	@ 0x30a
3419ebd4:	4a3b      	ldr	r2, [pc, #236]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419ebd6:	2100      	movs	r1, #0
3419ebd8:	6878      	ldr	r0, [r7, #4]
3419ebda:	f7fe fe25 	bl	3419d828 <VD55G1_log_impl>
3419ebde:	68fb      	ldr	r3, [r7, #12]
3419ebe0:	2b00      	cmp	r3, #0
3419ebe2:	d002      	beq.n	3419ebea <VD55G1_Setup+0x13e>
3419ebe4:	6878      	ldr	r0, [r7, #4]
3419ebe6:	f7fe fe3b 	bl	3419d860 <display_error>
3419ebea:	68fb      	ldr	r3, [r7, #12]
3419ebec:	2b00      	cmp	r3, #0
3419ebee:	d001      	beq.n	3419ebf4 <VD55G1_Setup+0x148>
3419ebf0:	68fb      	ldr	r3, [r7, #12]
3419ebf2:	e060      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupMirrorFlip(ctx);
3419ebf4:	6878      	ldr	r0, [r7, #4]
3419ebf6:	f7ff fe0f 	bl	3419e818 <VD55G1_SetupMirrorFlip>
3419ebfa:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ebfc:	68fb      	ldr	r3, [r7, #12]
3419ebfe:	2b00      	cmp	r3, #0
3419ec00:	d00d      	beq.n	3419ec1e <VD55G1_Setup+0x172>
3419ec02:	68fb      	ldr	r3, [r7, #12]
3419ec04:	9302      	str	r3, [sp, #8]
3419ec06:	f240 330d 	movw	r3, #781	@ 0x30d
3419ec0a:	9301      	str	r3, [sp, #4]
3419ec0c:	4b2c      	ldr	r3, [pc, #176]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419ec0e:	9300      	str	r3, [sp, #0]
3419ec10:	f240 330d 	movw	r3, #781	@ 0x30d
3419ec14:	4a2b      	ldr	r2, [pc, #172]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419ec16:	2100      	movs	r1, #0
3419ec18:	6878      	ldr	r0, [r7, #4]
3419ec1a:	f7fe fe05 	bl	3419d828 <VD55G1_log_impl>
3419ec1e:	68fb      	ldr	r3, [r7, #12]
3419ec20:	2b00      	cmp	r3, #0
3419ec22:	d002      	beq.n	3419ec2a <VD55G1_Setup+0x17e>
3419ec24:	6878      	ldr	r0, [r7, #4]
3419ec26:	f7fe fe1b 	bl	3419d860 <display_error>
3419ec2a:	68fb      	ldr	r3, [r7, #12]
3419ec2c:	2b00      	cmp	r3, #0
3419ec2e:	d001      	beq.n	3419ec34 <VD55G1_Setup+0x188>
3419ec30:	68fb      	ldr	r3, [r7, #12]
3419ec32:	e040      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupPatGen(ctx);
3419ec34:	6878      	ldr	r0, [r7, #4]
3419ec36:	f7ff fe41 	bl	3419e8bc <VD55G1_SetupPatGen>
3419ec3a:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ec3c:	68fb      	ldr	r3, [r7, #12]
3419ec3e:	2b00      	cmp	r3, #0
3419ec40:	d00d      	beq.n	3419ec5e <VD55G1_Setup+0x1b2>
3419ec42:	68fb      	ldr	r3, [r7, #12]
3419ec44:	9302      	str	r3, [sp, #8]
3419ec46:	f44f 7344 	mov.w	r3, #784	@ 0x310
3419ec4a:	9301      	str	r3, [sp, #4]
3419ec4c:	4b1c      	ldr	r3, [pc, #112]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419ec4e:	9300      	str	r3, [sp, #0]
3419ec50:	f44f 7344 	mov.w	r3, #784	@ 0x310
3419ec54:	4a1b      	ldr	r2, [pc, #108]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419ec56:	2100      	movs	r1, #0
3419ec58:	6878      	ldr	r0, [r7, #4]
3419ec5a:	f7fe fde5 	bl	3419d828 <VD55G1_log_impl>
3419ec5e:	68fb      	ldr	r3, [r7, #12]
3419ec60:	2b00      	cmp	r3, #0
3419ec62:	d002      	beq.n	3419ec6a <VD55G1_Setup+0x1be>
3419ec64:	6878      	ldr	r0, [r7, #4]
3419ec66:	f7fe fdfb 	bl	3419d860 <display_error>
3419ec6a:	68fb      	ldr	r3, [r7, #12]
3419ec6c:	2b00      	cmp	r3, #0
3419ec6e:	d001      	beq.n	3419ec74 <VD55G1_Setup+0x1c8>
3419ec70:	68fb      	ldr	r3, [r7, #12]
3419ec72:	e020      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  ret = VD55G1_Flicker(ctx);
3419ec74:	6878      	ldr	r0, [r7, #4]
3419ec76:	f7ff ff07 	bl	3419ea88 <VD55G1_Flicker>
3419ec7a:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ec7c:	68fb      	ldr	r3, [r7, #12]
3419ec7e:	2b00      	cmp	r3, #0
3419ec80:	d00d      	beq.n	3419ec9e <VD55G1_Setup+0x1f2>
3419ec82:	68fb      	ldr	r3, [r7, #12]
3419ec84:	9302      	str	r3, [sp, #8]
3419ec86:	f240 3313 	movw	r3, #787	@ 0x313
3419ec8a:	9301      	str	r3, [sp, #4]
3419ec8c:	4b0c      	ldr	r3, [pc, #48]	@ (3419ecc0 <VD55G1_Setup+0x214>)
3419ec8e:	9300      	str	r3, [sp, #0]
3419ec90:	f240 3313 	movw	r3, #787	@ 0x313
3419ec94:	4a0b      	ldr	r2, [pc, #44]	@ (3419ecc4 <VD55G1_Setup+0x218>)
3419ec96:	2100      	movs	r1, #0
3419ec98:	6878      	ldr	r0, [r7, #4]
3419ec9a:	f7fe fdc5 	bl	3419d828 <VD55G1_log_impl>
3419ec9e:	68fb      	ldr	r3, [r7, #12]
3419eca0:	2b00      	cmp	r3, #0
3419eca2:	d002      	beq.n	3419ecaa <VD55G1_Setup+0x1fe>
3419eca4:	6878      	ldr	r0, [r7, #4]
3419eca6:	f7fe fddb 	bl	3419d860 <display_error>
3419ecaa:	68fb      	ldr	r3, [r7, #12]
3419ecac:	2b00      	cmp	r3, #0
3419ecae:	d001      	beq.n	3419ecb4 <VD55G1_Setup+0x208>
3419ecb0:	68fb      	ldr	r3, [r7, #12]
3419ecb2:	e000      	b.n	3419ecb6 <VD55G1_Setup+0x20a>

  return 0;
3419ecb4:	2300      	movs	r3, #0
}
3419ecb6:	4618      	mov	r0, r3
3419ecb8:	3710      	adds	r7, #16
3419ecba:	46bd      	mov	sp, r7
3419ecbc:	bd80      	pop	{r7, pc}
3419ecbe:	bf00      	nop
3419ecc0:	341b3020 	.word	0x341b3020
3419ecc4:	341a60e4 	.word	0x341a60e4

3419ecc8 <VD55G1_StartStreaming>:

static int VD55G1_StartStreaming(VD55G1_Ctx_t *ctx)
{
3419ecc8:	b580      	push	{r7, lr}
3419ecca:	b088      	sub	sp, #32
3419eccc:	af04      	add	r7, sp, #16
3419ecce:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STBY, VD55G1_STBY_START_STREAM);
3419ecd0:	687b      	ldr	r3, [r7, #4]
3419ecd2:	691b      	ldr	r3, [r3, #16]
3419ecd4:	2201      	movs	r2, #1
3419ecd6:	f240 2101 	movw	r1, #513	@ 0x201
3419ecda:	6878      	ldr	r0, [r7, #4]
3419ecdc:	4798      	blx	r3
3419ecde:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ece0:	68fb      	ldr	r3, [r7, #12]
3419ece2:	2b00      	cmp	r3, #0
3419ece4:	d00d      	beq.n	3419ed02 <VD55G1_StartStreaming+0x3a>
3419ece6:	68fb      	ldr	r3, [r7, #12]
3419ece8:	9302      	str	r3, [sp, #8]
3419ecea:	f240 331d 	movw	r3, #797	@ 0x31d
3419ecee:	9301      	str	r3, [sp, #4]
3419ecf0:	4b31      	ldr	r3, [pc, #196]	@ (3419edb8 <VD55G1_StartStreaming+0xf0>)
3419ecf2:	9300      	str	r3, [sp, #0]
3419ecf4:	f240 331d 	movw	r3, #797	@ 0x31d
3419ecf8:	4a30      	ldr	r2, [pc, #192]	@ (3419edbc <VD55G1_StartStreaming+0xf4>)
3419ecfa:	2100      	movs	r1, #0
3419ecfc:	6878      	ldr	r0, [r7, #4]
3419ecfe:	f7fe fd93 	bl	3419d828 <VD55G1_log_impl>
3419ed02:	68fb      	ldr	r3, [r7, #12]
3419ed04:	2b00      	cmp	r3, #0
3419ed06:	d002      	beq.n	3419ed0e <VD55G1_StartStreaming+0x46>
3419ed08:	6878      	ldr	r0, [r7, #4]
3419ed0a:	f7fe fda9 	bl	3419d860 <display_error>
3419ed0e:	68fb      	ldr	r3, [r7, #12]
3419ed10:	2b00      	cmp	r3, #0
3419ed12:	d001      	beq.n	3419ed18 <VD55G1_StartStreaming+0x50>
3419ed14:	68fb      	ldr	r3, [r7, #12]
3419ed16:	e04b      	b.n	3419edb0 <VD55G1_StartStreaming+0xe8>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STBY, VD55G1_CMD_ACK);
3419ed18:	2200      	movs	r2, #0
3419ed1a:	f240 2101 	movw	r1, #513	@ 0x201
3419ed1e:	6878      	ldr	r0, [r7, #4]
3419ed20:	f7fe fdc8 	bl	3419d8b4 <VD55G1_PollReg8>
3419ed24:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ed26:	68fb      	ldr	r3, [r7, #12]
3419ed28:	2b00      	cmp	r3, #0
3419ed2a:	d00d      	beq.n	3419ed48 <VD55G1_StartStreaming+0x80>
3419ed2c:	68fb      	ldr	r3, [r7, #12]
3419ed2e:	9302      	str	r3, [sp, #8]
3419ed30:	f44f 7348 	mov.w	r3, #800	@ 0x320
3419ed34:	9301      	str	r3, [sp, #4]
3419ed36:	4b20      	ldr	r3, [pc, #128]	@ (3419edb8 <VD55G1_StartStreaming+0xf0>)
3419ed38:	9300      	str	r3, [sp, #0]
3419ed3a:	f44f 7348 	mov.w	r3, #800	@ 0x320
3419ed3e:	4a1f      	ldr	r2, [pc, #124]	@ (3419edbc <VD55G1_StartStreaming+0xf4>)
3419ed40:	2100      	movs	r1, #0
3419ed42:	6878      	ldr	r0, [r7, #4]
3419ed44:	f7fe fd70 	bl	3419d828 <VD55G1_log_impl>
3419ed48:	68fb      	ldr	r3, [r7, #12]
3419ed4a:	2b00      	cmp	r3, #0
3419ed4c:	d002      	beq.n	3419ed54 <VD55G1_StartStreaming+0x8c>
3419ed4e:	6878      	ldr	r0, [r7, #4]
3419ed50:	f7fe fd86 	bl	3419d860 <display_error>
3419ed54:	68fb      	ldr	r3, [r7, #12]
3419ed56:	2b00      	cmp	r3, #0
3419ed58:	d001      	beq.n	3419ed5e <VD55G1_StartStreaming+0x96>
3419ed5a:	68fb      	ldr	r3, [r7, #12]
3419ed5c:	e028      	b.n	3419edb0 <VD55G1_StartStreaming+0xe8>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_STREAMING);
3419ed5e:	2103      	movs	r1, #3
3419ed60:	6878      	ldr	r0, [r7, #4]
3419ed62:	f7fe fe07 	bl	3419d974 <VD55G1_WaitState>
3419ed66:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ed68:	68fb      	ldr	r3, [r7, #12]
3419ed6a:	2b00      	cmp	r3, #0
3419ed6c:	d00d      	beq.n	3419ed8a <VD55G1_StartStreaming+0xc2>
3419ed6e:	68fb      	ldr	r3, [r7, #12]
3419ed70:	9302      	str	r3, [sp, #8]
3419ed72:	f240 3323 	movw	r3, #803	@ 0x323
3419ed76:	9301      	str	r3, [sp, #4]
3419ed78:	4b0f      	ldr	r3, [pc, #60]	@ (3419edb8 <VD55G1_StartStreaming+0xf0>)
3419ed7a:	9300      	str	r3, [sp, #0]
3419ed7c:	f240 3323 	movw	r3, #803	@ 0x323
3419ed80:	4a0e      	ldr	r2, [pc, #56]	@ (3419edbc <VD55G1_StartStreaming+0xf4>)
3419ed82:	2100      	movs	r1, #0
3419ed84:	6878      	ldr	r0, [r7, #4]
3419ed86:	f7fe fd4f 	bl	3419d828 <VD55G1_log_impl>
3419ed8a:	68fb      	ldr	r3, [r7, #12]
3419ed8c:	2b00      	cmp	r3, #0
3419ed8e:	d002      	beq.n	3419ed96 <VD55G1_StartStreaming+0xce>
3419ed90:	6878      	ldr	r0, [r7, #4]
3419ed92:	f7fe fd65 	bl	3419d860 <display_error>
3419ed96:	68fb      	ldr	r3, [r7, #12]
3419ed98:	2b00      	cmp	r3, #0
3419ed9a:	d001      	beq.n	3419eda0 <VD55G1_StartStreaming+0xd8>
3419ed9c:	68fb      	ldr	r3, [r7, #12]
3419ed9e:	e007      	b.n	3419edb0 <VD55G1_StartStreaming+0xe8>

  VD55G1_notice(ctx, "Streaming is on\n");
3419eda0:	f240 3325 	movw	r3, #805	@ 0x325
3419eda4:	4a06      	ldr	r2, [pc, #24]	@ (3419edc0 <VD55G1_StartStreaming+0xf8>)
3419eda6:	2102      	movs	r1, #2
3419eda8:	6878      	ldr	r0, [r7, #4]
3419edaa:	f7fe fd3d 	bl	3419d828 <VD55G1_log_impl>

  return 0;
3419edae:	2300      	movs	r3, #0
}
3419edb0:	4618      	mov	r0, r3
3419edb2:	3710      	adds	r7, #16
3419edb4:	46bd      	mov	sp, r7
3419edb6:	bd80      	pop	{r7, pc}
3419edb8:	341b3030 	.word	0x341b3030
3419edbc:	341a60e4 	.word	0x341a60e4
3419edc0:	341a63d4 	.word	0x341a63d4

3419edc4 <VD55G1_StopStreaming>:

static int VD55G1_StopStreaming(VD55G1_Ctx_t *ctx)
{
3419edc4:	b580      	push	{r7, lr}
3419edc6:	b088      	sub	sp, #32
3419edc8:	af04      	add	r7, sp, #16
3419edca:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
3419edcc:	687b      	ldr	r3, [r7, #4]
3419edce:	691b      	ldr	r3, [r3, #16]
3419edd0:	2201      	movs	r2, #1
3419edd2:	f240 2102 	movw	r1, #514	@ 0x202
3419edd6:	6878      	ldr	r0, [r7, #4]
3419edd8:	4798      	blx	r3
3419edda:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419eddc:	68fb      	ldr	r3, [r7, #12]
3419edde:	2b00      	cmp	r3, #0
3419ede0:	d00d      	beq.n	3419edfe <VD55G1_StopStreaming+0x3a>
3419ede2:	68fb      	ldr	r3, [r7, #12]
3419ede4:	9302      	str	r3, [sp, #8]
3419ede6:	f240 332f 	movw	r3, #815	@ 0x32f
3419edea:	9301      	str	r3, [sp, #4]
3419edec:	4b31      	ldr	r3, [pc, #196]	@ (3419eeb4 <VD55G1_StopStreaming+0xf0>)
3419edee:	9300      	str	r3, [sp, #0]
3419edf0:	f240 332f 	movw	r3, #815	@ 0x32f
3419edf4:	4a30      	ldr	r2, [pc, #192]	@ (3419eeb8 <VD55G1_StopStreaming+0xf4>)
3419edf6:	2100      	movs	r1, #0
3419edf8:	6878      	ldr	r0, [r7, #4]
3419edfa:	f7fe fd15 	bl	3419d828 <VD55G1_log_impl>
3419edfe:	68fb      	ldr	r3, [r7, #12]
3419ee00:	2b00      	cmp	r3, #0
3419ee02:	d002      	beq.n	3419ee0a <VD55G1_StopStreaming+0x46>
3419ee04:	6878      	ldr	r0, [r7, #4]
3419ee06:	f7fe fd2b 	bl	3419d860 <display_error>
3419ee0a:	68fb      	ldr	r3, [r7, #12]
3419ee0c:	2b00      	cmp	r3, #0
3419ee0e:	d001      	beq.n	3419ee14 <VD55G1_StopStreaming+0x50>
3419ee10:	68fb      	ldr	r3, [r7, #12]
3419ee12:	e04b      	b.n	3419eeac <VD55G1_StopStreaming+0xe8>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STREAMING, VD55G1_CMD_ACK);
3419ee14:	2200      	movs	r2, #0
3419ee16:	f240 2102 	movw	r1, #514	@ 0x202
3419ee1a:	6878      	ldr	r0, [r7, #4]
3419ee1c:	f7fe fd4a 	bl	3419d8b4 <VD55G1_PollReg8>
3419ee20:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ee22:	68fb      	ldr	r3, [r7, #12]
3419ee24:	2b00      	cmp	r3, #0
3419ee26:	d00d      	beq.n	3419ee44 <VD55G1_StopStreaming+0x80>
3419ee28:	68fb      	ldr	r3, [r7, #12]
3419ee2a:	9302      	str	r3, [sp, #8]
3419ee2c:	f240 3332 	movw	r3, #818	@ 0x332
3419ee30:	9301      	str	r3, [sp, #4]
3419ee32:	4b20      	ldr	r3, [pc, #128]	@ (3419eeb4 <VD55G1_StopStreaming+0xf0>)
3419ee34:	9300      	str	r3, [sp, #0]
3419ee36:	f240 3332 	movw	r3, #818	@ 0x332
3419ee3a:	4a1f      	ldr	r2, [pc, #124]	@ (3419eeb8 <VD55G1_StopStreaming+0xf4>)
3419ee3c:	2100      	movs	r1, #0
3419ee3e:	6878      	ldr	r0, [r7, #4]
3419ee40:	f7fe fcf2 	bl	3419d828 <VD55G1_log_impl>
3419ee44:	68fb      	ldr	r3, [r7, #12]
3419ee46:	2b00      	cmp	r3, #0
3419ee48:	d002      	beq.n	3419ee50 <VD55G1_StopStreaming+0x8c>
3419ee4a:	6878      	ldr	r0, [r7, #4]
3419ee4c:	f7fe fd08 	bl	3419d860 <display_error>
3419ee50:	68fb      	ldr	r3, [r7, #12]
3419ee52:	2b00      	cmp	r3, #0
3419ee54:	d001      	beq.n	3419ee5a <VD55G1_StopStreaming+0x96>
3419ee56:	68fb      	ldr	r3, [r7, #12]
3419ee58:	e028      	b.n	3419eeac <VD55G1_StopStreaming+0xe8>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
3419ee5a:	2102      	movs	r1, #2
3419ee5c:	6878      	ldr	r0, [r7, #4]
3419ee5e:	f7fe fd89 	bl	3419d974 <VD55G1_WaitState>
3419ee62:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ee64:	68fb      	ldr	r3, [r7, #12]
3419ee66:	2b00      	cmp	r3, #0
3419ee68:	d00d      	beq.n	3419ee86 <VD55G1_StopStreaming+0xc2>
3419ee6a:	68fb      	ldr	r3, [r7, #12]
3419ee6c:	9302      	str	r3, [sp, #8]
3419ee6e:	f240 3335 	movw	r3, #821	@ 0x335
3419ee72:	9301      	str	r3, [sp, #4]
3419ee74:	4b0f      	ldr	r3, [pc, #60]	@ (3419eeb4 <VD55G1_StopStreaming+0xf0>)
3419ee76:	9300      	str	r3, [sp, #0]
3419ee78:	f240 3335 	movw	r3, #821	@ 0x335
3419ee7c:	4a0e      	ldr	r2, [pc, #56]	@ (3419eeb8 <VD55G1_StopStreaming+0xf4>)
3419ee7e:	2100      	movs	r1, #0
3419ee80:	6878      	ldr	r0, [r7, #4]
3419ee82:	f7fe fcd1 	bl	3419d828 <VD55G1_log_impl>
3419ee86:	68fb      	ldr	r3, [r7, #12]
3419ee88:	2b00      	cmp	r3, #0
3419ee8a:	d002      	beq.n	3419ee92 <VD55G1_StopStreaming+0xce>
3419ee8c:	6878      	ldr	r0, [r7, #4]
3419ee8e:	f7fe fce7 	bl	3419d860 <display_error>
3419ee92:	68fb      	ldr	r3, [r7, #12]
3419ee94:	2b00      	cmp	r3, #0
3419ee96:	d001      	beq.n	3419ee9c <VD55G1_StopStreaming+0xd8>
3419ee98:	68fb      	ldr	r3, [r7, #12]
3419ee9a:	e007      	b.n	3419eeac <VD55G1_StopStreaming+0xe8>

  VD55G1_notice(ctx, "Streaming is off\n");
3419ee9c:	f240 3337 	movw	r3, #823	@ 0x337
3419eea0:	4a06      	ldr	r2, [pc, #24]	@ (3419eebc <VD55G1_StopStreaming+0xf8>)
3419eea2:	2102      	movs	r1, #2
3419eea4:	6878      	ldr	r0, [r7, #4]
3419eea6:	f7fe fcbf 	bl	3419d828 <VD55G1_log_impl>

  return 0;
3419eeaa:	2300      	movs	r3, #0
}
3419eeac:	4618      	mov	r0, r3
3419eeae:	3710      	adds	r7, #16
3419eeb0:	46bd      	mov	sp, r7
3419eeb2:	bd80      	pop	{r7, pc}
3419eeb4:	341b3048 	.word	0x341b3048
3419eeb8:	341a60e4 	.word	0x341a60e4
3419eebc:	341a63f8 	.word	0x341a63f8

3419eec0 <VD55G1_Init>:

  return VD55G1_StartAWU(ctx);
}

int VD55G1_Init(VD55G1_Ctx_t *ctx, VD55G1_Config_t *config)
{
3419eec0:	b5b0      	push	{r4, r5, r7, lr}
3419eec2:	b086      	sub	sp, #24
3419eec4:	af00      	add	r7, sp, #0
3419eec6:	6078      	str	r0, [r7, #4]
3419eec8:	6039      	str	r1, [r7, #0]
  VD55G1_AWUConfig_t *awu = &config->awu;
3419eeca:	683b      	ldr	r3, [r7, #0]
3419eecc:	331c      	adds	r3, #28
3419eece:	617b      	str	r3, [r7, #20]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419eed0:	687b      	ldr	r3, [r7, #4]
3419eed2:	3328      	adds	r3, #40	@ 0x28
3419eed4:	613b      	str	r3, [r7, #16]
  int ret;

  if (config->frame_rate < VD55G1_MIN_FPS)
3419eed6:	683b      	ldr	r3, [r7, #0]
3419eed8:	689b      	ldr	r3, [r3, #8]
3419eeda:	2b01      	cmp	r3, #1
3419eedc:	dc02      	bgt.n	3419eee4 <VD55G1_Init+0x24>
    return -1;
3419eede:	f04f 33ff 	mov.w	r3, #4294967295
3419eee2:	e05d      	b.n	3419efa0 <VD55G1_Init+0xe0>
  if (config->frame_rate > VD55G1_MAX_FPS)
3419eee4:	683b      	ldr	r3, [r7, #0]
3419eee6:	689b      	ldr	r3, [r3, #8]
3419eee8:	2ba8      	cmp	r3, #168	@ 0xa8
3419eeea:	dd02      	ble.n	3419eef2 <VD55G1_Init+0x32>
    return -1;
3419eeec:	f04f 33ff 	mov.w	r3, #4294967295
3419eef0:	e056      	b.n	3419efa0 <VD55G1_Init+0xe0>

  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
3419eef2:	683b      	ldr	r3, [r7, #0]
3419eef4:	791b      	ldrb	r3, [r3, #4]
3419eef6:	2b00      	cmp	r3, #0
3419eef8:	d00e      	beq.n	3419ef18 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_VGA_640_480) &&
3419eefa:	683b      	ldr	r3, [r7, #0]
3419eefc:	791b      	ldrb	r3, [r3, #4]
  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
3419eefe:	2b01      	cmp	r3, #1
3419ef00:	d00a      	beq.n	3419ef18 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_SXGA_800_600) &&
3419ef02:	683b      	ldr	r3, [r7, #0]
3419ef04:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD55G1_RES_VGA_640_480) &&
3419ef06:	2b02      	cmp	r3, #2
3419ef08:	d006      	beq.n	3419ef18 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_FULL_804_704)) {
3419ef0a:	683b      	ldr	r3, [r7, #0]
3419ef0c:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD55G1_RES_SXGA_800_600) &&
3419ef0e:	2b03      	cmp	r3, #3
3419ef10:	d002      	beq.n	3419ef18 <VD55G1_Init+0x58>
    return -1;
3419ef12:	f04f 33ff 	mov.w	r3, #4294967295
3419ef16:	e043      	b.n	3419efa0 <VD55G1_Init+0xe0>
  }

  if (awu->is_enable && awu->threshold != VD55G1_AWU_THRESHOLD_DEFAULT) {
3419ef18:	697b      	ldr	r3, [r7, #20]
3419ef1a:	681b      	ldr	r3, [r3, #0]
3419ef1c:	2b00      	cmp	r3, #0
3419ef1e:	d011      	beq.n	3419ef44 <VD55G1_Init+0x84>
3419ef20:	697b      	ldr	r3, [r7, #20]
3419ef22:	691b      	ldr	r3, [r3, #16]
3419ef24:	2b00      	cmp	r3, #0
3419ef26:	d00d      	beq.n	3419ef44 <VD55G1_Init+0x84>
    if (awu->threshold < VD55G1_AWU_THRESHOLD_MIN)
3419ef28:	697b      	ldr	r3, [r7, #20]
3419ef2a:	691b      	ldr	r3, [r3, #16]
3419ef2c:	2b01      	cmp	r3, #1
3419ef2e:	dc02      	bgt.n	3419ef36 <VD55G1_Init+0x76>
      return -1;
3419ef30:	f04f 33ff 	mov.w	r3, #4294967295
3419ef34:	e034      	b.n	3419efa0 <VD55G1_Init+0xe0>
    if (awu->threshold > VD55G1_AWU_THRESHOLD_MAX)
3419ef36:	697b      	ldr	r3, [r7, #20]
3419ef38:	691b      	ldr	r3, [r3, #16]
3419ef3a:	2b80      	cmp	r3, #128	@ 0x80
3419ef3c:	dd02      	ble.n	3419ef44 <VD55G1_Init+0x84>
      return -1;
3419ef3e:	f04f 33ff 	mov.w	r3, #4294967295
3419ef42:	e02d      	b.n	3419efa0 <VD55G1_Init+0xe0>
  }

  drv_ctx->config_save = *config;
3419ef44:	693b      	ldr	r3, [r7, #16]
3419ef46:	683a      	ldr	r2, [r7, #0]
3419ef48:	f103 040c 	add.w	r4, r3, #12
3419ef4c:	4615      	mov	r5, r2
3419ef4e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419ef50:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419ef52:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419ef54:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419ef56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419ef58:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419ef5a:	682b      	ldr	r3, [r5, #0]
3419ef5c:	6023      	str	r3, [r4, #0]

  ctx->shutdown_pin(ctx, 0);
3419ef5e:	687b      	ldr	r3, [r7, #4]
3419ef60:	681b      	ldr	r3, [r3, #0]
3419ef62:	2100      	movs	r1, #0
3419ef64:	6878      	ldr	r0, [r7, #4]
3419ef66:	4798      	blx	r3
  ctx->delay(ctx, 10);
3419ef68:	687b      	ldr	r3, [r7, #4]
3419ef6a:	6a1b      	ldr	r3, [r3, #32]
3419ef6c:	210a      	movs	r1, #10
3419ef6e:	6878      	ldr	r0, [r7, #4]
3419ef70:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
3419ef72:	687b      	ldr	r3, [r7, #4]
3419ef74:	681b      	ldr	r3, [r3, #0]
3419ef76:	2101      	movs	r1, #1
3419ef78:	6878      	ldr	r0, [r7, #4]
3419ef7a:	4798      	blx	r3
  ctx->delay(ctx, 10);
3419ef7c:	687b      	ldr	r3, [r7, #4]
3419ef7e:	6a1b      	ldr	r3, [r3, #32]
3419ef80:	210a      	movs	r1, #10
3419ef82:	6878      	ldr	r0, [r7, #4]
3419ef84:	4798      	blx	r3

  ret = VD55G1_Boot(ctx);
3419ef86:	6878      	ldr	r0, [r7, #4]
3419ef88:	f7fe ff8c 	bl	3419dea4 <VD55G1_Boot>
3419ef8c:	60f8      	str	r0, [r7, #12]
  if (ret)
3419ef8e:	68fb      	ldr	r3, [r7, #12]
3419ef90:	2b00      	cmp	r3, #0
3419ef92:	d001      	beq.n	3419ef98 <VD55G1_Init+0xd8>
    return ret;
3419ef94:	68fb      	ldr	r3, [r7, #12]
3419ef96:	e003      	b.n	3419efa0 <VD55G1_Init+0xe0>

  drv_ctx->state = VD55G1_ST_IDLE;
3419ef98:	693b      	ldr	r3, [r7, #16]
3419ef9a:	2200      	movs	r2, #0
3419ef9c:	601a      	str	r2, [r3, #0]

  return 0;
3419ef9e:	2300      	movs	r3, #0
}
3419efa0:	4618      	mov	r0, r3
3419efa2:	3718      	adds	r7, #24
3419efa4:	46bd      	mov	sp, r7
3419efa6:	bdb0      	pop	{r4, r5, r7, pc}

3419efa8 <VD55G1_DeInit>:

int VD55G1_DeInit(VD55G1_Ctx_t *ctx)
{
3419efa8:	b580      	push	{r7, lr}
3419efaa:	b084      	sub	sp, #16
3419efac:	af00      	add	r7, sp, #0
3419efae:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419efb0:	687b      	ldr	r3, [r7, #4]
3419efb2:	3328      	adds	r3, #40	@ 0x28
3419efb4:	60fb      	str	r3, [r7, #12]

  if (drv_ctx->state == VD55G1_ST_STREAMING)
3419efb6:	68fb      	ldr	r3, [r7, #12]
3419efb8:	681b      	ldr	r3, [r3, #0]
3419efba:	2b01      	cmp	r3, #1
3419efbc:	d102      	bne.n	3419efc4 <VD55G1_DeInit+0x1c>
    return -1;
3419efbe:	f04f 33ff 	mov.w	r3, #4294967295
3419efc2:	e00a      	b.n	3419efda <VD55G1_DeInit+0x32>

  ctx->shutdown_pin(ctx, 0);
3419efc4:	687b      	ldr	r3, [r7, #4]
3419efc6:	681b      	ldr	r3, [r3, #0]
3419efc8:	2100      	movs	r1, #0
3419efca:	6878      	ldr	r0, [r7, #4]
3419efcc:	4798      	blx	r3
  ctx->delay(ctx, 10);
3419efce:	687b      	ldr	r3, [r7, #4]
3419efd0:	6a1b      	ldr	r3, [r3, #32]
3419efd2:	210a      	movs	r1, #10
3419efd4:	6878      	ldr	r0, [r7, #4]
3419efd6:	4798      	blx	r3

  return 0;
3419efd8:	2300      	movs	r3, #0
}
3419efda:	4618      	mov	r0, r3
3419efdc:	3710      	adds	r7, #16
3419efde:	46bd      	mov	sp, r7
3419efe0:	bd80      	pop	{r7, pc}

3419efe2 <VD55G1_Start>:

int VD55G1_Start(VD55G1_Ctx_t *ctx)
{
3419efe2:	b580      	push	{r7, lr}
3419efe4:	b084      	sub	sp, #16
3419efe6:	af00      	add	r7, sp, #0
3419efe8:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419efea:	687b      	ldr	r3, [r7, #4]
3419efec:	3328      	adds	r3, #40	@ 0x28
3419efee:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD55G1_Setup(ctx);
3419eff0:	6878      	ldr	r0, [r7, #4]
3419eff2:	f7ff fd5b 	bl	3419eaac <VD55G1_Setup>
3419eff6:	60b8      	str	r0, [r7, #8]
  if (ret)
3419eff8:	68bb      	ldr	r3, [r7, #8]
3419effa:	2b00      	cmp	r3, #0
3419effc:	d001      	beq.n	3419f002 <VD55G1_Start+0x20>
    return ret;
3419effe:	68bb      	ldr	r3, [r7, #8]
3419f000:	e00c      	b.n	3419f01c <VD55G1_Start+0x3a>

  ret = VD55G1_StartStreaming(ctx);
3419f002:	6878      	ldr	r0, [r7, #4]
3419f004:	f7ff fe60 	bl	3419ecc8 <VD55G1_StartStreaming>
3419f008:	60b8      	str	r0, [r7, #8]
  if (ret)
3419f00a:	68bb      	ldr	r3, [r7, #8]
3419f00c:	2b00      	cmp	r3, #0
3419f00e:	d001      	beq.n	3419f014 <VD55G1_Start+0x32>
    return ret;
3419f010:	68bb      	ldr	r3, [r7, #8]
3419f012:	e003      	b.n	3419f01c <VD55G1_Start+0x3a>
  drv_ctx->state = VD55G1_ST_STREAMING;
3419f014:	68fb      	ldr	r3, [r7, #12]
3419f016:	2201      	movs	r2, #1
3419f018:	601a      	str	r2, [r3, #0]

  return 0;
3419f01a:	2300      	movs	r3, #0
}
3419f01c:	4618      	mov	r0, r3
3419f01e:	3710      	adds	r7, #16
3419f020:	46bd      	mov	sp, r7
3419f022:	bd80      	pop	{r7, pc}

3419f024 <VD55G1_Stop>:

int VD55G1_Stop(VD55G1_Ctx_t *ctx)
{
3419f024:	b580      	push	{r7, lr}
3419f026:	b084      	sub	sp, #16
3419f028:	af00      	add	r7, sp, #0
3419f02a:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f02c:	687b      	ldr	r3, [r7, #4]
3419f02e:	3328      	adds	r3, #40	@ 0x28
3419f030:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD55G1_StopStreaming(ctx);
3419f032:	6878      	ldr	r0, [r7, #4]
3419f034:	f7ff fec6 	bl	3419edc4 <VD55G1_StopStreaming>
3419f038:	60b8      	str	r0, [r7, #8]
  if (ret)
3419f03a:	68bb      	ldr	r3, [r7, #8]
3419f03c:	2b00      	cmp	r3, #0
3419f03e:	d001      	beq.n	3419f044 <VD55G1_Stop+0x20>
    return ret;
3419f040:	68bb      	ldr	r3, [r7, #8]
3419f042:	e003      	b.n	3419f04c <VD55G1_Stop+0x28>
  drv_ctx->state = VD55G1_ST_IDLE;
3419f044:	68fb      	ldr	r3, [r7, #12]
3419f046:	2200      	movs	r2, #0
3419f048:	601a      	str	r2, [r3, #0]

  return 0;
3419f04a:	2300      	movs	r3, #0
}
3419f04c:	4618      	mov	r0, r3
3419f04e:	3710      	adds	r7, #16
3419f050:	46bd      	mov	sp, r7
3419f052:	bd80      	pop	{r7, pc}

3419f054 <VD55G1_SetFlipMirrorMode>:

  return 0;
}

int VD55G1_SetFlipMirrorMode(VD55G1_Ctx_t *ctx, VD55G1_MirrorFlip_t mode)
{
3419f054:	b580      	push	{r7, lr}
3419f056:	b086      	sub	sp, #24
3419f058:	af00      	add	r7, sp, #0
3419f05a:	6078      	str	r0, [r7, #4]
3419f05c:	460b      	mov	r3, r1
3419f05e:	70fb      	strb	r3, [r7, #3]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f060:	687b      	ldr	r3, [r7, #4]
3419f062:	3328      	adds	r3, #40	@ 0x28
3419f064:	617b      	str	r3, [r7, #20]
  int is_streaming;
  int ret;

  is_streaming = VD55G1_IsStreaming(ctx);
3419f066:	6878      	ldr	r0, [r7, #4]
3419f068:	f7fe fc68 	bl	3419d93c <VD55G1_IsStreaming>
3419f06c:	6138      	str	r0, [r7, #16]
  if (is_streaming < 0)
3419f06e:	693b      	ldr	r3, [r7, #16]
3419f070:	2b00      	cmp	r3, #0
3419f072:	da01      	bge.n	3419f078 <VD55G1_SetFlipMirrorMode+0x24>
    return is_streaming;
3419f074:	693b      	ldr	r3, [r7, #16]
3419f076:	e01b      	b.n	3419f0b0 <VD55G1_SetFlipMirrorMode+0x5c>

  if (is_streaming) {
3419f078:	693b      	ldr	r3, [r7, #16]
3419f07a:	2b00      	cmp	r3, #0
3419f07c:	d008      	beq.n	3419f090 <VD55G1_SetFlipMirrorMode+0x3c>
    ret = VD55G1_Stop(ctx);
3419f07e:	6878      	ldr	r0, [r7, #4]
3419f080:	f7ff ffd0 	bl	3419f024 <VD55G1_Stop>
3419f084:	60f8      	str	r0, [r7, #12]
    if (ret)
3419f086:	68fb      	ldr	r3, [r7, #12]
3419f088:	2b00      	cmp	r3, #0
3419f08a:	d001      	beq.n	3419f090 <VD55G1_SetFlipMirrorMode+0x3c>
      return ret;
3419f08c:	68fb      	ldr	r3, [r7, #12]
3419f08e:	e00f      	b.n	3419f0b0 <VD55G1_SetFlipMirrorMode+0x5c>
  }

  drv_ctx->config_save.flip_mirror_mode = mode;
3419f090:	697b      	ldr	r3, [r7, #20]
3419f092:	78fa      	ldrb	r2, [r7, #3]
3419f094:	761a      	strb	r2, [r3, #24]

  if (is_streaming) {
3419f096:	693b      	ldr	r3, [r7, #16]
3419f098:	2b00      	cmp	r3, #0
3419f09a:	d008      	beq.n	3419f0ae <VD55G1_SetFlipMirrorMode+0x5a>
    ret = VD55G1_Start(ctx);
3419f09c:	6878      	ldr	r0, [r7, #4]
3419f09e:	f7ff ffa0 	bl	3419efe2 <VD55G1_Start>
3419f0a2:	60f8      	str	r0, [r7, #12]
    if (ret)
3419f0a4:	68fb      	ldr	r3, [r7, #12]
3419f0a6:	2b00      	cmp	r3, #0
3419f0a8:	d001      	beq.n	3419f0ae <VD55G1_SetFlipMirrorMode+0x5a>
      return ret;
3419f0aa:	68fb      	ldr	r3, [r7, #12]
3419f0ac:	e000      	b.n	3419f0b0 <VD55G1_SetFlipMirrorMode+0x5c>
  }

  return 0;
3419f0ae:	2300      	movs	r3, #0
}
3419f0b0:	4618      	mov	r0, r3
3419f0b2:	3718      	adds	r7, #24
3419f0b4:	46bd      	mov	sp, r7
3419f0b6:	bd80      	pop	{r7, pc}

3419f0b8 <VD6G_dbg>:
  if (_ret_) display_error(_ctx_); \
  if (_ret_) return _ret_; \
} while(0)

static void VD6G_dbg(VD6G_Ctx_t *ctx, int lvl, const char *format, ...)
{
3419f0b8:	b40c      	push	{r2, r3}
3419f0ba:	b590      	push	{r4, r7, lr}
3419f0bc:	b085      	sub	sp, #20
3419f0be:	af00      	add	r7, sp, #0
3419f0c0:	6078      	str	r0, [r7, #4]
3419f0c2:	6039      	str	r1, [r7, #0]
  va_list ap;

  if (!ctx->log)
3419f0c4:	687b      	ldr	r3, [r7, #4]
3419f0c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419f0c8:	2b00      	cmp	r3, #0
3419f0ca:	d00b      	beq.n	3419f0e4 <VD6G_dbg+0x2c>
    return ;

  va_start(ap, format);
3419f0cc:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419f0d0:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
3419f0d2:	687b      	ldr	r3, [r7, #4]
3419f0d4:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419f0d6:	683b      	ldr	r3, [r7, #0]
3419f0d8:	1cd9      	adds	r1, r3, #3
3419f0da:	68fb      	ldr	r3, [r7, #12]
3419f0dc:	6a3a      	ldr	r2, [r7, #32]
3419f0de:	6878      	ldr	r0, [r7, #4]
3419f0e0:	47a0      	blx	r4
3419f0e2:	e000      	b.n	3419f0e6 <VD6G_dbg+0x2e>
    return ;
3419f0e4:	bf00      	nop
  va_end(ap);
}
3419f0e6:	3714      	adds	r7, #20
3419f0e8:	46bd      	mov	sp, r7
3419f0ea:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419f0ee:	b002      	add	sp, #8
3419f0f0:	4770      	bx	lr

3419f0f2 <VD6G_notice>:

static void VD6G_notice(VD6G_Ctx_t *ctx, const char *format, ...)
{
3419f0f2:	b40e      	push	{r1, r2, r3}
3419f0f4:	b590      	push	{r4, r7, lr}
3419f0f6:	b084      	sub	sp, #16
3419f0f8:	af00      	add	r7, sp, #0
3419f0fa:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
3419f0fc:	687b      	ldr	r3, [r7, #4]
3419f0fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419f100:	2b00      	cmp	r3, #0
3419f102:	d00a      	beq.n	3419f11a <VD6G_notice+0x28>
    return ;

  va_start(ap, format);
3419f104:	f107 0320 	add.w	r3, r7, #32
3419f108:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
3419f10a:	687b      	ldr	r3, [r7, #4]
3419f10c:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419f10e:	68fb      	ldr	r3, [r7, #12]
3419f110:	69fa      	ldr	r2, [r7, #28]
3419f112:	2102      	movs	r1, #2
3419f114:	6878      	ldr	r0, [r7, #4]
3419f116:	47a0      	blx	r4
3419f118:	e000      	b.n	3419f11c <VD6G_notice+0x2a>
    return ;
3419f11a:	bf00      	nop
  va_end(ap);
}
3419f11c:	3710      	adds	r7, #16
3419f11e:	46bd      	mov	sp, r7
3419f120:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419f124:	b003      	add	sp, #12
3419f126:	4770      	bx	lr

3419f128 <VD6G_warn>:

static void VD6G_warn(VD6G_Ctx_t *ctx, const char *format, ...)
{
3419f128:	b40e      	push	{r1, r2, r3}
3419f12a:	b590      	push	{r4, r7, lr}
3419f12c:	b084      	sub	sp, #16
3419f12e:	af00      	add	r7, sp, #0
3419f130:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
3419f132:	687b      	ldr	r3, [r7, #4]
3419f134:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419f136:	2b00      	cmp	r3, #0
3419f138:	d00a      	beq.n	3419f150 <VD6G_warn+0x28>
    return ;

  va_start(ap, format);
3419f13a:	f107 0320 	add.w	r3, r7, #32
3419f13e:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
3419f140:	687b      	ldr	r3, [r7, #4]
3419f142:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419f144:	68fb      	ldr	r3, [r7, #12]
3419f146:	69fa      	ldr	r2, [r7, #28]
3419f148:	2101      	movs	r1, #1
3419f14a:	6878      	ldr	r0, [r7, #4]
3419f14c:	47a0      	blx	r4
3419f14e:	e000      	b.n	3419f152 <VD6G_warn+0x2a>
    return ;
3419f150:	bf00      	nop
  va_end(ap);
}
3419f152:	3710      	adds	r7, #16
3419f154:	46bd      	mov	sp, r7
3419f156:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419f15a:	b003      	add	sp, #12
3419f15c:	4770      	bx	lr

3419f15e <VD6G_error>:

static void VD6G_error(VD6G_Ctx_t *ctx, const char *format, ...)
{
3419f15e:	b40e      	push	{r1, r2, r3}
3419f160:	b590      	push	{r4, r7, lr}
3419f162:	b084      	sub	sp, #16
3419f164:	af00      	add	r7, sp, #0
3419f166:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
3419f168:	687b      	ldr	r3, [r7, #4]
3419f16a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419f16c:	2b00      	cmp	r3, #0
3419f16e:	d00a      	beq.n	3419f186 <VD6G_error+0x28>
    return ;

  va_start(ap, format);
3419f170:	f107 0320 	add.w	r3, r7, #32
3419f174:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
3419f176:	687b      	ldr	r3, [r7, #4]
3419f178:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419f17a:	68fb      	ldr	r3, [r7, #12]
3419f17c:	69fa      	ldr	r2, [r7, #28]
3419f17e:	2100      	movs	r1, #0
3419f180:	6878      	ldr	r0, [r7, #4]
3419f182:	47a0      	blx	r4
3419f184:	e000      	b.n	3419f188 <VD6G_error+0x2a>
    return ;
3419f186:	bf00      	nop
  va_end(ap);
}
3419f188:	3710      	adds	r7, #16
3419f18a:	46bd      	mov	sp, r7
3419f18c:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419f190:	b003      	add	sp, #12
3419f192:	4770      	bx	lr

3419f194 <display_error>:

static void display_error(VD6G_Ctx_t *ctx)
{
3419f194:	b580      	push	{r7, lr}
3419f196:	b084      	sub	sp, #16
3419f198:	af00      	add	r7, sp, #0
3419f19a:	6078      	str	r0, [r7, #4]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
3419f19c:	687b      	ldr	r3, [r7, #4]
3419f19e:	689b      	ldr	r3, [r3, #8]
3419f1a0:	f107 020a 	add.w	r2, r7, #10
3419f1a4:	211c      	movs	r1, #28
3419f1a6:	6878      	ldr	r0, [r7, #4]
3419f1a8:	4798      	blx	r3
3419f1aa:	60f8      	str	r0, [r7, #12]
  assert(ret == 0);
3419f1ac:	68fb      	ldr	r3, [r7, #12]
3419f1ae:	2b00      	cmp	r3, #0
3419f1b0:	d006      	beq.n	3419f1c0 <display_error+0x2c>
3419f1b2:	4b08      	ldr	r3, [pc, #32]	@ (3419f1d4 <display_error+0x40>)
3419f1b4:	4a08      	ldr	r2, [pc, #32]	@ (3419f1d8 <display_error+0x44>)
3419f1b6:	f240 1131 	movw	r1, #305	@ 0x131
3419f1ba:	4808      	ldr	r0, [pc, #32]	@ (3419f1dc <display_error+0x48>)
3419f1bc:	f004 fb68 	bl	341a3890 <__assert_func>
  VD6G_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
3419f1c0:	897b      	ldrh	r3, [r7, #10]
3419f1c2:	461a      	mov	r2, r3
3419f1c4:	4906      	ldr	r1, [pc, #24]	@ (3419f1e0 <display_error+0x4c>)
3419f1c6:	6878      	ldr	r0, [r7, #4]
3419f1c8:	f7ff ffc9 	bl	3419f15e <VD6G_error>
}
3419f1cc:	bf00      	nop
3419f1ce:	3710      	adds	r7, #16
3419f1d0:	46bd      	mov	sp, r7
3419f1d2:	bd80      	pop	{r7, pc}
3419f1d4:	341a6438 	.word	0x341a6438
3419f1d8:	341b741c 	.word	0x341b741c
3419f1dc:	341a6444 	.word	0x341a6444
3419f1e0:	341a647c 	.word	0x341a647c

3419f1e4 <VD6G_PollReg8>:

static int VD6G_PollReg8(VD6G_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
3419f1e4:	b580      	push	{r7, lr}
3419f1e6:	b08a      	sub	sp, #40	@ 0x28
3419f1e8:	af02      	add	r7, sp, #8
3419f1ea:	6078      	str	r0, [r7, #4]
3419f1ec:	460b      	mov	r3, r1
3419f1ee:	807b      	strh	r3, [r7, #2]
3419f1f0:	4613      	mov	r3, r2
3419f1f2:	707b      	strb	r3, [r7, #1]
  const unsigned int loop_delay_ms = 10;
3419f1f4:	230a      	movs	r3, #10
3419f1f6:	61bb      	str	r3, [r7, #24]
  const unsigned int timeout_ms = 500;
3419f1f8:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
3419f1fc:	617b      	str	r3, [r7, #20]
  int loop_nb = timeout_ms / loop_delay_ms;
3419f1fe:	697a      	ldr	r2, [r7, #20]
3419f200:	69bb      	ldr	r3, [r7, #24]
3419f202:	fbb2 f3f3 	udiv	r3, r2, r3
3419f206:	61fb      	str	r3, [r7, #28]
  uint8_t val;
  int ret;

  while (--loop_nb) {
3419f208:	e029      	b.n	3419f25e <VD6G_PollReg8+0x7a>
    ret = ctx->read8(ctx, addr, &val);
3419f20a:	687b      	ldr	r3, [r7, #4]
3419f20c:	685b      	ldr	r3, [r3, #4]
3419f20e:	f107 020f 	add.w	r2, r7, #15
3419f212:	8879      	ldrh	r1, [r7, #2]
3419f214:	6878      	ldr	r0, [r7, #4]
3419f216:	4798      	blx	r3
3419f218:	6138      	str	r0, [r7, #16]
    VD6G_TraceError(ctx, ret);
3419f21a:	693b      	ldr	r3, [r7, #16]
3419f21c:	2b00      	cmp	r3, #0
3419f21e:	d008      	beq.n	3419f232 <VD6G_PollReg8+0x4e>
3419f220:	693b      	ldr	r3, [r7, #16]
3419f222:	9300      	str	r3, [sp, #0]
3419f224:	f240 133f 	movw	r3, #319	@ 0x13f
3419f228:	4a13      	ldr	r2, [pc, #76]	@ (3419f278 <VD6G_PollReg8+0x94>)
3419f22a:	4914      	ldr	r1, [pc, #80]	@ (3419f27c <VD6G_PollReg8+0x98>)
3419f22c:	6878      	ldr	r0, [r7, #4]
3419f22e:	f7ff ff96 	bl	3419f15e <VD6G_error>
3419f232:	693b      	ldr	r3, [r7, #16]
3419f234:	2b00      	cmp	r3, #0
3419f236:	d002      	beq.n	3419f23e <VD6G_PollReg8+0x5a>
3419f238:	6878      	ldr	r0, [r7, #4]
3419f23a:	f7ff ffab 	bl	3419f194 <display_error>
3419f23e:	693b      	ldr	r3, [r7, #16]
3419f240:	2b00      	cmp	r3, #0
3419f242:	d001      	beq.n	3419f248 <VD6G_PollReg8+0x64>
3419f244:	693b      	ldr	r3, [r7, #16]
3419f246:	e012      	b.n	3419f26e <VD6G_PollReg8+0x8a>
    if (val == poll_val)
3419f248:	7bfb      	ldrb	r3, [r7, #15]
3419f24a:	787a      	ldrb	r2, [r7, #1]
3419f24c:	429a      	cmp	r2, r3
3419f24e:	d101      	bne.n	3419f254 <VD6G_PollReg8+0x70>
      return 0;
3419f250:	2300      	movs	r3, #0
3419f252:	e00c      	b.n	3419f26e <VD6G_PollReg8+0x8a>
    ctx->delay(ctx, loop_delay_ms);
3419f254:	687b      	ldr	r3, [r7, #4]
3419f256:	6a1b      	ldr	r3, [r3, #32]
3419f258:	69b9      	ldr	r1, [r7, #24]
3419f25a:	6878      	ldr	r0, [r7, #4]
3419f25c:	4798      	blx	r3
  while (--loop_nb) {
3419f25e:	69fb      	ldr	r3, [r7, #28]
3419f260:	3b01      	subs	r3, #1
3419f262:	61fb      	str	r3, [r7, #28]
3419f264:	69fb      	ldr	r3, [r7, #28]
3419f266:	2b00      	cmp	r3, #0
3419f268:	d1cf      	bne.n	3419f20a <VD6G_PollReg8+0x26>
  }

  return -1;
3419f26a:	f04f 33ff 	mov.w	r3, #4294967295
}
3419f26e:	4618      	mov	r0, r3
3419f270:	3720      	adds	r7, #32
3419f272:	46bd      	mov	sp, r7
3419f274:	bd80      	pop	{r7, pc}
3419f276:	bf00      	nop
3419f278:	341b742c 	.word	0x341b742c
3419f27c:	341a6494 	.word	0x341a6494

3419f280 <VD6G_GetLineTimeInUs>:

static int VD6G_GetLineTimeInUs(VD6G_Ctx_t *ctx, uint32_t *line_time_in_us)
{
3419f280:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3419f284:	b08a      	sub	sp, #40	@ 0x28
3419f286:	af02      	add	r7, sp, #8
3419f288:	6178      	str	r0, [r7, #20]
3419f28a:	6139      	str	r1, [r7, #16]
  uint16_t line_len;
  int ret;

  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
3419f28c:	697b      	ldr	r3, [r7, #20]
3419f28e:	689b      	ldr	r3, [r3, #8]
3419f290:	f107 021a 	add.w	r2, r7, #26
3419f294:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419f298:	6978      	ldr	r0, [r7, #20]
3419f29a:	4798      	blx	r3
3419f29c:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
3419f29e:	69fb      	ldr	r3, [r7, #28]
3419f2a0:	2b00      	cmp	r3, #0
3419f2a2:	d008      	beq.n	3419f2b6 <VD6G_GetLineTimeInUs+0x36>
3419f2a4:	69fb      	ldr	r3, [r7, #28]
3419f2a6:	9300      	str	r3, [sp, #0]
3419f2a8:	f44f 73a7 	mov.w	r3, #334	@ 0x14e
3419f2ac:	4a28      	ldr	r2, [pc, #160]	@ (3419f350 <VD6G_GetLineTimeInUs+0xd0>)
3419f2ae:	4929      	ldr	r1, [pc, #164]	@ (3419f354 <VD6G_GetLineTimeInUs+0xd4>)
3419f2b0:	6978      	ldr	r0, [r7, #20]
3419f2b2:	f7ff ff54 	bl	3419f15e <VD6G_error>
3419f2b6:	69fb      	ldr	r3, [r7, #28]
3419f2b8:	2b00      	cmp	r3, #0
3419f2ba:	d002      	beq.n	3419f2c2 <VD6G_GetLineTimeInUs+0x42>
3419f2bc:	6978      	ldr	r0, [r7, #20]
3419f2be:	f7ff ff69 	bl	3419f194 <display_error>
3419f2c2:	69fb      	ldr	r3, [r7, #28]
3419f2c4:	2b00      	cmp	r3, #0
3419f2c6:	d001      	beq.n	3419f2cc <VD6G_GetLineTimeInUs+0x4c>
3419f2c8:	69fb      	ldr	r3, [r7, #28]
3419f2ca:	e035      	b.n	3419f338 <VD6G_GetLineTimeInUs+0xb8>

  /* compute line_time_in_us */
  *line_time_in_us = ((uint64_t)line_len * 1000000) / VD6G_PIXEL_CLOCK;
3419f2cc:	8b7b      	ldrh	r3, [r7, #26]
3419f2ce:	b29b      	uxth	r3, r3
3419f2d0:	2200      	movs	r2, #0
3419f2d2:	461c      	mov	r4, r3
3419f2d4:	4615      	mov	r5, r2
3419f2d6:	4622      	mov	r2, r4
3419f2d8:	462b      	mov	r3, r5
3419f2da:	ea52 134f 	orrs.w	r3, r2, pc, lsl #5
3419f2de:	ebb2 0804 	subs.w	r8, r2, r4
3419f2e2:	eb63 0905 	sbc.w	r9, r3, r5
3419f2e6:	4642      	mov	r2, r8
3419f2e8:	464b      	mov	r3, r9
3419f2ea:	ea52 234f 	orrs.w	r3, r2, pc, lsl #9
3419f2ee:	4690      	mov	r8, r2
3419f2f0:	4699      	mov	r9, r3
3419f2f2:	eb18 0a04 	adds.w	sl, r8, r4
3419f2f6:	eb49 0b05 	adc.w	fp, r9, r5
3419f2fa:	4652      	mov	r2, sl
3419f2fc:	465b      	mov	r3, fp
3419f2fe:	ea52 138f 	orrs.w	r3, r2, pc, lsl #6
3419f302:	ebb2 010a 	subs.w	r1, r2, sl
3419f306:	6039      	str	r1, [r7, #0]
3419f308:	eb63 030b 	sbc.w	r3, r3, fp
3419f30c:	607b      	str	r3, [r7, #4]
3419f30e:	e9d7 0100 	ldrd	r0, r1, [r7]
3419f312:	4603      	mov	r3, r0
3419f314:	191b      	adds	r3, r3, r4
3419f316:	60bb      	str	r3, [r7, #8]
3419f318:	460b      	mov	r3, r1
3419f31a:	eb45 0303 	adc.w	r3, r5, r3
3419f31e:	60fb      	str	r3, [r7, #12]
3419f320:	a309      	add	r3, pc, #36	@ (adr r3, 3419f348 <VD6G_GetLineTimeInUs+0xc8>)
3419f322:	e9d3 2300 	ldrd	r2, r3, [r3]
3419f326:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3419f32a:	f7e2 fa57 	bl	341817dc <__aeabi_uldivmod>
3419f32e:	4602      	mov	r2, r0
3419f330:	460b      	mov	r3, r1
3419f332:	693b      	ldr	r3, [r7, #16]
3419f334:	601a      	str	r2, [r3, #0]

  return 0;
3419f336:	2300      	movs	r3, #0
}
3419f338:	4618      	mov	r0, r3
3419f33a:	3720      	adds	r7, #32
3419f33c:	46bd      	mov	sp, r7
3419f33e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3419f342:	bf00      	nop
3419f344:	f3af 8000 	nop.w
3419f348:	09959d00 	.word	0x09959d00
3419f34c:	00000000 	.word	0x00000000
3419f350:	341b743c 	.word	0x341b743c
3419f354:	341a6494 	.word	0x341a6494

3419f358 <VD6G_WaitState>:

  return state == VD6G_SYSTEM_FSM_STREAMING;
}

static int VD6G_WaitState(VD6G_Ctx_t *ctx, int state)
{
3419f358:	b580      	push	{r7, lr}
3419f35a:	b084      	sub	sp, #16
3419f35c:	af00      	add	r7, sp, #0
3419f35e:	6078      	str	r0, [r7, #4]
3419f360:	6039      	str	r1, [r7, #0]
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
3419f362:	683b      	ldr	r3, [r7, #0]
3419f364:	b2db      	uxtb	r3, r3
3419f366:	461a      	mov	r2, r3
3419f368:	2128      	movs	r1, #40	@ 0x28
3419f36a:	6878      	ldr	r0, [r7, #4]
3419f36c:	f7ff ff3a 	bl	3419f1e4 <VD6G_PollReg8>
3419f370:	60f8      	str	r0, [r7, #12]

  if (ret)
3419f372:	68fb      	ldr	r3, [r7, #12]
3419f374:	2b00      	cmp	r3, #0
3419f376:	d005      	beq.n	3419f384 <VD6G_WaitState+0x2c>
    VD6G_warn(ctx, "Unable to reach state %d\n", state);
3419f378:	683a      	ldr	r2, [r7, #0]
3419f37a:	4908      	ldr	r1, [pc, #32]	@ (3419f39c <VD6G_WaitState+0x44>)
3419f37c:	6878      	ldr	r0, [r7, #4]
3419f37e:	f7ff fed3 	bl	3419f128 <VD6G_warn>
3419f382:	e005      	b.n	3419f390 <VD6G_WaitState+0x38>
  else
    VD6G_dbg(ctx, 0, "reach state %d\n", state);
3419f384:	683b      	ldr	r3, [r7, #0]
3419f386:	4a06      	ldr	r2, [pc, #24]	@ (3419f3a0 <VD6G_WaitState+0x48>)
3419f388:	2100      	movs	r1, #0
3419f38a:	6878      	ldr	r0, [r7, #4]
3419f38c:	f7ff fe94 	bl	3419f0b8 <VD6G_dbg>

  return ret;
3419f390:	68fb      	ldr	r3, [r7, #12]
}
3419f392:	4618      	mov	r0, r3
3419f394:	3710      	adds	r7, #16
3419f396:	46bd      	mov	sp, r7
3419f398:	bd80      	pop	{r7, pc}
3419f39a:	bf00      	nop
3419f39c:	341a64ac 	.word	0x341a64ac
3419f3a0:	341a64c8 	.word	0x341a64c8

3419f3a4 <VD6G_GetTopDie>:

static int VD6G_GetTopDie(VD6G_Ctx_t *ctx, uint8_t *top_die)
{
3419f3a4:	b580      	push	{r7, lr}
3419f3a6:	b086      	sub	sp, #24
3419f3a8:	af02      	add	r7, sp, #8
3419f3aa:	6078      	str	r0, [r7, #4]
3419f3ac:	6039      	str	r1, [r7, #0]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
3419f3ae:	687b      	ldr	r3, [r7, #4]
3419f3b0:	689b      	ldr	r3, [r3, #8]
3419f3b2:	f107 020a 	add.w	r2, r7, #10
3419f3b6:	2102      	movs	r1, #2
3419f3b8:	6878      	ldr	r0, [r7, #4]
3419f3ba:	4798      	blx	r3
3419f3bc:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f3be:	68fb      	ldr	r3, [r7, #12]
3419f3c0:	2b00      	cmp	r3, #0
3419f3c2:	d008      	beq.n	3419f3d6 <VD6G_GetTopDie+0x32>
3419f3c4:	68fb      	ldr	r3, [r7, #12]
3419f3c6:	9300      	str	r3, [sp, #0]
3419f3c8:	f240 1373 	movw	r3, #371	@ 0x173
3419f3cc:	4a10      	ldr	r2, [pc, #64]	@ (3419f410 <VD6G_GetTopDie+0x6c>)
3419f3ce:	4911      	ldr	r1, [pc, #68]	@ (3419f414 <VD6G_GetTopDie+0x70>)
3419f3d0:	6878      	ldr	r0, [r7, #4]
3419f3d2:	f7ff fec4 	bl	3419f15e <VD6G_error>
3419f3d6:	68fb      	ldr	r3, [r7, #12]
3419f3d8:	2b00      	cmp	r3, #0
3419f3da:	d002      	beq.n	3419f3e2 <VD6G_GetTopDie+0x3e>
3419f3dc:	6878      	ldr	r0, [r7, #4]
3419f3de:	f7ff fed9 	bl	3419f194 <display_error>
3419f3e2:	68fb      	ldr	r3, [r7, #12]
3419f3e4:	2b00      	cmp	r3, #0
3419f3e6:	d001      	beq.n	3419f3ec <VD6G_GetTopDie+0x48>
3419f3e8:	68fb      	ldr	r3, [r7, #12]
3419f3ea:	e00c      	b.n	3419f406 <VD6G_GetTopDie+0x62>
  VD6G_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
3419f3ec:	897b      	ldrh	r3, [r7, #10]
3419f3ee:	4a0a      	ldr	r2, [pc, #40]	@ (3419f418 <VD6G_GetTopDie+0x74>)
3419f3f0:	2100      	movs	r1, #0
3419f3f2:	6878      	ldr	r0, [r7, #4]
3419f3f4:	f7ff fe60 	bl	3419f0b8 <VD6G_dbg>
  *top_die = reg16 >> 8;
3419f3f8:	897b      	ldrh	r3, [r7, #10]
3419f3fa:	0a1b      	lsrs	r3, r3, #8
3419f3fc:	b29b      	uxth	r3, r3
3419f3fe:	b2da      	uxtb	r2, r3
3419f400:	683b      	ldr	r3, [r7, #0]
3419f402:	701a      	strb	r2, [r3, #0]

  return 0;
3419f404:	2300      	movs	r3, #0
}
3419f406:	4618      	mov	r0, r3
3419f408:	3710      	adds	r7, #16
3419f40a:	46bd      	mov	sp, r7
3419f40c:	bd80      	pop	{r7, pc}
3419f40e:	bf00      	nop
3419f410:	341b7454 	.word	0x341b7454
3419f414:	341a6494 	.word	0x341a6494
3419f418:	341a64d8 	.word	0x341a64d8

3419f41c <VD6G_CheckModelId>:

static int VD6G_CheckModelId(VD6G_Ctx_t *ctx)
{
3419f41c:	b580      	push	{r7, lr}
3419f41e:	b086      	sub	sp, #24
3419f420:	af02      	add	r7, sp, #8
3419f422:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_REG_MODEL_ID, &reg16);
3419f424:	687b      	ldr	r3, [r7, #4]
3419f426:	689b      	ldr	r3, [r3, #8]
3419f428:	f107 0208 	add.w	r2, r7, #8
3419f42c:	2100      	movs	r1, #0
3419f42e:	6878      	ldr	r0, [r7, #4]
3419f430:	4798      	blx	r3
3419f432:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f434:	68fb      	ldr	r3, [r7, #12]
3419f436:	2b00      	cmp	r3, #0
3419f438:	d008      	beq.n	3419f44c <VD6G_CheckModelId+0x30>
3419f43a:	68fb      	ldr	r3, [r7, #12]
3419f43c:	9300      	str	r3, [sp, #0]
3419f43e:	f240 1381 	movw	r3, #385	@ 0x181
3419f442:	4a34      	ldr	r2, [pc, #208]	@ (3419f514 <VD6G_CheckModelId+0xf8>)
3419f444:	4934      	ldr	r1, [pc, #208]	@ (3419f518 <VD6G_CheckModelId+0xfc>)
3419f446:	6878      	ldr	r0, [r7, #4]
3419f448:	f7ff fe89 	bl	3419f15e <VD6G_error>
3419f44c:	68fb      	ldr	r3, [r7, #12]
3419f44e:	2b00      	cmp	r3, #0
3419f450:	d002      	beq.n	3419f458 <VD6G_CheckModelId+0x3c>
3419f452:	6878      	ldr	r0, [r7, #4]
3419f454:	f7ff fe9e 	bl	3419f194 <display_error>
3419f458:	68fb      	ldr	r3, [r7, #12]
3419f45a:	2b00      	cmp	r3, #0
3419f45c:	d001      	beq.n	3419f462 <VD6G_CheckModelId+0x46>
3419f45e:	68fb      	ldr	r3, [r7, #12]
3419f460:	e053      	b.n	3419f50a <VD6G_CheckModelId+0xee>
  VD6G_dbg(ctx, 0, "model_id = 0x%04x\n", reg16);
3419f462:	893b      	ldrh	r3, [r7, #8]
3419f464:	4a2d      	ldr	r2, [pc, #180]	@ (3419f51c <VD6G_CheckModelId+0x100>)
3419f466:	2100      	movs	r1, #0
3419f468:	6878      	ldr	r0, [r7, #4]
3419f46a:	f7ff fe25 	bl	3419f0b8 <VD6G_dbg>
  if (reg16 != VD6G_MODEL_ID) {
3419f46e:	893b      	ldrh	r3, [r7, #8]
3419f470:	f245 6203 	movw	r2, #22019	@ 0x5603
3419f474:	4293      	cmp	r3, r2
3419f476:	d009      	beq.n	3419f48c <VD6G_CheckModelId+0x70>
    VD6G_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD6G_MODEL_ID, reg16);
3419f478:	893b      	ldrh	r3, [r7, #8]
3419f47a:	f245 6203 	movw	r2, #22019	@ 0x5603
3419f47e:	4928      	ldr	r1, [pc, #160]	@ (3419f520 <VD6G_CheckModelId+0x104>)
3419f480:	6878      	ldr	r0, [r7, #4]
3419f482:	f7ff fe6c 	bl	3419f15e <VD6G_error>
    return -1;
3419f486:	f04f 33ff 	mov.w	r3, #4294967295
3419f48a:	e03e      	b.n	3419f50a <VD6G_CheckModelId+0xee>
  }

  ret = VD6G_GetTopDie(ctx, &top_die);
3419f48c:	f107 030b 	add.w	r3, r7, #11
3419f490:	4619      	mov	r1, r3
3419f492:	6878      	ldr	r0, [r7, #4]
3419f494:	f7ff ff86 	bl	3419f3a4 <VD6G_GetTopDie>
3419f498:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f49a:	68fb      	ldr	r3, [r7, #12]
3419f49c:	2b00      	cmp	r3, #0
3419f49e:	d001      	beq.n	3419f4a4 <VD6G_CheckModelId+0x88>
    return ret;
3419f4a0:	68fb      	ldr	r3, [r7, #12]
3419f4a2:	e032      	b.n	3419f50a <VD6G_CheckModelId+0xee>
  if (top_die != VD6G_TOP_DIE_SLOW_BOOT && top_die != VD6G_TOP_DIE_FAST_BOOT) {
3419f4a4:	7afb      	ldrb	r3, [r7, #11]
3419f4a6:	2b20      	cmp	r3, #32
3419f4a8:	d009      	beq.n	3419f4be <VD6G_CheckModelId+0xa2>
3419f4aa:	7afb      	ldrb	r3, [r7, #11]
3419f4ac:	2b31      	cmp	r3, #49	@ 0x31
3419f4ae:	d006      	beq.n	3419f4be <VD6G_CheckModelId+0xa2>
    VD6G_error(ctx, "Unsupported revision\n");
3419f4b0:	491c      	ldr	r1, [pc, #112]	@ (3419f524 <VD6G_CheckModelId+0x108>)
3419f4b2:	6878      	ldr	r0, [r7, #4]
3419f4b4:	f7ff fe53 	bl	3419f15e <VD6G_error>
    return -1;
3419f4b8:	f04f 33ff 	mov.w	r3, #4294967295
3419f4bc:	e025      	b.n	3419f50a <VD6G_CheckModelId+0xee>
  }

  ret = ctx->read16(ctx, VD6G_REG_ROM_REVISION, &reg16);
3419f4be:	687b      	ldr	r3, [r7, #4]
3419f4c0:	689b      	ldr	r3, [r3, #8]
3419f4c2:	f107 0208 	add.w	r2, r7, #8
3419f4c6:	2114      	movs	r1, #20
3419f4c8:	6878      	ldr	r0, [r7, #4]
3419f4ca:	4798      	blx	r3
3419f4cc:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f4ce:	68fb      	ldr	r3, [r7, #12]
3419f4d0:	2b00      	cmp	r3, #0
3419f4d2:	d008      	beq.n	3419f4e6 <VD6G_CheckModelId+0xca>
3419f4d4:	68fb      	ldr	r3, [r7, #12]
3419f4d6:	9300      	str	r3, [sp, #0]
3419f4d8:	f240 1391 	movw	r3, #401	@ 0x191
3419f4dc:	4a0d      	ldr	r2, [pc, #52]	@ (3419f514 <VD6G_CheckModelId+0xf8>)
3419f4de:	490e      	ldr	r1, [pc, #56]	@ (3419f518 <VD6G_CheckModelId+0xfc>)
3419f4e0:	6878      	ldr	r0, [r7, #4]
3419f4e2:	f7ff fe3c 	bl	3419f15e <VD6G_error>
3419f4e6:	68fb      	ldr	r3, [r7, #12]
3419f4e8:	2b00      	cmp	r3, #0
3419f4ea:	d002      	beq.n	3419f4f2 <VD6G_CheckModelId+0xd6>
3419f4ec:	6878      	ldr	r0, [r7, #4]
3419f4ee:	f7ff fe51 	bl	3419f194 <display_error>
3419f4f2:	68fb      	ldr	r3, [r7, #12]
3419f4f4:	2b00      	cmp	r3, #0
3419f4f6:	d001      	beq.n	3419f4fc <VD6G_CheckModelId+0xe0>
3419f4f8:	68fb      	ldr	r3, [r7, #12]
3419f4fa:	e006      	b.n	3419f50a <VD6G_CheckModelId+0xee>
  VD6G_dbg(ctx, 0, "rom = 0x%04x\n", reg16);
3419f4fc:	893b      	ldrh	r3, [r7, #8]
3419f4fe:	4a0a      	ldr	r2, [pc, #40]	@ (3419f528 <VD6G_CheckModelId+0x10c>)
3419f500:	2100      	movs	r1, #0
3419f502:	6878      	ldr	r0, [r7, #4]
3419f504:	f7ff fdd8 	bl	3419f0b8 <VD6G_dbg>

  return 0;
3419f508:	2300      	movs	r3, #0
}
3419f50a:	4618      	mov	r0, r3
3419f50c:	3710      	adds	r7, #16
3419f50e:	46bd      	mov	sp, r7
3419f510:	bd80      	pop	{r7, pc}
3419f512:	bf00      	nop
3419f514:	341b7464 	.word	0x341b7464
3419f518:	341a6494 	.word	0x341a6494
3419f51c:	341a64ec 	.word	0x341a64ec
3419f520:	341a6500 	.word	0x341a6500
3419f524:	341a652c 	.word	0x341a652c
3419f528:	341a6544 	.word	0x341a6544

3419f52c <VD6G_ApplyPatchSlowBoot>:

static int VD6G_ApplyPatchSlowBoot(VD6G_Ctx_t *ctx)
{
3419f52c:	b590      	push	{r4, r7, lr}
3419f52e:	b089      	sub	sp, #36	@ 0x24
3419f530:	af02      	add	r7, sp, #8
3419f532:	6078      	str	r0, [r7, #4]
  uint8_t patch_major;
  uint8_t patch_minor;
  uint16_t reg16;
  int ret;

  patch_major = patch_cut2[3];
3419f534:	2302      	movs	r3, #2
3419f536:	75fb      	strb	r3, [r7, #23]
  patch_minor = patch_cut2[2];
3419f538:	231c      	movs	r3, #28
3419f53a:	75bb      	strb	r3, [r7, #22]

  ret = ctx->write_array(ctx, 0x2000, (uint8_t *) patch_cut2, sizeof(patch_cut2));
3419f53c:	687b      	ldr	r3, [r7, #4]
3419f53e:	69dc      	ldr	r4, [r3, #28]
3419f540:	f642 23f8 	movw	r3, #11000	@ 0x2af8
3419f544:	4a4a      	ldr	r2, [pc, #296]	@ (3419f670 <VD6G_ApplyPatchSlowBoot+0x144>)
3419f546:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
3419f54a:	6878      	ldr	r0, [r7, #4]
3419f54c:	47a0      	blx	r4
3419f54e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419f550:	693b      	ldr	r3, [r7, #16]
3419f552:	2b00      	cmp	r3, #0
3419f554:	d008      	beq.n	3419f568 <VD6G_ApplyPatchSlowBoot+0x3c>
3419f556:	693b      	ldr	r3, [r7, #16]
3419f558:	9300      	str	r3, [sp, #0]
3419f55a:	f44f 73d1 	mov.w	r3, #418	@ 0x1a2
3419f55e:	4a45      	ldr	r2, [pc, #276]	@ (3419f674 <VD6G_ApplyPatchSlowBoot+0x148>)
3419f560:	4945      	ldr	r1, [pc, #276]	@ (3419f678 <VD6G_ApplyPatchSlowBoot+0x14c>)
3419f562:	6878      	ldr	r0, [r7, #4]
3419f564:	f7ff fdfb 	bl	3419f15e <VD6G_error>
3419f568:	693b      	ldr	r3, [r7, #16]
3419f56a:	2b00      	cmp	r3, #0
3419f56c:	d002      	beq.n	3419f574 <VD6G_ApplyPatchSlowBoot+0x48>
3419f56e:	6878      	ldr	r0, [r7, #4]
3419f570:	f7ff fe10 	bl	3419f194 <display_error>
3419f574:	693b      	ldr	r3, [r7, #16]
3419f576:	2b00      	cmp	r3, #0
3419f578:	d001      	beq.n	3419f57e <VD6G_ApplyPatchSlowBoot+0x52>
3419f57a:	693b      	ldr	r3, [r7, #16]
3419f57c:	e074      	b.n	3419f668 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_PATCH_SETUP);
3419f57e:	687b      	ldr	r3, [r7, #4]
3419f580:	691b      	ldr	r3, [r3, #16]
3419f582:	2202      	movs	r2, #2
3419f584:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f588:	6878      	ldr	r0, [r7, #4]
3419f58a:	4798      	blx	r3
3419f58c:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419f58e:	693b      	ldr	r3, [r7, #16]
3419f590:	2b00      	cmp	r3, #0
3419f592:	d008      	beq.n	3419f5a6 <VD6G_ApplyPatchSlowBoot+0x7a>
3419f594:	693b      	ldr	r3, [r7, #16]
3419f596:	9300      	str	r3, [sp, #0]
3419f598:	f240 13a5 	movw	r3, #421	@ 0x1a5
3419f59c:	4a35      	ldr	r2, [pc, #212]	@ (3419f674 <VD6G_ApplyPatchSlowBoot+0x148>)
3419f59e:	4936      	ldr	r1, [pc, #216]	@ (3419f678 <VD6G_ApplyPatchSlowBoot+0x14c>)
3419f5a0:	6878      	ldr	r0, [r7, #4]
3419f5a2:	f7ff fddc 	bl	3419f15e <VD6G_error>
3419f5a6:	693b      	ldr	r3, [r7, #16]
3419f5a8:	2b00      	cmp	r3, #0
3419f5aa:	d002      	beq.n	3419f5b2 <VD6G_ApplyPatchSlowBoot+0x86>
3419f5ac:	6878      	ldr	r0, [r7, #4]
3419f5ae:	f7ff fdf1 	bl	3419f194 <display_error>
3419f5b2:	693b      	ldr	r3, [r7, #16]
3419f5b4:	2b00      	cmp	r3, #0
3419f5b6:	d001      	beq.n	3419f5bc <VD6G_ApplyPatchSlowBoot+0x90>
3419f5b8:	693b      	ldr	r3, [r7, #16]
3419f5ba:	e055      	b.n	3419f668 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
3419f5bc:	2200      	movs	r2, #0
3419f5be:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f5c2:	6878      	ldr	r0, [r7, #4]
3419f5c4:	f7ff fe0e 	bl	3419f1e4 <VD6G_PollReg8>
3419f5c8:	6138      	str	r0, [r7, #16]
  if (ret)
3419f5ca:	693b      	ldr	r3, [r7, #16]
3419f5cc:	2b00      	cmp	r3, #0
3419f5ce:	d001      	beq.n	3419f5d4 <VD6G_ApplyPatchSlowBoot+0xa8>
    return ret;
3419f5d0:	693b      	ldr	r3, [r7, #16]
3419f5d2:	e049      	b.n	3419f668 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = ctx->read16(ctx, VD6G_REG_FWPATCH_REVISION, &reg16);
3419f5d4:	687b      	ldr	r3, [r7, #4]
3419f5d6:	689b      	ldr	r3, [r3, #8]
3419f5d8:	f107 020e 	add.w	r2, r7, #14
3419f5dc:	211e      	movs	r1, #30
3419f5de:	6878      	ldr	r0, [r7, #4]
3419f5e0:	4798      	blx	r3
3419f5e2:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419f5e4:	693b      	ldr	r3, [r7, #16]
3419f5e6:	2b00      	cmp	r3, #0
3419f5e8:	d008      	beq.n	3419f5fc <VD6G_ApplyPatchSlowBoot+0xd0>
3419f5ea:	693b      	ldr	r3, [r7, #16]
3419f5ec:	9300      	str	r3, [sp, #0]
3419f5ee:	f44f 73d6 	mov.w	r3, #428	@ 0x1ac
3419f5f2:	4a20      	ldr	r2, [pc, #128]	@ (3419f674 <VD6G_ApplyPatchSlowBoot+0x148>)
3419f5f4:	4920      	ldr	r1, [pc, #128]	@ (3419f678 <VD6G_ApplyPatchSlowBoot+0x14c>)
3419f5f6:	6878      	ldr	r0, [r7, #4]
3419f5f8:	f7ff fdb1 	bl	3419f15e <VD6G_error>
3419f5fc:	693b      	ldr	r3, [r7, #16]
3419f5fe:	2b00      	cmp	r3, #0
3419f600:	d002      	beq.n	3419f608 <VD6G_ApplyPatchSlowBoot+0xdc>
3419f602:	6878      	ldr	r0, [r7, #4]
3419f604:	f7ff fdc6 	bl	3419f194 <display_error>
3419f608:	693b      	ldr	r3, [r7, #16]
3419f60a:	2b00      	cmp	r3, #0
3419f60c:	d001      	beq.n	3419f612 <VD6G_ApplyPatchSlowBoot+0xe6>
3419f60e:	693b      	ldr	r3, [r7, #16]
3419f610:	e02a      	b.n	3419f668 <VD6G_ApplyPatchSlowBoot+0x13c>
  VD6G_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
3419f612:	89fb      	ldrh	r3, [r7, #14]
3419f614:	4a19      	ldr	r2, [pc, #100]	@ (3419f67c <VD6G_ApplyPatchSlowBoot+0x150>)
3419f616:	2100      	movs	r1, #0
3419f618:	6878      	ldr	r0, [r7, #4]
3419f61a:	f7ff fd4d 	bl	3419f0b8 <VD6G_dbg>

  if (reg16 != (patch_major << 8) + patch_minor) {
3419f61e:	89fb      	ldrh	r3, [r7, #14]
3419f620:	4619      	mov	r1, r3
3419f622:	7dfb      	ldrb	r3, [r7, #23]
3419f624:	021a      	lsls	r2, r3, #8
3419f626:	7dbb      	ldrb	r3, [r7, #22]
3419f628:	4413      	add	r3, r2
3419f62a:	4299      	cmp	r1, r3
3419f62c:	d011      	beq.n	3419f652 <VD6G_ApplyPatchSlowBoot+0x126>
    VD6G_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor,
3419f62e:	7dfa      	ldrb	r2, [r7, #23]
3419f630:	7db9      	ldrb	r1, [r7, #22]
3419f632:	89fb      	ldrh	r3, [r7, #14]
3419f634:	0a1b      	lsrs	r3, r3, #8
3419f636:	b29b      	uxth	r3, r3
3419f638:	4618      	mov	r0, r3
3419f63a:	89fb      	ldrh	r3, [r7, #14]
3419f63c:	b2db      	uxtb	r3, r3
3419f63e:	9301      	str	r3, [sp, #4]
3419f640:	9000      	str	r0, [sp, #0]
3419f642:	460b      	mov	r3, r1
3419f644:	490e      	ldr	r1, [pc, #56]	@ (3419f680 <VD6G_ApplyPatchSlowBoot+0x154>)
3419f646:	6878      	ldr	r0, [r7, #4]
3419f648:	f7ff fd89 	bl	3419f15e <VD6G_error>
                 reg16 >> 8, reg16 & 0xff);
    return -1;
3419f64c:	f04f 33ff 	mov.w	r3, #4294967295
3419f650:	e00a      	b.n	3419f668 <VD6G_ApplyPatchSlowBoot+0x13c>
  }
  VD6G_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
3419f652:	89fb      	ldrh	r3, [r7, #14]
3419f654:	0a1b      	lsrs	r3, r3, #8
3419f656:	b29b      	uxth	r3, r3
3419f658:	461a      	mov	r2, r3
3419f65a:	89fb      	ldrh	r3, [r7, #14]
3419f65c:	b2db      	uxtb	r3, r3
3419f65e:	4909      	ldr	r1, [pc, #36]	@ (3419f684 <VD6G_ApplyPatchSlowBoot+0x158>)
3419f660:	6878      	ldr	r0, [r7, #4]
3419f662:	f7ff fd46 	bl	3419f0f2 <VD6G_notice>

  return 0;
3419f666:	2300      	movs	r3, #0
}
3419f668:	4618      	mov	r0, r3
3419f66a:	371c      	adds	r7, #28
3419f66c:	46bd      	mov	sp, r7
3419f66e:	bd90      	pop	{r4, r7, pc}
3419f670:	341b3060 	.word	0x341b3060
3419f674:	341b7478 	.word	0x341b7478
3419f678:	341a6494 	.word	0x341a6494
3419f67c:	341a6554 	.word	0x341a6554
3419f680:	341a6564 	.word	0x341a6564
3419f684:	341a6590 	.word	0x341a6590

3419f688 <VD6G_ApplyPatch>:

static int VD6G_ApplyPatch(VD6G_Ctx_t *ctx)
{
3419f688:	b580      	push	{r7, lr}
3419f68a:	b084      	sub	sp, #16
3419f68c:	af00      	add	r7, sp, #0
3419f68e:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  int ret;

  ret = VD6G_GetTopDie(ctx, &top_die);
3419f690:	f107 030b 	add.w	r3, r7, #11
3419f694:	4619      	mov	r1, r3
3419f696:	6878      	ldr	r0, [r7, #4]
3419f698:	f7ff fe84 	bl	3419f3a4 <VD6G_GetTopDie>
3419f69c:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f69e:	68fb      	ldr	r3, [r7, #12]
3419f6a0:	2b00      	cmp	r3, #0
3419f6a2:	d001      	beq.n	3419f6a8 <VD6G_ApplyPatch+0x20>
    return ret;
3419f6a4:	68fb      	ldr	r3, [r7, #12]
3419f6a6:	e015      	b.n	3419f6d4 <VD6G_ApplyPatch+0x4c>

  switch (top_die) {
3419f6a8:	7afb      	ldrb	r3, [r7, #11]
3419f6aa:	2b20      	cmp	r3, #32
3419f6ac:	d002      	beq.n	3419f6b4 <VD6G_ApplyPatch+0x2c>
3419f6ae:	2b31      	cmp	r3, #49	@ 0x31
3419f6b0:	d005      	beq.n	3419f6be <VD6G_ApplyPatch+0x36>
3419f6b2:	e007      	b.n	3419f6c4 <VD6G_ApplyPatch+0x3c>
  case VD6G_TOP_DIE_SLOW_BOOT:
    ret = VD6G_ApplyPatchSlowBoot(ctx);
3419f6b4:	6878      	ldr	r0, [r7, #4]
3419f6b6:	f7ff ff39 	bl	3419f52c <VD6G_ApplyPatchSlowBoot>
3419f6ba:	60f8      	str	r0, [r7, #12]
    break;
3419f6bc:	e009      	b.n	3419f6d2 <VD6G_ApplyPatch+0x4a>
  case VD6G_TOP_DIE_FAST_BOOT:
    ret = 0;
3419f6be:	2300      	movs	r3, #0
3419f6c0:	60fb      	str	r3, [r7, #12]
    break;
3419f6c2:	e006      	b.n	3419f6d2 <VD6G_ApplyPatch+0x4a>
  default:
    assert(0);
3419f6c4:	4b05      	ldr	r3, [pc, #20]	@ (3419f6dc <VD6G_ApplyPatch+0x54>)
3419f6c6:	4a06      	ldr	r2, [pc, #24]	@ (3419f6e0 <VD6G_ApplyPatch+0x58>)
3419f6c8:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
3419f6cc:	4805      	ldr	r0, [pc, #20]	@ (3419f6e4 <VD6G_ApplyPatch+0x5c>)
3419f6ce:	f004 f8df 	bl	341a3890 <__assert_func>
  }

  return ret;
3419f6d2:	68fb      	ldr	r3, [r7, #12]
}
3419f6d4:	4618      	mov	r0, r3
3419f6d6:	3710      	adds	r7, #16
3419f6d8:	46bd      	mov	sp, r7
3419f6da:	bd80      	pop	{r7, pc}
3419f6dc:	341a65a8 	.word	0x341a65a8
3419f6e0:	341b7490 	.word	0x341b7490
3419f6e4:	341a6444 	.word	0x341a6444

3419f6e8 <VD6G_BootMcu>:

static int VD6G_BootMcu(VD6G_Ctx_t *ctx)
{
3419f6e8:	b580      	push	{r7, lr}
3419f6ea:	b086      	sub	sp, #24
3419f6ec:	af02      	add	r7, sp, #8
3419f6ee:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_BOOT);
3419f6f0:	687b      	ldr	r3, [r7, #4]
3419f6f2:	691b      	ldr	r3, [r3, #16]
3419f6f4:	2201      	movs	r2, #1
3419f6f6:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f6fa:	6878      	ldr	r0, [r7, #4]
3419f6fc:	4798      	blx	r3
3419f6fe:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f700:	68fb      	ldr	r3, [r7, #12]
3419f702:	2b00      	cmp	r3, #0
3419f704:	d008      	beq.n	3419f718 <VD6G_BootMcu+0x30>
3419f706:	68fb      	ldr	r3, [r7, #12]
3419f708:	9300      	str	r3, [sp, #0]
3419f70a:	f240 13d5 	movw	r3, #469	@ 0x1d5
3419f70e:	4a17      	ldr	r2, [pc, #92]	@ (3419f76c <VD6G_BootMcu+0x84>)
3419f710:	4917      	ldr	r1, [pc, #92]	@ (3419f770 <VD6G_BootMcu+0x88>)
3419f712:	6878      	ldr	r0, [r7, #4]
3419f714:	f7ff fd23 	bl	3419f15e <VD6G_error>
3419f718:	68fb      	ldr	r3, [r7, #12]
3419f71a:	2b00      	cmp	r3, #0
3419f71c:	d002      	beq.n	3419f724 <VD6G_BootMcu+0x3c>
3419f71e:	6878      	ldr	r0, [r7, #4]
3419f720:	f7ff fd38 	bl	3419f194 <display_error>
3419f724:	68fb      	ldr	r3, [r7, #12]
3419f726:	2b00      	cmp	r3, #0
3419f728:	d001      	beq.n	3419f72e <VD6G_BootMcu+0x46>
3419f72a:	68fb      	ldr	r3, [r7, #12]
3419f72c:	e01a      	b.n	3419f764 <VD6G_BootMcu+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
3419f72e:	2200      	movs	r2, #0
3419f730:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f734:	6878      	ldr	r0, [r7, #4]
3419f736:	f7ff fd55 	bl	3419f1e4 <VD6G_PollReg8>
3419f73a:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f73c:	68fb      	ldr	r3, [r7, #12]
3419f73e:	2b00      	cmp	r3, #0
3419f740:	d001      	beq.n	3419f746 <VD6G_BootMcu+0x5e>
    return ret;
3419f742:	68fb      	ldr	r3, [r7, #12]
3419f744:	e00e      	b.n	3419f764 <VD6G_BootMcu+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3419f746:	2102      	movs	r1, #2
3419f748:	6878      	ldr	r0, [r7, #4]
3419f74a:	f7ff fe05 	bl	3419f358 <VD6G_WaitState>
3419f74e:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f750:	68fb      	ldr	r3, [r7, #12]
3419f752:	2b00      	cmp	r3, #0
3419f754:	d001      	beq.n	3419f75a <VD6G_BootMcu+0x72>
    return ret;
3419f756:	68fb      	ldr	r3, [r7, #12]
3419f758:	e004      	b.n	3419f764 <VD6G_BootMcu+0x7c>

  VD6G_notice(ctx, "sensor boot successfully\n");
3419f75a:	4906      	ldr	r1, [pc, #24]	@ (3419f774 <VD6G_BootMcu+0x8c>)
3419f75c:	6878      	ldr	r0, [r7, #4]
3419f75e:	f7ff fcc8 	bl	3419f0f2 <VD6G_notice>

  return 0;
3419f762:	2300      	movs	r3, #0
}
3419f764:	4618      	mov	r0, r3
3419f766:	3710      	adds	r7, #16
3419f768:	46bd      	mov	sp, r7
3419f76a:	bd80      	pop	{r7, pc}
3419f76c:	341b74a0 	.word	0x341b74a0
3419f770:	341a6494 	.word	0x341a6494
3419f774:	341a65ac 	.word	0x341a65ac

3419f778 <VD6G_ApplyVtPatchSlowBoot>:

static int VD6G_ApplyVtPatchSlowBoot(VD6G_Ctx_t *ctx)
{
3419f778:	b590      	push	{r4, r7, lr}
3419f77a:	b089      	sub	sp, #36	@ 0x24
3419f77c:	af02      	add	r7, sp, #8
3419f77e:	6078      	str	r0, [r7, #4]
  uint8_t cur_vtpatch_rd_rev, cur_vtpatch_gr_rev, cur_vtpatch_gt_rev;
  int vtpatch_offset = 0;
3419f780:	2300      	movs	r3, #0
3419f782:	617b      	str	r3, [r7, #20]
  int ret;
  int i;

  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_START_VTRAM_UPDATE);
3419f784:	687b      	ldr	r3, [r7, #4]
3419f786:	691b      	ldr	r3, [r3, #16]
3419f788:	2201      	movs	r2, #1
3419f78a:	f240 2103 	movw	r1, #515	@ 0x203
3419f78e:	6878      	ldr	r0, [r7, #4]
3419f790:	4798      	blx	r3
3419f792:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f794:	68fb      	ldr	r3, [r7, #12]
3419f796:	2b00      	cmp	r3, #0
3419f798:	d008      	beq.n	3419f7ac <VD6G_ApplyVtPatchSlowBoot+0x34>
3419f79a:	68fb      	ldr	r3, [r7, #12]
3419f79c:	9300      	str	r3, [sp, #0]
3419f79e:	f44f 73f6 	mov.w	r3, #492	@ 0x1ec
3419f7a2:	4a89      	ldr	r2, [pc, #548]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f7a4:	4989      	ldr	r1, [pc, #548]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f7a6:	6878      	ldr	r0, [r7, #4]
3419f7a8:	f7ff fcd9 	bl	3419f15e <VD6G_error>
3419f7ac:	68fb      	ldr	r3, [r7, #12]
3419f7ae:	2b00      	cmp	r3, #0
3419f7b0:	d002      	beq.n	3419f7b8 <VD6G_ApplyVtPatchSlowBoot+0x40>
3419f7b2:	6878      	ldr	r0, [r7, #4]
3419f7b4:	f7ff fcee 	bl	3419f194 <display_error>
3419f7b8:	68fb      	ldr	r3, [r7, #12]
3419f7ba:	2b00      	cmp	r3, #0
3419f7bc:	d001      	beq.n	3419f7c2 <VD6G_ApplyVtPatchSlowBoot+0x4a>
3419f7be:	68fb      	ldr	r3, [r7, #12]
3419f7c0:	e187      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
3419f7c2:	2200      	movs	r2, #0
3419f7c4:	f240 2103 	movw	r1, #515	@ 0x203
3419f7c8:	6878      	ldr	r0, [r7, #4]
3419f7ca:	f7ff fd0b 	bl	3419f1e4 <VD6G_PollReg8>
3419f7ce:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f7d0:	68fb      	ldr	r3, [r7, #12]
3419f7d2:	2b00      	cmp	r3, #0
3419f7d4:	d001      	beq.n	3419f7da <VD6G_ApplyVtPatchSlowBoot+0x62>
    return ret;
3419f7d6:	68fb      	ldr	r3, [r7, #12]
3419f7d8:	e17b      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3419f7da:	2102      	movs	r1, #2
3419f7dc:	6878      	ldr	r0, [r7, #4]
3419f7de:	f7ff fdbb 	bl	3419f358 <VD6G_WaitState>
3419f7e2:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f7e4:	68fb      	ldr	r3, [r7, #12]
3419f7e6:	2b00      	cmp	r3, #0
3419f7e8:	d001      	beq.n	3419f7ee <VD6G_ApplyVtPatchSlowBoot+0x76>
    return ret;
3419f7ea:	68fb      	ldr	r3, [r7, #12]
3419f7ec:	e171      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  for (i = 0; i < vtpatch_area_nb; i++) {
3419f7ee:	2300      	movs	r3, #0
3419f7f0:	613b      	str	r3, [r7, #16]
3419f7f2:	e033      	b.n	3419f85c <VD6G_ApplyVtPatchSlowBoot+0xe4>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
3419f7f4:	687b      	ldr	r3, [r7, #4]
3419f7f6:	69dc      	ldr	r4, [r3, #28]
3419f7f8:	4a75      	ldr	r2, [pc, #468]	@ (3419f9d0 <VD6G_ApplyVtPatchSlowBoot+0x258>)
3419f7fa:	693b      	ldr	r3, [r7, #16]
3419f7fc:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
3419f800:	b299      	uxth	r1, r3
3419f802:	697b      	ldr	r3, [r7, #20]
3419f804:	4a73      	ldr	r2, [pc, #460]	@ (3419f9d4 <VD6G_ApplyVtPatchSlowBoot+0x25c>)
3419f806:	441a      	add	r2, r3
3419f808:	4871      	ldr	r0, [pc, #452]	@ (3419f9d0 <VD6G_ApplyVtPatchSlowBoot+0x258>)
3419f80a:	693b      	ldr	r3, [r7, #16]
3419f80c:	00db      	lsls	r3, r3, #3
3419f80e:	4403      	add	r3, r0
3419f810:	685b      	ldr	r3, [r3, #4]
3419f812:	6878      	ldr	r0, [r7, #4]
3419f814:	47a0      	blx	r4
3419f816:	60f8      	str	r0, [r7, #12]
                           vtpatch_desc[i].size);
    VD6G_TraceError(ctx, ret);
3419f818:	68fb      	ldr	r3, [r7, #12]
3419f81a:	2b00      	cmp	r3, #0
3419f81c:	d008      	beq.n	3419f830 <VD6G_ApplyVtPatchSlowBoot+0xb8>
3419f81e:	68fb      	ldr	r3, [r7, #12]
3419f820:	9300      	str	r3, [sp, #0]
3419f822:	f240 13f9 	movw	r3, #505	@ 0x1f9
3419f826:	4a68      	ldr	r2, [pc, #416]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f828:	4968      	ldr	r1, [pc, #416]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f82a:	6878      	ldr	r0, [r7, #4]
3419f82c:	f7ff fc97 	bl	3419f15e <VD6G_error>
3419f830:	68fb      	ldr	r3, [r7, #12]
3419f832:	2b00      	cmp	r3, #0
3419f834:	d002      	beq.n	3419f83c <VD6G_ApplyVtPatchSlowBoot+0xc4>
3419f836:	6878      	ldr	r0, [r7, #4]
3419f838:	f7ff fcac 	bl	3419f194 <display_error>
3419f83c:	68fb      	ldr	r3, [r7, #12]
3419f83e:	2b00      	cmp	r3, #0
3419f840:	d001      	beq.n	3419f846 <VD6G_ApplyVtPatchSlowBoot+0xce>
3419f842:	68fb      	ldr	r3, [r7, #12]
3419f844:	e145      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
    vtpatch_offset += vtpatch_desc[i].size;
3419f846:	4a62      	ldr	r2, [pc, #392]	@ (3419f9d0 <VD6G_ApplyVtPatchSlowBoot+0x258>)
3419f848:	693b      	ldr	r3, [r7, #16]
3419f84a:	00db      	lsls	r3, r3, #3
3419f84c:	4413      	add	r3, r2
3419f84e:	685b      	ldr	r3, [r3, #4]
3419f850:	697a      	ldr	r2, [r7, #20]
3419f852:	4413      	add	r3, r2
3419f854:	617b      	str	r3, [r7, #20]
  for (i = 0; i < vtpatch_area_nb; i++) {
3419f856:	693b      	ldr	r3, [r7, #16]
3419f858:	3301      	adds	r3, #1
3419f85a:	613b      	str	r3, [r7, #16]
3419f85c:	4b5e      	ldr	r3, [pc, #376]	@ (3419f9d8 <VD6G_ApplyVtPatchSlowBoot+0x260>)
3419f85e:	681b      	ldr	r3, [r3, #0]
3419f860:	693a      	ldr	r2, [r7, #16]
3419f862:	429a      	cmp	r2, r3
3419f864:	dbc6      	blt.n	3419f7f4 <VD6G_ApplyVtPatchSlowBoot+0x7c>
  }
  ret = ctx->write8(ctx, 0xd9f8, VT_REVISION);
3419f866:	687b      	ldr	r3, [r7, #4]
3419f868:	691b      	ldr	r3, [r3, #16]
3419f86a:	2211      	movs	r2, #17
3419f86c:	f64d 11f8 	movw	r1, #55800	@ 0xd9f8
3419f870:	6878      	ldr	r0, [r7, #4]
3419f872:	4798      	blx	r3
3419f874:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f876:	68fb      	ldr	r3, [r7, #12]
3419f878:	2b00      	cmp	r3, #0
3419f87a:	d008      	beq.n	3419f88e <VD6G_ApplyVtPatchSlowBoot+0x116>
3419f87c:	68fb      	ldr	r3, [r7, #12]
3419f87e:	9300      	str	r3, [sp, #0]
3419f880:	f240 13fd 	movw	r3, #509	@ 0x1fd
3419f884:	4a50      	ldr	r2, [pc, #320]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f886:	4951      	ldr	r1, [pc, #324]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f888:	6878      	ldr	r0, [r7, #4]
3419f88a:	f7ff fc68 	bl	3419f15e <VD6G_error>
3419f88e:	68fb      	ldr	r3, [r7, #12]
3419f890:	2b00      	cmp	r3, #0
3419f892:	d002      	beq.n	3419f89a <VD6G_ApplyVtPatchSlowBoot+0x122>
3419f894:	6878      	ldr	r0, [r7, #4]
3419f896:	f7ff fc7d 	bl	3419f194 <display_error>
3419f89a:	68fb      	ldr	r3, [r7, #12]
3419f89c:	2b00      	cmp	r3, #0
3419f89e:	d001      	beq.n	3419f8a4 <VD6G_ApplyVtPatchSlowBoot+0x12c>
3419f8a0:	68fb      	ldr	r3, [r7, #12]
3419f8a2:	e116      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xaffc, VT_REVISION);
3419f8a4:	687b      	ldr	r3, [r7, #4]
3419f8a6:	691b      	ldr	r3, [r3, #16]
3419f8a8:	2211      	movs	r2, #17
3419f8aa:	f64a 71fc 	movw	r1, #45052	@ 0xaffc
3419f8ae:	6878      	ldr	r0, [r7, #4]
3419f8b0:	4798      	blx	r3
3419f8b2:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f8b4:	68fb      	ldr	r3, [r7, #12]
3419f8b6:	2b00      	cmp	r3, #0
3419f8b8:	d008      	beq.n	3419f8cc <VD6G_ApplyVtPatchSlowBoot+0x154>
3419f8ba:	68fb      	ldr	r3, [r7, #12]
3419f8bc:	9300      	str	r3, [sp, #0]
3419f8be:	f240 13ff 	movw	r3, #511	@ 0x1ff
3419f8c2:	4a41      	ldr	r2, [pc, #260]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f8c4:	4941      	ldr	r1, [pc, #260]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f8c6:	6878      	ldr	r0, [r7, #4]
3419f8c8:	f7ff fc49 	bl	3419f15e <VD6G_error>
3419f8cc:	68fb      	ldr	r3, [r7, #12]
3419f8ce:	2b00      	cmp	r3, #0
3419f8d0:	d002      	beq.n	3419f8d8 <VD6G_ApplyVtPatchSlowBoot+0x160>
3419f8d2:	6878      	ldr	r0, [r7, #4]
3419f8d4:	f7ff fc5e 	bl	3419f194 <display_error>
3419f8d8:	68fb      	ldr	r3, [r7, #12]
3419f8da:	2b00      	cmp	r3, #0
3419f8dc:	d001      	beq.n	3419f8e2 <VD6G_ApplyVtPatchSlowBoot+0x16a>
3419f8de:	68fb      	ldr	r3, [r7, #12]
3419f8e0:	e0f7      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xbbb4, VT_REVISION);
3419f8e2:	687b      	ldr	r3, [r7, #4]
3419f8e4:	691b      	ldr	r3, [r3, #16]
3419f8e6:	2211      	movs	r2, #17
3419f8e8:	f64b 31b4 	movw	r1, #48052	@ 0xbbb4
3419f8ec:	6878      	ldr	r0, [r7, #4]
3419f8ee:	4798      	blx	r3
3419f8f0:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f8f2:	68fb      	ldr	r3, [r7, #12]
3419f8f4:	2b00      	cmp	r3, #0
3419f8f6:	d008      	beq.n	3419f90a <VD6G_ApplyVtPatchSlowBoot+0x192>
3419f8f8:	68fb      	ldr	r3, [r7, #12]
3419f8fa:	9300      	str	r3, [sp, #0]
3419f8fc:	f240 2301 	movw	r3, #513	@ 0x201
3419f900:	4a31      	ldr	r2, [pc, #196]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f902:	4932      	ldr	r1, [pc, #200]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f904:	6878      	ldr	r0, [r7, #4]
3419f906:	f7ff fc2a 	bl	3419f15e <VD6G_error>
3419f90a:	68fb      	ldr	r3, [r7, #12]
3419f90c:	2b00      	cmp	r3, #0
3419f90e:	d002      	beq.n	3419f916 <VD6G_ApplyVtPatchSlowBoot+0x19e>
3419f910:	6878      	ldr	r0, [r7, #4]
3419f912:	f7ff fc3f 	bl	3419f194 <display_error>
3419f916:	68fb      	ldr	r3, [r7, #12]
3419f918:	2b00      	cmp	r3, #0
3419f91a:	d001      	beq.n	3419f920 <VD6G_ApplyVtPatchSlowBoot+0x1a8>
3419f91c:	68fb      	ldr	r3, [r7, #12]
3419f91e:	e0d8      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xb898, VT_REVISION);
3419f920:	687b      	ldr	r3, [r7, #4]
3419f922:	691b      	ldr	r3, [r3, #16]
3419f924:	2211      	movs	r2, #17
3419f926:	f64b 0198 	movw	r1, #47256	@ 0xb898
3419f92a:	6878      	ldr	r0, [r7, #4]
3419f92c:	4798      	blx	r3
3419f92e:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f930:	68fb      	ldr	r3, [r7, #12]
3419f932:	2b00      	cmp	r3, #0
3419f934:	d008      	beq.n	3419f948 <VD6G_ApplyVtPatchSlowBoot+0x1d0>
3419f936:	68fb      	ldr	r3, [r7, #12]
3419f938:	9300      	str	r3, [sp, #0]
3419f93a:	f240 2303 	movw	r3, #515	@ 0x203
3419f93e:	4a22      	ldr	r2, [pc, #136]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f940:	4922      	ldr	r1, [pc, #136]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f942:	6878      	ldr	r0, [r7, #4]
3419f944:	f7ff fc0b 	bl	3419f15e <VD6G_error>
3419f948:	68fb      	ldr	r3, [r7, #12]
3419f94a:	2b00      	cmp	r3, #0
3419f94c:	d002      	beq.n	3419f954 <VD6G_ApplyVtPatchSlowBoot+0x1dc>
3419f94e:	6878      	ldr	r0, [r7, #4]
3419f950:	f7ff fc20 	bl	3419f194 <display_error>
3419f954:	68fb      	ldr	r3, [r7, #12]
3419f956:	2b00      	cmp	r3, #0
3419f958:	d001      	beq.n	3419f95e <VD6G_ApplyVtPatchSlowBoot+0x1e6>
3419f95a:	68fb      	ldr	r3, [r7, #12]
3419f95c:	e0b9      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_END_VTRAM_UPDATE);
3419f95e:	687b      	ldr	r3, [r7, #4]
3419f960:	691b      	ldr	r3, [r3, #16]
3419f962:	2202      	movs	r2, #2
3419f964:	f240 2103 	movw	r1, #515	@ 0x203
3419f968:	6878      	ldr	r0, [r7, #4]
3419f96a:	4798      	blx	r3
3419f96c:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f96e:	68fb      	ldr	r3, [r7, #12]
3419f970:	2b00      	cmp	r3, #0
3419f972:	d008      	beq.n	3419f986 <VD6G_ApplyVtPatchSlowBoot+0x20e>
3419f974:	68fb      	ldr	r3, [r7, #12]
3419f976:	9300      	str	r3, [sp, #0]
3419f978:	f240 2306 	movw	r3, #518	@ 0x206
3419f97c:	4a12      	ldr	r2, [pc, #72]	@ (3419f9c8 <VD6G_ApplyVtPatchSlowBoot+0x250>)
3419f97e:	4913      	ldr	r1, [pc, #76]	@ (3419f9cc <VD6G_ApplyVtPatchSlowBoot+0x254>)
3419f980:	6878      	ldr	r0, [r7, #4]
3419f982:	f7ff fbec 	bl	3419f15e <VD6G_error>
3419f986:	68fb      	ldr	r3, [r7, #12]
3419f988:	2b00      	cmp	r3, #0
3419f98a:	d002      	beq.n	3419f992 <VD6G_ApplyVtPatchSlowBoot+0x21a>
3419f98c:	6878      	ldr	r0, [r7, #4]
3419f98e:	f7ff fc01 	bl	3419f194 <display_error>
3419f992:	68fb      	ldr	r3, [r7, #12]
3419f994:	2b00      	cmp	r3, #0
3419f996:	d001      	beq.n	3419f99c <VD6G_ApplyVtPatchSlowBoot+0x224>
3419f998:	68fb      	ldr	r3, [r7, #12]
3419f99a:	e09a      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
3419f99c:	2200      	movs	r2, #0
3419f99e:	f240 2103 	movw	r1, #515	@ 0x203
3419f9a2:	6878      	ldr	r0, [r7, #4]
3419f9a4:	f7ff fc1e 	bl	3419f1e4 <VD6G_PollReg8>
3419f9a8:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f9aa:	68fb      	ldr	r3, [r7, #12]
3419f9ac:	2b00      	cmp	r3, #0
3419f9ae:	d001      	beq.n	3419f9b4 <VD6G_ApplyVtPatchSlowBoot+0x23c>
    return ret;
3419f9b0:	68fb      	ldr	r3, [r7, #12]
3419f9b2:	e08e      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
3419f9b4:	2102      	movs	r1, #2
3419f9b6:	6878      	ldr	r0, [r7, #4]
3419f9b8:	f7ff fcce 	bl	3419f358 <VD6G_WaitState>
3419f9bc:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f9be:	68fb      	ldr	r3, [r7, #12]
3419f9c0:	2b00      	cmp	r3, #0
3419f9c2:	d00b      	beq.n	3419f9dc <VD6G_ApplyVtPatchSlowBoot+0x264>
    return ret;
3419f9c4:	68fb      	ldr	r3, [r7, #12]
3419f9c6:	e084      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
3419f9c8:	341b74b0 	.word	0x341b74b0
3419f9cc:	341a6494 	.word	0x341a6494
3419f9d0:	341c00f8 	.word	0x341c00f8
3419f9d4:	341b5b58 	.word	0x341b5b58
3419f9d8:	341c0130 	.word	0x341c0130

  ret = ctx->read8(ctx, VD6G_REG_VTIMING_RD_REVISION, &cur_vtpatch_rd_rev);
3419f9dc:	687b      	ldr	r3, [r7, #4]
3419f9de:	685b      	ldr	r3, [r3, #4]
3419f9e0:	f107 020b 	add.w	r2, r7, #11
3419f9e4:	2120      	movs	r1, #32
3419f9e6:	6878      	ldr	r0, [r7, #4]
3419f9e8:	4798      	blx	r3
3419f9ea:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419f9ec:	68fb      	ldr	r3, [r7, #12]
3419f9ee:	2b00      	cmp	r3, #0
3419f9f0:	d008      	beq.n	3419fa04 <VD6G_ApplyVtPatchSlowBoot+0x28c>
3419f9f2:	68fb      	ldr	r3, [r7, #12]
3419f9f4:	9300      	str	r3, [sp, #0]
3419f9f6:	f240 2311 	movw	r3, #529	@ 0x211
3419f9fa:	4a38      	ldr	r2, [pc, #224]	@ (3419fadc <VD6G_ApplyVtPatchSlowBoot+0x364>)
3419f9fc:	4938      	ldr	r1, [pc, #224]	@ (3419fae0 <VD6G_ApplyVtPatchSlowBoot+0x368>)
3419f9fe:	6878      	ldr	r0, [r7, #4]
3419fa00:	f7ff fbad 	bl	3419f15e <VD6G_error>
3419fa04:	68fb      	ldr	r3, [r7, #12]
3419fa06:	2b00      	cmp	r3, #0
3419fa08:	d002      	beq.n	3419fa10 <VD6G_ApplyVtPatchSlowBoot+0x298>
3419fa0a:	6878      	ldr	r0, [r7, #4]
3419fa0c:	f7ff fbc2 	bl	3419f194 <display_error>
3419fa10:	68fb      	ldr	r3, [r7, #12]
3419fa12:	2b00      	cmp	r3, #0
3419fa14:	d001      	beq.n	3419fa1a <VD6G_ApplyVtPatchSlowBoot+0x2a2>
3419fa16:	68fb      	ldr	r3, [r7, #12]
3419fa18:	e05b      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GR_REVISION, &cur_vtpatch_gr_rev);
3419fa1a:	687b      	ldr	r3, [r7, #4]
3419fa1c:	685b      	ldr	r3, [r3, #4]
3419fa1e:	f107 020a 	add.w	r2, r7, #10
3419fa22:	2124      	movs	r1, #36	@ 0x24
3419fa24:	6878      	ldr	r0, [r7, #4]
3419fa26:	4798      	blx	r3
3419fa28:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419fa2a:	68fb      	ldr	r3, [r7, #12]
3419fa2c:	2b00      	cmp	r3, #0
3419fa2e:	d008      	beq.n	3419fa42 <VD6G_ApplyVtPatchSlowBoot+0x2ca>
3419fa30:	68fb      	ldr	r3, [r7, #12]
3419fa32:	9300      	str	r3, [sp, #0]
3419fa34:	f240 2313 	movw	r3, #531	@ 0x213
3419fa38:	4a28      	ldr	r2, [pc, #160]	@ (3419fadc <VD6G_ApplyVtPatchSlowBoot+0x364>)
3419fa3a:	4929      	ldr	r1, [pc, #164]	@ (3419fae0 <VD6G_ApplyVtPatchSlowBoot+0x368>)
3419fa3c:	6878      	ldr	r0, [r7, #4]
3419fa3e:	f7ff fb8e 	bl	3419f15e <VD6G_error>
3419fa42:	68fb      	ldr	r3, [r7, #12]
3419fa44:	2b00      	cmp	r3, #0
3419fa46:	d002      	beq.n	3419fa4e <VD6G_ApplyVtPatchSlowBoot+0x2d6>
3419fa48:	6878      	ldr	r0, [r7, #4]
3419fa4a:	f7ff fba3 	bl	3419f194 <display_error>
3419fa4e:	68fb      	ldr	r3, [r7, #12]
3419fa50:	2b00      	cmp	r3, #0
3419fa52:	d001      	beq.n	3419fa58 <VD6G_ApplyVtPatchSlowBoot+0x2e0>
3419fa54:	68fb      	ldr	r3, [r7, #12]
3419fa56:	e03c      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GT_REVISION, &cur_vtpatch_gt_rev);
3419fa58:	687b      	ldr	r3, [r7, #4]
3419fa5a:	685b      	ldr	r3, [r3, #4]
3419fa5c:	f107 0209 	add.w	r2, r7, #9
3419fa60:	2126      	movs	r1, #38	@ 0x26
3419fa62:	6878      	ldr	r0, [r7, #4]
3419fa64:	4798      	blx	r3
3419fa66:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419fa68:	68fb      	ldr	r3, [r7, #12]
3419fa6a:	2b00      	cmp	r3, #0
3419fa6c:	d008      	beq.n	3419fa80 <VD6G_ApplyVtPatchSlowBoot+0x308>
3419fa6e:	68fb      	ldr	r3, [r7, #12]
3419fa70:	9300      	str	r3, [sp, #0]
3419fa72:	f240 2315 	movw	r3, #533	@ 0x215
3419fa76:	4a19      	ldr	r2, [pc, #100]	@ (3419fadc <VD6G_ApplyVtPatchSlowBoot+0x364>)
3419fa78:	4919      	ldr	r1, [pc, #100]	@ (3419fae0 <VD6G_ApplyVtPatchSlowBoot+0x368>)
3419fa7a:	6878      	ldr	r0, [r7, #4]
3419fa7c:	f7ff fb6f 	bl	3419f15e <VD6G_error>
3419fa80:	68fb      	ldr	r3, [r7, #12]
3419fa82:	2b00      	cmp	r3, #0
3419fa84:	d002      	beq.n	3419fa8c <VD6G_ApplyVtPatchSlowBoot+0x314>
3419fa86:	6878      	ldr	r0, [r7, #4]
3419fa88:	f7ff fb84 	bl	3419f194 <display_error>
3419fa8c:	68fb      	ldr	r3, [r7, #12]
3419fa8e:	2b00      	cmp	r3, #0
3419fa90:	d001      	beq.n	3419fa96 <VD6G_ApplyVtPatchSlowBoot+0x31e>
3419fa92:	68fb      	ldr	r3, [r7, #12]
3419fa94:	e01d      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>

  if (cur_vtpatch_rd_rev != VT_REVISION ||
3419fa96:	7afb      	ldrb	r3, [r7, #11]
3419fa98:	2b11      	cmp	r3, #17
3419fa9a:	d105      	bne.n	3419faa8 <VD6G_ApplyVtPatchSlowBoot+0x330>
      cur_vtpatch_gr_rev != VT_REVISION ||
3419fa9c:	7abb      	ldrb	r3, [r7, #10]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
3419fa9e:	2b11      	cmp	r3, #17
3419faa0:	d102      	bne.n	3419faa8 <VD6G_ApplyVtPatchSlowBoot+0x330>
      cur_vtpatch_gt_rev != VT_REVISION) {
3419faa2:	7a7b      	ldrb	r3, [r7, #9]
      cur_vtpatch_gr_rev != VT_REVISION ||
3419faa4:	2b11      	cmp	r3, #17
3419faa6:	d00e      	beq.n	3419fac6 <VD6G_ApplyVtPatchSlowBoot+0x34e>
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
3419faa8:	7afb      	ldrb	r3, [r7, #11]
3419faaa:	4619      	mov	r1, r3
3419faac:	7abb      	ldrb	r3, [r7, #10]
3419faae:	7a7a      	ldrb	r2, [r7, #9]
3419fab0:	9201      	str	r2, [sp, #4]
3419fab2:	9300      	str	r3, [sp, #0]
3419fab4:	460b      	mov	r3, r1
3419fab6:	2211      	movs	r2, #17
3419fab8:	490a      	ldr	r1, [pc, #40]	@ (3419fae4 <VD6G_ApplyVtPatchSlowBoot+0x36c>)
3419faba:	6878      	ldr	r0, [r7, #4]
3419fabc:	f7ff fb4f 	bl	3419f15e <VD6G_error>
                 cur_vtpatch_gr_rev, cur_vtpatch_gt_rev);
    return -1;
3419fac0:	f04f 33ff 	mov.w	r3, #4294967295
3419fac4:	e005      	b.n	3419fad2 <VD6G_ApplyVtPatchSlowBoot+0x35a>
  }
  VD6G_notice(ctx, "VT patch %d applied\n", VT_REVISION);
3419fac6:	2211      	movs	r2, #17
3419fac8:	4907      	ldr	r1, [pc, #28]	@ (3419fae8 <VD6G_ApplyVtPatchSlowBoot+0x370>)
3419faca:	6878      	ldr	r0, [r7, #4]
3419facc:	f7ff fb11 	bl	3419f0f2 <VD6G_notice>

  return 0;
3419fad0:	2300      	movs	r3, #0
}
3419fad2:	4618      	mov	r0, r3
3419fad4:	371c      	adds	r7, #28
3419fad6:	46bd      	mov	sp, r7
3419fad8:	bd90      	pop	{r4, r7, pc}
3419fada:	bf00      	nop
3419fadc:	341b74b0 	.word	0x341b74b0
3419fae0:	341a6494 	.word	0x341a6494
3419fae4:	341a65c8 	.word	0x341a65c8
3419fae8:	341a6604 	.word	0x341a6604

3419faec <VD6G_ApplyVtPatch>:

static int VD6G_ApplyVtPatch(VD6G_Ctx_t *ctx)
{
3419faec:	b580      	push	{r7, lr}
3419faee:	b084      	sub	sp, #16
3419faf0:	af00      	add	r7, sp, #0
3419faf2:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  int ret;

  ret = VD6G_GetTopDie(ctx, &top_die);
3419faf4:	f107 030b 	add.w	r3, r7, #11
3419faf8:	4619      	mov	r1, r3
3419fafa:	6878      	ldr	r0, [r7, #4]
3419fafc:	f7ff fc52 	bl	3419f3a4 <VD6G_GetTopDie>
3419fb00:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fb02:	68fb      	ldr	r3, [r7, #12]
3419fb04:	2b00      	cmp	r3, #0
3419fb06:	d001      	beq.n	3419fb0c <VD6G_ApplyVtPatch+0x20>
    return ret;
3419fb08:	68fb      	ldr	r3, [r7, #12]
3419fb0a:	e015      	b.n	3419fb38 <VD6G_ApplyVtPatch+0x4c>

  switch (top_die) {
3419fb0c:	7afb      	ldrb	r3, [r7, #11]
3419fb0e:	2b20      	cmp	r3, #32
3419fb10:	d002      	beq.n	3419fb18 <VD6G_ApplyVtPatch+0x2c>
3419fb12:	2b31      	cmp	r3, #49	@ 0x31
3419fb14:	d005      	beq.n	3419fb22 <VD6G_ApplyVtPatch+0x36>
3419fb16:	e007      	b.n	3419fb28 <VD6G_ApplyVtPatch+0x3c>
  case VD6G_TOP_DIE_SLOW_BOOT:
    ret = VD6G_ApplyVtPatchSlowBoot(ctx);
3419fb18:	6878      	ldr	r0, [r7, #4]
3419fb1a:	f7ff fe2d 	bl	3419f778 <VD6G_ApplyVtPatchSlowBoot>
3419fb1e:	60f8      	str	r0, [r7, #12]
    break;
3419fb20:	e009      	b.n	3419fb36 <VD6G_ApplyVtPatch+0x4a>
  case VD6G_TOP_DIE_FAST_BOOT:
    ret = 0;
3419fb22:	2300      	movs	r3, #0
3419fb24:	60fb      	str	r3, [r7, #12]
    break;
3419fb26:	e006      	b.n	3419fb36 <VD6G_ApplyVtPatch+0x4a>
  default:
    assert(0);
3419fb28:	4b05      	ldr	r3, [pc, #20]	@ (3419fb40 <VD6G_ApplyVtPatch+0x54>)
3419fb2a:	4a06      	ldr	r2, [pc, #24]	@ (3419fb44 <VD6G_ApplyVtPatch+0x58>)
3419fb2c:	f44f 710d 	mov.w	r1, #564	@ 0x234
3419fb30:	4805      	ldr	r0, [pc, #20]	@ (3419fb48 <VD6G_ApplyVtPatch+0x5c>)
3419fb32:	f003 fead 	bl	341a3890 <__assert_func>
  }

  return ret;
3419fb36:	68fb      	ldr	r3, [r7, #12]
}
3419fb38:	4618      	mov	r0, r3
3419fb3a:	3710      	adds	r7, #16
3419fb3c:	46bd      	mov	sp, r7
3419fb3e:	bd80      	pop	{r7, pc}
3419fb40:	341a65a8 	.word	0x341a65a8
3419fb44:	341b74cc 	.word	0x341b74cc
3419fb48:	341a6444 	.word	0x341a6444

3419fb4c <VD6G_SetBayerType>:

static int VD6G_SetBayerType(VD6G_Ctx_t *ctx)
{
3419fb4c:	b580      	push	{r7, lr}
3419fb4e:	b088      	sub	sp, #32
3419fb50:	af02      	add	r7, sp, #8
3419fb52:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
3419fb54:	687b      	ldr	r3, [r7, #4]
3419fb56:	332c      	adds	r3, #44	@ 0x2c
3419fb58:	617b      	str	r3, [r7, #20]
  uint8_t reg8;
  int ret;

  ret = ctx->read8(ctx, VD6G_REG_OPTICAL_REVISION, &reg8);
3419fb5a:	687b      	ldr	r3, [r7, #4]
3419fb5c:	685b      	ldr	r3, [r3, #4]
3419fb5e:	f107 020f 	add.w	r2, r7, #15
3419fb62:	211a      	movs	r1, #26
3419fb64:	6878      	ldr	r0, [r7, #4]
3419fb66:	4798      	blx	r3
3419fb68:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419fb6a:	693b      	ldr	r3, [r7, #16]
3419fb6c:	2b00      	cmp	r3, #0
3419fb6e:	d008      	beq.n	3419fb82 <VD6G_SetBayerType+0x36>
3419fb70:	693b      	ldr	r3, [r7, #16]
3419fb72:	9300      	str	r3, [sp, #0]
3419fb74:	f240 2341 	movw	r3, #577	@ 0x241
3419fb78:	4a24      	ldr	r2, [pc, #144]	@ (3419fc0c <VD6G_SetBayerType+0xc0>)
3419fb7a:	4925      	ldr	r1, [pc, #148]	@ (3419fc10 <VD6G_SetBayerType+0xc4>)
3419fb7c:	6878      	ldr	r0, [r7, #4]
3419fb7e:	f7ff faee 	bl	3419f15e <VD6G_error>
3419fb82:	693b      	ldr	r3, [r7, #16]
3419fb84:	2b00      	cmp	r3, #0
3419fb86:	d002      	beq.n	3419fb8e <VD6G_SetBayerType+0x42>
3419fb88:	6878      	ldr	r0, [r7, #4]
3419fb8a:	f7ff fb03 	bl	3419f194 <display_error>
3419fb8e:	693b      	ldr	r3, [r7, #16]
3419fb90:	2b00      	cmp	r3, #0
3419fb92:	d001      	beq.n	3419fb98 <VD6G_SetBayerType+0x4c>
3419fb94:	693b      	ldr	r3, [r7, #16]
3419fb96:	e035      	b.n	3419fc04 <VD6G_SetBayerType+0xb8>

  if (!(reg8 & 1)) {
3419fb98:	7bfb      	ldrb	r3, [r7, #15]
3419fb9a:	f003 0301 	and.w	r3, r3, #1
3419fb9e:	2b00      	cmp	r3, #0
3419fba0:	d105      	bne.n	3419fbae <VD6G_SetBayerType+0x62>
    ctx->bayer = VD6G_BAYER_NONE;
3419fba2:	687b      	ldr	r3, [r7, #4]
3419fba4:	2200      	movs	r2, #0
3419fba6:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    return 0;
3419fbaa:	2300      	movs	r3, #0
3419fbac:	e02a      	b.n	3419fc04 <VD6G_SetBayerType+0xb8>
  }

  switch (drv_ctx->config_save.flip_mirror_mode) {
3419fbae:	697b      	ldr	r3, [r7, #20]
3419fbb0:	7c1b      	ldrb	r3, [r3, #16]
3419fbb2:	2b03      	cmp	r3, #3
3419fbb4:	d81e      	bhi.n	3419fbf4 <VD6G_SetBayerType+0xa8>
3419fbb6:	a201      	add	r2, pc, #4	@ (adr r2, 3419fbbc <VD6G_SetBayerType+0x70>)
3419fbb8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419fbbc:	3419fbcd 	.word	0x3419fbcd
3419fbc0:	3419fbd7 	.word	0x3419fbd7
3419fbc4:	3419fbe1 	.word	0x3419fbe1
3419fbc8:	3419fbeb 	.word	0x3419fbeb
  case VD6G_MIRROR_FLIP_NONE:
    ctx->bayer = VD6G_BAYER_GRBG;
3419fbcc:	687b      	ldr	r3, [r7, #4]
3419fbce:	2202      	movs	r2, #2
3419fbd0:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
3419fbd4:	e015      	b.n	3419fc02 <VD6G_SetBayerType+0xb6>
  case VD6G_FLIP:
    ctx->bayer = VD6G_BAYER_BGGR;
3419fbd6:	687b      	ldr	r3, [r7, #4]
3419fbd8:	2204      	movs	r2, #4
3419fbda:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
3419fbde:	e010      	b.n	3419fc02 <VD6G_SetBayerType+0xb6>
  case VD6G_MIRROR:
    ctx->bayer = VD6G_BAYER_RGGB;
3419fbe0:	687b      	ldr	r3, [r7, #4]
3419fbe2:	2201      	movs	r2, #1
3419fbe4:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
3419fbe8:	e00b      	b.n	3419fc02 <VD6G_SetBayerType+0xb6>
  case VD6G_MIRROR_FLIP:
    ctx->bayer = VD6G_BAYER_GBRG;
3419fbea:	687b      	ldr	r3, [r7, #4]
3419fbec:	2203      	movs	r2, #3
3419fbee:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
3419fbf2:	e006      	b.n	3419fc02 <VD6G_SetBayerType+0xb6>
  default:
    assert(0);
3419fbf4:	4b07      	ldr	r3, [pc, #28]	@ (3419fc14 <VD6G_SetBayerType+0xc8>)
3419fbf6:	4a05      	ldr	r2, [pc, #20]	@ (3419fc0c <VD6G_SetBayerType+0xc0>)
3419fbf8:	f240 2156 	movw	r1, #598	@ 0x256
3419fbfc:	4806      	ldr	r0, [pc, #24]	@ (3419fc18 <VD6G_SetBayerType+0xcc>)
3419fbfe:	f003 fe47 	bl	341a3890 <__assert_func>
  }

  return 0;
3419fc02:	2300      	movs	r3, #0
}
3419fc04:	4618      	mov	r0, r3
3419fc06:	3718      	adds	r7, #24
3419fc08:	46bd      	mov	sp, r7
3419fc0a:	bd80      	pop	{r7, pc}
3419fc0c:	341b74e0 	.word	0x341b74e0
3419fc10:	341a6494 	.word	0x341a6494
3419fc14:	341a65a8 	.word	0x341a65a8
3419fc18:	341a6444 	.word	0x341a6444

3419fc1c <VD6G_SetExposureModeInternal>:

static int VD6G_SetExposureModeInternal(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
3419fc1c:	b580      	push	{r7, lr}
3419fc1e:	b086      	sub	sp, #24
3419fc20:	af02      	add	r7, sp, #8
3419fc22:	6078      	str	r0, [r7, #4]
3419fc24:	460b      	mov	r3, r1
3419fc26:	70fb      	strb	r3, [r7, #3]
  int ret;

  if ((mode != VD6G_EXPOSURE_AUTO) &&
3419fc28:	78fb      	ldrb	r3, [r7, #3]
3419fc2a:	2b00      	cmp	r3, #0
3419fc2c:	d008      	beq.n	3419fc40 <VD6G_SetExposureModeInternal+0x24>
3419fc2e:	78fb      	ldrb	r3, [r7, #3]
3419fc30:	2b01      	cmp	r3, #1
3419fc32:	d005      	beq.n	3419fc40 <VD6G_SetExposureModeInternal+0x24>
      (mode != VD6G_EXPOSURE_FREEZE_AEALGO) &&
3419fc34:	78fb      	ldrb	r3, [r7, #3]
3419fc36:	2b02      	cmp	r3, #2
3419fc38:	d002      	beq.n	3419fc40 <VD6G_SetExposureModeInternal+0x24>
      (mode != VD6G_EXPOSURE_MANUAL)) {
    return -1;
3419fc3a:	f04f 33ff 	mov.w	r3, #4294967295
3419fc3e:	e01f      	b.n	3419fc80 <VD6G_SetExposureModeInternal+0x64>
  }

  ret = ctx->write8(ctx, VD6G_REG_EXP_MODE, mode);
3419fc40:	687b      	ldr	r3, [r7, #4]
3419fc42:	691b      	ldr	r3, [r3, #16]
3419fc44:	78fa      	ldrb	r2, [r7, #3]
3419fc46:	f240 414c 	movw	r1, #1100	@ 0x44c
3419fc4a:	6878      	ldr	r0, [r7, #4]
3419fc4c:	4798      	blx	r3
3419fc4e:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
3419fc50:	68fb      	ldr	r3, [r7, #12]
3419fc52:	2b00      	cmp	r3, #0
3419fc54:	d008      	beq.n	3419fc68 <VD6G_SetExposureModeInternal+0x4c>
3419fc56:	68fb      	ldr	r3, [r7, #12]
3419fc58:	9300      	str	r3, [sp, #0]
3419fc5a:	f240 2367 	movw	r3, #615	@ 0x267
3419fc5e:	4a0a      	ldr	r2, [pc, #40]	@ (3419fc88 <VD6G_SetExposureModeInternal+0x6c>)
3419fc60:	490a      	ldr	r1, [pc, #40]	@ (3419fc8c <VD6G_SetExposureModeInternal+0x70>)
3419fc62:	6878      	ldr	r0, [r7, #4]
3419fc64:	f7ff fa7b 	bl	3419f15e <VD6G_error>
3419fc68:	68fb      	ldr	r3, [r7, #12]
3419fc6a:	2b00      	cmp	r3, #0
3419fc6c:	d002      	beq.n	3419fc74 <VD6G_SetExposureModeInternal+0x58>
3419fc6e:	6878      	ldr	r0, [r7, #4]
3419fc70:	f7ff fa90 	bl	3419f194 <display_error>
3419fc74:	68fb      	ldr	r3, [r7, #12]
3419fc76:	2b00      	cmp	r3, #0
3419fc78:	d001      	beq.n	3419fc7e <VD6G_SetExposureModeInternal+0x62>
3419fc7a:	68fb      	ldr	r3, [r7, #12]
3419fc7c:	e000      	b.n	3419fc80 <VD6G_SetExposureModeInternal+0x64>

  return 0;
3419fc7e:	2300      	movs	r3, #0
}
3419fc80:	4618      	mov	r0, r3
3419fc82:	3710      	adds	r7, #16
3419fc84:	46bd      	mov	sp, r7
3419fc86:	bd80      	pop	{r7, pc}
3419fc88:	341b74f4 	.word	0x341b74f4
3419fc8c:	341a6494 	.word	0x341a6494

3419fc90 <VD6G_Gpios>:

static int VD6G_Gpios(VD6G_Ctx_t *ctx)
{
3419fc90:	b580      	push	{r7, lr}
3419fc92:	b088      	sub	sp, #32
3419fc94:	af02      	add	r7, sp, #8
3419fc96:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
3419fc98:	687b      	ldr	r3, [r7, #4]
3419fc9a:	332c      	adds	r3, #44	@ 0x2c
3419fc9c:	613b      	str	r3, [r7, #16]
  int ret;
  int i;

  for (i = 0; i < VD6G_GPIO_NB; i++) {
3419fc9e:	2300      	movs	r3, #0
3419fca0:	617b      	str	r3, [r7, #20]
3419fca2:	e029      	b.n	3419fcf8 <VD6G_Gpios+0x68>
    ret = ctx->write8(ctx, VD6G_REG_GPIO_x_CTRL(i), drv_ctx->config_save.gpio_ctrl[i]);
3419fca4:	687b      	ldr	r3, [r7, #4]
3419fca6:	691b      	ldr	r3, [r3, #16]
3419fca8:	697a      	ldr	r2, [r7, #20]
3419fcaa:	b292      	uxth	r2, r2
3419fcac:	f202 4267 	addw	r2, r2, #1127	@ 0x467
3419fcb0:	b290      	uxth	r0, r2
3419fcb2:	6939      	ldr	r1, [r7, #16]
3419fcb4:	697a      	ldr	r2, [r7, #20]
3419fcb6:	440a      	add	r2, r1
3419fcb8:	3230      	adds	r2, #48	@ 0x30
3419fcba:	7812      	ldrb	r2, [r2, #0]
3419fcbc:	4601      	mov	r1, r0
3419fcbe:	6878      	ldr	r0, [r7, #4]
3419fcc0:	4798      	blx	r3
3419fcc2:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
3419fcc4:	68fb      	ldr	r3, [r7, #12]
3419fcc6:	2b00      	cmp	r3, #0
3419fcc8:	d008      	beq.n	3419fcdc <VD6G_Gpios+0x4c>
3419fcca:	68fb      	ldr	r3, [r7, #12]
3419fccc:	9300      	str	r3, [sp, #0]
3419fcce:	f44f 731d 	mov.w	r3, #628	@ 0x274
3419fcd2:	4a0d      	ldr	r2, [pc, #52]	@ (3419fd08 <VD6G_Gpios+0x78>)
3419fcd4:	490d      	ldr	r1, [pc, #52]	@ (3419fd0c <VD6G_Gpios+0x7c>)
3419fcd6:	6878      	ldr	r0, [r7, #4]
3419fcd8:	f7ff fa41 	bl	3419f15e <VD6G_error>
3419fcdc:	68fb      	ldr	r3, [r7, #12]
3419fcde:	2b00      	cmp	r3, #0
3419fce0:	d002      	beq.n	3419fce8 <VD6G_Gpios+0x58>
3419fce2:	6878      	ldr	r0, [r7, #4]
3419fce4:	f7ff fa56 	bl	3419f194 <display_error>
3419fce8:	68fb      	ldr	r3, [r7, #12]
3419fcea:	2b00      	cmp	r3, #0
3419fcec:	d001      	beq.n	3419fcf2 <VD6G_Gpios+0x62>
3419fcee:	68fb      	ldr	r3, [r7, #12]
3419fcf0:	e006      	b.n	3419fd00 <VD6G_Gpios+0x70>
  for (i = 0; i < VD6G_GPIO_NB; i++) {
3419fcf2:	697b      	ldr	r3, [r7, #20]
3419fcf4:	3301      	adds	r3, #1
3419fcf6:	617b      	str	r3, [r7, #20]
3419fcf8:	697b      	ldr	r3, [r7, #20]
3419fcfa:	2b07      	cmp	r3, #7
3419fcfc:	ddd2      	ble.n	3419fca4 <VD6G_Gpios+0x14>
  }

  return 0;
3419fcfe:	2300      	movs	r3, #0
}
3419fd00:	4618      	mov	r0, r3
3419fd02:	3718      	adds	r7, #24
3419fd04:	46bd      	mov	sp, r7
3419fd06:	bd80      	pop	{r7, pc}
3419fd08:	341b7514 	.word	0x341b7514
3419fd0c:	341a6494 	.word	0x341a6494

3419fd10 <VD6G_Boot>:

static int VD6G_Boot(VD6G_Ctx_t *ctx)
{
3419fd10:	b580      	push	{r7, lr}
3419fd12:	b084      	sub	sp, #16
3419fd14:	af00      	add	r7, sp, #0
3419fd16:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
3419fd18:	2101      	movs	r1, #1
3419fd1a:	6878      	ldr	r0, [r7, #4]
3419fd1c:	f7ff fb1c 	bl	3419f358 <VD6G_WaitState>
3419fd20:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd22:	68fb      	ldr	r3, [r7, #12]
3419fd24:	2b00      	cmp	r3, #0
3419fd26:	d001      	beq.n	3419fd2c <VD6G_Boot+0x1c>
    return ret;
3419fd28:	68fb      	ldr	r3, [r7, #12]
3419fd2a:	e036      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_CheckModelId(ctx);
3419fd2c:	6878      	ldr	r0, [r7, #4]
3419fd2e:	f7ff fb75 	bl	3419f41c <VD6G_CheckModelId>
3419fd32:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd34:	68fb      	ldr	r3, [r7, #12]
3419fd36:	2b00      	cmp	r3, #0
3419fd38:	d001      	beq.n	3419fd3e <VD6G_Boot+0x2e>
    return ret;
3419fd3a:	68fb      	ldr	r3, [r7, #12]
3419fd3c:	e02d      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_ApplyPatch(ctx);
3419fd3e:	6878      	ldr	r0, [r7, #4]
3419fd40:	f7ff fca2 	bl	3419f688 <VD6G_ApplyPatch>
3419fd44:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd46:	68fb      	ldr	r3, [r7, #12]
3419fd48:	2b00      	cmp	r3, #0
3419fd4a:	d001      	beq.n	3419fd50 <VD6G_Boot+0x40>
    return ret;
3419fd4c:	68fb      	ldr	r3, [r7, #12]
3419fd4e:	e024      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_BootMcu(ctx);
3419fd50:	6878      	ldr	r0, [r7, #4]
3419fd52:	f7ff fcc9 	bl	3419f6e8 <VD6G_BootMcu>
3419fd56:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd58:	68fb      	ldr	r3, [r7, #12]
3419fd5a:	2b00      	cmp	r3, #0
3419fd5c:	d001      	beq.n	3419fd62 <VD6G_Boot+0x52>
    return ret;
3419fd5e:	68fb      	ldr	r3, [r7, #12]
3419fd60:	e01b      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_ApplyVtPatch(ctx);
3419fd62:	6878      	ldr	r0, [r7, #4]
3419fd64:	f7ff fec2 	bl	3419faec <VD6G_ApplyVtPatch>
3419fd68:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd6a:	68fb      	ldr	r3, [r7, #12]
3419fd6c:	2b00      	cmp	r3, #0
3419fd6e:	d001      	beq.n	3419fd74 <VD6G_Boot+0x64>
    return ret;
3419fd70:	68fb      	ldr	r3, [r7, #12]
3419fd72:	e012      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_SetBayerType(ctx);
3419fd74:	6878      	ldr	r0, [r7, #4]
3419fd76:	f7ff fee9 	bl	3419fb4c <VD6G_SetBayerType>
3419fd7a:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd7c:	68fb      	ldr	r3, [r7, #12]
3419fd7e:	2b00      	cmp	r3, #0
3419fd80:	d001      	beq.n	3419fd86 <VD6G_Boot+0x76>
    return ret;
3419fd82:	68fb      	ldr	r3, [r7, #12]
3419fd84:	e009      	b.n	3419fd9a <VD6G_Boot+0x8a>

  ret = VD6G_Gpios(ctx);
3419fd86:	6878      	ldr	r0, [r7, #4]
3419fd88:	f7ff ff82 	bl	3419fc90 <VD6G_Gpios>
3419fd8c:	60f8      	str	r0, [r7, #12]
  if (ret)
3419fd8e:	68fb      	ldr	r3, [r7, #12]
3419fd90:	2b00      	cmp	r3, #0
3419fd92:	d001      	beq.n	3419fd98 <VD6G_Boot+0x88>
    return ret;
3419fd94:	68fb      	ldr	r3, [r7, #12]
3419fd96:	e000      	b.n	3419fd9a <VD6G_Boot+0x8a>
  return 0;
3419fd98:	2300      	movs	r3, #0
}
3419fd9a:	4618      	mov	r0, r3
3419fd9c:	3710      	adds	r7, #16
3419fd9e:	46bd      	mov	sp, r7
3419fda0:	bd80      	pop	{r7, pc}
	...

3419fda4 <VD6G_ComputeClocks>:

static int VD6G_ComputeClocks(VD6G_Ctx_t *ctx, uint32_t ext_clock, uint8_t *pll_prediv, uint8_t *pll_mult)
{
3419fda4:	b580      	push	{r7, lr}
3419fda6:	b088      	sub	sp, #32
3419fda8:	af00      	add	r7, sp, #0
3419fdaa:	60f8      	str	r0, [r7, #12]
3419fdac:	60b9      	str	r1, [r7, #8]
3419fdae:	607a      	str	r2, [r7, #4]
3419fdb0:	603b      	str	r3, [r7, #0]
  const unsigned int predivs[] = { 1, 2, 4 };
3419fdb2:	4a2d      	ldr	r2, [pc, #180]	@ (3419fe68 <VD6G_ComputeClocks+0xc4>)
3419fdb4:	f107 0310 	add.w	r3, r7, #16
3419fdb8:	ca07      	ldmia	r2, {r0, r1, r2}
3419fdba:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  int i;

  if (ext_clock < 6 * M_HZ ||
3419fdbe:	68bb      	ldr	r3, [r7, #8]
3419fdc0:	4a2a      	ldr	r2, [pc, #168]	@ (3419fe6c <VD6G_ComputeClocks+0xc8>)
3419fdc2:	4293      	cmp	r3, r2
3419fdc4:	d903      	bls.n	3419fdce <VD6G_ComputeClocks+0x2a>
3419fdc6:	68bb      	ldr	r3, [r7, #8]
3419fdc8:	4a29      	ldr	r2, [pc, #164]	@ (3419fe70 <VD6G_ComputeClocks+0xcc>)
3419fdca:	4293      	cmp	r3, r2
3419fdcc:	d906      	bls.n	3419fddc <VD6G_ComputeClocks+0x38>
      ext_clock > 27 * M_HZ) {
    VD6G_error(ctx, "External clock out of rangen\n");
3419fdce:	4929      	ldr	r1, [pc, #164]	@ (3419fe74 <VD6G_ComputeClocks+0xd0>)
3419fdd0:	68f8      	ldr	r0, [r7, #12]
3419fdd2:	f7ff f9c4 	bl	3419f15e <VD6G_error>
    return -1;
3419fdd6:	f04f 33ff 	mov.w	r3, #4294967295
3419fdda:	e040      	b.n	3419fe5e <VD6G_ComputeClocks+0xba>
  }

  /* PLL input should be in [6Mhz-12Mhz[ */
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
3419fddc:	2300      	movs	r3, #0
3419fdde:	61fb      	str	r3, [r7, #28]
3419fde0:	e014      	b.n	3419fe0c <VD6G_ComputeClocks+0x68>
    *pll_prediv = predivs[i];
3419fde2:	69fb      	ldr	r3, [r7, #28]
3419fde4:	009b      	lsls	r3, r3, #2
3419fde6:	3320      	adds	r3, #32
3419fde8:	443b      	add	r3, r7
3419fdea:	f853 3c10 	ldr.w	r3, [r3, #-16]
3419fdee:	b2da      	uxtb	r2, r3
3419fdf0:	687b      	ldr	r3, [r7, #4]
3419fdf2:	701a      	strb	r2, [r3, #0]
    if (ext_clock / *pll_prediv < 12 * M_HZ)
3419fdf4:	687b      	ldr	r3, [r7, #4]
3419fdf6:	781b      	ldrb	r3, [r3, #0]
3419fdf8:	461a      	mov	r2, r3
3419fdfa:	68bb      	ldr	r3, [r7, #8]
3419fdfc:	fbb3 f3f2 	udiv	r3, r3, r2
3419fe00:	4a1d      	ldr	r2, [pc, #116]	@ (3419fe78 <VD6G_ComputeClocks+0xd4>)
3419fe02:	4293      	cmp	r3, r2
3419fe04:	d306      	bcc.n	3419fe14 <VD6G_ComputeClocks+0x70>
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
3419fe06:	69fb      	ldr	r3, [r7, #28]
3419fe08:	3301      	adds	r3, #1
3419fe0a:	61fb      	str	r3, [r7, #28]
3419fe0c:	69fb      	ldr	r3, [r7, #28]
3419fe0e:	2b02      	cmp	r3, #2
3419fe10:	d9e7      	bls.n	3419fde2 <VD6G_ComputeClocks+0x3e>
3419fe12:	e000      	b.n	3419fe16 <VD6G_ComputeClocks+0x72>
      break;
3419fe14:	bf00      	nop
  }

  /* PLL output clock must be as close as possible to 804Mhz */
  *pll_mult = (VD6G_TARGET_PLL * *pll_prediv + ext_clock / 2) / ext_clock;
3419fe16:	687b      	ldr	r3, [r7, #4]
3419fe18:	781b      	ldrb	r3, [r3, #0]
3419fe1a:	461a      	mov	r2, r3
3419fe1c:	4b17      	ldr	r3, [pc, #92]	@ (3419fe7c <VD6G_ComputeClocks+0xd8>)
3419fe1e:	fb03 f202 	mul.w	r2, r3, r2
3419fe22:	68bb      	ldr	r3, [r7, #8]
3419fe24:	085b      	lsrs	r3, r3, #1
3419fe26:	441a      	add	r2, r3
3419fe28:	68bb      	ldr	r3, [r7, #8]
3419fe2a:	fbb2 f3f3 	udiv	r3, r2, r3
3419fe2e:	b2da      	uxtb	r2, r3
3419fe30:	683b      	ldr	r3, [r7, #0]
3419fe32:	701a      	strb	r2, [r3, #0]

  VD6G_dbg(ctx, 0, "Ext Clock = %d Hz\n", ext_clock);
3419fe34:	68bb      	ldr	r3, [r7, #8]
3419fe36:	4a12      	ldr	r2, [pc, #72]	@ (3419fe80 <VD6G_ComputeClocks+0xdc>)
3419fe38:	2100      	movs	r1, #0
3419fe3a:	68f8      	ldr	r0, [r7, #12]
3419fe3c:	f7ff f93c 	bl	3419f0b8 <VD6G_dbg>
  VD6G_dbg(ctx, 0, "PLL prediv = %d\n", *pll_prediv);
3419fe40:	687b      	ldr	r3, [r7, #4]
3419fe42:	781b      	ldrb	r3, [r3, #0]
3419fe44:	4a0f      	ldr	r2, [pc, #60]	@ (3419fe84 <VD6G_ComputeClocks+0xe0>)
3419fe46:	2100      	movs	r1, #0
3419fe48:	68f8      	ldr	r0, [r7, #12]
3419fe4a:	f7ff f935 	bl	3419f0b8 <VD6G_dbg>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
3419fe4e:	683b      	ldr	r3, [r7, #0]
3419fe50:	781b      	ldrb	r3, [r3, #0]
3419fe52:	4a0d      	ldr	r2, [pc, #52]	@ (3419fe88 <VD6G_ComputeClocks+0xe4>)
3419fe54:	2100      	movs	r1, #0
3419fe56:	68f8      	ldr	r0, [r7, #12]
3419fe58:	f7ff f92e 	bl	3419f0b8 <VD6G_dbg>

  return 0;
3419fe5c:	2300      	movs	r3, #0
}
3419fe5e:	4618      	mov	r0, r3
3419fe60:	3720      	adds	r7, #32
3419fe62:	46bd      	mov	sp, r7
3419fe64:	bd80      	pop	{r7, pc}
3419fe66:	bf00      	nop
3419fe68:	341a6674 	.word	0x341a6674
3419fe6c:	005b8d7f 	.word	0x005b8d7f
3419fe70:	019bfcc0 	.word	0x019bfcc0
3419fe74:	341a661c 	.word	0x341a661c
3419fe78:	00b71b00 	.word	0x00b71b00
3419fe7c:	2fec1100 	.word	0x2fec1100
3419fe80:	341a663c 	.word	0x341a663c
3419fe84:	341a6650 	.word	0x341a6650
3419fe88:	341a6664 	.word	0x341a6664

3419fe8c <VD6G_SetupClocks>:

static int VD6G_SetupClocks(VD6G_Ctx_t *ctx)
{
3419fe8c:	b580      	push	{r7, lr}
3419fe8e:	b088      	sub	sp, #32
3419fe90:	af02      	add	r7, sp, #8
3419fe92:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
3419fe94:	687b      	ldr	r3, [r7, #4]
3419fe96:	332c      	adds	r3, #44	@ 0x2c
3419fe98:	617b      	str	r3, [r7, #20]
  uint8_t pll_prediv;
  uint8_t pll_mult;
  int ret;

  ret = VD6G_ComputeClocks(ctx, drv_ctx->config_save.ext_clock_freq_in_hz, &pll_prediv, &pll_mult);
3419fe9a:	697b      	ldr	r3, [r7, #20]
3419fe9c:	685b      	ldr	r3, [r3, #4]
3419fe9e:	4619      	mov	r1, r3
3419fea0:	f107 030e 	add.w	r3, r7, #14
3419fea4:	f107 020f 	add.w	r2, r7, #15
3419fea8:	6878      	ldr	r0, [r7, #4]
3419feaa:	f7ff ff7b 	bl	3419fda4 <VD6G_ComputeClocks>
3419feae:	6138      	str	r0, [r7, #16]
  if (ret)
3419feb0:	693b      	ldr	r3, [r7, #16]
3419feb2:	2b00      	cmp	r3, #0
3419feb4:	d001      	beq.n	3419feba <VD6G_SetupClocks+0x2e>
    return ret;
3419feb6:	693b      	ldr	r3, [r7, #16]
3419feb8:	e083      	b.n	3419ffc2 <VD6G_SetupClocks+0x136>

  ret = ctx->write32(ctx, VD6G_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
3419feba:	687b      	ldr	r3, [r7, #4]
3419febc:	699b      	ldr	r3, [r3, #24]
3419febe:	697a      	ldr	r2, [r7, #20]
3419fec0:	6852      	ldr	r2, [r2, #4]
3419fec2:	f44f 7108 	mov.w	r1, #544	@ 0x220
3419fec6:	6878      	ldr	r0, [r7, #4]
3419fec8:	4798      	blx	r3
3419feca:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419fecc:	693b      	ldr	r3, [r7, #16]
3419fece:	2b00      	cmp	r3, #0
3419fed0:	d008      	beq.n	3419fee4 <VD6G_SetupClocks+0x58>
3419fed2:	693b      	ldr	r3, [r7, #16]
3419fed4:	9300      	str	r3, [sp, #0]
3419fed6:	f44f 7331 	mov.w	r3, #708	@ 0x2c4
3419feda:	4a3c      	ldr	r2, [pc, #240]	@ (3419ffcc <VD6G_SetupClocks+0x140>)
3419fedc:	493c      	ldr	r1, [pc, #240]	@ (3419ffd0 <VD6G_SetupClocks+0x144>)
3419fede:	6878      	ldr	r0, [r7, #4]
3419fee0:	f7ff f93d 	bl	3419f15e <VD6G_error>
3419fee4:	693b      	ldr	r3, [r7, #16]
3419fee6:	2b00      	cmp	r3, #0
3419fee8:	d002      	beq.n	3419fef0 <VD6G_SetupClocks+0x64>
3419feea:	6878      	ldr	r0, [r7, #4]
3419feec:	f7ff f952 	bl	3419f194 <display_error>
3419fef0:	693b      	ldr	r3, [r7, #16]
3419fef2:	2b00      	cmp	r3, #0
3419fef4:	d001      	beq.n	3419fefa <VD6G_SetupClocks+0x6e>
3419fef6:	693b      	ldr	r3, [r7, #16]
3419fef8:	e063      	b.n	3419ffc2 <VD6G_SetupClocks+0x136>

  ret = ctx->write8(ctx, VD6G_REG_CLK_PLL_PREDIV, pll_prediv);
3419fefa:	687b      	ldr	r3, [r7, #4]
3419fefc:	691b      	ldr	r3, [r3, #16]
3419fefe:	7bfa      	ldrb	r2, [r7, #15]
3419ff00:	f44f 7109 	mov.w	r1, #548	@ 0x224
3419ff04:	6878      	ldr	r0, [r7, #4]
3419ff06:	4798      	blx	r3
3419ff08:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419ff0a:	693b      	ldr	r3, [r7, #16]
3419ff0c:	2b00      	cmp	r3, #0
3419ff0e:	d008      	beq.n	3419ff22 <VD6G_SetupClocks+0x96>
3419ff10:	693b      	ldr	r3, [r7, #16]
3419ff12:	9300      	str	r3, [sp, #0]
3419ff14:	f240 23c7 	movw	r3, #711	@ 0x2c7
3419ff18:	4a2c      	ldr	r2, [pc, #176]	@ (3419ffcc <VD6G_SetupClocks+0x140>)
3419ff1a:	492d      	ldr	r1, [pc, #180]	@ (3419ffd0 <VD6G_SetupClocks+0x144>)
3419ff1c:	6878      	ldr	r0, [r7, #4]
3419ff1e:	f7ff f91e 	bl	3419f15e <VD6G_error>
3419ff22:	693b      	ldr	r3, [r7, #16]
3419ff24:	2b00      	cmp	r3, #0
3419ff26:	d002      	beq.n	3419ff2e <VD6G_SetupClocks+0xa2>
3419ff28:	6878      	ldr	r0, [r7, #4]
3419ff2a:	f7ff f933 	bl	3419f194 <display_error>
3419ff2e:	693b      	ldr	r3, [r7, #16]
3419ff30:	2b00      	cmp	r3, #0
3419ff32:	d001      	beq.n	3419ff38 <VD6G_SetupClocks+0xac>
3419ff34:	693b      	ldr	r3, [r7, #16]
3419ff36:	e044      	b.n	3419ffc2 <VD6G_SetupClocks+0x136>

  ret = ctx->write8(ctx, VD6G_REG_CLK_SYS_PLL_MULT, pll_mult);
3419ff38:	687b      	ldr	r3, [r7, #4]
3419ff3a:	691b      	ldr	r3, [r3, #16]
3419ff3c:	7bba      	ldrb	r2, [r7, #14]
3419ff3e:	f240 2126 	movw	r1, #550	@ 0x226
3419ff42:	6878      	ldr	r0, [r7, #4]
3419ff44:	4798      	blx	r3
3419ff46:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
3419ff48:	693b      	ldr	r3, [r7, #16]
3419ff4a:	2b00      	cmp	r3, #0
3419ff4c:	d008      	beq.n	3419ff60 <VD6G_SetupClocks+0xd4>
3419ff4e:	693b      	ldr	r3, [r7, #16]
3419ff50:	9300      	str	r3, [sp, #0]
3419ff52:	f240 23ca 	movw	r3, #714	@ 0x2ca
3419ff56:	4a1d      	ldr	r2, [pc, #116]	@ (3419ffcc <VD6G_SetupClocks+0x140>)
3419ff58:	491d      	ldr	r1, [pc, #116]	@ (3419ffd0 <VD6G_SetupClocks+0x144>)
3419ff5a:	6878      	ldr	r0, [r7, #4]
3419ff5c:	f7ff f8ff 	bl	3419f15e <VD6G_error>
3419ff60:	693b      	ldr	r3, [r7, #16]
3419ff62:	2b00      	cmp	r3, #0
3419ff64:	d002      	beq.n	3419ff6c <VD6G_SetupClocks+0xe0>
3419ff66:	6878      	ldr	r0, [r7, #4]
3419ff68:	f7ff f914 	bl	3419f194 <display_error>
3419ff6c:	693b      	ldr	r3, [r7, #16]
3419ff6e:	2b00      	cmp	r3, #0
3419ff70:	d001      	beq.n	3419ff76 <VD6G_SetupClocks+0xea>
3419ff72:	693b      	ldr	r3, [r7, #16]
3419ff74:	e025      	b.n	3419ffc2 <VD6G_SetupClocks+0x136>

  if (drv_ctx->config_save.line_len) {
3419ff76:	697b      	ldr	r3, [r7, #20]
3419ff78:	695b      	ldr	r3, [r3, #20]
3419ff7a:	2b00      	cmp	r3, #0
3419ff7c:	d020      	beq.n	3419ffc0 <VD6G_SetupClocks+0x134>
    ret = ctx->write16(ctx, VD6G_LINE_LENGTH, drv_ctx->config_save.line_len);
3419ff7e:	687b      	ldr	r3, [r7, #4]
3419ff80:	695b      	ldr	r3, [r3, #20]
3419ff82:	697a      	ldr	r2, [r7, #20]
3419ff84:	6952      	ldr	r2, [r2, #20]
3419ff86:	b292      	uxth	r2, r2
3419ff88:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419ff8c:	6878      	ldr	r0, [r7, #4]
3419ff8e:	4798      	blx	r3
3419ff90:	6138      	str	r0, [r7, #16]
    VD6G_TraceError(ctx, ret);
3419ff92:	693b      	ldr	r3, [r7, #16]
3419ff94:	2b00      	cmp	r3, #0
3419ff96:	d008      	beq.n	3419ffaa <VD6G_SetupClocks+0x11e>
3419ff98:	693b      	ldr	r3, [r7, #16]
3419ff9a:	9300      	str	r3, [sp, #0]
3419ff9c:	f240 23ce 	movw	r3, #718	@ 0x2ce
3419ffa0:	4a0a      	ldr	r2, [pc, #40]	@ (3419ffcc <VD6G_SetupClocks+0x140>)
3419ffa2:	490b      	ldr	r1, [pc, #44]	@ (3419ffd0 <VD6G_SetupClocks+0x144>)
3419ffa4:	6878      	ldr	r0, [r7, #4]
3419ffa6:	f7ff f8da 	bl	3419f15e <VD6G_error>
3419ffaa:	693b      	ldr	r3, [r7, #16]
3419ffac:	2b00      	cmp	r3, #0
3419ffae:	d002      	beq.n	3419ffb6 <VD6G_SetupClocks+0x12a>
3419ffb0:	6878      	ldr	r0, [r7, #4]
3419ffb2:	f7ff f8ef 	bl	3419f194 <display_error>
3419ffb6:	693b      	ldr	r3, [r7, #16]
3419ffb8:	2b00      	cmp	r3, #0
3419ffba:	d001      	beq.n	3419ffc0 <VD6G_SetupClocks+0x134>
3419ffbc:	693b      	ldr	r3, [r7, #16]
3419ffbe:	e000      	b.n	3419ffc2 <VD6G_SetupClocks+0x136>
  }

  return 0;
3419ffc0:	2300      	movs	r3, #0
}
3419ffc2:	4618      	mov	r0, r3
3419ffc4:	3718      	adds	r7, #24
3419ffc6:	46bd      	mov	sp, r7
3419ffc8:	bd80      	pop	{r7, pc}
3419ffca:	bf00      	nop
3419ffcc:	341b7520 	.word	0x341b7520
3419ffd0:	341a6494 	.word	0x341a6494

3419ffd4 <VD6G_SetupOutput>:

static int VD6G_SetupOutput(VD6G_Ctx_t *ctx)
{
3419ffd4:	b580      	push	{r7, lr}
3419ffd6:	b088      	sub	sp, #32
3419ffd8:	af02      	add	r7, sp, #8
3419ffda:	6078      	str	r0, [r7, #4]
  VD6G_OutItf_Config_t *out_itf = &ctx->ctx.config_save.out_itf;
3419ffdc:	687b      	ldr	r3, [r7, #4]
3419ffde:	3348      	adds	r3, #72	@ 0x48
3419ffe0:	617b      	str	r3, [r7, #20]
  uint16_t oif_ctrl;
  int ret;

  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
3419ffe2:	697b      	ldr	r3, [r7, #20]
3419ffe4:	681b      	ldr	r3, [r3, #0]
3419ffe6:	2b01      	cmp	r3, #1
3419ffe8:	d006      	beq.n	3419fff8 <VD6G_SetupOutput+0x24>
3419ffea:	697b      	ldr	r3, [r7, #20]
3419ffec:	681b      	ldr	r3, [r3, #0]
3419ffee:	2b02      	cmp	r3, #2
3419fff0:	d002      	beq.n	3419fff8 <VD6G_SetupOutput+0x24>
    return -1;
3419fff2:	f04f 33ff 	mov.w	r3, #4294967295
3419fff6:	e0ce      	b.n	341a0196 <VD6G_SetupOutput+0x1c2>
  /* Be sure we got value 0 or 1 */
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
3419fff8:	697b      	ldr	r3, [r7, #20]
3419fffa:	685b      	ldr	r3, [r3, #4]
3419fffc:	2b00      	cmp	r3, #0
3419fffe:	bf14      	ite	ne
341a0000:	2301      	movne	r3, #1
341a0002:	2300      	moveq	r3, #0
341a0004:	b2db      	uxtb	r3, r3
341a0006:	461a      	mov	r2, r3
341a0008:	697b      	ldr	r3, [r7, #20]
341a000a:	605a      	str	r2, [r3, #4]
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
341a000c:	697b      	ldr	r3, [r7, #20]
341a000e:	689b      	ldr	r3, [r3, #8]
341a0010:	2b00      	cmp	r3, #0
341a0012:	bf14      	ite	ne
341a0014:	2301      	movne	r3, #1
341a0016:	2300      	moveq	r3, #0
341a0018:	b2db      	uxtb	r3, r3
341a001a:	461a      	mov	r2, r3
341a001c:	697b      	ldr	r3, [r7, #20]
341a001e:	609a      	str	r2, [r3, #8]
  out_itf->data_lane1_swap_enable = !!out_itf->data_lane1_swap_enable;
341a0020:	697b      	ldr	r3, [r7, #20]
341a0022:	68db      	ldr	r3, [r3, #12]
341a0024:	2b00      	cmp	r3, #0
341a0026:	bf14      	ite	ne
341a0028:	2301      	movne	r3, #1
341a002a:	2300      	moveq	r3, #0
341a002c:	b2db      	uxtb	r3, r3
341a002e:	461a      	mov	r2, r3
341a0030:	697b      	ldr	r3, [r7, #20]
341a0032:	60da      	str	r2, [r3, #12]
  out_itf->data_lanes_mapping_swap_enable = !!out_itf->data_lanes_mapping_swap_enable;
341a0034:	697b      	ldr	r3, [r7, #20]
341a0036:	691b      	ldr	r3, [r3, #16]
341a0038:	2b00      	cmp	r3, #0
341a003a:	bf14      	ite	ne
341a003c:	2301      	movne	r3, #1
341a003e:	2300      	moveq	r3, #0
341a0040:	b2db      	uxtb	r3, r3
341a0042:	461a      	mov	r2, r3
341a0044:	697b      	ldr	r3, [r7, #20]
341a0046:	611a      	str	r2, [r3, #16]

  /* raw8 */
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
341a0048:	687b      	ldr	r3, [r7, #4]
341a004a:	691b      	ldr	r3, [r3, #16]
341a004c:	2208      	movs	r2, #8
341a004e:	f240 310a 	movw	r1, #778	@ 0x30a
341a0052:	6878      	ldr	r0, [r7, #4]
341a0054:	4798      	blx	r3
341a0056:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0058:	693b      	ldr	r3, [r7, #16]
341a005a:	2b00      	cmp	r3, #0
341a005c:	d008      	beq.n	341a0070 <VD6G_SetupOutput+0x9c>
341a005e:	693b      	ldr	r3, [r7, #16]
341a0060:	9300      	str	r3, [sp, #0]
341a0062:	f44f 7339 	mov.w	r3, #740	@ 0x2e4
341a0066:	4a4e      	ldr	r2, [pc, #312]	@ (341a01a0 <VD6G_SetupOutput+0x1cc>)
341a0068:	494e      	ldr	r1, [pc, #312]	@ (341a01a4 <VD6G_SetupOutput+0x1d0>)
341a006a:	6878      	ldr	r0, [r7, #4]
341a006c:	f7ff f877 	bl	3419f15e <VD6G_error>
341a0070:	693b      	ldr	r3, [r7, #16]
341a0072:	2b00      	cmp	r3, #0
341a0074:	d002      	beq.n	341a007c <VD6G_SetupOutput+0xa8>
341a0076:	6878      	ldr	r0, [r7, #4]
341a0078:	f7ff f88c 	bl	3419f194 <display_error>
341a007c:	693b      	ldr	r3, [r7, #16]
341a007e:	2b00      	cmp	r3, #0
341a0080:	d001      	beq.n	341a0086 <VD6G_SetupOutput+0xb2>
341a0082:	693b      	ldr	r3, [r7, #16]
341a0084:	e087      	b.n	341a0196 <VD6G_SetupOutput+0x1c2>

  /* csi lanes */
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a0086:	697b      	ldr	r3, [r7, #20]
341a0088:	68db      	ldr	r3, [r3, #12]
341a008a:	b21b      	sxth	r3, r3
341a008c:	025b      	lsls	r3, r3, #9
341a008e:	b21b      	sxth	r3, r3
             !out_itf->data_lanes_mapping_swap_enable << 7 |
341a0090:	697a      	ldr	r2, [r7, #20]
341a0092:	6912      	ldr	r2, [r2, #16]
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a0094:	2a00      	cmp	r2, #0
341a0096:	d101      	bne.n	341a009c <VD6G_SetupOutput+0xc8>
341a0098:	2280      	movs	r2, #128	@ 0x80
341a009a:	e000      	b.n	341a009e <VD6G_SetupOutput+0xca>
341a009c:	2200      	movs	r2, #0
341a009e:	4313      	orrs	r3, r2
341a00a0:	b21a      	sxth	r2, r3
             out_itf->data_lane0_swap_enable << 6 |
341a00a2:	697b      	ldr	r3, [r7, #20]
341a00a4:	689b      	ldr	r3, [r3, #8]
             !out_itf->data_lanes_mapping_swap_enable << 7 |
341a00a6:	b21b      	sxth	r3, r3
341a00a8:	019b      	lsls	r3, r3, #6
341a00aa:	b21b      	sxth	r3, r3
341a00ac:	4313      	orrs	r3, r2
341a00ae:	b21a      	sxth	r2, r3
             out_itf->data_lanes_mapping_swap_enable << 4 |
341a00b0:	697b      	ldr	r3, [r7, #20]
341a00b2:	691b      	ldr	r3, [r3, #16]
             out_itf->data_lane0_swap_enable << 6 |
341a00b4:	b21b      	sxth	r3, r3
341a00b6:	011b      	lsls	r3, r3, #4
341a00b8:	b21b      	sxth	r3, r3
341a00ba:	4313      	orrs	r3, r2
341a00bc:	b21a      	sxth	r2, r3
             out_itf->clock_lane_swap_enable << 3 |
341a00be:	697b      	ldr	r3, [r7, #20]
341a00c0:	685b      	ldr	r3, [r3, #4]
             out_itf->data_lanes_mapping_swap_enable << 4 |
341a00c2:	b21b      	sxth	r3, r3
341a00c4:	00db      	lsls	r3, r3, #3
341a00c6:	b21b      	sxth	r3, r3
341a00c8:	4313      	orrs	r3, r2
341a00ca:	b21a      	sxth	r2, r3
             out_itf->datalane_nb << 0;
341a00cc:	697b      	ldr	r3, [r7, #20]
341a00ce:	681b      	ldr	r3, [r3, #0]
             out_itf->clock_lane_swap_enable << 3 |
341a00d0:	b21b      	sxth	r3, r3
341a00d2:	4313      	orrs	r3, r2
341a00d4:	b21b      	sxth	r3, r3
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a00d6:	81fb      	strh	r3, [r7, #14]
  ret = ctx->write16(ctx, VD6G_REG_OIF_CTRL, oif_ctrl);
341a00d8:	687b      	ldr	r3, [r7, #4]
341a00da:	695b      	ldr	r3, [r3, #20]
341a00dc:	89fa      	ldrh	r2, [r7, #14]
341a00de:	f44f 7143 	mov.w	r1, #780	@ 0x30c
341a00e2:	6878      	ldr	r0, [r7, #4]
341a00e4:	4798      	blx	r3
341a00e6:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a00e8:	693b      	ldr	r3, [r7, #16]
341a00ea:	2b00      	cmp	r3, #0
341a00ec:	d008      	beq.n	341a0100 <VD6G_SetupOutput+0x12c>
341a00ee:	693b      	ldr	r3, [r7, #16]
341a00f0:	9300      	str	r3, [sp, #0]
341a00f2:	f240 23ee 	movw	r3, #750	@ 0x2ee
341a00f6:	4a2a      	ldr	r2, [pc, #168]	@ (341a01a0 <VD6G_SetupOutput+0x1cc>)
341a00f8:	492a      	ldr	r1, [pc, #168]	@ (341a01a4 <VD6G_SetupOutput+0x1d0>)
341a00fa:	6878      	ldr	r0, [r7, #4]
341a00fc:	f7ff f82f 	bl	3419f15e <VD6G_error>
341a0100:	693b      	ldr	r3, [r7, #16]
341a0102:	2b00      	cmp	r3, #0
341a0104:	d002      	beq.n	341a010c <VD6G_SetupOutput+0x138>
341a0106:	6878      	ldr	r0, [r7, #4]
341a0108:	f7ff f844 	bl	3419f194 <display_error>
341a010c:	693b      	ldr	r3, [r7, #16]
341a010e:	2b00      	cmp	r3, #0
341a0110:	d001      	beq.n	341a0116 <VD6G_SetupOutput+0x142>
341a0112:	693b      	ldr	r3, [r7, #16]
341a0114:	e03f      	b.n	341a0196 <VD6G_SetupOutput+0x1c2>

  /* csi speed */
  ret = ctx->write16(ctx, VD6G_REG_OIF_CSI_BITRATE, 804);
341a0116:	687b      	ldr	r3, [r7, #4]
341a0118:	695b      	ldr	r3, [r3, #20]
341a011a:	f44f 7249 	mov.w	r2, #804	@ 0x324
341a011e:	f240 3112 	movw	r1, #786	@ 0x312
341a0122:	6878      	ldr	r0, [r7, #4]
341a0124:	4798      	blx	r3
341a0126:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0128:	693b      	ldr	r3, [r7, #16]
341a012a:	2b00      	cmp	r3, #0
341a012c:	d008      	beq.n	341a0140 <VD6G_SetupOutput+0x16c>
341a012e:	693b      	ldr	r3, [r7, #16]
341a0130:	9300      	str	r3, [sp, #0]
341a0132:	f240 23f2 	movw	r3, #754	@ 0x2f2
341a0136:	4a1a      	ldr	r2, [pc, #104]	@ (341a01a0 <VD6G_SetupOutput+0x1cc>)
341a0138:	491a      	ldr	r1, [pc, #104]	@ (341a01a4 <VD6G_SetupOutput+0x1d0>)
341a013a:	6878      	ldr	r0, [r7, #4]
341a013c:	f7ff f80f 	bl	3419f15e <VD6G_error>
341a0140:	693b      	ldr	r3, [r7, #16]
341a0142:	2b00      	cmp	r3, #0
341a0144:	d002      	beq.n	341a014c <VD6G_SetupOutput+0x178>
341a0146:	6878      	ldr	r0, [r7, #4]
341a0148:	f7ff f824 	bl	3419f194 <display_error>
341a014c:	693b      	ldr	r3, [r7, #16]
341a014e:	2b00      	cmp	r3, #0
341a0150:	d001      	beq.n	341a0156 <VD6G_SetupOutput+0x182>
341a0152:	693b      	ldr	r3, [r7, #16]
341a0154:	e01f      	b.n	341a0196 <VD6G_SetupOutput+0x1c2>

  /* data type */
  ret = ctx->write8(ctx, VD6G_REG_OIF_IMG_CTRL, 0x2a);
341a0156:	687b      	ldr	r3, [r7, #4]
341a0158:	691b      	ldr	r3, [r3, #16]
341a015a:	222a      	movs	r2, #42	@ 0x2a
341a015c:	f240 310f 	movw	r1, #783	@ 0x30f
341a0160:	6878      	ldr	r0, [r7, #4]
341a0162:	4798      	blx	r3
341a0164:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0166:	693b      	ldr	r3, [r7, #16]
341a0168:	2b00      	cmp	r3, #0
341a016a:	d008      	beq.n	341a017e <VD6G_SetupOutput+0x1aa>
341a016c:	693b      	ldr	r3, [r7, #16]
341a016e:	9300      	str	r3, [sp, #0]
341a0170:	f240 23f6 	movw	r3, #758	@ 0x2f6
341a0174:	4a0a      	ldr	r2, [pc, #40]	@ (341a01a0 <VD6G_SetupOutput+0x1cc>)
341a0176:	490b      	ldr	r1, [pc, #44]	@ (341a01a4 <VD6G_SetupOutput+0x1d0>)
341a0178:	6878      	ldr	r0, [r7, #4]
341a017a:	f7fe fff0 	bl	3419f15e <VD6G_error>
341a017e:	693b      	ldr	r3, [r7, #16]
341a0180:	2b00      	cmp	r3, #0
341a0182:	d002      	beq.n	341a018a <VD6G_SetupOutput+0x1b6>
341a0184:	6878      	ldr	r0, [r7, #4]
341a0186:	f7ff f805 	bl	3419f194 <display_error>
341a018a:	693b      	ldr	r3, [r7, #16]
341a018c:	2b00      	cmp	r3, #0
341a018e:	d001      	beq.n	341a0194 <VD6G_SetupOutput+0x1c0>
341a0190:	693b      	ldr	r3, [r7, #16]
341a0192:	e000      	b.n	341a0196 <VD6G_SetupOutput+0x1c2>

  return 0;
341a0194:	2300      	movs	r3, #0
}
341a0196:	4618      	mov	r0, r3
341a0198:	3718      	adds	r7, #24
341a019a:	46bd      	mov	sp, r7
341a019c:	bd80      	pop	{r7, pc}
341a019e:	bf00      	nop
341a01a0:	341b7534 	.word	0x341b7534
341a01a4:	341a6494 	.word	0x341a6494

341a01a8 <VD6G_Resolution2Mode>:

static const struct vdg_mode *VD6G_Resolution2Mode(VD6G_Res_t resolution)
{
341a01a8:	b480      	push	{r7}
341a01aa:	b083      	sub	sp, #12
341a01ac:	af00      	add	r7, sp, #0
341a01ae:	4603      	mov	r3, r0
341a01b0:	71fb      	strb	r3, [r7, #7]
  switch (resolution) {
341a01b2:	79fb      	ldrb	r3, [r7, #7]
341a01b4:	2b08      	cmp	r3, #8
341a01b6:	d827      	bhi.n	341a0208 <VD6G_Resolution2Mode+0x60>
341a01b8:	a201      	add	r2, pc, #4	@ (adr r2, 341a01c0 <VD6G_Resolution2Mode+0x18>)
341a01ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a01be:	bf00      	nop
341a01c0:	341a01e5 	.word	0x341a01e5
341a01c4:	341a01e9 	.word	0x341a01e9
341a01c8:	341a01ed 	.word	0x341a01ed
341a01cc:	341a01f1 	.word	0x341a01f1
341a01d0:	341a01f5 	.word	0x341a01f5
341a01d4:	341a01f9 	.word	0x341a01f9
341a01d8:	341a01fd 	.word	0x341a01fd
341a01dc:	341a0201 	.word	0x341a0201
341a01e0:	341a0205 	.word	0x341a0205
  case VD6G_RES_QVGA_320_240:
    return &vdg_supported_modes[7];
341a01e4:	4b0c      	ldr	r3, [pc, #48]	@ (341a0218 <VD6G_Resolution2Mode+0x70>)
341a01e6:	e010      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_VGA_640_480:
    return &vdg_supported_modes[5];
341a01e8:	4b0c      	ldr	r3, [pc, #48]	@ (341a021c <VD6G_Resolution2Mode+0x74>)
341a01ea:	e00e      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_VGA_PORTRAIT_480_640:
    return &vdg_supported_modes[6];
341a01ec:	4b0c      	ldr	r3, [pc, #48]	@ (341a0220 <VD6G_Resolution2Mode+0x78>)
341a01ee:	e00c      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_XGA_1024_768:
    return &vdg_supported_modes[2];
341a01f0:	4b0c      	ldr	r3, [pc, #48]	@ (341a0224 <VD6G_Resolution2Mode+0x7c>)
341a01f2:	e00a      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_XGA_PORTRAIT_768_1024:
    return &vdg_supported_modes[3];
341a01f4:	4b0c      	ldr	r3, [pc, #48]	@ (341a0228 <VD6G_Resolution2Mode+0x80>)
341a01f6:	e008      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_720P_PORTRAIT_720_1280:
    return &vdg_supported_modes[4];
341a01f8:	4b0c      	ldr	r3, [pc, #48]	@ (341a022c <VD6G_Resolution2Mode+0x84>)
341a01fa:	e006      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_SXGA_PORTRAIT_1024_1280:
    return &vdg_supported_modes[1];
341a01fc:	4b0c      	ldr	r3, [pc, #48]	@ (341a0230 <VD6G_Resolution2Mode+0x88>)
341a01fe:	e004      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_PORTRAIT_1120_720:
    return &vdg_supported_modes[8];
341a0200:	4b0c      	ldr	r3, [pc, #48]	@ (341a0234 <VD6G_Resolution2Mode+0x8c>)
341a0202:	e002      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_FULL_1120_1364:
    return &vdg_supported_modes[0];
341a0204:	4b0c      	ldr	r3, [pc, #48]	@ (341a0238 <VD6G_Resolution2Mode+0x90>)
341a0206:	e000      	b.n	341a020a <VD6G_Resolution2Mode+0x62>
    break;
  default:
    return NULL;
341a0208:	2300      	movs	r3, #0
  }
}
341a020a:	4618      	mov	r0, r3
341a020c:	370c      	adds	r7, #12
341a020e:	46bd      	mov	sp, r7
341a0210:	f85d 7b04 	ldr.w	r7, [sp], #4
341a0214:	4770      	bx	lr
341a0216:	bf00      	nop
341a0218:	341b73e4 	.word	0x341b73e4
341a021c:	341b73ac 	.word	0x341b73ac
341a0220:	341b73c8 	.word	0x341b73c8
341a0224:	341b7358 	.word	0x341b7358
341a0228:	341b7374 	.word	0x341b7374
341a022c:	341b7390 	.word	0x341b7390
341a0230:	341b733c 	.word	0x341b733c
341a0234:	341b7400 	.word	0x341b7400
341a0238:	341b7320 	.word	0x341b7320

341a023c <VD6G_SetupSize>:

static int VD6G_SetupSize(VD6G_Ctx_t *ctx)
{
341a023c:	b580      	push	{r7, lr}
341a023e:	b088      	sub	sp, #32
341a0240:	af02      	add	r7, sp, #8
341a0242:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0244:	687b      	ldr	r3, [r7, #4]
341a0246:	332c      	adds	r3, #44	@ 0x2c
341a0248:	617b      	str	r3, [r7, #20]
  const struct vdg_mode *mode;
  int ret;

  mode = VD6G_Resolution2Mode(drv_ctx->config_save.resolution);
341a024a:	697b      	ldr	r3, [r7, #20]
341a024c:	7a1b      	ldrb	r3, [r3, #8]
341a024e:	4618      	mov	r0, r3
341a0250:	f7ff ffaa 	bl	341a01a8 <VD6G_Resolution2Mode>
341a0254:	6138      	str	r0, [r7, #16]
  if (!mode)
341a0256:	693b      	ldr	r3, [r7, #16]
341a0258:	2b00      	cmp	r3, #0
341a025a:	d102      	bne.n	341a0262 <VD6G_SetupSize+0x26>
    return -1;
341a025c:	f04f 33ff 	mov.w	r3, #4294967295
341a0260:	e0b2      	b.n	341a03c8 <VD6G_SetupSize+0x18c>

  ret = ctx->write8(ctx, VD6G_REG_READOUT_CTRL, mode->bin_mode);
341a0262:	687b      	ldr	r3, [r7, #4]
341a0264:	691b      	ldr	r3, [r3, #16]
341a0266:	693a      	ldr	r2, [r7, #16]
341a0268:	7a12      	ldrb	r2, [r2, #8]
341a026a:	f240 417e 	movw	r1, #1150	@ 0x47e
341a026e:	6878      	ldr	r0, [r7, #4]
341a0270:	4798      	blx	r3
341a0272:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0274:	68fb      	ldr	r3, [r7, #12]
341a0276:	2b00      	cmp	r3, #0
341a0278:	d008      	beq.n	341a028c <VD6G_SetupSize+0x50>
341a027a:	68fb      	ldr	r3, [r7, #12]
341a027c:	9300      	str	r3, [sp, #0]
341a027e:	f240 3329 	movw	r3, #809	@ 0x329
341a0282:	4a53      	ldr	r2, [pc, #332]	@ (341a03d0 <VD6G_SetupSize+0x194>)
341a0284:	4953      	ldr	r1, [pc, #332]	@ (341a03d4 <VD6G_SetupSize+0x198>)
341a0286:	6878      	ldr	r0, [r7, #4]
341a0288:	f7fe ff69 	bl	3419f15e <VD6G_error>
341a028c:	68fb      	ldr	r3, [r7, #12]
341a028e:	2b00      	cmp	r3, #0
341a0290:	d002      	beq.n	341a0298 <VD6G_SetupSize+0x5c>
341a0292:	6878      	ldr	r0, [r7, #4]
341a0294:	f7fe ff7e 	bl	3419f194 <display_error>
341a0298:	68fb      	ldr	r3, [r7, #12]
341a029a:	2b00      	cmp	r3, #0
341a029c:	d001      	beq.n	341a02a2 <VD6G_SetupSize+0x66>
341a029e:	68fb      	ldr	r3, [r7, #12]
341a02a0:	e092      	b.n	341a03c8 <VD6G_SetupSize+0x18c>

  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_START, mode->crop.left);
341a02a2:	687b      	ldr	r3, [r7, #4]
341a02a4:	695b      	ldr	r3, [r3, #20]
341a02a6:	693a      	ldr	r2, [r7, #16]
341a02a8:	68d2      	ldr	r2, [r2, #12]
341a02aa:	b292      	uxth	r2, r2
341a02ac:	f240 415e 	movw	r1, #1118	@ 0x45e
341a02b0:	6878      	ldr	r0, [r7, #4]
341a02b2:	4798      	blx	r3
341a02b4:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a02b6:	68fb      	ldr	r3, [r7, #12]
341a02b8:	2b00      	cmp	r3, #0
341a02ba:	d008      	beq.n	341a02ce <VD6G_SetupSize+0x92>
341a02bc:	68fb      	ldr	r3, [r7, #12]
341a02be:	9300      	str	r3, [sp, #0]
341a02c0:	f44f 734b 	mov.w	r3, #812	@ 0x32c
341a02c4:	4a42      	ldr	r2, [pc, #264]	@ (341a03d0 <VD6G_SetupSize+0x194>)
341a02c6:	4943      	ldr	r1, [pc, #268]	@ (341a03d4 <VD6G_SetupSize+0x198>)
341a02c8:	6878      	ldr	r0, [r7, #4]
341a02ca:	f7fe ff48 	bl	3419f15e <VD6G_error>
341a02ce:	68fb      	ldr	r3, [r7, #12]
341a02d0:	2b00      	cmp	r3, #0
341a02d2:	d002      	beq.n	341a02da <VD6G_SetupSize+0x9e>
341a02d4:	6878      	ldr	r0, [r7, #4]
341a02d6:	f7fe ff5d 	bl	3419f194 <display_error>
341a02da:	68fb      	ldr	r3, [r7, #12]
341a02dc:	2b00      	cmp	r3, #0
341a02de:	d001      	beq.n	341a02e4 <VD6G_SetupSize+0xa8>
341a02e0:	68fb      	ldr	r3, [r7, #12]
341a02e2:	e071      	b.n	341a03c8 <VD6G_SetupSize+0x18c>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_END, mode->crop.left + mode->crop.width - 1);
341a02e4:	687b      	ldr	r3, [r7, #4]
341a02e6:	695b      	ldr	r3, [r3, #20]
341a02e8:	693a      	ldr	r2, [r7, #16]
341a02ea:	68d2      	ldr	r2, [r2, #12]
341a02ec:	b291      	uxth	r1, r2
341a02ee:	693a      	ldr	r2, [r7, #16]
341a02f0:	6952      	ldr	r2, [r2, #20]
341a02f2:	b292      	uxth	r2, r2
341a02f4:	440a      	add	r2, r1
341a02f6:	b292      	uxth	r2, r2
341a02f8:	3a01      	subs	r2, #1
341a02fa:	b292      	uxth	r2, r2
341a02fc:	f44f 618c 	mov.w	r1, #1120	@ 0x460
341a0300:	6878      	ldr	r0, [r7, #4]
341a0302:	4798      	blx	r3
341a0304:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0306:	68fb      	ldr	r3, [r7, #12]
341a0308:	2b00      	cmp	r3, #0
341a030a:	d008      	beq.n	341a031e <VD6G_SetupSize+0xe2>
341a030c:	68fb      	ldr	r3, [r7, #12]
341a030e:	9300      	str	r3, [sp, #0]
341a0310:	f240 332e 	movw	r3, #814	@ 0x32e
341a0314:	4a2e      	ldr	r2, [pc, #184]	@ (341a03d0 <VD6G_SetupSize+0x194>)
341a0316:	492f      	ldr	r1, [pc, #188]	@ (341a03d4 <VD6G_SetupSize+0x198>)
341a0318:	6878      	ldr	r0, [r7, #4]
341a031a:	f7fe ff20 	bl	3419f15e <VD6G_error>
341a031e:	68fb      	ldr	r3, [r7, #12]
341a0320:	2b00      	cmp	r3, #0
341a0322:	d002      	beq.n	341a032a <VD6G_SetupSize+0xee>
341a0324:	6878      	ldr	r0, [r7, #4]
341a0326:	f7fe ff35 	bl	3419f194 <display_error>
341a032a:	68fb      	ldr	r3, [r7, #12]
341a032c:	2b00      	cmp	r3, #0
341a032e:	d001      	beq.n	341a0334 <VD6G_SetupSize+0xf8>
341a0330:	68fb      	ldr	r3, [r7, #12]
341a0332:	e049      	b.n	341a03c8 <VD6G_SetupSize+0x18c>

  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_START, mode->crop.top);
341a0334:	687b      	ldr	r3, [r7, #4]
341a0336:	695b      	ldr	r3, [r3, #20]
341a0338:	693a      	ldr	r2, [r7, #16]
341a033a:	6912      	ldr	r2, [r2, #16]
341a033c:	b292      	uxth	r2, r2
341a033e:	f240 4162 	movw	r1, #1122	@ 0x462
341a0342:	6878      	ldr	r0, [r7, #4]
341a0344:	4798      	blx	r3
341a0346:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0348:	68fb      	ldr	r3, [r7, #12]
341a034a:	2b00      	cmp	r3, #0
341a034c:	d008      	beq.n	341a0360 <VD6G_SetupSize+0x124>
341a034e:	68fb      	ldr	r3, [r7, #12]
341a0350:	9300      	str	r3, [sp, #0]
341a0352:	f240 3331 	movw	r3, #817	@ 0x331
341a0356:	4a1e      	ldr	r2, [pc, #120]	@ (341a03d0 <VD6G_SetupSize+0x194>)
341a0358:	491e      	ldr	r1, [pc, #120]	@ (341a03d4 <VD6G_SetupSize+0x198>)
341a035a:	6878      	ldr	r0, [r7, #4]
341a035c:	f7fe feff 	bl	3419f15e <VD6G_error>
341a0360:	68fb      	ldr	r3, [r7, #12]
341a0362:	2b00      	cmp	r3, #0
341a0364:	d002      	beq.n	341a036c <VD6G_SetupSize+0x130>
341a0366:	6878      	ldr	r0, [r7, #4]
341a0368:	f7fe ff14 	bl	3419f194 <display_error>
341a036c:	68fb      	ldr	r3, [r7, #12]
341a036e:	2b00      	cmp	r3, #0
341a0370:	d001      	beq.n	341a0376 <VD6G_SetupSize+0x13a>
341a0372:	68fb      	ldr	r3, [r7, #12]
341a0374:	e028      	b.n	341a03c8 <VD6G_SetupSize+0x18c>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_END, mode->crop.top + mode->crop.height - 1);
341a0376:	687b      	ldr	r3, [r7, #4]
341a0378:	695b      	ldr	r3, [r3, #20]
341a037a:	693a      	ldr	r2, [r7, #16]
341a037c:	6912      	ldr	r2, [r2, #16]
341a037e:	b291      	uxth	r1, r2
341a0380:	693a      	ldr	r2, [r7, #16]
341a0382:	6992      	ldr	r2, [r2, #24]
341a0384:	b292      	uxth	r2, r2
341a0386:	440a      	add	r2, r1
341a0388:	b292      	uxth	r2, r2
341a038a:	3a01      	subs	r2, #1
341a038c:	b292      	uxth	r2, r2
341a038e:	f240 4164 	movw	r1, #1124	@ 0x464
341a0392:	6878      	ldr	r0, [r7, #4]
341a0394:	4798      	blx	r3
341a0396:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0398:	68fb      	ldr	r3, [r7, #12]
341a039a:	2b00      	cmp	r3, #0
341a039c:	d008      	beq.n	341a03b0 <VD6G_SetupSize+0x174>
341a039e:	68fb      	ldr	r3, [r7, #12]
341a03a0:	9300      	str	r3, [sp, #0]
341a03a2:	f240 3333 	movw	r3, #819	@ 0x333
341a03a6:	4a0a      	ldr	r2, [pc, #40]	@ (341a03d0 <VD6G_SetupSize+0x194>)
341a03a8:	490a      	ldr	r1, [pc, #40]	@ (341a03d4 <VD6G_SetupSize+0x198>)
341a03aa:	6878      	ldr	r0, [r7, #4]
341a03ac:	f7fe fed7 	bl	3419f15e <VD6G_error>
341a03b0:	68fb      	ldr	r3, [r7, #12]
341a03b2:	2b00      	cmp	r3, #0
341a03b4:	d002      	beq.n	341a03bc <VD6G_SetupSize+0x180>
341a03b6:	6878      	ldr	r0, [r7, #4]
341a03b8:	f7fe feec 	bl	3419f194 <display_error>
341a03bc:	68fb      	ldr	r3, [r7, #12]
341a03be:	2b00      	cmp	r3, #0
341a03c0:	d001      	beq.n	341a03c6 <VD6G_SetupSize+0x18a>
341a03c2:	68fb      	ldr	r3, [r7, #12]
341a03c4:	e000      	b.n	341a03c8 <VD6G_SetupSize+0x18c>

  return 0;
341a03c6:	2300      	movs	r3, #0
}
341a03c8:	4618      	mov	r0, r3
341a03ca:	3718      	adds	r7, #24
341a03cc:	46bd      	mov	sp, r7
341a03ce:	bd80      	pop	{r7, pc}
341a03d0:	341b7548 	.word	0x341b7548
341a03d4:	341a6494 	.word	0x341a6494

341a03d8 <VD6G_SetupFrameRate>:

static int VD6G_SetupFrameRate(VD6G_Ctx_t *ctx)
{
341a03d8:	b580      	push	{r7, lr}
341a03da:	b088      	sub	sp, #32
341a03dc:	af02      	add	r7, sp, #8
341a03de:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a03e0:	687b      	ldr	r3, [r7, #4]
341a03e2:	332c      	adds	r3, #44	@ 0x2c
341a03e4:	617b      	str	r3, [r7, #20]
  uint16_t frame_length;
  uint16_t line_length;
  int ret;

  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_length);
341a03e6:	687b      	ldr	r3, [r7, #4]
341a03e8:	689b      	ldr	r3, [r3, #8]
341a03ea:	f107 020c 	add.w	r2, r7, #12
341a03ee:	f44f 7140 	mov.w	r1, #768	@ 0x300
341a03f2:	6878      	ldr	r0, [r7, #4]
341a03f4:	4798      	blx	r3
341a03f6:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a03f8:	693b      	ldr	r3, [r7, #16]
341a03fa:	2b00      	cmp	r3, #0
341a03fc:	d008      	beq.n	341a0410 <VD6G_SetupFrameRate+0x38>
341a03fe:	693b      	ldr	r3, [r7, #16]
341a0400:	9300      	str	r3, [sp, #0]
341a0402:	f44f 7350 	mov.w	r3, #832	@ 0x340
341a0406:	4a27      	ldr	r2, [pc, #156]	@ (341a04a4 <VD6G_SetupFrameRate+0xcc>)
341a0408:	4927      	ldr	r1, [pc, #156]	@ (341a04a8 <VD6G_SetupFrameRate+0xd0>)
341a040a:	6878      	ldr	r0, [r7, #4]
341a040c:	f7fe fea7 	bl	3419f15e <VD6G_error>
341a0410:	693b      	ldr	r3, [r7, #16]
341a0412:	2b00      	cmp	r3, #0
341a0414:	d002      	beq.n	341a041c <VD6G_SetupFrameRate+0x44>
341a0416:	6878      	ldr	r0, [r7, #4]
341a0418:	f7fe febc 	bl	3419f194 <display_error>
341a041c:	693b      	ldr	r3, [r7, #16]
341a041e:	2b00      	cmp	r3, #0
341a0420:	d001      	beq.n	341a0426 <VD6G_SetupFrameRate+0x4e>
341a0422:	693b      	ldr	r3, [r7, #16]
341a0424:	e039      	b.n	341a049a <VD6G_SetupFrameRate+0xc2>
  VD6G_dbg(ctx, 0, "Line len = %d\n", line_length);
341a0426:	89bb      	ldrh	r3, [r7, #12]
341a0428:	4a20      	ldr	r2, [pc, #128]	@ (341a04ac <VD6G_SetupFrameRate+0xd4>)
341a042a:	2100      	movs	r1, #0
341a042c:	6878      	ldr	r0, [r7, #4]
341a042e:	f7fe fe43 	bl	3419f0b8 <VD6G_dbg>

  frame_length = VD6G_PIXEL_CLOCK / (line_length * drv_ctx->config_save.frame_rate);
341a0432:	89bb      	ldrh	r3, [r7, #12]
341a0434:	461a      	mov	r2, r3
341a0436:	697b      	ldr	r3, [r7, #20]
341a0438:	68db      	ldr	r3, [r3, #12]
341a043a:	fb02 f303 	mul.w	r3, r2, r3
341a043e:	4a1c      	ldr	r2, [pc, #112]	@ (341a04b0 <VD6G_SetupFrameRate+0xd8>)
341a0440:	fb92 f3f3 	sdiv	r3, r2, r3
341a0444:	81fb      	strh	r3, [r7, #14]
  VD6G_dbg(ctx, 0, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
341a0446:	89fa      	ldrh	r2, [r7, #14]
341a0448:	697b      	ldr	r3, [r7, #20]
341a044a:	68db      	ldr	r3, [r3, #12]
341a044c:	9300      	str	r3, [sp, #0]
341a044e:	4613      	mov	r3, r2
341a0450:	4a18      	ldr	r2, [pc, #96]	@ (341a04b4 <VD6G_SetupFrameRate+0xdc>)
341a0452:	2100      	movs	r1, #0
341a0454:	6878      	ldr	r0, [r7, #4]
341a0456:	f7fe fe2f 	bl	3419f0b8 <VD6G_dbg>
  ret = ctx->write16(ctx, VD6G_FRAME_LENGTH, frame_length);
341a045a:	687b      	ldr	r3, [r7, #4]
341a045c:	695b      	ldr	r3, [r3, #20]
341a045e:	89fa      	ldrh	r2, [r7, #14]
341a0460:	f44f 618b 	mov.w	r1, #1112	@ 0x458
341a0464:	6878      	ldr	r0, [r7, #4]
341a0466:	4798      	blx	r3
341a0468:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a046a:	693b      	ldr	r3, [r7, #16]
341a046c:	2b00      	cmp	r3, #0
341a046e:	d008      	beq.n	341a0482 <VD6G_SetupFrameRate+0xaa>
341a0470:	693b      	ldr	r3, [r7, #16]
341a0472:	9300      	str	r3, [sp, #0]
341a0474:	f240 3346 	movw	r3, #838	@ 0x346
341a0478:	4a0a      	ldr	r2, [pc, #40]	@ (341a04a4 <VD6G_SetupFrameRate+0xcc>)
341a047a:	490b      	ldr	r1, [pc, #44]	@ (341a04a8 <VD6G_SetupFrameRate+0xd0>)
341a047c:	6878      	ldr	r0, [r7, #4]
341a047e:	f7fe fe6e 	bl	3419f15e <VD6G_error>
341a0482:	693b      	ldr	r3, [r7, #16]
341a0484:	2b00      	cmp	r3, #0
341a0486:	d002      	beq.n	341a048e <VD6G_SetupFrameRate+0xb6>
341a0488:	6878      	ldr	r0, [r7, #4]
341a048a:	f7fe fe83 	bl	3419f194 <display_error>
341a048e:	693b      	ldr	r3, [r7, #16]
341a0490:	2b00      	cmp	r3, #0
341a0492:	d001      	beq.n	341a0498 <VD6G_SetupFrameRate+0xc0>
341a0494:	693b      	ldr	r3, [r7, #16]
341a0496:	e000      	b.n	341a049a <VD6G_SetupFrameRate+0xc2>

  return 0;
341a0498:	2300      	movs	r3, #0
}
341a049a:	4618      	mov	r0, r3
341a049c:	3718      	adds	r7, #24
341a049e:	46bd      	mov	sp, r7
341a04a0:	bd80      	pop	{r7, pc}
341a04a2:	bf00      	nop
341a04a4:	341b7558 	.word	0x341b7558
341a04a8:	341a6494 	.word	0x341a6494
341a04ac:	341a6680 	.word	0x341a6680
341a04b0:	09959d00 	.word	0x09959d00
341a04b4:	341a6690 	.word	0x341a6690

341a04b8 <VD6G_SetupExposure>:

static int VD6G_SetupExposure(VD6G_Ctx_t *ctx)
{
341a04b8:	b580      	push	{r7, lr}
341a04ba:	b084      	sub	sp, #16
341a04bc:	af00      	add	r7, sp, #0
341a04be:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a04c0:	687b      	ldr	r3, [r7, #4]
341a04c2:	332c      	adds	r3, #44	@ 0x2c
341a04c4:	60fb      	str	r3, [r7, #12]

  return VD6G_SetExposureModeInternal(ctx, drv_ctx->config_save.exposure_mode);
341a04c6:	68fb      	ldr	r3, [r7, #12]
341a04c8:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a04cc:	4619      	mov	r1, r3
341a04ce:	6878      	ldr	r0, [r7, #4]
341a04d0:	f7ff fba4 	bl	3419fc1c <VD6G_SetExposureModeInternal>
341a04d4:	4603      	mov	r3, r0
}
341a04d6:	4618      	mov	r0, r3
341a04d8:	3710      	adds	r7, #16
341a04da:	46bd      	mov	sp, r7
341a04dc:	bd80      	pop	{r7, pc}
	...

341a04e0 <VD6G_SetupMirrorFlip>:

static int VD6G_SetupMirrorFlip(VD6G_Ctx_t *ctx)
{
341a04e0:	b580      	push	{r7, lr}
341a04e2:	b088      	sub	sp, #32
341a04e4:	af02      	add	r7, sp, #8
341a04e6:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a04e8:	687b      	ldr	r3, [r7, #4]
341a04ea:	332c      	adds	r3, #44	@ 0x2c
341a04ec:	613b      	str	r3, [r7, #16]
  uint8_t mode;
  int ret;

  switch (drv_ctx->config_save.flip_mirror_mode) {
341a04ee:	693b      	ldr	r3, [r7, #16]
341a04f0:	7c1b      	ldrb	r3, [r3, #16]
341a04f2:	2b03      	cmp	r3, #3
341a04f4:	d816      	bhi.n	341a0524 <VD6G_SetupMirrorFlip+0x44>
341a04f6:	a201      	add	r2, pc, #4	@ (adr r2, 341a04fc <VD6G_SetupMirrorFlip+0x1c>)
341a04f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a04fc:	341a050d 	.word	0x341a050d
341a0500:	341a0513 	.word	0x341a0513
341a0504:	341a0519 	.word	0x341a0519
341a0508:	341a051f 	.word	0x341a051f
  case VD6G_MIRROR_FLIP_NONE:
    mode = 0;
341a050c:	2300      	movs	r3, #0
341a050e:	75fb      	strb	r3, [r7, #23]
    break;
341a0510:	e00b      	b.n	341a052a <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_FLIP:
    mode = 2;
341a0512:	2302      	movs	r3, #2
341a0514:	75fb      	strb	r3, [r7, #23]
    break;
341a0516:	e008      	b.n	341a052a <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_MIRROR:
    mode = 1;
341a0518:	2301      	movs	r3, #1
341a051a:	75fb      	strb	r3, [r7, #23]
    break;
341a051c:	e005      	b.n	341a052a <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_MIRROR_FLIP:
    mode = 3;
341a051e:	2303      	movs	r3, #3
341a0520:	75fb      	strb	r3, [r7, #23]
    break;
341a0522:	e002      	b.n	341a052a <VD6G_SetupMirrorFlip+0x4a>
  default:
    return -1;
341a0524:	f04f 33ff 	mov.w	r3, #4294967295
341a0528:	e01f      	b.n	341a056a <VD6G_SetupMirrorFlip+0x8a>
  }

  ret = ctx->write8(ctx, VD6G_REG_ORIENTATION, mode);
341a052a:	687b      	ldr	r3, [r7, #4]
341a052c:	691b      	ldr	r3, [r3, #16]
341a052e:	7dfa      	ldrb	r2, [r7, #23]
341a0530:	f240 3102 	movw	r1, #770	@ 0x302
341a0534:	6878      	ldr	r0, [r7, #4]
341a0536:	4798      	blx	r3
341a0538:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a053a:	68fb      	ldr	r3, [r7, #12]
341a053c:	2b00      	cmp	r3, #0
341a053e:	d008      	beq.n	341a0552 <VD6G_SetupMirrorFlip+0x72>
341a0540:	68fb      	ldr	r3, [r7, #12]
341a0542:	9300      	str	r3, [sp, #0]
341a0544:	f240 336a 	movw	r3, #874	@ 0x36a
341a0548:	4a0a      	ldr	r2, [pc, #40]	@ (341a0574 <VD6G_SetupMirrorFlip+0x94>)
341a054a:	490b      	ldr	r1, [pc, #44]	@ (341a0578 <VD6G_SetupMirrorFlip+0x98>)
341a054c:	6878      	ldr	r0, [r7, #4]
341a054e:	f7fe fe06 	bl	3419f15e <VD6G_error>
341a0552:	68fb      	ldr	r3, [r7, #12]
341a0554:	2b00      	cmp	r3, #0
341a0556:	d002      	beq.n	341a055e <VD6G_SetupMirrorFlip+0x7e>
341a0558:	6878      	ldr	r0, [r7, #4]
341a055a:	f7fe fe1b 	bl	3419f194 <display_error>
341a055e:	68fb      	ldr	r3, [r7, #12]
341a0560:	2b00      	cmp	r3, #0
341a0562:	d001      	beq.n	341a0568 <VD6G_SetupMirrorFlip+0x88>
341a0564:	68fb      	ldr	r3, [r7, #12]
341a0566:	e000      	b.n	341a056a <VD6G_SetupMirrorFlip+0x8a>

  return 0;
341a0568:	2300      	movs	r3, #0
}
341a056a:	4618      	mov	r0, r3
341a056c:	3718      	adds	r7, #24
341a056e:	46bd      	mov	sp, r7
341a0570:	bd80      	pop	{r7, pc}
341a0572:	bf00      	nop
341a0574:	341b756c 	.word	0x341b756c
341a0578:	341a6494 	.word	0x341a6494

341a057c <VD6G_SetupPatGen>:

static int VD6G_SetupPatGen(VD6G_Ctx_t *ctx)
{
341a057c:	b580      	push	{r7, lr}
341a057e:	b088      	sub	sp, #32
341a0580:	af02      	add	r7, sp, #8
341a0582:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0584:	687b      	ldr	r3, [r7, #4]
341a0586:	332c      	adds	r3, #44	@ 0x2c
341a0588:	613b      	str	r3, [r7, #16]
  uint16_t value = VD6G_PATGEN_CTRL_DISABLE;
341a058a:	2300      	movs	r3, #0
341a058c:	82fb      	strh	r3, [r7, #22]
  int ret;

  switch (drv_ctx->config_save.patgen) {
341a058e:	693b      	ldr	r3, [r7, #16]
341a0590:	7e1b      	ldrb	r3, [r3, #24]
341a0592:	2b06      	cmp	r3, #6
341a0594:	d829      	bhi.n	341a05ea <VD6G_SetupPatGen+0x6e>
341a0596:	a201      	add	r2, pc, #4	@ (adr r2, 341a059c <VD6G_SetupPatGen+0x20>)
341a0598:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a059c:	341a05b9 	.word	0x341a05b9
341a05a0:	341a05bf 	.word	0x341a05bf
341a05a4:	341a05c5 	.word	0x341a05c5
341a05a8:	341a05cb 	.word	0x341a05cb
341a05ac:	341a05d3 	.word	0x341a05d3
341a05b0:	341a05db 	.word	0x341a05db
341a05b4:	341a05e3 	.word	0x341a05e3
  case VD6G_PATGEN_DISABLE:
    value = VD6G_PATGEN_CTRL_DISABLE;
341a05b8:	2300      	movs	r3, #0
341a05ba:	82fb      	strh	r3, [r7, #22]
    break;
341a05bc:	e018      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_SOLID_COLOR:
    value = VD6G_PATGEN_CTRL_SOLID_COLOR ;
341a05be:	2311      	movs	r3, #17
341a05c0:	82fb      	strh	r3, [r7, #22]
    break;
341a05c2:	e015      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_VERTICAL_COLOR_BARS:
    value = VD6G_PATGEN_CTRL_VER_COLOR_BAR;
341a05c4:	2321      	movs	r3, #33	@ 0x21
341a05c6:	82fb      	strh	r3, [r7, #22]
    break;
341a05c8:	e012      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_HORIZONTAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_HOR_GRAY;
341a05ca:	f240 1301 	movw	r3, #257	@ 0x101
341a05ce:	82fb      	strh	r3, [r7, #22]
    break;
341a05d0:	e00e      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_VERTICAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_VER_GRAY;
341a05d2:	f240 1311 	movw	r3, #273	@ 0x111
341a05d6:	82fb      	strh	r3, [r7, #22]
    break;
341a05d8:	e00a      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_DIAGONAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_DIAG_GRAY;
341a05da:	f240 1321 	movw	r3, #289	@ 0x121
341a05de:	82fb      	strh	r3, [r7, #22]
    break;
341a05e0:	e006      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_PSEUDO_RANDOM:
    value = VD6G_PATGEN_CTRL_PSN;
341a05e2:	f240 1331 	movw	r3, #305	@ 0x131
341a05e6:	82fb      	strh	r3, [r7, #22]
    break;
341a05e8:	e002      	b.n	341a05f0 <VD6G_SetupPatGen+0x74>
  default:
    return -1;
341a05ea:	f04f 33ff 	mov.w	r3, #4294967295
341a05ee:	e061      	b.n	341a06b4 <VD6G_SetupPatGen+0x138>
  }

  if (drv_ctx->config_save.patgen != VD6G_PATGEN_DISABLE)
341a05f0:	693b      	ldr	r3, [r7, #16]
341a05f2:	7e1b      	ldrb	r3, [r3, #24]
341a05f4:	2b00      	cmp	r3, #0
341a05f6:	d03d      	beq.n	341a0674 <VD6G_SetupPatGen+0xf8>
  {
    ret = ctx->write8(ctx, VD6G_REG_DUSTER_CTRL, VD6G_DUSTER_CTRL_DISABLE);
341a05f8:	687b      	ldr	r3, [r7, #4]
341a05fa:	691b      	ldr	r3, [r3, #16]
341a05fc:	2200      	movs	r2, #0
341a05fe:	f44f 7146 	mov.w	r1, #792	@ 0x318
341a0602:	6878      	ldr	r0, [r7, #4]
341a0604:	4798      	blx	r3
341a0606:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
341a0608:	68fb      	ldr	r3, [r7, #12]
341a060a:	2b00      	cmp	r3, #0
341a060c:	d008      	beq.n	341a0620 <VD6G_SetupPatGen+0xa4>
341a060e:	68fb      	ldr	r3, [r7, #12]
341a0610:	9300      	str	r3, [sp, #0]
341a0612:	f240 3392 	movw	r3, #914	@ 0x392
341a0616:	4a29      	ldr	r2, [pc, #164]	@ (341a06bc <VD6G_SetupPatGen+0x140>)
341a0618:	4929      	ldr	r1, [pc, #164]	@ (341a06c0 <VD6G_SetupPatGen+0x144>)
341a061a:	6878      	ldr	r0, [r7, #4]
341a061c:	f7fe fd9f 	bl	3419f15e <VD6G_error>
341a0620:	68fb      	ldr	r3, [r7, #12]
341a0622:	2b00      	cmp	r3, #0
341a0624:	d002      	beq.n	341a062c <VD6G_SetupPatGen+0xb0>
341a0626:	6878      	ldr	r0, [r7, #4]
341a0628:	f7fe fdb4 	bl	3419f194 <display_error>
341a062c:	68fb      	ldr	r3, [r7, #12]
341a062e:	2b00      	cmp	r3, #0
341a0630:	d001      	beq.n	341a0636 <VD6G_SetupPatGen+0xba>
341a0632:	68fb      	ldr	r3, [r7, #12]
341a0634:	e03e      	b.n	341a06b4 <VD6G_SetupPatGen+0x138>
    ret = ctx->write8(ctx, VD6G_REG_DARKCAL_CTRL, VD6G_DARKCAL_CTRL_DISABLE_DARKAVG);
341a0636:	687b      	ldr	r3, [r7, #4]
341a0638:	691b      	ldr	r3, [r3, #16]
341a063a:	2202      	movs	r2, #2
341a063c:	f44f 7150 	mov.w	r1, #832	@ 0x340
341a0640:	6878      	ldr	r0, [r7, #4]
341a0642:	4798      	blx	r3
341a0644:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
341a0646:	68fb      	ldr	r3, [r7, #12]
341a0648:	2b00      	cmp	r3, #0
341a064a:	d008      	beq.n	341a065e <VD6G_SetupPatGen+0xe2>
341a064c:	68fb      	ldr	r3, [r7, #12]
341a064e:	9300      	str	r3, [sp, #0]
341a0650:	f44f 7365 	mov.w	r3, #916	@ 0x394
341a0654:	4a19      	ldr	r2, [pc, #100]	@ (341a06bc <VD6G_SetupPatGen+0x140>)
341a0656:	491a      	ldr	r1, [pc, #104]	@ (341a06c0 <VD6G_SetupPatGen+0x144>)
341a0658:	6878      	ldr	r0, [r7, #4]
341a065a:	f7fe fd80 	bl	3419f15e <VD6G_error>
341a065e:	68fb      	ldr	r3, [r7, #12]
341a0660:	2b00      	cmp	r3, #0
341a0662:	d002      	beq.n	341a066a <VD6G_SetupPatGen+0xee>
341a0664:	6878      	ldr	r0, [r7, #4]
341a0666:	f7fe fd95 	bl	3419f194 <display_error>
341a066a:	68fb      	ldr	r3, [r7, #12]
341a066c:	2b00      	cmp	r3, #0
341a066e:	d001      	beq.n	341a0674 <VD6G_SetupPatGen+0xf8>
341a0670:	68fb      	ldr	r3, [r7, #12]
341a0672:	e01f      	b.n	341a06b4 <VD6G_SetupPatGen+0x138>
  }

  ret = ctx->write16(ctx, VD6G_REG_PATGEN_CTRL, value);
341a0674:	687b      	ldr	r3, [r7, #4]
341a0676:	695b      	ldr	r3, [r3, #20]
341a0678:	8afa      	ldrh	r2, [r7, #22]
341a067a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
341a067e:	6878      	ldr	r0, [r7, #4]
341a0680:	4798      	blx	r3
341a0682:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0684:	68fb      	ldr	r3, [r7, #12]
341a0686:	2b00      	cmp	r3, #0
341a0688:	d008      	beq.n	341a069c <VD6G_SetupPatGen+0x120>
341a068a:	68fb      	ldr	r3, [r7, #12]
341a068c:	9300      	str	r3, [sp, #0]
341a068e:	f44f 7366 	mov.w	r3, #920	@ 0x398
341a0692:	4a0a      	ldr	r2, [pc, #40]	@ (341a06bc <VD6G_SetupPatGen+0x140>)
341a0694:	490a      	ldr	r1, [pc, #40]	@ (341a06c0 <VD6G_SetupPatGen+0x144>)
341a0696:	6878      	ldr	r0, [r7, #4]
341a0698:	f7fe fd61 	bl	3419f15e <VD6G_error>
341a069c:	68fb      	ldr	r3, [r7, #12]
341a069e:	2b00      	cmp	r3, #0
341a06a0:	d002      	beq.n	341a06a8 <VD6G_SetupPatGen+0x12c>
341a06a2:	6878      	ldr	r0, [r7, #4]
341a06a4:	f7fe fd76 	bl	3419f194 <display_error>
341a06a8:	68fb      	ldr	r3, [r7, #12]
341a06aa:	2b00      	cmp	r3, #0
341a06ac:	d001      	beq.n	341a06b2 <VD6G_SetupPatGen+0x136>
341a06ae:	68fb      	ldr	r3, [r7, #12]
341a06b0:	e000      	b.n	341a06b4 <VD6G_SetupPatGen+0x138>

  return 0;
341a06b2:	2300      	movs	r3, #0
}
341a06b4:	4618      	mov	r0, r3
341a06b6:	3718      	adds	r7, #24
341a06b8:	46bd      	mov	sp, r7
341a06ba:	bd80      	pop	{r7, pc}
341a06bc:	341b7584 	.word	0x341b7584
341a06c0:	341a6494 	.word	0x341a6494

341a06c4 <VD6G_SetFlicker>:

static int VD6G_SetFlicker(VD6G_Ctx_t *ctx, VD6G_Flicker_t flicker)
{
341a06c4:	b580      	push	{r7, lr}
341a06c6:	b086      	sub	sp, #24
341a06c8:	af02      	add	r7, sp, #8
341a06ca:	6078      	str	r0, [r7, #4]
341a06cc:	460b      	mov	r3, r1
341a06ce:	70fb      	strb	r3, [r7, #3]
  uint16_t mode;
  int ret;

  switch (flicker) {
341a06d0:	78fb      	ldrb	r3, [r7, #3]
341a06d2:	2b02      	cmp	r3, #2
341a06d4:	d00c      	beq.n	341a06f0 <VD6G_SetFlicker+0x2c>
341a06d6:	2b02      	cmp	r3, #2
341a06d8:	dc0d      	bgt.n	341a06f6 <VD6G_SetFlicker+0x32>
341a06da:	2b00      	cmp	r3, #0
341a06dc:	d002      	beq.n	341a06e4 <VD6G_SetFlicker+0x20>
341a06de:	2b01      	cmp	r3, #1
341a06e0:	d003      	beq.n	341a06ea <VD6G_SetFlicker+0x26>
341a06e2:	e008      	b.n	341a06f6 <VD6G_SetFlicker+0x32>
  case VD6G_FLICKER_FREE_NONE:
    mode = AE_COMP_CTRL_GAIN_PRIO;
341a06e4:	2300      	movs	r3, #0
341a06e6:	81fb      	strh	r3, [r7, #14]
    break;
341a06e8:	e008      	b.n	341a06fc <VD6G_SetFlicker+0x38>
  case VD6G_FLICKER_FREE_50HZ:
    mode = AE_COMP_CTRL_FLICKER_50_HZ;
341a06ea:	2301      	movs	r3, #1
341a06ec:	81fb      	strh	r3, [r7, #14]
    break;
341a06ee:	e005      	b.n	341a06fc <VD6G_SetFlicker+0x38>
  case VD6G_FLICKER_FREE_60HZ:
    mode = AE_COMP_CTRL_FLICKER_60_HZ;
341a06f0:	2303      	movs	r3, #3
341a06f2:	81fb      	strh	r3, [r7, #14]
    break;
341a06f4:	e002      	b.n	341a06fc <VD6G_SetFlicker+0x38>
  default:
    return -1;
341a06f6:	f04f 33ff 	mov.w	r3, #4294967295
341a06fa:	e01f      	b.n	341a073c <VD6G_SetFlicker+0x78>
  }

  ret = ctx->write16(ctx, VD6G_REG_AE_COMPILER_CONTROL, mode);
341a06fc:	687b      	ldr	r3, [r7, #4]
341a06fe:	695b      	ldr	r3, [r3, #20]
341a0700:	89fa      	ldrh	r2, [r7, #14]
341a0702:	f44f 6186 	mov.w	r1, #1072	@ 0x430
341a0706:	6878      	ldr	r0, [r7, #4]
341a0708:	4798      	blx	r3
341a070a:	60b8      	str	r0, [r7, #8]
  VD6G_TraceError(ctx, ret);
341a070c:	68bb      	ldr	r3, [r7, #8]
341a070e:	2b00      	cmp	r3, #0
341a0710:	d008      	beq.n	341a0724 <VD6G_SetFlicker+0x60>
341a0712:	68bb      	ldr	r3, [r7, #8]
341a0714:	9300      	str	r3, [sp, #0]
341a0716:	f240 33b1 	movw	r3, #945	@ 0x3b1
341a071a:	4a0a      	ldr	r2, [pc, #40]	@ (341a0744 <VD6G_SetFlicker+0x80>)
341a071c:	490a      	ldr	r1, [pc, #40]	@ (341a0748 <VD6G_SetFlicker+0x84>)
341a071e:	6878      	ldr	r0, [r7, #4]
341a0720:	f7fe fd1d 	bl	3419f15e <VD6G_error>
341a0724:	68bb      	ldr	r3, [r7, #8]
341a0726:	2b00      	cmp	r3, #0
341a0728:	d002      	beq.n	341a0730 <VD6G_SetFlicker+0x6c>
341a072a:	6878      	ldr	r0, [r7, #4]
341a072c:	f7fe fd32 	bl	3419f194 <display_error>
341a0730:	68bb      	ldr	r3, [r7, #8]
341a0732:	2b00      	cmp	r3, #0
341a0734:	d001      	beq.n	341a073a <VD6G_SetFlicker+0x76>
341a0736:	68bb      	ldr	r3, [r7, #8]
341a0738:	e000      	b.n	341a073c <VD6G_SetFlicker+0x78>

  return 0;
341a073a:	2300      	movs	r3, #0
}
341a073c:	4618      	mov	r0, r3
341a073e:	3710      	adds	r7, #16
341a0740:	46bd      	mov	sp, r7
341a0742:	bd80      	pop	{r7, pc}
341a0744:	341b7598 	.word	0x341b7598
341a0748:	341a6494 	.word	0x341a6494

341a074c <VD6G_Flicker>:

static int VD6G_Flicker(VD6G_Ctx_t *ctx)
{
341a074c:	b580      	push	{r7, lr}
341a074e:	b084      	sub	sp, #16
341a0750:	af00      	add	r7, sp, #0
341a0752:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0754:	687b      	ldr	r3, [r7, #4]
341a0756:	332c      	adds	r3, #44	@ 0x2c
341a0758:	60fb      	str	r3, [r7, #12]

  return VD6G_SetFlicker(ctx, drv_ctx->config_save.flicker);
341a075a:	68fb      	ldr	r3, [r7, #12]
341a075c:	7e5b      	ldrb	r3, [r3, #25]
341a075e:	4619      	mov	r1, r3
341a0760:	6878      	ldr	r0, [r7, #4]
341a0762:	f7ff ffaf 	bl	341a06c4 <VD6G_SetFlicker>
341a0766:	4603      	mov	r3, r0
}
341a0768:	4618      	mov	r0, r3
341a076a:	3710      	adds	r7, #16
341a076c:	46bd      	mov	sp, r7
341a076e:	bd80      	pop	{r7, pc}

341a0770 <VD6G_SetupEarly>:

static int VD6G_SetupEarly(VD6G_Ctx_t *ctx)
{
341a0770:	b580      	push	{r7, lr}
341a0772:	b084      	sub	sp, #16
341a0774:	af00      	add	r7, sp, #0
341a0776:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_SetupClocks(ctx);
341a0778:	6878      	ldr	r0, [r7, #4]
341a077a:	f7ff fb87 	bl	3419fe8c <VD6G_SetupClocks>
341a077e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0780:	68fb      	ldr	r3, [r7, #12]
341a0782:	2b00      	cmp	r3, #0
341a0784:	d001      	beq.n	341a078a <VD6G_SetupEarly+0x1a>
    return ret;
341a0786:	68fb      	ldr	r3, [r7, #12]
341a0788:	e009      	b.n	341a079e <VD6G_SetupEarly+0x2e>

  ret = VD6G_SetupFrameRate(ctx);
341a078a:	6878      	ldr	r0, [r7, #4]
341a078c:	f7ff fe24 	bl	341a03d8 <VD6G_SetupFrameRate>
341a0790:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0792:	68fb      	ldr	r3, [r7, #12]
341a0794:	2b00      	cmp	r3, #0
341a0796:	d001      	beq.n	341a079c <VD6G_SetupEarly+0x2c>
    return ret;
341a0798:	68fb      	ldr	r3, [r7, #12]
341a079a:	e000      	b.n	341a079e <VD6G_SetupEarly+0x2e>

  return 0;
341a079c:	2300      	movs	r3, #0
}
341a079e:	4618      	mov	r0, r3
341a07a0:	3710      	adds	r7, #16
341a07a2:	46bd      	mov	sp, r7
341a07a4:	bd80      	pop	{r7, pc}

341a07a6 <VD6G_Setup>:

static int VD6G_Setup(VD6G_Ctx_t *ctx)
{
341a07a6:	b580      	push	{r7, lr}
341a07a8:	b084      	sub	sp, #16
341a07aa:	af00      	add	r7, sp, #0
341a07ac:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_SetupOutput(ctx);
341a07ae:	6878      	ldr	r0, [r7, #4]
341a07b0:	f7ff fc10 	bl	3419ffd4 <VD6G_SetupOutput>
341a07b4:	60f8      	str	r0, [r7, #12]
  if (ret)
341a07b6:	68fb      	ldr	r3, [r7, #12]
341a07b8:	2b00      	cmp	r3, #0
341a07ba:	d001      	beq.n	341a07c0 <VD6G_Setup+0x1a>
    return ret;
341a07bc:	68fb      	ldr	r3, [r7, #12]
341a07be:	e02d      	b.n	341a081c <VD6G_Setup+0x76>

  ret = VD6G_SetupSize(ctx);
341a07c0:	6878      	ldr	r0, [r7, #4]
341a07c2:	f7ff fd3b 	bl	341a023c <VD6G_SetupSize>
341a07c6:	60f8      	str	r0, [r7, #12]
  if (ret)
341a07c8:	68fb      	ldr	r3, [r7, #12]
341a07ca:	2b00      	cmp	r3, #0
341a07cc:	d001      	beq.n	341a07d2 <VD6G_Setup+0x2c>
    return ret;
341a07ce:	68fb      	ldr	r3, [r7, #12]
341a07d0:	e024      	b.n	341a081c <VD6G_Setup+0x76>

  ret = VD6G_SetupExposure(ctx);
341a07d2:	6878      	ldr	r0, [r7, #4]
341a07d4:	f7ff fe70 	bl	341a04b8 <VD6G_SetupExposure>
341a07d8:	60f8      	str	r0, [r7, #12]
  if (ret)
341a07da:	68fb      	ldr	r3, [r7, #12]
341a07dc:	2b00      	cmp	r3, #0
341a07de:	d001      	beq.n	341a07e4 <VD6G_Setup+0x3e>
    return ret;
341a07e0:	68fb      	ldr	r3, [r7, #12]
341a07e2:	e01b      	b.n	341a081c <VD6G_Setup+0x76>

  ret = VD6G_SetupMirrorFlip(ctx);
341a07e4:	6878      	ldr	r0, [r7, #4]
341a07e6:	f7ff fe7b 	bl	341a04e0 <VD6G_SetupMirrorFlip>
341a07ea:	60f8      	str	r0, [r7, #12]
  if (ret)
341a07ec:	68fb      	ldr	r3, [r7, #12]
341a07ee:	2b00      	cmp	r3, #0
341a07f0:	d001      	beq.n	341a07f6 <VD6G_Setup+0x50>
    return ret;
341a07f2:	68fb      	ldr	r3, [r7, #12]
341a07f4:	e012      	b.n	341a081c <VD6G_Setup+0x76>

  ret = VD6G_SetupPatGen(ctx);
341a07f6:	6878      	ldr	r0, [r7, #4]
341a07f8:	f7ff fec0 	bl	341a057c <VD6G_SetupPatGen>
341a07fc:	60f8      	str	r0, [r7, #12]
  if (ret)
341a07fe:	68fb      	ldr	r3, [r7, #12]
341a0800:	2b00      	cmp	r3, #0
341a0802:	d001      	beq.n	341a0808 <VD6G_Setup+0x62>
    return ret;
341a0804:	68fb      	ldr	r3, [r7, #12]
341a0806:	e009      	b.n	341a081c <VD6G_Setup+0x76>

  ret = VD6G_Flicker(ctx);
341a0808:	6878      	ldr	r0, [r7, #4]
341a080a:	f7ff ff9f 	bl	341a074c <VD6G_Flicker>
341a080e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0810:	68fb      	ldr	r3, [r7, #12]
341a0812:	2b00      	cmp	r3, #0
341a0814:	d001      	beq.n	341a081a <VD6G_Setup+0x74>
    return ret;
341a0816:	68fb      	ldr	r3, [r7, #12]
341a0818:	e000      	b.n	341a081c <VD6G_Setup+0x76>

  return 0;
341a081a:	2300      	movs	r3, #0
}
341a081c:	4618      	mov	r0, r3
341a081e:	3710      	adds	r7, #16
341a0820:	46bd      	mov	sp, r7
341a0822:	bd80      	pop	{r7, pc}

341a0824 <VD6G_StartStreaming>:

static int VD6G_StartStreaming(VD6G_Ctx_t *ctx)
{
341a0824:	b580      	push	{r7, lr}
341a0826:	b086      	sub	sp, #24
341a0828:	af02      	add	r7, sp, #8
341a082a:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_STBY, VD6G_CMD_START_STREAM);
341a082c:	687b      	ldr	r3, [r7, #4]
341a082e:	691b      	ldr	r3, [r3, #16]
341a0830:	2201      	movs	r2, #1
341a0832:	f240 2101 	movw	r1, #513	@ 0x201
341a0836:	6878      	ldr	r0, [r7, #4]
341a0838:	4798      	blx	r3
341a083a:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a083c:	68fb      	ldr	r3, [r7, #12]
341a083e:	2b00      	cmp	r3, #0
341a0840:	d008      	beq.n	341a0854 <VD6G_StartStreaming+0x30>
341a0842:	68fb      	ldr	r3, [r7, #12]
341a0844:	9300      	str	r3, [sp, #0]
341a0846:	f44f 737c 	mov.w	r3, #1008	@ 0x3f0
341a084a:	4a17      	ldr	r2, [pc, #92]	@ (341a08a8 <VD6G_StartStreaming+0x84>)
341a084c:	4917      	ldr	r1, [pc, #92]	@ (341a08ac <VD6G_StartStreaming+0x88>)
341a084e:	6878      	ldr	r0, [r7, #4]
341a0850:	f7fe fc85 	bl	3419f15e <VD6G_error>
341a0854:	68fb      	ldr	r3, [r7, #12]
341a0856:	2b00      	cmp	r3, #0
341a0858:	d002      	beq.n	341a0860 <VD6G_StartStreaming+0x3c>
341a085a:	6878      	ldr	r0, [r7, #4]
341a085c:	f7fe fc9a 	bl	3419f194 <display_error>
341a0860:	68fb      	ldr	r3, [r7, #12]
341a0862:	2b00      	cmp	r3, #0
341a0864:	d001      	beq.n	341a086a <VD6G_StartStreaming+0x46>
341a0866:	68fb      	ldr	r3, [r7, #12]
341a0868:	e01a      	b.n	341a08a0 <VD6G_StartStreaming+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_STBY, VD6G_CMD_ACK);
341a086a:	2200      	movs	r2, #0
341a086c:	f240 2101 	movw	r1, #513	@ 0x201
341a0870:	6878      	ldr	r0, [r7, #4]
341a0872:	f7fe fcb7 	bl	3419f1e4 <VD6G_PollReg8>
341a0876:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0878:	68fb      	ldr	r3, [r7, #12]
341a087a:	2b00      	cmp	r3, #0
341a087c:	d001      	beq.n	341a0882 <VD6G_StartStreaming+0x5e>
    return ret;
341a087e:	68fb      	ldr	r3, [r7, #12]
341a0880:	e00e      	b.n	341a08a0 <VD6G_StartStreaming+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_STREAMING);
341a0882:	2103      	movs	r1, #3
341a0884:	6878      	ldr	r0, [r7, #4]
341a0886:	f7fe fd67 	bl	3419f358 <VD6G_WaitState>
341a088a:	60f8      	str	r0, [r7, #12]
  if (ret)
341a088c:	68fb      	ldr	r3, [r7, #12]
341a088e:	2b00      	cmp	r3, #0
341a0890:	d001      	beq.n	341a0896 <VD6G_StartStreaming+0x72>
    return ret;
341a0892:	68fb      	ldr	r3, [r7, #12]
341a0894:	e004      	b.n	341a08a0 <VD6G_StartStreaming+0x7c>

  VD6G_notice(ctx, "Streaming is on\n");
341a0896:	4906      	ldr	r1, [pc, #24]	@ (341a08b0 <VD6G_StartStreaming+0x8c>)
341a0898:	6878      	ldr	r0, [r7, #4]
341a089a:	f7fe fc2a 	bl	3419f0f2 <VD6G_notice>

  return 0;
341a089e:	2300      	movs	r3, #0
}
341a08a0:	4618      	mov	r0, r3
341a08a2:	3710      	adds	r7, #16
341a08a4:	46bd      	mov	sp, r7
341a08a6:	bd80      	pop	{r7, pc}
341a08a8:	341b75a8 	.word	0x341b75a8
341a08ac:	341a6494 	.word	0x341a6494
341a08b0:	341a66b8 	.word	0x341a66b8

341a08b4 <VD6G_StopStreaming>:

static int VD6G_StopStreaming(VD6G_Ctx_t *ctx)
{
341a08b4:	b580      	push	{r7, lr}
341a08b6:	b086      	sub	sp, #24
341a08b8:	af02      	add	r7, sp, #8
341a08ba:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
341a08bc:	687b      	ldr	r3, [r7, #4]
341a08be:	691b      	ldr	r3, [r3, #16]
341a08c0:	2201      	movs	r2, #1
341a08c2:	f240 2102 	movw	r1, #514	@ 0x202
341a08c6:	6878      	ldr	r0, [r7, #4]
341a08c8:	4798      	blx	r3
341a08ca:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a08cc:	68fb      	ldr	r3, [r7, #12]
341a08ce:	2b00      	cmp	r3, #0
341a08d0:	d008      	beq.n	341a08e4 <VD6G_StopStreaming+0x30>
341a08d2:	68fb      	ldr	r3, [r7, #12]
341a08d4:	9300      	str	r3, [sp, #0]
341a08d6:	f240 4304 	movw	r3, #1028	@ 0x404
341a08da:	4a17      	ldr	r2, [pc, #92]	@ (341a0938 <VD6G_StopStreaming+0x84>)
341a08dc:	4917      	ldr	r1, [pc, #92]	@ (341a093c <VD6G_StopStreaming+0x88>)
341a08de:	6878      	ldr	r0, [r7, #4]
341a08e0:	f7fe fc3d 	bl	3419f15e <VD6G_error>
341a08e4:	68fb      	ldr	r3, [r7, #12]
341a08e6:	2b00      	cmp	r3, #0
341a08e8:	d002      	beq.n	341a08f0 <VD6G_StopStreaming+0x3c>
341a08ea:	6878      	ldr	r0, [r7, #4]
341a08ec:	f7fe fc52 	bl	3419f194 <display_error>
341a08f0:	68fb      	ldr	r3, [r7, #12]
341a08f2:	2b00      	cmp	r3, #0
341a08f4:	d001      	beq.n	341a08fa <VD6G_StopStreaming+0x46>
341a08f6:	68fb      	ldr	r3, [r7, #12]
341a08f8:	e01a      	b.n	341a0930 <VD6G_StopStreaming+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_STREAMING, VD6G_CMD_ACK);
341a08fa:	2200      	movs	r2, #0
341a08fc:	f240 2102 	movw	r1, #514	@ 0x202
341a0900:	6878      	ldr	r0, [r7, #4]
341a0902:	f7fe fc6f 	bl	3419f1e4 <VD6G_PollReg8>
341a0906:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0908:	68fb      	ldr	r3, [r7, #12]
341a090a:	2b00      	cmp	r3, #0
341a090c:	d001      	beq.n	341a0912 <VD6G_StopStreaming+0x5e>
    return ret;
341a090e:	68fb      	ldr	r3, [r7, #12]
341a0910:	e00e      	b.n	341a0930 <VD6G_StopStreaming+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
341a0912:	2102      	movs	r1, #2
341a0914:	6878      	ldr	r0, [r7, #4]
341a0916:	f7fe fd1f 	bl	3419f358 <VD6G_WaitState>
341a091a:	60f8      	str	r0, [r7, #12]
  if (ret)
341a091c:	68fb      	ldr	r3, [r7, #12]
341a091e:	2b00      	cmp	r3, #0
341a0920:	d001      	beq.n	341a0926 <VD6G_StopStreaming+0x72>
    return ret;
341a0922:	68fb      	ldr	r3, [r7, #12]
341a0924:	e004      	b.n	341a0930 <VD6G_StopStreaming+0x7c>

  VD6G_notice(ctx, "Streaming is off\n");
341a0926:	4906      	ldr	r1, [pc, #24]	@ (341a0940 <VD6G_StopStreaming+0x8c>)
341a0928:	6878      	ldr	r0, [r7, #4]
341a092a:	f7fe fbe2 	bl	3419f0f2 <VD6G_notice>

  return 0;
341a092e:	2300      	movs	r3, #0
}
341a0930:	4618      	mov	r0, r3
341a0932:	3710      	adds	r7, #16
341a0934:	46bd      	mov	sp, r7
341a0936:	bd80      	pop	{r7, pc}
341a0938:	341b75bc 	.word	0x341b75bc
341a093c:	341a6494 	.word	0x341a6494
341a0940:	341a66cc 	.word	0x341a66cc

341a0944 <VD6G_Init>:

int VD6G_Init(VD6G_Ctx_t *ctx, VD6G_Config_t *config)
{
341a0944:	b5b0      	push	{r4, r5, r7, lr}
341a0946:	b084      	sub	sp, #16
341a0948:	af00      	add	r7, sp, #0
341a094a:	6078      	str	r0, [r7, #4]
341a094c:	6039      	str	r1, [r7, #0]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a094e:	687b      	ldr	r3, [r7, #4]
341a0950:	332c      	adds	r3, #44	@ 0x2c
341a0952:	60fb      	str	r3, [r7, #12]
  int ret;

  if (config->frame_rate < VD6G_MIN_FPS)
341a0954:	683b      	ldr	r3, [r7, #0]
341a0956:	689b      	ldr	r3, [r3, #8]
341a0958:	2b00      	cmp	r3, #0
341a095a:	dc02      	bgt.n	341a0962 <VD6G_Init+0x1e>
    return -1;
341a095c:	f04f 33ff 	mov.w	r3, #4294967295
341a0960:	e078      	b.n	341a0a54 <VD6G_Init+0x110>
  if (config->frame_rate > VD6G_MAX_FPS)
341a0962:	683b      	ldr	r3, [r7, #0]
341a0964:	689b      	ldr	r3, [r3, #8]
341a0966:	2b58      	cmp	r3, #88	@ 0x58
341a0968:	dd02      	ble.n	341a0970 <VD6G_Init+0x2c>
    return -1;
341a096a:	f04f 33ff 	mov.w	r3, #4294967295
341a096e:	e071      	b.n	341a0a54 <VD6G_Init+0x110>

  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
341a0970:	683b      	ldr	r3, [r7, #0]
341a0972:	791b      	ldrb	r3, [r3, #4]
341a0974:	2b00      	cmp	r3, #0
341a0976:	d022      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_VGA_640_480) &&
341a0978:	683b      	ldr	r3, [r7, #0]
341a097a:	791b      	ldrb	r3, [r3, #4]
  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
341a097c:	2b01      	cmp	r3, #1
341a097e:	d01e      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_VGA_PORTRAIT_480_640) &&
341a0980:	683b      	ldr	r3, [r7, #0]
341a0982:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_VGA_640_480) &&
341a0984:	2b02      	cmp	r3, #2
341a0986:	d01a      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_XGA_1024_768) &&
341a0988:	683b      	ldr	r3, [r7, #0]
341a098a:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_VGA_PORTRAIT_480_640) &&
341a098c:	2b03      	cmp	r3, #3
341a098e:	d016      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_XGA_PORTRAIT_768_1024) &&
341a0990:	683b      	ldr	r3, [r7, #0]
341a0992:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_XGA_1024_768) &&
341a0994:	2b04      	cmp	r3, #4
341a0996:	d012      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_720P_PORTRAIT_720_1280) &&
341a0998:	683b      	ldr	r3, [r7, #0]
341a099a:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_XGA_PORTRAIT_768_1024) &&
341a099c:	2b05      	cmp	r3, #5
341a099e:	d00e      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_SXGA_PORTRAIT_1024_1280) &&
341a09a0:	683b      	ldr	r3, [r7, #0]
341a09a2:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_720P_PORTRAIT_720_1280) &&
341a09a4:	2b06      	cmp	r3, #6
341a09a6:	d00a      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_PORTRAIT_1120_720) &&
341a09a8:	683b      	ldr	r3, [r7, #0]
341a09aa:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_SXGA_PORTRAIT_1024_1280) &&
341a09ac:	2b07      	cmp	r3, #7
341a09ae:	d006      	beq.n	341a09be <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_FULL_1120_1364)) {
341a09b0:	683b      	ldr	r3, [r7, #0]
341a09b2:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_PORTRAIT_1120_720) &&
341a09b4:	2b08      	cmp	r3, #8
341a09b6:	d002      	beq.n	341a09be <VD6G_Init+0x7a>
    return -1;
341a09b8:	f04f 33ff 	mov.w	r3, #4294967295
341a09bc:	e04a      	b.n	341a0a54 <VD6G_Init+0x110>
  }

  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
341a09be:	683b      	ldr	r3, [r7, #0]
341a09c0:	7b1b      	ldrb	r3, [r3, #12]
341a09c2:	2b00      	cmp	r3, #0
341a09c4:	d00e      	beq.n	341a09e4 <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_FLIP) &&
341a09c6:	683b      	ldr	r3, [r7, #0]
341a09c8:	7b1b      	ldrb	r3, [r3, #12]
  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
341a09ca:	2b01      	cmp	r3, #1
341a09cc:	d00a      	beq.n	341a09e4 <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_MIRROR) &&
341a09ce:	683b      	ldr	r3, [r7, #0]
341a09d0:	7b1b      	ldrb	r3, [r3, #12]
      (config->flip_mirror_mode != VD6G_FLIP) &&
341a09d2:	2b02      	cmp	r3, #2
341a09d4:	d006      	beq.n	341a09e4 <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_MIRROR_FLIP)) {
341a09d6:	683b      	ldr	r3, [r7, #0]
341a09d8:	7b1b      	ldrb	r3, [r3, #12]
      (config->flip_mirror_mode != VD6G_MIRROR) &&
341a09da:	2b03      	cmp	r3, #3
341a09dc:	d002      	beq.n	341a09e4 <VD6G_Init+0xa0>
    return -1;
341a09de:	f04f 33ff 	mov.w	r3, #4294967295
341a09e2:	e037      	b.n	341a0a54 <VD6G_Init+0x110>
  }

  ctx->shutdown_pin(ctx, 0);
341a09e4:	687b      	ldr	r3, [r7, #4]
341a09e6:	681b      	ldr	r3, [r3, #0]
341a09e8:	2100      	movs	r1, #0
341a09ea:	6878      	ldr	r0, [r7, #4]
341a09ec:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a09ee:	687b      	ldr	r3, [r7, #4]
341a09f0:	6a1b      	ldr	r3, [r3, #32]
341a09f2:	210a      	movs	r1, #10
341a09f4:	6878      	ldr	r0, [r7, #4]
341a09f6:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
341a09f8:	687b      	ldr	r3, [r7, #4]
341a09fa:	681b      	ldr	r3, [r3, #0]
341a09fc:	2101      	movs	r1, #1
341a09fe:	6878      	ldr	r0, [r7, #4]
341a0a00:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a0a02:	687b      	ldr	r3, [r7, #4]
341a0a04:	6a1b      	ldr	r3, [r3, #32]
341a0a06:	210a      	movs	r1, #10
341a0a08:	6878      	ldr	r0, [r7, #4]
341a0a0a:	4798      	blx	r3

  drv_ctx->config_save = *config;
341a0a0c:	68fb      	ldr	r3, [r7, #12]
341a0a0e:	683a      	ldr	r2, [r7, #0]
341a0a10:	1d1c      	adds	r4, r3, #4
341a0a12:	4615      	mov	r5, r2
341a0a14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a0a16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a0a18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a0a1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a0a1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a0a1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a0a20:	e895 0003 	ldmia.w	r5, {r0, r1}
341a0a24:	e884 0003 	stmia.w	r4, {r0, r1}
  drv_ctx->is_streaming = 0;
341a0a28:	68fb      	ldr	r3, [r7, #12]
341a0a2a:	2200      	movs	r2, #0
341a0a2c:	601a      	str	r2, [r3, #0]

  ret = VD6G_Boot(ctx);
341a0a2e:	6878      	ldr	r0, [r7, #4]
341a0a30:	f7ff f96e 	bl	3419fd10 <VD6G_Boot>
341a0a34:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0a36:	68bb      	ldr	r3, [r7, #8]
341a0a38:	2b00      	cmp	r3, #0
341a0a3a:	d001      	beq.n	341a0a40 <VD6G_Init+0xfc>
    return ret;
341a0a3c:	68bb      	ldr	r3, [r7, #8]
341a0a3e:	e009      	b.n	341a0a54 <VD6G_Init+0x110>

  ret = VD6G_SetupEarly(ctx);
341a0a40:	6878      	ldr	r0, [r7, #4]
341a0a42:	f7ff fe95 	bl	341a0770 <VD6G_SetupEarly>
341a0a46:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0a48:	68bb      	ldr	r3, [r7, #8]
341a0a4a:	2b00      	cmp	r3, #0
341a0a4c:	d001      	beq.n	341a0a52 <VD6G_Init+0x10e>
    return ret;
341a0a4e:	68bb      	ldr	r3, [r7, #8]
341a0a50:	e000      	b.n	341a0a54 <VD6G_Init+0x110>

  return 0;
341a0a52:	2300      	movs	r3, #0
}
341a0a54:	4618      	mov	r0, r3
341a0a56:	3710      	adds	r7, #16
341a0a58:	46bd      	mov	sp, r7
341a0a5a:	bdb0      	pop	{r4, r5, r7, pc}

341a0a5c <VD6G_DeInit>:

int VD6G_DeInit(VD6G_Ctx_t *ctx)
{
341a0a5c:	b580      	push	{r7, lr}
341a0a5e:	b084      	sub	sp, #16
341a0a60:	af00      	add	r7, sp, #0
341a0a62:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0a64:	687b      	ldr	r3, [r7, #4]
341a0a66:	332c      	adds	r3, #44	@ 0x2c
341a0a68:	60fb      	str	r3, [r7, #12]

  if (drv_ctx->is_streaming)
341a0a6a:	68fb      	ldr	r3, [r7, #12]
341a0a6c:	681b      	ldr	r3, [r3, #0]
341a0a6e:	2b00      	cmp	r3, #0
341a0a70:	d002      	beq.n	341a0a78 <VD6G_DeInit+0x1c>
    return -1;
341a0a72:	f04f 33ff 	mov.w	r3, #4294967295
341a0a76:	e00a      	b.n	341a0a8e <VD6G_DeInit+0x32>

  ctx->shutdown_pin(ctx, 0);
341a0a78:	687b      	ldr	r3, [r7, #4]
341a0a7a:	681b      	ldr	r3, [r3, #0]
341a0a7c:	2100      	movs	r1, #0
341a0a7e:	6878      	ldr	r0, [r7, #4]
341a0a80:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a0a82:	687b      	ldr	r3, [r7, #4]
341a0a84:	6a1b      	ldr	r3, [r3, #32]
341a0a86:	210a      	movs	r1, #10
341a0a88:	6878      	ldr	r0, [r7, #4]
341a0a8a:	4798      	blx	r3

  return 0;
341a0a8c:	2300      	movs	r3, #0
}
341a0a8e:	4618      	mov	r0, r3
341a0a90:	3710      	adds	r7, #16
341a0a92:	46bd      	mov	sp, r7
341a0a94:	bd80      	pop	{r7, pc}

341a0a96 <VD6G_Start>:

int VD6G_Start(VD6G_Ctx_t *ctx)
{
341a0a96:	b580      	push	{r7, lr}
341a0a98:	b084      	sub	sp, #16
341a0a9a:	af00      	add	r7, sp, #0
341a0a9c:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0a9e:	687b      	ldr	r3, [r7, #4]
341a0aa0:	332c      	adds	r3, #44	@ 0x2c
341a0aa2:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_Setup(ctx);
341a0aa4:	6878      	ldr	r0, [r7, #4]
341a0aa6:	f7ff fe7e 	bl	341a07a6 <VD6G_Setup>
341a0aaa:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0aac:	68bb      	ldr	r3, [r7, #8]
341a0aae:	2b00      	cmp	r3, #0
341a0ab0:	d001      	beq.n	341a0ab6 <VD6G_Start+0x20>
    return ret;
341a0ab2:	68bb      	ldr	r3, [r7, #8]
341a0ab4:	e00c      	b.n	341a0ad0 <VD6G_Start+0x3a>

  ret = VD6G_StartStreaming(ctx);
341a0ab6:	6878      	ldr	r0, [r7, #4]
341a0ab8:	f7ff feb4 	bl	341a0824 <VD6G_StartStreaming>
341a0abc:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0abe:	68bb      	ldr	r3, [r7, #8]
341a0ac0:	2b00      	cmp	r3, #0
341a0ac2:	d001      	beq.n	341a0ac8 <VD6G_Start+0x32>
    return ret;
341a0ac4:	68bb      	ldr	r3, [r7, #8]
341a0ac6:	e003      	b.n	341a0ad0 <VD6G_Start+0x3a>
  drv_ctx->is_streaming = 1;
341a0ac8:	68fb      	ldr	r3, [r7, #12]
341a0aca:	2201      	movs	r2, #1
341a0acc:	601a      	str	r2, [r3, #0]

  return 0;
341a0ace:	2300      	movs	r3, #0
}
341a0ad0:	4618      	mov	r0, r3
341a0ad2:	3710      	adds	r7, #16
341a0ad4:	46bd      	mov	sp, r7
341a0ad6:	bd80      	pop	{r7, pc}

341a0ad8 <VD6G_Stop>:

int VD6G_Stop(VD6G_Ctx_t *ctx)
{
341a0ad8:	b580      	push	{r7, lr}
341a0ada:	b084      	sub	sp, #16
341a0adc:	af00      	add	r7, sp, #0
341a0ade:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0ae0:	687b      	ldr	r3, [r7, #4]
341a0ae2:	332c      	adds	r3, #44	@ 0x2c
341a0ae4:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_StopStreaming(ctx);
341a0ae6:	6878      	ldr	r0, [r7, #4]
341a0ae8:	f7ff fee4 	bl	341a08b4 <VD6G_StopStreaming>
341a0aec:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0aee:	68bb      	ldr	r3, [r7, #8]
341a0af0:	2b00      	cmp	r3, #0
341a0af2:	d001      	beq.n	341a0af8 <VD6G_Stop+0x20>
    return ret;
341a0af4:	68bb      	ldr	r3, [r7, #8]
341a0af6:	e003      	b.n	341a0b00 <VD6G_Stop+0x28>
  drv_ctx->is_streaming = 0;
341a0af8:	68fb      	ldr	r3, [r7, #12]
341a0afa:	2200      	movs	r2, #0
341a0afc:	601a      	str	r2, [r3, #0]

  return 0;
341a0afe:	2300      	movs	r3, #0
}
341a0b00:	4618      	mov	r0, r3
341a0b02:	3710      	adds	r7, #16
341a0b04:	46bd      	mov	sp, r7
341a0b06:	bd80      	pop	{r7, pc}

341a0b08 <VD6G_SetExposureMode>:

  return 0;
}

int VD6G_SetExposureMode(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
341a0b08:	b580      	push	{r7, lr}
341a0b0a:	b084      	sub	sp, #16
341a0b0c:	af00      	add	r7, sp, #0
341a0b0e:	6078      	str	r0, [r7, #4]
341a0b10:	460b      	mov	r3, r1
341a0b12:	70fb      	strb	r3, [r7, #3]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0b14:	687b      	ldr	r3, [r7, #4]
341a0b16:	332c      	adds	r3, #44	@ 0x2c
341a0b18:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_SetExposureModeInternal(ctx, mode);
341a0b1a:	78fb      	ldrb	r3, [r7, #3]
341a0b1c:	4619      	mov	r1, r3
341a0b1e:	6878      	ldr	r0, [r7, #4]
341a0b20:	f7ff f87c 	bl	3419fc1c <VD6G_SetExposureModeInternal>
341a0b24:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0b26:	68bb      	ldr	r3, [r7, #8]
341a0b28:	2b00      	cmp	r3, #0
341a0b2a:	d001      	beq.n	341a0b30 <VD6G_SetExposureMode+0x28>
    return ret;
341a0b2c:	68bb      	ldr	r3, [r7, #8]
341a0b2e:	e004      	b.n	341a0b3a <VD6G_SetExposureMode+0x32>

  drv_ctx->config_save.exposure_mode = mode;
341a0b30:	68fb      	ldr	r3, [r7, #12]
341a0b32:	78fa      	ldrb	r2, [r7, #3]
341a0b34:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return 0;
341a0b38:	2300      	movs	r3, #0
}
341a0b3a:	4618      	mov	r0, r3
341a0b3c:	3710      	adds	r7, #16
341a0b3e:	46bd      	mov	sp, r7
341a0b40:	bd80      	pop	{r7, pc}
	...

341a0b44 <VD6G_GetAnalogGainRegRange>:

int VD6G_GetAnalogGainRegRange(VD6G_Ctx_t *ctx, uint8_t *AGmin, uint8_t *AGmax)
{
341a0b44:	b580      	push	{r7, lr}
341a0b46:	b088      	sub	sp, #32
341a0b48:	af02      	add	r7, sp, #8
341a0b4a:	60f8      	str	r0, [r7, #12]
341a0b4c:	60b9      	str	r1, [r7, #8]
341a0b4e:	607a      	str	r2, [r7, #4]
  int ret;
  uint8_t value;

  if ((AGmin == NULL) || (AGmax == NULL))
341a0b50:	68bb      	ldr	r3, [r7, #8]
341a0b52:	2b00      	cmp	r3, #0
341a0b54:	d002      	beq.n	341a0b5c <VD6G_GetAnalogGainRegRange+0x18>
341a0b56:	687b      	ldr	r3, [r7, #4]
341a0b58:	2b00      	cmp	r3, #0
341a0b5a:	d102      	bne.n	341a0b62 <VD6G_GetAnalogGainRegRange+0x1e>
    return -1;
341a0b5c:	f04f 33ff 	mov.w	r3, #4294967295
341a0b60:	e04c      	b.n	341a0bfc <VD6G_GetAnalogGainRegRange+0xb8>

  ret = ctx->read8(ctx, VD6G_REG_MIN_AG_CODED, &value);
341a0b62:	68fb      	ldr	r3, [r7, #12]
341a0b64:	685b      	ldr	r3, [r3, #4]
341a0b66:	f107 0213 	add.w	r2, r7, #19
341a0b6a:	f640 117e 	movw	r1, #2430	@ 0x97e
341a0b6e:	68f8      	ldr	r0, [r7, #12]
341a0b70:	4798      	blx	r3
341a0b72:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a0b74:	697b      	ldr	r3, [r7, #20]
341a0b76:	2b00      	cmp	r3, #0
341a0b78:	d008      	beq.n	341a0b8c <VD6G_GetAnalogGainRegRange+0x48>
341a0b7a:	697b      	ldr	r3, [r7, #20]
341a0b7c:	9300      	str	r3, [sp, #0]
341a0b7e:	f44f 6399 	mov.w	r3, #1224	@ 0x4c8
341a0b82:	4a20      	ldr	r2, [pc, #128]	@ (341a0c04 <VD6G_GetAnalogGainRegRange+0xc0>)
341a0b84:	4920      	ldr	r1, [pc, #128]	@ (341a0c08 <VD6G_GetAnalogGainRegRange+0xc4>)
341a0b86:	68f8      	ldr	r0, [r7, #12]
341a0b88:	f7fe fae9 	bl	3419f15e <VD6G_error>
341a0b8c:	697b      	ldr	r3, [r7, #20]
341a0b8e:	2b00      	cmp	r3, #0
341a0b90:	d002      	beq.n	341a0b98 <VD6G_GetAnalogGainRegRange+0x54>
341a0b92:	68f8      	ldr	r0, [r7, #12]
341a0b94:	f7fe fafe 	bl	3419f194 <display_error>
341a0b98:	697b      	ldr	r3, [r7, #20]
341a0b9a:	2b00      	cmp	r3, #0
341a0b9c:	d001      	beq.n	341a0ba2 <VD6G_GetAnalogGainRegRange+0x5e>
341a0b9e:	697b      	ldr	r3, [r7, #20]
341a0ba0:	e02c      	b.n	341a0bfc <VD6G_GetAnalogGainRegRange+0xb8>
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
341a0ba2:	7cfb      	ldrb	r3, [r7, #19]
341a0ba4:	f003 031f 	and.w	r3, r3, #31
341a0ba8:	b2da      	uxtb	r2, r3
341a0baa:	68bb      	ldr	r3, [r7, #8]
341a0bac:	701a      	strb	r2, [r3, #0]

  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
341a0bae:	68fb      	ldr	r3, [r7, #12]
341a0bb0:	685b      	ldr	r3, [r3, #4]
341a0bb2:	f107 0213 	add.w	r2, r7, #19
341a0bb6:	f44f 6116 	mov.w	r1, #2400	@ 0x960
341a0bba:	68f8      	ldr	r0, [r7, #12]
341a0bbc:	4798      	blx	r3
341a0bbe:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a0bc0:	697b      	ldr	r3, [r7, #20]
341a0bc2:	2b00      	cmp	r3, #0
341a0bc4:	d008      	beq.n	341a0bd8 <VD6G_GetAnalogGainRegRange+0x94>
341a0bc6:	697b      	ldr	r3, [r7, #20]
341a0bc8:	9300      	str	r3, [sp, #0]
341a0bca:	f240 43cc 	movw	r3, #1228	@ 0x4cc
341a0bce:	4a0d      	ldr	r2, [pc, #52]	@ (341a0c04 <VD6G_GetAnalogGainRegRange+0xc0>)
341a0bd0:	490d      	ldr	r1, [pc, #52]	@ (341a0c08 <VD6G_GetAnalogGainRegRange+0xc4>)
341a0bd2:	68f8      	ldr	r0, [r7, #12]
341a0bd4:	f7fe fac3 	bl	3419f15e <VD6G_error>
341a0bd8:	697b      	ldr	r3, [r7, #20]
341a0bda:	2b00      	cmp	r3, #0
341a0bdc:	d002      	beq.n	341a0be4 <VD6G_GetAnalogGainRegRange+0xa0>
341a0bde:	68f8      	ldr	r0, [r7, #12]
341a0be0:	f7fe fad8 	bl	3419f194 <display_error>
341a0be4:	697b      	ldr	r3, [r7, #20]
341a0be6:	2b00      	cmp	r3, #0
341a0be8:	d001      	beq.n	341a0bee <VD6G_GetAnalogGainRegRange+0xaa>
341a0bea:	697b      	ldr	r3, [r7, #20]
341a0bec:	e006      	b.n	341a0bfc <VD6G_GetAnalogGainRegRange+0xb8>
  *AGmax = value & VD6G_REG_MAX_AG_CODED_MASK;
341a0bee:	7cfb      	ldrb	r3, [r7, #19]
341a0bf0:	f003 031f 	and.w	r3, r3, #31
341a0bf4:	b2da      	uxtb	r2, r3
341a0bf6:	687b      	ldr	r3, [r7, #4]
341a0bf8:	701a      	strb	r2, [r3, #0]

  return 0;
341a0bfa:	2300      	movs	r3, #0
}
341a0bfc:	4618      	mov	r0, r3
341a0bfe:	3718      	adds	r7, #24
341a0c00:	46bd      	mov	sp, r7
341a0c02:	bd80      	pop	{r7, pc}
341a0c04:	341b75d0 	.word	0x341b75d0
341a0c08:	341a6494 	.word	0x341a6494

341a0c0c <VD6G_SetAnalogGain>:

int VD6G_SetAnalogGain(VD6G_Ctx_t *ctx, int gain)
{
341a0c0c:	b580      	push	{r7, lr}
341a0c0e:	b086      	sub	sp, #24
341a0c10:	af02      	add	r7, sp, #8
341a0c12:	6078      	str	r0, [r7, #4]
341a0c14:	6039      	str	r1, [r7, #0]
  int ret;
  uint8_t again_regmin, again_regmax;

  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
341a0c16:	f107 020a 	add.w	r2, r7, #10
341a0c1a:	f107 030b 	add.w	r3, r7, #11
341a0c1e:	4619      	mov	r1, r3
341a0c20:	6878      	ldr	r0, [r7, #4]
341a0c22:	f7ff ff8f 	bl	341a0b44 <VD6G_GetAnalogGainRegRange>
341a0c26:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0c28:	68fb      	ldr	r3, [r7, #12]
341a0c2a:	2b00      	cmp	r3, #0
341a0c2c:	d001      	beq.n	341a0c32 <VD6G_SetAnalogGain+0x26>
    return ret;
341a0c2e:	68fb      	ldr	r3, [r7, #12]
341a0c30:	e034      	b.n	341a0c9c <VD6G_SetAnalogGain+0x90>

  ret = CHECK_RANGE(gain, again_regmin, again_regmax);
341a0c32:	7afb      	ldrb	r3, [r7, #11]
341a0c34:	461a      	mov	r2, r3
341a0c36:	683b      	ldr	r3, [r7, #0]
341a0c38:	4293      	cmp	r3, r2
341a0c3a:	db06      	blt.n	341a0c4a <VD6G_SetAnalogGain+0x3e>
341a0c3c:	7abb      	ldrb	r3, [r7, #10]
341a0c3e:	461a      	mov	r2, r3
341a0c40:	683b      	ldr	r3, [r7, #0]
341a0c42:	4293      	cmp	r3, r2
341a0c44:	dc01      	bgt.n	341a0c4a <VD6G_SetAnalogGain+0x3e>
341a0c46:	2300      	movs	r3, #0
341a0c48:	e001      	b.n	341a0c4e <VD6G_SetAnalogGain+0x42>
341a0c4a:	f04f 33ff 	mov.w	r3, #4294967295
341a0c4e:	60fb      	str	r3, [r7, #12]
  if (ret)
341a0c50:	68fb      	ldr	r3, [r7, #12]
341a0c52:	2b00      	cmp	r3, #0
341a0c54:	d001      	beq.n	341a0c5a <VD6G_SetAnalogGain+0x4e>
    return ret;
341a0c56:	68fb      	ldr	r3, [r7, #12]
341a0c58:	e020      	b.n	341a0c9c <VD6G_SetAnalogGain+0x90>

  ret = ctx->write8(ctx, VD6G_REG_MANUAL_ANALOG_GAIN, gain);
341a0c5a:	687b      	ldr	r3, [r7, #4]
341a0c5c:	691b      	ldr	r3, [r3, #16]
341a0c5e:	683a      	ldr	r2, [r7, #0]
341a0c60:	b2d2      	uxtb	r2, r2
341a0c62:	f240 414d 	movw	r1, #1101	@ 0x44d
341a0c66:	6878      	ldr	r0, [r7, #4]
341a0c68:	4798      	blx	r3
341a0c6a:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0c6c:	68fb      	ldr	r3, [r7, #12]
341a0c6e:	2b00      	cmp	r3, #0
341a0c70:	d008      	beq.n	341a0c84 <VD6G_SetAnalogGain+0x78>
341a0c72:	68fb      	ldr	r3, [r7, #12]
341a0c74:	9300      	str	r3, [sp, #0]
341a0c76:	f44f 639c 	mov.w	r3, #1248	@ 0x4e0
341a0c7a:	4a0a      	ldr	r2, [pc, #40]	@ (341a0ca4 <VD6G_SetAnalogGain+0x98>)
341a0c7c:	490a      	ldr	r1, [pc, #40]	@ (341a0ca8 <VD6G_SetAnalogGain+0x9c>)
341a0c7e:	6878      	ldr	r0, [r7, #4]
341a0c80:	f7fe fa6d 	bl	3419f15e <VD6G_error>
341a0c84:	68fb      	ldr	r3, [r7, #12]
341a0c86:	2b00      	cmp	r3, #0
341a0c88:	d002      	beq.n	341a0c90 <VD6G_SetAnalogGain+0x84>
341a0c8a:	6878      	ldr	r0, [r7, #4]
341a0c8c:	f7fe fa82 	bl	3419f194 <display_error>
341a0c90:	68fb      	ldr	r3, [r7, #12]
341a0c92:	2b00      	cmp	r3, #0
341a0c94:	d001      	beq.n	341a0c9a <VD6G_SetAnalogGain+0x8e>
341a0c96:	68fb      	ldr	r3, [r7, #12]
341a0c98:	e000      	b.n	341a0c9c <VD6G_SetAnalogGain+0x90>

  return 0;
341a0c9a:	2300      	movs	r3, #0
}
341a0c9c:	4618      	mov	r0, r3
341a0c9e:	3710      	adds	r7, #16
341a0ca0:	46bd      	mov	sp, r7
341a0ca2:	bd80      	pop	{r7, pc}
341a0ca4:	341b75ec 	.word	0x341b75ec
341a0ca8:	341a6494 	.word	0x341a6494

341a0cac <VD6G_GetDigitalGainRegRange>:

int VD6G_GetDigitalGainRegRange(VD6G_Ctx_t *ctx, uint16_t *DGmin, uint16_t *DGmax)
{
341a0cac:	b580      	push	{r7, lr}
341a0cae:	b088      	sub	sp, #32
341a0cb0:	af02      	add	r7, sp, #8
341a0cb2:	60f8      	str	r0, [r7, #12]
341a0cb4:	60b9      	str	r1, [r7, #8]
341a0cb6:	607a      	str	r2, [r7, #4]
  int ret;

  if ((DGmin == NULL) && (DGmax == NULL))
341a0cb8:	68bb      	ldr	r3, [r7, #8]
341a0cba:	2b00      	cmp	r3, #0
341a0cbc:	d105      	bne.n	341a0cca <VD6G_GetDigitalGainRegRange+0x1e>
341a0cbe:	687b      	ldr	r3, [r7, #4]
341a0cc0:	2b00      	cmp	r3, #0
341a0cc2:	d102      	bne.n	341a0cca <VD6G_GetDigitalGainRegRange+0x1e>
    return -1;
341a0cc4:	f04f 33ff 	mov.w	r3, #4294967295
341a0cc8:	e03e      	b.n	341a0d48 <VD6G_GetDigitalGainRegRange+0x9c>

  ret = ctx->read16(ctx, VD6G_REG_MIN_DG, DGmin);
341a0cca:	68fb      	ldr	r3, [r7, #12]
341a0ccc:	689b      	ldr	r3, [r3, #8]
341a0cce:	68ba      	ldr	r2, [r7, #8]
341a0cd0:	f640 117c 	movw	r1, #2428	@ 0x97c
341a0cd4:	68f8      	ldr	r0, [r7, #12]
341a0cd6:	4798      	blx	r3
341a0cd8:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a0cda:	697b      	ldr	r3, [r7, #20]
341a0cdc:	2b00      	cmp	r3, #0
341a0cde:	d008      	beq.n	341a0cf2 <VD6G_GetDigitalGainRegRange+0x46>
341a0ce0:	697b      	ldr	r3, [r7, #20]
341a0ce2:	9300      	str	r3, [sp, #0]
341a0ce4:	f240 43ed 	movw	r3, #1261	@ 0x4ed
341a0ce8:	4a19      	ldr	r2, [pc, #100]	@ (341a0d50 <VD6G_GetDigitalGainRegRange+0xa4>)
341a0cea:	491a      	ldr	r1, [pc, #104]	@ (341a0d54 <VD6G_GetDigitalGainRegRange+0xa8>)
341a0cec:	68f8      	ldr	r0, [r7, #12]
341a0cee:	f7fe fa36 	bl	3419f15e <VD6G_error>
341a0cf2:	697b      	ldr	r3, [r7, #20]
341a0cf4:	2b00      	cmp	r3, #0
341a0cf6:	d002      	beq.n	341a0cfe <VD6G_GetDigitalGainRegRange+0x52>
341a0cf8:	68f8      	ldr	r0, [r7, #12]
341a0cfa:	f7fe fa4b 	bl	3419f194 <display_error>
341a0cfe:	697b      	ldr	r3, [r7, #20]
341a0d00:	2b00      	cmp	r3, #0
341a0d02:	d001      	beq.n	341a0d08 <VD6G_GetDigitalGainRegRange+0x5c>
341a0d04:	697b      	ldr	r3, [r7, #20]
341a0d06:	e01f      	b.n	341a0d48 <VD6G_GetDigitalGainRegRange+0x9c>

  ret = ctx->read16(ctx, VD6G_REG_MAX_DG, DGmax);
341a0d08:	68fb      	ldr	r3, [r7, #12]
341a0d0a:	689b      	ldr	r3, [r3, #8]
341a0d0c:	687a      	ldr	r2, [r7, #4]
341a0d0e:	f640 115e 	movw	r1, #2398	@ 0x95e
341a0d12:	68f8      	ldr	r0, [r7, #12]
341a0d14:	4798      	blx	r3
341a0d16:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a0d18:	697b      	ldr	r3, [r7, #20]
341a0d1a:	2b00      	cmp	r3, #0
341a0d1c:	d008      	beq.n	341a0d30 <VD6G_GetDigitalGainRegRange+0x84>
341a0d1e:	697b      	ldr	r3, [r7, #20]
341a0d20:	9300      	str	r3, [sp, #0]
341a0d22:	f44f 639e 	mov.w	r3, #1264	@ 0x4f0
341a0d26:	4a0a      	ldr	r2, [pc, #40]	@ (341a0d50 <VD6G_GetDigitalGainRegRange+0xa4>)
341a0d28:	490a      	ldr	r1, [pc, #40]	@ (341a0d54 <VD6G_GetDigitalGainRegRange+0xa8>)
341a0d2a:	68f8      	ldr	r0, [r7, #12]
341a0d2c:	f7fe fa17 	bl	3419f15e <VD6G_error>
341a0d30:	697b      	ldr	r3, [r7, #20]
341a0d32:	2b00      	cmp	r3, #0
341a0d34:	d002      	beq.n	341a0d3c <VD6G_GetDigitalGainRegRange+0x90>
341a0d36:	68f8      	ldr	r0, [r7, #12]
341a0d38:	f7fe fa2c 	bl	3419f194 <display_error>
341a0d3c:	697b      	ldr	r3, [r7, #20]
341a0d3e:	2b00      	cmp	r3, #0
341a0d40:	d001      	beq.n	341a0d46 <VD6G_GetDigitalGainRegRange+0x9a>
341a0d42:	697b      	ldr	r3, [r7, #20]
341a0d44:	e000      	b.n	341a0d48 <VD6G_GetDigitalGainRegRange+0x9c>

  return 0;
341a0d46:	2300      	movs	r3, #0
}
341a0d48:	4618      	mov	r0, r3
341a0d4a:	3718      	adds	r7, #24
341a0d4c:	46bd      	mov	sp, r7
341a0d4e:	bd80      	pop	{r7, pc}
341a0d50:	341b7600 	.word	0x341b7600
341a0d54:	341a6494 	.word	0x341a6494

341a0d58 <VD6G_SetDigitalGain>:

int VD6G_SetDigitalGain(VD6G_Ctx_t *ctx, int gain)
{
341a0d58:	b580      	push	{r7, lr}
341a0d5a:	b086      	sub	sp, #24
341a0d5c:	af02      	add	r7, sp, #8
341a0d5e:	6078      	str	r0, [r7, #4]
341a0d60:	6039      	str	r1, [r7, #0]
  int ret;
  uint16_t dgain_regmin, dgain_regmax;

  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
341a0d62:	f107 0208 	add.w	r2, r7, #8
341a0d66:	f107 030a 	add.w	r3, r7, #10
341a0d6a:	4619      	mov	r1, r3
341a0d6c:	6878      	ldr	r0, [r7, #4]
341a0d6e:	f7ff ff9d 	bl	341a0cac <VD6G_GetDigitalGainRegRange>
341a0d72:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0d74:	68fb      	ldr	r3, [r7, #12]
341a0d76:	2b00      	cmp	r3, #0
341a0d78:	d001      	beq.n	341a0d7e <VD6G_SetDigitalGain+0x26>
    return ret;
341a0d7a:	68fb      	ldr	r3, [r7, #12]
341a0d7c:	e094      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  ret = CHECK_RANGE(gain, dgain_regmin, dgain_regmax);
341a0d7e:	897b      	ldrh	r3, [r7, #10]
341a0d80:	461a      	mov	r2, r3
341a0d82:	683b      	ldr	r3, [r7, #0]
341a0d84:	4293      	cmp	r3, r2
341a0d86:	db06      	blt.n	341a0d96 <VD6G_SetDigitalGain+0x3e>
341a0d88:	893b      	ldrh	r3, [r7, #8]
341a0d8a:	461a      	mov	r2, r3
341a0d8c:	683b      	ldr	r3, [r7, #0]
341a0d8e:	4293      	cmp	r3, r2
341a0d90:	dc01      	bgt.n	341a0d96 <VD6G_SetDigitalGain+0x3e>
341a0d92:	2300      	movs	r3, #0
341a0d94:	e001      	b.n	341a0d9a <VD6G_SetDigitalGain+0x42>
341a0d96:	f04f 33ff 	mov.w	r3, #4294967295
341a0d9a:	60fb      	str	r3, [r7, #12]
  if (ret)
341a0d9c:	68fb      	ldr	r3, [r7, #12]
341a0d9e:	2b00      	cmp	r3, #0
341a0da0:	d001      	beq.n	341a0da6 <VD6G_SetDigitalGain+0x4e>
    return ret;
341a0da2:	68fb      	ldr	r3, [r7, #12]
341a0da4:	e080      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH0_DIGITAL_GAIN, gain);
341a0da6:	687b      	ldr	r3, [r7, #4]
341a0da8:	695b      	ldr	r3, [r3, #20]
341a0daa:	683a      	ldr	r2, [r7, #0]
341a0dac:	b292      	uxth	r2, r2
341a0dae:	f44f 618a 	mov.w	r1, #1104	@ 0x450
341a0db2:	6878      	ldr	r0, [r7, #4]
341a0db4:	4798      	blx	r3
341a0db6:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0db8:	68fb      	ldr	r3, [r7, #12]
341a0dba:	2b00      	cmp	r3, #0
341a0dbc:	d008      	beq.n	341a0dd0 <VD6G_SetDigitalGain+0x78>
341a0dbe:	68fb      	ldr	r3, [r7, #12]
341a0dc0:	9300      	str	r3, [sp, #0]
341a0dc2:	f240 5303 	movw	r3, #1283	@ 0x503
341a0dc6:	4a3a      	ldr	r2, [pc, #232]	@ (341a0eb0 <VD6G_SetDigitalGain+0x158>)
341a0dc8:	493a      	ldr	r1, [pc, #232]	@ (341a0eb4 <VD6G_SetDigitalGain+0x15c>)
341a0dca:	6878      	ldr	r0, [r7, #4]
341a0dcc:	f7fe f9c7 	bl	3419f15e <VD6G_error>
341a0dd0:	68fb      	ldr	r3, [r7, #12]
341a0dd2:	2b00      	cmp	r3, #0
341a0dd4:	d002      	beq.n	341a0ddc <VD6G_SetDigitalGain+0x84>
341a0dd6:	6878      	ldr	r0, [r7, #4]
341a0dd8:	f7fe f9dc 	bl	3419f194 <display_error>
341a0ddc:	68fb      	ldr	r3, [r7, #12]
341a0dde:	2b00      	cmp	r3, #0
341a0de0:	d001      	beq.n	341a0de6 <VD6G_SetDigitalGain+0x8e>
341a0de2:	68fb      	ldr	r3, [r7, #12]
341a0de4:	e060      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH1_DIGITAL_GAIN, gain);
341a0de6:	687b      	ldr	r3, [r7, #4]
341a0de8:	695b      	ldr	r3, [r3, #20]
341a0dea:	683a      	ldr	r2, [r7, #0]
341a0dec:	b292      	uxth	r2, r2
341a0dee:	f240 4152 	movw	r1, #1106	@ 0x452
341a0df2:	6878      	ldr	r0, [r7, #4]
341a0df4:	4798      	blx	r3
341a0df6:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0df8:	68fb      	ldr	r3, [r7, #12]
341a0dfa:	2b00      	cmp	r3, #0
341a0dfc:	d008      	beq.n	341a0e10 <VD6G_SetDigitalGain+0xb8>
341a0dfe:	68fb      	ldr	r3, [r7, #12]
341a0e00:	9300      	str	r3, [sp, #0]
341a0e02:	f240 5306 	movw	r3, #1286	@ 0x506
341a0e06:	4a2a      	ldr	r2, [pc, #168]	@ (341a0eb0 <VD6G_SetDigitalGain+0x158>)
341a0e08:	492a      	ldr	r1, [pc, #168]	@ (341a0eb4 <VD6G_SetDigitalGain+0x15c>)
341a0e0a:	6878      	ldr	r0, [r7, #4]
341a0e0c:	f7fe f9a7 	bl	3419f15e <VD6G_error>
341a0e10:	68fb      	ldr	r3, [r7, #12]
341a0e12:	2b00      	cmp	r3, #0
341a0e14:	d002      	beq.n	341a0e1c <VD6G_SetDigitalGain+0xc4>
341a0e16:	6878      	ldr	r0, [r7, #4]
341a0e18:	f7fe f9bc 	bl	3419f194 <display_error>
341a0e1c:	68fb      	ldr	r3, [r7, #12]
341a0e1e:	2b00      	cmp	r3, #0
341a0e20:	d001      	beq.n	341a0e26 <VD6G_SetDigitalGain+0xce>
341a0e22:	68fb      	ldr	r3, [r7, #12]
341a0e24:	e040      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
341a0e26:	687b      	ldr	r3, [r7, #4]
341a0e28:	695b      	ldr	r3, [r3, #20]
341a0e2a:	683a      	ldr	r2, [r7, #0]
341a0e2c:	b292      	uxth	r2, r2
341a0e2e:	f240 4154 	movw	r1, #1108	@ 0x454
341a0e32:	6878      	ldr	r0, [r7, #4]
341a0e34:	4798      	blx	r3
341a0e36:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0e38:	68fb      	ldr	r3, [r7, #12]
341a0e3a:	2b00      	cmp	r3, #0
341a0e3c:	d008      	beq.n	341a0e50 <VD6G_SetDigitalGain+0xf8>
341a0e3e:	68fb      	ldr	r3, [r7, #12]
341a0e40:	9300      	str	r3, [sp, #0]
341a0e42:	f240 5309 	movw	r3, #1289	@ 0x509
341a0e46:	4a1a      	ldr	r2, [pc, #104]	@ (341a0eb0 <VD6G_SetDigitalGain+0x158>)
341a0e48:	491a      	ldr	r1, [pc, #104]	@ (341a0eb4 <VD6G_SetDigitalGain+0x15c>)
341a0e4a:	6878      	ldr	r0, [r7, #4]
341a0e4c:	f7fe f987 	bl	3419f15e <VD6G_error>
341a0e50:	68fb      	ldr	r3, [r7, #12]
341a0e52:	2b00      	cmp	r3, #0
341a0e54:	d002      	beq.n	341a0e5c <VD6G_SetDigitalGain+0x104>
341a0e56:	6878      	ldr	r0, [r7, #4]
341a0e58:	f7fe f99c 	bl	3419f194 <display_error>
341a0e5c:	68fb      	ldr	r3, [r7, #12]
341a0e5e:	2b00      	cmp	r3, #0
341a0e60:	d001      	beq.n	341a0e66 <VD6G_SetDigitalGain+0x10e>
341a0e62:	68fb      	ldr	r3, [r7, #12]
341a0e64:	e020      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
341a0e66:	687b      	ldr	r3, [r7, #4]
341a0e68:	695b      	ldr	r3, [r3, #20]
341a0e6a:	683a      	ldr	r2, [r7, #0]
341a0e6c:	b292      	uxth	r2, r2
341a0e6e:	f240 4156 	movw	r1, #1110	@ 0x456
341a0e72:	6878      	ldr	r0, [r7, #4]
341a0e74:	4798      	blx	r3
341a0e76:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0e78:	68fb      	ldr	r3, [r7, #12]
341a0e7a:	2b00      	cmp	r3, #0
341a0e7c:	d008      	beq.n	341a0e90 <VD6G_SetDigitalGain+0x138>
341a0e7e:	68fb      	ldr	r3, [r7, #12]
341a0e80:	9300      	str	r3, [sp, #0]
341a0e82:	f240 530c 	movw	r3, #1292	@ 0x50c
341a0e86:	4a0a      	ldr	r2, [pc, #40]	@ (341a0eb0 <VD6G_SetDigitalGain+0x158>)
341a0e88:	490a      	ldr	r1, [pc, #40]	@ (341a0eb4 <VD6G_SetDigitalGain+0x15c>)
341a0e8a:	6878      	ldr	r0, [r7, #4]
341a0e8c:	f7fe f967 	bl	3419f15e <VD6G_error>
341a0e90:	68fb      	ldr	r3, [r7, #12]
341a0e92:	2b00      	cmp	r3, #0
341a0e94:	d002      	beq.n	341a0e9c <VD6G_SetDigitalGain+0x144>
341a0e96:	6878      	ldr	r0, [r7, #4]
341a0e98:	f7fe f97c 	bl	3419f194 <display_error>
341a0e9c:	68fb      	ldr	r3, [r7, #12]
341a0e9e:	2b00      	cmp	r3, #0
341a0ea0:	d001      	beq.n	341a0ea6 <VD6G_SetDigitalGain+0x14e>
341a0ea2:	68fb      	ldr	r3, [r7, #12]
341a0ea4:	e000      	b.n	341a0ea8 <VD6G_SetDigitalGain+0x150>

  return 0;
341a0ea6:	2300      	movs	r3, #0
}
341a0ea8:	4618      	mov	r0, r3
341a0eaa:	3710      	adds	r7, #16
341a0eac:	46bd      	mov	sp, r7
341a0eae:	bd80      	pop	{r7, pc}
341a0eb0:	341b761c 	.word	0x341b761c
341a0eb4:	341a6494 	.word	0x341a6494

341a0eb8 <VD6G_GetExposureRegRange>:

int VD6G_GetExposureRegRange(VD6G_Ctx_t *ctx, uint32_t *min_us, uint32_t *max_us)
{
341a0eb8:	b580      	push	{r7, lr}
341a0eba:	b08a      	sub	sp, #40	@ 0x28
341a0ebc:	af02      	add	r7, sp, #8
341a0ebe:	60f8      	str	r0, [r7, #12]
341a0ec0:	60b9      	str	r1, [r7, #8]
341a0ec2:	607a      	str	r2, [r7, #4]
  uint16_t exp_coarse_intg_margin;
  uint32_t line_time_in_us;
  uint16_t frame_length;
  int ret;

  if ((min_us == NULL) || (max_us == NULL))
341a0ec4:	68bb      	ldr	r3, [r7, #8]
341a0ec6:	2b00      	cmp	r3, #0
341a0ec8:	d002      	beq.n	341a0ed0 <VD6G_GetExposureRegRange+0x18>
341a0eca:	687b      	ldr	r3, [r7, #4]
341a0ecc:	2b00      	cmp	r3, #0
341a0ece:	d102      	bne.n	341a0ed6 <VD6G_GetExposureRegRange+0x1e>
    return -1;
341a0ed0:	f04f 33ff 	mov.w	r3, #4294967295
341a0ed4:	e065      	b.n	341a0fa2 <VD6G_GetExposureRegRange+0xea>

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
341a0ed6:	f107 0314 	add.w	r3, r7, #20
341a0eda:	4619      	mov	r1, r3
341a0edc:	68f8      	ldr	r0, [r7, #12]
341a0ede:	f7fe f9cf 	bl	3419f280 <VD6G_GetLineTimeInUs>
341a0ee2:	61f8      	str	r0, [r7, #28]
  if (ret)
341a0ee4:	69fb      	ldr	r3, [r7, #28]
341a0ee6:	2b00      	cmp	r3, #0
341a0ee8:	d001      	beq.n	341a0eee <VD6G_GetExposureRegRange+0x36>
    return ret;
341a0eea:	69fb      	ldr	r3, [r7, #28]
341a0eec:	e059      	b.n	341a0fa2 <VD6G_GetExposureRegRange+0xea>

  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
341a0eee:	697a      	ldr	r2, [r7, #20]
341a0ef0:	4613      	mov	r3, r2
341a0ef2:	005b      	lsls	r3, r3, #1
341a0ef4:	4413      	add	r3, r2
341a0ef6:	00da      	lsls	r2, r3, #3
341a0ef8:	1ad2      	subs	r2, r2, r3
341a0efa:	68bb      	ldr	r3, [r7, #8]
341a0efc:	601a      	str	r2, [r3, #0]

  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
341a0efe:	68fb      	ldr	r3, [r7, #12]
341a0f00:	689b      	ldr	r3, [r3, #8]
341a0f02:	f107 0212 	add.w	r2, r7, #18
341a0f06:	f44f 618b 	mov.w	r1, #1112	@ 0x458
341a0f0a:	68f8      	ldr	r0, [r7, #12]
341a0f0c:	4798      	blx	r3
341a0f0e:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
341a0f10:	69fb      	ldr	r3, [r7, #28]
341a0f12:	2b00      	cmp	r3, #0
341a0f14:	d008      	beq.n	341a0f28 <VD6G_GetExposureRegRange+0x70>
341a0f16:	69fb      	ldr	r3, [r7, #28]
341a0f18:	9300      	str	r3, [sp, #0]
341a0f1a:	f240 5322 	movw	r3, #1314	@ 0x522
341a0f1e:	4a23      	ldr	r2, [pc, #140]	@ (341a0fac <VD6G_GetExposureRegRange+0xf4>)
341a0f20:	4923      	ldr	r1, [pc, #140]	@ (341a0fb0 <VD6G_GetExposureRegRange+0xf8>)
341a0f22:	68f8      	ldr	r0, [r7, #12]
341a0f24:	f7fe f91b 	bl	3419f15e <VD6G_error>
341a0f28:	69fb      	ldr	r3, [r7, #28]
341a0f2a:	2b00      	cmp	r3, #0
341a0f2c:	d002      	beq.n	341a0f34 <VD6G_GetExposureRegRange+0x7c>
341a0f2e:	68f8      	ldr	r0, [r7, #12]
341a0f30:	f7fe f930 	bl	3419f194 <display_error>
341a0f34:	69fb      	ldr	r3, [r7, #28]
341a0f36:	2b00      	cmp	r3, #0
341a0f38:	d001      	beq.n	341a0f3e <VD6G_GetExposureRegRange+0x86>
341a0f3a:	69fb      	ldr	r3, [r7, #28]
341a0f3c:	e031      	b.n	341a0fa2 <VD6G_GetExposureRegRange+0xea>

  ret = ctx->read16(ctx, VD6G_REG_EXP_COARSE_INTG_MARGIN, &exp_coarse_intg_margin);
341a0f3e:	68fb      	ldr	r3, [r7, #12]
341a0f40:	689b      	ldr	r3, [r3, #8]
341a0f42:	f107 021a 	add.w	r2, r7, #26
341a0f46:	f640 1146 	movw	r1, #2374	@ 0x946
341a0f4a:	68f8      	ldr	r0, [r7, #12]
341a0f4c:	4798      	blx	r3
341a0f4e:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
341a0f50:	69fb      	ldr	r3, [r7, #28]
341a0f52:	2b00      	cmp	r3, #0
341a0f54:	d008      	beq.n	341a0f68 <VD6G_GetExposureRegRange+0xb0>
341a0f56:	69fb      	ldr	r3, [r7, #28]
341a0f58:	9300      	str	r3, [sp, #0]
341a0f5a:	f240 5325 	movw	r3, #1317	@ 0x525
341a0f5e:	4a13      	ldr	r2, [pc, #76]	@ (341a0fac <VD6G_GetExposureRegRange+0xf4>)
341a0f60:	4913      	ldr	r1, [pc, #76]	@ (341a0fb0 <VD6G_GetExposureRegRange+0xf8>)
341a0f62:	68f8      	ldr	r0, [r7, #12]
341a0f64:	f7fe f8fb 	bl	3419f15e <VD6G_error>
341a0f68:	69fb      	ldr	r3, [r7, #28]
341a0f6a:	2b00      	cmp	r3, #0
341a0f6c:	d002      	beq.n	341a0f74 <VD6G_GetExposureRegRange+0xbc>
341a0f6e:	68f8      	ldr	r0, [r7, #12]
341a0f70:	f7fe f910 	bl	3419f194 <display_error>
341a0f74:	69fb      	ldr	r3, [r7, #28]
341a0f76:	2b00      	cmp	r3, #0
341a0f78:	d001      	beq.n	341a0f7e <VD6G_GetExposureRegRange+0xc6>
341a0f7a:	69fb      	ldr	r3, [r7, #28]
341a0f7c:	e011      	b.n	341a0fa2 <VD6G_GetExposureRegRange+0xea>

  if (exp_coarse_intg_margin >= VD6G_MIN_EXP_COARSE_INTG_MARGIN)
341a0f7e:	8b7b      	ldrh	r3, [r7, #26]
341a0f80:	2b43      	cmp	r3, #67	@ 0x43
341a0f82:	d90c      	bls.n	341a0f9e <VD6G_GetExposureRegRange+0xe6>
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
341a0f84:	8a7b      	ldrh	r3, [r7, #18]
341a0f86:	461a      	mov	r2, r3
341a0f88:	8b7b      	ldrh	r3, [r7, #26]
341a0f8a:	1ad3      	subs	r3, r2, r3
341a0f8c:	3b07      	subs	r3, #7
341a0f8e:	461a      	mov	r2, r3
341a0f90:	697b      	ldr	r3, [r7, #20]
341a0f92:	fb03 f202 	mul.w	r2, r3, r2
341a0f96:	687b      	ldr	r3, [r7, #4]
341a0f98:	601a      	str	r2, [r3, #0]
  else
    return -1;

  return 0;
341a0f9a:	2300      	movs	r3, #0
341a0f9c:	e001      	b.n	341a0fa2 <VD6G_GetExposureRegRange+0xea>
    return -1;
341a0f9e:	f04f 33ff 	mov.w	r3, #4294967295
}
341a0fa2:	4618      	mov	r0, r3
341a0fa4:	3720      	adds	r7, #32
341a0fa6:	46bd      	mov	sp, r7
341a0fa8:	bd80      	pop	{r7, pc}
341a0faa:	bf00      	nop
341a0fac:	341b7630 	.word	0x341b7630
341a0fb0:	341a6494 	.word	0x341a6494

341a0fb4 <VD6G_SetExposureTime>:

int VD6G_SetExposureTime(VD6G_Ctx_t *ctx, int exposure_us)
{
341a0fb4:	b580      	push	{r7, lr}
341a0fb6:	b088      	sub	sp, #32
341a0fb8:	af02      	add	r7, sp, #8
341a0fba:	6078      	str	r0, [r7, #4]
341a0fbc:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint32_t exp_min, exp_max;
  uint32_t line_time_in_us;

  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
341a0fbe:	f107 020c 	add.w	r2, r7, #12
341a0fc2:	f107 0310 	add.w	r3, r7, #16
341a0fc6:	4619      	mov	r1, r3
341a0fc8:	6878      	ldr	r0, [r7, #4]
341a0fca:	f7ff ff75 	bl	341a0eb8 <VD6G_GetExposureRegRange>
341a0fce:	6178      	str	r0, [r7, #20]
  if (ret)
341a0fd0:	697b      	ldr	r3, [r7, #20]
341a0fd2:	2b00      	cmp	r3, #0
341a0fd4:	d001      	beq.n	341a0fda <VD6G_SetExposureTime+0x26>
    return ret;
341a0fd6:	697b      	ldr	r3, [r7, #20]
341a0fd8:	e041      	b.n	341a105e <VD6G_SetExposureTime+0xaa>

  ret = CHECK_RANGE(exposure_us, exp_min, exp_max);
341a0fda:	683a      	ldr	r2, [r7, #0]
341a0fdc:	693b      	ldr	r3, [r7, #16]
341a0fde:	429a      	cmp	r2, r3
341a0fe0:	d305      	bcc.n	341a0fee <VD6G_SetExposureTime+0x3a>
341a0fe2:	683a      	ldr	r2, [r7, #0]
341a0fe4:	68fb      	ldr	r3, [r7, #12]
341a0fe6:	429a      	cmp	r2, r3
341a0fe8:	d801      	bhi.n	341a0fee <VD6G_SetExposureTime+0x3a>
341a0fea:	2300      	movs	r3, #0
341a0fec:	e001      	b.n	341a0ff2 <VD6G_SetExposureTime+0x3e>
341a0fee:	f04f 33ff 	mov.w	r3, #4294967295
341a0ff2:	617b      	str	r3, [r7, #20]
  if (ret)
341a0ff4:	697b      	ldr	r3, [r7, #20]
341a0ff6:	2b00      	cmp	r3, #0
341a0ff8:	d001      	beq.n	341a0ffe <VD6G_SetExposureTime+0x4a>
    return ret;
341a0ffa:	697b      	ldr	r3, [r7, #20]
341a0ffc:	e02f      	b.n	341a105e <VD6G_SetExposureTime+0xaa>

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
341a0ffe:	f107 0308 	add.w	r3, r7, #8
341a1002:	4619      	mov	r1, r3
341a1004:	6878      	ldr	r0, [r7, #4]
341a1006:	f7fe f93b 	bl	3419f280 <VD6G_GetLineTimeInUs>
341a100a:	6178      	str	r0, [r7, #20]
  if (ret)
341a100c:	697b      	ldr	r3, [r7, #20]
341a100e:	2b00      	cmp	r3, #0
341a1010:	d001      	beq.n	341a1016 <VD6G_SetExposureTime+0x62>
    return ret;
341a1012:	697b      	ldr	r3, [r7, #20]
341a1014:	e023      	b.n	341a105e <VD6G_SetExposureTime+0xaa>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_COARSE_EXP, CEIL(exposure_us / line_time_in_us));
341a1016:	687b      	ldr	r3, [r7, #4]
341a1018:	695b      	ldr	r3, [r3, #20]
341a101a:	6839      	ldr	r1, [r7, #0]
341a101c:	68ba      	ldr	r2, [r7, #8]
341a101e:	fbb1 f2f2 	udiv	r2, r1, r2
341a1022:	b292      	uxth	r2, r2
341a1024:	f240 414e 	movw	r1, #1102	@ 0x44e
341a1028:	6878      	ldr	r0, [r7, #4]
341a102a:	4798      	blx	r3
341a102c:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a102e:	697b      	ldr	r3, [r7, #20]
341a1030:	2b00      	cmp	r3, #0
341a1032:	d008      	beq.n	341a1046 <VD6G_SetExposureTime+0x92>
341a1034:	697b      	ldr	r3, [r7, #20]
341a1036:	9300      	str	r3, [sp, #0]
341a1038:	f240 5342 	movw	r3, #1346	@ 0x542
341a103c:	4a0a      	ldr	r2, [pc, #40]	@ (341a1068 <VD6G_SetExposureTime+0xb4>)
341a103e:	490b      	ldr	r1, [pc, #44]	@ (341a106c <VD6G_SetExposureTime+0xb8>)
341a1040:	6878      	ldr	r0, [r7, #4]
341a1042:	f7fe f88c 	bl	3419f15e <VD6G_error>
341a1046:	697b      	ldr	r3, [r7, #20]
341a1048:	2b00      	cmp	r3, #0
341a104a:	d002      	beq.n	341a1052 <VD6G_SetExposureTime+0x9e>
341a104c:	6878      	ldr	r0, [r7, #4]
341a104e:	f7fe f8a1 	bl	3419f194 <display_error>
341a1052:	697b      	ldr	r3, [r7, #20]
341a1054:	2b00      	cmp	r3, #0
341a1056:	d001      	beq.n	341a105c <VD6G_SetExposureTime+0xa8>
341a1058:	697b      	ldr	r3, [r7, #20]
341a105a:	e000      	b.n	341a105e <VD6G_SetExposureTime+0xaa>

  return 0;
341a105c:	2300      	movs	r3, #0
}
341a105e:	4618      	mov	r0, r3
341a1060:	3718      	adds	r7, #24
341a1062:	46bd      	mov	sp, r7
341a1064:	bd80      	pop	{r7, pc}
341a1066:	bf00      	nop
341a1068:	341b764c 	.word	0x341b764c
341a106c:	341a6494 	.word	0x341a6494

341a1070 <EXTMEM_Init>:
/** @defgroup EXTMEM_Exported_Functions External Memory Exported Functions
  * @{
  */

EXTMEM_StatusTypeDef EXTMEM_Init(uint32_t MemId, uint32_t ClockInput)
{
341a1070:	b580      	push	{r7, lr}
341a1072:	b084      	sub	sp, #16
341a1074:	af00      	add	r7, sp, #0
341a1076:	6078      	str	r0, [r7, #4]
341a1078:	6039      	str	r1, [r7, #0]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
341a107a:	23fb      	movs	r3, #251	@ 0xfb
341a107c:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();

  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
341a107e:	687b      	ldr	r3, [r7, #4]
341a1080:	2b01      	cmp	r3, #1
341a1082:	d855      	bhi.n	341a1130 <EXTMEM_Init+0xc0>
  {
    retr = EXTMEM_OK;
341a1084:	2300      	movs	r3, #0
341a1086:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
341a1088:	4a2c      	ldr	r2, [pc, #176]	@ (341a113c <EXTMEM_Init+0xcc>)
341a108a:	687b      	ldr	r3, [r7, #4]
341a108c:	21ac      	movs	r1, #172	@ 0xac
341a108e:	fb01 f303 	mul.w	r3, r1, r3
341a1092:	4413      	add	r3, r2
341a1094:	781b      	ldrb	r3, [r3, #0]
341a1096:	2b00      	cmp	r3, #0
341a1098:	d002      	beq.n	341a10a0 <EXTMEM_Init+0x30>
341a109a:	2b02      	cmp	r3, #2
341a109c:	d021      	beq.n	341a10e2 <EXTMEM_Init+0x72>
341a109e:	e041      	b.n	341a1124 <EXTMEM_Init+0xb4>
    {
#if EXTMEM_DRIVER_NOR_SFDP == 1
      case EXTMEM_NOR_SFDP:{
        /* Initialize the SFDP memory */
        if (EXTMEM_DRIVER_NOR_SFDP_OK != EXTMEM_DRIVER_NOR_SFDP_Init(extmem_list_config[MemId].Handle,
341a10a0:	4a26      	ldr	r2, [pc, #152]	@ (341a113c <EXTMEM_Init+0xcc>)
341a10a2:	687b      	ldr	r3, [r7, #4]
341a10a4:	21ac      	movs	r1, #172	@ 0xac
341a10a6:	fb01 f303 	mul.w	r3, r1, r3
341a10aa:	4413      	add	r3, r2
341a10ac:	3304      	adds	r3, #4
341a10ae:	6818      	ldr	r0, [r3, #0]
341a10b0:	4a22      	ldr	r2, [pc, #136]	@ (341a113c <EXTMEM_Init+0xcc>)
341a10b2:	687b      	ldr	r3, [r7, #4]
341a10b4:	21ac      	movs	r1, #172	@ 0xac
341a10b6:	fb01 f303 	mul.w	r3, r1, r3
341a10ba:	4413      	add	r3, r2
341a10bc:	3308      	adds	r3, #8
341a10be:	7819      	ldrb	r1, [r3, #0]
341a10c0:	687b      	ldr	r3, [r7, #4]
341a10c2:	22ac      	movs	r2, #172	@ 0xac
341a10c4:	fb02 f303 	mul.w	r3, r2, r3
341a10c8:	3308      	adds	r3, #8
341a10ca:	4a1c      	ldr	r2, [pc, #112]	@ (341a113c <EXTMEM_Init+0xcc>)
341a10cc:	4413      	add	r3, r2
341a10ce:	3304      	adds	r3, #4
341a10d0:	683a      	ldr	r2, [r7, #0]
341a10d2:	f002 fb21 	bl	341a3718 <EXTMEM_DRIVER_NOR_SFDP_Init>
341a10d6:	4603      	mov	r3, r0
341a10d8:	2b00      	cmp	r3, #0
341a10da:	d026      	beq.n	341a112a <EXTMEM_Init+0xba>
                                                                     extmem_list_config[MemId].ConfigType,
                                                                     ClockInput,
                                                                     &extmem_list_config[MemId].NorSfdpObject))
        {
          retr = EXTMEM_ERROR_DRIVER;
341a10dc:	23fd      	movs	r3, #253	@ 0xfd
341a10de:	73fb      	strb	r3, [r7, #15]
        }
        break;
341a10e0:	e023      	b.n	341a112a <EXTMEM_Init+0xba>
    }
#endif /* EXTMEM_DRIVER_SDCARD == 1 */
#if EXTMEM_DRIVER_PSRAM == 1
    case EXTMEM_PSRAM : {
        /* Initialize the SFDP memory */
        if (EXTMEM_DRIVER_PSRAM_OK != EXTMEM_DRIVER_PSRAM_Init(extmem_list_config[MemId].Handle,
341a10e2:	4a16      	ldr	r2, [pc, #88]	@ (341a113c <EXTMEM_Init+0xcc>)
341a10e4:	687b      	ldr	r3, [r7, #4]
341a10e6:	21ac      	movs	r1, #172	@ 0xac
341a10e8:	fb01 f303 	mul.w	r3, r1, r3
341a10ec:	4413      	add	r3, r2
341a10ee:	3304      	adds	r3, #4
341a10f0:	6818      	ldr	r0, [r3, #0]
341a10f2:	4a12      	ldr	r2, [pc, #72]	@ (341a113c <EXTMEM_Init+0xcc>)
341a10f4:	687b      	ldr	r3, [r7, #4]
341a10f6:	21ac      	movs	r1, #172	@ 0xac
341a10f8:	fb01 f303 	mul.w	r3, r1, r3
341a10fc:	4413      	add	r3, r2
341a10fe:	3308      	adds	r3, #8
341a1100:	7819      	ldrb	r1, [r3, #0]
341a1102:	687b      	ldr	r3, [r7, #4]
341a1104:	22ac      	movs	r2, #172	@ 0xac
341a1106:	fb02 f303 	mul.w	r3, r2, r3
341a110a:	3308      	adds	r3, #8
341a110c:	4a0b      	ldr	r2, [pc, #44]	@ (341a113c <EXTMEM_Init+0xcc>)
341a110e:	4413      	add	r3, r2
341a1110:	3304      	adds	r3, #4
341a1112:	683a      	ldr	r2, [r7, #0]
341a1114:	f000 f814 	bl	341a1140 <EXTMEM_DRIVER_PSRAM_Init>
341a1118:	4603      	mov	r3, r0
341a111a:	2b00      	cmp	r3, #0
341a111c:	d007      	beq.n	341a112e <EXTMEM_Init+0xbe>
                                                               extmem_list_config[MemId].ConfigType,
                                                               ClockInput,
                                                               &extmem_list_config[MemId].PsramObject))
        {
          retr = EXTMEM_ERROR_DRIVER;
341a111e:	23fd      	movs	r3, #253	@ 0xfd
341a1120:	73fb      	strb	r3, [r7, #15]
        }
        break;
341a1122:	e004      	b.n	341a112e <EXTMEM_Init+0xbe>
      break;
    }
#endif /* EXTMEM_DRIVER_USER == 1 */
    default:{
        EXTMEM_DEBUG("\terror unknown type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
341a1124:	23fe      	movs	r3, #254	@ 0xfe
341a1126:	73fb      	strb	r3, [r7, #15]
        break;
341a1128:	e002      	b.n	341a1130 <EXTMEM_Init+0xc0>
        break;
341a112a:	bf00      	nop
341a112c:	e000      	b.n	341a1130 <EXTMEM_Init+0xc0>
        break;
341a112e:	bf00      	nop
      }
    }
  }
  return retr;
341a1130:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a1134:	4618      	mov	r0, r3
341a1136:	3710      	adds	r7, #16
341a1138:	46bd      	mov	sp, r7
341a113a:	bd80      	pop	{r7, pc}
341a113c:	341c1a2c 	.word	0x341c1a2c

341a1140 <EXTMEM_DRIVER_PSRAM_Init>:
  */

EXTMEM_DRIVER_PSRAM_StatusTypeDef EXTMEM_DRIVER_PSRAM_Init(void *Peripheral, EXTMEM_LinkConfig_TypeDef Config,
                                                           uint32_t ClockInput,
                                                           EXTMEM_DRIVER_PSRAM_ObjectTypeDef *PsramObject)
{
341a1140:	b580      	push	{r7, lr}
341a1142:	b088      	sub	sp, #32
341a1144:	af00      	add	r7, sp, #0
341a1146:	60f8      	str	r0, [r7, #12]
341a1148:	607a      	str	r2, [r7, #4]
341a114a:	603b      	str	r3, [r7, #0]
341a114c:	460b      	mov	r3, r1
341a114e:	72fb      	strb	r3, [r7, #11]
  EXTMEM_DRIVER_PSRAM_StatusTypeDef retr = EXTMEM_DRIVER_PSRAM_OK;
341a1150:	2300      	movs	r3, #0
341a1152:	77fb      	strb	r3, [r7, #31]

  /* initialize the instance */
  DEBUG_STR("initialize the instance")
  
  /* Initialize XSPI low layer */
  (void)SAL_XSPI_Init(&PsramObject->psram_private.SALObject, Peripheral);
341a1154:	683b      	ldr	r3, [r7, #0]
341a1156:	68f9      	ldr	r1, [r7, #12]
341a1158:	4618      	mov	r0, r3
341a115a:	f000 f905 	bl	341a1368 <SAL_XSPI_Init>

  /* Abort any ongoing XSPI action */
  (void)SAL_XSPI_DisableMapMode(&PsramObject->psram_private.SALObject);
341a115e:	683b      	ldr	r3, [r7, #0]
341a1160:	4618      	mov	r0, r3
341a1162:	f000 fd98 	bl	341a1c96 <SAL_XSPI_DisableMapMode>

  /* Set the frequency prescaler */
  DEBUG_STR("set memory speed according freqIn and freqMax supported by the memory")
  if (HAL_OK != SAL_XSPI_SetClock(&PsramObject->psram_private.SALObject, ClockInput, PsramObject->psram_public.FreqMax, &ClockOut))
341a1166:	6838      	ldr	r0, [r7, #0]
341a1168:	683b      	ldr	r3, [r7, #0]
341a116a:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
341a116c:	f107 0318 	add.w	r3, r7, #24
341a1170:	6879      	ldr	r1, [r7, #4]
341a1172:	f000 f8ba 	bl	341a12ea <SAL_XSPI_SetClock>
341a1176:	4603      	mov	r3, r0
341a1178:	2b00      	cmp	r3, #0
341a117a:	d002      	beq.n	341a1182 <EXTMEM_DRIVER_PSRAM_Init+0x42>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR;
341a117c:	2380      	movs	r3, #128	@ 0x80
341a117e:	77fb      	strb	r3, [r7, #31]
    goto error;
341a1180:	e03e      	b.n	341a1200 <EXTMEM_DRIVER_PSRAM_Init+0xc0>
  }

  /* Set the memory size */
  DEBUG_STR("set memory size according")
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_FLASHSIZE, &PsramObject->psram_public.MemorySize);
341a1182:	6838      	ldr	r0, [r7, #0]
341a1184:	683b      	ldr	r3, [r7, #0]
341a1186:	3354      	adds	r3, #84	@ 0x54
341a1188:	461a      	mov	r2, r3
341a118a:	2104      	movs	r1, #4
341a118c:	f000 f920 	bl	341a13d0 <SAL_XSPI_MemoryConfig>

  /* Set the memory size */
  DEBUG_STR("set xspi link config")
  linkvalue = PHY_LINK_RAM8;
341a1190:	230a      	movs	r3, #10
341a1192:	75fb      	strb	r3, [r7, #23]
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_PHY_LINK, &linkvalue);
341a1194:	683b      	ldr	r3, [r7, #0]
341a1196:	f107 0217 	add.w	r2, r7, #23
341a119a:	2100      	movs	r1, #0
341a119c:	4618      	mov	r0, r3
341a119e:	f000 f917 	bl	341a13d0 <SAL_XSPI_MemoryConfig>

  /* Set the configuration to perform register operation */
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_DUMMY_CYCLES, &PsramObject->psram_public.REG_DummyCycle);
341a11a2:	6838      	ldr	r0, [r7, #0]
341a11a4:	683b      	ldr	r3, [r7, #0]
341a11a6:	3369      	adds	r3, #105	@ 0x69
341a11a8:	461a      	mov	r2, r3
341a11aa:	2101      	movs	r1, #1
341a11ac:	f000 f910 	bl	341a13d0 <SAL_XSPI_MemoryConfig>

  /* Execute the command sequence */
  for (uint8_t command_index = 0u; command_index < PsramObject->psram_public.NumberOfConfig; command_index++)
341a11b0:	2300      	movs	r3, #0
341a11b2:	77bb      	strb	r3, [r7, #30]
341a11b4:	e00d      	b.n	341a11d2 <EXTMEM_DRIVER_PSRAM_Init+0x92>
  {
    retr = PSRAM_ExecuteCommand(PsramObject, command_index);
341a11b6:	7fbb      	ldrb	r3, [r7, #30]
341a11b8:	4619      	mov	r1, r3
341a11ba:	6838      	ldr	r0, [r7, #0]
341a11bc:	f000 f826 	bl	341a120c <PSRAM_ExecuteCommand>
341a11c0:	4603      	mov	r3, r0
341a11c2:	77fb      	strb	r3, [r7, #31]
    if (retr != EXTMEM_DRIVER_PSRAM_OK)
341a11c4:	f997 301f 	ldrsb.w	r3, [r7, #31]
341a11c8:	2b00      	cmp	r3, #0
341a11ca:	d118      	bne.n	341a11fe <EXTMEM_DRIVER_PSRAM_Init+0xbe>
  for (uint8_t command_index = 0u; command_index < PsramObject->psram_public.NumberOfConfig; command_index++)
341a11cc:	7fbb      	ldrb	r3, [r7, #30]
341a11ce:	3301      	adds	r3, #1
341a11d0:	77bb      	strb	r3, [r7, #30]
341a11d2:	683b      	ldr	r3, [r7, #0]
341a11d4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a11d8:	7fba      	ldrb	r2, [r7, #30]
341a11da:	429a      	cmp	r2, r3
341a11dc:	d3eb      	bcc.n	341a11b6 <EXTMEM_DRIVER_PSRAM_Init+0x76>
    {
      goto error;
    }
  }

  switch(Config)
341a11de:	7afb      	ldrb	r3, [r7, #11]
341a11e0:	2b04      	cmp	r3, #4
341a11e2:	d109      	bne.n	341a11f8 <EXTMEM_DRIVER_PSRAM_Init+0xb8>
  {
  case EXTMEM_LINK_CONFIG_16LINES:
    linkvalue = PHY_LINK_RAM16;
341a11e4:	230b      	movs	r3, #11
341a11e6:	75fb      	strb	r3, [r7, #23]
    (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_PHY_LINK, &linkvalue);
341a11e8:	683b      	ldr	r3, [r7, #0]
341a11ea:	f107 0217 	add.w	r2, r7, #23
341a11ee:	2100      	movs	r1, #0
341a11f0:	4618      	mov	r0, r3
341a11f2:	f000 f8ed 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
    break;
341a11f6:	e003      	b.n	341a1200 <EXTMEM_DRIVER_PSRAM_Init+0xc0>

  case EXTMEM_LINK_CONFIG_8LINES:
  default:
    retr = EXTMEM_DRIVER_PSRAM_ERROR;
341a11f8:	2380      	movs	r3, #128	@ 0x80
341a11fa:	77fb      	strb	r3, [r7, #31]
    goto error;
341a11fc:	e000      	b.n	341a1200 <EXTMEM_DRIVER_PSRAM_Init+0xc0>
      goto error;
341a11fe:	bf00      	nop
    break;
  }

error:
  return retr;
341a1200:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
341a1204:	4618      	mov	r0, r3
341a1206:	3720      	adds	r7, #32
341a1208:	46bd      	mov	sp, r7
341a120a:	bd80      	pop	{r7, pc}

341a120c <PSRAM_ExecuteCommand>:
 * @param PsramObject psram memory object
 * @param Index command index
 * @return @ref EXTMEM_DRIVER_PSRAM_StatusTypeDef
 **/
EXTMEM_DRIVER_PSRAM_StatusTypeDef PSRAM_ExecuteCommand(EXTMEM_DRIVER_PSRAM_ObjectTypeDef *PsramObject, uint8_t Index)
{
341a120c:	b590      	push	{r4, r7, lr}
341a120e:	b087      	sub	sp, #28
341a1210:	af02      	add	r7, sp, #8
341a1212:	6078      	str	r0, [r7, #4]
341a1214:	460b      	mov	r3, r1
341a1216:	70fb      	strb	r3, [r7, #3]
  EXTMEM_DRIVER_PSRAM_StatusTypeDef retr = EXTMEM_DRIVER_PSRAM_OK;
341a1218:	2300      	movs	r3, #0
341a121a:	73fb      	strb	r3, [r7, #15]
  uint8_t regval[2];

  if (PsramObject->psram_public.ReadREGSize > 2u)
341a121c:	687b      	ldr	r3, [r7, #4]
341a121e:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
341a1222:	2b02      	cmp	r3, #2
341a1224:	d902      	bls.n	341a122c <PSRAM_ExecuteCommand+0x20>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_REGSIZE;
341a1226:	23f9      	movs	r3, #249	@ 0xf9
341a1228:	73fb      	strb	r3, [r7, #15]
    goto error;
341a122a:	e058      	b.n	341a12de <PSRAM_ExecuteCommand+0xd2>
  }

  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a122c:	6878      	ldr	r0, [r7, #4]
341a122e:	687b      	ldr	r3, [r7, #4]
341a1230:	f893 4066 	ldrb.w	r4, [r3, #102]	@ 0x66
                              PsramObject->psram_public.ReadREG,
                              PsramObject->psram_public.config[Index].REGAddress, 
341a1234:	78fa      	ldrb	r2, [r7, #3]
341a1236:	6879      	ldr	r1, [r7, #4]
341a1238:	4613      	mov	r3, r2
341a123a:	005b      	lsls	r3, r3, #1
341a123c:	4413      	add	r3, r2
341a123e:	440b      	add	r3, r1
341a1240:	335f      	adds	r3, #95	@ 0x5f
341a1242:	781b      	ldrb	r3, [r3, #0]
  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a1244:	4619      	mov	r1, r3
                              regval, PsramObject->psram_public.ReadREGSize))
341a1246:	687b      	ldr	r3, [r7, #4]
341a1248:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a124c:	461a      	mov	r2, r3
341a124e:	f107 030c 	add.w	r3, r7, #12
341a1252:	9200      	str	r2, [sp, #0]
341a1254:	460a      	mov	r2, r1
341a1256:	4621      	mov	r1, r4
341a1258:	f000 fae6 	bl	341a1828 <SAL_XSPI_Read>
341a125c:	4603      	mov	r3, r0
341a125e:	2b00      	cmp	r3, #0
341a1260:	d002      	beq.n	341a1268 <PSRAM_ExecuteCommand+0x5c>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_READREG;
341a1262:	23ff      	movs	r3, #255	@ 0xff
341a1264:	73fb      	strb	r3, [r7, #15]
    goto error;
341a1266:	e03a      	b.n	341a12de <PSRAM_ExecuteCommand+0xd2>
  }

  MODIFY_REG(regval[0], 
341a1268:	7b3b      	ldrb	r3, [r7, #12]
341a126a:	b259      	sxtb	r1, r3
341a126c:	78fa      	ldrb	r2, [r7, #3]
341a126e:	6878      	ldr	r0, [r7, #4]
341a1270:	4613      	mov	r3, r2
341a1272:	005b      	lsls	r3, r3, #1
341a1274:	4413      	add	r3, r2
341a1276:	4403      	add	r3, r0
341a1278:	335d      	adds	r3, #93	@ 0x5d
341a127a:	781b      	ldrb	r3, [r3, #0]
341a127c:	b25b      	sxtb	r3, r3
341a127e:	43db      	mvns	r3, r3
341a1280:	b25b      	sxtb	r3, r3
341a1282:	400b      	ands	r3, r1
341a1284:	b259      	sxtb	r1, r3
341a1286:	78fa      	ldrb	r2, [r7, #3]
341a1288:	6878      	ldr	r0, [r7, #4]
341a128a:	4613      	mov	r3, r2
341a128c:	005b      	lsls	r3, r3, #1
341a128e:	4413      	add	r3, r2
341a1290:	4403      	add	r3, r0
341a1292:	335e      	adds	r3, #94	@ 0x5e
341a1294:	781b      	ldrb	r3, [r3, #0]
341a1296:	b25b      	sxtb	r3, r3
341a1298:	430b      	orrs	r3, r1
341a129a:	b25b      	sxtb	r3, r3
341a129c:	b2db      	uxtb	r3, r3
341a129e:	733b      	strb	r3, [r7, #12]
             PsramObject->psram_public.config[Index].WriteMask, 
             PsramObject->psram_public.config[Index].WriteValue);

  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a12a0:	6878      	ldr	r0, [r7, #4]
341a12a2:	687b      	ldr	r3, [r7, #4]
341a12a4:	f893 4067 	ldrb.w	r4, [r3, #103]	@ 0x67
                               PsramObject->psram_public.WriteREG,
                               PsramObject->psram_public.config[Index].REGAddress, 
341a12a8:	78fa      	ldrb	r2, [r7, #3]
341a12aa:	6879      	ldr	r1, [r7, #4]
341a12ac:	4613      	mov	r3, r2
341a12ae:	005b      	lsls	r3, r3, #1
341a12b0:	4413      	add	r3, r2
341a12b2:	440b      	add	r3, r1
341a12b4:	335f      	adds	r3, #95	@ 0x5f
341a12b6:	781b      	ldrb	r3, [r3, #0]
  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a12b8:	4619      	mov	r1, r3
                               regval, PsramObject->psram_public.ReadREGSize))
341a12ba:	687b      	ldr	r3, [r7, #4]
341a12bc:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a12c0:	461a      	mov	r2, r3
341a12c2:	f107 030c 	add.w	r3, r7, #12
341a12c6:	9200      	str	r2, [sp, #0]
341a12c8:	460a      	mov	r2, r1
341a12ca:	4621      	mov	r1, r4
341a12cc:	f000 fb14 	bl	341a18f8 <SAL_XSPI_Write>
341a12d0:	4603      	mov	r3, r0
341a12d2:	2b00      	cmp	r3, #0
341a12d4:	d002      	beq.n	341a12dc <PSRAM_ExecuteCommand+0xd0>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_WRITEREG;
341a12d6:	23fe      	movs	r3, #254	@ 0xfe
341a12d8:	73fb      	strb	r3, [r7, #15]
    goto error;
341a12da:	e000      	b.n	341a12de <PSRAM_ExecuteCommand+0xd2>
  }

error:
341a12dc:	bf00      	nop
  return retr;
341a12de:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a12e2:	4618      	mov	r0, r3
341a12e4:	3714      	adds	r7, #20
341a12e6:	46bd      	mov	sp, r7
341a12e8:	bd90      	pop	{r4, r7, pc}

341a12ea <SAL_XSPI_SetClock>:
/* Private variables ---------------------------------------------------------*/
/** @defgroup SAL_XSPI_Exported_Functions SAL XSP Exported Functions
  * @{
  */
HAL_StatusTypeDef SAL_XSPI_SetClock(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t ClockIn, uint32_t ClockRequested, uint32_t *ClockReal)
{
341a12ea:	b480      	push	{r7}
341a12ec:	b087      	sub	sp, #28
341a12ee:	af00      	add	r7, sp, #0
341a12f0:	60f8      	str	r0, [r7, #12]
341a12f2:	60b9      	str	r1, [r7, #8]
341a12f4:	607a      	str	r2, [r7, #4]
341a12f6:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr = HAL_OK;
341a12f8:	2300      	movs	r3, #0
341a12fa:	75fb      	strb	r3, [r7, #23]
  uint32_t divider;

  if (ClockRequested == 0u)
341a12fc:	687b      	ldr	r3, [r7, #4]
341a12fe:	2b00      	cmp	r3, #0
341a1300:	d102      	bne.n	341a1308 <SAL_XSPI_SetClock+0x1e>
  {
    retr = HAL_ERROR;
341a1302:	2301      	movs	r3, #1
341a1304:	75fb      	strb	r3, [r7, #23]
341a1306:	e028      	b.n	341a135a <SAL_XSPI_SetClock+0x70>
  }
  else
  {
    divider = (ClockIn / ClockRequested);
341a1308:	68ba      	ldr	r2, [r7, #8]
341a130a:	687b      	ldr	r3, [r7, #4]
341a130c:	fbb2 f3f3 	udiv	r3, r2, r3
341a1310:	613b      	str	r3, [r7, #16]
    if (divider >= 1u)
341a1312:	693b      	ldr	r3, [r7, #16]
341a1314:	2b00      	cmp	r3, #0
341a1316:	d00d      	beq.n	341a1334 <SAL_XSPI_SetClock+0x4a>
    {
      *ClockReal = ClockIn / divider;
341a1318:	68ba      	ldr	r2, [r7, #8]
341a131a:	693b      	ldr	r3, [r7, #16]
341a131c:	fbb2 f2f3 	udiv	r2, r2, r3
341a1320:	683b      	ldr	r3, [r7, #0]
341a1322:	601a      	str	r2, [r3, #0]
      if (*ClockReal <= ClockRequested)
341a1324:	683b      	ldr	r3, [r7, #0]
341a1326:	681b      	ldr	r3, [r3, #0]
341a1328:	687a      	ldr	r2, [r7, #4]
341a132a:	429a      	cmp	r2, r3
341a132c:	d302      	bcc.n	341a1334 <SAL_XSPI_SetClock+0x4a>
      {
        divider--;
341a132e:	693b      	ldr	r3, [r7, #16]
341a1330:	3b01      	subs	r3, #1
341a1332:	613b      	str	r3, [r7, #16]
      }
    }

    /* real clock calculation */
    *ClockReal = ClockIn / (divider + 1u);
341a1334:	693b      	ldr	r3, [r7, #16]
341a1336:	3301      	adds	r3, #1
341a1338:	68ba      	ldr	r2, [r7, #8]
341a133a:	fbb2 f2f3 	udiv	r2, r2, r3
341a133e:	683b      	ldr	r3, [r7, #0]
341a1340:	601a      	str	r2, [r3, #0]

    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::CLOCKDIV::"); DEBUG_PARAM_INT(divider+1); DEBUG_PARAM_END();
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::CLKFREQ::"); DEBUG_PARAM_INTD(*ClockReal); DEBUG_PARAM_END();
    MODIFY_REG(SalXspi->hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER, (uint32_t)divider << XSPI_DCR2_PRESCALER_Pos);
341a1342:	68fb      	ldr	r3, [r7, #12]
341a1344:	681b      	ldr	r3, [r3, #0]
341a1346:	681b      	ldr	r3, [r3, #0]
341a1348:	68db      	ldr	r3, [r3, #12]
341a134a:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
341a134e:	68fb      	ldr	r3, [r7, #12]
341a1350:	681b      	ldr	r3, [r3, #0]
341a1352:	681b      	ldr	r3, [r3, #0]
341a1354:	693a      	ldr	r2, [r7, #16]
341a1356:	430a      	orrs	r2, r1
341a1358:	60da      	str	r2, [r3, #12]
  }

  return retr;
341a135a:	7dfb      	ldrb	r3, [r7, #23]
}
341a135c:	4618      	mov	r0, r3
341a135e:	371c      	adds	r7, #28
341a1360:	46bd      	mov	sp, r7
341a1362:	f85d 7b04 	ldr.w	r7, [sp], #4
341a1366:	4770      	bx	lr

341a1368 <SAL_XSPI_Init>:
/*
* This function is used to configure the way to discuss with the memory
*
*/
HAL_StatusTypeDef SAL_XSPI_Init(SAL_XSPI_ObjectTypeDef *SalXspi, void *HALHandle)
{
341a1368:	b580      	push	{r7, lr}
341a136a:	b096      	sub	sp, #88	@ 0x58
341a136c:	af00      	add	r7, sp, #0
341a136e:	6078      	str	r0, [r7, #4]
341a1370:	6039      	str	r1, [r7, #0]
  XSPI_RegularCmdTypeDef s_commandbase = {
341a1372:	f107 030c 	add.w	r3, r7, #12
341a1376:	224c      	movs	r2, #76	@ 0x4c
341a1378:	2100      	movs	r1, #0
341a137a:	4618      	mov	r0, r3
341a137c:	f002 fd12 	bl	341a3da4 <memset>
341a1380:	235a      	movs	r3, #90	@ 0x5a
341a1382:	617b      	str	r3, [r7, #20]
341a1384:	2301      	movs	r3, #1
341a1386:	61bb      	str	r3, [r7, #24]
341a1388:	f44f 7380 	mov.w	r3, #256	@ 0x100
341a138c:	62bb      	str	r3, [r7, #40]	@ 0x28
341a138e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a1392:	62fb      	str	r3, [r7, #44]	@ 0x2c
341a1394:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a1398:	647b      	str	r3, [r7, #68]	@ 0x44
341a139a:	2308      	movs	r3, #8
341a139c:	653b      	str	r3, [r7, #80]	@ 0x50
#if defined(XSPI_CCR_SIOO)
      .SIOOMode = HAL_XSPI_SIOO_INST_EVERY_CMD,
#endif /* HAL_XSPI_SIOO_INST_EVERY_CMD */
  };

  SalXspi->hxspi = (XSPI_HandleTypeDef *)HALHandle;
341a139e:	687b      	ldr	r3, [r7, #4]
341a13a0:	683a      	ldr	r2, [r7, #0]
341a13a2:	601a      	str	r2, [r3, #0]
  SalXspi->Commandbase = s_commandbase;
341a13a4:	687b      	ldr	r3, [r7, #4]
341a13a6:	3304      	adds	r3, #4
341a13a8:	f107 010c 	add.w	r1, r7, #12
341a13ac:	224c      	movs	r2, #76	@ 0x4c
341a13ae:	4618      	mov	r0, r3
341a13b0:	f002 fd73 	bl	341a3e9a <memcpy>
  SalXspi->CommandExtension = 0;
341a13b4:	687b      	ldr	r3, [r7, #4]
341a13b6:	2200      	movs	r2, #0
341a13b8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  SalXspi->PhyLink = PHY_LINK_1S1S1S;
341a13bc:	687b      	ldr	r3, [r7, #4]
341a13be:	2200      	movs	r2, #0
341a13c0:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
  HAL_XSPI_RegisterCallback(SalXspi->hxspi,HAL_XSPI_TX_CPLT_CB_ID, SAL_XSPI_CompleteCallback);
  /* set the error callback */
  HAL_XSPI_RegisterCallback(SalXspi->hxspi,HAL_XSPI_ERROR_CB_ID, SAL_XSPI_ErrorCallback);
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

  return HAL_OK;
341a13c4:	2300      	movs	r3, #0
}
341a13c6:	4618      	mov	r0, r3
341a13c8:	3758      	adds	r7, #88	@ 0x58
341a13ca:	46bd      	mov	sp, r7
341a13cc:	bd80      	pop	{r7, pc}
	...

341a13d0 <SAL_XSPI_MemoryConfig>:

HAL_StatusTypeDef SAL_XSPI_MemoryConfig(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_MemParamTypeTypeDef ParametersType, void *ParamVal)
{
341a13d0:	b580      	push	{r7, lr}
341a13d2:	b098      	sub	sp, #96	@ 0x60
341a13d4:	af00      	add	r7, sp, #0
341a13d6:	60f8      	str	r0, [r7, #12]
341a13d8:	460b      	mov	r3, r1
341a13da:	607a      	str	r2, [r7, #4]
341a13dc:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr = HAL_OK;
341a13de:	2300      	movs	r3, #0
341a13e0:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  XSPI_RegularCmdTypeDef s_commandbase = SalXspi->Commandbase;
341a13e4:	68fb      	ldr	r3, [r7, #12]
341a13e6:	f107 0010 	add.w	r0, r7, #16
341a13ea:	3304      	adds	r3, #4
341a13ec:	224c      	movs	r2, #76	@ 0x4c
341a13ee:	4619      	mov	r1, r3
341a13f0:	f002 fd53 	bl	341a3e9a <memcpy>

  switch (ParametersType) {
341a13f4:	7afb      	ldrb	r3, [r7, #11]
341a13f6:	2b04      	cmp	r3, #4
341a13f8:	f200 812a 	bhi.w	341a1650 <SAL_XSPI_MemoryConfig+0x280>
341a13fc:	a201      	add	r2, pc, #4	@ (adr r2, 341a1404 <SAL_XSPI_MemoryConfig+0x34>)
341a13fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a1402:	bf00      	nop
341a1404:	341a1419 	.word	0x341a1419
341a1408:	341a1641 	.word	0x341a1641
341a140c:	341a1613 	.word	0x341a1613
341a1410:	341a1651 	.word	0x341a1651
341a1414:	341a161b 	.word	0x341a161b
  case PARAM_PHY_LINK:{
    SalXspi->PhyLink = *((SAL_XSPI_PhysicalLinkTypeDef *)ParamVal);
341a1418:	687b      	ldr	r3, [r7, #4]
341a141a:	781a      	ldrb	r2, [r3, #0]
341a141c:	68fb      	ldr	r3, [r7, #12]
341a141e:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_PHY_LINK::");DEBUG_PARAM_DATA(STR_PHY_LINK(SalXspi->PhyLink));
    switch (SalXspi->PhyLink)
341a1422:	68fb      	ldr	r3, [r7, #12]
341a1424:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
341a1428:	2b0b      	cmp	r3, #11
341a142a:	f200 80ed 	bhi.w	341a1608 <SAL_XSPI_MemoryConfig+0x238>
341a142e:	a201      	add	r2, pc, #4	@ (adr r2, 341a1434 <SAL_XSPI_MemoryConfig+0x64>)
341a1430:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a1434:	341a1465 	.word	0x341a1465
341a1438:	341a1465 	.word	0x341a1465
341a143c:	341a1465 	.word	0x341a1465
341a1440:	341a1465 	.word	0x341a1465
341a1444:	341a1495 	.word	0x341a1495
341a1448:	341a1495 	.word	0x341a1495
341a144c:	341a14c5 	.word	0x341a14c5
341a1450:	341a14f9 	.word	0x341a14f9
341a1454:	341a1529 	.word	0x341a1529
341a1458:	341a155f 	.word	0x341a155f
341a145c:	341a1595 	.word	0x341a1595
341a1460:	341a15cf 	.word	0x341a15cf
    {
    case PHY_LINK_1S1D1D:
    case PHY_LINK_1S2S2S:
    case PHY_LINK_1S1S2S:
    case PHY_LINK_1S1S1S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
341a1464:	2301      	movs	r3, #1
341a1466:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a1468:	2300      	movs	r3, #0
341a146a:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a146c:	2300      	movs	r3, #0
341a146e:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
341a1470:	f44f 7380 	mov.w	r3, #256	@ 0x100
341a1474:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a1476:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a147a:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a147c:	2300      	movs	r3, #0
341a147e:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_1_LINE;
341a1480:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a1484:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a1486:	2300      	movs	r3, #0
341a1488:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a148a:	2308      	movs	r3, #8
341a148c:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a148e:	2300      	movs	r3, #0
341a1490:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a1492:	e0bd      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }

    case PHY_LINK_4S4D4D:
    case PHY_LINK_4S4S4S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
341a1494:	2303      	movs	r3, #3
341a1496:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a1498:	2300      	movs	r3, #0
341a149a:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a149c:	2300      	movs	r3, #0
341a149e:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
341a14a0:	f44f 7340 	mov.w	r3, #768	@ 0x300
341a14a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a14a6:	2300      	movs	r3, #0
341a14a8:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a14aa:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a14ae:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
341a14b0:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a14b4:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a14b6:	2300      	movs	r3, #0
341a14b8:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 6;
341a14ba:	2306      	movs	r3, #6
341a14bc:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a14be:	2300      	movs	r3, #0
341a14c0:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a14c2:	e0a5      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
      }
    case PHY_LINK_4D4D4D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
341a14c4:	2303      	movs	r3, #3
341a14c6:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a14c8:	2300      	movs	r3, #0
341a14ca:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
341a14cc:	2308      	movs	r3, #8
341a14ce:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
341a14d0:	f44f 7340 	mov.w	r3, #768	@ 0x300
341a14d4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a14d6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a14da:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a14dc:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a14e0:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
341a14e2:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a14e6:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a14e8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a14ec:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 6;
341a14ee:	2306      	movs	r3, #6
341a14f0:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a14f2:	2300      	movs	r3, #0
341a14f4:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a14f6:	e08b      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_1S8S8S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
341a14f8:	2301      	movs	r3, #1
341a14fa:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a14fc:	2300      	movs	r3, #0
341a14fe:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a1500:	2300      	movs	r3, #0
341a1502:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a1504:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a1508:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a150a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a150e:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a1510:	2300      	movs	r3, #0
341a1512:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a1514:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a1518:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a151a:	2300      	movs	r3, #0
341a151c:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a151e:	2308      	movs	r3, #8
341a1520:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a1522:	2300      	movs	r3, #0
341a1524:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a1526:	e073      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_8S8D8D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
341a1528:	2304      	movs	r3, #4
341a152a:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a152c:	2300      	movs	r3, #0
341a152e:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a1530:	2300      	movs	r3, #0
341a1532:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a1534:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a1538:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a153a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a153e:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a1540:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a1544:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a1546:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a154a:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a154c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a1550:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a1552:	2308      	movs	r3, #8
341a1554:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
341a1556:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a155a:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a155c:	e058      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }

    case PHY_LINK_8D8D8D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
341a155e:	2304      	movs	r3, #4
341a1560:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
341a1562:	2310      	movs	r3, #16
341a1564:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
341a1566:	2308      	movs	r3, #8
341a1568:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a156a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a156e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a1570:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a1574:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a1576:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a157a:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a157c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a1580:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a1582:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a1586:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 20;
341a1588:	2314      	movs	r3, #20
341a158a:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
341a158c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a1590:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a1592:	e03d      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_RAM8:{
      s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
341a1594:	2304      	movs	r3, #4
341a1596:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
341a1598:	2300      	movs	r3, #0
341a159a:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a159c:	2300      	movs	r3, #0
341a159e:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
341a15a0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a15a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
341a15a6:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a15aa:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a15ac:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a15b0:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341a15b2:	2300      	movs	r3, #0
341a15b4:	63fb      	str	r3, [r7, #60]	@ 0x3c
      s_commandbase.DataMode           = HAL_XSPI_DATA_8_LINES;
341a15b6:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a15ba:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
341a15bc:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a15c0:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles        = 10;
341a15c2:	230a      	movs	r3, #10
341a15c4:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
341a15c6:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a15ca:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a15cc:	e020      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }
#if defined(HAL_XSPI_DATA_16_LINES)
    case PHY_LINK_RAM16 :{
      s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
341a15ce:	2304      	movs	r3, #4
341a15d0:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
341a15d2:	2300      	movs	r3, #0
341a15d4:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a15d6:	2300      	movs	r3, #0
341a15d8:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
341a15da:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a15de:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
341a15e0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a15e4:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a15e6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a15ea:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341a15ec:	2300      	movs	r3, #0
341a15ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
      s_commandbase.DataMode           = HAL_XSPI_DATA_16_LINES;
341a15f0:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
341a15f4:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
341a15f6:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a15fa:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles        = 10;
341a15fc:	230a      	movs	r3, #10
341a15fe:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
341a1600:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a1604:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a1606:	e003      	b.n	341a1610 <SAL_XSPI_MemoryConfig+0x240>
    }
#endif /* defined(HAL_XSPI_DATA_16_LINES) */
    default:
      retr = HAL_ERROR;
341a1608:	2301      	movs	r3, #1
341a160a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
      break;
341a160e:	bf00      	nop
    }
    DEBUG_PARAM_END();
    break;
341a1610:	e022      	b.n	341a1658 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_ADDRESS_4BYTES: {
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_ADDRESS_4BYTES"); DEBUG_PARAM_END();
    s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a1612:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a1616:	633b      	str	r3, [r7, #48]	@ 0x30
    break;
341a1618:	e01e      	b.n	341a1658 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_FLASHSIZE:{
    uint8_t valParam = *((uint8_t *)ParamVal);
341a161a:	687b      	ldr	r3, [r7, #4]
341a161c:	781b      	ldrb	r3, [r3, #0]
341a161e:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_FLASHSIZE::"); DEBUG_PARAM_INT(valParam); DEBUG_PARAM_END();
    MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_DEVSIZE, ((uint32_t)valParam) << XSPI_DCR1_DEVSIZE_Pos);
341a1622:	68fb      	ldr	r3, [r7, #12]
341a1624:	681b      	ldr	r3, [r3, #0]
341a1626:	681b      	ldr	r3, [r3, #0]
341a1628:	689b      	ldr	r3, [r3, #8]
341a162a:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
341a162e:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
341a1632:	041a      	lsls	r2, r3, #16
341a1634:	68fb      	ldr	r3, [r7, #12]
341a1636:	681b      	ldr	r3, [r3, #0]
341a1638:	681b      	ldr	r3, [r3, #0]
341a163a:	430a      	orrs	r2, r1
341a163c:	609a      	str	r2, [r3, #8]
    break;
341a163e:	e00b      	b.n	341a1658 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_DUMMY_CYCLES:{
    uint8_t valParam = *((uint8_t *)ParamVal);
341a1640:	687b      	ldr	r3, [r7, #4]
341a1642:	781b      	ldrb	r3, [r3, #0]
341a1644:	f887 305d 	strb.w	r3, [r7, #93]	@ 0x5d
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_DUMMY_CYCLES::"); DEBUG_PARAM_INT(valParam); DEBUG_PARAM_END();
    s_commandbase.DummyCycles = valParam;
341a1648:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
341a164c:	657b      	str	r3, [r7, #84]	@ 0x54
    break;
341a164e:	e003      	b.n	341a1658 <SAL_XSPI_MemoryConfig+0x288>
  }
  default:
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::SAL_XSPI_MemoryConfig::ERROR"); DEBUG_PARAM_END();
    retr = HAL_ERROR;
341a1650:	2301      	movs	r3, #1
341a1652:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
    break;
341a1656:	bf00      	nop
  }
  SalXspi->Commandbase = s_commandbase;
341a1658:	68fb      	ldr	r3, [r7, #12]
341a165a:	3304      	adds	r3, #4
341a165c:	f107 0110 	add.w	r1, r7, #16
341a1660:	224c      	movs	r2, #76	@ 0x4c
341a1662:	4618      	mov	r0, r3
341a1664:	f002 fc19 	bl	341a3e9a <memcpy>
  return retr;
341a1668:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a166c:	4618      	mov	r0, r3
341a166e:	3760      	adds	r7, #96	@ 0x60
341a1670:	46bd      	mov	sp, r7
341a1672:	bd80      	pop	{r7, pc}

341a1674 <SAL_XSPI_GetSFDP>:

HAL_StatusTypeDef SAL_XSPI_GetSFDP(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t Address, uint8_t *Data, uint32_t DataSize)
{
341a1674:	b580      	push	{r7, lr}
341a1676:	b098      	sub	sp, #96	@ 0x60
341a1678:	af00      	add	r7, sp, #0
341a167a:	60f8      	str	r0, [r7, #12]
341a167c:	60b9      	str	r1, [r7, #8]
341a167e:	607a      	str	r2, [r7, #4]
341a1680:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a1682:	68fb      	ldr	r3, [r7, #12]
341a1684:	f107 0010 	add.w	r0, r7, #16
341a1688:	3304      	adds	r3, #4
341a168a:	224c      	movs	r2, #76	@ 0x4c
341a168c:	4619      	mov	r1, r3
341a168e:	f002 fc04 	bl	341a3e9a <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
341a1692:	68fb      	ldr	r3, [r7, #12]
341a1694:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a1698:	6a39      	ldr	r1, [r7, #32]
341a169a:	225a      	movs	r2, #90	@ 0x5a
341a169c:	4618      	mov	r0, r3
341a169e:	f000 fb51 	bl	341a1d44 <XSPI_FormatCommand>
341a16a2:	4603      	mov	r3, r0
341a16a4:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_SFDP_COMMAND);

  s_command.Address     = Address;
341a16a6:	68bb      	ldr	r3, [r7, #8]
341a16a8:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength  = DataSize;
341a16aa:	683b      	ldr	r3, [r7, #0]
341a16ac:	64fb      	str	r3, [r7, #76]	@ 0x4c
  /* Nb of Dummy cycles for READ SFDP command does not correspond to SFDPDummyCycle field of SAL structure,
     as initialised after SFDP Header analysis */
  s_command.DummyCycles = EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_DEFAULT;
341a16ae:	2308      	movs	r3, #8
341a16b0:	657b      	str	r3, [r7, #84]	@ 0x54

  if (s_command.AddressMode == HAL_XSPI_ADDRESS_1_LINE)
341a16b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341a16b4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341a16b8:	d102      	bne.n	341a16c0 <SAL_XSPI_GetSFDP+0x4c>
  {
    s_command.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a16ba:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a16be:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
341a16c0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a16c2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a16c6:	d103      	bne.n	341a16d0 <SAL_XSPI_GetSFDP+0x5c>
  {
    s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
341a16c8:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a16cc:	65bb      	str	r3, [r7, #88]	@ 0x58
341a16ce:	e001      	b.n	341a16d4 <SAL_XSPI_GetSFDP+0x60>
  }
  else
  {
    s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
341a16d0:	2300      	movs	r3, #0
341a16d2:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a16d4:	68fb      	ldr	r3, [r7, #12]
341a16d6:	681b      	ldr	r3, [r3, #0]
341a16d8:	f107 0110 	add.w	r1, r7, #16
341a16dc:	2264      	movs	r2, #100	@ 0x64
341a16de:	4618      	mov	r0, r3
341a16e0:	f7f3 fde0 	bl	341952a4 <HAL_XSPI_Command>
341a16e4:	4603      	mov	r3, r0
341a16e6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if ( retr  != HAL_OK)
341a16ea:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a16ee:	2b00      	cmp	r3, #0
341a16f0:	d10a      	bne.n	341a1708 <SAL_XSPI_GetSFDP+0x94>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a16f2:	68fb      	ldr	r3, [r7, #12]
341a16f4:	681b      	ldr	r3, [r3, #0]
341a16f6:	2264      	movs	r2, #100	@ 0x64
341a16f8:	6879      	ldr	r1, [r7, #4]
341a16fa:	4618      	mov	r0, r3
341a16fc:	f7f3 fed5 	bl	341954aa <HAL_XSPI_Receive>
341a1700:	4603      	mov	r3, r0
341a1702:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a1706:	e000      	b.n	341a170a <SAL_XSPI_GetSFDP+0x96>
    goto error;
341a1708:	bf00      	nop

error:
  if (retr != HAL_OK )
341a170a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a170e:	2b00      	cmp	r3, #0
341a1710:	d004      	beq.n	341a171c <SAL_XSPI_GetSFDP+0xa8>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1712:	68fb      	ldr	r3, [r7, #12]
341a1714:	681b      	ldr	r3, [r3, #0]
341a1716:	4618      	mov	r0, r3
341a1718:	f7f4 f860 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a171c:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1720:	4618      	mov	r0, r3
341a1722:	3760      	adds	r7, #96	@ 0x60
341a1724:	46bd      	mov	sp, r7
341a1726:	bd80      	pop	{r7, pc}

341a1728 <SAL_XSPI_GetId>:

HAL_StatusTypeDef SAL_XSPI_GetId(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t *Data, uint32_t DataSize)
{
341a1728:	b580      	push	{r7, lr}
341a172a:	b098      	sub	sp, #96	@ 0x60
341a172c:	af00      	add	r7, sp, #0
341a172e:	60f8      	str	r0, [r7, #12]
341a1730:	60b9      	str	r1, [r7, #8]
341a1732:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a1734:	68fb      	ldr	r3, [r7, #12]
341a1736:	f107 0010 	add.w	r0, r7, #16
341a173a:	3304      	adds	r3, #4
341a173c:	224c      	movs	r2, #76	@ 0x4c
341a173e:	4619      	mov	r1, r3
341a1740:	f002 fbab 	bl	341a3e9a <memcpy>

  /* Initialize the Read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
341a1744:	68fb      	ldr	r3, [r7, #12]
341a1746:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a174a:	6a39      	ldr	r1, [r7, #32]
341a174c:	229f      	movs	r2, #159	@ 0x9f
341a174e:	4618      	mov	r0, r3
341a1750:	f000 faf8 	bl	341a1d44 <XSPI_FormatCommand>
341a1754:	4603      	mov	r3, r0
341a1756:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_JEDEC_ID_SPI_COMMAND);

  s_command.DataLength  = DataSize;
341a1758:	687b      	ldr	r3, [r7, #4]
341a175a:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
341a175c:	69fb      	ldr	r3, [r7, #28]
341a175e:	2b01      	cmp	r3, #1
341a1760:	d107      	bne.n	341a1772 <SAL_XSPI_GetId+0x4a>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a1762:	2300      	movs	r3, #0
341a1764:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
341a1766:	2300      	movs	r3, #0
341a1768:	657b      	str	r3, [r7, #84]	@ 0x54
    /* this behavior is linked with micron memory to read ID in 1S8S8S */
    s_command.DataMode = HAL_XSPI_DATA_1_LINE;
341a176a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a176e:	64bb      	str	r3, [r7, #72]	@ 0x48
341a1770:	e030      	b.n	341a17d4 <SAL_XSPI_GetId+0xac>
  }
  else if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_4_LINES)
341a1772:	69fb      	ldr	r3, [r7, #28]
341a1774:	2b03      	cmp	r3, #3
341a1776:	d107      	bne.n	341a1788 <SAL_XSPI_GetId+0x60>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a1778:	2300      	movs	r3, #0
341a177a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
341a177c:	2300      	movs	r3, #0
341a177e:	657b      	str	r3, [r7, #84]	@ 0x54
    /* this behavior is linked with ISSI memory to read ID in 4S4S4S */
    s_command.DataMode          = HAL_XSPI_DATA_4_LINES;
341a1780:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a1784:	64bb      	str	r3, [r7, #72]	@ 0x48
341a1786:	e025      	b.n	341a17d4 <SAL_XSPI_GetId+0xac>
  }
  else if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_8_LINES)
341a1788:	69fb      	ldr	r3, [r7, #28]
341a178a:	2b04      	cmp	r3, #4
341a178c:	d11e      	bne.n	341a17cc <SAL_XSPI_GetId+0xa4>
  {
    s_command.Address = 0;
341a178e:	2300      	movs	r3, #0
341a1790:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Specific case for Macronix memories : RDID is not Data DTR  */
    if ((Data[0] == 0xC2) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a1792:	68bb      	ldr	r3, [r7, #8]
341a1794:	781b      	ldrb	r3, [r3, #0]
341a1796:	2bc2      	cmp	r3, #194	@ 0xc2
341a1798:	d108      	bne.n	341a17ac <SAL_XSPI_GetId+0x84>
341a179a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a179c:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a17a0:	d104      	bne.n	341a17ac <SAL_XSPI_GetId+0x84>
    {
      s_command.DummyCycles       = 4;
341a17a2:	2304      	movs	r3, #4
341a17a4:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.DataDTRMode       = HAL_XSPI_DATA_DTR_DISABLE;
341a17a6:	2300      	movs	r3, #0
341a17a8:	653b      	str	r3, [r7, #80]	@ 0x50
341a17aa:	e013      	b.n	341a17d4 <SAL_XSPI_GetId+0xac>
    }
    /* Specific case for GigaDevice memories : RDID has no address even in Octal mode  */
    else if ((Data[0] == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a17ac:	68bb      	ldr	r3, [r7, #8]
341a17ae:	781b      	ldrb	r3, [r3, #0]
341a17b0:	2bc8      	cmp	r3, #200	@ 0xc8
341a17b2:	d108      	bne.n	341a17c6 <SAL_XSPI_GetId+0x9e>
341a17b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a17b6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a17ba:	d104      	bne.n	341a17c6 <SAL_XSPI_GetId+0x9e>
    {
      s_command.DummyCycles       = 8;
341a17bc:	2308      	movs	r3, #8
341a17be:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a17c0:	2300      	movs	r3, #0
341a17c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
341a17c4:	e006      	b.n	341a17d4 <SAL_XSPI_GetId+0xac>
    }
    else
    {
      s_command.DummyCycles = 8;
341a17c6:	2308      	movs	r3, #8
341a17c8:	657b      	str	r3, [r7, #84]	@ 0x54
341a17ca:	e003      	b.n	341a17d4 <SAL_XSPI_GetId+0xac>
    }
    /* Required behavior to be confirmed on the other memories */
  }
  else
  {
    s_command.Address = 0;
341a17cc:	2300      	movs	r3, #0
341a17ce:	62bb      	str	r3, [r7, #40]	@ 0x28
    s_command.DummyCycles = 8;
341a17d0:	2308      	movs	r3, #8
341a17d2:	657b      	str	r3, [r7, #84]	@ 0x54
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a17d4:	68fb      	ldr	r3, [r7, #12]
341a17d6:	681b      	ldr	r3, [r3, #0]
341a17d8:	f107 0110 	add.w	r1, r7, #16
341a17dc:	2264      	movs	r2, #100	@ 0x64
341a17de:	4618      	mov	r0, r3
341a17e0:	f7f3 fd60 	bl	341952a4 <HAL_XSPI_Command>
341a17e4:	4603      	mov	r3, r0
341a17e6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if ( retr  != HAL_OK)
341a17ea:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a17ee:	2b00      	cmp	r3, #0
341a17f0:	d10a      	bne.n	341a1808 <SAL_XSPI_GetId+0xe0>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a17f2:	68fb      	ldr	r3, [r7, #12]
341a17f4:	681b      	ldr	r3, [r3, #0]
341a17f6:	2264      	movs	r2, #100	@ 0x64
341a17f8:	68b9      	ldr	r1, [r7, #8]
341a17fa:	4618      	mov	r0, r3
341a17fc:	f7f3 fe55 	bl	341954aa <HAL_XSPI_Receive>
341a1800:	4603      	mov	r3, r0
341a1802:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a1806:	e000      	b.n	341a180a <SAL_XSPI_GetId+0xe2>
    goto error;
341a1808:	bf00      	nop

error:
  if (retr != HAL_OK )
341a180a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a180e:	2b00      	cmp	r3, #0
341a1810:	d004      	beq.n	341a181c <SAL_XSPI_GetId+0xf4>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1812:	68fb      	ldr	r3, [r7, #12]
341a1814:	681b      	ldr	r3, [r3, #0]
341a1816:	4618      	mov	r0, r3
341a1818:	f7f3 ffe0 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a181c:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1820:	4618      	mov	r0, r3
341a1822:	3760      	adds	r7, #96	@ 0x60
341a1824:	46bd      	mov	sp, r7
341a1826:	bd80      	pop	{r7, pc}

341a1828 <SAL_XSPI_Read>:

HAL_StatusTypeDef SAL_XSPI_Read(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address, uint8_t *Data, uint32_t DataSize)
{
341a1828:	b580      	push	{r7, lr}
341a182a:	b098      	sub	sp, #96	@ 0x60
341a182c:	af00      	add	r7, sp, #0
341a182e:	60f8      	str	r0, [r7, #12]
341a1830:	607a      	str	r2, [r7, #4]
341a1832:	603b      	str	r3, [r7, #0]
341a1834:	460b      	mov	r3, r1
341a1836:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a1838:	68fb      	ldr	r3, [r7, #12]
341a183a:	f107 0010 	add.w	r0, r7, #16
341a183e:	3304      	adds	r3, #4
341a1840:	224c      	movs	r2, #76	@ 0x4c
341a1842:	4619      	mov	r1, r3
341a1844:	f002 fb29 	bl	341a3e9a <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a1848:	68fb      	ldr	r3, [r7, #12]
341a184a:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a184e:	6a39      	ldr	r1, [r7, #32]
341a1850:	7afa      	ldrb	r2, [r7, #11]
341a1852:	4618      	mov	r0, r3
341a1854:	f000 fa76 	bl	341a1d44 <XSPI_FormatCommand>
341a1858:	4603      	mov	r3, r0
341a185a:	61bb      	str	r3, [r7, #24]

  s_command.Address           = Address;
341a185c:	687b      	ldr	r3, [r7, #4]
341a185e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength        = DataSize;
341a1860:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a1862:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* DTR management for single/dual/quad */
  switch(SalXspi->PhyLink)
341a1864:	68fb      	ldr	r3, [r7, #12]
341a1866:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
341a186a:	2b05      	cmp	r3, #5
341a186c:	d006      	beq.n	341a187c <SAL_XSPI_Read+0x54>
341a186e:	2b05      	cmp	r3, #5
341a1870:	dc1a      	bgt.n	341a18a8 <SAL_XSPI_Read+0x80>
341a1872:	2b01      	cmp	r3, #1
341a1874:	d014      	beq.n	341a18a0 <SAL_XSPI_Read+0x78>
341a1876:	2b02      	cmp	r3, #2
341a1878:	d00b      	beq.n	341a1892 <SAL_XSPI_Read+0x6a>
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
   break;
   }
   default :{
     /* keep default parameters */
   break;
341a187a:	e015      	b.n	341a18a8 <SAL_XSPI_Read+0x80>
     s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a187c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a1880:	637b      	str	r3, [r7, #52]	@ 0x34
     s_command.DataDTRMode    = HAL_XSPI_DATA_DTR_ENABLE;
341a1882:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a1886:	653b      	str	r3, [r7, #80]	@ 0x50
     s_command.DummyCycles    = SalXspi->DTRDummyCycle;
341a1888:	68fb      	ldr	r3, [r7, #12]
341a188a:	f893 3053 	ldrb.w	r3, [r3, #83]	@ 0x53
341a188e:	657b      	str	r3, [r7, #84]	@ 0x54
   break;
341a1890:	e00b      	b.n	341a18aa <SAL_XSPI_Read+0x82>
     s_command.AddressMode    = HAL_XSPI_ADDRESS_2_LINES;
341a1892:	f44f 7300 	mov.w	r3, #512	@ 0x200
341a1896:	62fb      	str	r3, [r7, #44]	@ 0x2c
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
341a1898:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341a189c:	64bb      	str	r3, [r7, #72]	@ 0x48
   break;
341a189e:	e004      	b.n	341a18aa <SAL_XSPI_Read+0x82>
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
341a18a0:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341a18a4:	64bb      	str	r3, [r7, #72]	@ 0x48
   break;
341a18a6:	e000      	b.n	341a18aa <SAL_XSPI_Read+0x82>
   break;
341a18a8:	bf00      	nop
   }
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a18aa:	68fb      	ldr	r3, [r7, #12]
341a18ac:	681b      	ldr	r3, [r3, #0]
341a18ae:	f107 0110 	add.w	r1, r7, #16
341a18b2:	2264      	movs	r2, #100	@ 0x64
341a18b4:	4618      	mov	r0, r3
341a18b6:	f7f3 fcf5 	bl	341952a4 <HAL_XSPI_Command>
341a18ba:	4603      	mov	r3, r0
341a18bc:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (retr  != HAL_OK)
341a18c0:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a18c4:	2b00      	cmp	r3, #0
341a18c6:	d107      	bne.n	341a18d8 <SAL_XSPI_Read+0xb0>
  {
    goto error;
  }

  /* read the data */
  retr = XSPI_Receive(SalXspi, Data);
341a18c8:	6839      	ldr	r1, [r7, #0]
341a18ca:	68f8      	ldr	r0, [r7, #12]
341a18cc:	f000 fa76 	bl	341a1dbc <XSPI_Receive>
341a18d0:	4603      	mov	r3, r0
341a18d2:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a18d6:	e000      	b.n	341a18da <SAL_XSPI_Read+0xb2>
    goto error;
341a18d8:	bf00      	nop

error:
  if (retr != HAL_OK )
341a18da:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a18de:	2b00      	cmp	r3, #0
341a18e0:	d004      	beq.n	341a18ec <SAL_XSPI_Read+0xc4>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a18e2:	68fb      	ldr	r3, [r7, #12]
341a18e4:	681b      	ldr	r3, [r3, #0]
341a18e6:	4618      	mov	r0, r3
341a18e8:	f7f3 ff78 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a18ec:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a18f0:	4618      	mov	r0, r3
341a18f2:	3760      	adds	r7, #96	@ 0x60
341a18f4:	46bd      	mov	sp, r7
341a18f6:	bd80      	pop	{r7, pc}

341a18f8 <SAL_XSPI_Write>:

HAL_StatusTypeDef SAL_XSPI_Write(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address, const uint8_t *Data, uint32_t DataSize)
{
341a18f8:	b580      	push	{r7, lr}
341a18fa:	b098      	sub	sp, #96	@ 0x60
341a18fc:	af00      	add	r7, sp, #0
341a18fe:	60f8      	str	r0, [r7, #12]
341a1900:	607a      	str	r2, [r7, #4]
341a1902:	603b      	str	r3, [r7, #0]
341a1904:	460b      	mov	r3, r1
341a1906:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a1908:	68fb      	ldr	r3, [r7, #12]
341a190a:	f107 0010 	add.w	r0, r7, #16
341a190e:	3304      	adds	r3, #4
341a1910:	224c      	movs	r2, #76	@ 0x4c
341a1912:	4619      	mov	r1, r3
341a1914:	f002 fac1 	bl	341a3e9a <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a1918:	68fb      	ldr	r3, [r7, #12]
341a191a:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a191e:	6a39      	ldr	r1, [r7, #32]
341a1920:	7afa      	ldrb	r2, [r7, #11]
341a1922:	4618      	mov	r0, r3
341a1924:	f000 fa0e 	bl	341a1d44 <XSPI_FormatCommand>
341a1928:	4603      	mov	r3, r0
341a192a:	61bb      	str	r3, [r7, #24]

  s_command.Address           = Address;
341a192c:	687b      	ldr	r3, [r7, #4]
341a192e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength        = DataSize;
341a1930:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a1932:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DummyCycles       = 0u;
341a1934:	2300      	movs	r3, #0
341a1936:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DQSMode           = HAL_XSPI_DQS_DISABLE;
341a1938:	2300      	movs	r3, #0
341a193a:	65bb      	str	r3, [r7, #88]	@ 0x58

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a193c:	68fb      	ldr	r3, [r7, #12]
341a193e:	681b      	ldr	r3, [r3, #0]
341a1940:	f107 0110 	add.w	r1, r7, #16
341a1944:	2264      	movs	r2, #100	@ 0x64
341a1946:	4618      	mov	r0, r3
341a1948:	f7f3 fcac 	bl	341952a4 <HAL_XSPI_Command>
341a194c:	4603      	mov	r3, r0
341a194e:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (HAL_OK != retr)
341a1952:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1956:	2b00      	cmp	r3, #0
341a1958:	d107      	bne.n	341a196a <SAL_XSPI_Write+0x72>
  {
    goto error;
  }

  /* transmit data */
  retr = XSPI_Transmit(SalXspi, Data);
341a195a:	6839      	ldr	r1, [r7, #0]
341a195c:	68f8      	ldr	r0, [r7, #12]
341a195e:	f000 fa1a 	bl	341a1d96 <XSPI_Transmit>
341a1962:	4603      	mov	r3, r0
341a1964:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a1968:	e000      	b.n	341a196c <SAL_XSPI_Write+0x74>
    goto error;
341a196a:	bf00      	nop

error:
  if (retr != HAL_OK )
341a196c:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1970:	2b00      	cmp	r3, #0
341a1972:	d004      	beq.n	341a197e <SAL_XSPI_Write+0x86>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1974:	68fb      	ldr	r3, [r7, #12]
341a1976:	681b      	ldr	r3, [r3, #0]
341a1978:	4618      	mov	r0, r3
341a197a:	f7f3 ff2f 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a197e:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1982:	4618      	mov	r0, r3
341a1984:	3760      	adds	r7, #96	@ 0x60
341a1986:	46bd      	mov	sp, r7
341a1988:	bd80      	pop	{r7, pc}

341a198a <SAL_XSPI_CommandSendData>:
  return retr;
}

HAL_StatusTypeDef SAL_XSPI_CommandSendData(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
341a198a:	b580      	push	{r7, lr}
341a198c:	b098      	sub	sp, #96	@ 0x60
341a198e:	af00      	add	r7, sp, #0
341a1990:	60f8      	str	r0, [r7, #12]
341a1992:	607a      	str	r2, [r7, #4]
341a1994:	461a      	mov	r2, r3
341a1996:	460b      	mov	r3, r1
341a1998:	72fb      	strb	r3, [r7, #11]
341a199a:	4613      	mov	r3, r2
341a199c:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a199e:	68fb      	ldr	r3, [r7, #12]
341a19a0:	f107 0010 	add.w	r0, r7, #16
341a19a4:	3304      	adds	r3, #4
341a19a6:	224c      	movs	r2, #76	@ 0x4c
341a19a8:	4619      	mov	r1, r3
341a19aa:	f002 fa76 	bl	341a3e9a <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the writing of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a19ae:	68fb      	ldr	r3, [r7, #12]
341a19b0:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a19b4:	6a39      	ldr	r1, [r7, #32]
341a19b6:	7afa      	ldrb	r2, [r7, #11]
341a19b8:	4618      	mov	r0, r3
341a19ba:	f000 f9c3 	bl	341a1d44 <XSPI_FormatCommand>
341a19be:	4603      	mov	r3, r0
341a19c0:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
341a19c2:	2300      	movs	r3, #0
341a19c4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0U;
341a19c6:	2300      	movs	r3, #0
341a19c8:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a19ca:	893b      	ldrh	r3, [r7, #8]
341a19cc:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
341a19ce:	2300      	movs	r3, #0
341a19d0:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
341a19d2:	893b      	ldrh	r3, [r7, #8]
341a19d4:	2b00      	cmp	r3, #0
341a19d6:	d101      	bne.n	341a19dc <SAL_XSPI_CommandSendData+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
341a19d8:	2300      	movs	r3, #0
341a19da:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a19dc:	68fb      	ldr	r3, [r7, #12]
341a19de:	681b      	ldr	r3, [r3, #0]
341a19e0:	f107 0110 	add.w	r1, r7, #16
341a19e4:	2264      	movs	r2, #100	@ 0x64
341a19e6:	4618      	mov	r0, r3
341a19e8:	f7f3 fc5c 	bl	341952a4 <HAL_XSPI_Command>
341a19ec:	4603      	mov	r3, r0
341a19ee:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if (( retr == HAL_OK) && (DataSize != 0u))
341a19f2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a19f6:	2b00      	cmp	r3, #0
341a19f8:	d10c      	bne.n	341a1a14 <SAL_XSPI_CommandSendData+0x8a>
341a19fa:	893b      	ldrh	r3, [r7, #8]
341a19fc:	2b00      	cmp	r3, #0
341a19fe:	d009      	beq.n	341a1a14 <SAL_XSPI_CommandSendData+0x8a>
  {
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1a00:	68fb      	ldr	r3, [r7, #12]
341a1a02:	681b      	ldr	r3, [r3, #0]
341a1a04:	2264      	movs	r2, #100	@ 0x64
341a1a06:	6879      	ldr	r1, [r7, #4]
341a1a08:	4618      	mov	r0, r3
341a1a0a:	f7f3 fcdb 	bl	341953c4 <HAL_XSPI_Transmit>
341a1a0e:	4603      	mov	r3, r0
341a1a10:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a1a14:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1a18:	2b00      	cmp	r3, #0
341a1a1a:	d004      	beq.n	341a1a26 <SAL_XSPI_CommandSendData+0x9c>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1a1c:	68fb      	ldr	r3, [r7, #12]
341a1a1e:	681b      	ldr	r3, [r3, #0]
341a1a20:	4618      	mov	r0, r3
341a1a22:	f7f3 fedb 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a1a26:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1a2a:	4618      	mov	r0, r3
341a1a2c:	3760      	adds	r7, #96	@ 0x60
341a1a2e:	46bd      	mov	sp, r7
341a1a30:	bd80      	pop	{r7, pc}

341a1a32 <SAL_XSPI_SendReadCommand>:

HAL_StatusTypeDef SAL_XSPI_SendReadCommand(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
341a1a32:	b580      	push	{r7, lr}
341a1a34:	b098      	sub	sp, #96	@ 0x60
341a1a36:	af00      	add	r7, sp, #0
341a1a38:	60f8      	str	r0, [r7, #12]
341a1a3a:	607a      	str	r2, [r7, #4]
341a1a3c:	461a      	mov	r2, r3
341a1a3e:	460b      	mov	r3, r1
341a1a40:	72fb      	strb	r3, [r7, #11]
341a1a42:	4613      	mov	r3, r2
341a1a44:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a1a46:	68fb      	ldr	r3, [r7, #12]
341a1a48:	f107 0010 	add.w	r0, r7, #16
341a1a4c:	3304      	adds	r3, #4
341a1a4e:	224c      	movs	r2, #76	@ 0x4c
341a1a50:	4619      	mov	r1, r3
341a1a52:	f002 fa22 	bl	341a3e9a <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a1a56:	68fb      	ldr	r3, [r7, #12]
341a1a58:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a1a5c:	6a39      	ldr	r1, [r7, #32]
341a1a5e:	7afa      	ldrb	r2, [r7, #11]
341a1a60:	4618      	mov	r0, r3
341a1a62:	f000 f96f 	bl	341a1d44 <XSPI_FormatCommand>
341a1a66:	4603      	mov	r3, r0
341a1a68:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
341a1a6a:	2300      	movs	r3, #0
341a1a6c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0u;
341a1a6e:	2300      	movs	r3, #0
341a1a70:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a1a72:	893b      	ldrh	r3, [r7, #8]
341a1a74:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
341a1a76:	2300      	movs	r3, #0
341a1a78:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
341a1a7a:	893b      	ldrh	r3, [r7, #8]
341a1a7c:	2b00      	cmp	r3, #0
341a1a7e:	d101      	bne.n	341a1a84 <SAL_XSPI_SendReadCommand+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
341a1a80:	2300      	movs	r3, #0
341a1a82:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1a84:	68fb      	ldr	r3, [r7, #12]
341a1a86:	681b      	ldr	r3, [r3, #0]
341a1a88:	f107 0110 	add.w	r1, r7, #16
341a1a8c:	2264      	movs	r2, #100	@ 0x64
341a1a8e:	4618      	mov	r0, r3
341a1a90:	f7f3 fc08 	bl	341952a4 <HAL_XSPI_Command>
341a1a94:	4603      	mov	r3, r0
341a1a96:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if (( retr == HAL_OK) && (DataSize != 0u))
341a1a9a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1a9e:	2b00      	cmp	r3, #0
341a1aa0:	d10c      	bne.n	341a1abc <SAL_XSPI_SendReadCommand+0x8a>
341a1aa2:	893b      	ldrh	r3, [r7, #8]
341a1aa4:	2b00      	cmp	r3, #0
341a1aa6:	d009      	beq.n	341a1abc <SAL_XSPI_SendReadCommand+0x8a>
  {
    /* Get the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1aa8:	68fb      	ldr	r3, [r7, #12]
341a1aaa:	681b      	ldr	r3, [r3, #0]
341a1aac:	2264      	movs	r2, #100	@ 0x64
341a1aae:	6879      	ldr	r1, [r7, #4]
341a1ab0:	4618      	mov	r0, r3
341a1ab2:	f7f3 fcfa 	bl	341954aa <HAL_XSPI_Receive>
341a1ab6:	4603      	mov	r3, r0
341a1ab8:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a1abc:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1ac0:	2b00      	cmp	r3, #0
341a1ac2:	d004      	beq.n	341a1ace <SAL_XSPI_SendReadCommand+0x9c>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1ac4:	68fb      	ldr	r3, [r7, #12]
341a1ac6:	681b      	ldr	r3, [r3, #0]
341a1ac8:	4618      	mov	r0, r3
341a1aca:	f7f3 fe87 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a1ace:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1ad2:	4618      	mov	r0, r3
341a1ad4:	3760      	adds	r7, #96	@ 0x60
341a1ad6:	46bd      	mov	sp, r7
341a1ad8:	bd80      	pop	{r7, pc}

341a1ada <SAL_XSPI_CommandSendReadAddress>:

HAL_StatusTypeDef SAL_XSPI_CommandSendReadAddress(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                                  uint32_t Address, uint8_t *Data, uint16_t DataSize,
                                                  uint8_t ManuId)
{
341a1ada:	b580      	push	{r7, lr}
341a1adc:	b098      	sub	sp, #96	@ 0x60
341a1ade:	af00      	add	r7, sp, #0
341a1ae0:	60f8      	str	r0, [r7, #12]
341a1ae2:	607a      	str	r2, [r7, #4]
341a1ae4:	603b      	str	r3, [r7, #0]
341a1ae6:	460b      	mov	r3, r1
341a1ae8:	72fb      	strb	r3, [r7, #11]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a1aea:	68fb      	ldr	r3, [r7, #12]
341a1aec:	f107 0010 	add.w	r0, r7, #16
341a1af0:	3304      	adds	r3, #4
341a1af2:	224c      	movs	r2, #76	@ 0x4c
341a1af4:	4619      	mov	r1, r3
341a1af6:	f002 f9d0 	bl	341a3e9a <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a1afa:	68fb      	ldr	r3, [r7, #12]
341a1afc:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a1b00:	6a39      	ldr	r1, [r7, #32]
341a1b02:	7afa      	ldrb	r2, [r7, #11]
341a1b04:	4618      	mov	r0, r3
341a1b06:	f000 f91d 	bl	341a1d44 <XSPI_FormatCommand>
341a1b0a:	4603      	mov	r3, r0
341a1b0c:	61bb      	str	r3, [r7, #24]

  s_command.Address            = Address;
341a1b0e:	687b      	ldr	r3, [r7, #4]
341a1b10:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DummyCycles        = SalXspi->SFDPDummyCycle;
341a1b12:	68fb      	ldr	r3, [r7, #12]
341a1b14:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
341a1b18:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a1b1a:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
341a1b1e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
  if ((ManuId == EXTMEM_MANFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a1b20:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
341a1b24:	2bc2      	cmp	r3, #194	@ 0xc2
341a1b26:	d106      	bne.n	341a1b36 <SAL_XSPI_CommandSendReadAddress+0x5c>
341a1b28:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a1b2a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a1b2e:	d102      	bne.n	341a1b36 <SAL_XSPI_CommandSendReadAddress+0x5c>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
341a1b30:	2300      	movs	r3, #0
341a1b32:	653b      	str	r3, [r7, #80]	@ 0x50
341a1b34:	e00e      	b.n	341a1b54 <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  /* Specific case for GigaDevice memories : Read Configuration Register are not Data DTR  */
  else if ((ManuId == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a1b36:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
341a1b3a:	2bc8      	cmp	r3, #200	@ 0xc8
341a1b3c:	d108      	bne.n	341a1b50 <SAL_XSPI_CommandSendReadAddress+0x76>
341a1b3e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a1b40:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a1b44:	d104      	bne.n	341a1b50 <SAL_XSPI_CommandSendReadAddress+0x76>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
341a1b46:	2300      	movs	r3, #0
341a1b48:	653b      	str	r3, [r7, #80]	@ 0x50
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
341a1b4a:	2300      	movs	r3, #0
341a1b4c:	65bb      	str	r3, [r7, #88]	@ 0x58
341a1b4e:	e001      	b.n	341a1b54 <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  else
  {
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
341a1b50:	2300      	movs	r3, #0
341a1b52:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1b54:	68fb      	ldr	r3, [r7, #12]
341a1b56:	681b      	ldr	r3, [r3, #0]
341a1b58:	f107 0110 	add.w	r1, r7, #16
341a1b5c:	2264      	movs	r2, #100	@ 0x64
341a1b5e:	4618      	mov	r0, r3
341a1b60:	f7f3 fba0 	bl	341952a4 <HAL_XSPI_Command>
341a1b64:	4603      	mov	r3, r0
341a1b66:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if ( retr == HAL_OK)
341a1b6a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1b6e:	2b00      	cmp	r3, #0
341a1b70:	d109      	bne.n	341a1b86 <SAL_XSPI_CommandSendReadAddress+0xac>
  {
    /* Get the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1b72:	68fb      	ldr	r3, [r7, #12]
341a1b74:	681b      	ldr	r3, [r3, #0]
341a1b76:	2264      	movs	r2, #100	@ 0x64
341a1b78:	6839      	ldr	r1, [r7, #0]
341a1b7a:	4618      	mov	r0, r3
341a1b7c:	f7f3 fc95 	bl	341954aa <HAL_XSPI_Receive>
341a1b80:	4603      	mov	r3, r0
341a1b82:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a1b86:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a1b8a:	2b00      	cmp	r3, #0
341a1b8c:	d004      	beq.n	341a1b98 <SAL_XSPI_CommandSendReadAddress+0xbe>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1b8e:	68fb      	ldr	r3, [r7, #12]
341a1b90:	681b      	ldr	r3, [r3, #0]
341a1b92:	4618      	mov	r0, r3
341a1b94:	f7f3 fe22 	bl	341957dc <HAL_XSPI_Abort>
  }
  return retr;
341a1b98:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a1b9c:	4618      	mov	r0, r3
341a1b9e:	3760      	adds	r7, #96	@ 0x60
341a1ba0:	46bd      	mov	sp, r7
341a1ba2:	bd80      	pop	{r7, pc}

341a1ba4 <SAL_XSPI_CheckStatusRegister>:

HAL_StatusTypeDef SAL_XSPI_CheckStatusRegister(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address,
                                               uint8_t MatchValue, uint8_t MatchMask, uint8_t ManuId,
                                               uint32_t Timeout)
{
341a1ba4:	b580      	push	{r7, lr}
341a1ba6:	b09e      	sub	sp, #120	@ 0x78
341a1ba8:	af00      	add	r7, sp, #0
341a1baa:	60f8      	str	r0, [r7, #12]
341a1bac:	607a      	str	r2, [r7, #4]
341a1bae:	461a      	mov	r2, r3
341a1bb0:	460b      	mov	r3, r1
341a1bb2:	72fb      	strb	r3, [r7, #11]
341a1bb4:	4613      	mov	r3, r2
341a1bb6:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a1bb8:	68fb      	ldr	r3, [r7, #12]
341a1bba:	f107 0028 	add.w	r0, r7, #40	@ 0x28
341a1bbe:	3304      	adds	r3, #4
341a1bc0:	224c      	movs	r2, #76	@ 0x4c
341a1bc2:	4619      	mov	r1, r3
341a1bc4:	f002 f969 	bl	341a3e9a <memcpy>
  XSPI_AutoPollingTypeDef  s_config = {
341a1bc8:	7abb      	ldrb	r3, [r7, #10]
341a1bca:	617b      	str	r3, [r7, #20]
341a1bcc:	f897 3080 	ldrb.w	r3, [r7, #128]	@ 0x80
341a1bd0:	61bb      	str	r3, [r7, #24]
341a1bd2:	2300      	movs	r3, #0
341a1bd4:	61fb      	str	r3, [r7, #28]
341a1bd6:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
341a1bda:	623b      	str	r3, [r7, #32]
341a1bdc:	2310      	movs	r3, #16
341a1bde:	627b      	str	r3, [r7, #36]	@ 0x24
                                       .IntervalTime  = 0x10
                                      };
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a1be0:	68fb      	ldr	r3, [r7, #12]
341a1be2:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a1be6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
341a1be8:	7afa      	ldrb	r2, [r7, #11]
341a1bea:	4618      	mov	r0, r3
341a1bec:	f000 f8aa 	bl	341a1d44 <XSPI_FormatCommand>
341a1bf0:	4603      	mov	r3, r0
341a1bf2:	633b      	str	r3, [r7, #48]	@ 0x30

  s_command.DataLength     = 1u;
341a1bf4:	2301      	movs	r3, #1
341a1bf6:	667b      	str	r3, [r7, #100]	@ 0x64
  s_command.DQSMode        = HAL_XSPI_DQS_DISABLE;
341a1bf8:	2300      	movs	r3, #0
341a1bfa:	673b      	str	r3, [r7, #112]	@ 0x70

  if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
341a1bfc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341a1bfe:	2b01      	cmp	r3, #1
341a1c00:	d106      	bne.n	341a1c10 <SAL_XSPI_CheckStatusRegister+0x6c>
  {
    /* patch cypress to force 1 line on status read */
    s_command.DataMode    = HAL_XSPI_DATA_1_LINE;
341a1c02:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a1c06:	663b      	str	r3, [r7, #96]	@ 0x60
    s_command.AddressMode = HAL_XSPI_DATA_NONE;
341a1c08:	2300      	movs	r3, #0
341a1c0a:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.DummyCycles = 0u;
341a1c0c:	2300      	movs	r3, #0
341a1c0e:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* @ is used only in 8 LINES format */
  if (s_command.DataMode == HAL_XSPI_DATA_8_LINES)
341a1c10:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
341a1c12:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
341a1c16:	d114      	bne.n	341a1c42 <SAL_XSPI_CheckStatusRegister+0x9e>
  {
    /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
    if ((ManuId == EXTMEM_MANFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a1c18:	f897 3084 	ldrb.w	r3, [r7, #132]	@ 0x84
341a1c1c:	2bc2      	cmp	r3, #194	@ 0xc2
341a1c1e:	d108      	bne.n	341a1c32 <SAL_XSPI_CheckStatusRegister+0x8e>
341a1c20:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a1c22:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a1c26:	d104      	bne.n	341a1c32 <SAL_XSPI_CheckStatusRegister+0x8e>
    {
      s_command.DQSMode        = HAL_XSPI_DQS_ENABLE;
341a1c28:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a1c2c:	673b      	str	r3, [r7, #112]	@ 0x70
      s_command.DataDTRMode    = HAL_XSPI_DATA_DTR_DISABLE;
341a1c2e:	2300      	movs	r3, #0
341a1c30:	66bb      	str	r3, [r7, #104]	@ 0x68
    }
    s_command.AddressMode    = HAL_XSPI_ADDRESS_8_LINES;
341a1c32:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a1c36:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.AddressWidth   = HAL_XSPI_ADDRESS_32_BITS;
341a1c38:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a1c3c:	64bb      	str	r3, [r7, #72]	@ 0x48
    s_command.Address        = Address;
341a1c3e:	687b      	ldr	r3, [r7, #4]
341a1c40:	643b      	str	r3, [r7, #64]	@ 0x40
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1c42:	68fb      	ldr	r3, [r7, #12]
341a1c44:	681b      	ldr	r3, [r3, #0]
341a1c46:	f107 0128 	add.w	r1, r7, #40	@ 0x28
341a1c4a:	2264      	movs	r2, #100	@ 0x64
341a1c4c:	4618      	mov	r0, r3
341a1c4e:	f7f3 fb29 	bl	341952a4 <HAL_XSPI_Command>
341a1c52:	4603      	mov	r3, r0
341a1c54:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
  if ( retr == HAL_OK)
341a1c58:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
341a1c5c:	2b00      	cmp	r3, #0
341a1c5e:	d10b      	bne.n	341a1c78 <SAL_XSPI_CheckStatusRegister+0xd4>
  {
    retr = HAL_XSPI_AutoPolling(SalXspi->hxspi, &s_config, Timeout);
341a1c60:	68fb      	ldr	r3, [r7, #12]
341a1c62:	681b      	ldr	r3, [r3, #0]
341a1c64:	f107 0114 	add.w	r1, r7, #20
341a1c68:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
341a1c6c:	4618      	mov	r0, r3
341a1c6e:	f7f3 fcbf 	bl	341955f0 <HAL_XSPI_AutoPolling>
341a1c72:	4603      	mov	r3, r0
341a1c74:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    DEBUG_AUTOPOLLING(SalXspi->hxspi->Instance->DR, s_config.MatchValue, s_config.MatchMask)
  }

  if (retr != HAL_OK )
341a1c78:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
341a1c7c:	2b00      	cmp	r3, #0
341a1c7e:	d004      	beq.n	341a1c8a <SAL_XSPI_CheckStatusRegister+0xe6>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a1c80:	68fb      	ldr	r3, [r7, #12]
341a1c82:	681b      	ldr	r3, [r3, #0]
341a1c84:	4618      	mov	r0, r3
341a1c86:	f7f3 fda9 	bl	341957dc <HAL_XSPI_Abort>
  }
  /* return status */
  return retr;
341a1c8a:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
341a1c8e:	4618      	mov	r0, r3
341a1c90:	3778      	adds	r7, #120	@ 0x78
341a1c92:	46bd      	mov	sp, r7
341a1c94:	bd80      	pop	{r7, pc}

341a1c96 <SAL_XSPI_DisableMapMode>:
  /* return status */
  return retr;
}

HAL_StatusTypeDef SAL_XSPI_DisableMapMode(SAL_XSPI_ObjectTypeDef *SalXspi)
{
341a1c96:	b580      	push	{r7, lr}
341a1c98:	b082      	sub	sp, #8
341a1c9a:	af00      	add	r7, sp, #0
341a1c9c:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dsb 0xF":::"memory");
341a1c9e:	f3bf 8f4f 	dsb	sy
}
341a1ca2:	bf00      	nop
  __DSB();
  return HAL_XSPI_Abort(SalXspi->hxspi);
341a1ca4:	687b      	ldr	r3, [r7, #4]
341a1ca6:	681b      	ldr	r3, [r3, #0]
341a1ca8:	4618      	mov	r0, r3
341a1caa:	f7f3 fd97 	bl	341957dc <HAL_XSPI_Abort>
341a1cae:	4603      	mov	r3, r0
}
341a1cb0:	4618      	mov	r0, r3
341a1cb2:	3708      	adds	r7, #8
341a1cb4:	46bd      	mov	sp, r7
341a1cb6:	bd80      	pop	{r7, pc}

341a1cb8 <SAL_XSPI_UpdateMemoryType>:


HAL_StatusTypeDef SAL_XSPI_UpdateMemoryType(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_DataOrderTypeDef DataOrder)
{
341a1cb8:	b480      	push	{r7}
341a1cba:	b085      	sub	sp, #20
341a1cbc:	af00      	add	r7, sp, #0
341a1cbe:	6078      	str	r0, [r7, #4]
341a1cc0:	460b      	mov	r3, r1
341a1cc2:	70fb      	strb	r3, [r7, #3]
HAL_StatusTypeDef retr = HAL_OK;
341a1cc4:	2300      	movs	r3, #0
341a1cc6:	73fb      	strb	r3, [r7, #15]

  /* read the memory type value */
  uint32_t memorytype = READ_REG(SalXspi->hxspi->Instance->DCR1) & XSPI_DCR1_MTYP;
341a1cc8:	687b      	ldr	r3, [r7, #4]
341a1cca:	681b      	ldr	r3, [r3, #0]
341a1ccc:	681b      	ldr	r3, [r3, #0]
341a1cce:	689b      	ldr	r3, [r3, #8]
341a1cd0:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
341a1cd4:	60bb      	str	r3, [r7, #8]

  switch(DataOrder)
341a1cd6:	78fb      	ldrb	r3, [r7, #3]
341a1cd8:	2b00      	cmp	r3, #0
341a1cda:	d11e      	bne.n	341a1d1a <SAL_XSPI_UpdateMemoryType+0x62>
  {
  case SAL_XSPI_ORDERINVERTED :
    if (memorytype == HAL_XSPI_MEMTYPE_MICRON) {
341a1cdc:	68bb      	ldr	r3, [r7, #8]
341a1cde:	2b00      	cmp	r3, #0
341a1ce0:	d103      	bne.n	341a1cea <SAL_XSPI_UpdateMemoryType+0x32>
      memorytype = HAL_XSPI_MEMTYPE_MACRONIX;
341a1ce2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a1ce6:	60bb      	str	r3, [r7, #8]
341a1ce8:	e008      	b.n	341a1cfc <SAL_XSPI_UpdateMemoryType+0x44>
    } else if (memorytype == HAL_XSPI_MEMTYPE_MACRONIX) {
341a1cea:	68bb      	ldr	r3, [r7, #8]
341a1cec:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341a1cf0:	d102      	bne.n	341a1cf8 <SAL_XSPI_UpdateMemoryType+0x40>
      memorytype = HAL_XSPI_MEMTYPE_MICRON;
341a1cf2:	2300      	movs	r3, #0
341a1cf4:	60bb      	str	r3, [r7, #8]
341a1cf6:	e001      	b.n	341a1cfc <SAL_XSPI_UpdateMemoryType+0x44>
    } else {
      retr = HAL_ERROR;
341a1cf8:	2301      	movs	r3, #1
341a1cfa:	73fb      	strb	r3, [r7, #15]
    }
    MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_MTYP, memorytype);
341a1cfc:	687b      	ldr	r3, [r7, #4]
341a1cfe:	681b      	ldr	r3, [r3, #0]
341a1d00:	681b      	ldr	r3, [r3, #0]
341a1d02:	689b      	ldr	r3, [r3, #8]
341a1d04:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
341a1d08:	687b      	ldr	r3, [r7, #4]
341a1d0a:	681b      	ldr	r3, [r3, #0]
341a1d0c:	681b      	ldr	r3, [r3, #0]
341a1d0e:	68ba      	ldr	r2, [r7, #8]
341a1d10:	430a      	orrs	r2, r1
341a1d12:	609a      	str	r2, [r3, #8]
    break;
341a1d14:	bf00      	nop
    return HAL_ERROR;
    break;
  }

  DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::SAL_XSPI_UpdateMemoryType::"); DEBUG_PARAM_INT(memorytype); DEBUG_PARAM_END();
  return retr;
341a1d16:	7bfb      	ldrb	r3, [r7, #15]
341a1d18:	e000      	b.n	341a1d1c <SAL_XSPI_UpdateMemoryType+0x64>
    return HAL_ERROR;
341a1d1a:	2301      	movs	r3, #1
}
341a1d1c:	4618      	mov	r0, r3
341a1d1e:	3714      	adds	r7, #20
341a1d20:	46bd      	mov	sp, r7
341a1d22:	f85d 7b04 	ldr.w	r7, [sp], #4
341a1d26:	4770      	bx	lr

341a1d28 <SAL_XSPI_Abort>:

HAL_StatusTypeDef SAL_XSPI_Abort(SAL_XSPI_ObjectTypeDef *SalXspi)
{
341a1d28:	b580      	push	{r7, lr}
341a1d2a:	b082      	sub	sp, #8
341a1d2c:	af00      	add	r7, sp, #0
341a1d2e:	6078      	str	r0, [r7, #4]
  return HAL_XSPI_Abort(SalXspi->hxspi);
341a1d30:	687b      	ldr	r3, [r7, #4]
341a1d32:	681b      	ldr	r3, [r3, #0]
341a1d34:	4618      	mov	r0, r3
341a1d36:	f7f3 fd51 	bl	341957dc <HAL_XSPI_Abort>
341a1d3a:	4603      	mov	r3, r0
}
341a1d3c:	4618      	mov	r0, r3
341a1d3e:	3708      	adds	r7, #8
341a1d40:	46bd      	mov	sp, r7
341a1d42:	bd80      	pop	{r7, pc}

341a1d44 <XSPI_FormatCommand>:
  * @param InstructionWidth instruction width
  * @param Command command
  * @return the formatted command
  */
uint16_t XSPI_FormatCommand(uint8_t CommandExtension, uint32_t InstructionWidth, uint8_t Command)
{
341a1d44:	b480      	push	{r7}
341a1d46:	b085      	sub	sp, #20
341a1d48:	af00      	add	r7, sp, #0
341a1d4a:	4603      	mov	r3, r0
341a1d4c:	6039      	str	r1, [r7, #0]
341a1d4e:	71fb      	strb	r3, [r7, #7]
341a1d50:	4613      	mov	r3, r2
341a1d52:	71bb      	strb	r3, [r7, #6]
  uint16_t retr;
  if  (InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS)
341a1d54:	683b      	ldr	r3, [r7, #0]
341a1d56:	2b10      	cmp	r3, #16
341a1d58:	d114      	bne.n	341a1d84 <XSPI_FormatCommand+0x40>
  {
    /* 0b00 The Command Extension is the same as the Command. (The Command / Command Extension has the same value for the whole clock period.)*/
    /* 0b01 The Command Extension is the inverse of the Command. The Command Extension acts as a confirmation of the Command */
    /* 0b11 Command and Command Extension forms a 16 bit command word :: Not yet handled */
    retr = ((uint16_t)Command << 8u);
341a1d5a:	79bb      	ldrb	r3, [r7, #6]
341a1d5c:	b29b      	uxth	r3, r3
341a1d5e:	021b      	lsls	r3, r3, #8
341a1d60:	81fb      	strh	r3, [r7, #14]
    if (CommandExtension == 1u)
341a1d62:	79fb      	ldrb	r3, [r7, #7]
341a1d64:	2b01      	cmp	r3, #1
341a1d66:	d107      	bne.n	341a1d78 <XSPI_FormatCommand+0x34>
    {
       retr|=  (uint8_t)(~Command & 0xFFu);
341a1d68:	79bb      	ldrb	r3, [r7, #6]
341a1d6a:	43db      	mvns	r3, r3
341a1d6c:	b2db      	uxtb	r3, r3
341a1d6e:	461a      	mov	r2, r3
341a1d70:	89fb      	ldrh	r3, [r7, #14]
341a1d72:	4313      	orrs	r3, r2
341a1d74:	81fb      	strh	r3, [r7, #14]
341a1d76:	e007      	b.n	341a1d88 <XSPI_FormatCommand+0x44>
    }
    else
    {
       retr|=  (uint8_t)(Command & 0xFFu);
341a1d78:	79bb      	ldrb	r3, [r7, #6]
341a1d7a:	b29a      	uxth	r2, r3
341a1d7c:	89fb      	ldrh	r3, [r7, #14]
341a1d7e:	4313      	orrs	r3, r2
341a1d80:	81fb      	strh	r3, [r7, #14]
341a1d82:	e001      	b.n	341a1d88 <XSPI_FormatCommand+0x44>
    }
  }
  else
  {
    retr = Command;
341a1d84:	79bb      	ldrb	r3, [r7, #6]
341a1d86:	81fb      	strh	r3, [r7, #14]
  }

  return retr;
341a1d88:	89fb      	ldrh	r3, [r7, #14]
}
341a1d8a:	4618      	mov	r0, r3
341a1d8c:	3714      	adds	r7, #20
341a1d8e:	46bd      	mov	sp, r7
341a1d90:	f85d 7b04 	ldr.w	r7, [sp], #4
341a1d94:	4770      	bx	lr

341a1d96 <XSPI_Transmit>:
  * @param SalXspi handle on the XSPI IP
  * @param Data data pointer
  * @return none
  */
HAL_StatusTypeDef XSPI_Transmit(SAL_XSPI_ObjectTypeDef *SalXspi, const uint8_t *Data)
{
341a1d96:	b580      	push	{r7, lr}
341a1d98:	b084      	sub	sp, #16
341a1d9a:	af00      	add	r7, sp, #0
341a1d9c:	6078      	str	r0, [r7, #4]
341a1d9e:	6039      	str	r1, [r7, #0]
#if defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U)
  if (SalXspi->hxspi->hdmatx == NULL)
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  {
    /* transmit data */
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1da0:	687b      	ldr	r3, [r7, #4]
341a1da2:	681b      	ldr	r3, [r3, #0]
341a1da4:	2264      	movs	r2, #100	@ 0x64
341a1da6:	6839      	ldr	r1, [r7, #0]
341a1da8:	4618      	mov	r0, r3
341a1daa:	f7f3 fb0b 	bl	341953c4 <HAL_XSPI_Transmit>
341a1dae:	4603      	mov	r3, r0
341a1db0:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

  return retr;
341a1db2:	7bfb      	ldrb	r3, [r7, #15]
}
341a1db4:	4618      	mov	r0, r3
341a1db6:	3710      	adds	r7, #16
341a1db8:	46bd      	mov	sp, r7
341a1dba:	bd80      	pop	{r7, pc}

341a1dbc <XSPI_Receive>:
  * @param SalXspi handle on the XSPI IP
  * @param Data data pointer
  * @return none
  */
HAL_StatusTypeDef XSPI_Receive(SAL_XSPI_ObjectTypeDef *SalXspi,  uint8_t *Data)
{
341a1dbc:	b580      	push	{r7, lr}
341a1dbe:	b084      	sub	sp, #16
341a1dc0:	af00      	add	r7, sp, #0
341a1dc2:	6078      	str	r0, [r7, #4]
341a1dc4:	6039      	str	r1, [r7, #0]
#if defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U)
  if (SalXspi->hxspi->hdmarx == NULL)
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  {
    /* Reception of the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a1dc6:	687b      	ldr	r3, [r7, #4]
341a1dc8:	681b      	ldr	r3, [r3, #0]
341a1dca:	2264      	movs	r2, #100	@ 0x64
341a1dcc:	6839      	ldr	r1, [r7, #0]
341a1dce:	4618      	mov	r0, r3
341a1dd0:	f7f3 fb6b 	bl	341954aa <HAL_XSPI_Receive>
341a1dd4:	4603      	mov	r3, r0
341a1dd6:	73fb      	strb	r3, [r7, #15]
        retr = HAL_ERROR;
      }
    }
  }
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  return retr;
341a1dd8:	7bfb      	ldrb	r3, [r7, #15]
}
341a1dda:	4618      	mov	r0, r3
341a1ddc:	3710      	adds	r7, #16
341a1dde:	46bd      	mov	sp, r7
341a1de0:	bd80      	pop	{r7, pc}

341a1de2 <SFDP_ReadHeader>:
 * @param Object memory Object
 * @param sfdp_header data of the SFDP header
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef SFDP_ReadHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
341a1de2:	b580      	push	{r7, lr}
341a1de4:	b084      	sub	sp, #16
341a1de6:	af00      	add	r7, sp, #0
341a1de8:	6078      	str	r0, [r7, #4]
341a1dea:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr;
  uint8_t retry_counter = 0;
341a1dec:	2300      	movs	r3, #0
341a1dee:	73bb      	strb	r3, [r7, #14]
  SFDP_DEBUG_STR(__func__);

  do {
    /* Reset the signature value */
    sfdp_header->Signature = 0;
341a1df0:	683b      	ldr	r3, [r7, #0]
341a1df2:	2200      	movs	r2, #0
341a1df4:	601a      	str	r2, [r3, #0]

    /* send the SFDP command to read the header */
    if(HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, 0, (uint8_t*)sfdp_header, SFDP_HEADER_SIZE))
341a1df6:	687b      	ldr	r3, [r7, #4]
341a1df8:	f103 0008 	add.w	r0, r3, #8
341a1dfc:	2308      	movs	r3, #8
341a1dfe:	683a      	ldr	r2, [r7, #0]
341a1e00:	2100      	movs	r1, #0
341a1e02:	f7ff fc37 	bl	341a1674 <SAL_XSPI_GetSFDP>
341a1e06:	4603      	mov	r3, r0
341a1e08:	2b00      	cmp	r3, #0
341a1e0a:	d002      	beq.n	341a1e12 <SFDP_ReadHeader+0x30>
    {
      retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a1e0c:	2303      	movs	r3, #3
341a1e0e:	73fb      	strb	r3, [r7, #15]
      goto error;
341a1e10:	e01f      	b.n	341a1e52 <SFDP_ReadHeader+0x70>
    }

    /* view the header signature value  */
    SFDP_DEBUG_INT("SFDP signature::", sfdp_header->Signature);

    switch(CheckSFDP_Signature(Object, sfdp_header->Signature))
341a1e12:	683b      	ldr	r3, [r7, #0]
341a1e14:	681b      	ldr	r3, [r3, #0]
341a1e16:	4619      	mov	r1, r3
341a1e18:	6878      	ldr	r0, [r7, #4]
341a1e1a:	f001 fc53 	bl	341a36c4 <CheckSFDP_Signature>
341a1e1e:	4603      	mov	r3, r0
341a1e20:	2b00      	cmp	r3, #0
341a1e22:	d002      	beq.n	341a1e2a <SFDP_ReadHeader+0x48>
341a1e24:	2b05      	cmp	r3, #5
341a1e26:	d005      	beq.n	341a1e34 <SFDP_ReadHeader+0x52>
341a1e28:	e00a      	b.n	341a1e40 <SFDP_ReadHeader+0x5e>
    {
    case EXTMEM_SFDP_OK:
      SFDP_DEBUG_INT("param_number=", sfdp_header->param_number);
      SFDP_DEBUG_INT("AccessProtocol=", sfdp_header->AccessProtocol);
      retr = EXTMEM_SFDP_OK;
341a1e2a:	2300      	movs	r3, #0
341a1e2c:	73fb      	strb	r3, [r7, #15]
      retry_counter = 2u;
341a1e2e:	2302      	movs	r3, #2
341a1e30:	73bb      	strb	r3, [r7, #14]
    break;
341a1e32:	e00a      	b.n	341a1e4a <SFDP_ReadHeader+0x68>
    case EXTMEM_SFDP_ERROR_SIGNATUREMTYPE:
      retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a1e34:	2304      	movs	r3, #4
341a1e36:	73fb      	strb	r3, [r7, #15]
      retry_counter++;
341a1e38:	7bbb      	ldrb	r3, [r7, #14]
341a1e3a:	3301      	adds	r3, #1
341a1e3c:	73bb      	strb	r3, [r7, #14]
      break;
341a1e3e:	e004      	b.n	341a1e4a <SFDP_ReadHeader+0x68>
    /* case EXTMEM_SFDP_ERROR_SIGNATURE :*/
    default :
      retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a1e40:	2304      	movs	r3, #4
341a1e42:	73fb      	strb	r3, [r7, #15]
      retry_counter = 2u;
341a1e44:	2302      	movs	r3, #2
341a1e46:	73bb      	strb	r3, [r7, #14]
      break;
341a1e48:	bf00      	nop
    }
  } while(retry_counter < 2u);
341a1e4a:	7bbb      	ldrb	r3, [r7, #14]
341a1e4c:	2b01      	cmp	r3, #1
341a1e4e:	d9cf      	bls.n	341a1df0 <SFDP_ReadHeader+0xe>

error:
341a1e50:	bf00      	nop
  return retr;
341a1e52:	7bfb      	ldrb	r3, [r7, #15]
}
341a1e54:	4618      	mov	r0, r3
341a1e56:	3710      	adds	r7, #16
341a1e58:	46bd      	mov	sp, r7
341a1e5a:	bd80      	pop	{r7, pc}

341a1e5c <SFDP_GetHeader>:


SFDP_StatusTypeDef SFDP_GetHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
341a1e5c:	b590      	push	{r4, r7, lr}
341a1e5e:	b089      	sub	sp, #36	@ 0x24
341a1e60:	af00      	add	r7, sp, #0
341a1e62:	6078      	str	r0, [r7, #4]
341a1e64:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a1e66:	2304      	movs	r3, #4
341a1e68:	77fb      	strb	r3, [r7, #31]
  SFDP_DEBUG_STR(__func__);
  const TableConfig_Typedef table_config[] =
341a1e6a:	4b2a      	ldr	r3, [pc, #168]	@ (341a1f14 <SFDP_GetHeader+0xb8>)
341a1e6c:	f107 040c 	add.w	r4, r7, #12
341a1e70:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
341a1e72:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    {PHY_LINK_8D8D8D, 10u},
    {PHY_LINK_8D8D8D, 16u}
  };

  /* loop to find the link configuration of the memory */
  for (uint8_t index = 0u;
341a1e76:	2300      	movs	r3, #0
341a1e78:	77bb      	strb	r3, [r7, #30]
341a1e7a:	e040      	b.n	341a1efe <SFDP_GetHeader+0xa2>
  {
    /* Set the command mode */
    SFDP_DEBUG_STR("try a command configuration");

    /* Configure the link */
    Object->sfdp_private.DriverInfo.SpiPhyLink  = table_config[index].PhyLink;
341a1e7c:	7fbb      	ldrb	r3, [r7, #30]
341a1e7e:	005b      	lsls	r3, r3, #1
341a1e80:	3320      	adds	r3, #32
341a1e82:	443b      	add	r3, r7
341a1e84:	f813 2c14 	ldrb.w	r2, [r3, #-20]
341a1e88:	687b      	ldr	r3, [r7, #4]
341a1e8a:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
    (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink);
341a1e8e:	687b      	ldr	r3, [r7, #4]
341a1e90:	f103 0008 	add.w	r0, r3, #8
341a1e94:	687b      	ldr	r3, [r7, #4]
341a1e96:	3364      	adds	r3, #100	@ 0x64
341a1e98:	461a      	mov	r2, r3
341a1e9a:	2100      	movs	r1, #0
341a1e9c:	f7ff fa98 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
    SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, table_config[index].DummyCycle);
341a1ea0:	7fbb      	ldrb	r3, [r7, #30]
341a1ea2:	005b      	lsls	r3, r3, #1
341a1ea4:	3320      	adds	r3, #32
341a1ea6:	443b      	add	r3, r7
341a1ea8:	f813 2c13 	ldrb.w	r2, [r3, #-19]
341a1eac:	687b      	ldr	r3, [r7, #4]
341a1eae:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

    /* Loop on the instruction extension */
    for (uint8_t IExt = 0u;
341a1eb2:	2300      	movs	r3, #0
341a1eb4:	777b      	strb	r3, [r7, #29]
341a1eb6:	e017      	b.n	341a1ee8 <SFDP_GetHeader+0x8c>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
    {
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject, IExt);
341a1eb8:	687b      	ldr	r3, [r7, #4]
341a1eba:	7f7a      	ldrb	r2, [r7, #29]
341a1ebc:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
      /* Read the sfdp header */
      if (EXTMEM_SFDP_OK == SFDP_ReadHeader(Object, sfdp_header))
341a1ec0:	6839      	ldr	r1, [r7, #0]
341a1ec2:	6878      	ldr	r0, [r7, #4]
341a1ec4:	f7ff ff8d 	bl	341a1de2 <SFDP_ReadHeader>
341a1ec8:	4603      	mov	r3, r0
341a1eca:	2b00      	cmp	r3, #0
341a1ecc:	d101      	bne.n	341a1ed2 <SFDP_GetHeader+0x76>
      {
        retr = EXTMEM_SFDP_OK;
341a1ece:	2300      	movs	r3, #0
341a1ed0:	77fb      	strb	r3, [r7, #31]
      }

      if (table_config[index].PhyLink < PHY_LINK_4S4S4S)
341a1ed2:	7fbb      	ldrb	r3, [r7, #30]
341a1ed4:	005b      	lsls	r3, r3, #1
341a1ed6:	3320      	adds	r3, #32
341a1ed8:	443b      	add	r3, r7
341a1eda:	f813 3c14 	ldrb.w	r3, [r3, #-20]
341a1ede:	2b03      	cmp	r3, #3
341a1ee0:	d909      	bls.n	341a1ef6 <SFDP_GetHeader+0x9a>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
341a1ee2:	7f7b      	ldrb	r3, [r7, #29]
341a1ee4:	3301      	adds	r3, #1
341a1ee6:	777b      	strb	r3, [r7, #29]
341a1ee8:	7f7b      	ldrb	r3, [r7, #29]
341a1eea:	2b01      	cmp	r3, #1
341a1eec:	d804      	bhi.n	341a1ef8 <SFDP_GetHeader+0x9c>
341a1eee:	7ffb      	ldrb	r3, [r7, #31]
341a1ef0:	2b04      	cmp	r3, #4
341a1ef2:	d0e1      	beq.n	341a1eb8 <SFDP_GetHeader+0x5c>
341a1ef4:	e000      	b.n	341a1ef8 <SFDP_GetHeader+0x9c>
      {
        /* Config 1 is invalid so exit the loop */
        break;
341a1ef6:	bf00      	nop
           ; index++)
341a1ef8:	7fbb      	ldrb	r3, [r7, #30]
341a1efa:	3301      	adds	r3, #1
341a1efc:	77bb      	strb	r3, [r7, #30]
       (index < (sizeof(table_config)/sizeof(TableConfig_Typedef))) &&
341a1efe:	7fbb      	ldrb	r3, [r7, #30]
341a1f00:	2b07      	cmp	r3, #7
341a1f02:	d802      	bhi.n	341a1f0a <SFDP_GetHeader+0xae>
341a1f04:	7ffb      	ldrb	r3, [r7, #31]
341a1f06:	2b04      	cmp	r3, #4
341a1f08:	d0b8      	beq.n	341a1e7c <SFDP_GetHeader+0x20>
      }
    }
  }
  return retr;
341a1f0a:	7ffb      	ldrb	r3, [r7, #31]
}
341a1f0c:	4618      	mov	r0, r3
341a1f0e:	3724      	adds	r7, #36	@ 0x24
341a1f10:	46bd      	mov	sp, r7
341a1f12:	bd90      	pop	{r4, r7, pc}
341a1f14:	341a66e0 	.word	0x341a66e0

341a1f18 <SFDP_CollectData>:

SFDP_StatusTypeDef SFDP_CollectData(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a1f18:	b580      	push	{r7, lr}
341a1f1a:	b088      	sub	sp, #32
341a1f1c:	af00      	add	r7, sp, #0
341a1f1e:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a1f20:	2300      	movs	r3, #0
341a1f22:	77fb      	strb	r3, [r7, #31]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
341a1f24:	2308      	movs	r3, #8
341a1f26:	61bb      	str	r3, [r7, #24]
  SFDP_DEBUG_STR(__func__);

  /* reset the table mask */
  Object->sfdp_private.Sfdp_table_mask = 0;
341a1f28:	687b      	ldr	r3, [r7, #4]
341a1f2a:	2200      	movs	r2, #0
341a1f2c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

  /* reset the param info */
  (void)memset(sfdp_param_info, 0x0, sizeof(sfdp_param_info));
341a1f30:	2278      	movs	r2, #120	@ 0x78
341a1f32:	2100      	movs	r1, #0
341a1f34:	485f      	ldr	r0, [pc, #380]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1f36:	f001 ff35 	bl	341a3da4 <memset>

  /* get the table param info */
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a1f3a:	2300      	movs	r3, #0
341a1f3c:	75fb      	strb	r3, [r7, #23]
341a1f3e:	e027      	b.n	341a1f90 <SFDP_CollectData+0x78>
  {
    CHECK_FUNCTION_CALL(sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[index]))
341a1f40:	7dfa      	ldrb	r2, [r7, #23]
341a1f42:	4613      	mov	r3, r2
341a1f44:	005b      	lsls	r3, r3, #1
341a1f46:	4413      	add	r3, r2
341a1f48:	009b      	lsls	r3, r3, #2
341a1f4a:	4a5a      	ldr	r2, [pc, #360]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1f4c:	4413      	add	r3, r2
341a1f4e:	461a      	mov	r2, r3
341a1f50:	69b9      	ldr	r1, [r7, #24]
341a1f52:	6878      	ldr	r0, [r7, #4]
341a1f54:	f000 ffe4 	bl	341a2f20 <sfdp_get_paraminfo>
341a1f58:	4603      	mov	r3, r0
341a1f5a:	77fb      	strb	r3, [r7, #31]
341a1f5c:	7ffb      	ldrb	r3, [r7, #31]
341a1f5e:	2b00      	cmp	r3, #0
341a1f60:	f040 80a2 	bne.w	341a20a8 <SFDP_CollectData+0x190>
    Object->sfdp_private.Sfdp_table_mask |= (uint32_t)sfdp_param_info[index].type;
341a1f64:	687b      	ldr	r3, [r7, #4]
341a1f66:	f8d3 1094 	ldr.w	r1, [r3, #148]	@ 0x94
341a1f6a:	7dfa      	ldrb	r2, [r7, #23]
341a1f6c:	4851      	ldr	r0, [pc, #324]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1f6e:	4613      	mov	r3, r2
341a1f70:	005b      	lsls	r3, r3, #1
341a1f72:	4413      	add	r3, r2
341a1f74:	009b      	lsls	r3, r3, #2
341a1f76:	4403      	add	r3, r0
341a1f78:	681b      	ldr	r3, [r3, #0]
341a1f7a:	ea41 0203 	orr.w	r2, r1, r3
341a1f7e:	687b      	ldr	r3, [r7, #4]
341a1f80:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    sfdp_address+= SFDP_PARAM_HEADER_SIZE;
341a1f84:	69bb      	ldr	r3, [r7, #24]
341a1f86:	3308      	adds	r3, #8
341a1f88:	61bb      	str	r3, [r7, #24]
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a1f8a:	7dfb      	ldrb	r3, [r7, #23]
341a1f8c:	3301      	adds	r3, #1
341a1f8e:	75fb      	strb	r3, [r7, #23]
341a1f90:	7dfa      	ldrb	r2, [r7, #23]
341a1f92:	687b      	ldr	r3, [r7, #4]
341a1f94:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
341a1f98:	3301      	adds	r3, #1
341a1f9a:	429a      	cmp	r2, r3
341a1f9c:	d3d0      	bcc.n	341a1f40 <SFDP_CollectData+0x28>
  }

  /* Read each table param to extract the information to build the driver */
  for (uint8_t index = 0u;  sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
341a1f9e:	2300      	movs	r3, #0
341a1fa0:	75bb      	strb	r3, [r7, #22]
341a1fa2:	e075      	b.n	341a2090 <SFDP_CollectData+0x178>
  {
    uint8_t *ptr = NULL;
341a1fa4:	2300      	movs	r3, #0
341a1fa6:	613b      	str	r3, [r7, #16]
    uint32_t size = sfdp_param_info[index].size;
341a1fa8:	7dba      	ldrb	r2, [r7, #22]
341a1faa:	4942      	ldr	r1, [pc, #264]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1fac:	4613      	mov	r3, r2
341a1fae:	005b      	lsls	r3, r3, #1
341a1fb0:	4413      	add	r3, r2
341a1fb2:	009b      	lsls	r3, r3, #2
341a1fb4:	440b      	add	r3, r1
341a1fb6:	3308      	adds	r3, #8
341a1fb8:	781b      	ldrb	r3, [r3, #0]
341a1fba:	60fb      	str	r3, [r7, #12]
    switch(sfdp_param_info[index].type)
341a1fbc:	7dba      	ldrb	r2, [r7, #22]
341a1fbe:	493d      	ldr	r1, [pc, #244]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1fc0:	4613      	mov	r3, r2
341a1fc2:	005b      	lsls	r3, r3, #1
341a1fc4:	4413      	add	r3, r2
341a1fc6:	009b      	lsls	r3, r3, #2
341a1fc8:	440b      	add	r3, r1
341a1fca:	681b      	ldr	r3, [r3, #0]
341a1fcc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
341a1fd0:	d029      	beq.n	341a2026 <SFDP_CollectData+0x10e>
341a1fd2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
341a1fd6:	d829      	bhi.n	341a202c <SFDP_CollectData+0x114>
341a1fd8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a1fdc:	d01d      	beq.n	341a201a <SFDP_CollectData+0x102>
341a1fde:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a1fe2:	d823      	bhi.n	341a202c <SFDP_CollectData+0x114>
341a1fe4:	2b80      	cmp	r3, #128	@ 0x80
341a1fe6:	d01b      	beq.n	341a2020 <SFDP_CollectData+0x108>
341a1fe8:	2b80      	cmp	r3, #128	@ 0x80
341a1fea:	d81f      	bhi.n	341a202c <SFDP_CollectData+0x114>
341a1fec:	2b08      	cmp	r3, #8
341a1fee:	d002      	beq.n	341a1ff6 <SFDP_CollectData+0xde>
341a1ff0:	2b40      	cmp	r3, #64	@ 0x40
341a1ff2:	d00f      	beq.n	341a2014 <SFDP_CollectData+0xfc>
    case SFDP_PARAMID_OCTAL_DDR:
      ptr = JEDEC_OctalDdr.data_BYTE;
      break;
    default :
      SFDP_DEBUG_STR("the table is not yet handled by the SW");
      break;
341a1ff4:	e01a      	b.n	341a202c <SFDP_CollectData+0x114>
      JEDEC_Basic.size = sfdp_param_info[index].size;
341a1ff6:	7dba      	ldrb	r2, [r7, #22]
341a1ff8:	492e      	ldr	r1, [pc, #184]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a1ffa:	4613      	mov	r3, r2
341a1ffc:	005b      	lsls	r3, r3, #1
341a1ffe:	4413      	add	r3, r2
341a2000:	009b      	lsls	r3, r3, #2
341a2002:	440b      	add	r3, r1
341a2004:	3308      	adds	r3, #8
341a2006:	781b      	ldrb	r3, [r3, #0]
341a2008:	461a      	mov	r2, r3
341a200a:	4b2b      	ldr	r3, [pc, #172]	@ (341a20b8 <SFDP_CollectData+0x1a0>)
341a200c:	601a      	str	r2, [r3, #0]
      ptr = JEDEC_Basic.Params.data_BYTE;
341a200e:	4b2b      	ldr	r3, [pc, #172]	@ (341a20bc <SFDP_CollectData+0x1a4>)
341a2010:	613b      	str	r3, [r7, #16]
      break;
341a2012:	e00c      	b.n	341a202e <SFDP_CollectData+0x116>
      ptr = JEDEC_Address4Bytes.data_BYTE;
341a2014:	4b2a      	ldr	r3, [pc, #168]	@ (341a20c0 <SFDP_CollectData+0x1a8>)
341a2016:	613b      	str	r3, [r7, #16]
      break;
341a2018:	e009      	b.n	341a202e <SFDP_CollectData+0x116>
      ptr = JEDEC_SCCR_Map.data_b;
341a201a:	4b2a      	ldr	r3, [pc, #168]	@ (341a20c4 <SFDP_CollectData+0x1ac>)
341a201c:	613b      	str	r3, [r7, #16]
      break;
341a201e:	e006      	b.n	341a202e <SFDP_CollectData+0x116>
      ptr = JEDEC_XSPI10.data_BYTE;
341a2020:	4b29      	ldr	r3, [pc, #164]	@ (341a20c8 <SFDP_CollectData+0x1b0>)
341a2022:	613b      	str	r3, [r7, #16]
      break;
341a2024:	e003      	b.n	341a202e <SFDP_CollectData+0x116>
      ptr = JEDEC_OctalDdr.data_BYTE;
341a2026:	4b29      	ldr	r3, [pc, #164]	@ (341a20cc <SFDP_CollectData+0x1b4>)
341a2028:	613b      	str	r3, [r7, #16]
      break;
341a202a:	e000      	b.n	341a202e <SFDP_CollectData+0x116>
      break;
341a202c:	bf00      	nop
    }
    if (ptr != NULL)
341a202e:	693b      	ldr	r3, [r7, #16]
341a2030:	2b00      	cmp	r3, #0
341a2032:	d016      	beq.n	341a2062 <SFDP_CollectData+0x14a>
    {
      if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a2034:	687b      	ldr	r3, [r7, #4]
341a2036:	f103 0008 	add.w	r0, r3, #8
341a203a:	7dba      	ldrb	r2, [r7, #22]
341a203c:	491d      	ldr	r1, [pc, #116]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a203e:	4613      	mov	r3, r2
341a2040:	005b      	lsls	r3, r3, #1
341a2042:	4413      	add	r3, r2
341a2044:	009b      	lsls	r3, r3, #2
341a2046:	440b      	add	r3, r1
341a2048:	3304      	adds	r3, #4
341a204a:	6819      	ldr	r1, [r3, #0]
341a204c:	68fb      	ldr	r3, [r7, #12]
341a204e:	009b      	lsls	r3, r3, #2
341a2050:	693a      	ldr	r2, [r7, #16]
341a2052:	f7ff fb0f 	bl	341a1674 <SAL_XSPI_GetSFDP>
341a2056:	4603      	mov	r3, r0
341a2058:	2b00      	cmp	r3, #0
341a205a:	d002      	beq.n	341a2062 <SFDP_CollectData+0x14a>
                                     sfdp_param_info[index].address,
                                     ptr, size * 4u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
341a205c:	230c      	movs	r3, #12
341a205e:	77fb      	strb	r3, [r7, #31]
        goto error;
341a2060:	e022      	b.n	341a20a8 <SFDP_CollectData+0x190>
      }
    }

    if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[index].type)
341a2062:	7dba      	ldrb	r2, [r7, #22]
341a2064:	4913      	ldr	r1, [pc, #76]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a2066:	4613      	mov	r3, r2
341a2068:	005b      	lsls	r3, r3, #1
341a206a:	4413      	add	r3, r2
341a206c:	009b      	lsls	r3, r3, #2
341a206e:	440b      	add	r3, r1
341a2070:	681b      	ldr	r3, [r3, #0]
341a2072:	2b08      	cmp	r3, #8
341a2074:	d109      	bne.n	341a208a <SFDP_CollectData+0x172>
    {
      /* save data about the reset procedure */
      Object->sfdp_private.Reset_info = JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support;
341a2076:	4b10      	ldr	r3, [pc, #64]	@ (341a20b8 <SFDP_CollectData+0x1a0>)
341a2078:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a207c:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a2080:	b2db      	uxtb	r3, r3
341a2082:	461a      	mov	r2, r3
341a2084:	687b      	ldr	r3, [r7, #4]
341a2086:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
  for (uint8_t index = 0u;  sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
341a208a:	7dbb      	ldrb	r3, [r7, #22]
341a208c:	3301      	adds	r3, #1
341a208e:	75bb      	strb	r3, [r7, #22]
341a2090:	7dba      	ldrb	r2, [r7, #22]
341a2092:	4908      	ldr	r1, [pc, #32]	@ (341a20b4 <SFDP_CollectData+0x19c>)
341a2094:	4613      	mov	r3, r2
341a2096:	005b      	lsls	r3, r3, #1
341a2098:	4413      	add	r3, r2
341a209a:	009b      	lsls	r3, r3, #2
341a209c:	440b      	add	r3, r1
341a209e:	681b      	ldr	r3, [r3, #0]
341a20a0:	2b00      	cmp	r3, #0
341a20a2:	f47f af7f 	bne.w	341a1fa4 <SFDP_CollectData+0x8c>
    }
  }

error:
341a20a6:	bf00      	nop
  return retr;
341a20a8:	7ffb      	ldrb	r3, [r7, #31]
}
341a20aa:	4618      	mov	r0, r3
341a20ac:	3720      	adds	r7, #32
341a20ae:	46bd      	mov	sp, r7
341a20b0:	bd80      	pop	{r7, pc}
341a20b2:	bf00      	nop
341a20b4:	341c1b84 	.word	0x341c1b84
341a20b8:	341c1bfc 	.word	0x341c1bfc
341a20bc:	341c1c00 	.word	0x341c1c00
341a20c0:	341c1c5c 	.word	0x341c1c5c
341a20c4:	341c1c7c 	.word	0x341c1c7c
341a20c8:	341c1c64 	.word	0x341c1c64
341a20cc:	341c1cec 	.word	0x341c1cec

341a20d0 <SFDP_MemoryReset>:

SFDP_StatusTypeDef SFDP_MemoryReset(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a20d0:	b580      	push	{r7, lr}
341a20d2:	b086      	sub	sp, #24
341a20d4:	af00      	add	r7, sp, #0
341a20d6:	6078      	str	r0, [r7, #4]
  RESET_METHOD reset_method;
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
341a20d8:	2307      	movs	r3, #7
341a20da:	75bb      	strb	r3, [r7, #22]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
341a20dc:	2308      	movs	r3, #8
341a20de:	613b      	str	r3, [r7, #16]
  uint8_t find = 0u;
341a20e0:	2300      	movs	r3, #0
341a20e2:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR(__func__);

  /* get the table param info */
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a20e4:	2300      	movs	r3, #0
341a20e6:	73bb      	strb	r3, [r7, #14]
341a20e8:	e02e      	b.n	341a2148 <SFDP_MemoryReset+0x78>
  {
    retr = sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[0]);
341a20ea:	4a64      	ldr	r2, [pc, #400]	@ (341a227c <SFDP_MemoryReset+0x1ac>)
341a20ec:	6939      	ldr	r1, [r7, #16]
341a20ee:	6878      	ldr	r0, [r7, #4]
341a20f0:	f000 ff16 	bl	341a2f20 <sfdp_get_paraminfo>
341a20f4:	4603      	mov	r3, r0
341a20f6:	75bb      	strb	r3, [r7, #22]
    if (EXTMEM_SFDP_OK == retr)
341a20f8:	7dbb      	ldrb	r3, [r7, #22]
341a20fa:	2b00      	cmp	r3, #0
341a20fc:	d118      	bne.n	341a2130 <SFDP_MemoryReset+0x60>
    {
      /* check if the table is basic table */
      if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[0].type)
341a20fe:	4b5f      	ldr	r3, [pc, #380]	@ (341a227c <SFDP_MemoryReset+0x1ac>)
341a2100:	681b      	ldr	r3, [r3, #0]
341a2102:	2b08      	cmp	r3, #8
341a2104:	d114      	bne.n	341a2130 <SFDP_MemoryReset+0x60>
      {
        /* read the JEDEC basic param */
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a2106:	687b      	ldr	r3, [r7, #4]
341a2108:	f103 0008 	add.w	r0, r3, #8
341a210c:	4b5b      	ldr	r3, [pc, #364]	@ (341a227c <SFDP_MemoryReset+0x1ac>)
341a210e:	6859      	ldr	r1, [r3, #4]
                                       sfdp_param_info[0].address,
                                       JEDEC_Basic.Params.data_BYTE,
                                       ((uint32_t)sfdp_param_info[0].size) * 4u))
341a2110:	4b5a      	ldr	r3, [pc, #360]	@ (341a227c <SFDP_MemoryReset+0x1ac>)
341a2112:	7a1b      	ldrb	r3, [r3, #8]
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a2114:	009b      	lsls	r3, r3, #2
341a2116:	4a5a      	ldr	r2, [pc, #360]	@ (341a2280 <SFDP_MemoryReset+0x1b0>)
341a2118:	f7ff faac 	bl	341a1674 <SAL_XSPI_GetSFDP>
341a211c:	4603      	mov	r3, r0
341a211e:	2b00      	cmp	r3, #0
341a2120:	d002      	beq.n	341a2128 <SFDP_MemoryReset+0x58>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2122:	230c      	movs	r3, #12
341a2124:	75bb      	strb	r3, [r7, #22]
341a2126:	e003      	b.n	341a2130 <SFDP_MemoryReset+0x60>
        }
        else
        {
          retr = EXTMEM_SFDP_OK;
341a2128:	2300      	movs	r3, #0
341a212a:	75bb      	strb	r3, [r7, #22]
          find = 1u;
341a212c:	2301      	movs	r3, #1
341a212e:	73fb      	strb	r3, [r7, #15]
        }
      }
    }

    if ((EXTMEM_SFDP_OK != retr) || (1u == find))
341a2130:	7dbb      	ldrb	r3, [r7, #22]
341a2132:	2b00      	cmp	r3, #0
341a2134:	d10f      	bne.n	341a2156 <SFDP_MemoryReset+0x86>
341a2136:	7bfb      	ldrb	r3, [r7, #15]
341a2138:	2b01      	cmp	r3, #1
341a213a:	d00c      	beq.n	341a2156 <SFDP_MemoryReset+0x86>
    {
        /* stop the read, if there is an error or if the table has been found */
        break;
    }
    /* look for the next table */
    sfdp_address+= SFDP_PARAM_HEADER_SIZE;
341a213c:	693b      	ldr	r3, [r7, #16]
341a213e:	3308      	adds	r3, #8
341a2140:	613b      	str	r3, [r7, #16]
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a2142:	7bbb      	ldrb	r3, [r7, #14]
341a2144:	3301      	adds	r3, #1
341a2146:	73bb      	strb	r3, [r7, #14]
341a2148:	7bba      	ldrb	r2, [r7, #14]
341a214a:	687b      	ldr	r3, [r7, #4]
341a214c:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
341a2150:	3301      	adds	r3, #1
341a2152:	429a      	cmp	r2, r3
341a2154:	d3c9      	bcc.n	341a20ea <SFDP_MemoryReset+0x1a>
  }

  /* if an error has been returned or if the table has not been found */
  if ((EXTMEM_SFDP_OK != retr) || (0u == find))
341a2156:	7dbb      	ldrb	r3, [r7, #22]
341a2158:	2b00      	cmp	r3, #0
341a215a:	d102      	bne.n	341a2162 <SFDP_MemoryReset+0x92>
341a215c:	7bfb      	ldrb	r3, [r7, #15]
341a215e:	2b00      	cmp	r3, #0
341a2160:	d102      	bne.n	341a2168 <SFDP_MemoryReset+0x98>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2162:	230c      	movs	r3, #12
341a2164:	75bb      	strb	r3, [r7, #22]
    goto error;
341a2166:	e083      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
  }

  /* determine how to proceed memory reset */
  if( 0x0u == JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support)
341a2168:	4b46      	ldr	r3, [pc, #280]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a216a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a216e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341a2172:	b2db      	uxtb	r3, r3
341a2174:	2b00      	cmp	r3, #0
341a2176:	d102      	bne.n	341a217e <SFDP_MemoryReset+0xae>
  {
    /* 00_0000b: no software reset instruction is supported */
    reset_method = RESET_NONE;
341a2178:	2300      	movs	r3, #0
341a217a:	75fb      	strb	r3, [r7, #23]
341a217c:	e053      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x1u == (0x1u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a217e:	4b41      	ldr	r3, [pc, #260]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a2180:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a2184:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a2188:	b2db      	uxtb	r3, r3
341a218a:	f003 0301 	and.w	r3, r3, #1
341a218e:	b2db      	uxtb	r3, r3
341a2190:	2b00      	cmp	r3, #0
341a2192:	d002      	beq.n	341a219a <SFDP_MemoryReset+0xca>
  {
    /* xx_xxx1b: drive Fh on all 4 data wires for 8 clocks */
    reset_method = RESET_Fh_4DATA_8CLOCK;
341a2194:	2301      	movs	r3, #1
341a2196:	75fb      	strb	r3, [r7, #23]
341a2198:	e045      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x2u == (0x2u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a219a:	4b3a      	ldr	r3, [pc, #232]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a219c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a21a0:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a21a4:	b2db      	uxtb	r3, r3
341a21a6:	f003 0302 	and.w	r3, r3, #2
341a21aa:	b2db      	uxtb	r3, r3
341a21ac:	2b00      	cmp	r3, #0
341a21ae:	d002      	beq.n	341a21b6 <SFDP_MemoryReset+0xe6>
  {
    /* xx_xx1xb: drive Fh on all 4 data wires for 10 clocks if device is operating in 4-byte address mode */
    reset_method = RESET_Fh_4DATA_10CLOCK;
341a21b0:	2302      	movs	r3, #2
341a21b2:	75fb      	strb	r3, [r7, #23]
341a21b4:	e037      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x4u == (0x4u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a21b6:	4b33      	ldr	r3, [pc, #204]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a21b8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a21bc:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a21c0:	b2db      	uxtb	r3, r3
341a21c2:	f003 0304 	and.w	r3, r3, #4
341a21c6:	b2db      	uxtb	r3, r3
341a21c8:	2b00      	cmp	r3, #0
341a21ca:	d002      	beq.n	341a21d2 <SFDP_MemoryReset+0x102>
  {
    /* xx_x1xxb: drive Fh on all 4 data wires for 16 clocks */
    reset_method = RESET_Fh_4DATA_16CLOCK;
341a21cc:	2303      	movs	r3, #3
341a21ce:	75fb      	strb	r3, [r7, #23]
341a21d0:	e029      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x8u == (0x8u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a21d2:	4b2c      	ldr	r3, [pc, #176]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a21d4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a21d8:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a21dc:	b2db      	uxtb	r3, r3
341a21de:	f003 0308 	and.w	r3, r3, #8
341a21e2:	b2db      	uxtb	r3, r3
341a21e4:	2b00      	cmp	r3, #0
341a21e6:	d002      	beq.n	341a21ee <SFDP_MemoryReset+0x11e>
  {
    /* xx_1xxxb: issue instruction F0h */
    reset_method = RESET_INSTRUCTION_F0;
341a21e8:	2304      	movs	r3, #4
341a21ea:	75fb      	strb	r3, [r7, #23]
341a21ec:	e01b      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x10u == (0x10u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a21ee:	4b25      	ldr	r3, [pc, #148]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a21f0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a21f4:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a21f8:	b2db      	uxtb	r3, r3
341a21fa:	f003 0310 	and.w	r3, r3, #16
341a21fe:	b2db      	uxtb	r3, r3
341a2200:	2b00      	cmp	r3, #0
341a2202:	d002      	beq.n	341a220a <SFDP_MemoryReset+0x13a>
  {
    /* x1_xxxxb: issue reset enable instruction 66h, then issue reset instruction 99h. The reset enable,
    reset sequence may be issued on 1, 2, or 4 wires depending on the device operating mode.
    */
    reset_method = RESET_INSTRUCTION_66_99;
341a2204:	2305      	movs	r3, #5
341a2206:	75fb      	strb	r3, [r7, #23]
341a2208:	e00d      	b.n	341a2226 <SFDP_MemoryReset+0x156>
  }
  else if (0x20u == (0x20u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a220a:	4b1e      	ldr	r3, [pc, #120]	@ (341a2284 <SFDP_MemoryReset+0x1b4>)
341a220c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a2210:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a2214:	b2db      	uxtb	r3, r3
341a2216:	2b1f      	cmp	r3, #31
341a2218:	d902      	bls.n	341a2220 <SFDP_MemoryReset+0x150>
    xx_xx1x_xxxxb: Hardware reset
    xx_x1xx_xxxxb: Software reset (see bits 13:8 in this DWORD)
    xx_1xxx_xxxxb: Power cycle
    x1_xxxx_xxxxb: Reserved
    */
    retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a221a:	230f      	movs	r3, #15
341a221c:	75bb      	strb	r3, [r7, #22]
    goto error;
341a221e:	e027      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
  }
  else
  {
    /* no coherence, should be managed as error */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2220:	230c      	movs	r3, #12
341a2222:	75bb      	strb	r3, [r7, #22]
    goto error;
341a2224:	e024      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
  }

  switch(reset_method)
341a2226:	7dfb      	ldrb	r3, [r7, #23]
341a2228:	2b05      	cmp	r3, #5
341a222a:	d009      	beq.n	341a2240 <SFDP_MemoryReset+0x170>
341a222c:	2b05      	cmp	r3, #5
341a222e:	dc1b      	bgt.n	341a2268 <SFDP_MemoryReset+0x198>
341a2230:	2b00      	cmp	r3, #0
341a2232:	d01c      	beq.n	341a226e <SFDP_MemoryReset+0x19e>
341a2234:	2b00      	cmp	r3, #0
341a2236:	db17      	blt.n	341a2268 <SFDP_MemoryReset+0x198>
341a2238:	3b01      	subs	r3, #1
341a223a:	2b03      	cmp	r3, #3
341a223c:	d814      	bhi.n	341a2268 <SFDP_MemoryReset+0x198>
341a223e:	e010      	b.n	341a2262 <SFDP_MemoryReset+0x192>
  case RESET_NONE:
    break;
  case RESET_INSTRUCTION_66_99:
    /* perform the reset in 1, 2 and 4 lines */
    SFDP_DEBUG_STR("::reset 0x66 0x99");
    (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x66, NULL, 0);
341a2240:	687b      	ldr	r3, [r7, #4]
341a2242:	f103 0008 	add.w	r0, r3, #8
341a2246:	2300      	movs	r3, #0
341a2248:	2200      	movs	r2, #0
341a224a:	2166      	movs	r1, #102	@ 0x66
341a224c:	f7ff fb9d 	bl	341a198a <SAL_XSPI_CommandSendData>
    (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x99, NULL, 0);
341a2250:	687b      	ldr	r3, [r7, #4]
341a2252:	f103 0008 	add.w	r0, r3, #8
341a2256:	2300      	movs	r3, #0
341a2258:	2200      	movs	r2, #0
341a225a:	2199      	movs	r1, #153	@ 0x99
341a225c:	f7ff fb95 	bl	341a198a <SAL_XSPI_CommandSendData>
    break;
341a2260:	e006      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
  case RESET_INSTRUCTION_F0:
  case RESET_Fh_4DATA_8CLOCK:
  case RESET_Fh_4DATA_10CLOCK:
  case RESET_Fh_4DATA_16CLOCK:
    retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a2262:	230f      	movs	r3, #15
341a2264:	75bb      	strb	r3, [r7, #22]
    break;
341a2266:	e003      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
  /* case RESET_ERROR:*/
  default :
    retr = EXTMEM_SFDP_ERROR_PARAM;
341a2268:	2301      	movs	r3, #1
341a226a:	75bb      	strb	r3, [r7, #22]
    break;
341a226c:	e000      	b.n	341a2270 <SFDP_MemoryReset+0x1a0>
    break;
341a226e:	bf00      	nop
  }
error :
  return retr;
341a2270:	7dbb      	ldrb	r3, [r7, #22]
}
341a2272:	4618      	mov	r0, r3
341a2274:	3718      	adds	r7, #24
341a2276:	46bd      	mov	sp, r7
341a2278:	bd80      	pop	{r7, pc}
341a227a:	bf00      	nop
341a227c:	341c1b84 	.word	0x341c1b84
341a2280:	341c1c00 	.word	0x341c1c00
341a2284:	341c1bfc 	.word	0x341c1bfc

341a2288 <SFDP_BuildGenericDriver>:

SFDP_StatusTypeDef SFDP_BuildGenericDriver(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint8_t *FreqUpdated)
{
341a2288:	b5f0      	push	{r4, r5, r6, r7, lr}
341a228a:	b08f      	sub	sp, #60	@ 0x3c
341a228c:	af04      	add	r7, sp, #16
341a228e:	6078      	str	r0, [r7, #4]
341a2290:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a2292:	2300      	movs	r3, #0
341a2294:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  static const uint16_t block_erase_unit[] = { 16u, 256u, 4000u, 64000u};
  static const uint32_t chip_erase_unit[]  = { 16u, 256u, 4000u, 64000u};
  SFDP_DEBUG_STR(__func__);
  uint8_t flag4byteAddress = 0u;
341a2298:	2300      	movs	r3, #0
341a229a:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint32_t dummyCycles, dummyCyclesValue;
  uint8_t FlashSize;

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL) != (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
341a229e:	687b      	ldr	r3, [r7, #4]
341a22a0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a22a4:	f003 0308 	and.w	r3, r3, #8
341a22a8:	2b00      	cmp	r3, #0
341a22aa:	d104      	bne.n	341a22b6 <SFDP_BuildGenericDriver+0x2e>
  {
    /* This table is mandatory to build the driver data */
    retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
341a22ac:	2307      	movs	r3, #7
341a22ae:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a22b2:	f000 bdbd 	b.w	341a2e30 <SFDP_BuildGenericDriver+0xba8>
  /* ---------------------------------------------------
   *  Flash sizing
   * ---------------------------------------------------
   */
  /* Calculation of the flash density in puissance of 2 */
  if ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x80000000u) == 0x0u)
341a22b6:	4bba      	ldr	r3, [pc, #744]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a22b8:	689b      	ldr	r3, [r3, #8]
341a22ba:	2b00      	cmp	r3, #0
341a22bc:	db13      	blt.n	341a22e6 <SFDP_BuildGenericDriver+0x5e>
  {
#if( __CORTEX_M == 0)
#error "the assembly instruction is not available"
#else
    Object->sfdp_private.FlashSize = 31u - (uint8_t)__CLZ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize + 1u));
341a22be:	4bb8      	ldr	r3, [pc, #736]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a22c0:	689b      	ldr	r3, [r3, #8]
341a22c2:	3301      	adds	r3, #1
341a22c4:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
341a22c6:	69bb      	ldr	r3, [r7, #24]
341a22c8:	2b00      	cmp	r3, #0
341a22ca:	d101      	bne.n	341a22d0 <SFDP_BuildGenericDriver+0x48>
    return 32U;
341a22cc:	2320      	movs	r3, #32
341a22ce:	e003      	b.n	341a22d8 <SFDP_BuildGenericDriver+0x50>
  return __builtin_clz(value);
341a22d0:	69bb      	ldr	r3, [r7, #24]
341a22d2:	fab3 f383 	clz	r3, r3
341a22d6:	b2db      	uxtb	r3, r3
341a22d8:	f1c3 031f 	rsb	r3, r3, #31
341a22dc:	b2da      	uxtb	r2, r3
341a22de:	687b      	ldr	r3, [r7, #4]
341a22e0:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
341a22e4:	e005      	b.n	341a22f2 <SFDP_BuildGenericDriver+0x6a>
#endif /* __CORTEX_M */
  }
  else
  {
    Object->sfdp_private.FlashSize = (uint8_t)(JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x7FFFFFFFu);
341a22e6:	4bae      	ldr	r3, [pc, #696]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a22e8:	689b      	ldr	r3, [r3, #8]
341a22ea:	b2da      	uxtb	r2, r3
341a22ec:	687b      	ldr	r3, [r7, #4]
341a22ee:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
  }

  /* Conversion bit to byte */
  Object->sfdp_private.FlashSize = Object->sfdp_private.FlashSize - 3u; /* divide by eight the value */
341a22f2:	687b      	ldr	r3, [r7, #4]
341a22f4:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
341a22f8:	3b03      	subs	r3, #3
341a22fa:	b2da      	uxtb	r2, r3
341a22fc:	687b      	ldr	r3, [r7, #4]
341a22fe:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e

  SFDP_DEBUG_INT("-> flash size: 2^", Object->sfdp_private.FlashSize);
  FlashSize = Object->sfdp_private.FlashSize - 1u;
341a2302:	687b      	ldr	r3, [r7, #4]
341a2304:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
341a2308:	3b01      	subs	r3, #1
341a230a:	b2db      	uxtb	r3, r3
341a230c:	74fb      	strb	r3, [r7, #19]
  (void) SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_FLASHSIZE, &FlashSize);
341a230e:	687b      	ldr	r3, [r7, #4]
341a2310:	3308      	adds	r3, #8
341a2312:	f107 0213 	add.w	r2, r7, #19
341a2316:	2104      	movs	r1, #4
341a2318:	4618      	mov	r0, r3
341a231a:	f7ff f859 	bl	341a13d0 <SAL_XSPI_MemoryConfig>

  /* get the page size info */
  Object->sfdp_private.PageSize = ((uint32_t)1u <<  JEDEC_Basic.Params.Param_DWORD.D11.PageSize);
341a231e:	4ba0      	ldr	r3, [pc, #640]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2320:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
341a2324:	f3c3 1303 	ubfx	r3, r3, #4, #4
341a2328:	b2db      	uxtb	r3, r3
341a232a:	461a      	mov	r2, r3
341a232c:	2301      	movs	r3, #1
341a232e:	fa03 f202 	lsl.w	r2, r3, r2
341a2332:	687b      	ldr	r3, [r7, #4]
341a2334:	661a      	str	r2, [r3, #96]	@ 0x60

  /* ---------------------------------------------------
   *  Set default command
   * ---------------------------------------------------
   */
  Object->sfdp_private.DriverInfo.PageProgramInstruction = SFDP_DRIVER_PAGE_PROGRAM_COMMAND;
341a2336:	687b      	ldr	r3, [r7, #4]
341a2338:	2202      	movs	r2, #2
341a233a:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
  /* ---------------------------------------------------
   *  Erase management
   * ---------------------------------------------------
   */
  /* Manage erase data */
  Object->sfdp_private.DriverInfo.EraseType1Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Size;
341a233e:	4b98      	ldr	r3, [pc, #608]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2340:	f893 2020 	ldrb.w	r2, [r3, #32]
341a2344:	687b      	ldr	r3, [r7, #4]
341a2346:	f883 2077 	strb.w	r2, [r3, #119]	@ 0x77
  Object->sfdp_private.DriverInfo.EraseType1Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Instruction;
341a234a:	4b95      	ldr	r3, [pc, #596]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a234c:	f893 2021 	ldrb.w	r2, [r3, #33]	@ 0x21
341a2350:	687b      	ldr	r3, [r7, #4]
341a2352:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
  Object->sfdp_private.DriverInfo.EraseType2Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Size;
341a2356:	4b92      	ldr	r3, [pc, #584]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2358:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
341a235c:	687b      	ldr	r3, [r7, #4]
341a235e:	f883 2079 	strb.w	r2, [r3, #121]	@ 0x79
  Object->sfdp_private.DriverInfo.EraseType2Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Instruction;
341a2362:	4b8f      	ldr	r3, [pc, #572]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2364:	f893 2023 	ldrb.w	r2, [r3, #35]	@ 0x23
341a2368:	687b      	ldr	r3, [r7, #4]
341a236a:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
  Object->sfdp_private.DriverInfo.EraseType3Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Size;
341a236e:	4b8c      	ldr	r3, [pc, #560]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2370:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
341a2374:	687b      	ldr	r3, [r7, #4]
341a2376:	f883 207b 	strb.w	r2, [r3, #123]	@ 0x7b
  Object->sfdp_private.DriverInfo.EraseType3Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Instruction;
341a237a:	4b89      	ldr	r3, [pc, #548]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a237c:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
341a2380:	687b      	ldr	r3, [r7, #4]
341a2382:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
  Object->sfdp_private.DriverInfo.EraseType4Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Size;
341a2386:	4b86      	ldr	r3, [pc, #536]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2388:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
341a238c:	687b      	ldr	r3, [r7, #4]
341a238e:	f883 207d 	strb.w	r2, [r3, #125]	@ 0x7d
  Object->sfdp_private.DriverInfo.EraseType4Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Instruction;
341a2392:	4b83      	ldr	r3, [pc, #524]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2394:	f893 2027 	ldrb.w	r2, [r3, #39]	@ 0x27
341a2398:	687b      	ldr	r3, [r7, #4]
341a239a:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e

  if (Object->sfdp_private.DriverInfo.EraseType1Command != 0x0u)
341a239e:	687b      	ldr	r3, [r7, #4]
341a23a0:	f893 3078 	ldrb.w	r3, [r3, #120]	@ 0x78
341a23a4:	2b00      	cmp	r3, #0
341a23a6:	d01d      	beq.n	341a23e4 <SFDP_BuildGenericDriver+0x15c>
  {
    Object->sfdp_private.DriverInfo.EraseType1Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_units];
341a23a8:	4b7d      	ldr	r3, [pc, #500]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a23aa:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a23ae:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a23b2:	b2db      	uxtb	r3, r3
341a23b4:	461a      	mov	r2, r3
341a23b6:	4b7a      	ldr	r3, [pc, #488]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a23b8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341a23ba:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a23be:	b2db      	uxtb	r3, r3
341a23c0:	3301      	adds	r3, #1
341a23c2:	fb02 f303 	mul.w	r3, r2, r3
341a23c6:	4a76      	ldr	r2, [pc, #472]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a23c8:	f892 2029 	ldrb.w	r2, [r2, #41]	@ 0x29
341a23cc:	f3c2 0241 	ubfx	r2, r2, #1, #2
341a23d0:	b2d2      	uxtb	r2, r2
341a23d2:	4611      	mov	r1, r2
341a23d4:	4a73      	ldr	r2, [pc, #460]	@ (341a25a4 <SFDP_BuildGenericDriver+0x31c>)
341a23d6:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a23da:	fb03 f202 	mul.w	r2, r3, r2
341a23de:	687b      	ldr	r3, [r7, #4]
341a23e0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  }

  if (Object->sfdp_private.DriverInfo.EraseType2Command != 0x0u)
341a23e4:	687b      	ldr	r3, [r7, #4]
341a23e6:	f893 307a 	ldrb.w	r3, [r3, #122]	@ 0x7a
341a23ea:	2b00      	cmp	r3, #0
341a23ec:	d01e      	beq.n	341a242c <SFDP_BuildGenericDriver+0x1a4>
  {
    Object->sfdp_private.DriverInfo.EraseType2Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_units];
341a23ee:	4b6c      	ldr	r3, [pc, #432]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a23f0:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a23f4:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a23f8:	b2db      	uxtb	r3, r3
341a23fa:	461a      	mov	r2, r3
341a23fc:	4b68      	ldr	r3, [pc, #416]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a23fe:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
341a2402:	f3c3 03c4 	ubfx	r3, r3, #3, #5
341a2406:	b2db      	uxtb	r3, r3
341a2408:	3301      	adds	r3, #1
341a240a:	fb02 f303 	mul.w	r3, r2, r3
341a240e:	4a64      	ldr	r2, [pc, #400]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2410:	f892 202a 	ldrb.w	r2, [r2, #42]	@ 0x2a
341a2414:	f3c2 0201 	ubfx	r2, r2, #0, #2
341a2418:	b2d2      	uxtb	r2, r2
341a241a:	4611      	mov	r1, r2
341a241c:	4a61      	ldr	r2, [pc, #388]	@ (341a25a4 <SFDP_BuildGenericDriver+0x31c>)
341a241e:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a2422:	fb03 f202 	mul.w	r2, r3, r2
341a2426:	687b      	ldr	r3, [r7, #4]
341a2428:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  }

  if (Object->sfdp_private.DriverInfo.EraseType3Command != 0x0u)
341a242c:	687b      	ldr	r3, [r7, #4]
341a242e:	f893 307c 	ldrb.w	r3, [r3, #124]	@ 0x7c
341a2432:	2b00      	cmp	r3, #0
341a2434:	d01d      	beq.n	341a2472 <SFDP_BuildGenericDriver+0x1ea>
  {
    Object->sfdp_private.DriverInfo.EraseType3Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_units];
341a2436:	4b5a      	ldr	r3, [pc, #360]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2438:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a243c:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a2440:	b2db      	uxtb	r3, r3
341a2442:	461a      	mov	r2, r3
341a2444:	4b56      	ldr	r3, [pc, #344]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2446:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
341a244a:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a244e:	b2db      	uxtb	r3, r3
341a2450:	3301      	adds	r3, #1
341a2452:	fb02 f303 	mul.w	r3, r2, r3
341a2456:	4a52      	ldr	r2, [pc, #328]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2458:	8d52      	ldrh	r2, [r2, #42]	@ 0x2a
341a245a:	f3c2 12c1 	ubfx	r2, r2, #7, #2
341a245e:	b2d2      	uxtb	r2, r2
341a2460:	4611      	mov	r1, r2
341a2462:	4a50      	ldr	r2, [pc, #320]	@ (341a25a4 <SFDP_BuildGenericDriver+0x31c>)
341a2464:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a2468:	fb03 f202 	mul.w	r2, r3, r2
341a246c:	687b      	ldr	r3, [r7, #4]
341a246e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  }

  if (Object->sfdp_private.DriverInfo.EraseType4Command != 0x0u)
341a2472:	687b      	ldr	r3, [r7, #4]
341a2474:	f893 307e 	ldrb.w	r3, [r3, #126]	@ 0x7e
341a2478:	2b00      	cmp	r3, #0
341a247a:	d01e      	beq.n	341a24ba <SFDP_BuildGenericDriver+0x232>
  {
    Object->sfdp_private.DriverInfo.EraseType4Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_units];
341a247c:	4b48      	ldr	r3, [pc, #288]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a247e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a2482:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a2486:	b2db      	uxtb	r3, r3
341a2488:	461a      	mov	r2, r3
341a248a:	4b45      	ldr	r3, [pc, #276]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a248c:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
341a2490:	f3c3 0344 	ubfx	r3, r3, #1, #5
341a2494:	b2db      	uxtb	r3, r3
341a2496:	3301      	adds	r3, #1
341a2498:	fb02 f303 	mul.w	r3, r2, r3
341a249c:	4a40      	ldr	r2, [pc, #256]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a249e:	f892 202b 	ldrb.w	r2, [r2, #43]	@ 0x2b
341a24a2:	f3c2 1281 	ubfx	r2, r2, #6, #2
341a24a6:	b2d2      	uxtb	r2, r2
341a24a8:	4611      	mov	r1, r2
341a24aa:	4a3e      	ldr	r2, [pc, #248]	@ (341a25a4 <SFDP_BuildGenericDriver+0x31c>)
341a24ac:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a24b0:	fb03 f202 	mul.w	r2, r3, r2
341a24b4:	687b      	ldr	r3, [r7, #4]
341a24b6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  }

  Object->sfdp_private.DriverInfo.EraseChipTiming   = JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_count + 1u)* chip_erase_unit[JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_units];
341a24ba:	4b39      	ldr	r3, [pc, #228]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a24bc:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a24c0:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a24c4:	b2db      	uxtb	r3, r3
341a24c6:	461a      	mov	r2, r3
341a24c8:	4b35      	ldr	r3, [pc, #212]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a24ca:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
341a24ce:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a24d2:	b2db      	uxtb	r3, r3
341a24d4:	3301      	adds	r3, #1
341a24d6:	fb02 f303 	mul.w	r3, r2, r3
341a24da:	4a31      	ldr	r2, [pc, #196]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a24dc:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
341a24e0:	f3c2 1241 	ubfx	r2, r2, #5, #2
341a24e4:	b2d2      	uxtb	r2, r2
341a24e6:	4611      	mov	r1, r2
341a24e8:	4a2f      	ldr	r2, [pc, #188]	@ (341a25a8 <SFDP_BuildGenericDriver+0x320>)
341a24ea:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
341a24ee:	fb03 f202 	mul.w	r2, r3, r2
341a24f2:	687b      	ldr	r3, [r7, #4]
341a24f4:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
   *   WIP/WEL : write in progress/ write enable management
   * ------------------------------------------------------
   */
  /* This bit definition is maintained for legacy compatibility only. New system implementations
  should refer to 6.4.19 for a full definition of volatile and non-volatile behavior. */
  Object->sfdp_private.DriverInfo.ReadWELCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a24f8:	687b      	ldr	r3, [r7, #4]
341a24fa:	2205      	movs	r2, #5
341a24fc:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
  Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a2500:	687b      	ldr	r3, [r7, #4]
341a2502:	2205      	movs	r2, #5
341a2504:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  if (JEDEC_Basic.Params.Param_DWORD.D1.WriteEnableInstructionVolatileRegister == 0u)
341a2508:	4b25      	ldr	r3, [pc, #148]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a250a:	791b      	ldrb	r3, [r3, #4]
341a250c:	f003 0310 	and.w	r3, r3, #16
341a2510:	b2db      	uxtb	r3, r3
341a2512:	2b00      	cmp	r3, #0
341a2514:	d104      	bne.n	341a2520 <SFDP_BuildGenericDriver+0x298>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
341a2516:	687b      	ldr	r3, [r7, #4]
341a2518:	2250      	movs	r2, #80	@ 0x50
341a251a:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a251e:	e003      	b.n	341a2528 <SFDP_BuildGenericDriver+0x2a0>
  }
  else
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a2520:	687b      	ldr	r3, [r7, #4]
341a2522:	2206      	movs	r2, #6
341a2524:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
  /* Volatile or Non-Volatile Register and Write Enable Instruction for Status Register 1
     The instruction 01h is typically used to write status register 1 which contains Block Protection (BP) and other bits. Status register 1 is written by the first data byte following the instruction 01h. The protection bits must be written to zero to enable writes/erases to the device.
     This field describes how to modify the writable bits in status register 1 in either a volatile or non-volatile manner. Bits 1:0 in status register 1 are de-facto standard write enable and busy status and are excluded from the definitions below.
  */
  /* xxx_xxx1b: Non-Volatile Status Register 1, powers-up to last written value, use instruction 06h to enable write */
  if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x1u) != 0u)
341a2528:	4b1d      	ldr	r3, [pc, #116]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a252a:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a252e:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a2532:	b2db      	uxtb	r3, r3
341a2534:	f003 0301 	and.w	r3, r3, #1
341a2538:	2b00      	cmp	r3, #0
341a253a:	d004      	beq.n	341a2546 <SFDP_BuildGenericDriver+0x2be>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a253c:	687b      	ldr	r3, [r7, #4]
341a253e:	2206      	movs	r2, #6
341a2540:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a2544:	e046      	b.n	341a25d4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_xx1xb: Volatile Status Register 1, status register powers-up with bits set to "1"s, use instruction 06h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x02u) != 0u)
341a2546:	4b16      	ldr	r3, [pc, #88]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2548:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a254c:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a2550:	b2db      	uxtb	r3, r3
341a2552:	f003 0302 	and.w	r3, r3, #2
341a2556:	2b00      	cmp	r3, #0
341a2558:	d004      	beq.n	341a2564 <SFDP_BuildGenericDriver+0x2dc>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a255a:	687b      	ldr	r3, [r7, #4]
341a255c:	2206      	movs	r2, #6
341a255e:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a2562:	e037      	b.n	341a25d4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_x1xxb: Volatile Status Register 1, status register powers-up with bits set to "1"s, use instruction 50h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x04u) != 0u)
341a2564:	4b0e      	ldr	r3, [pc, #56]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2566:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a256a:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a256e:	b2db      	uxtb	r3, r3
341a2570:	f003 0304 	and.w	r3, r3, #4
341a2574:	2b00      	cmp	r3, #0
341a2576:	d004      	beq.n	341a2582 <SFDP_BuildGenericDriver+0x2fa>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
341a2578:	687b      	ldr	r3, [r7, #4]
341a257a:	2250      	movs	r2, #80	@ 0x50
341a257c:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a2580:	e028      	b.n	341a25d4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_1xxxb: Non-Volatile/Volatile status register 1 powers-up to last written value in the non-volatile status register,
     use instruction 06h to enable write to non-volatile status register. Volatile status register may be activated after
     power-up to override the non-volatile status register, use instruction 50h to enable write and activate the volatile
     status register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x08u) != 0u)
341a2582:	4b07      	ldr	r3, [pc, #28]	@ (341a25a0 <SFDP_BuildGenericDriver+0x318>)
341a2584:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a2588:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a258c:	b2db      	uxtb	r3, r3
341a258e:	f003 0308 	and.w	r3, r3, #8
341a2592:	2b00      	cmp	r3, #0
341a2594:	d00a      	beq.n	341a25ac <SFDP_BuildGenericDriver+0x324>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a2596:	687b      	ldr	r3, [r7, #4]
341a2598:	2206      	movs	r2, #6
341a259a:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a259e:	e019      	b.n	341a25d4 <SFDP_BuildGenericDriver+0x34c>
341a25a0:	341c1bfc 	.word	0x341c1bfc
341a25a4:	341b7664 	.word	0x341b7664
341a25a8:	341b766c 	.word	0x341b766c
  }
  /* xx1_xxxxb: Status Register 1 contains a mix of volatile and non-volatile bits. The 06h instruction is used to
     enable writing of the register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x10u) != 0u)
341a25ac:	4b66      	ldr	r3, [pc, #408]	@ (341a2748 <SFDP_BuildGenericDriver+0x4c0>)
341a25ae:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a25b2:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a25b6:	b2db      	uxtb	r3, r3
341a25b8:	f003 0310 	and.w	r3, r3, #16
341a25bc:	2b00      	cmp	r3, #0
341a25be:	d004      	beq.n	341a25ca <SFDP_BuildGenericDriver+0x342>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a25c0:	687b      	ldr	r3, [r7, #4]
341a25c2:	2206      	movs	r2, #6
341a25c4:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a25c8:	e004      	b.n	341a25d4 <SFDP_BuildGenericDriver+0x34c>
     1xx_xxxxb: Reserved
     NOTE If the status register is read-only then this field will contain all zeros in bits 4:0.
  */
  else
  {
    retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D16;
341a25ca:	230a      	movs	r3, #10
341a25cc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a25d0:	f000 bc2e 	b.w	341a2e30 <SFDP_BuildGenericDriver+0xba8>
  }

  if(0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
341a25d4:	687b      	ldr	r3, [r7, #4]
341a25d6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a25da:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341a25de:	2b00      	cmp	r3, #0
341a25e0:	d078      	beq.n	341a26d4 <SFDP_BuildGenericDriver+0x44c>
  {
    /* WIP */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitAvailable)
341a25e2:	4b5a      	ldr	r3, [pc, #360]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a25e4:	7cdb      	ldrb	r3, [r3, #19]
341a25e6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a25ea:	b2db      	uxtb	r3, r3
341a25ec:	2b00      	cmp	r3, #0
341a25ee:	d034      	beq.n	341a265a <SFDP_BuildGenericDriver+0x3d2>
    {
      Object->sfdp_private.DriverInfo.ReadWIPCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.CommandReadAccess;
341a25f0:	4b56      	ldr	r3, [pc, #344]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a25f2:	7c5a      	ldrb	r2, [r3, #17]
341a25f4:	687b      	ldr	r3, [r7, #4]
341a25f6:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
341a25fa:	4b54      	ldr	r3, [pc, #336]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a25fc:	7cdb      	ldrb	r3, [r3, #19]
341a25fe:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a2602:	b2db      	uxtb	r3, r3
341a2604:	461a      	mov	r2, r3
341a2606:	687b      	ldr	r3, [r7, #4]
341a2608:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
      Object->sfdp_private.DriverInfo.WIPBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.WIPpolarity;
341a260c:	4b4f      	ldr	r3, [pc, #316]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a260e:	7cdb      	ldrb	r3, [r3, #19]
341a2610:	f3c3 1380 	ubfx	r3, r3, #6, #1
341a2614:	b2db      	uxtb	r3, r3
341a2616:	461a      	mov	r2, r3
341a2618:	687b      	ldr	r3, [r7, #4]
341a261a:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
341a261e:	4b4b      	ldr	r3, [pc, #300]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2620:	7cdb      	ldrb	r3, [r3, #19]
341a2622:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a2626:	b2db      	uxtb	r3, r3
341a2628:	461a      	mov	r2, r3
341a262a:	687b      	ldr	r3, [r7, #4]
341a262c:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
341a2630:	4b46      	ldr	r3, [pc, #280]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2632:	7cdb      	ldrb	r3, [r3, #19]
341a2634:	f003 0310 	and.w	r3, r3, #16
341a2638:	b2db      	uxtb	r3, r3
341a263a:	2b00      	cmp	r3, #0
341a263c:	d009      	beq.n	341a2652 <SFDP_BuildGenericDriver+0x3ca>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WIPAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.LocalAddressForWIP;
341a263e:	4b43      	ldr	r3, [pc, #268]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2640:	7cdb      	ldrb	r3, [r3, #19]
341a2642:	f3c3 03c0 	ubfx	r3, r3, #3, #1
341a2646:	b2db      	uxtb	r3, r3
341a2648:	461a      	mov	r2, r3
341a264a:	687b      	ldr	r3, [r7, #4]
341a264c:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
341a2650:	e003      	b.n	341a265a <SFDP_BuildGenericDriver+0x3d2>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WIPAddress = EXTMEM_ADDRESS_NONE;
341a2652:	687b      	ldr	r3, [r7, #4]
341a2654:	22ff      	movs	r2, #255	@ 0xff
341a2656:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
      }
    }

    /* WEL */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D6.WELBitAvailable)
341a265a:	4b3c      	ldr	r3, [pc, #240]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a265c:	7ddb      	ldrb	r3, [r3, #23]
341a265e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a2662:	b2db      	uxtb	r3, r3
341a2664:	2b00      	cmp	r3, #0
341a2666:	d073      	beq.n	341a2750 <SFDP_BuildGenericDriver+0x4c8>
    {
      Object->sfdp_private.DriverInfo.ReadWELCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.CommandReadAccess;
341a2668:	4b38      	ldr	r3, [pc, #224]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a266a:	7d5a      	ldrb	r2, [r3, #21]
341a266c:	687b      	ldr	r3, [r7, #4]
341a266e:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
341a2672:	4b36      	ldr	r3, [pc, #216]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2674:	7ddb      	ldrb	r3, [r3, #23]
341a2676:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a267a:	b2db      	uxtb	r3, r3
341a267c:	461a      	mov	r2, r3
341a267e:	687b      	ldr	r3, [r7, #4]
341a2680:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
      Object->sfdp_private.DriverInfo.WELBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELpolarity;
341a2684:	4b31      	ldr	r3, [pc, #196]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2686:	7ddb      	ldrb	r3, [r3, #23]
341a2688:	f3c3 1380 	ubfx	r3, r3, #6, #1
341a268c:	b2db      	uxtb	r3, r3
341a268e:	461a      	mov	r2, r3
341a2690:	687b      	ldr	r3, [r7, #4]
341a2692:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
341a2696:	4b2d      	ldr	r3, [pc, #180]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a2698:	7ddb      	ldrb	r3, [r3, #23]
341a269a:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a269e:	b2db      	uxtb	r3, r3
341a26a0:	461a      	mov	r2, r3
341a26a2:	687b      	ldr	r3, [r7, #4]
341a26a4:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
341a26a8:	4b28      	ldr	r3, [pc, #160]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a26aa:	7cdb      	ldrb	r3, [r3, #19]
341a26ac:	f003 0310 	and.w	r3, r3, #16
341a26b0:	b2db      	uxtb	r3, r3
341a26b2:	2b00      	cmp	r3, #0
341a26b4:	d009      	beq.n	341a26ca <SFDP_BuildGenericDriver+0x442>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WELAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELLocalAddress;
341a26b6:	4b25      	ldr	r3, [pc, #148]	@ (341a274c <SFDP_BuildGenericDriver+0x4c4>)
341a26b8:	7ddb      	ldrb	r3, [r3, #23]
341a26ba:	f3c3 03c0 	ubfx	r3, r3, #3, #1
341a26be:	b2db      	uxtb	r3, r3
341a26c0:	461a      	mov	r2, r3
341a26c2:	687b      	ldr	r3, [r7, #4]
341a26c4:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
341a26c8:	e042      	b.n	341a2750 <SFDP_BuildGenericDriver+0x4c8>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WELAddress = EXTMEM_ADDRESS_NONE;
341a26ca:	687b      	ldr	r3, [r7, #4]
341a26cc:	22ff      	movs	r2, #255	@ 0xff
341a26ce:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
341a26d2:	e03d      	b.n	341a2750 <SFDP_BuildGenericDriver+0x4c8>
      }
    }
  }
  else
  {
      Object->sfdp_private.DriverInfo.WELPosition     = 1;
341a26d4:	687b      	ldr	r3, [r7, #4]
341a26d6:	2201      	movs	r2, #1
341a26d8:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
      Object->sfdp_private.DriverInfo.WELBusyPolarity = 0;
341a26dc:	687b      	ldr	r3, [r7, #4]
341a26de:	2200      	movs	r2, #0
341a26e0:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73

      /*
       *   WIP : Status register read management
       *         Basic D14 Status register Polling device Busy
       */
      if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x01u))
341a26e4:	4b18      	ldr	r3, [pc, #96]	@ (341a2748 <SFDP_BuildGenericDriver+0x4c0>)
341a26e6:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a26ea:	f3c3 0385 	ubfx	r3, r3, #2, #6
341a26ee:	b2db      	uxtb	r3, r3
341a26f0:	f003 0301 	and.w	r3, r3, #1
341a26f4:	2b00      	cmp	r3, #0
341a26f6:	d00c      	beq.n	341a2712 <SFDP_BuildGenericDriver+0x48a>
      {
        /* xx_xxx1b: Use of legacy polling is supported by reading the Status Register with 05h instruction
           and checking WIP bit[0] (0=ready; 1=busy). */
        Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a26f8:	687b      	ldr	r3, [r7, #4]
341a26fa:	2205      	movs	r2, #5
341a26fc:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        Object->sfdp_private.DriverInfo.WIPPosition = 0u;
341a2700:	687b      	ldr	r3, [r7, #4]
341a2702:	2200      	movs	r2, #0
341a2704:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
        Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
341a2708:	687b      	ldr	r3, [r7, #4]
341a270a:	2200      	movs	r2, #0
341a270c:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
341a2710:	e01e      	b.n	341a2750 <SFDP_BuildGenericDriver+0x4c8>
      }
      else if (0x02u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x02u))
341a2712:	4b0d      	ldr	r3, [pc, #52]	@ (341a2748 <SFDP_BuildGenericDriver+0x4c0>)
341a2714:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a2718:	f3c3 0385 	ubfx	r3, r3, #2, #6
341a271c:	b2db      	uxtb	r3, r3
341a271e:	f003 0302 	and.w	r3, r3, #2
341a2722:	2b00      	cmp	r3, #0
341a2724:	d00c      	beq.n	341a2740 <SFDP_BuildGenericDriver+0x4b8>
      {
        /* xx_xx1xb: Bit 7 of the Flag Status Register may be polled any time a Program, Erase, Suspend/Resume
           command is issued, or after a Reset command while the device is busy. The read instruction is 70h.
           Flag Status Register bit definitions: bit[7]: Program or erase controller status (0=busy; 1=ready)*/
        Object->sfdp_private.DriverInfo.ReadWIPCommand = 0x70;
341a2726:	687b      	ldr	r3, [r7, #4]
341a2728:	2270      	movs	r2, #112	@ 0x70
341a272a:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        Object->sfdp_private.DriverInfo.WIPPosition = 7u;
341a272e:	687b      	ldr	r3, [r7, #4]
341a2730:	2207      	movs	r2, #7
341a2732:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
        Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
341a2736:	687b      	ldr	r3, [r7, #4]
341a2738:	2200      	movs	r2, #0
341a273a:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
341a273e:	e007      	b.n	341a2750 <SFDP_BuildGenericDriver+0x4c8>
      }
      else
      {
          retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D14;
341a2740:	2309      	movs	r3, #9
341a2742:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a2746:	e373      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
341a2748:	341c1bfc 	.word	0x341c1bfc
341a274c:	341c1c7c 	.word	0x341c1c7c
      }
  }

  /* Set default value for Read instruction */
  Object->sfdp_private.DriverInfo.ReadInstruction     = SFDP_DRIVER_READ_COMMAND;
341a2750:	687b      	ldr	r3, [r7, #4]
341a2752:	2203      	movs	r2, #3
341a2754:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76

  /* ---------------------------------------------------
   *  command based on SFDP_PARAMID_BASIC_SPIPROTOCOL
   * ---------------------------------------------------
   */
  if (((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
341a2758:	687b      	ldr	r3, [r7, #4]
341a275a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a275e:	f003 0308 	and.w	r3, r3, #8
341a2762:	2b00      	cmp	r3, #0
341a2764:	f000 80af 	beq.w	341a28c6 <SFDP_BuildGenericDriver+0x63e>
       == (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
      && (Object->sfdp_private.Config < EXTMEM_LINK_CONFIG_8LINES))
341a2768:	687b      	ldr	r3, [r7, #4]
341a276a:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a276e:	2b02      	cmp	r3, #2
341a2770:	f200 80a9 	bhi.w	341a28c6 <SFDP_BuildGenericDriver+0x63e>
  {
    dummyCycles = 0;
341a2774:	2300      	movs	r3, #0
341a2776:	617b      	str	r3, [r7, #20]
    Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
341a2778:	687b      	ldr	r3, [r7, #4]
341a277a:	2200      	movs	r2, #0
341a277c:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_1LINE)
341a2780:	687b      	ldr	r3, [r7, #4]
341a2782:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a2786:	2b00      	cmp	r3, #0
341a2788:	d04c      	beq.n	341a2824 <SFDP_BuildGenericDriver+0x59c>
    {
      /* control if read 1s1s2s is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction != 0u)
341a278a:	4baa      	ldr	r3, [pc, #680]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a278c:	7c5b      	ldrb	r3, [r3, #17]
341a278e:	2b00      	cmp	r3, #0
341a2790:	d015      	beq.n	341a27be <SFDP_BuildGenericDriver+0x536>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_ModeClock;
341a2792:	4ba8      	ldr	r3, [pc, #672]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a2794:	7c1b      	ldrb	r3, [r3, #16]
341a2796:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a279a:	b2db      	uxtb	r3, r3
341a279c:	461a      	mov	r2, r3
341a279e:	4ba5      	ldr	r3, [pc, #660]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27a0:	7c1b      	ldrb	r3, [r3, #16]
341a27a2:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a27a6:	b2db      	uxtb	r3, r3
341a27a8:	4413      	add	r3, r2
341a27aa:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction;
341a27ac:	4ba1      	ldr	r3, [pc, #644]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27ae:	7c5a      	ldrb	r2, [r3, #17]
341a27b0:	687b      	ldr	r3, [r7, #4]
341a27b2:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S2S;
341a27b6:	687b      	ldr	r3, [r7, #4]
341a27b8:	2201      	movs	r2, #1
341a27ba:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* control if read 1S2S2S is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction != 0u)
341a27be:	4b9d      	ldr	r3, [pc, #628]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27c0:	7cdb      	ldrb	r3, [r3, #19]
341a27c2:	2b00      	cmp	r3, #0
341a27c4:	d015      	beq.n	341a27f2 <SFDP_BuildGenericDriver+0x56a>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_ModeClock;
341a27c6:	4b9b      	ldr	r3, [pc, #620]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27c8:	7c9b      	ldrb	r3, [r3, #18]
341a27ca:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a27ce:	b2db      	uxtb	r3, r3
341a27d0:	461a      	mov	r2, r3
341a27d2:	4b98      	ldr	r3, [pc, #608]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27d4:	7c9b      	ldrb	r3, [r3, #18]
341a27d6:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a27da:	b2db      	uxtb	r3, r3
341a27dc:	4413      	add	r3, r2
341a27de:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction;
341a27e0:	4b94      	ldr	r3, [pc, #592]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27e2:	7cda      	ldrb	r2, [r3, #19]
341a27e4:	687b      	ldr	r3, [r7, #4]
341a27e6:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S2S2S;
341a27ea:	687b      	ldr	r3, [r7, #4]
341a27ec:	2202      	movs	r2, #2
341a27ee:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* The memory work only in 2S2S2S */
      if (JEDEC_Basic.Params.Param_DWORD.D5._2S2S2S_FastReadSupport != 0u)
341a27f2:	4b90      	ldr	r3, [pc, #576]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a27f4:	7d1b      	ldrb	r3, [r3, #20]
341a27f6:	f003 0301 	and.w	r3, r3, #1
341a27fa:	b2db      	uxtb	r3, r3
341a27fc:	2b00      	cmp	r3, #0
341a27fe:	d011      	beq.n	341a2824 <SFDP_BuildGenericDriver+0x59c>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_ModeClock;
341a2800:	4b8c      	ldr	r3, [pc, #560]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a2802:	7e9b      	ldrb	r3, [r3, #26]
341a2804:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a2808:	b2db      	uxtb	r3, r3
341a280a:	461a      	mov	r2, r3
341a280c:	4b89      	ldr	r3, [pc, #548]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a280e:	7e9b      	ldrb	r3, [r3, #26]
341a2810:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a2814:	b2db      	uxtb	r3, r3
341a2816:	4413      	add	r3, r2
341a2818:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_FastReadInstruction;
341a281a:	4b86      	ldr	r3, [pc, #536]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a281c:	7eda      	ldrb	r2, [r3, #27]
341a281e:	687b      	ldr	r3, [r7, #4]
341a2820:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      }
    }

    /* the command set is only based on this table */
    /* determine the best line configuration */
    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_2LINES)
341a2824:	687b      	ldr	r3, [r7, #4]
341a2826:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a282a:	2b01      	cmp	r3, #1
341a282c:	d92c      	bls.n	341a2888 <SFDP_BuildGenericDriver+0x600>
    {
      if (JEDEC_Basic.Params.Param_DWORD.D5._4S4S4S_FastReadSupport != 0u)
341a282e:	4b81      	ldr	r3, [pc, #516]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a2830:	7d1b      	ldrb	r3, [r3, #20]
341a2832:	f003 0310 	and.w	r3, r3, #16
341a2836:	b2db      	uxtb	r3, r3
341a2838:	2b00      	cmp	r3, #0
341a283a:	d020      	beq.n	341a287e <SFDP_BuildGenericDriver+0x5f6>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_ModeClock;
341a283c:	4b7d      	ldr	r3, [pc, #500]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a283e:	7f9b      	ldrb	r3, [r3, #30]
341a2840:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a2844:	b2db      	uxtb	r3, r3
341a2846:	461a      	mov	r2, r3
341a2848:	4b7a      	ldr	r3, [pc, #488]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a284a:	7f9b      	ldrb	r3, [r3, #30]
341a284c:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a2850:	b2db      	uxtb	r3, r3
341a2852:	4413      	add	r3, r2
341a2854:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_FastReadInstruction;
341a2856:	4b77      	ldr	r3, [pc, #476]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a2858:	7fda      	ldrb	r2, [r3, #31]
341a285a:	687b      	ldr	r3, [r7, #4]
341a285c:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_4S4S4S;
341a2860:	687b      	ldr	r3, [r7, #4]
341a2862:	2204      	movs	r2, #4
341a2864:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

        retr = JEDEC_Basic_Manage4S4S4SEnableSequence(Object);
341a2868:	6878      	ldr	r0, [r7, #4]
341a286a:	f000 feeb 	bl	341a3644 <JEDEC_Basic_Manage4S4S4SEnableSequence>
341a286e:	4603      	mov	r3, r0
341a2870:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if ( retr != EXTMEM_SFDP_OK)
341a2874:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341a2878:	2b00      	cmp	r3, #0
341a287a:	f040 82d6 	bne.w	341a2e2a <SFDP_BuildGenericDriver+0xba2>
      }
      else /* other configuration with more 4 lines */
      {
        /* not yet handled */
      }
      SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, (uint8_t)dummyCycles);
341a287e:	697b      	ldr	r3, [r7, #20]
341a2880:	b2da      	uxtb	r2, r3
341a2882:	687b      	ldr	r3, [r7, #4]
341a2884:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
#endif /* IS25WP032D_ENABLE_DTR */

    }

    /* Configure the link */
    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a2888:	687b      	ldr	r3, [r7, #4]
341a288a:	f103 0008 	add.w	r0, r3, #8
341a288e:	687b      	ldr	r3, [r7, #4]
341a2890:	3364      	adds	r3, #100	@ 0x64
341a2892:	461a      	mov	r2, r3
341a2894:	2100      	movs	r1, #0
341a2896:	f7fe fd9b 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a289a:	4603      	mov	r3, r0
341a289c:	2b00      	cmp	r3, #0
341a289e:	d003      	beq.n	341a28a8 <SFDP_BuildGenericDriver+0x620>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a28a0:	230c      	movs	r3, #12
341a28a2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a28a6:	e2c3      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
    }

    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, &dummyCycles))
341a28a8:	687b      	ldr	r3, [r7, #4]
341a28aa:	3308      	adds	r3, #8
341a28ac:	f107 0214 	add.w	r2, r7, #20
341a28b0:	2101      	movs	r1, #1
341a28b2:	4618      	mov	r0, r3
341a28b4:	f7fe fd8c 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a28b8:	4603      	mov	r3, r0
341a28ba:	2b00      	cmp	r3, #0
341a28bc:	d003      	beq.n	341a28c6 <SFDP_BuildGenericDriver+0x63e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a28be:	230c      	movs	r3, #12
341a28c0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a28c4:	e2b4      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
  /* -------------------------------------------------------------------------------------------------------------------
     If an octal DDR table is present and the target is 8D8D8D,
     when switch in octal DDR mode
     -------------------------------------------------------------------------------------------------------------------
  */
  if (((uint32_t)SFDP_PARAMID_OCTAL_DDR == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_OCTAL_DDR))
341a28c6:	687b      	ldr	r3, [r7, #4]
341a28c8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a28cc:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341a28d0:	2b00      	cmp	r3, #0
341a28d2:	d073      	beq.n	341a29bc <SFDP_BuildGenericDriver+0x734>
      && (EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config))
341a28d4:	687b      	ldr	r3, [r7, #4]
341a28d6:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a28da:	2b03      	cmp	r3, #3
341a28dc:	d16e      	bne.n	341a29bc <SFDP_BuildGenericDriver+0x734>
  {
    /* check if we are not already in octal mode */
    if (PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)
341a28de:	687b      	ldr	r3, [r7, #4]
341a28e0:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a28e4:	2b09      	cmp	r3, #9
341a28e6:	d103      	bne.n	341a28f0 <SFDP_BuildGenericDriver+0x668>
    {
      flag4byteAddress = 1u;
341a28e8:	2301      	movs	r3, #1
341a28ea:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
341a28ee:	e044      	b.n	341a297a <SFDP_BuildGenericDriver+0x6f2>
    }
    else
    {
      /* Execute the flash command sequence to switch in octal DDR */
      if (EXTMEM_SFDP_OK == sfdp_enter_octal_mode(Object))
341a28f0:	6878      	ldr	r0, [r7, #4]
341a28f2:	f000 fc11 	bl	341a3118 <sfdp_enter_octal_mode>
341a28f6:	4603      	mov	r3, r0
341a28f8:	2b00      	cmp	r3, #0
341a28fa:	d13e      	bne.n	341a297a <SFDP_BuildGenericDriver+0x6f2>
      {
        /* switch the memory interface configuration according to the Access protocol field */
        flag4byteAddress = 1u;
341a28fc:	2301      	movs	r3, #1
341a28fe:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        /* Specific case of GigaDevice memory GD25LX512ME whose Instruction mode remains on 8S (8bit commands) */
        if (Object->sfdp_private.ManuID == EXTMEM_MANFACTURER_GIGADEVICE)
341a2902:	687b      	ldr	r3, [r7, #4]
341a2904:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a2908:	2bc8      	cmp	r3, #200	@ 0xc8
341a290a:	d104      	bne.n	341a2916 <SFDP_BuildGenericDriver+0x68e>
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8S8D8D;
341a290c:	687b      	ldr	r3, [r7, #4]
341a290e:	2208      	movs	r2, #8
341a2910:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
341a2914:	e003      	b.n	341a291e <SFDP_BuildGenericDriver+0x696>
        }
        else
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8D8D8D;
341a2916:	687b      	ldr	r3, [r7, #4]
341a2918:	2209      	movs	r2, #9
341a291a:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        }

        /* update the physical link */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a291e:	687b      	ldr	r3, [r7, #4]
341a2920:	f103 0008 	add.w	r0, r3, #8
341a2924:	687b      	ldr	r3, [r7, #4]
341a2926:	3364      	adds	r3, #100	@ 0x64
341a2928:	461a      	mov	r2, r3
341a292a:	2100      	movs	r1, #0
341a292c:	f7fe fd50 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a2930:	4603      	mov	r3, r0
341a2932:	2b00      	cmp	r3, #0
341a2934:	d003      	beq.n	341a293e <SFDP_BuildGenericDriver+0x6b6>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2936:	230c      	movs	r3, #12
341a2938:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a293c:	e278      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }

        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFDu)
341a293e:	687b      	ldr	r3, [r7, #4]
341a2940:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
341a2944:	2bfd      	cmp	r3, #253	@ 0xfd
341a2946:	d109      	bne.n	341a295c <SFDP_BuildGenericDriver+0x6d4>
        {
          /* set 20 wait state */
          dummyCycles = 20;
341a2948:	2314      	movs	r3, #20
341a294a:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a294c:	687b      	ldr	r3, [r7, #4]
341a294e:	3308      	adds	r3, #8
341a2950:	f107 0214 	add.w	r2, r7, #20
341a2954:	2101      	movs	r1, #1
341a2956:	4618      	mov	r0, r3
341a2958:	f7fe fd3a 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
        }
        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFEu)
341a295c:	687b      	ldr	r3, [r7, #4]
341a295e:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
341a2962:	2bfe      	cmp	r3, #254	@ 0xfe
341a2964:	d109      	bne.n	341a297a <SFDP_BuildGenericDriver+0x6f2>
        {
          /* set 8 wait state */
          dummyCycles = 8;
341a2966:	2308      	movs	r3, #8
341a2968:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a296a:	687b      	ldr	r3, [r7, #4]
341a296c:	3308      	adds	r3, #8
341a296e:	f107 0214 	add.w	r2, r7, #20
341a2972:	2101      	movs	r1, #1
341a2974:	4618      	mov	r0, r3
341a2976:	f7fe fd2b 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
        /* an error occurs when trying to switch the mode                        */
        /* when continue the process and check if another mode could be targeted */
      }
    }

    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
341a297a:	687b      	ldr	r3, [r7, #4]
341a297c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a2980:	f003 0308 	and.w	r3, r3, #8
341a2984:	2b00      	cmp	r3, #0
341a2986:	d019      	beq.n	341a29bc <SFDP_BuildGenericDriver+0x734>
        (JEDEC_Basic.size > 16u))
341a2988:	4b2a      	ldr	r3, [pc, #168]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a298a:	681b      	ldr	r3, [r3, #0]
    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
341a298c:	2b10      	cmp	r3, #16
341a298e:	d915      	bls.n	341a29bc <SFDP_BuildGenericDriver+0x734>
    {
      /* check octal information to determine */
      /* 0b00 The Command Extension is the same as the Command. (The Command / Command Extension has the same value for the whole clock period.)*/
      /* 0b01 The Command Extension is the inverse of the Command. The Command Extension acts as a confirmation of the Command */
      /* 0b11 Command and Command Extension forms a 16-bit command word */
      if (JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension > 1u)
341a2990:	4b28      	ldr	r3, [pc, #160]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a2992:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
341a2996:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a299a:	b2db      	uxtb	r3, r3
341a299c:	2b01      	cmp	r3, #1
341a299e:	d903      	bls.n	341a29a8 <SFDP_BuildGenericDriver+0x720>
      {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a29a0:	230f      	movs	r3, #15
341a29a2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a29a6:	e243      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
      }
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject, (uint8_t)JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension);
341a29a8:	4b22      	ldr	r3, [pc, #136]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a29aa:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
341a29ae:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a29b2:	b2db      	uxtb	r3, r3
341a29b4:	461a      	mov	r2, r3
341a29b6:	687b      	ldr	r3, [r7, #4]
341a29b8:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    }
  }

  /* Check WIP flag with new access mode */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a29bc:	2164      	movs	r1, #100	@ 0x64
341a29be:	6878      	ldr	r0, [r7, #4]
341a29c0:	f000 fa4a 	bl	341a2e58 <driver_check_FlagBUSY>
341a29c4:	4603      	mov	r3, r0
341a29c6:	2b00      	cmp	r3, #0
341a29c8:	d003      	beq.n	341a29d2 <SFDP_BuildGenericDriver+0x74a>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a29ca:	230c      	movs	r3, #12
341a29cc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a29d0:	e22e      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
  }

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION) == (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION)
341a29d2:	687b      	ldr	r3, [r7, #4]
341a29d4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a29d8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a29dc:	2b00      	cmp	r3, #0
341a29de:	f000 8144 	beq.w	341a2c6a <SFDP_BuildGenericDriver+0x9e2>
  {
    if (0u == flag4byteAddress)
341a29e2:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
341a29e6:	2b00      	cmp	r3, #0
341a29e8:	f040 80a2 	bne.w	341a2b30 <SFDP_BuildGenericDriver+0x8a8>
    {
      /* xxxx_xxx1b: issue instruction B7h (preceding write enable not required) */
      if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x01u))
341a29ec:	4b11      	ldr	r3, [pc, #68]	@ (341a2a34 <SFDP_BuildGenericDriver+0x7ac>)
341a29ee:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a29f2:	f003 0301 	and.w	r3, r3, #1
341a29f6:	2b00      	cmp	r3, #0
341a29f8:	d01e      	beq.n	341a2a38 <SFDP_BuildGenericDriver+0x7b0>
      {
        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,0xB7, NULL, 0))
341a29fa:	687b      	ldr	r3, [r7, #4]
341a29fc:	f103 0008 	add.w	r0, r3, #8
341a2a00:	2300      	movs	r3, #0
341a2a02:	2200      	movs	r2, #0
341a2a04:	21b7      	movs	r1, #183	@ 0xb7
341a2a06:	f7fe ffc0 	bl	341a198a <SAL_XSPI_CommandSendData>
341a2a0a:	4603      	mov	r3, r0
341a2a0c:	2b00      	cmp	r3, #0
341a2a0e:	d003      	beq.n	341a2a18 <SFDP_BuildGenericDriver+0x790>
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2a10:	230c      	movs	r3, #12
341a2a12:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a2a16:	e20b      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }

        /* Set 4-Byte addressing on PHY side */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
341a2a18:	687b      	ldr	r3, [r7, #4]
341a2a1a:	3308      	adds	r3, #8
341a2a1c:	2200      	movs	r2, #0
341a2a1e:	2102      	movs	r1, #2
341a2a20:	4618      	mov	r0, r3
341a2a22:	f7fe fcd5 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a2a26:	4603      	mov	r3, r0
341a2a28:	2b00      	cmp	r3, #0
341a2a2a:	d06f      	beq.n	341a2b0c <SFDP_BuildGenericDriver+0x884>
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2a2c:	230c      	movs	r3, #12
341a2a2e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a2a32:	e1fd      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
341a2a34:	341c1bfc 	.word	0x341c1bfc
        }

        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xxxx_xx1xb: issue write enable instruction 06h, then issue instruction B7h */
      else if (0x2u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x2u))
341a2a38:	4b53      	ldr	r3, [pc, #332]	@ (341a2b88 <SFDP_BuildGenericDriver+0x900>)
341a2a3a:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a2a3e:	f003 0302 	and.w	r3, r3, #2
341a2a42:	2b00      	cmp	r3, #0
341a2a44:	d050      	beq.n	341a2ae8 <SFDP_BuildGenericDriver+0x860>
      {
        /* send command to write enable */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
341a2a46:	687b      	ldr	r3, [r7, #4]
341a2a48:	f103 0008 	add.w	r0, r3, #8
341a2a4c:	687b      	ldr	r3, [r7, #4]
341a2a4e:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a2a52:	2300      	movs	r3, #0
341a2a54:	2200      	movs	r2, #0
341a2a56:	f7fe ff98 	bl	341a198a <SAL_XSPI_CommandSendData>
341a2a5a:	4603      	mov	r3, r0
341a2a5c:	2b00      	cmp	r3, #0
341a2a5e:	d003      	beq.n	341a2a68 <SFDP_BuildGenericDriver+0x7e0>
                                           Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2a60:	230c      	movs	r3, #12
341a2a62:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a2a66:	e1e3      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }

        /* control the write enable */
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a2a68:	687b      	ldr	r3, [r7, #4]
341a2a6a:	f103 0008 	add.w	r0, r3, #8
341a2a6e:	687b      	ldr	r3, [r7, #4]
341a2a70:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                                   Object->sfdp_private.DriverInfo.ReadWELCommand,
                                                   Object->sfdp_private.DriverInfo.WELAddress,
341a2a74:	687b      	ldr	r3, [r7, #4]
341a2a76:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a2a7a:	461e      	mov	r6, r3
                                                   ((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u: 0u) << Object->sfdp_private.DriverInfo.WELPosition,
341a2a7c:	687b      	ldr	r3, [r7, #4]
341a2a7e:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
341a2a82:	2b00      	cmp	r3, #0
341a2a84:	d101      	bne.n	341a2a8a <SFDP_BuildGenericDriver+0x802>
341a2a86:	2301      	movs	r3, #1
341a2a88:	e000      	b.n	341a2a8c <SFDP_BuildGenericDriver+0x804>
341a2a8a:	2300      	movs	r3, #0
341a2a8c:	687a      	ldr	r2, [r7, #4]
341a2a8e:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
341a2a92:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a2a94:	b2dc      	uxtb	r4, r3
                                                   1u << Object->sfdp_private.DriverInfo.WELPosition,
341a2a96:	687b      	ldr	r3, [r7, #4]
341a2a98:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
341a2a9c:	461a      	mov	r2, r3
341a2a9e:	2301      	movs	r3, #1
341a2aa0:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a2aa2:	b2db      	uxtb	r3, r3
341a2aa4:	687a      	ldr	r2, [r7, #4]
341a2aa6:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a2aaa:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
341a2aae:	9502      	str	r5, [sp, #8]
341a2ab0:	9201      	str	r2, [sp, #4]
341a2ab2:	9300      	str	r3, [sp, #0]
341a2ab4:	4623      	mov	r3, r4
341a2ab6:	4632      	mov	r2, r6
341a2ab8:	f7ff f874 	bl	341a1ba4 <SAL_XSPI_CheckStatusRegister>
341a2abc:	4603      	mov	r3, r0
341a2abe:	2b00      	cmp	r3, #0
341a2ac0:	d003      	beq.n	341a2aca <SFDP_BuildGenericDriver+0x842>
                                                   Object->sfdp_private.ManuID, 1000))
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2ac2:	230c      	movs	r3, #12
341a2ac4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a2ac8:	e1b2      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }

        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0xB7, NULL, 0u))
341a2aca:	687b      	ldr	r3, [r7, #4]
341a2acc:	f103 0008 	add.w	r0, r3, #8
341a2ad0:	2300      	movs	r3, #0
341a2ad2:	2200      	movs	r2, #0
341a2ad4:	21b7      	movs	r1, #183	@ 0xb7
341a2ad6:	f7fe ff58 	bl	341a198a <SAL_XSPI_CommandSendData>
341a2ada:	4603      	mov	r3, r0
341a2adc:	2b00      	cmp	r3, #0
341a2ade:	d015      	beq.n	341a2b0c <SFDP_BuildGenericDriver+0x884>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2ae0:	230c      	movs	r3, #12
341a2ae2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a2ae6:	e1a3      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }
      }
      /* x1xx_xxxxb: Always operates in 4-Byte address mode */
      else if (0x40u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x40u))
341a2ae8:	4b27      	ldr	r3, [pc, #156]	@ (341a2b88 <SFDP_BuildGenericDriver+0x900>)
341a2aea:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a2aee:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a2af2:	2b00      	cmp	r3, #0
341a2af4:	d10a      	bne.n	341a2b0c <SFDP_BuildGenericDriver+0x884>
      {
        /* nothing to do */
        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xx1x_xxxxb: Supports dedicated 4-Byte address instruction set. Consult vendor data sheet for the instruction set definition.*/
      else if (0x20u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x20u))
341a2af6:	4b24      	ldr	r3, [pc, #144]	@ (341a2b88 <SFDP_BuildGenericDriver+0x900>)
341a2af8:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a2afc:	f003 0320 	and.w	r3, r3, #32
341a2b00:	2b00      	cmp	r3, #0
341a2b02:	d103      	bne.n	341a2b0c <SFDP_BuildGenericDriver+0x884>
        /* xxxx_x1xxb: 8-bit volatile extended address register used to define A[31:24] bits. Read with instruction C8h. Write instruction is C5h with 1 byte of data. Select the active 128 Mbit memory segment by setting the appropriate A[31:24] bits and use 3-Byte addressing.
           xxxx_1xxxb: 8-bit volatile bank register used to define A[30:A24] bits. MSB (bit[7]) is used to enable/disable 4-byte address mode. When MSB is set to 1, 4-byte address mode is active and A[30:24] bits are do not care. Read with instruction 16h. Write instruction is 17h with 1 byte of data. When MSB is cleared to 0, select the active 128 Mbit segment by setting the appropriate A[30:24] bits and use 3-Byte addressing.
           xxx1_xxxxb: A 16-bit nonvolatile configuration register controls 3-Byte/4-Byte address mode. Read instruction is B5h. Bit[0] controls address mode [0=3-Byte;1=4-Byte]. Write configuration register instruction is B1h, data length is 2 bytes.
        */
      else {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a2b04:	230f      	movs	r3, #15
341a2b06:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a2b0a:	e191      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>

      }

      /* Set 4 bytes addressing on PHY side */
      if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
341a2b0c:	687b      	ldr	r3, [r7, #4]
341a2b0e:	3308      	adds	r3, #8
341a2b10:	2200      	movs	r2, #0
341a2b12:	2102      	movs	r1, #2
341a2b14:	4618      	mov	r0, r3
341a2b16:	f7fe fc5b 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a2b1a:	4603      	mov	r3, r0
341a2b1c:	2b00      	cmp	r3, #0
341a2b1e:	d003      	beq.n	341a2b28 <SFDP_BuildGenericDriver+0x8a0>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2b20:	230c      	movs	r3, #12
341a2b22:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a2b26:	e183      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
      }

      /* Set the read function for 4 bytes Address */
      Object->sfdp_private.DriverInfo.ReadInstruction = 0x13U;
341a2b28:	687b      	ldr	r3, [r7, #4]
341a2b2a:	2213      	movs	r2, #19
341a2b2c:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if ((EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config) && (PHY_LINK_1S1S1S == Object->sfdp_private.DriverInfo.SpiPhyLink))
341a2b30:	687b      	ldr	r3, [r7, #4]
341a2b32:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a2b36:	2b03      	cmp	r3, #3
341a2b38:	d132      	bne.n	341a2ba0 <SFDP_BuildGenericDriver+0x918>
341a2b3a:	687b      	ldr	r3, [r7, #4]
341a2b3c:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a2b40:	2b00      	cmp	r3, #0
341a2b42:	d12d      	bne.n	341a2ba0 <SFDP_BuildGenericDriver+0x918>
    {
      /* check if we can switch to if the config is still 1S8S8S */
      if ((0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)  && (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand))
341a2b44:	4b11      	ldr	r3, [pc, #68]	@ (341a2b8c <SFDP_BuildGenericDriver+0x904>)
341a2b46:	789b      	ldrb	r3, [r3, #2]
341a2b48:	f003 0320 	and.w	r3, r3, #32
341a2b4c:	b2db      	uxtb	r3, r3
341a2b4e:	2b00      	cmp	r3, #0
341a2b50:	d026      	beq.n	341a2ba0 <SFDP_BuildGenericDriver+0x918>
341a2b52:	4b0e      	ldr	r3, [pc, #56]	@ (341a2b8c <SFDP_BuildGenericDriver+0x904>)
341a2b54:	78db      	ldrb	r3, [r3, #3]
341a2b56:	f003 0301 	and.w	r3, r3, #1
341a2b5a:	b2db      	uxtb	r3, r3
341a2b5c:	2b00      	cmp	r3, #0
341a2b5e:	d01f      	beq.n	341a2ba0 <SFDP_BuildGenericDriver+0x918>
      {
        /* Patch Micron write command 0x81 @0x0 0xE7 */
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S8S8S;
341a2b60:	687b      	ldr	r3, [r7, #4]
341a2b62:	2207      	movs	r2, #7
341a2b64:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a2b68:	687b      	ldr	r3, [r7, #4]
341a2b6a:	f103 0008 	add.w	r0, r3, #8
341a2b6e:	687b      	ldr	r3, [r7, #4]
341a2b70:	3364      	adds	r3, #100	@ 0x64
341a2b72:	461a      	mov	r2, r3
341a2b74:	2100      	movs	r1, #0
341a2b76:	f7fe fc2b 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a2b7a:	4603      	mov	r3, r0
341a2b7c:	2b00      	cmp	r3, #0
341a2b7e:	d007      	beq.n	341a2b90 <SFDP_BuildGenericDriver+0x908>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a2b80:	230c      	movs	r3, #12
341a2b82:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a2b86:	e153      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
341a2b88:	341c1bfc 	.word	0x341c1bfc
341a2b8c:	341c1c5c 	.word	0x341c1c5c
        }
        Object->sfdp_private.DriverInfo.ReadInstruction = 0xCC;
341a2b90:	687b      	ldr	r3, [r7, #4]
341a2b92:	22cc      	movs	r2, #204	@ 0xcc
341a2b94:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x8E;
341a2b98:	687b      	ldr	r3, [r7, #4]
341a2b9a:	228e      	movs	r2, #142	@ 0x8e
341a2b9c:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75

    /*
      need to be study more; it seems that Macronix used it to define the command maybe because only one mode is
      supported in their case
    */
    if ((Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8D8D8D) ||
341a2ba0:	687b      	ldr	r3, [r7, #4]
341a2ba2:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a2ba6:	2b09      	cmp	r3, #9
341a2ba8:	d004      	beq.n	341a2bb4 <SFDP_BuildGenericDriver+0x92c>
        (Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_1S1S1S))
341a2baa:	687b      	ldr	r3, [r7, #4]
341a2bac:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
    if ((Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8D8D8D) ||
341a2bb0:	2b00      	cmp	r3, #0
341a2bb2:	d120      	bne.n	341a2bf6 <SFDP_BuildGenericDriver+0x96e>
    {
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_PageProgramCommand) {Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x12u;}
341a2bb4:	4ba1      	ldr	r3, [pc, #644]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2bb6:	781b      	ldrb	r3, [r3, #0]
341a2bb8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a2bbc:	b2db      	uxtb	r3, r3
341a2bbe:	2b00      	cmp	r3, #0
341a2bc0:	d003      	beq.n	341a2bca <SFDP_BuildGenericDriver+0x942>
341a2bc2:	687b      	ldr	r3, [r7, #4]
341a2bc4:	2212      	movs	r2, #18
341a2bc6:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_ReadCommand)        {Object->sfdp_private.DriverInfo.ReadInstruction        = 0x13u;}
341a2bca:	4b9c      	ldr	r3, [pc, #624]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2bcc:	781b      	ldrb	r3, [r3, #0]
341a2bce:	f003 0301 	and.w	r3, r3, #1
341a2bd2:	b2db      	uxtb	r3, r3
341a2bd4:	2b00      	cmp	r3, #0
341a2bd6:	d003      	beq.n	341a2be0 <SFDP_BuildGenericDriver+0x958>
341a2bd8:	687b      	ldr	r3, [r7, #4]
341a2bda:	2213      	movs	r2, #19
341a2bdc:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_FastReadCommand)    {Object->sfdp_private.DriverInfo.ReadInstruction        = 0x0Cu;}
341a2be0:	4b96      	ldr	r3, [pc, #600]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2be2:	781b      	ldrb	r3, [r3, #0]
341a2be4:	f003 0302 	and.w	r3, r3, #2
341a2be8:	b2db      	uxtb	r3, r3
341a2bea:	2b00      	cmp	r3, #0
341a2bec:	d003      	beq.n	341a2bf6 <SFDP_BuildGenericDriver+0x96e>
341a2bee:	687b      	ldr	r3, [r7, #4]
341a2bf0:	220c      	movs	r2, #12
341a2bf2:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if (Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8S8D8D)
341a2bf6:	687b      	ldr	r3, [r7, #4]
341a2bf8:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a2bfc:	2b08      	cmp	r3, #8
341a2bfe:	d120      	bne.n	341a2c42 <SFDP_BuildGenericDriver+0x9ba>
    {
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand) {Object->sfdp_private.DriverInfo.PageProgramInstruction  = 0x02u;}
341a2c00:	4b8e      	ldr	r3, [pc, #568]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c02:	78db      	ldrb	r3, [r3, #3]
341a2c04:	f003 0301 	and.w	r3, r3, #1
341a2c08:	b2db      	uxtb	r3, r3
341a2c0a:	2b00      	cmp	r3, #0
341a2c0c:	d003      	beq.n	341a2c16 <SFDP_BuildGenericDriver+0x98e>
341a2c0e:	687b      	ldr	r3, [r7, #4]
341a2c10:	2202      	movs	r2, #2
341a2c12:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)    {Object->sfdp_private.DriverInfo.ReadInstruction         = 0xCCu;}
341a2c16:	4b89      	ldr	r3, [pc, #548]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c18:	789b      	ldrb	r3, [r3, #2]
341a2c1a:	f003 0320 	and.w	r3, r3, #32
341a2c1e:	b2db      	uxtb	r3, r3
341a2c20:	2b00      	cmp	r3, #0
341a2c22:	d003      	beq.n	341a2c2c <SFDP_BuildGenericDriver+0x9a4>
341a2c24:	687b      	ldr	r3, [r7, #4]
341a2c26:	22cc      	movs	r2, #204	@ 0xcc
341a2c28:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8D8D_DTRReadCommand)     {Object->sfdp_private.DriverInfo.ReadInstruction         = 0xFDu;}
341a2c2c:	4b83      	ldr	r3, [pc, #524]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c2e:	789b      	ldrb	r3, [r3, #2]
341a2c30:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a2c34:	b2db      	uxtb	r3, r3
341a2c36:	2b00      	cmp	r3, #0
341a2c38:	d003      	beq.n	341a2c42 <SFDP_BuildGenericDriver+0x9ba>
341a2c3a:	687b      	ldr	r3, [r7, #4]
341a2c3c:	22fd      	movs	r2, #253	@ 0xfd
341a2c3e:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    Object->sfdp_private.DriverInfo.EraseType1Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType1;
341a2c42:	4b7e      	ldr	r3, [pc, #504]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c44:	791a      	ldrb	r2, [r3, #4]
341a2c46:	687b      	ldr	r3, [r7, #4]
341a2c48:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
    Object->sfdp_private.DriverInfo.EraseType2Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType2;
341a2c4c:	4b7b      	ldr	r3, [pc, #492]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c4e:	795a      	ldrb	r2, [r3, #5]
341a2c50:	687b      	ldr	r3, [r7, #4]
341a2c52:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
    Object->sfdp_private.DriverInfo.EraseType3Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType3;
341a2c56:	4b79      	ldr	r3, [pc, #484]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c58:	799a      	ldrb	r2, [r3, #6]
341a2c5a:	687b      	ldr	r3, [r7, #4]
341a2c5c:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
    Object->sfdp_private.DriverInfo.EraseType4Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType4;
341a2c60:	4b76      	ldr	r3, [pc, #472]	@ (341a2e3c <SFDP_BuildGenericDriver+0xbb4>)
341a2c62:	79da      	ldrb	r2, [r3, #7]
341a2c64:	687b      	ldr	r3, [r7, #4]
341a2c66:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e
  }

  if(((uint32_t)SFDP_PARAMID_XSPI_V1_0 == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_XSPI_V1_0))
341a2c6a:	687b      	ldr	r3, [r7, #4]
341a2c6c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a2c70:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341a2c74:	2b00      	cmp	r3, #0
341a2c76:	f000 80da 	beq.w	341a2e2e <SFDP_BuildGenericDriver+0xba6>
      &&
      ((PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink) || (PHY_LINK_8S8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)))
341a2c7a:	687b      	ldr	r3, [r7, #4]
341a2c7c:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
      &&
341a2c80:	2b09      	cmp	r3, #9
341a2c82:	d005      	beq.n	341a2c90 <SFDP_BuildGenericDriver+0xa08>
      ((PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink) || (PHY_LINK_8S8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)))
341a2c84:	687b      	ldr	r3, [r7, #4]
341a2c86:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a2c8a:	2b08      	cmp	r3, #8
341a2c8c:	f040 80cf 	bne.w	341a2e2e <SFDP_BuildGenericDriver+0xba6>
  {
    uint32_t ClockOut = 0u;
341a2c90:	2300      	movs	r3, #0
341a2c92:	60fb      	str	r3, [r7, #12]
    uint32_t MaxFreqMhz;
    /* Read command */
    if (0u != JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand)
341a2c94:	4b6a      	ldr	r3, [pc, #424]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2c96:	785b      	ldrb	r3, [r3, #1]
341a2c98:	2b00      	cmp	r3, #0
341a2c9a:	d004      	beq.n	341a2ca6 <SFDP_BuildGenericDriver+0xa1e>
    {
      Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand;
341a2c9c:	4b68      	ldr	r3, [pc, #416]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2c9e:	785a      	ldrb	r2, [r3, #1]
341a2ca0:	687b      	ldr	r3, [r7, #4]
341a2ca2:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if (JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle != 0u)
341a2ca6:	4b66      	ldr	r3, [pc, #408]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2ca8:	7d1b      	ldrb	r3, [r3, #20]
341a2caa:	f003 031f 	and.w	r3, r3, #31
341a2cae:	b2db      	uxtb	r3, r3
341a2cb0:	2b00      	cmp	r3, #0
341a2cb2:	d00d      	beq.n	341a2cd0 <SFDP_BuildGenericDriver+0xa48>
    {
      /* Set the default dummy cycle of this mode */
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle;
341a2cb4:	4b62      	ldr	r3, [pc, #392]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2cb6:	7d1b      	ldrb	r3, [r3, #20]
341a2cb8:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a2cbc:	b2db      	uxtb	r3, r3
341a2cbe:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a2cc0:	687b      	ldr	r3, [r7, #4]
341a2cc2:	3308      	adds	r3, #8
341a2cc4:	f107 0214 	add.w	r2, r7, #20
341a2cc8:	2101      	movs	r1, #1
341a2cca:	4618      	mov	r0, r3
341a2ccc:	f7fe fb80 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
    }

    /* adapt the memory interface frequency according to its capabilities */
    MaxFreqMhz = sfdp_getfrequencevalue(JEDEC_Basic.Params.Param_DWORD.D20._8D8D8D_MaximunSpeedWithStrobe);
341a2cd0:	4b5c      	ldr	r3, [pc, #368]	@ (341a2e44 <SFDP_BuildGenericDriver+0xbbc>)
341a2cd2:	f893 3053 	ldrb.w	r3, [r3, #83]	@ 0x53
341a2cd6:	f3c3 1303 	ubfx	r3, r3, #4, #4
341a2cda:	b2db      	uxtb	r3, r3
341a2cdc:	4618      	mov	r0, r3
341a2cde:	f000 f8f9 	bl	341a2ed4 <sfdp_getfrequencevalue>
341a2ce2:	61f8      	str	r0, [r7, #28]
    if (MaxFreqMhz > Object->sfdp_private.DriverInfo.ClockIn)
341a2ce4:	687b      	ldr	r3, [r7, #4]
341a2ce6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
341a2ce8:	69fa      	ldr	r2, [r7, #28]
341a2cea:	429a      	cmp	r2, r3
341a2cec:	d902      	bls.n	341a2cf4 <SFDP_BuildGenericDriver+0xa6c>
    {
      /* Adjust the frequence with the ClockIn */
      MaxFreqMhz = Object->sfdp_private.DriverInfo.ClockIn;
341a2cee:	687b      	ldr	r3, [r7, #4]
341a2cf0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
341a2cf2:	61fb      	str	r3, [r7, #28]
    }

    /* Update the clock to be aligned with selected configuration */
    if(HAL_OK != SAL_XSPI_SetClock(&Object->sfdp_private.SALObject, Object->sfdp_private.DriverInfo.ClockIn, MaxFreqMhz, &ClockOut))
341a2cf4:	687b      	ldr	r3, [r7, #4]
341a2cf6:	f103 0008 	add.w	r0, r3, #8
341a2cfa:	687b      	ldr	r3, [r7, #4]
341a2cfc:	6e99      	ldr	r1, [r3, #104]	@ 0x68
341a2cfe:	f107 030c 	add.w	r3, r7, #12
341a2d02:	69fa      	ldr	r2, [r7, #28]
341a2d04:	f7fe faf1 	bl	341a12ea <SAL_XSPI_SetClock>
341a2d08:	4603      	mov	r3, r0
341a2d0a:	2b00      	cmp	r3, #0
341a2d0c:	d003      	beq.n	341a2d16 <SFDP_BuildGenericDriver+0xa8e>
    {
      retr = EXTMEM_SFDP_ERROR_SETCLOCK;
341a2d0e:	230d      	movs	r3, #13
341a2d10:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a2d14:	e08c      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
    }
    *FreqUpdated = 1u; /* Used to indicate that the clock configuration has been updated */
341a2d16:	683b      	ldr	r3, [r7, #0]
341a2d18:	2201      	movs	r2, #1
341a2d1a:	701a      	strb	r2, [r3, #0]

    /* get the dummy cycle value according to the real output clock */
    if ((ClockOut >= CLOCK_200MHZ) && (JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle != 0u))
341a2d1c:	68fb      	ldr	r3, [r7, #12]
341a2d1e:	4a4a      	ldr	r2, [pc, #296]	@ (341a2e48 <SFDP_BuildGenericDriver+0xbc0>)
341a2d20:	4293      	cmp	r3, r2
341a2d22:	d913      	bls.n	341a2d4c <SFDP_BuildGenericDriver+0xac4>
341a2d24:	4b46      	ldr	r3, [pc, #280]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d26:	899b      	ldrh	r3, [r3, #12]
341a2d28:	f403 6378 	and.w	r3, r3, #3968	@ 0xf80
341a2d2c:	b29b      	uxth	r3, r3
341a2d2e:	2b00      	cmp	r3, #0
341a2d30:	d00c      	beq.n	341a2d4c <SFDP_BuildGenericDriver+0xac4>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle;
341a2d32:	4b43      	ldr	r3, [pc, #268]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d34:	899b      	ldrh	r3, [r3, #12]
341a2d36:	f3c3 13c4 	ubfx	r3, r3, #7, #5
341a2d3a:	b2db      	uxtb	r3, r3
341a2d3c:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_ConfigPattern;
341a2d3e:	4b40      	ldr	r3, [pc, #256]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d40:	7b1b      	ldrb	r3, [r3, #12]
341a2d42:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a2d46:	b2db      	uxtb	r3, r3
341a2d48:	623b      	str	r3, [r7, #32]
341a2d4a:	e03b      	b.n	341a2dc4 <SFDP_BuildGenericDriver+0xb3c>
    }
    else if ((ClockOut >= CLOCK_166MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle != 0u))
341a2d4c:	68fb      	ldr	r3, [r7, #12]
341a2d4e:	4a3f      	ldr	r2, [pc, #252]	@ (341a2e4c <SFDP_BuildGenericDriver+0xbc4>)
341a2d50:	4293      	cmp	r3, r2
341a2d52:	d913      	bls.n	341a2d7c <SFDP_BuildGenericDriver+0xaf4>
341a2d54:	4b3a      	ldr	r3, [pc, #232]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d56:	7cdb      	ldrb	r3, [r3, #19]
341a2d58:	f023 0307 	bic.w	r3, r3, #7
341a2d5c:	b2db      	uxtb	r3, r3
341a2d5e:	2b00      	cmp	r3, #0
341a2d60:	d00c      	beq.n	341a2d7c <SFDP_BuildGenericDriver+0xaf4>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle;
341a2d62:	4b37      	ldr	r3, [pc, #220]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d64:	7cdb      	ldrb	r3, [r3, #19]
341a2d66:	f3c3 03c4 	ubfx	r3, r3, #3, #5
341a2d6a:	b2db      	uxtb	r3, r3
341a2d6c:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_ConfigPattern;
341a2d6e:	4b34      	ldr	r3, [pc, #208]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d70:	8a5b      	ldrh	r3, [r3, #18]
341a2d72:	f3c3 1384 	ubfx	r3, r3, #6, #5
341a2d76:	b2db      	uxtb	r3, r3
341a2d78:	623b      	str	r3, [r7, #32]
341a2d7a:	e023      	b.n	341a2dc4 <SFDP_BuildGenericDriver+0xb3c>
    }
    else if ((ClockOut >= CLOCK_133MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle != 0u))
341a2d7c:	68fb      	ldr	r3, [r7, #12]
341a2d7e:	4a34      	ldr	r2, [pc, #208]	@ (341a2e50 <SFDP_BuildGenericDriver+0xbc8>)
341a2d80:	4293      	cmp	r3, r2
341a2d82:	d913      	bls.n	341a2dac <SFDP_BuildGenericDriver+0xb24>
341a2d84:	4b2e      	ldr	r3, [pc, #184]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d86:	7c9b      	ldrb	r3, [r3, #18]
341a2d88:	f003 033e 	and.w	r3, r3, #62	@ 0x3e
341a2d8c:	b2db      	uxtb	r3, r3
341a2d8e:	2b00      	cmp	r3, #0
341a2d90:	d00c      	beq.n	341a2dac <SFDP_BuildGenericDriver+0xb24>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle;
341a2d92:	4b2b      	ldr	r3, [pc, #172]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2d94:	7c9b      	ldrb	r3, [r3, #18]
341a2d96:	f3c3 0344 	ubfx	r3, r3, #1, #5
341a2d9a:	b2db      	uxtb	r3, r3
341a2d9c:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_ConfigPattern;
341a2d9e:	4b28      	ldr	r3, [pc, #160]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2da0:	691b      	ldr	r3, [r3, #16]
341a2da2:	f3c3 3304 	ubfx	r3, r3, #12, #5
341a2da6:	b2db      	uxtb	r3, r3
341a2da8:	623b      	str	r3, [r7, #32]
341a2daa:	e00b      	b.n	341a2dc4 <SFDP_BuildGenericDriver+0xb3c>
    }
    else /* if (ClockOut =< 100Mhz) */
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_DummyCycle;
341a2dac:	4b24      	ldr	r3, [pc, #144]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2dae:	8a1b      	ldrh	r3, [r3, #16]
341a2db0:	f3c3 13c4 	ubfx	r3, r3, #7, #5
341a2db4:	b2db      	uxtb	r3, r3
341a2db6:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_ConfigPattern;
341a2db8:	4b21      	ldr	r3, [pc, #132]	@ (341a2e40 <SFDP_BuildGenericDriver+0xbb8>)
341a2dba:	7c1b      	ldrb	r3, [r3, #16]
341a2dbc:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a2dc0:	b2db      	uxtb	r3, r3
341a2dc2:	623b      	str	r3, [r7, #32]
    }

    /* Specific case of GigaDevice memory with wrongly coded SFDP table in JEDEC_SCCR_Map.Param_DWORD.D9 */
    if (Object->sfdp_private.ManuID == EXTMEM_MANFACTURER_GIGADEVICE)
341a2dc4:	687b      	ldr	r3, [r7, #4]
341a2dc6:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a2dca:	2bc8      	cmp	r3, #200	@ 0xc8
341a2dcc:	d10a      	bne.n	341a2de4 <SFDP_BuildGenericDriver+0xb5c>
    {
      dummyCycles = 16;
341a2dce:	2310      	movs	r3, #16
341a2dd0:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a2dd2:	687b      	ldr	r3, [r7, #4]
341a2dd4:	3308      	adds	r3, #8
341a2dd6:	f107 0214 	add.w	r2, r7, #20
341a2dda:	2101      	movs	r1, #1
341a2ddc:	4618      	mov	r0, r3
341a2dde:	f7fe faf7 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
341a2de2:	e025      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
    }
    else
    {
      /* Write the dummy cycle value in the configuration register using information coming from SCCR Map */
      if((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
341a2de4:	687b      	ldr	r3, [r7, #4]
341a2de6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a2dea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341a2dee:	2b00      	cmp	r3, #0
341a2df0:	d017      	beq.n	341a2e22 <SFDP_BuildGenericDriver+0xb9a>
         && (0u != JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable))
341a2df2:	4b18      	ldr	r3, [pc, #96]	@ (341a2e54 <SFDP_BuildGenericDriver+0xbcc>)
341a2df4:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a2df8:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a2dfc:	b2db      	uxtb	r3, r3
341a2dfe:	2b00      	cmp	r3, #0
341a2e00:	d00f      	beq.n	341a2e22 <SFDP_BuildGenericDriver+0xb9a>
      {
        /* Update the frequence with MaxFreqMhz information */
        if( sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
341a2e02:	6a39      	ldr	r1, [r7, #32]
341a2e04:	6878      	ldr	r0, [r7, #4]
341a2e06:	f000 fa6b 	bl	341a32e0 <sfdp_set_dummycycle>
341a2e0a:	4603      	mov	r3, r0
341a2e0c:	2b00      	cmp	r3, #0
341a2e0e:	d10f      	bne.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        {
          /* Set the dummy cycle corresponding */
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a2e10:	687b      	ldr	r3, [r7, #4]
341a2e12:	3308      	adds	r3, #8
341a2e14:	f107 0214 	add.w	r2, r7, #20
341a2e18:	2101      	movs	r1, #1
341a2e1a:	4618      	mov	r0, r3
341a2e1c:	f7fe fad8 	bl	341a13d0 <SAL_XSPI_MemoryConfig>
        if( sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
341a2e20:	e006      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
        }
      }
      else
      {
        retr = EXTMEM_SFDP_ERROR_CONFIGDUMMY;
341a2e22:	230e      	movs	r3, #14
341a2e24:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a2e28:	e002      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
          goto error;
341a2e2a:	bf00      	nop
341a2e2c:	e000      	b.n	341a2e30 <SFDP_BuildGenericDriver+0xba8>
      }
    }
  }

error :
341a2e2e:	bf00      	nop
  return retr;
341a2e30:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
341a2e34:	4618      	mov	r0, r3
341a2e36:	372c      	adds	r7, #44	@ 0x2c
341a2e38:	46bd      	mov	sp, r7
341a2e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a2e3c:	341c1c5c 	.word	0x341c1c5c
341a2e40:	341c1c64 	.word	0x341c1c64
341a2e44:	341c1bfc 	.word	0x341c1bfc
341a2e48:	0bebc1ff 	.word	0x0bebc1ff
341a2e4c:	09e4f57f 	.word	0x09e4f57f
341a2e50:	07ed6b3f 	.word	0x07ed6b3f
341a2e54:	341c1c7c 	.word	0x341c1c7c

341a2e58 <driver_check_FlagBUSY>:


EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef driver_check_FlagBUSY(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject, uint32_t Timeout)
{
341a2e58:	b5f0      	push	{r4, r5, r6, r7, lr}
341a2e5a:	b089      	sub	sp, #36	@ 0x24
341a2e5c:	af04      	add	r7, sp, #16
341a2e5e:	6078      	str	r0, [r7, #4]
341a2e60:	6039      	str	r1, [r7, #0]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUSY;
341a2e62:	23fb      	movs	r3, #251	@ 0xfb
341a2e64:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR((uint8_t *)__func__)
  if (0u != SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand)
341a2e66:	687b      	ldr	r3, [r7, #4]
341a2e68:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
341a2e6c:	2b00      	cmp	r3, #0
341a2e6e:	d02b      	beq.n	341a2ec8 <driver_check_FlagBUSY+0x70>
  {
    /* check that the WIP flag is not set */
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a2e70:	687b      	ldr	r3, [r7, #4]
341a2e72:	f103 0008 	add.w	r0, r3, #8
341a2e76:	687b      	ldr	r3, [r7, #4]
341a2e78:	f893 406c 	ldrb.w	r4, [r3, #108]	@ 0x6c
                                               SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand,
                                               SFDPObject->sfdp_private.DriverInfo.WIPAddress,
341a2e7c:	687b      	ldr	r3, [r7, #4]
341a2e7e:	f893 306f 	ldrb.w	r3, [r3, #111]	@ 0x6f
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a2e82:	461e      	mov	r6, r3
                                               SFDPObject->sfdp_private.DriverInfo.WIPBusyPolarity << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
341a2e84:	687b      	ldr	r3, [r7, #4]
341a2e86:	f893 306e 	ldrb.w	r3, [r3, #110]	@ 0x6e
341a2e8a:	461a      	mov	r2, r3
341a2e8c:	687b      	ldr	r3, [r7, #4]
341a2e8e:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
341a2e92:	fa02 f303 	lsl.w	r3, r2, r3
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a2e96:	b2dd      	uxtb	r5, r3
                                               1u << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
341a2e98:	687b      	ldr	r3, [r7, #4]
341a2e9a:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
341a2e9e:	461a      	mov	r2, r3
341a2ea0:	2301      	movs	r3, #1
341a2ea2:	4093      	lsls	r3, r2
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a2ea4:	b2db      	uxtb	r3, r3
341a2ea6:	687a      	ldr	r2, [r7, #4]
341a2ea8:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a2eac:	6839      	ldr	r1, [r7, #0]
341a2eae:	9102      	str	r1, [sp, #8]
341a2eb0:	9201      	str	r2, [sp, #4]
341a2eb2:	9300      	str	r3, [sp, #0]
341a2eb4:	462b      	mov	r3, r5
341a2eb6:	4632      	mov	r2, r6
341a2eb8:	4621      	mov	r1, r4
341a2eba:	f7fe fe73 	bl	341a1ba4 <SAL_XSPI_CheckStatusRegister>
341a2ebe:	4603      	mov	r3, r0
341a2ec0:	2b00      	cmp	r3, #0
341a2ec2:	d101      	bne.n	341a2ec8 <driver_check_FlagBUSY+0x70>
                                               SFDPObject->sfdp_private.ManuID, Timeout))
    {
      retr = EXTMEM_DRIVER_NOR_SFDP_OK;
341a2ec4:	2300      	movs	r3, #0
341a2ec6:	73fb      	strb	r3, [r7, #15]
    }
  }
  return retr;
341a2ec8:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a2ecc:	4618      	mov	r0, r3
341a2ece:	3714      	adds	r7, #20
341a2ed0:	46bd      	mov	sp, r7
341a2ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}

341a2ed4 <sfdp_getfrequencevalue>:
 * @brief This function returns the frequency value corresponding to a frequency
 * @param BitField bit field value
 * @return frequency value
 */
uint32_t sfdp_getfrequencevalue(uint32_t BitField)
{
341a2ed4:	b4b0      	push	{r4, r5, r7}
341a2ed6:	b08b      	sub	sp, #44	@ 0x2c
341a2ed8:	af00      	add	r7, sp, #0
341a2eda:	6078      	str	r0, [r7, #4]
  const uint16_t freqMhz_table[] = { 0x0, 33, 50, 66, 80, 100, 133, 166, 200, 250, 266, 333, 400 };
341a2edc:	4b0e      	ldr	r3, [pc, #56]	@ (341a2f18 <sfdp_getfrequencevalue+0x44>)
341a2ede:	f107 040c 	add.w	r4, r7, #12
341a2ee2:	461d      	mov	r5, r3
341a2ee4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a2ee6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a2ee8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
341a2eec:	c403      	stmia	r4!, {r0, r1}
341a2eee:	8022      	strh	r2, [r4, #0]
  SFDP_DEBUG_STR(__func__);

  if (BitField < 0b1010u)
341a2ef0:	687b      	ldr	r3, [r7, #4]
341a2ef2:	2b09      	cmp	r3, #9
341a2ef4:	d80a      	bhi.n	341a2f0c <sfdp_getfrequencevalue+0x38>
  {
    return (uint32_t)freqMhz_table[BitField]* 1000000u;
341a2ef6:	687b      	ldr	r3, [r7, #4]
341a2ef8:	005b      	lsls	r3, r3, #1
341a2efa:	3328      	adds	r3, #40	@ 0x28
341a2efc:	443b      	add	r3, r7
341a2efe:	f833 3c1c 	ldrh.w	r3, [r3, #-28]
341a2f02:	461a      	mov	r2, r3
341a2f04:	4b05      	ldr	r3, [pc, #20]	@ (341a2f1c <sfdp_getfrequencevalue+0x48>)
341a2f06:	fb02 f303 	mul.w	r3, r2, r3
341a2f0a:	e000      	b.n	341a2f0e <sfdp_getfrequencevalue+0x3a>
  }
  return 0; /* the max frequency is unknown */
341a2f0c:	2300      	movs	r3, #0
}
341a2f0e:	4618      	mov	r0, r3
341a2f10:	372c      	adds	r7, #44	@ 0x2c
341a2f12:	46bd      	mov	sp, r7
341a2f14:	bcb0      	pop	{r4, r5, r7}
341a2f16:	4770      	bx	lr
341a2f18:	341a66f0 	.word	0x341a66f0
341a2f1c:	000f4240 	.word	0x000f4240

341a2f20 <sfdp_get_paraminfo>:
 * @param sfdp_param_info pointer on parameter info
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_get_paraminfo(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t sfdp_address,
                                      SFDP_ParameterTableTypeDef *Param_info)
{
341a2f20:	b580      	push	{r7, lr}
341a2f22:	b088      	sub	sp, #32
341a2f24:	af00      	add	r7, sp, #0
341a2f26:	60f8      	str	r0, [r7, #12]
341a2f28:	60b9      	str	r1, [r7, #8]
341a2f2a:	607a      	str	r2, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a2f2c:	2300      	movs	r3, #0
341a2f2e:	77fb      	strb	r3, [r7, #31]
  SFDP_ParameterHeaderTypeDef sfdp_param_header = {0};
341a2f30:	f107 0314 	add.w	r3, r7, #20
341a2f34:	2200      	movs	r2, #0
341a2f36:	601a      	str	r2, [r3, #0]
341a2f38:	605a      	str	r2, [r3, #4]
  SFDP_DEBUG_STR(__func__);

  /* send the SFDP command to read the header */
  if(HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, sfdp_address,
341a2f3a:	68fb      	ldr	r3, [r7, #12]
341a2f3c:	f103 0008 	add.w	r0, r3, #8
341a2f40:	f107 0214 	add.w	r2, r7, #20
341a2f44:	2308      	movs	r3, #8
341a2f46:	68b9      	ldr	r1, [r7, #8]
341a2f48:	f7fe fb94 	bl	341a1674 <SAL_XSPI_GetSFDP>
341a2f4c:	4603      	mov	r3, r0
341a2f4e:	2b00      	cmp	r3, #0
341a2f50:	d002      	beq.n	341a2f58 <sfdp_get_paraminfo+0x38>
                                (uint8_t*)&sfdp_param_header, SFDP_PARAM_HEADER_SIZE))
  {
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a2f52:	2303      	movs	r3, #3
341a2f54:	77fb      	strb	r3, [r7, #31]
    goto error;
341a2f56:	e0d9      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
  }

  Param_info->type = SFDP_PARAMID_UNKNOWN;
341a2f58:	687b      	ldr	r3, [r7, #4]
341a2f5a:	2200      	movs	r2, #0
341a2f5c:	601a      	str	r2, [r3, #0]
  Param_info->size = sfdp_param_header.Length ;
341a2f5e:	7dfa      	ldrb	r2, [r7, #23]
341a2f60:	687b      	ldr	r3, [r7, #4]
341a2f62:	721a      	strb	r2, [r3, #8]
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
341a2f64:	7ebb      	ldrb	r3, [r7, #26]
341a2f66:	041a      	lsls	r2, r3, #16
                        |((uint32_t)sfdp_param_header.TableAddressPointer[1u] << 8u)
341a2f68:	7e7b      	ldrb	r3, [r7, #25]
341a2f6a:	021b      	lsls	r3, r3, #8
341a2f6c:	4313      	orrs	r3, r2
                        |((uint32_t)sfdp_param_header.TableAddressPointer[0u]));
341a2f6e:	7e3a      	ldrb	r2, [r7, #24]
341a2f70:	431a      	orrs	r2, r3
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
341a2f72:	687b      	ldr	r3, [r7, #4]
341a2f74:	605a      	str	r2, [r3, #4]

  if ((sfdp_param_header.ID_msb > 0x00u) && (sfdp_param_header.ID_msb < 0x80u))
341a2f76:	7efb      	ldrb	r3, [r7, #27]
341a2f78:	2b00      	cmp	r3, #0
341a2f7a:	d010      	beq.n	341a2f9e <sfdp_get_paraminfo+0x7e>
341a2f7c:	7efb      	ldrb	r3, [r7, #27]
341a2f7e:	b25b      	sxtb	r3, r3
341a2f80:	2b00      	cmp	r3, #0
341a2f82:	db0c      	blt.n	341a2f9e <sfdp_get_paraminfo+0x7e>
  {
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a2f84:	7d3b      	ldrb	r3, [r7, #20]
341a2f86:	f003 0301 	and.w	r3, r3, #1
341a2f8a:	2b00      	cmp	r3, #0
341a2f8c:	d003      	beq.n	341a2f96 <sfdp_get_paraminfo+0x76>
    {
      Param_info->type = SFDP_PARAMID_VENDOR;
341a2f8e:	687b      	ldr	r3, [r7, #4]
341a2f90:	2201      	movs	r2, #1
341a2f92:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a2f94:	e0ba      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_VENDOR");
    }
    else
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_VENDOR;
341a2f96:	687b      	ldr	r3, [r7, #4]
341a2f98:	2202      	movs	r2, #2
341a2f9a:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a2f9c:	e0b6      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_VENDOR");
    }
  }
  else if (sfdp_param_header.ID_msb >= 0x80u)
341a2f9e:	7efb      	ldrb	r3, [r7, #27]
341a2fa0:	b25b      	sxtb	r3, r3
341a2fa2:	2b00      	cmp	r3, #0
341a2fa4:	f280 80ae 	bge.w	341a3104 <sfdp_get_paraminfo+0x1e4>
  {
    if((sfdp_param_header.ID_lsb & 0x01u) == 0x00u)
341a2fa8:	7d3b      	ldrb	r3, [r7, #20]
341a2faa:	f003 0301 	and.w	r3, r3, #1
341a2fae:	2b00      	cmp	r3, #0
341a2fb0:	d102      	bne.n	341a2fb8 <sfdp_get_paraminfo+0x98>
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_JEDEC;
341a2fb2:	687b      	ldr	r3, [r7, #4]
341a2fb4:	2204      	movs	r2, #4
341a2fb6:	601a      	str	r2, [r3, #0]
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_JEDEC");
    }

    if (sfdp_param_header.ID_msb == SFDP_BASIC_PARAMETER_TABLE_MSB)
341a2fb8:	7efb      	ldrb	r3, [r7, #27]
341a2fba:	2bff      	cmp	r3, #255	@ 0xff
341a2fbc:	f040 80a6 	bne.w	341a310c <sfdp_get_paraminfo+0x1ec>
    {
      switch(sfdp_param_header.ID_lsb)
341a2fc0:	7d3b      	ldrb	r3, [r7, #20]
341a2fc2:	2b0f      	cmp	r3, #15
341a2fc4:	dc4c      	bgt.n	341a3060 <sfdp_get_paraminfo+0x140>
341a2fc6:	2b00      	cmp	r3, #0
341a2fc8:	da24      	bge.n	341a3014 <sfdp_get_paraminfo+0xf4>
        Param_info->type = SFDP_PARAMID_RESERVED;
        SFDP_DEBUG_STR("-> info SFDP_PARAMID_RESERVED");
        break;
      default :
        SFDP_DEBUG_STR("-> info SFDP_PARAMID_????");
        break;
341a2fca:	e09e      	b.n	341a310a <sfdp_get_paraminfo+0x1ea>
      switch(sfdp_param_header.ID_lsb)
341a2fcc:	3b81      	subs	r3, #129	@ 0x81
341a2fce:	2b0d      	cmp	r3, #13
341a2fd0:	f200 809b 	bhi.w	341a310a <sfdp_get_paraminfo+0x1ea>
341a2fd4:	a201      	add	r2, pc, #4	@ (adr r2, 341a2fdc <sfdp_get_paraminfo+0xbc>)
341a2fd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a2fda:	bf00      	nop
341a2fdc:	341a3081 	.word	0x341a3081
341a2fe0:	341a310b 	.word	0x341a310b
341a2fe4:	341a310b 	.word	0x341a310b
341a2fe8:	341a3091 	.word	0x341a3091
341a2fec:	341a310b 	.word	0x341a310b
341a2ff0:	341a310b 	.word	0x341a310b
341a2ff4:	341a30ab 	.word	0x341a30ab
341a2ff8:	341a30b5 	.word	0x341a30b5
341a2ffc:	341a310b 	.word	0x341a310b
341a3000:	341a310b 	.word	0x341a310b
341a3004:	341a30d3 	.word	0x341a30d3
341a3008:	341a310b 	.word	0x341a310b
341a300c:	341a30e7 	.word	0x341a30e7
341a3010:	341a30f1 	.word	0x341a30f1
341a3014:	2b0f      	cmp	r3, #15
341a3016:	d878      	bhi.n	341a310a <sfdp_get_paraminfo+0x1ea>
341a3018:	a201      	add	r2, pc, #4	@ (adr r2, 341a3020 <sfdp_get_paraminfo+0x100>)
341a301a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a301e:	bf00      	nop
341a3020:	341a306b 	.word	0x341a306b
341a3024:	341a310b 	.word	0x341a310b
341a3028:	341a310b 	.word	0x341a310b
341a302c:	341a3089 	.word	0x341a3089
341a3030:	341a310b 	.word	0x341a310b
341a3034:	341a3099 	.word	0x341a3099
341a3038:	341a30a1 	.word	0x341a30a1
341a303c:	341a310b 	.word	0x341a310b
341a3040:	341a310b 	.word	0x341a310b
341a3044:	341a30bf 	.word	0x341a30bf
341a3048:	341a30c9 	.word	0x341a30c9
341a304c:	341a310b 	.word	0x341a310b
341a3050:	341a30dd 	.word	0x341a30dd
341a3054:	341a310b 	.word	0x341a310b
341a3058:	341a310b 	.word	0x341a310b
341a305c:	341a30fb 	.word	0x341a30fb
341a3060:	2b8e      	cmp	r3, #142	@ 0x8e
341a3062:	dc52      	bgt.n	341a310a <sfdp_get_paraminfo+0x1ea>
341a3064:	2b81      	cmp	r3, #129	@ 0x81
341a3066:	dab1      	bge.n	341a2fcc <sfdp_get_paraminfo+0xac>
        break;
341a3068:	e04f      	b.n	341a310a <sfdp_get_paraminfo+0x1ea>
        Param_info->type = SFDP_PARAMID_BASIC_SPIPROTOCOL;
341a306a:	687b      	ldr	r3, [r7, #4]
341a306c:	2208      	movs	r2, #8
341a306e:	601a      	str	r2, [r3, #0]
        Param_info->size = ((sfdp_param_header.Length ) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
341a3070:	7dfb      	ldrb	r3, [r7, #23]
                             ? sfdp_param_header.Length : SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE;
341a3072:	2b17      	cmp	r3, #23
341a3074:	bf28      	it	cs
341a3076:	2317      	movcs	r3, #23
341a3078:	b2da      	uxtb	r2, r3
        Param_info->size = ((sfdp_param_header.Length ) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
341a307a:	687b      	ldr	r3, [r7, #4]
341a307c:	721a      	strb	r2, [r3, #8]
        break;
341a307e:	e045      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_SECTORMAP;
341a3080:	687b      	ldr	r3, [r7, #4]
341a3082:	2210      	movs	r2, #16
341a3084:	601a      	str	r2, [r3, #0]
        break;
341a3086:	e041      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_RPMC;
341a3088:	687b      	ldr	r3, [r7, #4]
341a308a:	2220      	movs	r2, #32
341a308c:	601a      	str	r2, [r3, #0]
        break;
341a308e:	e03d      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION;
341a3090:	687b      	ldr	r3, [r7, #4]
341a3092:	2240      	movs	r2, #64	@ 0x40
341a3094:	601a      	str	r2, [r3, #0]
        break;
341a3096:	e039      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_XSPI_V1_0;
341a3098:	687b      	ldr	r3, [r7, #4]
341a309a:	2280      	movs	r2, #128	@ 0x80
341a309c:	601a      	str	r2, [r3, #0]
        break;
341a309e:	e035      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_XSPI_V2_0;
341a30a0:	687b      	ldr	r3, [r7, #4]
341a30a2:	f44f 7280 	mov.w	r2, #256	@ 0x100
341a30a6:	601a      	str	r2, [r3, #0]
        break;
341a30a8:	e030      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP;
341a30aa:	687b      	ldr	r3, [r7, #4]
341a30ac:	f44f 7200 	mov.w	r2, #512	@ 0x200
341a30b0:	601a      	str	r2, [r3, #0]
        break;
341a30b2:	e02b      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP_MULTICHIP;
341a30b4:	687b      	ldr	r3, [r7, #4]
341a30b6:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341a30ba:	601a      	str	r2, [r3, #0]
        break;
341a30bc:	e026      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_XSPI_V2_0;
341a30be:	687b      	ldr	r3, [r7, #4]
341a30c0:	f44f 6200 	mov.w	r2, #2048	@ 0x800
341a30c4:	601a      	str	r2, [r3, #0]
        break;
341a30c6:	e021      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_OCTAL_DDR;
341a30c8:	687b      	ldr	r3, [r7, #4]
341a30ca:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
341a30ce:	601a      	str	r2, [r3, #0]
        break;
341a30d0:	e01c      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_MSPT;
341a30d2:	687b      	ldr	r3, [r7, #4]
341a30d4:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
341a30d8:	601a      	str	r2, [r3, #0]
        break;
341a30da:	e017      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_X4QUAD_DS;
341a30dc:	687b      	ldr	r3, [r7, #4]
341a30de:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
341a30e2:	601a      	str	r2, [r3, #0]
        break;
341a30e4:	e012      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_QUAD_DDR;
341a30e6:	687b      	ldr	r3, [r7, #4]
341a30e8:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341a30ec:	601a      	str	r2, [r3, #0]
        break;
341a30ee:	e00d      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_SECURE_PACKET_READ_WRITE;
341a30f0:	687b      	ldr	r3, [r7, #4]
341a30f2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341a30f6:	601a      	str	r2, [r3, #0]
        break;
341a30f8:	e008      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_RESERVED;
341a30fa:	687b      	ldr	r3, [r7, #4]
341a30fc:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
341a3100:	601a      	str	r2, [r3, #0]
        break;
341a3102:	e003      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
  }
  else
  {
    /* Unexpected value for MSB field of SFDP Parameter ID */
    SFDP_DEBUG_STR("-> Unexpected value for MSB field of SFDP Parameter ID");
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a3104:	2303      	movs	r3, #3
341a3106:	77fb      	strb	r3, [r7, #31]
    goto error;
341a3108:	e000      	b.n	341a310c <sfdp_get_paraminfo+0x1ec>
        break;
341a310a:	bf00      	nop
  }

error:
  return retr;
341a310c:	7ffb      	ldrb	r3, [r7, #31]
}
341a310e:	4618      	mov	r0, r3
341a3110:	3720      	adds	r7, #32
341a3112:	46bd      	mov	sp, r7
341a3114:	bd80      	pop	{r7, pc}
341a3116:	bf00      	nop

341a3118 <sfdp_enter_octal_mode>:
 * @brief This function executes the octal DDR table to enter octal DDR mode
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_enter_octal_mode(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a3118:	b590      	push	{r4, r7, lr}
341a311a:	b085      	sub	sp, #20
341a311c:	af00      	add	r7, sp, #0
341a311e:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a3120:	2300      	movs	r3, #0
341a3122:	73fb      	strb	r3, [r7, #15]
  uint8_t data[7];
  SFDP_DEBUG_STR(__func__);
  /* D1-D2 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand)
341a3124:	4b6d      	ldr	r3, [pc, #436]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3126:	78db      	ldrb	r3, [r3, #3]
341a3128:	2b00      	cmp	r3, #0
341a312a:	d028      	beq.n	341a317e <sfdp_enter_octal_mode+0x66>
  {
    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte1CommandSequence;
341a312c:	4b6b      	ldr	r3, [pc, #428]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a312e:	789b      	ldrb	r3, [r3, #2]
341a3130:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte2CommandSequence;
341a3132:	4b6a      	ldr	r3, [pc, #424]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3134:	785b      	ldrb	r3, [r3, #1]
341a3136:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte3CommandSequence;
341a3138:	4b68      	ldr	r3, [pc, #416]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a313a:	781b      	ldrb	r3, [r3, #0]
341a313c:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte4CommandSequence;
341a313e:	4b67      	ldr	r3, [pc, #412]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3140:	79db      	ldrb	r3, [r3, #7]
341a3142:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte5CommandSequence;
341a3144:	4b65      	ldr	r3, [pc, #404]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3146:	799b      	ldrb	r3, [r3, #6]
341a3148:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte6CommandSequence;
341a314a:	4b64      	ldr	r3, [pc, #400]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a314c:	795b      	ldrb	r3, [r3, #5]
341a314e:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte7CommandSequence;
341a3150:	4b62      	ldr	r3, [pc, #392]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3152:	791b      	ldrb	r3, [r3, #4]
341a3154:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a3156:	687b      	ldr	r3, [r7, #4]
341a3158:	f103 0008 	add.w	r0, r3, #8
341a315c:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand - 1u)))
341a315e:	4b5f      	ldr	r3, [pc, #380]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3160:	78db      	ldrb	r3, [r3, #3]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a3162:	3b01      	subs	r3, #1
341a3164:	b29c      	uxth	r4, r3
341a3166:	f107 0308 	add.w	r3, r7, #8
341a316a:	1c5a      	adds	r2, r3, #1
341a316c:	4623      	mov	r3, r4
341a316e:	f7fe fc0c 	bl	341a198a <SAL_XSPI_CommandSendData>
341a3172:	4603      	mov	r3, r0
341a3174:	2b00      	cmp	r3, #0
341a3176:	d002      	beq.n	341a317e <sfdp_enter_octal_mode+0x66>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a3178:	230b      	movs	r3, #11
341a317a:	73fb      	strb	r3, [r7, #15]
      goto error;
341a317c:	e0a9      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D3-D4 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand)
341a317e:	4b57      	ldr	r3, [pc, #348]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3180:	7adb      	ldrb	r3, [r3, #11]
341a3182:	2b00      	cmp	r3, #0
341a3184:	d032      	beq.n	341a31ec <sfdp_enter_octal_mode+0xd4>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a3186:	2164      	movs	r1, #100	@ 0x64
341a3188:	6878      	ldr	r0, [r7, #4]
341a318a:	f7ff fe65 	bl	341a2e58 <driver_check_FlagBUSY>
341a318e:	4603      	mov	r3, r0
341a3190:	2b00      	cmp	r3, #0
341a3192:	d002      	beq.n	341a319a <sfdp_enter_octal_mode+0x82>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3194:	230c      	movs	r3, #12
341a3196:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3198:	e09b      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte1CommandSequence;
341a319a:	4b50      	ldr	r3, [pc, #320]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a319c:	7a9b      	ldrb	r3, [r3, #10]
341a319e:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte2CommandSequence;
341a31a0:	4b4e      	ldr	r3, [pc, #312]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31a2:	7a5b      	ldrb	r3, [r3, #9]
341a31a4:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte3CommandSequence;
341a31a6:	4b4d      	ldr	r3, [pc, #308]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31a8:	7a1b      	ldrb	r3, [r3, #8]
341a31aa:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte4CommandSequence;
341a31ac:	4b4b      	ldr	r3, [pc, #300]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31ae:	7bdb      	ldrb	r3, [r3, #15]
341a31b0:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte5CommandSequence;
341a31b2:	4b4a      	ldr	r3, [pc, #296]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31b4:	7b9b      	ldrb	r3, [r3, #14]
341a31b6:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte6CommandSequence;
341a31b8:	4b48      	ldr	r3, [pc, #288]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31ba:	7b5b      	ldrb	r3, [r3, #13]
341a31bc:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte7CommandSequence;
341a31be:	4b47      	ldr	r3, [pc, #284]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31c0:	7b1b      	ldrb	r3, [r3, #12]
341a31c2:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a31c4:	687b      	ldr	r3, [r7, #4]
341a31c6:	f103 0008 	add.w	r0, r3, #8
341a31ca:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand - 1u)))
341a31cc:	4b43      	ldr	r3, [pc, #268]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31ce:	7adb      	ldrb	r3, [r3, #11]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a31d0:	3b01      	subs	r3, #1
341a31d2:	b29c      	uxth	r4, r3
341a31d4:	f107 0308 	add.w	r3, r7, #8
341a31d8:	1c5a      	adds	r2, r3, #1
341a31da:	4623      	mov	r3, r4
341a31dc:	f7fe fbd5 	bl	341a198a <SAL_XSPI_CommandSendData>
341a31e0:	4603      	mov	r3, r0
341a31e2:	2b00      	cmp	r3, #0
341a31e4:	d002      	beq.n	341a31ec <sfdp_enter_octal_mode+0xd4>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a31e6:	230b      	movs	r3, #11
341a31e8:	73fb      	strb	r3, [r7, #15]
      goto error;
341a31ea:	e072      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D5-D6 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand)
341a31ec:	4b3b      	ldr	r3, [pc, #236]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a31ee:	7cdb      	ldrb	r3, [r3, #19]
341a31f0:	2b00      	cmp	r3, #0
341a31f2:	d032      	beq.n	341a325a <sfdp_enter_octal_mode+0x142>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a31f4:	2164      	movs	r1, #100	@ 0x64
341a31f6:	6878      	ldr	r0, [r7, #4]
341a31f8:	f7ff fe2e 	bl	341a2e58 <driver_check_FlagBUSY>
341a31fc:	4603      	mov	r3, r0
341a31fe:	2b00      	cmp	r3, #0
341a3200:	d002      	beq.n	341a3208 <sfdp_enter_octal_mode+0xf0>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3202:	230c      	movs	r3, #12
341a3204:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3206:	e064      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte1CommandSequence;
341a3208:	4b34      	ldr	r3, [pc, #208]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a320a:	7c9b      	ldrb	r3, [r3, #18]
341a320c:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte2CommandSequence;
341a320e:	4b33      	ldr	r3, [pc, #204]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3210:	7c5b      	ldrb	r3, [r3, #17]
341a3212:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte3CommandSequence;
341a3214:	4b31      	ldr	r3, [pc, #196]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3216:	7c1b      	ldrb	r3, [r3, #16]
341a3218:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte4CommandSequence;
341a321a:	4b30      	ldr	r3, [pc, #192]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a321c:	7ddb      	ldrb	r3, [r3, #23]
341a321e:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte5CommandSequence;
341a3220:	4b2e      	ldr	r3, [pc, #184]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3222:	7d9b      	ldrb	r3, [r3, #22]
341a3224:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte6CommandSequence;
341a3226:	4b2d      	ldr	r3, [pc, #180]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3228:	7d5b      	ldrb	r3, [r3, #21]
341a322a:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte7CommandSequence;
341a322c:	4b2b      	ldr	r3, [pc, #172]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a322e:	7d1b      	ldrb	r3, [r3, #20]
341a3230:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a3232:	687b      	ldr	r3, [r7, #4]
341a3234:	f103 0008 	add.w	r0, r3, #8
341a3238:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand - 1u)))
341a323a:	4b28      	ldr	r3, [pc, #160]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a323c:	7cdb      	ldrb	r3, [r3, #19]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a323e:	3b01      	subs	r3, #1
341a3240:	b29c      	uxth	r4, r3
341a3242:	f107 0308 	add.w	r3, r7, #8
341a3246:	1c5a      	adds	r2, r3, #1
341a3248:	4623      	mov	r3, r4
341a324a:	f7fe fb9e 	bl	341a198a <SAL_XSPI_CommandSendData>
341a324e:	4603      	mov	r3, r0
341a3250:	2b00      	cmp	r3, #0
341a3252:	d002      	beq.n	341a325a <sfdp_enter_octal_mode+0x142>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a3254:	230b      	movs	r3, #11
341a3256:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3258:	e03b      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D7-D8 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand)
341a325a:	4b20      	ldr	r3, [pc, #128]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a325c:	7edb      	ldrb	r3, [r3, #27]
341a325e:	2b00      	cmp	r3, #0
341a3260:	d032      	beq.n	341a32c8 <sfdp_enter_octal_mode+0x1b0>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a3262:	2164      	movs	r1, #100	@ 0x64
341a3264:	6878      	ldr	r0, [r7, #4]
341a3266:	f7ff fdf7 	bl	341a2e58 <driver_check_FlagBUSY>
341a326a:	4603      	mov	r3, r0
341a326c:	2b00      	cmp	r3, #0
341a326e:	d002      	beq.n	341a3276 <sfdp_enter_octal_mode+0x15e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3270:	230c      	movs	r3, #12
341a3272:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3274:	e02d      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte1CommandSequence;
341a3276:	4b19      	ldr	r3, [pc, #100]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3278:	7e9b      	ldrb	r3, [r3, #26]
341a327a:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte2CommandSequence;
341a327c:	4b17      	ldr	r3, [pc, #92]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a327e:	7e5b      	ldrb	r3, [r3, #25]
341a3280:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte3CommandSequence;
341a3282:	4b16      	ldr	r3, [pc, #88]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3284:	7e1b      	ldrb	r3, [r3, #24]
341a3286:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte4CommandSequence;
341a3288:	4b14      	ldr	r3, [pc, #80]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a328a:	7fdb      	ldrb	r3, [r3, #31]
341a328c:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte5CommandSequence;
341a328e:	4b13      	ldr	r3, [pc, #76]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3290:	7f9b      	ldrb	r3, [r3, #30]
341a3292:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte6CommandSequence;
341a3294:	4b11      	ldr	r3, [pc, #68]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a3296:	7f5b      	ldrb	r3, [r3, #29]
341a3298:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte7CommandSequence;
341a329a:	4b10      	ldr	r3, [pc, #64]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a329c:	7f1b      	ldrb	r3, [r3, #28]
341a329e:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a32a0:	687b      	ldr	r3, [r7, #4]
341a32a2:	f103 0008 	add.w	r0, r3, #8
341a32a6:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand - 1u)))
341a32a8:	4b0c      	ldr	r3, [pc, #48]	@ (341a32dc <sfdp_enter_octal_mode+0x1c4>)
341a32aa:	7edb      	ldrb	r3, [r3, #27]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a32ac:	3b01      	subs	r3, #1
341a32ae:	b29c      	uxth	r4, r3
341a32b0:	f107 0308 	add.w	r3, r7, #8
341a32b4:	1c5a      	adds	r2, r3, #1
341a32b6:	4623      	mov	r3, r4
341a32b8:	f7fe fb67 	bl	341a198a <SAL_XSPI_CommandSendData>
341a32bc:	4603      	mov	r3, r0
341a32be:	2b00      	cmp	r3, #0
341a32c0:	d002      	beq.n	341a32c8 <sfdp_enter_octal_mode+0x1b0>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a32c2:	230b      	movs	r3, #11
341a32c4:	73fb      	strb	r3, [r7, #15]
      goto error;
341a32c6:	e004      	b.n	341a32d2 <sfdp_enter_octal_mode+0x1ba>

    /* no more wait for busy flag clear here, as command format might have changed to Octal */
  }

  /* Abort any ongoing transfer to avoid performance issue */
  SAL_XSPI_Abort(&Object->sfdp_private.SALObject);
341a32c8:	687b      	ldr	r3, [r7, #4]
341a32ca:	3308      	adds	r3, #8
341a32cc:	4618      	mov	r0, r3
341a32ce:	f7fe fd2b 	bl	341a1d28 <SAL_XSPI_Abort>

error:
  return retr;
341a32d2:	7bfb      	ldrb	r3, [r7, #15]
}
341a32d4:	4618      	mov	r0, r3
341a32d6:	3714      	adds	r7, #20
341a32d8:	46bd      	mov	sp, r7
341a32da:	bd90      	pop	{r4, r7, pc}
341a32dc:	341c1cec 	.word	0x341c1cec

341a32e0 <sfdp_set_dummycycle>:
 * @brief This function writes the config register to set dummy cycle
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_set_dummycycle(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t DummyValue)
{
341a32e0:	b5f0      	push	{r4, r5, r6, r7, lr}
341a32e2:	b08b      	sub	sp, #44	@ 0x2c
341a32e4:	af04      	add	r7, sp, #16
341a32e6:	6078      	str	r0, [r7, #4]
341a32e8:	6039      	str	r1, [r7, #0]
const uint8_t MaskWaitStateValue[4] = { 0x3u, 0x7u, 0xFu, 0x1Fu };
341a32ea:	4b76      	ldr	r3, [pc, #472]	@ (341a34c4 <sfdp_set_dummycycle+0x1e4>)
341a32ec:	60fb      	str	r3, [r7, #12]
SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a32ee:	2300      	movs	r3, #0
341a32f0:	75fb      	strb	r3, [r7, #23]
uint8_t localValue[2] = { 0 };
341a32f2:	2300      	movs	r3, #0
341a32f4:	813b      	strh	r3, [r7, #8]
uint32_t Address;

  if((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
341a32f6:	4b74      	ldr	r3, [pc, #464]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a32f8:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a32fc:	f003 0310 	and.w	r3, r3, #16
341a3300:	b2db      	uxtb	r3, r3
341a3302:	2b00      	cmp	r3, #0
341a3304:	d10a      	bne.n	341a331c <sfdp_set_dummycycle+0x3c>
    (JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable == 1u))
341a3306:	4b70      	ldr	r3, [pc, #448]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a3308:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a330c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a3310:	b2db      	uxtb	r3, r3
  if((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
341a3312:	2b00      	cmp	r3, #0
341a3314:	d002      	beq.n	341a331c <sfdp_set_dummycycle+0x3c>
  {
    /* Not yet supported */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3316:	230c      	movs	r3, #12
341a3318:	75fb      	strb	r3, [r7, #23]
    goto error;
341a331a:	e0ce      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* Compute the Address */
  if (JEDEC_SCCR_Map.Param_DWORD.D9.LocalAddress == 1u)
341a331c:	4b6a      	ldr	r3, [pc, #424]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a331e:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a3322:	f003 0308 	and.w	r3, r3, #8
341a3326:	b2db      	uxtb	r3, r3
341a3328:	2b00      	cmp	r3, #0
341a332a:	d005      	beq.n	341a3338 <sfdp_set_dummycycle+0x58>
  {
    /* Local Address is found in Byte 1 of 32-bit address */
    Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported << 8;
341a332c:	4b66      	ldr	r3, [pc, #408]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a332e:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
341a3332:	021b      	lsls	r3, r3, #8
341a3334:	613b      	str	r3, [r7, #16]
341a3336:	e00b      	b.n	341a3350 <sfdp_set_dummycycle+0x70>
  }
  else
  {
    /* Specific case of GigaDevice GD25LX512ME where register address is wrongly coded in SFDP table */
    if (Object->sfdp_private.ManuID == 0xC8)
341a3338:	687b      	ldr	r3, [r7, #4]
341a333a:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a333e:	2bc8      	cmp	r3, #200	@ 0xc8
341a3340:	d102      	bne.n	341a3348 <sfdp_set_dummycycle+0x68>
    {
      /* Address value in datasheet : 1, address value coded in SFDP table 200 */
      Address = 1U;
341a3342:	2301      	movs	r3, #1
341a3344:	613b      	str	r3, [r7, #16]
341a3346:	e003      	b.n	341a3350 <sfdp_set_dummycycle+0x70>
    }
    else
    {
      /* Local address for Variable Dummy Cycle Settings bits is found in last byte of the address */
      Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported;
341a3348:	4b5f      	ldr	r3, [pc, #380]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a334a:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
341a334e:	613b      	str	r3, [r7, #16]
    }
  }

  /* Read the configuration */
  if (HAL_OK != SAL_XSPI_CommandSendReadAddress(&Object->sfdp_private.SALObject,
341a3350:	687b      	ldr	r3, [r7, #4]
341a3352:	f103 0008 	add.w	r0, r3, #8
341a3356:	4b5c      	ldr	r3, [pc, #368]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a3358:	f893 1021 	ldrb.w	r1, [r3, #33]	@ 0x21
341a335c:	687b      	ldr	r3, [r7, #4]
341a335e:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a3362:	f107 0208 	add.w	r2, r7, #8
341a3366:	9301      	str	r3, [sp, #4]
341a3368:	2302      	movs	r3, #2
341a336a:	9300      	str	r3, [sp, #0]
341a336c:	4613      	mov	r3, r2
341a336e:	693a      	ldr	r2, [r7, #16]
341a3370:	f7fe fbb3 	bl	341a1ada <SAL_XSPI_CommandSendReadAddress>
341a3374:	4603      	mov	r3, r0
341a3376:	2b00      	cmp	r3, #0
341a3378:	d002      	beq.n	341a3380 <sfdp_set_dummycycle+0xa0>
                                                Address,
                                                (uint8_t *)localValue,
                                                2u,
                                                Object->sfdp_private.ManuID))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a337a:	230c      	movs	r3, #12
341a337c:	75fb      	strb	r3, [r7, #23]
    goto error;
341a337e:	e09c      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* send command to write enable */
  if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
341a3380:	687b      	ldr	r3, [r7, #4]
341a3382:	f103 0008 	add.w	r0, r3, #8
341a3386:	687b      	ldr	r3, [r7, #4]
341a3388:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a338c:	2300      	movs	r3, #0
341a338e:	2200      	movs	r2, #0
341a3390:	f7fe fafb 	bl	341a198a <SAL_XSPI_CommandSendData>
341a3394:	4603      	mov	r3, r0
341a3396:	2b00      	cmp	r3, #0
341a3398:	d002      	beq.n	341a33a0 <sfdp_set_dummycycle+0xc0>
                                         Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a339a:	230c      	movs	r3, #12
341a339c:	75fb      	strb	r3, [r7, #23]
    goto error;
341a339e:	e08c      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* control the write enable */
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a33a0:	687b      	ldr	r3, [r7, #4]
341a33a2:	f103 0008 	add.w	r0, r3, #8
341a33a6:	687b      	ldr	r3, [r7, #4]
341a33a8:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                             Object->sfdp_private.DriverInfo.ReadWELCommand,
                                             Object->sfdp_private.DriverInfo.WELAddress,
341a33ac:	687b      	ldr	r3, [r7, #4]
341a33ae:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a33b2:	461e      	mov	r6, r3
                                             ((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u: 0u) << Object->sfdp_private.DriverInfo.WELPosition,
341a33b4:	687b      	ldr	r3, [r7, #4]
341a33b6:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
341a33ba:	2b00      	cmp	r3, #0
341a33bc:	d101      	bne.n	341a33c2 <sfdp_set_dummycycle+0xe2>
341a33be:	2301      	movs	r3, #1
341a33c0:	e000      	b.n	341a33c4 <sfdp_set_dummycycle+0xe4>
341a33c2:	2300      	movs	r3, #0
341a33c4:	687a      	ldr	r2, [r7, #4]
341a33c6:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
341a33ca:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a33cc:	b2dc      	uxtb	r4, r3
                                             1u << Object->sfdp_private.DriverInfo.WELPosition,
341a33ce:	687b      	ldr	r3, [r7, #4]
341a33d0:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
341a33d4:	461a      	mov	r2, r3
341a33d6:	2301      	movs	r3, #1
341a33d8:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a33da:	b2db      	uxtb	r3, r3
341a33dc:	687a      	ldr	r2, [r7, #4]
341a33de:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a33e2:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
341a33e6:	9502      	str	r5, [sp, #8]
341a33e8:	9201      	str	r2, [sp, #4]
341a33ea:	9300      	str	r3, [sp, #0]
341a33ec:	4623      	mov	r3, r4
341a33ee:	4632      	mov	r2, r6
341a33f0:	f7fe fbd8 	bl	341a1ba4 <SAL_XSPI_CheckStatusRegister>
341a33f4:	4603      	mov	r3, r0
341a33f6:	2b00      	cmp	r3, #0
341a33f8:	d002      	beq.n	341a3400 <sfdp_set_dummycycle+0x120>
                                             Object->sfdp_private.ManuID, 1000))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a33fa:	230c      	movs	r3, #12
341a33fc:	75fb      	strb	r3, [r7, #23]
    goto error;
341a33fe:	e05c      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* clear the value */
  localValue[0] = localValue[0] & ~(MaskWaitStateValue[JEDEC_SCCR_Map.Param_DWORD.D9.NumberBitsUsedToSetWaitStates] << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
341a3400:	7a3b      	ldrb	r3, [r7, #8]
341a3402:	b25a      	sxtb	r2, r3
341a3404:	4b30      	ldr	r3, [pc, #192]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a3406:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a340a:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a340e:	b2db      	uxtb	r3, r3
341a3410:	3318      	adds	r3, #24
341a3412:	443b      	add	r3, r7
341a3414:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
341a3418:	4619      	mov	r1, r3
341a341a:	4b2b      	ldr	r3, [pc, #172]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a341c:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a3420:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3424:	b2db      	uxtb	r3, r3
341a3426:	fa01 f303 	lsl.w	r3, r1, r3
341a342a:	b25b      	sxtb	r3, r3
341a342c:	43db      	mvns	r3, r3
341a342e:	b25b      	sxtb	r3, r3
341a3430:	4013      	ands	r3, r2
341a3432:	b25b      	sxtb	r3, r3
341a3434:	b2db      	uxtb	r3, r3
341a3436:	723b      	strb	r3, [r7, #8]

  /* Apply the value with the mask */
  localValue[0] =  localValue[0] | (uint8_t)(DummyValue << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
341a3438:	7a3a      	ldrb	r2, [r7, #8]
341a343a:	4b23      	ldr	r3, [pc, #140]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a343c:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a3440:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3444:	b2db      	uxtb	r3, r3
341a3446:	4619      	mov	r1, r3
341a3448:	683b      	ldr	r3, [r7, #0]
341a344a:	408b      	lsls	r3, r1
341a344c:	b2db      	uxtb	r3, r3
341a344e:	4313      	orrs	r3, r2
341a3450:	b2db      	uxtb	r3, r3
341a3452:	723b      	strb	r3, [r7, #8]
  localValue[1] = localValue[0];
341a3454:	7a3b      	ldrb	r3, [r7, #8]
341a3456:	727b      	strb	r3, [r7, #9]

  /* Write de configuration */
  if (HAL_OK != SAL_XSPI_Write(&Object->sfdp_private.SALObject, (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D9.CommandWriteAccess, Address, (uint8_t *)localValue, 2u))
341a3458:	687b      	ldr	r3, [r7, #4]
341a345a:	f103 0008 	add.w	r0, r3, #8
341a345e:	4b1a      	ldr	r3, [pc, #104]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a3460:	f893 1020 	ldrb.w	r1, [r3, #32]
341a3464:	f107 0308 	add.w	r3, r7, #8
341a3468:	2202      	movs	r2, #2
341a346a:	9200      	str	r2, [sp, #0]
341a346c:	693a      	ldr	r2, [r7, #16]
341a346e:	f7fe fa43 	bl	341a18f8 <SAL_XSPI_Write>
341a3472:	4603      	mov	r3, r0
341a3474:	2b00      	cmp	r3, #0
341a3476:	d002      	beq.n	341a347e <sfdp_set_dummycycle+0x19e>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3478:	230c      	movs	r3, #12
341a347a:	75fb      	strb	r3, [r7, #23]
    goto error;
341a347c:	e01d      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* wait for busy flag clear */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a347e:	2164      	movs	r1, #100	@ 0x64
341a3480:	6878      	ldr	r0, [r7, #4]
341a3482:	f7ff fce9 	bl	341a2e58 <driver_check_FlagBUSY>
341a3486:	4603      	mov	r3, r0
341a3488:	2b00      	cmp	r3, #0
341a348a:	d002      	beq.n	341a3492 <sfdp_set_dummycycle+0x1b2>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a348c:	230c      	movs	r3, #12
341a348e:	75fb      	strb	r3, [r7, #23]
    goto error;
341a3490:	e013      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

  /* Read the configuration, line can be removed it is only used for debug purpose */
  if (HAL_OK != SAL_XSPI_Read(&Object->sfdp_private.SALObject, (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D9.CommandReadAccess,
341a3492:	687b      	ldr	r3, [r7, #4]
341a3494:	f103 0008 	add.w	r0, r3, #8
341a3498:	4b0b      	ldr	r3, [pc, #44]	@ (341a34c8 <sfdp_set_dummycycle+0x1e8>)
341a349a:	f893 1021 	ldrb.w	r1, [r3, #33]	@ 0x21
341a349e:	f107 0308 	add.w	r3, r7, #8
341a34a2:	2202      	movs	r2, #2
341a34a4:	9200      	str	r2, [sp, #0]
341a34a6:	693a      	ldr	r2, [r7, #16]
341a34a8:	f7fe f9be 	bl	341a1828 <SAL_XSPI_Read>
341a34ac:	4603      	mov	r3, r0
341a34ae:	2b00      	cmp	r3, #0
341a34b0:	d002      	beq.n	341a34b8 <sfdp_set_dummycycle+0x1d8>
                              Address, (uint8_t *)localValue, 2u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a34b2:	230c      	movs	r3, #12
341a34b4:	75fb      	strb	r3, [r7, #23]
    goto error;
341a34b6:	e000      	b.n	341a34ba <sfdp_set_dummycycle+0x1da>
  }

error :
341a34b8:	bf00      	nop
  return retr;
341a34ba:	7dfb      	ldrb	r3, [r7, #23]
}
341a34bc:	4618      	mov	r0, r3
341a34be:	371c      	adds	r7, #28
341a34c0:	46bd      	mov	sp, r7
341a34c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a34c4:	1f0f0703 	.word	0x1f0f0703
341a34c8:	341c1c7c 	.word	0x341c1c7c

341a34cc <JEDEC_Basic_ManageQuadEnableRequirement>:
          JEDEC_Basic.Params.Param_DWORD.D15.QuadEnableRequirement parameter
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef JEDEC_Basic_ManageQuadEnableRequirement(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a34cc:	b580      	push	{r7, lr}
341a34ce:	b084      	sub	sp, #16
341a34d0:	af00      	add	r7, sp, #0
341a34d2:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a34d4:	230f      	movs	r3, #15
341a34d6:	73fb      	strb	r3, [r7, #15]
  uint8_t localValue[2];

  /* switch the mode in QSPI if available */
  switch (JEDEC_Basic.Params.Param_DWORD.D15.QuadEnableRequirement & 0x7u)
341a34d8:	4b59      	ldr	r3, [pc, #356]	@ (341a3640 <JEDEC_Basic_ManageQuadEnableRequirement+0x174>)
341a34da:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
341a34de:	f3c3 1302 	ubfx	r3, r3, #4, #3
341a34e2:	b2db      	uxtb	r3, r3
341a34e4:	2b07      	cmp	r3, #7
341a34e6:	f200 80a4 	bhi.w	341a3632 <JEDEC_Basic_ManageQuadEnableRequirement+0x166>
341a34ea:	a201      	add	r2, pc, #4	@ (adr r2, 341a34f0 <JEDEC_Basic_ManageQuadEnableRequirement+0x24>)
341a34ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a34f0:	341a3633 	.word	0x341a3633
341a34f4:	341a3633 	.word	0x341a3633
341a34f8:	341a3511 	.word	0x341a3511
341a34fc:	341a3633 	.word	0x341a3633
341a3500:	341a3591 	.word	0x341a3591
341a3504:	341a3633 	.word	0x341a3633
341a3508:	341a3633 	.word	0x341a3633
341a350c:	341a3633 	.word	0x341a3633
              */
    break;
  case 0x2u: {/* 010b: QE is bit 6 of status register 1. It is set via Write Status with one data byte where bit 6 is one.
                 It is cleared via Write Status with one data byte where bit 6 is zero. */
    /* 1 - set the write enable */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject,
341a3510:	687b      	ldr	r3, [r7, #4]
341a3512:	f103 0008 	add.w	r0, r3, #8
341a3516:	687b      	ldr	r3, [r7, #4]
341a3518:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a351c:	2300      	movs	r3, #0
341a351e:	2200      	movs	r2, #0
341a3520:	f7fe fa87 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
341a3524:	4603      	mov	r3, r0
341a3526:	2b00      	cmp	r3, #0
341a3528:	d002      	beq.n	341a3530 <JEDEC_Basic_ManageQuadEnableRequirement+0x64>
                                           Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a352a:	230c      	movs	r3, #12
341a352c:	73fb      	strb	r3, [r7, #15]
      goto error;
341a352e:	e081      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* 2 - read the status register */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND,
341a3530:	687b      	ldr	r3, [r7, #4]
341a3532:	f103 0008 	add.w	r0, r3, #8
341a3536:	f107 020c 	add.w	r2, r7, #12
341a353a:	2301      	movs	r3, #1
341a353c:	2105      	movs	r1, #5
341a353e:	f7fe fa78 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
341a3542:	4603      	mov	r3, r0
341a3544:	2b00      	cmp	r3, #0
341a3546:	d002      	beq.n	341a354e <JEDEC_Basic_ManageQuadEnableRequirement+0x82>
                                           (uint8_t *)&localValue[0], 1u))
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3548:	230c      	movs	r3, #12
341a354a:	73fb      	strb	r3, [r7, #15]
      goto error;
341a354c:	e072      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* 3 - update the status register to enable QPI mode*/
    localValue[0] = localValue[0] | 0x40u;
341a354e:	7b3b      	ldrb	r3, [r7, #12]
341a3550:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a3554:	b2db      	uxtb	r3, r3
341a3556:	733b      	strb	r3, [r7, #12]

    /* 4 - write the status register with QPI mode to 1 */
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 1u))
341a3558:	687b      	ldr	r3, [r7, #4]
341a355a:	f103 0008 	add.w	r0, r3, #8
341a355e:	f107 020c 	add.w	r2, r7, #12
341a3562:	2301      	movs	r3, #1
341a3564:	2101      	movs	r1, #1
341a3566:	f7fe fa10 	bl	341a198a <SAL_XSPI_CommandSendData>
341a356a:	4603      	mov	r3, r0
341a356c:	2b00      	cmp	r3, #0
341a356e:	d002      	beq.n	341a3576 <JEDEC_Basic_ManageQuadEnableRequirement+0xaa>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3570:	230c      	movs	r3, #12
341a3572:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3574:	e05e      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* wait busy flag  */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
341a3576:	2164      	movs	r1, #100	@ 0x64
341a3578:	6878      	ldr	r0, [r7, #4]
341a357a:	f7ff fc6d 	bl	341a2e58 <driver_check_FlagBUSY>
341a357e:	4603      	mov	r3, r0
341a3580:	2b00      	cmp	r3, #0
341a3582:	d002      	beq.n	341a358a <JEDEC_Basic_ManageQuadEnableRequirement+0xbe>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3584:	230c      	movs	r3, #12
341a3586:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3588:	e054      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    retr = EXTMEM_SFDP_OK;
341a358a:	2300      	movs	r3, #0
341a358c:	73fb      	strb	r3, [r7, #15]
    break;
341a358e:	e051      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
  case 0x4u:{ /* 100b: QE is bit 1 of status register 2. It is set via Write Status with two data bytes where bit 1 of the second byte is one.
                It is cleared via Write Status with two data bytes where bit 1 of the second byte is zero.
                In contrast to the 001b code, writing one byte to the status register does not modify status register 2.*/

    /* read the status register */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
341a3590:	687b      	ldr	r3, [r7, #4]
341a3592:	f103 0008 	add.w	r0, r3, #8
341a3596:	f107 020c 	add.w	r2, r7, #12
341a359a:	2302      	movs	r3, #2
341a359c:	2105      	movs	r1, #5
341a359e:	f7fe fa48 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
341a35a2:	4603      	mov	r3, r0
341a35a4:	2b00      	cmp	r3, #0
341a35a6:	d002      	beq.n	341a35ae <JEDEC_Basic_ManageQuadEnableRequirement+0xe2>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a35a8:	230c      	movs	r3, #12
341a35aa:	73fb      	strb	r3, [r7, #15]
      goto error;
341a35ac:	e042      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* update the status register */
    localValue[1] |= 2u;
341a35ae:	7b7b      	ldrb	r3, [r7, #13]
341a35b0:	f043 0302 	orr.w	r3, r3, #2
341a35b4:	b2db      	uxtb	r3, r3
341a35b6:	737b      	strb	r3, [r7, #13]

    /* WEL */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
341a35b8:	687b      	ldr	r3, [r7, #4]
341a35ba:	f103 0008 	add.w	r0, r3, #8
341a35be:	687b      	ldr	r3, [r7, #4]
341a35c0:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a35c4:	2300      	movs	r3, #0
341a35c6:	2200      	movs	r2, #0
341a35c8:	f7fe fa33 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
341a35cc:	4603      	mov	r3, r0
341a35ce:	2b00      	cmp	r3, #0
341a35d0:	d002      	beq.n	341a35d8 <JEDEC_Basic_ManageQuadEnableRequirement+0x10c>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a35d2:	230c      	movs	r3, #12
341a35d4:	73fb      	strb	r3, [r7, #15]
      goto error;
341a35d6:	e02d      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* write the status register */
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 2u))
341a35d8:	687b      	ldr	r3, [r7, #4]
341a35da:	f103 0008 	add.w	r0, r3, #8
341a35de:	f107 020c 	add.w	r2, r7, #12
341a35e2:	2302      	movs	r3, #2
341a35e4:	2101      	movs	r1, #1
341a35e6:	f7fe f9d0 	bl	341a198a <SAL_XSPI_CommandSendData>
341a35ea:	4603      	mov	r3, r0
341a35ec:	2b00      	cmp	r3, #0
341a35ee:	d002      	beq.n	341a35f6 <JEDEC_Basic_ManageQuadEnableRequirement+0x12a>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a35f0:	230c      	movs	r3, #12
341a35f2:	73fb      	strb	r3, [r7, #15]
      goto error;
341a35f4:	e01e      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* wait busy flag  */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
341a35f6:	2164      	movs	r1, #100	@ 0x64
341a35f8:	6878      	ldr	r0, [r7, #4]
341a35fa:	f7ff fc2d 	bl	341a2e58 <driver_check_FlagBUSY>
341a35fe:	4603      	mov	r3, r0
341a3600:	2b00      	cmp	r3, #0
341a3602:	d002      	beq.n	341a360a <JEDEC_Basic_ManageQuadEnableRequirement+0x13e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3604:	230c      	movs	r3, #12
341a3606:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3608:	e014      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* Optional : only for control read the status register and check write operation is OK */
    localValue[1] = 0xFF;
341a360a:	23ff      	movs	r3, #255	@ 0xff
341a360c:	737b      	strb	r3, [r7, #13]
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
341a360e:	687b      	ldr	r3, [r7, #4]
341a3610:	f103 0008 	add.w	r0, r3, #8
341a3614:	f107 020c 	add.w	r2, r7, #12
341a3618:	2302      	movs	r3, #2
341a361a:	2105      	movs	r1, #5
341a361c:	f7fe fa09 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
341a3620:	4603      	mov	r3, r0
341a3622:	2b00      	cmp	r3, #0
341a3624:	d002      	beq.n	341a362c <JEDEC_Basic_ManageQuadEnableRequirement+0x160>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3626:	230c      	movs	r3, #12
341a3628:	73fb      	strb	r3, [r7, #15]
      goto error;
341a362a:	e003      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    retr = EXTMEM_SFDP_OK;
341a362c:	2300      	movs	r3, #0
341a362e:	73fb      	strb	r3, [r7, #15]
    break;
341a3630:	e000      	b.n	341a3634 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
  case 0x6u: /* 110b: QE is bit 1 of the status register 2. Status register 1 is read using Read Status instruction 05h. Status register 2 is read using instruction 35h, and status register 3 is read using instruction 15h. QE is set via Write Status Register instruction 31h with one data byte where bit 1 is one. It is cleared via Write Status Register instruction 31h with one data byte where bit 1 is zero.*/
    break;
  case 0x7u: /*111b: Reserved */
    break;
  default :/* Added for Misra */
    break;
341a3632:	bf00      	nop
  }
error :
  return retr;
341a3634:	7bfb      	ldrb	r3, [r7, #15]
}
341a3636:	4618      	mov	r0, r3
341a3638:	3710      	adds	r7, #16
341a363a:	46bd      	mov	sp, r7
341a363c:	bd80      	pop	{r7, pc}
341a363e:	bf00      	nop
341a3640:	341c1bfc 	.word	0x341c1bfc

341a3644 <JEDEC_Basic_Manage4S4S4SEnableSequence>:
          JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence parameter
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef JEDEC_Basic_Manage4S4S4SEnableSequence(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a3644:	b580      	push	{r7, lr}
341a3646:	b084      	sub	sp, #16
341a3648:	af00      	add	r7, sp, #0
341a364a:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a364c:	230f      	movs	r3, #15
341a364e:	73fb      	strb	r3, [r7, #15]
  uint8_t instruction = 0x00u;
341a3650:	2300      	movs	r3, #0
341a3652:	73bb      	strb	r3, [r7, #14]

  /* 4-4-4 mode enable sequences; This field describes the supported methods to enter 4-4-4 mode from 1-1-1 mode */
  /* x_xxx1b: set QE per QER description above, then issue instruction 38h */
  if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x1u) == 0x1u)
341a3654:	4b1a      	ldr	r3, [pc, #104]	@ (341a36c0 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
341a3656:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
341a3658:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a365c:	b2db      	uxtb	r3, r3
341a365e:	f003 0301 	and.w	r3, r3, #1
341a3662:	2b00      	cmp	r3, #0
341a3664:	d007      	beq.n	341a3676 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x32>
  {
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
341a3666:	6878      	ldr	r0, [r7, #4]
341a3668:	f7ff ff30 	bl	341a34cc <JEDEC_Basic_ManageQuadEnableRequirement>
341a366c:	4603      	mov	r3, r0
341a366e:	73fb      	strb	r3, [r7, #15]
    instruction = 0x38u;
341a3670:	2338      	movs	r3, #56	@ 0x38
341a3672:	73bb      	strb	r3, [r7, #14]
341a3674:	e00f      	b.n	341a3696 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  }
  /* x_x1xxb: issue instruction 35h */
  else if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x4u) == 0x4u)
341a3676:	4b12      	ldr	r3, [pc, #72]	@ (341a36c0 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
341a3678:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
341a367a:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a367e:	b2db      	uxtb	r3, r3
341a3680:	f003 0304 	and.w	r3, r3, #4
341a3684:	2b00      	cmp	r3, #0
341a3686:	d006      	beq.n	341a3696 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  {
    /* If QE bit exists, Quad Enable Requirement describes method to enable Quad operations */
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
341a3688:	6878      	ldr	r0, [r7, #4]
341a368a:	f7ff ff1f 	bl	341a34cc <JEDEC_Basic_ManageQuadEnableRequirement>
341a368e:	4603      	mov	r3, r0
341a3690:	73fb      	strb	r3, [r7, #15]
    instruction = 0x35u;
341a3692:	2335      	movs	r3, #53	@ 0x35
341a3694:	73bb      	strb	r3, [r7, #14]
       Device uses a read-modify-write sequence of operations:
       Read Volatile Enhanced Configuration Register using instruction 65h, no address is required, set bit 7 to 1.
       Write Volatile Enhanced Configuration Register using instruction 61h, no address is required. This configuration is volatile.
  NOTE If device is in 0-4-4 mode, then this mode must be exited before the 4-4-4 enable sequence is issued.
  */
  if ((retr == EXTMEM_SFDP_OK) && (instruction != 0u))
341a3696:	7bfb      	ldrb	r3, [r7, #15]
341a3698:	2b00      	cmp	r3, #0
341a369a:	d10c      	bne.n	341a36b6 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
341a369c:	7bbb      	ldrb	r3, [r7, #14]
341a369e:	2b00      	cmp	r3, #0
341a36a0:	d009      	beq.n	341a36b6 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
  {
    (void)SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, instruction, NULL, 0u);
341a36a2:	687b      	ldr	r3, [r7, #4]
341a36a4:	f103 0008 	add.w	r0, r3, #8
341a36a8:	7bb9      	ldrb	r1, [r7, #14]
341a36aa:	2300      	movs	r3, #0
341a36ac:	2200      	movs	r2, #0
341a36ae:	f7fe f9c0 	bl	341a1a32 <SAL_XSPI_SendReadCommand>
    /* @note on memory W25Q64JV the command 38h does not exist so the control on command execution has been removed */
    retr = EXTMEM_SFDP_OK;
341a36b2:	2300      	movs	r3, #0
341a36b4:	73fb      	strb	r3, [r7, #15]
  }

  return retr;
341a36b6:	7bfb      	ldrb	r3, [r7, #15]
}
341a36b8:	4618      	mov	r0, r3
341a36ba:	3710      	adds	r7, #16
341a36bc:	46bd      	mov	sp, r7
341a36be:	bd80      	pop	{r7, pc}
341a36c0:	341c1bfc 	.word	0x341c1bfc

341a36c4 <CheckSFDP_Signature>:
 * @param Object memory Object
 * @param Signature value of the SFDP signature
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef CheckSFDP_Signature(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t Signature )
{
341a36c4:	b580      	push	{r7, lr}
341a36c6:	b084      	sub	sp, #16
341a36c8:	af00      	add	r7, sp, #0
341a36ca:	6078      	str	r0, [r7, #4]
341a36cc:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a36ce:	2304      	movs	r3, #4
341a36d0:	73fb      	strb	r3, [r7, #15]

  /* check the magic number */
  switch(Signature)
341a36d2:	683b      	ldr	r3, [r7, #0]
341a36d4:	4a0e      	ldr	r2, [pc, #56]	@ (341a3710 <CheckSFDP_Signature+0x4c>)
341a36d6:	4293      	cmp	r3, r2
341a36d8:	d006      	beq.n	341a36e8 <CheckSFDP_Signature+0x24>
341a36da:	683b      	ldr	r3, [r7, #0]
341a36dc:	4a0d      	ldr	r2, [pc, #52]	@ (341a3714 <CheckSFDP_Signature+0x50>)
341a36de:	4293      	cmp	r3, r2
341a36e0:	d10e      	bne.n	341a3700 <CheckSFDP_Signature+0x3c>
  {
  case SFDP_SIGNATURE :
    SFDP_DEBUG_STR("signature of the header: OK");
    retr = EXTMEM_SFDP_OK;
341a36e2:	2300      	movs	r3, #0
341a36e4:	73fb      	strb	r3, [r7, #15]
    break;
341a36e6:	e00e      	b.n	341a3706 <CheckSFDP_Signature+0x42>
  case SFDP_SIGNATURE_INVERTED :
    SFDP_DEBUG_STR("signature of the header: KO inverted data order");
    /* Change the memory type settings */
    if (HAL_OK == SAL_XSPI_UpdateMemoryType(&Object->sfdp_private.SALObject, SAL_XSPI_ORDERINVERTED))
341a36e8:	687b      	ldr	r3, [r7, #4]
341a36ea:	3308      	adds	r3, #8
341a36ec:	2100      	movs	r1, #0
341a36ee:	4618      	mov	r0, r3
341a36f0:	f7fe fae2 	bl	341a1cb8 <SAL_XSPI_UpdateMemoryType>
341a36f4:	4603      	mov	r3, r0
341a36f6:	2b00      	cmp	r3, #0
341a36f8:	d104      	bne.n	341a3704 <CheckSFDP_Signature+0x40>
    {
      retr = EXTMEM_SFDP_ERROR_SIGNATUREMTYPE;
341a36fa:	2305      	movs	r3, #5
341a36fc:	73fb      	strb	r3, [r7, #15]
    }
    break;
341a36fe:	e001      	b.n	341a3704 <CheckSFDP_Signature+0x40>
  default :
    SFDP_DEBUG_STR("signature of the header: KO");
    break;
341a3700:	bf00      	nop
341a3702:	e000      	b.n	341a3706 <CheckSFDP_Signature+0x42>
    break;
341a3704:	bf00      	nop
  }
  return retr;
341a3706:	7bfb      	ldrb	r3, [r7, #15]
}
341a3708:	4618      	mov	r0, r3
341a370a:	3710      	adds	r7, #16
341a370c:	46bd      	mov	sp, r7
341a370e:	bd80      	pop	{r7, pc}
341a3710:	44505346 	.word	0x44505346
341a3714:	50444653 	.word	0x50444653

341a3718 <EXTMEM_DRIVER_NOR_SFDP_Init>:
/** @defgroup DRIVER_SFDP_Exported_Functions DRIVER SFDP Exported Functions
  * @{
  */

EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef EXTMEM_DRIVER_NOR_SFDP_Init(void *Peripheral, EXTMEM_LinkConfig_TypeDef Config, uint32_t ClockInput, EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject)
{
341a3718:	b580      	push	{r7, lr}
341a371a:	b08a      	sub	sp, #40	@ 0x28
341a371c:	af00      	add	r7, sp, #0
341a371e:	60f8      	str	r0, [r7, #12]
341a3720:	607a      	str	r2, [r7, #4]
341a3722:	603b      	str	r3, [r7, #0]
341a3724:	460b      	mov	r3, r1
341a3726:	72fb      	strb	r3, [r7, #11]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_OK;
341a3728:	2300      	movs	r3, #0
341a372a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  SFDP_HeaderTypeDef JEDEC_SFDP_Header;
  uint8_t FreqUpdate = 0u;
341a372e:	2300      	movs	r3, #0
341a3730:	76fb      	strb	r3, [r7, #27]
  uint8_t DataID[6];
  uint32_t ClockOut;

  /* reset data of SFDPObject to zero */
  SFDP_DEBUG_STR("1 - reset data SFDPObject to zero")
  (void)memset((void *)&SFDPObject->sfdp_private, 0x0, sizeof(SFDPObject->sfdp_private));
341a3732:	683b      	ldr	r3, [r7, #0]
341a3734:	3308      	adds	r3, #8
341a3736:	2298      	movs	r2, #152	@ 0x98
341a3738:	2100      	movs	r1, #0
341a373a:	4618      	mov	r0, r3
341a373c:	f000 fb32 	bl	341a3da4 <memset>

  /* initialize the SFDPObject */
  SFDP_DEBUG_STR("2 - initialize the SFDPObject")
  SFDPObject->sfdp_private.Config = Config;
341a3740:	683b      	ldr	r3, [r7, #0]
341a3742:	7afa      	ldrb	r2, [r7, #11]
341a3744:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
  SFDPObject->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
341a3748:	683b      	ldr	r3, [r7, #0]
341a374a:	2200      	movs	r2, #0
341a374c:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
  SFDPObject->sfdp_private.DriverInfo.ClockIn = ClockInput;
341a3750:	683b      	ldr	r3, [r7, #0]
341a3752:	687a      	ldr	r2, [r7, #4]
341a3754:	669a      	str	r2, [r3, #104]	@ 0x68
  SAL_XSPI_SET_SFDPDUMMYCYLE(SFDPObject->sfdp_private.SALObject, EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_DEFAULT);
341a3756:	683b      	ldr	r3, [r7, #0]
341a3758:	2208      	movs	r2, #8
341a375a:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

  /* set memory speed to 50Mhz maximum */
  SFDP_DEBUG_STR("3 - set memory link and speed to 50Mhz maximum")
  (void)SAL_XSPI_Init(&SFDPObject->sfdp_private.SALObject, Peripheral);
341a375e:	683b      	ldr	r3, [r7, #0]
341a3760:	3308      	adds	r3, #8
341a3762:	68f9      	ldr	r1, [r7, #12]
341a3764:	4618      	mov	r0, r3
341a3766:	f7fd fdff 	bl	341a1368 <SAL_XSPI_Init>
  (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput, DRIVER_SFDP_DEFAULT_CLOCK, &ClockOut);
341a376a:	683b      	ldr	r3, [r7, #0]
341a376c:	f103 0008 	add.w	r0, r3, #8
341a3770:	f107 0310 	add.w	r3, r7, #16
341a3774:	4a45      	ldr	r2, [pc, #276]	@ (341a388c <EXTMEM_DRIVER_NOR_SFDP_Init+0x174>)
341a3776:	6879      	ldr	r1, [r7, #4]
341a3778:	f7fd fdb7 	bl	341a12ea <SAL_XSPI_SetClock>

  /* Abort any ongoing XSPI action */
  (void)SAL_XSPI_DisableMapMode(&SFDPObject->sfdp_private.SALObject);
341a377c:	683b      	ldr	r3, [r7, #0]
341a377e:	3308      	adds	r3, #8
341a3780:	4618      	mov	r0, r3
341a3782:	f7fe fa88 	bl	341a1c96 <SAL_XSPI_DisableMapMode>

  /* analyze the SFDP structure to get driver information */
  SFDP_DEBUG_STR("4 - analyze the SFDP structure to get driver information")
  if(EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
341a3786:	f107 031c 	add.w	r3, r7, #28
341a378a:	4619      	mov	r1, r3
341a378c:	6838      	ldr	r0, [r7, #0]
341a378e:	f7fe fb65 	bl	341a1e5c <SFDP_GetHeader>
341a3792:	4603      	mov	r3, r0
341a3794:	2b00      	cmp	r3, #0
341a3796:	d003      	beq.n	341a37a0 <EXTMEM_DRIVER_NOR_SFDP_Init+0x88>
    /*
     *  for the future, we can try to get SFDP by using different mode
     *  the SFDP read is only performed in 1S1S1S mode
     */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a3798:	23ff      	movs	r3, #255	@ 0xff
341a379a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a379e:	e06e      	b.n	341a387e <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* Reset the memory */
  SFDP_DEBUG_STR("5 - reset the memory")
  if(EXTMEM_SFDP_OK != SFDP_MemoryReset(SFDPObject))
341a37a0:	6838      	ldr	r0, [r7, #0]
341a37a2:	f7fe fc95 	bl	341a20d0 <SFDP_MemoryReset>
     */
    SFDP_DEBUG_STR("ERROR::on the call of SFDP_MemoryReset but no error returned")
  }

  /* wait few ms after the reset operation, this is done to avoid issue on SFDP read */
  HAL_Delay(10);
341a37a6:	200a      	movs	r0, #10
341a37a8:	f7e1 fdde 	bl	34185368 <HAL_Delay>

  /* analyze the SFDP structure to get driver information after the reset */
  SFDP_DEBUG_STR("6 - analyze the SFDP structure to get driver information")
  if(EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
341a37ac:	f107 031c 	add.w	r3, r7, #28
341a37b0:	4619      	mov	r1, r3
341a37b2:	6838      	ldr	r0, [r7, #0]
341a37b4:	f7fe fb52 	bl	341a1e5c <SFDP_GetHeader>
341a37b8:	4603      	mov	r3, r0
341a37ba:	2b00      	cmp	r3, #0
341a37bc:	d003      	beq.n	341a37c6 <EXTMEM_DRIVER_NOR_SFDP_Init+0xae>
    /*
     *  for the future, we can try to get SFDP by using different mode
     *  the SFDP read is only perform in 1S1S1S mode
     */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a37be:	23ff      	movs	r3, #255	@ 0xff
341a37c0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a37c4:	e05b      	b.n	341a387e <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* Save information from the SFDP table
     Nb of parameters starts at 0 (0 means 1 parameter) */
  if (JEDEC_SFDP_Header.param_number >= SFDP_MAX_NB_OF_PARAM)
341a37c6:	f897 3022 	ldrb.w	r3, [r7, #34]	@ 0x22
341a37ca:	2b09      	cmp	r3, #9
341a37cc:	d904      	bls.n	341a37d8 <EXTMEM_DRIVER_NOR_SFDP_Init+0xc0>
  {
    SFDPObject->sfdp_private.Sfdp_param_number = SFDP_MAX_NB_OF_PARAM - 1;
341a37ce:	683b      	ldr	r3, [r7, #0]
341a37d0:	2209      	movs	r2, #9
341a37d2:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
341a37d6:	e004      	b.n	341a37e2 <EXTMEM_DRIVER_NOR_SFDP_Init+0xca>
  }
  else
  {
    SFDPObject->sfdp_private.Sfdp_param_number = JEDEC_SFDP_Header.param_number;
341a37d8:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
341a37dc:	683b      	ldr	r3, [r7, #0]
341a37de:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
  }
  SFDPObject->sfdp_private.Sfdp_AccessProtocol = JEDEC_SFDP_Header.AccessProtocol;
341a37e2:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
341a37e6:	683b      	ldr	r3, [r7, #0]
341a37e8:	f883 209d 	strb.w	r2, [r3, #157]	@ 0x9d

  /* read the flash ID */
  SFDP_DEBUG_STR("7 - read the flash ID")
  (void)SAL_XSPI_GetId(&SFDPObject->sfdp_private.SALObject, DataID, EXTMEM_READ_JEDEC_ID_SIZE);
341a37ec:	683b      	ldr	r3, [r7, #0]
341a37ee:	3308      	adds	r3, #8
341a37f0:	f107 0114 	add.w	r1, r7, #20
341a37f4:	2204      	movs	r2, #4
341a37f6:	4618      	mov	r0, r3
341a37f8:	f7fd ff96 	bl	341a1728 <SAL_XSPI_GetId>
  DEBUG_ID(DataID);

  /* Keep manufacturer information, it could be used to help in
     building of consistent driver */
  SFDPObject->sfdp_private.ManuID = DataID[0];
341a37fc:	7d3a      	ldrb	r2, [r7, #20]
341a37fe:	683b      	ldr	r3, [r7, #0]
341a3800:	f883 205d 	strb.w	r2, [r3, #93]	@ 0x5d

  /* get the SFDP data */
  SFDP_DEBUG_STR("8 - collect the SFDP data")
  if(EXTMEM_SFDP_OK != SFDP_CollectData(SFDPObject))
341a3804:	6838      	ldr	r0, [r7, #0]
341a3806:	f7fe fb87 	bl	341a1f18 <SFDP_CollectData>
341a380a:	4603      	mov	r3, r0
341a380c:	2b00      	cmp	r3, #0
341a380e:	d003      	beq.n	341a3818 <EXTMEM_DRIVER_NOR_SFDP_Init+0x100>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a3810:	23ff      	movs	r3, #255	@ 0xff
341a3812:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a3816:	e032      	b.n	341a387e <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* setup the generic driver information and prepare the physical layer */
  SFDP_DEBUG_STR("9 - build the generic driver information and prepare the physical layer")
  if(EXTMEM_SFDP_OK != SFDP_BuildGenericDriver(SFDPObject, &FreqUpdate))
341a3818:	f107 031b 	add.w	r3, r7, #27
341a381c:	4619      	mov	r1, r3
341a381e:	6838      	ldr	r0, [r7, #0]
341a3820:	f7fe fd32 	bl	341a2288 <SFDP_BuildGenericDriver>
341a3824:	4603      	mov	r3, r0
341a3826:	2b00      	cmp	r3, #0
341a3828:	d003      	beq.n	341a3832 <EXTMEM_DRIVER_NOR_SFDP_Init+0x11a>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD;
341a382a:	23fd      	movs	r3, #253	@ 0xfd
341a382c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a3830:	e025      	b.n	341a387e <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  SFDP_DEBUG_STR("10 - adjust the frequency if required")
  if ((FreqUpdate == 0u) && (SFDPObject->sfdp_public.MaxFreq != 0u))
341a3832:	7efb      	ldrb	r3, [r7, #27]
341a3834:	2b00      	cmp	r3, #0
341a3836:	d10d      	bne.n	341a3854 <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
341a3838:	683b      	ldr	r3, [r7, #0]
341a383a:	681b      	ldr	r3, [r3, #0]
341a383c:	2b00      	cmp	r3, #0
341a383e:	d009      	beq.n	341a3854 <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
  {
    (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput, SFDPObject->sfdp_public.MaxFreq, &ClockOut);
341a3840:	683b      	ldr	r3, [r7, #0]
341a3842:	f103 0008 	add.w	r0, r3, #8
341a3846:	683b      	ldr	r3, [r7, #0]
341a3848:	681a      	ldr	r2, [r3, #0]
341a384a:	f107 0310 	add.w	r3, r7, #16
341a384e:	6879      	ldr	r1, [r7, #4]
341a3850:	f7fd fd4b 	bl	341a12ea <SAL_XSPI_SetClock>
    SFDP_DEBUG_STR("--> new freq configured");
  }

  SFDP_DEBUG_STR("11 - read again the SFDP header to adjust memory type if necessary")
  if(EXTMEM_SFDP_OK != SFDP_ReadHeader(SFDPObject, &JEDEC_SFDP_Header))
341a3854:	f107 031c 	add.w	r3, r7, #28
341a3858:	4619      	mov	r1, r3
341a385a:	6838      	ldr	r0, [r7, #0]
341a385c:	f7fe fac1 	bl	341a1de2 <SFDP_ReadHeader>
341a3860:	4603      	mov	r3, r0
341a3862:	2b00      	cmp	r3, #0
341a3864:	d003      	beq.n	341a386e <EXTMEM_DRIVER_NOR_SFDP_Init+0x156>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_MEMTYPE_CHECK")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_MEMTYPE_CHECK;
341a3866:	23f2      	movs	r3, #242	@ 0xf2
341a3868:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a386c:	e007      	b.n	341a387e <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  (void)SAL_XSPI_GetId(&SFDPObject->sfdp_private.SALObject, DataID, EXTMEM_READ_JEDEC_ID_SIZE);
341a386e:	683b      	ldr	r3, [r7, #0]
341a3870:	3308      	adds	r3, #8
341a3872:	f107 0114 	add.w	r1, r7, #20
341a3876:	2204      	movs	r2, #4
341a3878:	4618      	mov	r0, r3
341a387a:	f7fd ff55 	bl	341a1728 <SAL_XSPI_GetId>
  DEBUG_ID(DataID);

error:
  return retr;
341a387e:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
}
341a3882:	4618      	mov	r0, r3
341a3884:	3728      	adds	r7, #40	@ 0x28
341a3886:	46bd      	mov	sp, r7
341a3888:	bd80      	pop	{r7, pc}
341a388a:	bf00      	nop
341a388c:	02faf080 	.word	0x02faf080

341a3890 <__assert_func>:
341a3890:	b51f      	push	{r0, r1, r2, r3, r4, lr}
341a3892:	4614      	mov	r4, r2
341a3894:	461a      	mov	r2, r3
341a3896:	4b09      	ldr	r3, [pc, #36]	@ (341a38bc <__assert_func+0x2c>)
341a3898:	4605      	mov	r5, r0
341a389a:	681b      	ldr	r3, [r3, #0]
341a389c:	68d8      	ldr	r0, [r3, #12]
341a389e:	b14c      	cbz	r4, 341a38b4 <__assert_func+0x24>
341a38a0:	4b07      	ldr	r3, [pc, #28]	@ (341a38c0 <__assert_func+0x30>)
341a38a2:	9100      	str	r1, [sp, #0]
341a38a4:	4907      	ldr	r1, [pc, #28]	@ (341a38c4 <__assert_func+0x34>)
341a38a6:	e9cd 3401 	strd	r3, r4, [sp, #4]
341a38aa:	462b      	mov	r3, r5
341a38ac:	f000 f8b2 	bl	341a3a14 <fiprintf>
341a38b0:	f000 fb00 	bl	341a3eb4 <abort>
341a38b4:	4b04      	ldr	r3, [pc, #16]	@ (341a38c8 <__assert_func+0x38>)
341a38b6:	461c      	mov	r4, r3
341a38b8:	e7f3      	b.n	341a38a2 <__assert_func+0x12>
341a38ba:	bf00      	nop
341a38bc:	341c0140 	.word	0x341c0140
341a38c0:	341b7d21 	.word	0x341b7d21
341a38c4:	341b7d2e 	.word	0x341b7d2e
341a38c8:	341b78d9 	.word	0x341b78d9

341a38cc <std>:
341a38cc:	2300      	movs	r3, #0
341a38ce:	b510      	push	{r4, lr}
341a38d0:	4604      	mov	r4, r0
341a38d2:	6083      	str	r3, [r0, #8]
341a38d4:	8181      	strh	r1, [r0, #12]
341a38d6:	4619      	mov	r1, r3
341a38d8:	6643      	str	r3, [r0, #100]	@ 0x64
341a38da:	81c2      	strh	r2, [r0, #14]
341a38dc:	2208      	movs	r2, #8
341a38de:	6183      	str	r3, [r0, #24]
341a38e0:	e9c0 3300 	strd	r3, r3, [r0]
341a38e4:	e9c0 3304 	strd	r3, r3, [r0, #16]
341a38e8:	305c      	adds	r0, #92	@ 0x5c
341a38ea:	f000 fa5b 	bl	341a3da4 <memset>
341a38ee:	4b0d      	ldr	r3, [pc, #52]	@ (341a3924 <std+0x58>)
341a38f0:	6224      	str	r4, [r4, #32]
341a38f2:	6263      	str	r3, [r4, #36]	@ 0x24
341a38f4:	4b0c      	ldr	r3, [pc, #48]	@ (341a3928 <std+0x5c>)
341a38f6:	62a3      	str	r3, [r4, #40]	@ 0x28
341a38f8:	4b0c      	ldr	r3, [pc, #48]	@ (341a392c <std+0x60>)
341a38fa:	62e3      	str	r3, [r4, #44]	@ 0x2c
341a38fc:	4b0c      	ldr	r3, [pc, #48]	@ (341a3930 <std+0x64>)
341a38fe:	6323      	str	r3, [r4, #48]	@ 0x30
341a3900:	4b0c      	ldr	r3, [pc, #48]	@ (341a3934 <std+0x68>)
341a3902:	429c      	cmp	r4, r3
341a3904:	d006      	beq.n	341a3914 <std+0x48>
341a3906:	f103 0268 	add.w	r2, r3, #104	@ 0x68
341a390a:	4294      	cmp	r4, r2
341a390c:	d002      	beq.n	341a3914 <std+0x48>
341a390e:	33d0      	adds	r3, #208	@ 0xd0
341a3910:	429c      	cmp	r4, r3
341a3912:	d105      	bne.n	341a3920 <std+0x54>
341a3914:	f104 0058 	add.w	r0, r4, #88	@ 0x58
341a3918:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a391c:	f000 baba 	b.w	341a3e94 <__retarget_lock_init_recursive>
341a3920:	bd10      	pop	{r4, pc}
341a3922:	bf00      	nop
341a3924:	341a3bc1 	.word	0x341a3bc1
341a3928:	341a3be3 	.word	0x341a3be3
341a392c:	341a3c1b 	.word	0x341a3c1b
341a3930:	341a3c3f 	.word	0x341a3c3f
341a3934:	341c1d0c 	.word	0x341c1d0c

341a3938 <stdio_exit_handler>:
341a3938:	4a02      	ldr	r2, [pc, #8]	@ (341a3944 <stdio_exit_handler+0xc>)
341a393a:	4903      	ldr	r1, [pc, #12]	@ (341a3948 <stdio_exit_handler+0x10>)
341a393c:	4803      	ldr	r0, [pc, #12]	@ (341a394c <stdio_exit_handler+0x14>)
341a393e:	f000 b87b 	b.w	341a3a38 <_fwalk_sglue>
341a3942:	bf00      	nop
341a3944:	341c0134 	.word	0x341c0134
341a3948:	341a4a11 	.word	0x341a4a11
341a394c:	341c0144 	.word	0x341c0144

341a3950 <cleanup_stdio>:
341a3950:	6841      	ldr	r1, [r0, #4]
341a3952:	4b0c      	ldr	r3, [pc, #48]	@ (341a3984 <cleanup_stdio+0x34>)
341a3954:	4299      	cmp	r1, r3
341a3956:	b510      	push	{r4, lr}
341a3958:	4604      	mov	r4, r0
341a395a:	d001      	beq.n	341a3960 <cleanup_stdio+0x10>
341a395c:	f001 f858 	bl	341a4a10 <_fflush_r>
341a3960:	68a1      	ldr	r1, [r4, #8]
341a3962:	4b09      	ldr	r3, [pc, #36]	@ (341a3988 <cleanup_stdio+0x38>)
341a3964:	4299      	cmp	r1, r3
341a3966:	d002      	beq.n	341a396e <cleanup_stdio+0x1e>
341a3968:	4620      	mov	r0, r4
341a396a:	f001 f851 	bl	341a4a10 <_fflush_r>
341a396e:	68e1      	ldr	r1, [r4, #12]
341a3970:	4b06      	ldr	r3, [pc, #24]	@ (341a398c <cleanup_stdio+0x3c>)
341a3972:	4299      	cmp	r1, r3
341a3974:	d004      	beq.n	341a3980 <cleanup_stdio+0x30>
341a3976:	4620      	mov	r0, r4
341a3978:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a397c:	f001 b848 	b.w	341a4a10 <_fflush_r>
341a3980:	bd10      	pop	{r4, pc}
341a3982:	bf00      	nop
341a3984:	341c1d0c 	.word	0x341c1d0c
341a3988:	341c1d74 	.word	0x341c1d74
341a398c:	341c1ddc 	.word	0x341c1ddc

341a3990 <global_stdio_init.part.0>:
341a3990:	b510      	push	{r4, lr}
341a3992:	4b0b      	ldr	r3, [pc, #44]	@ (341a39c0 <global_stdio_init.part.0+0x30>)
341a3994:	2104      	movs	r1, #4
341a3996:	4c0b      	ldr	r4, [pc, #44]	@ (341a39c4 <global_stdio_init.part.0+0x34>)
341a3998:	4a0b      	ldr	r2, [pc, #44]	@ (341a39c8 <global_stdio_init.part.0+0x38>)
341a399a:	4620      	mov	r0, r4
341a399c:	601a      	str	r2, [r3, #0]
341a399e:	2200      	movs	r2, #0
341a39a0:	f7ff ff94 	bl	341a38cc <std>
341a39a4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
341a39a8:	2201      	movs	r2, #1
341a39aa:	2109      	movs	r1, #9
341a39ac:	f7ff ff8e 	bl	341a38cc <std>
341a39b0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
341a39b4:	2202      	movs	r2, #2
341a39b6:	2112      	movs	r1, #18
341a39b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a39bc:	f7ff bf86 	b.w	341a38cc <std>
341a39c0:	341c1e44 	.word	0x341c1e44
341a39c4:	341c1d0c 	.word	0x341c1d0c
341a39c8:	341a3939 	.word	0x341a3939

341a39cc <__sfp_lock_acquire>:
341a39cc:	4801      	ldr	r0, [pc, #4]	@ (341a39d4 <__sfp_lock_acquire+0x8>)
341a39ce:	f000 ba62 	b.w	341a3e96 <__retarget_lock_acquire_recursive>
341a39d2:	bf00      	nop
341a39d4:	341c1e4d 	.word	0x341c1e4d

341a39d8 <__sfp_lock_release>:
341a39d8:	4801      	ldr	r0, [pc, #4]	@ (341a39e0 <__sfp_lock_release+0x8>)
341a39da:	f000 ba5d 	b.w	341a3e98 <__retarget_lock_release_recursive>
341a39de:	bf00      	nop
341a39e0:	341c1e4d 	.word	0x341c1e4d

341a39e4 <__sinit>:
341a39e4:	b510      	push	{r4, lr}
341a39e6:	4604      	mov	r4, r0
341a39e8:	f7ff fff0 	bl	341a39cc <__sfp_lock_acquire>
341a39ec:	6a23      	ldr	r3, [r4, #32]
341a39ee:	b11b      	cbz	r3, 341a39f8 <__sinit+0x14>
341a39f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a39f4:	f7ff bff0 	b.w	341a39d8 <__sfp_lock_release>
341a39f8:	4b04      	ldr	r3, [pc, #16]	@ (341a3a0c <__sinit+0x28>)
341a39fa:	6223      	str	r3, [r4, #32]
341a39fc:	4b04      	ldr	r3, [pc, #16]	@ (341a3a10 <__sinit+0x2c>)
341a39fe:	681b      	ldr	r3, [r3, #0]
341a3a00:	2b00      	cmp	r3, #0
341a3a02:	d1f5      	bne.n	341a39f0 <__sinit+0xc>
341a3a04:	f7ff ffc4 	bl	341a3990 <global_stdio_init.part.0>
341a3a08:	e7f2      	b.n	341a39f0 <__sinit+0xc>
341a3a0a:	bf00      	nop
341a3a0c:	341a3951 	.word	0x341a3951
341a3a10:	341c1e44 	.word	0x341c1e44

341a3a14 <fiprintf>:
341a3a14:	b40e      	push	{r1, r2, r3}
341a3a16:	b503      	push	{r0, r1, lr}
341a3a18:	ab03      	add	r3, sp, #12
341a3a1a:	4601      	mov	r1, r0
341a3a1c:	4805      	ldr	r0, [pc, #20]	@ (341a3a34 <fiprintf+0x20>)
341a3a1e:	f853 2b04 	ldr.w	r2, [r3], #4
341a3a22:	6800      	ldr	r0, [r0, #0]
341a3a24:	9301      	str	r3, [sp, #4]
341a3a26:	f000 fcc7 	bl	341a43b8 <_vfiprintf_r>
341a3a2a:	b002      	add	sp, #8
341a3a2c:	f85d eb04 	ldr.w	lr, [sp], #4
341a3a30:	b003      	add	sp, #12
341a3a32:	4770      	bx	lr
341a3a34:	341c0140 	.word	0x341c0140

341a3a38 <_fwalk_sglue>:
341a3a38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
341a3a3c:	4607      	mov	r7, r0
341a3a3e:	4688      	mov	r8, r1
341a3a40:	4614      	mov	r4, r2
341a3a42:	2600      	movs	r6, #0
341a3a44:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
341a3a48:	f1b9 0901 	subs.w	r9, r9, #1
341a3a4c:	d505      	bpl.n	341a3a5a <_fwalk_sglue+0x22>
341a3a4e:	6824      	ldr	r4, [r4, #0]
341a3a50:	2c00      	cmp	r4, #0
341a3a52:	d1f7      	bne.n	341a3a44 <_fwalk_sglue+0xc>
341a3a54:	4630      	mov	r0, r6
341a3a56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
341a3a5a:	89ab      	ldrh	r3, [r5, #12]
341a3a5c:	2b01      	cmp	r3, #1
341a3a5e:	d907      	bls.n	341a3a70 <_fwalk_sglue+0x38>
341a3a60:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
341a3a64:	3301      	adds	r3, #1
341a3a66:	d003      	beq.n	341a3a70 <_fwalk_sglue+0x38>
341a3a68:	4629      	mov	r1, r5
341a3a6a:	4638      	mov	r0, r7
341a3a6c:	47c0      	blx	r8
341a3a6e:	4306      	orrs	r6, r0
341a3a70:	3568      	adds	r5, #104	@ 0x68
341a3a72:	e7e9      	b.n	341a3a48 <_fwalk_sglue+0x10>

341a3a74 <iprintf>:
341a3a74:	b40f      	push	{r0, r1, r2, r3}
341a3a76:	b507      	push	{r0, r1, r2, lr}
341a3a78:	4906      	ldr	r1, [pc, #24]	@ (341a3a94 <iprintf+0x20>)
341a3a7a:	ab04      	add	r3, sp, #16
341a3a7c:	6808      	ldr	r0, [r1, #0]
341a3a7e:	f853 2b04 	ldr.w	r2, [r3], #4
341a3a82:	6881      	ldr	r1, [r0, #8]
341a3a84:	9301      	str	r3, [sp, #4]
341a3a86:	f000 fc97 	bl	341a43b8 <_vfiprintf_r>
341a3a8a:	b003      	add	sp, #12
341a3a8c:	f85d eb04 	ldr.w	lr, [sp], #4
341a3a90:	b004      	add	sp, #16
341a3a92:	4770      	bx	lr
341a3a94:	341c0140 	.word	0x341c0140

341a3a98 <_puts_r>:
341a3a98:	6a03      	ldr	r3, [r0, #32]
341a3a9a:	b570      	push	{r4, r5, r6, lr}
341a3a9c:	4605      	mov	r5, r0
341a3a9e:	460e      	mov	r6, r1
341a3aa0:	6884      	ldr	r4, [r0, #8]
341a3aa2:	b90b      	cbnz	r3, 341a3aa8 <_puts_r+0x10>
341a3aa4:	f7ff ff9e 	bl	341a39e4 <__sinit>
341a3aa8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a3aaa:	07db      	lsls	r3, r3, #31
341a3aac:	d405      	bmi.n	341a3aba <_puts_r+0x22>
341a3aae:	89a3      	ldrh	r3, [r4, #12]
341a3ab0:	0598      	lsls	r0, r3, #22
341a3ab2:	d402      	bmi.n	341a3aba <_puts_r+0x22>
341a3ab4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a3ab6:	f000 f9ee 	bl	341a3e96 <__retarget_lock_acquire_recursive>
341a3aba:	89a3      	ldrh	r3, [r4, #12]
341a3abc:	0719      	lsls	r1, r3, #28
341a3abe:	d502      	bpl.n	341a3ac6 <_puts_r+0x2e>
341a3ac0:	6923      	ldr	r3, [r4, #16]
341a3ac2:	2b00      	cmp	r3, #0
341a3ac4:	d135      	bne.n	341a3b32 <_puts_r+0x9a>
341a3ac6:	4621      	mov	r1, r4
341a3ac8:	4628      	mov	r0, r5
341a3aca:	f000 f8fb 	bl	341a3cc4 <__swsetup_r>
341a3ace:	b380      	cbz	r0, 341a3b32 <_puts_r+0x9a>
341a3ad0:	f04f 35ff 	mov.w	r5, #4294967295
341a3ad4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a3ad6:	07da      	lsls	r2, r3, #31
341a3ad8:	d405      	bmi.n	341a3ae6 <_puts_r+0x4e>
341a3ada:	89a3      	ldrh	r3, [r4, #12]
341a3adc:	059b      	lsls	r3, r3, #22
341a3ade:	d402      	bmi.n	341a3ae6 <_puts_r+0x4e>
341a3ae0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a3ae2:	f000 f9d9 	bl	341a3e98 <__retarget_lock_release_recursive>
341a3ae6:	4628      	mov	r0, r5
341a3ae8:	bd70      	pop	{r4, r5, r6, pc}
341a3aea:	2b00      	cmp	r3, #0
341a3aec:	da04      	bge.n	341a3af8 <_puts_r+0x60>
341a3aee:	69a2      	ldr	r2, [r4, #24]
341a3af0:	429a      	cmp	r2, r3
341a3af2:	dc17      	bgt.n	341a3b24 <_puts_r+0x8c>
341a3af4:	290a      	cmp	r1, #10
341a3af6:	d015      	beq.n	341a3b24 <_puts_r+0x8c>
341a3af8:	6823      	ldr	r3, [r4, #0]
341a3afa:	1c5a      	adds	r2, r3, #1
341a3afc:	6022      	str	r2, [r4, #0]
341a3afe:	7019      	strb	r1, [r3, #0]
341a3b00:	68a3      	ldr	r3, [r4, #8]
341a3b02:	f816 1f01 	ldrb.w	r1, [r6, #1]!
341a3b06:	3b01      	subs	r3, #1
341a3b08:	60a3      	str	r3, [r4, #8]
341a3b0a:	2900      	cmp	r1, #0
341a3b0c:	d1ed      	bne.n	341a3aea <_puts_r+0x52>
341a3b0e:	2b00      	cmp	r3, #0
341a3b10:	da11      	bge.n	341a3b36 <_puts_r+0x9e>
341a3b12:	4622      	mov	r2, r4
341a3b14:	210a      	movs	r1, #10
341a3b16:	4628      	mov	r0, r5
341a3b18:	f000 f895 	bl	341a3c46 <__swbuf_r>
341a3b1c:	3001      	adds	r0, #1
341a3b1e:	d0d7      	beq.n	341a3ad0 <_puts_r+0x38>
341a3b20:	250a      	movs	r5, #10
341a3b22:	e7d7      	b.n	341a3ad4 <_puts_r+0x3c>
341a3b24:	4622      	mov	r2, r4
341a3b26:	4628      	mov	r0, r5
341a3b28:	f000 f88d 	bl	341a3c46 <__swbuf_r>
341a3b2c:	3001      	adds	r0, #1
341a3b2e:	d1e7      	bne.n	341a3b00 <_puts_r+0x68>
341a3b30:	e7ce      	b.n	341a3ad0 <_puts_r+0x38>
341a3b32:	3e01      	subs	r6, #1
341a3b34:	e7e4      	b.n	341a3b00 <_puts_r+0x68>
341a3b36:	6823      	ldr	r3, [r4, #0]
341a3b38:	1c5a      	adds	r2, r3, #1
341a3b3a:	6022      	str	r2, [r4, #0]
341a3b3c:	220a      	movs	r2, #10
341a3b3e:	701a      	strb	r2, [r3, #0]
341a3b40:	e7ee      	b.n	341a3b20 <_puts_r+0x88>
	...

341a3b44 <puts>:
341a3b44:	4b02      	ldr	r3, [pc, #8]	@ (341a3b50 <puts+0xc>)
341a3b46:	4601      	mov	r1, r0
341a3b48:	6818      	ldr	r0, [r3, #0]
341a3b4a:	f7ff bfa5 	b.w	341a3a98 <_puts_r>
341a3b4e:	bf00      	nop
341a3b50:	341c0140 	.word	0x341c0140

341a3b54 <sniprintf>:
341a3b54:	b40c      	push	{r2, r3}
341a3b56:	4b19      	ldr	r3, [pc, #100]	@ (341a3bbc <sniprintf+0x68>)
341a3b58:	b530      	push	{r4, r5, lr}
341a3b5a:	1e0c      	subs	r4, r1, #0
341a3b5c:	b09d      	sub	sp, #116	@ 0x74
341a3b5e:	681d      	ldr	r5, [r3, #0]
341a3b60:	da08      	bge.n	341a3b74 <sniprintf+0x20>
341a3b62:	238b      	movs	r3, #139	@ 0x8b
341a3b64:	f04f 30ff 	mov.w	r0, #4294967295
341a3b68:	602b      	str	r3, [r5, #0]
341a3b6a:	b01d      	add	sp, #116	@ 0x74
341a3b6c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a3b70:	b002      	add	sp, #8
341a3b72:	4770      	bx	lr
341a3b74:	f44f 7302 	mov.w	r3, #520	@ 0x208
341a3b78:	9002      	str	r0, [sp, #8]
341a3b7a:	9006      	str	r0, [sp, #24]
341a3b7c:	a902      	add	r1, sp, #8
341a3b7e:	f8ad 3014 	strh.w	r3, [sp, #20]
341a3b82:	f04f 0300 	mov.w	r3, #0
341a3b86:	9a20      	ldr	r2, [sp, #128]	@ 0x80
341a3b88:	4628      	mov	r0, r5
341a3b8a:	931b      	str	r3, [sp, #108]	@ 0x6c
341a3b8c:	bf14      	ite	ne
341a3b8e:	f104 33ff 	addne.w	r3, r4, #4294967295
341a3b92:	4623      	moveq	r3, r4
341a3b94:	9304      	str	r3, [sp, #16]
341a3b96:	9307      	str	r3, [sp, #28]
341a3b98:	f64f 73ff 	movw	r3, #65535	@ 0xffff
341a3b9c:	f8ad 3016 	strh.w	r3, [sp, #22]
341a3ba0:	ab21      	add	r3, sp, #132	@ 0x84
341a3ba2:	9301      	str	r3, [sp, #4]
341a3ba4:	f000 fae2 	bl	341a416c <_svfiprintf_r>
341a3ba8:	1c43      	adds	r3, r0, #1
341a3baa:	bfbc      	itt	lt
341a3bac:	238b      	movlt	r3, #139	@ 0x8b
341a3bae:	602b      	strlt	r3, [r5, #0]
341a3bb0:	2c00      	cmp	r4, #0
341a3bb2:	d0da      	beq.n	341a3b6a <sniprintf+0x16>
341a3bb4:	9b02      	ldr	r3, [sp, #8]
341a3bb6:	2200      	movs	r2, #0
341a3bb8:	701a      	strb	r2, [r3, #0]
341a3bba:	e7d6      	b.n	341a3b6a <sniprintf+0x16>
341a3bbc:	341c0140 	.word	0x341c0140

341a3bc0 <__sread>:
341a3bc0:	b510      	push	{r4, lr}
341a3bc2:	460c      	mov	r4, r1
341a3bc4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a3bc8:	f000 f916 	bl	341a3df8 <_read_r>
341a3bcc:	2800      	cmp	r0, #0
341a3bce:	bfab      	itete	ge
341a3bd0:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
341a3bd2:	89a3      	ldrhlt	r3, [r4, #12]
341a3bd4:	181b      	addge	r3, r3, r0
341a3bd6:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
341a3bda:	bfac      	ite	ge
341a3bdc:	6563      	strge	r3, [r4, #84]	@ 0x54
341a3bde:	81a3      	strhlt	r3, [r4, #12]
341a3be0:	bd10      	pop	{r4, pc}

341a3be2 <__swrite>:
341a3be2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a3be6:	461f      	mov	r7, r3
341a3be8:	898b      	ldrh	r3, [r1, #12]
341a3bea:	4605      	mov	r5, r0
341a3bec:	460c      	mov	r4, r1
341a3bee:	05db      	lsls	r3, r3, #23
341a3bf0:	4616      	mov	r6, r2
341a3bf2:	d505      	bpl.n	341a3c00 <__swrite+0x1e>
341a3bf4:	2302      	movs	r3, #2
341a3bf6:	2200      	movs	r2, #0
341a3bf8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a3bfc:	f000 f8ea 	bl	341a3dd4 <_lseek_r>
341a3c00:	89a3      	ldrh	r3, [r4, #12]
341a3c02:	4632      	mov	r2, r6
341a3c04:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
341a3c08:	4628      	mov	r0, r5
341a3c0a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
341a3c0e:	81a3      	strh	r3, [r4, #12]
341a3c10:	463b      	mov	r3, r7
341a3c12:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
341a3c16:	f000 b901 	b.w	341a3e1c <_write_r>

341a3c1a <__sseek>:
341a3c1a:	b510      	push	{r4, lr}
341a3c1c:	460c      	mov	r4, r1
341a3c1e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a3c22:	f000 f8d7 	bl	341a3dd4 <_lseek_r>
341a3c26:	1c43      	adds	r3, r0, #1
341a3c28:	89a3      	ldrh	r3, [r4, #12]
341a3c2a:	bf15      	itete	ne
341a3c2c:	6560      	strne	r0, [r4, #84]	@ 0x54
341a3c2e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
341a3c32:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
341a3c36:	81a3      	strheq	r3, [r4, #12]
341a3c38:	bf18      	it	ne
341a3c3a:	81a3      	strhne	r3, [r4, #12]
341a3c3c:	bd10      	pop	{r4, pc}

341a3c3e <__sclose>:
341a3c3e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a3c42:	f000 b8b7 	b.w	341a3db4 <_close_r>

341a3c46 <__swbuf_r>:
341a3c46:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a3c48:	460e      	mov	r6, r1
341a3c4a:	4614      	mov	r4, r2
341a3c4c:	4605      	mov	r5, r0
341a3c4e:	b118      	cbz	r0, 341a3c58 <__swbuf_r+0x12>
341a3c50:	6a03      	ldr	r3, [r0, #32]
341a3c52:	b90b      	cbnz	r3, 341a3c58 <__swbuf_r+0x12>
341a3c54:	f7ff fec6 	bl	341a39e4 <__sinit>
341a3c58:	69a3      	ldr	r3, [r4, #24]
341a3c5a:	60a3      	str	r3, [r4, #8]
341a3c5c:	89a3      	ldrh	r3, [r4, #12]
341a3c5e:	071a      	lsls	r2, r3, #28
341a3c60:	d501      	bpl.n	341a3c66 <__swbuf_r+0x20>
341a3c62:	6923      	ldr	r3, [r4, #16]
341a3c64:	b943      	cbnz	r3, 341a3c78 <__swbuf_r+0x32>
341a3c66:	4621      	mov	r1, r4
341a3c68:	4628      	mov	r0, r5
341a3c6a:	f000 f82b 	bl	341a3cc4 <__swsetup_r>
341a3c6e:	b118      	cbz	r0, 341a3c78 <__swbuf_r+0x32>
341a3c70:	f04f 37ff 	mov.w	r7, #4294967295
341a3c74:	4638      	mov	r0, r7
341a3c76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
341a3c78:	6823      	ldr	r3, [r4, #0]
341a3c7a:	b2f6      	uxtb	r6, r6
341a3c7c:	6922      	ldr	r2, [r4, #16]
341a3c7e:	4637      	mov	r7, r6
341a3c80:	1a98      	subs	r0, r3, r2
341a3c82:	6963      	ldr	r3, [r4, #20]
341a3c84:	4283      	cmp	r3, r0
341a3c86:	dc05      	bgt.n	341a3c94 <__swbuf_r+0x4e>
341a3c88:	4621      	mov	r1, r4
341a3c8a:	4628      	mov	r0, r5
341a3c8c:	f000 fec0 	bl	341a4a10 <_fflush_r>
341a3c90:	2800      	cmp	r0, #0
341a3c92:	d1ed      	bne.n	341a3c70 <__swbuf_r+0x2a>
341a3c94:	68a3      	ldr	r3, [r4, #8]
341a3c96:	3b01      	subs	r3, #1
341a3c98:	60a3      	str	r3, [r4, #8]
341a3c9a:	6823      	ldr	r3, [r4, #0]
341a3c9c:	1c5a      	adds	r2, r3, #1
341a3c9e:	6022      	str	r2, [r4, #0]
341a3ca0:	701e      	strb	r6, [r3, #0]
341a3ca2:	1c43      	adds	r3, r0, #1
341a3ca4:	6962      	ldr	r2, [r4, #20]
341a3ca6:	429a      	cmp	r2, r3
341a3ca8:	d004      	beq.n	341a3cb4 <__swbuf_r+0x6e>
341a3caa:	89a3      	ldrh	r3, [r4, #12]
341a3cac:	07db      	lsls	r3, r3, #31
341a3cae:	d5e1      	bpl.n	341a3c74 <__swbuf_r+0x2e>
341a3cb0:	2e0a      	cmp	r6, #10
341a3cb2:	d1df      	bne.n	341a3c74 <__swbuf_r+0x2e>
341a3cb4:	4621      	mov	r1, r4
341a3cb6:	4628      	mov	r0, r5
341a3cb8:	f000 feaa 	bl	341a4a10 <_fflush_r>
341a3cbc:	2800      	cmp	r0, #0
341a3cbe:	d0d9      	beq.n	341a3c74 <__swbuf_r+0x2e>
341a3cc0:	e7d6      	b.n	341a3c70 <__swbuf_r+0x2a>
	...

341a3cc4 <__swsetup_r>:
341a3cc4:	b538      	push	{r3, r4, r5, lr}
341a3cc6:	4b29      	ldr	r3, [pc, #164]	@ (341a3d6c <__swsetup_r+0xa8>)
341a3cc8:	4605      	mov	r5, r0
341a3cca:	460c      	mov	r4, r1
341a3ccc:	6818      	ldr	r0, [r3, #0]
341a3cce:	b118      	cbz	r0, 341a3cd8 <__swsetup_r+0x14>
341a3cd0:	6a03      	ldr	r3, [r0, #32]
341a3cd2:	b90b      	cbnz	r3, 341a3cd8 <__swsetup_r+0x14>
341a3cd4:	f7ff fe86 	bl	341a39e4 <__sinit>
341a3cd8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a3cdc:	0719      	lsls	r1, r3, #28
341a3cde:	d422      	bmi.n	341a3d26 <__swsetup_r+0x62>
341a3ce0:	06da      	lsls	r2, r3, #27
341a3ce2:	d407      	bmi.n	341a3cf4 <__swsetup_r+0x30>
341a3ce4:	2209      	movs	r2, #9
341a3ce6:	602a      	str	r2, [r5, #0]
341a3ce8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a3cec:	f04f 30ff 	mov.w	r0, #4294967295
341a3cf0:	81a3      	strh	r3, [r4, #12]
341a3cf2:	e033      	b.n	341a3d5c <__swsetup_r+0x98>
341a3cf4:	0758      	lsls	r0, r3, #29
341a3cf6:	d512      	bpl.n	341a3d1e <__swsetup_r+0x5a>
341a3cf8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
341a3cfa:	b141      	cbz	r1, 341a3d0e <__swsetup_r+0x4a>
341a3cfc:	f104 0344 	add.w	r3, r4, #68	@ 0x44
341a3d00:	4299      	cmp	r1, r3
341a3d02:	d002      	beq.n	341a3d0a <__swsetup_r+0x46>
341a3d04:	4628      	mov	r0, r5
341a3d06:	f000 f8dd 	bl	341a3ec4 <_free_r>
341a3d0a:	2300      	movs	r3, #0
341a3d0c:	6363      	str	r3, [r4, #52]	@ 0x34
341a3d0e:	89a3      	ldrh	r3, [r4, #12]
341a3d10:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
341a3d14:	81a3      	strh	r3, [r4, #12]
341a3d16:	2300      	movs	r3, #0
341a3d18:	6063      	str	r3, [r4, #4]
341a3d1a:	6923      	ldr	r3, [r4, #16]
341a3d1c:	6023      	str	r3, [r4, #0]
341a3d1e:	89a3      	ldrh	r3, [r4, #12]
341a3d20:	f043 0308 	orr.w	r3, r3, #8
341a3d24:	81a3      	strh	r3, [r4, #12]
341a3d26:	6923      	ldr	r3, [r4, #16]
341a3d28:	b94b      	cbnz	r3, 341a3d3e <__swsetup_r+0x7a>
341a3d2a:	89a3      	ldrh	r3, [r4, #12]
341a3d2c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
341a3d30:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a3d34:	d003      	beq.n	341a3d3e <__swsetup_r+0x7a>
341a3d36:	4621      	mov	r1, r4
341a3d38:	4628      	mov	r0, r5
341a3d3a:	f000 feb6 	bl	341a4aaa <__smakebuf_r>
341a3d3e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a3d42:	f013 0201 	ands.w	r2, r3, #1
341a3d46:	d00a      	beq.n	341a3d5e <__swsetup_r+0x9a>
341a3d48:	2200      	movs	r2, #0
341a3d4a:	60a2      	str	r2, [r4, #8]
341a3d4c:	6962      	ldr	r2, [r4, #20]
341a3d4e:	4252      	negs	r2, r2
341a3d50:	61a2      	str	r2, [r4, #24]
341a3d52:	6922      	ldr	r2, [r4, #16]
341a3d54:	b942      	cbnz	r2, 341a3d68 <__swsetup_r+0xa4>
341a3d56:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
341a3d5a:	d1c5      	bne.n	341a3ce8 <__swsetup_r+0x24>
341a3d5c:	bd38      	pop	{r3, r4, r5, pc}
341a3d5e:	0799      	lsls	r1, r3, #30
341a3d60:	bf58      	it	pl
341a3d62:	6962      	ldrpl	r2, [r4, #20]
341a3d64:	60a2      	str	r2, [r4, #8]
341a3d66:	e7f4      	b.n	341a3d52 <__swsetup_r+0x8e>
341a3d68:	2000      	movs	r0, #0
341a3d6a:	e7f7      	b.n	341a3d5c <__swsetup_r+0x98>
341a3d6c:	341c0140 	.word	0x341c0140

341a3d70 <memmove>:
341a3d70:	4288      	cmp	r0, r1
341a3d72:	b510      	push	{r4, lr}
341a3d74:	eb01 0402 	add.w	r4, r1, r2
341a3d78:	d902      	bls.n	341a3d80 <memmove+0x10>
341a3d7a:	4284      	cmp	r4, r0
341a3d7c:	4623      	mov	r3, r4
341a3d7e:	d807      	bhi.n	341a3d90 <memmove+0x20>
341a3d80:	1e43      	subs	r3, r0, #1
341a3d82:	42a1      	cmp	r1, r4
341a3d84:	d008      	beq.n	341a3d98 <memmove+0x28>
341a3d86:	f811 2b01 	ldrb.w	r2, [r1], #1
341a3d8a:	f803 2f01 	strb.w	r2, [r3, #1]!
341a3d8e:	e7f8      	b.n	341a3d82 <memmove+0x12>
341a3d90:	4402      	add	r2, r0
341a3d92:	4601      	mov	r1, r0
341a3d94:	428a      	cmp	r2, r1
341a3d96:	d100      	bne.n	341a3d9a <memmove+0x2a>
341a3d98:	bd10      	pop	{r4, pc}
341a3d9a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
341a3d9e:	f802 4d01 	strb.w	r4, [r2, #-1]!
341a3da2:	e7f7      	b.n	341a3d94 <memmove+0x24>

341a3da4 <memset>:
341a3da4:	4402      	add	r2, r0
341a3da6:	4603      	mov	r3, r0
341a3da8:	4293      	cmp	r3, r2
341a3daa:	d100      	bne.n	341a3dae <memset+0xa>
341a3dac:	4770      	bx	lr
341a3dae:	f803 1b01 	strb.w	r1, [r3], #1
341a3db2:	e7f9      	b.n	341a3da8 <memset+0x4>

341a3db4 <_close_r>:
341a3db4:	b538      	push	{r3, r4, r5, lr}
341a3db6:	2300      	movs	r3, #0
341a3db8:	4d05      	ldr	r5, [pc, #20]	@ (341a3dd0 <_close_r+0x1c>)
341a3dba:	4604      	mov	r4, r0
341a3dbc:	4608      	mov	r0, r1
341a3dbe:	602b      	str	r3, [r5, #0]
341a3dc0:	f7df f8b2 	bl	34182f28 <_close>
341a3dc4:	1c43      	adds	r3, r0, #1
341a3dc6:	d102      	bne.n	341a3dce <_close_r+0x1a>
341a3dc8:	682b      	ldr	r3, [r5, #0]
341a3dca:	b103      	cbz	r3, 341a3dce <_close_r+0x1a>
341a3dcc:	6023      	str	r3, [r4, #0]
341a3dce:	bd38      	pop	{r3, r4, r5, pc}
341a3dd0:	341c1e48 	.word	0x341c1e48

341a3dd4 <_lseek_r>:
341a3dd4:	b538      	push	{r3, r4, r5, lr}
341a3dd6:	4604      	mov	r4, r0
341a3dd8:	4d06      	ldr	r5, [pc, #24]	@ (341a3df4 <_lseek_r+0x20>)
341a3dda:	4608      	mov	r0, r1
341a3ddc:	4611      	mov	r1, r2
341a3dde:	2200      	movs	r2, #0
341a3de0:	602a      	str	r2, [r5, #0]
341a3de2:	461a      	mov	r2, r3
341a3de4:	f7df f8c7 	bl	34182f76 <_lseek>
341a3de8:	1c43      	adds	r3, r0, #1
341a3dea:	d102      	bne.n	341a3df2 <_lseek_r+0x1e>
341a3dec:	682b      	ldr	r3, [r5, #0]
341a3dee:	b103      	cbz	r3, 341a3df2 <_lseek_r+0x1e>
341a3df0:	6023      	str	r3, [r4, #0]
341a3df2:	bd38      	pop	{r3, r4, r5, pc}
341a3df4:	341c1e48 	.word	0x341c1e48

341a3df8 <_read_r>:
341a3df8:	b538      	push	{r3, r4, r5, lr}
341a3dfa:	4604      	mov	r4, r0
341a3dfc:	4d06      	ldr	r5, [pc, #24]	@ (341a3e18 <_read_r+0x20>)
341a3dfe:	4608      	mov	r0, r1
341a3e00:	4611      	mov	r1, r2
341a3e02:	2200      	movs	r2, #0
341a3e04:	602a      	str	r2, [r5, #0]
341a3e06:	461a      	mov	r2, r3
341a3e08:	f7df f855 	bl	34182eb6 <_read>
341a3e0c:	1c43      	adds	r3, r0, #1
341a3e0e:	d102      	bne.n	341a3e16 <_read_r+0x1e>
341a3e10:	682b      	ldr	r3, [r5, #0]
341a3e12:	b103      	cbz	r3, 341a3e16 <_read_r+0x1e>
341a3e14:	6023      	str	r3, [r4, #0]
341a3e16:	bd38      	pop	{r3, r4, r5, pc}
341a3e18:	341c1e48 	.word	0x341c1e48

341a3e1c <_write_r>:
341a3e1c:	b538      	push	{r3, r4, r5, lr}
341a3e1e:	4604      	mov	r4, r0
341a3e20:	4d06      	ldr	r5, [pc, #24]	@ (341a3e3c <_write_r+0x20>)
341a3e22:	4608      	mov	r0, r1
341a3e24:	4611      	mov	r1, r2
341a3e26:	2200      	movs	r2, #0
341a3e28:	602a      	str	r2, [r5, #0]
341a3e2a:	461a      	mov	r2, r3
341a3e2c:	f7df f860 	bl	34182ef0 <_write>
341a3e30:	1c43      	adds	r3, r0, #1
341a3e32:	d102      	bne.n	341a3e3a <_write_r+0x1e>
341a3e34:	682b      	ldr	r3, [r5, #0]
341a3e36:	b103      	cbz	r3, 341a3e3a <_write_r+0x1e>
341a3e38:	6023      	str	r3, [r4, #0]
341a3e3a:	bd38      	pop	{r3, r4, r5, pc}
341a3e3c:	341c1e48 	.word	0x341c1e48

341a3e40 <__errno>:
341a3e40:	4b01      	ldr	r3, [pc, #4]	@ (341a3e48 <__errno+0x8>)
341a3e42:	6818      	ldr	r0, [r3, #0]
341a3e44:	4770      	bx	lr
341a3e46:	bf00      	nop
341a3e48:	341c0140 	.word	0x341c0140

341a3e4c <__libc_init_array>:
341a3e4c:	b570      	push	{r4, r5, r6, lr}
341a3e4e:	4d0d      	ldr	r5, [pc, #52]	@ (341a3e84 <__libc_init_array+0x38>)
341a3e50:	2600      	movs	r6, #0
341a3e52:	4c0d      	ldr	r4, [pc, #52]	@ (341a3e88 <__libc_init_array+0x3c>)
341a3e54:	1b64      	subs	r4, r4, r5
341a3e56:	10a4      	asrs	r4, r4, #2
341a3e58:	42a6      	cmp	r6, r4
341a3e5a:	d109      	bne.n	341a3e70 <__libc_init_array+0x24>
341a3e5c:	4d0b      	ldr	r5, [pc, #44]	@ (341a3e8c <__libc_init_array+0x40>)
341a3e5e:	2600      	movs	r6, #0
341a3e60:	4c0b      	ldr	r4, [pc, #44]	@ (341a3e90 <__libc_init_array+0x44>)
341a3e62:	f001 fda1 	bl	341a59a8 <_init>
341a3e66:	1b64      	subs	r4, r4, r5
341a3e68:	10a4      	asrs	r4, r4, #2
341a3e6a:	42a6      	cmp	r6, r4
341a3e6c:	d105      	bne.n	341a3e7a <__libc_init_array+0x2e>
341a3e6e:	bd70      	pop	{r4, r5, r6, pc}
341a3e70:	f855 3b04 	ldr.w	r3, [r5], #4
341a3e74:	3601      	adds	r6, #1
341a3e76:	4798      	blx	r3
341a3e78:	e7ee      	b.n	341a3e58 <__libc_init_array+0xc>
341a3e7a:	f855 3b04 	ldr.w	r3, [r5], #4
341a3e7e:	3601      	adds	r6, #1
341a3e80:	4798      	blx	r3
341a3e82:	e7f2      	b.n	341a3e6a <__libc_init_array+0x1e>
341a3e84:	341ba15c 	.word	0x341ba15c
341a3e88:	341ba15c 	.word	0x341ba15c
341a3e8c:	341ba15c 	.word	0x341ba15c
341a3e90:	341ba160 	.word	0x341ba160

341a3e94 <__retarget_lock_init_recursive>:
341a3e94:	4770      	bx	lr

341a3e96 <__retarget_lock_acquire_recursive>:
341a3e96:	4770      	bx	lr

341a3e98 <__retarget_lock_release_recursive>:
341a3e98:	4770      	bx	lr

341a3e9a <memcpy>:
341a3e9a:	440a      	add	r2, r1
341a3e9c:	1e43      	subs	r3, r0, #1
341a3e9e:	4291      	cmp	r1, r2
341a3ea0:	d100      	bne.n	341a3ea4 <memcpy+0xa>
341a3ea2:	4770      	bx	lr
341a3ea4:	b510      	push	{r4, lr}
341a3ea6:	f811 4b01 	ldrb.w	r4, [r1], #1
341a3eaa:	4291      	cmp	r1, r2
341a3eac:	f803 4f01 	strb.w	r4, [r3, #1]!
341a3eb0:	d1f9      	bne.n	341a3ea6 <memcpy+0xc>
341a3eb2:	bd10      	pop	{r4, pc}

341a3eb4 <abort>:
341a3eb4:	2006      	movs	r0, #6
341a3eb6:	b508      	push	{r3, lr}
341a3eb8:	f000 fe5c 	bl	341a4b74 <raise>
341a3ebc:	2001      	movs	r0, #1
341a3ebe:	f7de ffef 	bl	34182ea0 <_exit>
	...

341a3ec4 <_free_r>:
341a3ec4:	b538      	push	{r3, r4, r5, lr}
341a3ec6:	4605      	mov	r5, r0
341a3ec8:	2900      	cmp	r1, #0
341a3eca:	d041      	beq.n	341a3f50 <_free_r+0x8c>
341a3ecc:	f851 3c04 	ldr.w	r3, [r1, #-4]
341a3ed0:	1f0c      	subs	r4, r1, #4
341a3ed2:	2b00      	cmp	r3, #0
341a3ed4:	bfb8      	it	lt
341a3ed6:	18e4      	addlt	r4, r4, r3
341a3ed8:	f000 f8e0 	bl	341a409c <__malloc_lock>
341a3edc:	4a1d      	ldr	r2, [pc, #116]	@ (341a3f54 <_free_r+0x90>)
341a3ede:	6813      	ldr	r3, [r2, #0]
341a3ee0:	b933      	cbnz	r3, 341a3ef0 <_free_r+0x2c>
341a3ee2:	6063      	str	r3, [r4, #4]
341a3ee4:	6014      	str	r4, [r2, #0]
341a3ee6:	4628      	mov	r0, r5
341a3ee8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
341a3eec:	f000 b8dc 	b.w	341a40a8 <__malloc_unlock>
341a3ef0:	42a3      	cmp	r3, r4
341a3ef2:	d908      	bls.n	341a3f06 <_free_r+0x42>
341a3ef4:	6820      	ldr	r0, [r4, #0]
341a3ef6:	1821      	adds	r1, r4, r0
341a3ef8:	428b      	cmp	r3, r1
341a3efa:	bf01      	itttt	eq
341a3efc:	6819      	ldreq	r1, [r3, #0]
341a3efe:	685b      	ldreq	r3, [r3, #4]
341a3f00:	1809      	addeq	r1, r1, r0
341a3f02:	6021      	streq	r1, [r4, #0]
341a3f04:	e7ed      	b.n	341a3ee2 <_free_r+0x1e>
341a3f06:	461a      	mov	r2, r3
341a3f08:	685b      	ldr	r3, [r3, #4]
341a3f0a:	b10b      	cbz	r3, 341a3f10 <_free_r+0x4c>
341a3f0c:	42a3      	cmp	r3, r4
341a3f0e:	d9fa      	bls.n	341a3f06 <_free_r+0x42>
341a3f10:	6811      	ldr	r1, [r2, #0]
341a3f12:	1850      	adds	r0, r2, r1
341a3f14:	42a0      	cmp	r0, r4
341a3f16:	d10b      	bne.n	341a3f30 <_free_r+0x6c>
341a3f18:	6820      	ldr	r0, [r4, #0]
341a3f1a:	4401      	add	r1, r0
341a3f1c:	1850      	adds	r0, r2, r1
341a3f1e:	6011      	str	r1, [r2, #0]
341a3f20:	4283      	cmp	r3, r0
341a3f22:	d1e0      	bne.n	341a3ee6 <_free_r+0x22>
341a3f24:	6818      	ldr	r0, [r3, #0]
341a3f26:	685b      	ldr	r3, [r3, #4]
341a3f28:	4408      	add	r0, r1
341a3f2a:	6053      	str	r3, [r2, #4]
341a3f2c:	6010      	str	r0, [r2, #0]
341a3f2e:	e7da      	b.n	341a3ee6 <_free_r+0x22>
341a3f30:	d902      	bls.n	341a3f38 <_free_r+0x74>
341a3f32:	230c      	movs	r3, #12
341a3f34:	602b      	str	r3, [r5, #0]
341a3f36:	e7d6      	b.n	341a3ee6 <_free_r+0x22>
341a3f38:	6820      	ldr	r0, [r4, #0]
341a3f3a:	1821      	adds	r1, r4, r0
341a3f3c:	428b      	cmp	r3, r1
341a3f3e:	bf02      	ittt	eq
341a3f40:	6819      	ldreq	r1, [r3, #0]
341a3f42:	685b      	ldreq	r3, [r3, #4]
341a3f44:	1809      	addeq	r1, r1, r0
341a3f46:	6063      	str	r3, [r4, #4]
341a3f48:	bf08      	it	eq
341a3f4a:	6021      	streq	r1, [r4, #0]
341a3f4c:	6054      	str	r4, [r2, #4]
341a3f4e:	e7ca      	b.n	341a3ee6 <_free_r+0x22>
341a3f50:	bd38      	pop	{r3, r4, r5, pc}
341a3f52:	bf00      	nop
341a3f54:	341c1e54 	.word	0x341c1e54

341a3f58 <sbrk_aligned>:
341a3f58:	b570      	push	{r4, r5, r6, lr}
341a3f5a:	4e0f      	ldr	r6, [pc, #60]	@ (341a3f98 <sbrk_aligned+0x40>)
341a3f5c:	460c      	mov	r4, r1
341a3f5e:	4605      	mov	r5, r0
341a3f60:	6831      	ldr	r1, [r6, #0]
341a3f62:	b911      	cbnz	r1, 341a3f6a <sbrk_aligned+0x12>
341a3f64:	f000 fe44 	bl	341a4bf0 <_sbrk_r>
341a3f68:	6030      	str	r0, [r6, #0]
341a3f6a:	4621      	mov	r1, r4
341a3f6c:	4628      	mov	r0, r5
341a3f6e:	f000 fe3f 	bl	341a4bf0 <_sbrk_r>
341a3f72:	1c43      	adds	r3, r0, #1
341a3f74:	d103      	bne.n	341a3f7e <sbrk_aligned+0x26>
341a3f76:	f04f 34ff 	mov.w	r4, #4294967295
341a3f7a:	4620      	mov	r0, r4
341a3f7c:	bd70      	pop	{r4, r5, r6, pc}
341a3f7e:	1cc4      	adds	r4, r0, #3
341a3f80:	f024 0403 	bic.w	r4, r4, #3
341a3f84:	42a0      	cmp	r0, r4
341a3f86:	d0f8      	beq.n	341a3f7a <sbrk_aligned+0x22>
341a3f88:	1a21      	subs	r1, r4, r0
341a3f8a:	4628      	mov	r0, r5
341a3f8c:	f000 fe30 	bl	341a4bf0 <_sbrk_r>
341a3f90:	3001      	adds	r0, #1
341a3f92:	d1f2      	bne.n	341a3f7a <sbrk_aligned+0x22>
341a3f94:	e7ef      	b.n	341a3f76 <sbrk_aligned+0x1e>
341a3f96:	bf00      	nop
341a3f98:	341c1e50 	.word	0x341c1e50

341a3f9c <_malloc_r>:
341a3f9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
341a3fa0:	1ccd      	adds	r5, r1, #3
341a3fa2:	4606      	mov	r6, r0
341a3fa4:	f025 0503 	bic.w	r5, r5, #3
341a3fa8:	3508      	adds	r5, #8
341a3faa:	2d0c      	cmp	r5, #12
341a3fac:	bf38      	it	cc
341a3fae:	250c      	movcc	r5, #12
341a3fb0:	2d00      	cmp	r5, #0
341a3fb2:	db01      	blt.n	341a3fb8 <_malloc_r+0x1c>
341a3fb4:	42a9      	cmp	r1, r5
341a3fb6:	d904      	bls.n	341a3fc2 <_malloc_r+0x26>
341a3fb8:	230c      	movs	r3, #12
341a3fba:	6033      	str	r3, [r6, #0]
341a3fbc:	2000      	movs	r0, #0
341a3fbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
341a3fc2:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 341a4098 <_malloc_r+0xfc>
341a3fc6:	f000 f869 	bl	341a409c <__malloc_lock>
341a3fca:	f8d8 3000 	ldr.w	r3, [r8]
341a3fce:	461c      	mov	r4, r3
341a3fd0:	bb44      	cbnz	r4, 341a4024 <_malloc_r+0x88>
341a3fd2:	4629      	mov	r1, r5
341a3fd4:	4630      	mov	r0, r6
341a3fd6:	f7ff ffbf 	bl	341a3f58 <sbrk_aligned>
341a3fda:	1c43      	adds	r3, r0, #1
341a3fdc:	4604      	mov	r4, r0
341a3fde:	d158      	bne.n	341a4092 <_malloc_r+0xf6>
341a3fe0:	f8d8 4000 	ldr.w	r4, [r8]
341a3fe4:	4627      	mov	r7, r4
341a3fe6:	2f00      	cmp	r7, #0
341a3fe8:	d143      	bne.n	341a4072 <_malloc_r+0xd6>
341a3fea:	2c00      	cmp	r4, #0
341a3fec:	d04b      	beq.n	341a4086 <_malloc_r+0xea>
341a3fee:	6823      	ldr	r3, [r4, #0]
341a3ff0:	4639      	mov	r1, r7
341a3ff2:	4630      	mov	r0, r6
341a3ff4:	eb04 0903 	add.w	r9, r4, r3
341a3ff8:	f000 fdfa 	bl	341a4bf0 <_sbrk_r>
341a3ffc:	4581      	cmp	r9, r0
341a3ffe:	d142      	bne.n	341a4086 <_malloc_r+0xea>
341a4000:	6821      	ldr	r1, [r4, #0]
341a4002:	4630      	mov	r0, r6
341a4004:	1a6d      	subs	r5, r5, r1
341a4006:	4629      	mov	r1, r5
341a4008:	f7ff ffa6 	bl	341a3f58 <sbrk_aligned>
341a400c:	3001      	adds	r0, #1
341a400e:	d03a      	beq.n	341a4086 <_malloc_r+0xea>
341a4010:	6823      	ldr	r3, [r4, #0]
341a4012:	442b      	add	r3, r5
341a4014:	6023      	str	r3, [r4, #0]
341a4016:	f8d8 3000 	ldr.w	r3, [r8]
341a401a:	685a      	ldr	r2, [r3, #4]
341a401c:	bb62      	cbnz	r2, 341a4078 <_malloc_r+0xdc>
341a401e:	f8c8 7000 	str.w	r7, [r8]
341a4022:	e00f      	b.n	341a4044 <_malloc_r+0xa8>
341a4024:	6822      	ldr	r2, [r4, #0]
341a4026:	1b52      	subs	r2, r2, r5
341a4028:	d420      	bmi.n	341a406c <_malloc_r+0xd0>
341a402a:	2a0b      	cmp	r2, #11
341a402c:	d917      	bls.n	341a405e <_malloc_r+0xc2>
341a402e:	1961      	adds	r1, r4, r5
341a4030:	42a3      	cmp	r3, r4
341a4032:	6025      	str	r5, [r4, #0]
341a4034:	bf18      	it	ne
341a4036:	6059      	strne	r1, [r3, #4]
341a4038:	6863      	ldr	r3, [r4, #4]
341a403a:	bf08      	it	eq
341a403c:	f8c8 1000 	streq.w	r1, [r8]
341a4040:	5162      	str	r2, [r4, r5]
341a4042:	604b      	str	r3, [r1, #4]
341a4044:	4630      	mov	r0, r6
341a4046:	f000 f82f 	bl	341a40a8 <__malloc_unlock>
341a404a:	f104 000b 	add.w	r0, r4, #11
341a404e:	1d23      	adds	r3, r4, #4
341a4050:	f020 0007 	bic.w	r0, r0, #7
341a4054:	1ac2      	subs	r2, r0, r3
341a4056:	bf1c      	itt	ne
341a4058:	1a1b      	subne	r3, r3, r0
341a405a:	50a3      	strne	r3, [r4, r2]
341a405c:	e7af      	b.n	341a3fbe <_malloc_r+0x22>
341a405e:	6862      	ldr	r2, [r4, #4]
341a4060:	42a3      	cmp	r3, r4
341a4062:	bf0c      	ite	eq
341a4064:	f8c8 2000 	streq.w	r2, [r8]
341a4068:	605a      	strne	r2, [r3, #4]
341a406a:	e7eb      	b.n	341a4044 <_malloc_r+0xa8>
341a406c:	4623      	mov	r3, r4
341a406e:	6864      	ldr	r4, [r4, #4]
341a4070:	e7ae      	b.n	341a3fd0 <_malloc_r+0x34>
341a4072:	463c      	mov	r4, r7
341a4074:	687f      	ldr	r7, [r7, #4]
341a4076:	e7b6      	b.n	341a3fe6 <_malloc_r+0x4a>
341a4078:	461a      	mov	r2, r3
341a407a:	685b      	ldr	r3, [r3, #4]
341a407c:	42a3      	cmp	r3, r4
341a407e:	d1fb      	bne.n	341a4078 <_malloc_r+0xdc>
341a4080:	2300      	movs	r3, #0
341a4082:	6053      	str	r3, [r2, #4]
341a4084:	e7de      	b.n	341a4044 <_malloc_r+0xa8>
341a4086:	230c      	movs	r3, #12
341a4088:	4630      	mov	r0, r6
341a408a:	6033      	str	r3, [r6, #0]
341a408c:	f000 f80c 	bl	341a40a8 <__malloc_unlock>
341a4090:	e794      	b.n	341a3fbc <_malloc_r+0x20>
341a4092:	6005      	str	r5, [r0, #0]
341a4094:	e7d6      	b.n	341a4044 <_malloc_r+0xa8>
341a4096:	bf00      	nop
341a4098:	341c1e54 	.word	0x341c1e54

341a409c <__malloc_lock>:
341a409c:	4801      	ldr	r0, [pc, #4]	@ (341a40a4 <__malloc_lock+0x8>)
341a409e:	f7ff befa 	b.w	341a3e96 <__retarget_lock_acquire_recursive>
341a40a2:	bf00      	nop
341a40a4:	341c1e4c 	.word	0x341c1e4c

341a40a8 <__malloc_unlock>:
341a40a8:	4801      	ldr	r0, [pc, #4]	@ (341a40b0 <__malloc_unlock+0x8>)
341a40aa:	f7ff bef5 	b.w	341a3e98 <__retarget_lock_release_recursive>
341a40ae:	bf00      	nop
341a40b0:	341c1e4c 	.word	0x341c1e4c

341a40b4 <__ssputs_r>:
341a40b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
341a40b8:	461f      	mov	r7, r3
341a40ba:	688e      	ldr	r6, [r1, #8]
341a40bc:	4682      	mov	sl, r0
341a40be:	460c      	mov	r4, r1
341a40c0:	42be      	cmp	r6, r7
341a40c2:	4690      	mov	r8, r2
341a40c4:	680b      	ldr	r3, [r1, #0]
341a40c6:	d82d      	bhi.n	341a4124 <__ssputs_r+0x70>
341a40c8:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
341a40cc:	f412 6f90 	tst.w	r2, #1152	@ 0x480
341a40d0:	d026      	beq.n	341a4120 <__ssputs_r+0x6c>
341a40d2:	6965      	ldr	r5, [r4, #20]
341a40d4:	6909      	ldr	r1, [r1, #16]
341a40d6:	eb05 0545 	add.w	r5, r5, r5, lsl #1
341a40da:	eba3 0901 	sub.w	r9, r3, r1
341a40de:	1c7b      	adds	r3, r7, #1
341a40e0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
341a40e4:	444b      	add	r3, r9
341a40e6:	106d      	asrs	r5, r5, #1
341a40e8:	429d      	cmp	r5, r3
341a40ea:	bf38      	it	cc
341a40ec:	461d      	movcc	r5, r3
341a40ee:	0553      	lsls	r3, r2, #21
341a40f0:	d527      	bpl.n	341a4142 <__ssputs_r+0x8e>
341a40f2:	4629      	mov	r1, r5
341a40f4:	f7ff ff52 	bl	341a3f9c <_malloc_r>
341a40f8:	4606      	mov	r6, r0
341a40fa:	b360      	cbz	r0, 341a4156 <__ssputs_r+0xa2>
341a40fc:	464a      	mov	r2, r9
341a40fe:	6921      	ldr	r1, [r4, #16]
341a4100:	f7ff fecb 	bl	341a3e9a <memcpy>
341a4104:	89a3      	ldrh	r3, [r4, #12]
341a4106:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
341a410a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
341a410e:	81a3      	strh	r3, [r4, #12]
341a4110:	6126      	str	r6, [r4, #16]
341a4112:	444e      	add	r6, r9
341a4114:	6165      	str	r5, [r4, #20]
341a4116:	eba5 0509 	sub.w	r5, r5, r9
341a411a:	6026      	str	r6, [r4, #0]
341a411c:	463e      	mov	r6, r7
341a411e:	60a5      	str	r5, [r4, #8]
341a4120:	42be      	cmp	r6, r7
341a4122:	d900      	bls.n	341a4126 <__ssputs_r+0x72>
341a4124:	463e      	mov	r6, r7
341a4126:	4632      	mov	r2, r6
341a4128:	4641      	mov	r1, r8
341a412a:	6820      	ldr	r0, [r4, #0]
341a412c:	f7ff fe20 	bl	341a3d70 <memmove>
341a4130:	68a3      	ldr	r3, [r4, #8]
341a4132:	2000      	movs	r0, #0
341a4134:	1b9b      	subs	r3, r3, r6
341a4136:	60a3      	str	r3, [r4, #8]
341a4138:	6823      	ldr	r3, [r4, #0]
341a413a:	4433      	add	r3, r6
341a413c:	6023      	str	r3, [r4, #0]
341a413e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a4142:	462a      	mov	r2, r5
341a4144:	f000 fd72 	bl	341a4c2c <_realloc_r>
341a4148:	4606      	mov	r6, r0
341a414a:	2800      	cmp	r0, #0
341a414c:	d1e0      	bne.n	341a4110 <__ssputs_r+0x5c>
341a414e:	6921      	ldr	r1, [r4, #16]
341a4150:	4650      	mov	r0, sl
341a4152:	f7ff feb7 	bl	341a3ec4 <_free_r>
341a4156:	230c      	movs	r3, #12
341a4158:	f04f 30ff 	mov.w	r0, #4294967295
341a415c:	f8ca 3000 	str.w	r3, [sl]
341a4160:	89a3      	ldrh	r3, [r4, #12]
341a4162:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a4166:	81a3      	strh	r3, [r4, #12]
341a4168:	e7e9      	b.n	341a413e <__ssputs_r+0x8a>
	...

341a416c <_svfiprintf_r>:
341a416c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a4170:	4698      	mov	r8, r3
341a4172:	898b      	ldrh	r3, [r1, #12]
341a4174:	b09d      	sub	sp, #116	@ 0x74
341a4176:	4607      	mov	r7, r0
341a4178:	061b      	lsls	r3, r3, #24
341a417a:	460d      	mov	r5, r1
341a417c:	4614      	mov	r4, r2
341a417e:	d510      	bpl.n	341a41a2 <_svfiprintf_r+0x36>
341a4180:	690b      	ldr	r3, [r1, #16]
341a4182:	b973      	cbnz	r3, 341a41a2 <_svfiprintf_r+0x36>
341a4184:	2140      	movs	r1, #64	@ 0x40
341a4186:	f7ff ff09 	bl	341a3f9c <_malloc_r>
341a418a:	6028      	str	r0, [r5, #0]
341a418c:	6128      	str	r0, [r5, #16]
341a418e:	b930      	cbnz	r0, 341a419e <_svfiprintf_r+0x32>
341a4190:	230c      	movs	r3, #12
341a4192:	603b      	str	r3, [r7, #0]
341a4194:	f04f 30ff 	mov.w	r0, #4294967295
341a4198:	b01d      	add	sp, #116	@ 0x74
341a419a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a419e:	2340      	movs	r3, #64	@ 0x40
341a41a0:	616b      	str	r3, [r5, #20]
341a41a2:	2300      	movs	r3, #0
341a41a4:	f8cd 800c 	str.w	r8, [sp, #12]
341a41a8:	f04f 0901 	mov.w	r9, #1
341a41ac:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 341a4350 <_svfiprintf_r+0x1e4>
341a41b0:	9309      	str	r3, [sp, #36]	@ 0x24
341a41b2:	2320      	movs	r3, #32
341a41b4:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
341a41b8:	2330      	movs	r3, #48	@ 0x30
341a41ba:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
341a41be:	4623      	mov	r3, r4
341a41c0:	469a      	mov	sl, r3
341a41c2:	f813 2b01 	ldrb.w	r2, [r3], #1
341a41c6:	b10a      	cbz	r2, 341a41cc <_svfiprintf_r+0x60>
341a41c8:	2a25      	cmp	r2, #37	@ 0x25
341a41ca:	d1f9      	bne.n	341a41c0 <_svfiprintf_r+0x54>
341a41cc:	ebba 0b04 	subs.w	fp, sl, r4
341a41d0:	d00b      	beq.n	341a41ea <_svfiprintf_r+0x7e>
341a41d2:	465b      	mov	r3, fp
341a41d4:	4622      	mov	r2, r4
341a41d6:	4629      	mov	r1, r5
341a41d8:	4638      	mov	r0, r7
341a41da:	f7ff ff6b 	bl	341a40b4 <__ssputs_r>
341a41de:	3001      	adds	r0, #1
341a41e0:	f000 80a7 	beq.w	341a4332 <_svfiprintf_r+0x1c6>
341a41e4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
341a41e6:	445a      	add	r2, fp
341a41e8:	9209      	str	r2, [sp, #36]	@ 0x24
341a41ea:	f89a 3000 	ldrb.w	r3, [sl]
341a41ee:	2b00      	cmp	r3, #0
341a41f0:	f000 809f 	beq.w	341a4332 <_svfiprintf_r+0x1c6>
341a41f4:	2300      	movs	r3, #0
341a41f6:	f04f 32ff 	mov.w	r2, #4294967295
341a41fa:	f10a 0a01 	add.w	sl, sl, #1
341a41fe:	9304      	str	r3, [sp, #16]
341a4200:	9307      	str	r3, [sp, #28]
341a4202:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
341a4206:	931a      	str	r3, [sp, #104]	@ 0x68
341a4208:	e9cd 2305 	strd	r2, r3, [sp, #20]
341a420c:	4654      	mov	r4, sl
341a420e:	2205      	movs	r2, #5
341a4210:	484f      	ldr	r0, [pc, #316]	@ (341a4350 <_svfiprintf_r+0x1e4>)
341a4212:	f814 1b01 	ldrb.w	r1, [r4], #1
341a4216:	f000 fcfb 	bl	341a4c10 <memchr>
341a421a:	9a04      	ldr	r2, [sp, #16]
341a421c:	b9d8      	cbnz	r0, 341a4256 <_svfiprintf_r+0xea>
341a421e:	06d0      	lsls	r0, r2, #27
341a4220:	bf44      	itt	mi
341a4222:	2320      	movmi	r3, #32
341a4224:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a4228:	0711      	lsls	r1, r2, #28
341a422a:	bf44      	itt	mi
341a422c:	232b      	movmi	r3, #43	@ 0x2b
341a422e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a4232:	f89a 3000 	ldrb.w	r3, [sl]
341a4236:	2b2a      	cmp	r3, #42	@ 0x2a
341a4238:	d015      	beq.n	341a4266 <_svfiprintf_r+0xfa>
341a423a:	9a07      	ldr	r2, [sp, #28]
341a423c:	4654      	mov	r4, sl
341a423e:	2000      	movs	r0, #0
341a4240:	f04f 0c0a 	mov.w	ip, #10
341a4244:	4621      	mov	r1, r4
341a4246:	f811 3b01 	ldrb.w	r3, [r1], #1
341a424a:	3b30      	subs	r3, #48	@ 0x30
341a424c:	2b09      	cmp	r3, #9
341a424e:	d94b      	bls.n	341a42e8 <_svfiprintf_r+0x17c>
341a4250:	b1b0      	cbz	r0, 341a4280 <_svfiprintf_r+0x114>
341a4252:	9207      	str	r2, [sp, #28]
341a4254:	e014      	b.n	341a4280 <_svfiprintf_r+0x114>
341a4256:	eba0 0308 	sub.w	r3, r0, r8
341a425a:	46a2      	mov	sl, r4
341a425c:	fa09 f303 	lsl.w	r3, r9, r3
341a4260:	4313      	orrs	r3, r2
341a4262:	9304      	str	r3, [sp, #16]
341a4264:	e7d2      	b.n	341a420c <_svfiprintf_r+0xa0>
341a4266:	9b03      	ldr	r3, [sp, #12]
341a4268:	1d19      	adds	r1, r3, #4
341a426a:	681b      	ldr	r3, [r3, #0]
341a426c:	2b00      	cmp	r3, #0
341a426e:	9103      	str	r1, [sp, #12]
341a4270:	bfbb      	ittet	lt
341a4272:	425b      	neglt	r3, r3
341a4274:	f042 0202 	orrlt.w	r2, r2, #2
341a4278:	9307      	strge	r3, [sp, #28]
341a427a:	9307      	strlt	r3, [sp, #28]
341a427c:	bfb8      	it	lt
341a427e:	9204      	strlt	r2, [sp, #16]
341a4280:	7823      	ldrb	r3, [r4, #0]
341a4282:	2b2e      	cmp	r3, #46	@ 0x2e
341a4284:	d10a      	bne.n	341a429c <_svfiprintf_r+0x130>
341a4286:	7863      	ldrb	r3, [r4, #1]
341a4288:	2b2a      	cmp	r3, #42	@ 0x2a
341a428a:	d132      	bne.n	341a42f2 <_svfiprintf_r+0x186>
341a428c:	9b03      	ldr	r3, [sp, #12]
341a428e:	3402      	adds	r4, #2
341a4290:	1d1a      	adds	r2, r3, #4
341a4292:	681b      	ldr	r3, [r3, #0]
341a4294:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
341a4298:	9203      	str	r2, [sp, #12]
341a429a:	9305      	str	r3, [sp, #20]
341a429c:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 341a4360 <_svfiprintf_r+0x1f4>
341a42a0:	2203      	movs	r2, #3
341a42a2:	7821      	ldrb	r1, [r4, #0]
341a42a4:	4650      	mov	r0, sl
341a42a6:	f000 fcb3 	bl	341a4c10 <memchr>
341a42aa:	b138      	cbz	r0, 341a42bc <_svfiprintf_r+0x150>
341a42ac:	eba0 000a 	sub.w	r0, r0, sl
341a42b0:	2240      	movs	r2, #64	@ 0x40
341a42b2:	9b04      	ldr	r3, [sp, #16]
341a42b4:	3401      	adds	r4, #1
341a42b6:	4082      	lsls	r2, r0
341a42b8:	4313      	orrs	r3, r2
341a42ba:	9304      	str	r3, [sp, #16]
341a42bc:	f814 1b01 	ldrb.w	r1, [r4], #1
341a42c0:	2206      	movs	r2, #6
341a42c2:	4824      	ldr	r0, [pc, #144]	@ (341a4354 <_svfiprintf_r+0x1e8>)
341a42c4:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
341a42c8:	f000 fca2 	bl	341a4c10 <memchr>
341a42cc:	2800      	cmp	r0, #0
341a42ce:	d036      	beq.n	341a433e <_svfiprintf_r+0x1d2>
341a42d0:	4b21      	ldr	r3, [pc, #132]	@ (341a4358 <_svfiprintf_r+0x1ec>)
341a42d2:	bb1b      	cbnz	r3, 341a431c <_svfiprintf_r+0x1b0>
341a42d4:	9b03      	ldr	r3, [sp, #12]
341a42d6:	3307      	adds	r3, #7
341a42d8:	f023 0307 	bic.w	r3, r3, #7
341a42dc:	3308      	adds	r3, #8
341a42de:	9303      	str	r3, [sp, #12]
341a42e0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
341a42e2:	4433      	add	r3, r6
341a42e4:	9309      	str	r3, [sp, #36]	@ 0x24
341a42e6:	e76a      	b.n	341a41be <_svfiprintf_r+0x52>
341a42e8:	fb0c 3202 	mla	r2, ip, r2, r3
341a42ec:	460c      	mov	r4, r1
341a42ee:	2001      	movs	r0, #1
341a42f0:	e7a8      	b.n	341a4244 <_svfiprintf_r+0xd8>
341a42f2:	2300      	movs	r3, #0
341a42f4:	3401      	adds	r4, #1
341a42f6:	f04f 0c0a 	mov.w	ip, #10
341a42fa:	4619      	mov	r1, r3
341a42fc:	9305      	str	r3, [sp, #20]
341a42fe:	4620      	mov	r0, r4
341a4300:	f810 2b01 	ldrb.w	r2, [r0], #1
341a4304:	3a30      	subs	r2, #48	@ 0x30
341a4306:	2a09      	cmp	r2, #9
341a4308:	d903      	bls.n	341a4312 <_svfiprintf_r+0x1a6>
341a430a:	2b00      	cmp	r3, #0
341a430c:	d0c6      	beq.n	341a429c <_svfiprintf_r+0x130>
341a430e:	9105      	str	r1, [sp, #20]
341a4310:	e7c4      	b.n	341a429c <_svfiprintf_r+0x130>
341a4312:	fb0c 2101 	mla	r1, ip, r1, r2
341a4316:	4604      	mov	r4, r0
341a4318:	2301      	movs	r3, #1
341a431a:	e7f0      	b.n	341a42fe <_svfiprintf_r+0x192>
341a431c:	ab03      	add	r3, sp, #12
341a431e:	462a      	mov	r2, r5
341a4320:	a904      	add	r1, sp, #16
341a4322:	4638      	mov	r0, r7
341a4324:	9300      	str	r3, [sp, #0]
341a4326:	4b0d      	ldr	r3, [pc, #52]	@ (341a435c <_svfiprintf_r+0x1f0>)
341a4328:	f3af 8000 	nop.w
341a432c:	1c42      	adds	r2, r0, #1
341a432e:	4606      	mov	r6, r0
341a4330:	d1d6      	bne.n	341a42e0 <_svfiprintf_r+0x174>
341a4332:	89ab      	ldrh	r3, [r5, #12]
341a4334:	065b      	lsls	r3, r3, #25
341a4336:	f53f af2d 	bmi.w	341a4194 <_svfiprintf_r+0x28>
341a433a:	9809      	ldr	r0, [sp, #36]	@ 0x24
341a433c:	e72c      	b.n	341a4198 <_svfiprintf_r+0x2c>
341a433e:	ab03      	add	r3, sp, #12
341a4340:	462a      	mov	r2, r5
341a4342:	a904      	add	r1, sp, #16
341a4344:	4638      	mov	r0, r7
341a4346:	9300      	str	r3, [sp, #0]
341a4348:	4b04      	ldr	r3, [pc, #16]	@ (341a435c <_svfiprintf_r+0x1f0>)
341a434a:	f000 f9bf 	bl	341a46cc <_printf_i>
341a434e:	e7ed      	b.n	341a432c <_svfiprintf_r+0x1c0>
341a4350:	341b7d5d 	.word	0x341b7d5d
341a4354:	341b7d67 	.word	0x341b7d67
341a4358:	00000000 	.word	0x00000000
341a435c:	341a40b5 	.word	0x341a40b5
341a4360:	341b7d63 	.word	0x341b7d63

341a4364 <__sfputc_r>:
341a4364:	6893      	ldr	r3, [r2, #8]
341a4366:	3b01      	subs	r3, #1
341a4368:	2b00      	cmp	r3, #0
341a436a:	b410      	push	{r4}
341a436c:	6093      	str	r3, [r2, #8]
341a436e:	da08      	bge.n	341a4382 <__sfputc_r+0x1e>
341a4370:	6994      	ldr	r4, [r2, #24]
341a4372:	42a3      	cmp	r3, r4
341a4374:	db01      	blt.n	341a437a <__sfputc_r+0x16>
341a4376:	290a      	cmp	r1, #10
341a4378:	d103      	bne.n	341a4382 <__sfputc_r+0x1e>
341a437a:	f85d 4b04 	ldr.w	r4, [sp], #4
341a437e:	f7ff bc62 	b.w	341a3c46 <__swbuf_r>
341a4382:	6813      	ldr	r3, [r2, #0]
341a4384:	1c58      	adds	r0, r3, #1
341a4386:	6010      	str	r0, [r2, #0]
341a4388:	4608      	mov	r0, r1
341a438a:	7019      	strb	r1, [r3, #0]
341a438c:	f85d 4b04 	ldr.w	r4, [sp], #4
341a4390:	4770      	bx	lr

341a4392 <__sfputs_r>:
341a4392:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a4394:	4606      	mov	r6, r0
341a4396:	460f      	mov	r7, r1
341a4398:	4614      	mov	r4, r2
341a439a:	18d5      	adds	r5, r2, r3
341a439c:	42ac      	cmp	r4, r5
341a439e:	d101      	bne.n	341a43a4 <__sfputs_r+0x12>
341a43a0:	2000      	movs	r0, #0
341a43a2:	e007      	b.n	341a43b4 <__sfputs_r+0x22>
341a43a4:	463a      	mov	r2, r7
341a43a6:	f814 1b01 	ldrb.w	r1, [r4], #1
341a43aa:	4630      	mov	r0, r6
341a43ac:	f7ff ffda 	bl	341a4364 <__sfputc_r>
341a43b0:	1c43      	adds	r3, r0, #1
341a43b2:	d1f3      	bne.n	341a439c <__sfputs_r+0xa>
341a43b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

341a43b8 <_vfiprintf_r>:
341a43b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a43bc:	460d      	mov	r5, r1
341a43be:	b09d      	sub	sp, #116	@ 0x74
341a43c0:	4614      	mov	r4, r2
341a43c2:	4698      	mov	r8, r3
341a43c4:	4606      	mov	r6, r0
341a43c6:	b118      	cbz	r0, 341a43d0 <_vfiprintf_r+0x18>
341a43c8:	6a03      	ldr	r3, [r0, #32]
341a43ca:	b90b      	cbnz	r3, 341a43d0 <_vfiprintf_r+0x18>
341a43cc:	f7ff fb0a 	bl	341a39e4 <__sinit>
341a43d0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a43d2:	07d9      	lsls	r1, r3, #31
341a43d4:	d405      	bmi.n	341a43e2 <_vfiprintf_r+0x2a>
341a43d6:	89ab      	ldrh	r3, [r5, #12]
341a43d8:	059a      	lsls	r2, r3, #22
341a43da:	d402      	bmi.n	341a43e2 <_vfiprintf_r+0x2a>
341a43dc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a43de:	f7ff fd5a 	bl	341a3e96 <__retarget_lock_acquire_recursive>
341a43e2:	89ab      	ldrh	r3, [r5, #12]
341a43e4:	071b      	lsls	r3, r3, #28
341a43e6:	d501      	bpl.n	341a43ec <_vfiprintf_r+0x34>
341a43e8:	692b      	ldr	r3, [r5, #16]
341a43ea:	b99b      	cbnz	r3, 341a4414 <_vfiprintf_r+0x5c>
341a43ec:	4629      	mov	r1, r5
341a43ee:	4630      	mov	r0, r6
341a43f0:	f7ff fc68 	bl	341a3cc4 <__swsetup_r>
341a43f4:	b170      	cbz	r0, 341a4414 <_vfiprintf_r+0x5c>
341a43f6:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a43f8:	07dc      	lsls	r4, r3, #31
341a43fa:	d504      	bpl.n	341a4406 <_vfiprintf_r+0x4e>
341a43fc:	f04f 30ff 	mov.w	r0, #4294967295
341a4400:	b01d      	add	sp, #116	@ 0x74
341a4402:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a4406:	89ab      	ldrh	r3, [r5, #12]
341a4408:	0598      	lsls	r0, r3, #22
341a440a:	d4f7      	bmi.n	341a43fc <_vfiprintf_r+0x44>
341a440c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a440e:	f7ff fd43 	bl	341a3e98 <__retarget_lock_release_recursive>
341a4412:	e7f3      	b.n	341a43fc <_vfiprintf_r+0x44>
341a4414:	2300      	movs	r3, #0
341a4416:	f8cd 800c 	str.w	r8, [sp, #12]
341a441a:	f04f 0901 	mov.w	r9, #1
341a441e:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 341a45d4 <_vfiprintf_r+0x21c>
341a4422:	9309      	str	r3, [sp, #36]	@ 0x24
341a4424:	2320      	movs	r3, #32
341a4426:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
341a442a:	2330      	movs	r3, #48	@ 0x30
341a442c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
341a4430:	4623      	mov	r3, r4
341a4432:	469a      	mov	sl, r3
341a4434:	f813 2b01 	ldrb.w	r2, [r3], #1
341a4438:	b10a      	cbz	r2, 341a443e <_vfiprintf_r+0x86>
341a443a:	2a25      	cmp	r2, #37	@ 0x25
341a443c:	d1f9      	bne.n	341a4432 <_vfiprintf_r+0x7a>
341a443e:	ebba 0b04 	subs.w	fp, sl, r4
341a4442:	d00b      	beq.n	341a445c <_vfiprintf_r+0xa4>
341a4444:	465b      	mov	r3, fp
341a4446:	4622      	mov	r2, r4
341a4448:	4629      	mov	r1, r5
341a444a:	4630      	mov	r0, r6
341a444c:	f7ff ffa1 	bl	341a4392 <__sfputs_r>
341a4450:	3001      	adds	r0, #1
341a4452:	f000 80a7 	beq.w	341a45a4 <_vfiprintf_r+0x1ec>
341a4456:	9a09      	ldr	r2, [sp, #36]	@ 0x24
341a4458:	445a      	add	r2, fp
341a445a:	9209      	str	r2, [sp, #36]	@ 0x24
341a445c:	f89a 3000 	ldrb.w	r3, [sl]
341a4460:	2b00      	cmp	r3, #0
341a4462:	f000 809f 	beq.w	341a45a4 <_vfiprintf_r+0x1ec>
341a4466:	2300      	movs	r3, #0
341a4468:	f04f 32ff 	mov.w	r2, #4294967295
341a446c:	f10a 0a01 	add.w	sl, sl, #1
341a4470:	9304      	str	r3, [sp, #16]
341a4472:	9307      	str	r3, [sp, #28]
341a4474:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
341a4478:	931a      	str	r3, [sp, #104]	@ 0x68
341a447a:	e9cd 2305 	strd	r2, r3, [sp, #20]
341a447e:	4654      	mov	r4, sl
341a4480:	2205      	movs	r2, #5
341a4482:	4854      	ldr	r0, [pc, #336]	@ (341a45d4 <_vfiprintf_r+0x21c>)
341a4484:	f814 1b01 	ldrb.w	r1, [r4], #1
341a4488:	f000 fbc2 	bl	341a4c10 <memchr>
341a448c:	9a04      	ldr	r2, [sp, #16]
341a448e:	b9d8      	cbnz	r0, 341a44c8 <_vfiprintf_r+0x110>
341a4490:	06d1      	lsls	r1, r2, #27
341a4492:	bf44      	itt	mi
341a4494:	2320      	movmi	r3, #32
341a4496:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a449a:	0713      	lsls	r3, r2, #28
341a449c:	bf44      	itt	mi
341a449e:	232b      	movmi	r3, #43	@ 0x2b
341a44a0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a44a4:	f89a 3000 	ldrb.w	r3, [sl]
341a44a8:	2b2a      	cmp	r3, #42	@ 0x2a
341a44aa:	d015      	beq.n	341a44d8 <_vfiprintf_r+0x120>
341a44ac:	9a07      	ldr	r2, [sp, #28]
341a44ae:	4654      	mov	r4, sl
341a44b0:	2000      	movs	r0, #0
341a44b2:	f04f 0c0a 	mov.w	ip, #10
341a44b6:	4621      	mov	r1, r4
341a44b8:	f811 3b01 	ldrb.w	r3, [r1], #1
341a44bc:	3b30      	subs	r3, #48	@ 0x30
341a44be:	2b09      	cmp	r3, #9
341a44c0:	d94b      	bls.n	341a455a <_vfiprintf_r+0x1a2>
341a44c2:	b1b0      	cbz	r0, 341a44f2 <_vfiprintf_r+0x13a>
341a44c4:	9207      	str	r2, [sp, #28]
341a44c6:	e014      	b.n	341a44f2 <_vfiprintf_r+0x13a>
341a44c8:	eba0 0308 	sub.w	r3, r0, r8
341a44cc:	46a2      	mov	sl, r4
341a44ce:	fa09 f303 	lsl.w	r3, r9, r3
341a44d2:	4313      	orrs	r3, r2
341a44d4:	9304      	str	r3, [sp, #16]
341a44d6:	e7d2      	b.n	341a447e <_vfiprintf_r+0xc6>
341a44d8:	9b03      	ldr	r3, [sp, #12]
341a44da:	1d19      	adds	r1, r3, #4
341a44dc:	681b      	ldr	r3, [r3, #0]
341a44de:	2b00      	cmp	r3, #0
341a44e0:	9103      	str	r1, [sp, #12]
341a44e2:	bfbb      	ittet	lt
341a44e4:	425b      	neglt	r3, r3
341a44e6:	f042 0202 	orrlt.w	r2, r2, #2
341a44ea:	9307      	strge	r3, [sp, #28]
341a44ec:	9307      	strlt	r3, [sp, #28]
341a44ee:	bfb8      	it	lt
341a44f0:	9204      	strlt	r2, [sp, #16]
341a44f2:	7823      	ldrb	r3, [r4, #0]
341a44f4:	2b2e      	cmp	r3, #46	@ 0x2e
341a44f6:	d10a      	bne.n	341a450e <_vfiprintf_r+0x156>
341a44f8:	7863      	ldrb	r3, [r4, #1]
341a44fa:	2b2a      	cmp	r3, #42	@ 0x2a
341a44fc:	d132      	bne.n	341a4564 <_vfiprintf_r+0x1ac>
341a44fe:	9b03      	ldr	r3, [sp, #12]
341a4500:	3402      	adds	r4, #2
341a4502:	1d1a      	adds	r2, r3, #4
341a4504:	681b      	ldr	r3, [r3, #0]
341a4506:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
341a450a:	9203      	str	r2, [sp, #12]
341a450c:	9305      	str	r3, [sp, #20]
341a450e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 341a45e4 <_vfiprintf_r+0x22c>
341a4512:	2203      	movs	r2, #3
341a4514:	7821      	ldrb	r1, [r4, #0]
341a4516:	4650      	mov	r0, sl
341a4518:	f000 fb7a 	bl	341a4c10 <memchr>
341a451c:	b138      	cbz	r0, 341a452e <_vfiprintf_r+0x176>
341a451e:	eba0 000a 	sub.w	r0, r0, sl
341a4522:	2240      	movs	r2, #64	@ 0x40
341a4524:	9b04      	ldr	r3, [sp, #16]
341a4526:	3401      	adds	r4, #1
341a4528:	4082      	lsls	r2, r0
341a452a:	4313      	orrs	r3, r2
341a452c:	9304      	str	r3, [sp, #16]
341a452e:	f814 1b01 	ldrb.w	r1, [r4], #1
341a4532:	2206      	movs	r2, #6
341a4534:	4828      	ldr	r0, [pc, #160]	@ (341a45d8 <_vfiprintf_r+0x220>)
341a4536:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
341a453a:	f000 fb69 	bl	341a4c10 <memchr>
341a453e:	2800      	cmp	r0, #0
341a4540:	d03f      	beq.n	341a45c2 <_vfiprintf_r+0x20a>
341a4542:	4b26      	ldr	r3, [pc, #152]	@ (341a45dc <_vfiprintf_r+0x224>)
341a4544:	bb1b      	cbnz	r3, 341a458e <_vfiprintf_r+0x1d6>
341a4546:	9b03      	ldr	r3, [sp, #12]
341a4548:	3307      	adds	r3, #7
341a454a:	f023 0307 	bic.w	r3, r3, #7
341a454e:	3308      	adds	r3, #8
341a4550:	9303      	str	r3, [sp, #12]
341a4552:	9b09      	ldr	r3, [sp, #36]	@ 0x24
341a4554:	443b      	add	r3, r7
341a4556:	9309      	str	r3, [sp, #36]	@ 0x24
341a4558:	e76a      	b.n	341a4430 <_vfiprintf_r+0x78>
341a455a:	fb0c 3202 	mla	r2, ip, r2, r3
341a455e:	460c      	mov	r4, r1
341a4560:	2001      	movs	r0, #1
341a4562:	e7a8      	b.n	341a44b6 <_vfiprintf_r+0xfe>
341a4564:	2300      	movs	r3, #0
341a4566:	3401      	adds	r4, #1
341a4568:	f04f 0c0a 	mov.w	ip, #10
341a456c:	4619      	mov	r1, r3
341a456e:	9305      	str	r3, [sp, #20]
341a4570:	4620      	mov	r0, r4
341a4572:	f810 2b01 	ldrb.w	r2, [r0], #1
341a4576:	3a30      	subs	r2, #48	@ 0x30
341a4578:	2a09      	cmp	r2, #9
341a457a:	d903      	bls.n	341a4584 <_vfiprintf_r+0x1cc>
341a457c:	2b00      	cmp	r3, #0
341a457e:	d0c6      	beq.n	341a450e <_vfiprintf_r+0x156>
341a4580:	9105      	str	r1, [sp, #20]
341a4582:	e7c4      	b.n	341a450e <_vfiprintf_r+0x156>
341a4584:	fb0c 2101 	mla	r1, ip, r1, r2
341a4588:	4604      	mov	r4, r0
341a458a:	2301      	movs	r3, #1
341a458c:	e7f0      	b.n	341a4570 <_vfiprintf_r+0x1b8>
341a458e:	ab03      	add	r3, sp, #12
341a4590:	462a      	mov	r2, r5
341a4592:	a904      	add	r1, sp, #16
341a4594:	4630      	mov	r0, r6
341a4596:	9300      	str	r3, [sp, #0]
341a4598:	4b11      	ldr	r3, [pc, #68]	@ (341a45e0 <_vfiprintf_r+0x228>)
341a459a:	f3af 8000 	nop.w
341a459e:	4607      	mov	r7, r0
341a45a0:	1c78      	adds	r0, r7, #1
341a45a2:	d1d6      	bne.n	341a4552 <_vfiprintf_r+0x19a>
341a45a4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a45a6:	07d9      	lsls	r1, r3, #31
341a45a8:	d405      	bmi.n	341a45b6 <_vfiprintf_r+0x1fe>
341a45aa:	89ab      	ldrh	r3, [r5, #12]
341a45ac:	059a      	lsls	r2, r3, #22
341a45ae:	d402      	bmi.n	341a45b6 <_vfiprintf_r+0x1fe>
341a45b0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a45b2:	f7ff fc71 	bl	341a3e98 <__retarget_lock_release_recursive>
341a45b6:	89ab      	ldrh	r3, [r5, #12]
341a45b8:	065b      	lsls	r3, r3, #25
341a45ba:	f53f af1f 	bmi.w	341a43fc <_vfiprintf_r+0x44>
341a45be:	9809      	ldr	r0, [sp, #36]	@ 0x24
341a45c0:	e71e      	b.n	341a4400 <_vfiprintf_r+0x48>
341a45c2:	ab03      	add	r3, sp, #12
341a45c4:	462a      	mov	r2, r5
341a45c6:	a904      	add	r1, sp, #16
341a45c8:	4630      	mov	r0, r6
341a45ca:	9300      	str	r3, [sp, #0]
341a45cc:	4b04      	ldr	r3, [pc, #16]	@ (341a45e0 <_vfiprintf_r+0x228>)
341a45ce:	f000 f87d 	bl	341a46cc <_printf_i>
341a45d2:	e7e4      	b.n	341a459e <_vfiprintf_r+0x1e6>
341a45d4:	341b7d5d 	.word	0x341b7d5d
341a45d8:	341b7d67 	.word	0x341b7d67
341a45dc:	00000000 	.word	0x00000000
341a45e0:	341a4393 	.word	0x341a4393
341a45e4:	341b7d63 	.word	0x341b7d63

341a45e8 <_printf_common>:
341a45e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
341a45ec:	4616      	mov	r6, r2
341a45ee:	4698      	mov	r8, r3
341a45f0:	688a      	ldr	r2, [r1, #8]
341a45f2:	4607      	mov	r7, r0
341a45f4:	690b      	ldr	r3, [r1, #16]
341a45f6:	460c      	mov	r4, r1
341a45f8:	f8dd 9020 	ldr.w	r9, [sp, #32]
341a45fc:	4293      	cmp	r3, r2
341a45fe:	bfb8      	it	lt
341a4600:	4613      	movlt	r3, r2
341a4602:	6033      	str	r3, [r6, #0]
341a4604:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
341a4608:	b10a      	cbz	r2, 341a460e <_printf_common+0x26>
341a460a:	3301      	adds	r3, #1
341a460c:	6033      	str	r3, [r6, #0]
341a460e:	6823      	ldr	r3, [r4, #0]
341a4610:	0699      	lsls	r1, r3, #26
341a4612:	bf42      	ittt	mi
341a4614:	6833      	ldrmi	r3, [r6, #0]
341a4616:	3302      	addmi	r3, #2
341a4618:	6033      	strmi	r3, [r6, #0]
341a461a:	6825      	ldr	r5, [r4, #0]
341a461c:	f015 0506 	ands.w	r5, r5, #6
341a4620:	d106      	bne.n	341a4630 <_printf_common+0x48>
341a4622:	f104 0a19 	add.w	sl, r4, #25
341a4626:	68e3      	ldr	r3, [r4, #12]
341a4628:	6832      	ldr	r2, [r6, #0]
341a462a:	1a9b      	subs	r3, r3, r2
341a462c:	42ab      	cmp	r3, r5
341a462e:	dc2b      	bgt.n	341a4688 <_printf_common+0xa0>
341a4630:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
341a4634:	6822      	ldr	r2, [r4, #0]
341a4636:	3b00      	subs	r3, #0
341a4638:	bf18      	it	ne
341a463a:	2301      	movne	r3, #1
341a463c:	0692      	lsls	r2, r2, #26
341a463e:	d430      	bmi.n	341a46a2 <_printf_common+0xba>
341a4640:	f104 0243 	add.w	r2, r4, #67	@ 0x43
341a4644:	4641      	mov	r1, r8
341a4646:	4638      	mov	r0, r7
341a4648:	47c8      	blx	r9
341a464a:	3001      	adds	r0, #1
341a464c:	d023      	beq.n	341a4696 <_printf_common+0xae>
341a464e:	6823      	ldr	r3, [r4, #0]
341a4650:	341a      	adds	r4, #26
341a4652:	f854 2c0a 	ldr.w	r2, [r4, #-10]
341a4656:	f003 0306 	and.w	r3, r3, #6
341a465a:	2b04      	cmp	r3, #4
341a465c:	bf0a      	itet	eq
341a465e:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
341a4662:	2500      	movne	r5, #0
341a4664:	6833      	ldreq	r3, [r6, #0]
341a4666:	f04f 0600 	mov.w	r6, #0
341a466a:	bf08      	it	eq
341a466c:	1aed      	subeq	r5, r5, r3
341a466e:	f854 3c12 	ldr.w	r3, [r4, #-18]
341a4672:	bf08      	it	eq
341a4674:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
341a4678:	4293      	cmp	r3, r2
341a467a:	bfc4      	itt	gt
341a467c:	1a9b      	subgt	r3, r3, r2
341a467e:	18ed      	addgt	r5, r5, r3
341a4680:	42b5      	cmp	r5, r6
341a4682:	d11a      	bne.n	341a46ba <_printf_common+0xd2>
341a4684:	2000      	movs	r0, #0
341a4686:	e008      	b.n	341a469a <_printf_common+0xb2>
341a4688:	2301      	movs	r3, #1
341a468a:	4652      	mov	r2, sl
341a468c:	4641      	mov	r1, r8
341a468e:	4638      	mov	r0, r7
341a4690:	47c8      	blx	r9
341a4692:	3001      	adds	r0, #1
341a4694:	d103      	bne.n	341a469e <_printf_common+0xb6>
341a4696:	f04f 30ff 	mov.w	r0, #4294967295
341a469a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a469e:	3501      	adds	r5, #1
341a46a0:	e7c1      	b.n	341a4626 <_printf_common+0x3e>
341a46a2:	18e1      	adds	r1, r4, r3
341a46a4:	1c5a      	adds	r2, r3, #1
341a46a6:	2030      	movs	r0, #48	@ 0x30
341a46a8:	3302      	adds	r3, #2
341a46aa:	4422      	add	r2, r4
341a46ac:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
341a46b0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
341a46b4:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
341a46b8:	e7c2      	b.n	341a4640 <_printf_common+0x58>
341a46ba:	2301      	movs	r3, #1
341a46bc:	4622      	mov	r2, r4
341a46be:	4641      	mov	r1, r8
341a46c0:	4638      	mov	r0, r7
341a46c2:	47c8      	blx	r9
341a46c4:	3001      	adds	r0, #1
341a46c6:	d0e6      	beq.n	341a4696 <_printf_common+0xae>
341a46c8:	3601      	adds	r6, #1
341a46ca:	e7d9      	b.n	341a4680 <_printf_common+0x98>

341a46cc <_printf_i>:
341a46cc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
341a46d0:	7e0f      	ldrb	r7, [r1, #24]
341a46d2:	4691      	mov	r9, r2
341a46d4:	4680      	mov	r8, r0
341a46d6:	460c      	mov	r4, r1
341a46d8:	2f78      	cmp	r7, #120	@ 0x78
341a46da:	469a      	mov	sl, r3
341a46dc:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
341a46de:	f101 0243 	add.w	r2, r1, #67	@ 0x43
341a46e2:	d807      	bhi.n	341a46f4 <_printf_i+0x28>
341a46e4:	2f62      	cmp	r7, #98	@ 0x62
341a46e6:	d80a      	bhi.n	341a46fe <_printf_i+0x32>
341a46e8:	2f00      	cmp	r7, #0
341a46ea:	f000 80d1 	beq.w	341a4890 <_printf_i+0x1c4>
341a46ee:	2f58      	cmp	r7, #88	@ 0x58
341a46f0:	f000 80b8 	beq.w	341a4864 <_printf_i+0x198>
341a46f4:	f104 0642 	add.w	r6, r4, #66	@ 0x42
341a46f8:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
341a46fc:	e03a      	b.n	341a4774 <_printf_i+0xa8>
341a46fe:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
341a4702:	2b15      	cmp	r3, #21
341a4704:	d8f6      	bhi.n	341a46f4 <_printf_i+0x28>
341a4706:	a101      	add	r1, pc, #4	@ (adr r1, 341a470c <_printf_i+0x40>)
341a4708:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
341a470c:	341a4765 	.word	0x341a4765
341a4710:	341a4779 	.word	0x341a4779
341a4714:	341a46f5 	.word	0x341a46f5
341a4718:	341a46f5 	.word	0x341a46f5
341a471c:	341a46f5 	.word	0x341a46f5
341a4720:	341a46f5 	.word	0x341a46f5
341a4724:	341a4779 	.word	0x341a4779
341a4728:	341a46f5 	.word	0x341a46f5
341a472c:	341a46f5 	.word	0x341a46f5
341a4730:	341a46f5 	.word	0x341a46f5
341a4734:	341a46f5 	.word	0x341a46f5
341a4738:	341a4877 	.word	0x341a4877
341a473c:	341a47a3 	.word	0x341a47a3
341a4740:	341a4831 	.word	0x341a4831
341a4744:	341a46f5 	.word	0x341a46f5
341a4748:	341a46f5 	.word	0x341a46f5
341a474c:	341a4899 	.word	0x341a4899
341a4750:	341a46f5 	.word	0x341a46f5
341a4754:	341a47a3 	.word	0x341a47a3
341a4758:	341a46f5 	.word	0x341a46f5
341a475c:	341a46f5 	.word	0x341a46f5
341a4760:	341a4839 	.word	0x341a4839
341a4764:	6833      	ldr	r3, [r6, #0]
341a4766:	1d1a      	adds	r2, r3, #4
341a4768:	681b      	ldr	r3, [r3, #0]
341a476a:	6032      	str	r2, [r6, #0]
341a476c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
341a4770:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
341a4774:	2301      	movs	r3, #1
341a4776:	e09c      	b.n	341a48b2 <_printf_i+0x1e6>
341a4778:	6833      	ldr	r3, [r6, #0]
341a477a:	6820      	ldr	r0, [r4, #0]
341a477c:	1d19      	adds	r1, r3, #4
341a477e:	6031      	str	r1, [r6, #0]
341a4780:	0606      	lsls	r6, r0, #24
341a4782:	d501      	bpl.n	341a4788 <_printf_i+0xbc>
341a4784:	681d      	ldr	r5, [r3, #0]
341a4786:	e003      	b.n	341a4790 <_printf_i+0xc4>
341a4788:	0645      	lsls	r5, r0, #25
341a478a:	d5fb      	bpl.n	341a4784 <_printf_i+0xb8>
341a478c:	f9b3 5000 	ldrsh.w	r5, [r3]
341a4790:	2d00      	cmp	r5, #0
341a4792:	da03      	bge.n	341a479c <_printf_i+0xd0>
341a4794:	232d      	movs	r3, #45	@ 0x2d
341a4796:	426d      	negs	r5, r5
341a4798:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
341a479c:	4858      	ldr	r0, [pc, #352]	@ (341a4900 <_printf_i+0x234>)
341a479e:	230a      	movs	r3, #10
341a47a0:	e011      	b.n	341a47c6 <_printf_i+0xfa>
341a47a2:	6821      	ldr	r1, [r4, #0]
341a47a4:	6833      	ldr	r3, [r6, #0]
341a47a6:	0608      	lsls	r0, r1, #24
341a47a8:	f853 5b04 	ldr.w	r5, [r3], #4
341a47ac:	d402      	bmi.n	341a47b4 <_printf_i+0xe8>
341a47ae:	0649      	lsls	r1, r1, #25
341a47b0:	bf48      	it	mi
341a47b2:	b2ad      	uxthmi	r5, r5
341a47b4:	2f6f      	cmp	r7, #111	@ 0x6f
341a47b6:	6033      	str	r3, [r6, #0]
341a47b8:	4851      	ldr	r0, [pc, #324]	@ (341a4900 <_printf_i+0x234>)
341a47ba:	bf14      	ite	ne
341a47bc:	230a      	movne	r3, #10
341a47be:	2308      	moveq	r3, #8
341a47c0:	2100      	movs	r1, #0
341a47c2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
341a47c6:	6866      	ldr	r6, [r4, #4]
341a47c8:	2e00      	cmp	r6, #0
341a47ca:	60a6      	str	r6, [r4, #8]
341a47cc:	db05      	blt.n	341a47da <_printf_i+0x10e>
341a47ce:	6821      	ldr	r1, [r4, #0]
341a47d0:	432e      	orrs	r6, r5
341a47d2:	f021 0104 	bic.w	r1, r1, #4
341a47d6:	6021      	str	r1, [r4, #0]
341a47d8:	d04b      	beq.n	341a4872 <_printf_i+0x1a6>
341a47da:	4616      	mov	r6, r2
341a47dc:	fbb5 f1f3 	udiv	r1, r5, r3
341a47e0:	fb03 5711 	mls	r7, r3, r1, r5
341a47e4:	5dc7      	ldrb	r7, [r0, r7]
341a47e6:	f806 7d01 	strb.w	r7, [r6, #-1]!
341a47ea:	462f      	mov	r7, r5
341a47ec:	460d      	mov	r5, r1
341a47ee:	42bb      	cmp	r3, r7
341a47f0:	d9f4      	bls.n	341a47dc <_printf_i+0x110>
341a47f2:	2b08      	cmp	r3, #8
341a47f4:	d10b      	bne.n	341a480e <_printf_i+0x142>
341a47f6:	6823      	ldr	r3, [r4, #0]
341a47f8:	07df      	lsls	r7, r3, #31
341a47fa:	d508      	bpl.n	341a480e <_printf_i+0x142>
341a47fc:	6923      	ldr	r3, [r4, #16]
341a47fe:	6861      	ldr	r1, [r4, #4]
341a4800:	4299      	cmp	r1, r3
341a4802:	bfde      	ittt	le
341a4804:	2330      	movle	r3, #48	@ 0x30
341a4806:	f806 3c01 	strble.w	r3, [r6, #-1]
341a480a:	f106 36ff 	addle.w	r6, r6, #4294967295
341a480e:	1b92      	subs	r2, r2, r6
341a4810:	6122      	str	r2, [r4, #16]
341a4812:	464b      	mov	r3, r9
341a4814:	aa03      	add	r2, sp, #12
341a4816:	4621      	mov	r1, r4
341a4818:	4640      	mov	r0, r8
341a481a:	f8cd a000 	str.w	sl, [sp]
341a481e:	f7ff fee3 	bl	341a45e8 <_printf_common>
341a4822:	3001      	adds	r0, #1
341a4824:	d14a      	bne.n	341a48bc <_printf_i+0x1f0>
341a4826:	f04f 30ff 	mov.w	r0, #4294967295
341a482a:	b004      	add	sp, #16
341a482c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a4830:	6823      	ldr	r3, [r4, #0]
341a4832:	f043 0320 	orr.w	r3, r3, #32
341a4836:	6023      	str	r3, [r4, #0]
341a4838:	2778      	movs	r7, #120	@ 0x78
341a483a:	4832      	ldr	r0, [pc, #200]	@ (341a4904 <_printf_i+0x238>)
341a483c:	6823      	ldr	r3, [r4, #0]
341a483e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
341a4842:	061f      	lsls	r7, r3, #24
341a4844:	6831      	ldr	r1, [r6, #0]
341a4846:	f851 5b04 	ldr.w	r5, [r1], #4
341a484a:	d402      	bmi.n	341a4852 <_printf_i+0x186>
341a484c:	065f      	lsls	r7, r3, #25
341a484e:	bf48      	it	mi
341a4850:	b2ad      	uxthmi	r5, r5
341a4852:	6031      	str	r1, [r6, #0]
341a4854:	07d9      	lsls	r1, r3, #31
341a4856:	bf44      	itt	mi
341a4858:	f043 0320 	orrmi.w	r3, r3, #32
341a485c:	6023      	strmi	r3, [r4, #0]
341a485e:	b11d      	cbz	r5, 341a4868 <_printf_i+0x19c>
341a4860:	2310      	movs	r3, #16
341a4862:	e7ad      	b.n	341a47c0 <_printf_i+0xf4>
341a4864:	4826      	ldr	r0, [pc, #152]	@ (341a4900 <_printf_i+0x234>)
341a4866:	e7e9      	b.n	341a483c <_printf_i+0x170>
341a4868:	6823      	ldr	r3, [r4, #0]
341a486a:	f023 0320 	bic.w	r3, r3, #32
341a486e:	6023      	str	r3, [r4, #0]
341a4870:	e7f6      	b.n	341a4860 <_printf_i+0x194>
341a4872:	4616      	mov	r6, r2
341a4874:	e7bd      	b.n	341a47f2 <_printf_i+0x126>
341a4876:	6833      	ldr	r3, [r6, #0]
341a4878:	6825      	ldr	r5, [r4, #0]
341a487a:	1d18      	adds	r0, r3, #4
341a487c:	6961      	ldr	r1, [r4, #20]
341a487e:	6030      	str	r0, [r6, #0]
341a4880:	062e      	lsls	r6, r5, #24
341a4882:	681b      	ldr	r3, [r3, #0]
341a4884:	d501      	bpl.n	341a488a <_printf_i+0x1be>
341a4886:	6019      	str	r1, [r3, #0]
341a4888:	e002      	b.n	341a4890 <_printf_i+0x1c4>
341a488a:	0668      	lsls	r0, r5, #25
341a488c:	d5fb      	bpl.n	341a4886 <_printf_i+0x1ba>
341a488e:	8019      	strh	r1, [r3, #0]
341a4890:	2300      	movs	r3, #0
341a4892:	4616      	mov	r6, r2
341a4894:	6123      	str	r3, [r4, #16]
341a4896:	e7bc      	b.n	341a4812 <_printf_i+0x146>
341a4898:	6833      	ldr	r3, [r6, #0]
341a489a:	2100      	movs	r1, #0
341a489c:	1d1a      	adds	r2, r3, #4
341a489e:	6032      	str	r2, [r6, #0]
341a48a0:	681e      	ldr	r6, [r3, #0]
341a48a2:	6862      	ldr	r2, [r4, #4]
341a48a4:	4630      	mov	r0, r6
341a48a6:	f000 f9b3 	bl	341a4c10 <memchr>
341a48aa:	b108      	cbz	r0, 341a48b0 <_printf_i+0x1e4>
341a48ac:	1b80      	subs	r0, r0, r6
341a48ae:	6060      	str	r0, [r4, #4]
341a48b0:	6863      	ldr	r3, [r4, #4]
341a48b2:	6123      	str	r3, [r4, #16]
341a48b4:	2300      	movs	r3, #0
341a48b6:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
341a48ba:	e7aa      	b.n	341a4812 <_printf_i+0x146>
341a48bc:	6923      	ldr	r3, [r4, #16]
341a48be:	4632      	mov	r2, r6
341a48c0:	4649      	mov	r1, r9
341a48c2:	4640      	mov	r0, r8
341a48c4:	47d0      	blx	sl
341a48c6:	3001      	adds	r0, #1
341a48c8:	d0ad      	beq.n	341a4826 <_printf_i+0x15a>
341a48ca:	6823      	ldr	r3, [r4, #0]
341a48cc:	079b      	lsls	r3, r3, #30
341a48ce:	d413      	bmi.n	341a48f8 <_printf_i+0x22c>
341a48d0:	68e0      	ldr	r0, [r4, #12]
341a48d2:	9b03      	ldr	r3, [sp, #12]
341a48d4:	4298      	cmp	r0, r3
341a48d6:	bfb8      	it	lt
341a48d8:	4618      	movlt	r0, r3
341a48da:	e7a6      	b.n	341a482a <_printf_i+0x15e>
341a48dc:	2301      	movs	r3, #1
341a48de:	4632      	mov	r2, r6
341a48e0:	4649      	mov	r1, r9
341a48e2:	4640      	mov	r0, r8
341a48e4:	47d0      	blx	sl
341a48e6:	3001      	adds	r0, #1
341a48e8:	d09d      	beq.n	341a4826 <_printf_i+0x15a>
341a48ea:	3501      	adds	r5, #1
341a48ec:	68e3      	ldr	r3, [r4, #12]
341a48ee:	9903      	ldr	r1, [sp, #12]
341a48f0:	1a5b      	subs	r3, r3, r1
341a48f2:	42ab      	cmp	r3, r5
341a48f4:	dcf2      	bgt.n	341a48dc <_printf_i+0x210>
341a48f6:	e7eb      	b.n	341a48d0 <_printf_i+0x204>
341a48f8:	2500      	movs	r5, #0
341a48fa:	f104 0619 	add.w	r6, r4, #25
341a48fe:	e7f5      	b.n	341a48ec <_printf_i+0x220>
341a4900:	341b7d6e 	.word	0x341b7d6e
341a4904:	341b7d7f 	.word	0x341b7d7f

341a4908 <__sflush_r>:
341a4908:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
341a490c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a4910:	0716      	lsls	r6, r2, #28
341a4912:	4605      	mov	r5, r0
341a4914:	460c      	mov	r4, r1
341a4916:	d454      	bmi.n	341a49c2 <__sflush_r+0xba>
341a4918:	684b      	ldr	r3, [r1, #4]
341a491a:	2b00      	cmp	r3, #0
341a491c:	dc02      	bgt.n	341a4924 <__sflush_r+0x1c>
341a491e:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
341a4920:	2b00      	cmp	r3, #0
341a4922:	dd48      	ble.n	341a49b6 <__sflush_r+0xae>
341a4924:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
341a4926:	2e00      	cmp	r6, #0
341a4928:	d045      	beq.n	341a49b6 <__sflush_r+0xae>
341a492a:	2300      	movs	r3, #0
341a492c:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
341a4930:	682f      	ldr	r7, [r5, #0]
341a4932:	6a21      	ldr	r1, [r4, #32]
341a4934:	602b      	str	r3, [r5, #0]
341a4936:	d030      	beq.n	341a499a <__sflush_r+0x92>
341a4938:	6d62      	ldr	r2, [r4, #84]	@ 0x54
341a493a:	89a3      	ldrh	r3, [r4, #12]
341a493c:	0759      	lsls	r1, r3, #29
341a493e:	d505      	bpl.n	341a494c <__sflush_r+0x44>
341a4940:	6863      	ldr	r3, [r4, #4]
341a4942:	1ad2      	subs	r2, r2, r3
341a4944:	6b63      	ldr	r3, [r4, #52]	@ 0x34
341a4946:	b10b      	cbz	r3, 341a494c <__sflush_r+0x44>
341a4948:	6c23      	ldr	r3, [r4, #64]	@ 0x40
341a494a:	1ad2      	subs	r2, r2, r3
341a494c:	2300      	movs	r3, #0
341a494e:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
341a4950:	6a21      	ldr	r1, [r4, #32]
341a4952:	4628      	mov	r0, r5
341a4954:	47b0      	blx	r6
341a4956:	1c43      	adds	r3, r0, #1
341a4958:	89a3      	ldrh	r3, [r4, #12]
341a495a:	d106      	bne.n	341a496a <__sflush_r+0x62>
341a495c:	6829      	ldr	r1, [r5, #0]
341a495e:	291d      	cmp	r1, #29
341a4960:	d82b      	bhi.n	341a49ba <__sflush_r+0xb2>
341a4962:	4a2a      	ldr	r2, [pc, #168]	@ (341a4a0c <__sflush_r+0x104>)
341a4964:	40ca      	lsrs	r2, r1
341a4966:	07d6      	lsls	r6, r2, #31
341a4968:	d527      	bpl.n	341a49ba <__sflush_r+0xb2>
341a496a:	2200      	movs	r2, #0
341a496c:	04d9      	lsls	r1, r3, #19
341a496e:	6062      	str	r2, [r4, #4]
341a4970:	6922      	ldr	r2, [r4, #16]
341a4972:	6022      	str	r2, [r4, #0]
341a4974:	d504      	bpl.n	341a4980 <__sflush_r+0x78>
341a4976:	1c42      	adds	r2, r0, #1
341a4978:	d101      	bne.n	341a497e <__sflush_r+0x76>
341a497a:	682b      	ldr	r3, [r5, #0]
341a497c:	b903      	cbnz	r3, 341a4980 <__sflush_r+0x78>
341a497e:	6560      	str	r0, [r4, #84]	@ 0x54
341a4980:	6b61      	ldr	r1, [r4, #52]	@ 0x34
341a4982:	602f      	str	r7, [r5, #0]
341a4984:	b1b9      	cbz	r1, 341a49b6 <__sflush_r+0xae>
341a4986:	f104 0344 	add.w	r3, r4, #68	@ 0x44
341a498a:	4299      	cmp	r1, r3
341a498c:	d002      	beq.n	341a4994 <__sflush_r+0x8c>
341a498e:	4628      	mov	r0, r5
341a4990:	f7ff fa98 	bl	341a3ec4 <_free_r>
341a4994:	2300      	movs	r3, #0
341a4996:	6363      	str	r3, [r4, #52]	@ 0x34
341a4998:	e00d      	b.n	341a49b6 <__sflush_r+0xae>
341a499a:	2301      	movs	r3, #1
341a499c:	4628      	mov	r0, r5
341a499e:	47b0      	blx	r6
341a49a0:	4602      	mov	r2, r0
341a49a2:	1c50      	adds	r0, r2, #1
341a49a4:	d1c9      	bne.n	341a493a <__sflush_r+0x32>
341a49a6:	682b      	ldr	r3, [r5, #0]
341a49a8:	2b00      	cmp	r3, #0
341a49aa:	d0c6      	beq.n	341a493a <__sflush_r+0x32>
341a49ac:	2b1d      	cmp	r3, #29
341a49ae:	d001      	beq.n	341a49b4 <__sflush_r+0xac>
341a49b0:	2b16      	cmp	r3, #22
341a49b2:	d11d      	bne.n	341a49f0 <__sflush_r+0xe8>
341a49b4:	602f      	str	r7, [r5, #0]
341a49b6:	2000      	movs	r0, #0
341a49b8:	e021      	b.n	341a49fe <__sflush_r+0xf6>
341a49ba:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a49be:	b21b      	sxth	r3, r3
341a49c0:	e01a      	b.n	341a49f8 <__sflush_r+0xf0>
341a49c2:	690f      	ldr	r7, [r1, #16]
341a49c4:	2f00      	cmp	r7, #0
341a49c6:	d0f6      	beq.n	341a49b6 <__sflush_r+0xae>
341a49c8:	0793      	lsls	r3, r2, #30
341a49ca:	680e      	ldr	r6, [r1, #0]
341a49cc:	600f      	str	r7, [r1, #0]
341a49ce:	bf0c      	ite	eq
341a49d0:	694b      	ldreq	r3, [r1, #20]
341a49d2:	2300      	movne	r3, #0
341a49d4:	eba6 0807 	sub.w	r8, r6, r7
341a49d8:	608b      	str	r3, [r1, #8]
341a49da:	f1b8 0f00 	cmp.w	r8, #0
341a49de:	ddea      	ble.n	341a49b6 <__sflush_r+0xae>
341a49e0:	4643      	mov	r3, r8
341a49e2:	463a      	mov	r2, r7
341a49e4:	6a21      	ldr	r1, [r4, #32]
341a49e6:	4628      	mov	r0, r5
341a49e8:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
341a49ea:	47b0      	blx	r6
341a49ec:	2800      	cmp	r0, #0
341a49ee:	dc08      	bgt.n	341a4a02 <__sflush_r+0xfa>
341a49f0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a49f4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a49f8:	f04f 30ff 	mov.w	r0, #4294967295
341a49fc:	81a3      	strh	r3, [r4, #12]
341a49fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
341a4a02:	4407      	add	r7, r0
341a4a04:	eba8 0800 	sub.w	r8, r8, r0
341a4a08:	e7e7      	b.n	341a49da <__sflush_r+0xd2>
341a4a0a:	bf00      	nop
341a4a0c:	20400001 	.word	0x20400001

341a4a10 <_fflush_r>:
341a4a10:	b538      	push	{r3, r4, r5, lr}
341a4a12:	690b      	ldr	r3, [r1, #16]
341a4a14:	4605      	mov	r5, r0
341a4a16:	460c      	mov	r4, r1
341a4a18:	b913      	cbnz	r3, 341a4a20 <_fflush_r+0x10>
341a4a1a:	2500      	movs	r5, #0
341a4a1c:	4628      	mov	r0, r5
341a4a1e:	bd38      	pop	{r3, r4, r5, pc}
341a4a20:	b118      	cbz	r0, 341a4a2a <_fflush_r+0x1a>
341a4a22:	6a03      	ldr	r3, [r0, #32]
341a4a24:	b90b      	cbnz	r3, 341a4a2a <_fflush_r+0x1a>
341a4a26:	f7fe ffdd 	bl	341a39e4 <__sinit>
341a4a2a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a4a2e:	2b00      	cmp	r3, #0
341a4a30:	d0f3      	beq.n	341a4a1a <_fflush_r+0xa>
341a4a32:	6e62      	ldr	r2, [r4, #100]	@ 0x64
341a4a34:	07d0      	lsls	r0, r2, #31
341a4a36:	d404      	bmi.n	341a4a42 <_fflush_r+0x32>
341a4a38:	0599      	lsls	r1, r3, #22
341a4a3a:	d402      	bmi.n	341a4a42 <_fflush_r+0x32>
341a4a3c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a4a3e:	f7ff fa2a 	bl	341a3e96 <__retarget_lock_acquire_recursive>
341a4a42:	4628      	mov	r0, r5
341a4a44:	4621      	mov	r1, r4
341a4a46:	f7ff ff5f 	bl	341a4908 <__sflush_r>
341a4a4a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a4a4c:	4605      	mov	r5, r0
341a4a4e:	07da      	lsls	r2, r3, #31
341a4a50:	d4e4      	bmi.n	341a4a1c <_fflush_r+0xc>
341a4a52:	89a3      	ldrh	r3, [r4, #12]
341a4a54:	059b      	lsls	r3, r3, #22
341a4a56:	d4e1      	bmi.n	341a4a1c <_fflush_r+0xc>
341a4a58:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a4a5a:	f7ff fa1d 	bl	341a3e98 <__retarget_lock_release_recursive>
341a4a5e:	e7dd      	b.n	341a4a1c <_fflush_r+0xc>

341a4a60 <__swhatbuf_r>:
341a4a60:	b570      	push	{r4, r5, r6, lr}
341a4a62:	460c      	mov	r4, r1
341a4a64:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a4a68:	b096      	sub	sp, #88	@ 0x58
341a4a6a:	4615      	mov	r5, r2
341a4a6c:	2900      	cmp	r1, #0
341a4a6e:	461e      	mov	r6, r3
341a4a70:	da0c      	bge.n	341a4a8c <__swhatbuf_r+0x2c>
341a4a72:	89a3      	ldrh	r3, [r4, #12]
341a4a74:	2100      	movs	r1, #0
341a4a76:	f013 0f80 	tst.w	r3, #128	@ 0x80
341a4a7a:	bf14      	ite	ne
341a4a7c:	2340      	movne	r3, #64	@ 0x40
341a4a7e:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
341a4a82:	2000      	movs	r0, #0
341a4a84:	6031      	str	r1, [r6, #0]
341a4a86:	602b      	str	r3, [r5, #0]
341a4a88:	b016      	add	sp, #88	@ 0x58
341a4a8a:	bd70      	pop	{r4, r5, r6, pc}
341a4a8c:	466a      	mov	r2, sp
341a4a8e:	f000 f879 	bl	341a4b84 <_fstat_r>
341a4a92:	2800      	cmp	r0, #0
341a4a94:	dbed      	blt.n	341a4a72 <__swhatbuf_r+0x12>
341a4a96:	9901      	ldr	r1, [sp, #4]
341a4a98:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
341a4a9c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
341a4aa0:	4259      	negs	r1, r3
341a4aa2:	4159      	adcs	r1, r3
341a4aa4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a4aa8:	e7eb      	b.n	341a4a82 <__swhatbuf_r+0x22>

341a4aaa <__smakebuf_r>:
341a4aaa:	898b      	ldrh	r3, [r1, #12]
341a4aac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
341a4aae:	079d      	lsls	r5, r3, #30
341a4ab0:	4606      	mov	r6, r0
341a4ab2:	460c      	mov	r4, r1
341a4ab4:	d507      	bpl.n	341a4ac6 <__smakebuf_r+0x1c>
341a4ab6:	f104 0347 	add.w	r3, r4, #71	@ 0x47
341a4aba:	6023      	str	r3, [r4, #0]
341a4abc:	6123      	str	r3, [r4, #16]
341a4abe:	2301      	movs	r3, #1
341a4ac0:	6163      	str	r3, [r4, #20]
341a4ac2:	b003      	add	sp, #12
341a4ac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a4ac6:	ab01      	add	r3, sp, #4
341a4ac8:	466a      	mov	r2, sp
341a4aca:	f7ff ffc9 	bl	341a4a60 <__swhatbuf_r>
341a4ace:	9f00      	ldr	r7, [sp, #0]
341a4ad0:	4605      	mov	r5, r0
341a4ad2:	4630      	mov	r0, r6
341a4ad4:	4639      	mov	r1, r7
341a4ad6:	f7ff fa61 	bl	341a3f9c <_malloc_r>
341a4ada:	b948      	cbnz	r0, 341a4af0 <__smakebuf_r+0x46>
341a4adc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a4ae0:	059a      	lsls	r2, r3, #22
341a4ae2:	d4ee      	bmi.n	341a4ac2 <__smakebuf_r+0x18>
341a4ae4:	f023 0303 	bic.w	r3, r3, #3
341a4ae8:	f043 0302 	orr.w	r3, r3, #2
341a4aec:	81a3      	strh	r3, [r4, #12]
341a4aee:	e7e2      	b.n	341a4ab6 <__smakebuf_r+0xc>
341a4af0:	89a3      	ldrh	r3, [r4, #12]
341a4af2:	6020      	str	r0, [r4, #0]
341a4af4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
341a4af8:	81a3      	strh	r3, [r4, #12]
341a4afa:	9b01      	ldr	r3, [sp, #4]
341a4afc:	e9c4 0704 	strd	r0, r7, [r4, #16]
341a4b00:	b15b      	cbz	r3, 341a4b1a <__smakebuf_r+0x70>
341a4b02:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
341a4b06:	4630      	mov	r0, r6
341a4b08:	f000 f84e 	bl	341a4ba8 <_isatty_r>
341a4b0c:	b128      	cbz	r0, 341a4b1a <__smakebuf_r+0x70>
341a4b0e:	89a3      	ldrh	r3, [r4, #12]
341a4b10:	f023 0303 	bic.w	r3, r3, #3
341a4b14:	f043 0301 	orr.w	r3, r3, #1
341a4b18:	81a3      	strh	r3, [r4, #12]
341a4b1a:	89a3      	ldrh	r3, [r4, #12]
341a4b1c:	431d      	orrs	r5, r3
341a4b1e:	81a5      	strh	r5, [r4, #12]
341a4b20:	e7cf      	b.n	341a4ac2 <__smakebuf_r+0x18>

341a4b22 <_raise_r>:
341a4b22:	291f      	cmp	r1, #31
341a4b24:	b538      	push	{r3, r4, r5, lr}
341a4b26:	4605      	mov	r5, r0
341a4b28:	460c      	mov	r4, r1
341a4b2a:	d904      	bls.n	341a4b36 <_raise_r+0x14>
341a4b2c:	2316      	movs	r3, #22
341a4b2e:	6003      	str	r3, [r0, #0]
341a4b30:	f04f 30ff 	mov.w	r0, #4294967295
341a4b34:	bd38      	pop	{r3, r4, r5, pc}
341a4b36:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
341a4b38:	b112      	cbz	r2, 341a4b40 <_raise_r+0x1e>
341a4b3a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
341a4b3e:	b94b      	cbnz	r3, 341a4b54 <_raise_r+0x32>
341a4b40:	4628      	mov	r0, r5
341a4b42:	f000 f853 	bl	341a4bec <_getpid_r>
341a4b46:	4622      	mov	r2, r4
341a4b48:	4601      	mov	r1, r0
341a4b4a:	4628      	mov	r0, r5
341a4b4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
341a4b50:	f000 b83a 	b.w	341a4bc8 <_kill_r>
341a4b54:	2b01      	cmp	r3, #1
341a4b56:	d00a      	beq.n	341a4b6e <_raise_r+0x4c>
341a4b58:	1c59      	adds	r1, r3, #1
341a4b5a:	d103      	bne.n	341a4b64 <_raise_r+0x42>
341a4b5c:	2316      	movs	r3, #22
341a4b5e:	6003      	str	r3, [r0, #0]
341a4b60:	2001      	movs	r0, #1
341a4b62:	e7e7      	b.n	341a4b34 <_raise_r+0x12>
341a4b64:	2100      	movs	r1, #0
341a4b66:	4620      	mov	r0, r4
341a4b68:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
341a4b6c:	4798      	blx	r3
341a4b6e:	2000      	movs	r0, #0
341a4b70:	e7e0      	b.n	341a4b34 <_raise_r+0x12>
	...

341a4b74 <raise>:
341a4b74:	4b02      	ldr	r3, [pc, #8]	@ (341a4b80 <raise+0xc>)
341a4b76:	4601      	mov	r1, r0
341a4b78:	6818      	ldr	r0, [r3, #0]
341a4b7a:	f7ff bfd2 	b.w	341a4b22 <_raise_r>
341a4b7e:	bf00      	nop
341a4b80:	341c0140 	.word	0x341c0140

341a4b84 <_fstat_r>:
341a4b84:	b538      	push	{r3, r4, r5, lr}
341a4b86:	2300      	movs	r3, #0
341a4b88:	4d06      	ldr	r5, [pc, #24]	@ (341a4ba4 <_fstat_r+0x20>)
341a4b8a:	4604      	mov	r4, r0
341a4b8c:	4608      	mov	r0, r1
341a4b8e:	4611      	mov	r1, r2
341a4b90:	602b      	str	r3, [r5, #0]
341a4b92:	f7de f9d5 	bl	34182f40 <_fstat>
341a4b96:	1c43      	adds	r3, r0, #1
341a4b98:	d102      	bne.n	341a4ba0 <_fstat_r+0x1c>
341a4b9a:	682b      	ldr	r3, [r5, #0]
341a4b9c:	b103      	cbz	r3, 341a4ba0 <_fstat_r+0x1c>
341a4b9e:	6023      	str	r3, [r4, #0]
341a4ba0:	bd38      	pop	{r3, r4, r5, pc}
341a4ba2:	bf00      	nop
341a4ba4:	341c1e48 	.word	0x341c1e48

341a4ba8 <_isatty_r>:
341a4ba8:	b538      	push	{r3, r4, r5, lr}
341a4baa:	2300      	movs	r3, #0
341a4bac:	4d05      	ldr	r5, [pc, #20]	@ (341a4bc4 <_isatty_r+0x1c>)
341a4bae:	4604      	mov	r4, r0
341a4bb0:	4608      	mov	r0, r1
341a4bb2:	602b      	str	r3, [r5, #0]
341a4bb4:	f7de f9d4 	bl	34182f60 <_isatty>
341a4bb8:	1c43      	adds	r3, r0, #1
341a4bba:	d102      	bne.n	341a4bc2 <_isatty_r+0x1a>
341a4bbc:	682b      	ldr	r3, [r5, #0]
341a4bbe:	b103      	cbz	r3, 341a4bc2 <_isatty_r+0x1a>
341a4bc0:	6023      	str	r3, [r4, #0]
341a4bc2:	bd38      	pop	{r3, r4, r5, pc}
341a4bc4:	341c1e48 	.word	0x341c1e48

341a4bc8 <_kill_r>:
341a4bc8:	b538      	push	{r3, r4, r5, lr}
341a4bca:	2300      	movs	r3, #0
341a4bcc:	4d06      	ldr	r5, [pc, #24]	@ (341a4be8 <_kill_r+0x20>)
341a4bce:	4604      	mov	r4, r0
341a4bd0:	4608      	mov	r0, r1
341a4bd2:	4611      	mov	r1, r2
341a4bd4:	602b      	str	r3, [r5, #0]
341a4bd6:	f7de f953 	bl	34182e80 <_kill>
341a4bda:	1c43      	adds	r3, r0, #1
341a4bdc:	d102      	bne.n	341a4be4 <_kill_r+0x1c>
341a4bde:	682b      	ldr	r3, [r5, #0]
341a4be0:	b103      	cbz	r3, 341a4be4 <_kill_r+0x1c>
341a4be2:	6023      	str	r3, [r4, #0]
341a4be4:	bd38      	pop	{r3, r4, r5, pc}
341a4be6:	bf00      	nop
341a4be8:	341c1e48 	.word	0x341c1e48

341a4bec <_getpid_r>:
341a4bec:	f7de b940 	b.w	34182e70 <_getpid>

341a4bf0 <_sbrk_r>:
341a4bf0:	b538      	push	{r3, r4, r5, lr}
341a4bf2:	2300      	movs	r3, #0
341a4bf4:	4d05      	ldr	r5, [pc, #20]	@ (341a4c0c <_sbrk_r+0x1c>)
341a4bf6:	4604      	mov	r4, r0
341a4bf8:	4608      	mov	r0, r1
341a4bfa:	602b      	str	r3, [r5, #0]
341a4bfc:	f7de f9c8 	bl	34182f90 <_sbrk>
341a4c00:	1c43      	adds	r3, r0, #1
341a4c02:	d102      	bne.n	341a4c0a <_sbrk_r+0x1a>
341a4c04:	682b      	ldr	r3, [r5, #0]
341a4c06:	b103      	cbz	r3, 341a4c0a <_sbrk_r+0x1a>
341a4c08:	6023      	str	r3, [r4, #0]
341a4c0a:	bd38      	pop	{r3, r4, r5, pc}
341a4c0c:	341c1e48 	.word	0x341c1e48

341a4c10 <memchr>:
341a4c10:	b2c9      	uxtb	r1, r1
341a4c12:	4603      	mov	r3, r0
341a4c14:	4402      	add	r2, r0
341a4c16:	b510      	push	{r4, lr}
341a4c18:	4293      	cmp	r3, r2
341a4c1a:	4618      	mov	r0, r3
341a4c1c:	d101      	bne.n	341a4c22 <memchr+0x12>
341a4c1e:	2000      	movs	r0, #0
341a4c20:	e003      	b.n	341a4c2a <memchr+0x1a>
341a4c22:	7804      	ldrb	r4, [r0, #0]
341a4c24:	3301      	adds	r3, #1
341a4c26:	428c      	cmp	r4, r1
341a4c28:	d1f6      	bne.n	341a4c18 <memchr+0x8>
341a4c2a:	bd10      	pop	{r4, pc}

341a4c2c <_realloc_r>:
341a4c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a4c30:	4607      	mov	r7, r0
341a4c32:	4614      	mov	r4, r2
341a4c34:	460d      	mov	r5, r1
341a4c36:	b921      	cbnz	r1, 341a4c42 <_realloc_r+0x16>
341a4c38:	4611      	mov	r1, r2
341a4c3a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
341a4c3e:	f7ff b9ad 	b.w	341a3f9c <_malloc_r>
341a4c42:	b92a      	cbnz	r2, 341a4c50 <_realloc_r+0x24>
341a4c44:	4625      	mov	r5, r4
341a4c46:	f7ff f93d 	bl	341a3ec4 <_free_r>
341a4c4a:	4628      	mov	r0, r5
341a4c4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
341a4c50:	f000 f81a 	bl	341a4c88 <_malloc_usable_size_r>
341a4c54:	4284      	cmp	r4, r0
341a4c56:	4606      	mov	r6, r0
341a4c58:	d802      	bhi.n	341a4c60 <_realloc_r+0x34>
341a4c5a:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
341a4c5e:	d8f4      	bhi.n	341a4c4a <_realloc_r+0x1e>
341a4c60:	4621      	mov	r1, r4
341a4c62:	4638      	mov	r0, r7
341a4c64:	f7ff f99a 	bl	341a3f9c <_malloc_r>
341a4c68:	4680      	mov	r8, r0
341a4c6a:	b908      	cbnz	r0, 341a4c70 <_realloc_r+0x44>
341a4c6c:	4645      	mov	r5, r8
341a4c6e:	e7ec      	b.n	341a4c4a <_realloc_r+0x1e>
341a4c70:	42b4      	cmp	r4, r6
341a4c72:	4622      	mov	r2, r4
341a4c74:	4629      	mov	r1, r5
341a4c76:	bf28      	it	cs
341a4c78:	4632      	movcs	r2, r6
341a4c7a:	f7ff f90e 	bl	341a3e9a <memcpy>
341a4c7e:	4629      	mov	r1, r5
341a4c80:	4638      	mov	r0, r7
341a4c82:	f7ff f91f 	bl	341a3ec4 <_free_r>
341a4c86:	e7f1      	b.n	341a4c6c <_realloc_r+0x40>

341a4c88 <_malloc_usable_size_r>:
341a4c88:	f851 3c04 	ldr.w	r3, [r1, #-4]
341a4c8c:	1f18      	subs	r0, r3, #4
341a4c8e:	2b00      	cmp	r3, #0
341a4c90:	bfbc      	itt	lt
341a4c92:	580b      	ldrlt	r3, [r1, r0]
341a4c94:	18c0      	addlt	r0, r0, r3
341a4c96:	4770      	bx	lr

341a4c98 <log10>:
341a4c98:	b508      	push	{r3, lr}
341a4c9a:	ed2d 8b02 	vpush	{d8}
341a4c9e:	eeb0 8b40 	vmov.f64	d8, d0
341a4ca2:	f000 fca1 	bl	341a55e8 <__ieee754_log10>
341a4ca6:	eeb4 8b48 	vcmp.f64	d8, d8
341a4caa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a4cae:	d60f      	bvs.n	341a4cd0 <log10+0x38>
341a4cb0:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
341a4cb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a4cb8:	d80a      	bhi.n	341a4cd0 <log10+0x38>
341a4cba:	eeb5 8b40 	vcmp.f64	d8, #0.0
341a4cbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a4cc2:	d108      	bne.n	341a4cd6 <log10+0x3e>
341a4cc4:	f7ff f8bc 	bl	341a3e40 <__errno>
341a4cc8:	2322      	movs	r3, #34	@ 0x22
341a4cca:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 341a4cf0 <log10+0x58>
341a4cce:	6003      	str	r3, [r0, #0]
341a4cd0:	ecbd 8b02 	vpop	{d8}
341a4cd4:	bd08      	pop	{r3, pc}
341a4cd6:	f7ff f8b3 	bl	341a3e40 <__errno>
341a4cda:	2321      	movs	r3, #33	@ 0x21
341a4cdc:	ecbd 8b02 	vpop	{d8}
341a4ce0:	6003      	str	r3, [r0, #0]
341a4ce2:	4805      	ldr	r0, [pc, #20]	@ (341a4cf8 <log10+0x60>)
341a4ce4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
341a4ce8:	f000 b82a 	b.w	341a4d40 <nan>
341a4cec:	f3af 8000 	nop.w
341a4cf0:	00000000 	.word	0x00000000
341a4cf4:	fff00000 	.word	0xfff00000
341a4cf8:	341b78d9 	.word	0x341b78d9
341a4cfc:	00000000 	.word	0x00000000

341a4d00 <sqrt>:
341a4d00:	b508      	push	{r3, lr}
341a4d02:	ed2d 8b04 	vpush	{d8-d9}
341a4d06:	eeb0 8b40 	vmov.f64	d8, d0
341a4d0a:	f000 fc6a 	bl	341a55e2 <__ieee754_sqrt>
341a4d0e:	eeb4 8b48 	vcmp.f64	d8, d8
341a4d12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a4d16:	d60c      	bvs.n	341a4d32 <sqrt+0x32>
341a4d18:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 341a4d38 <sqrt+0x38>
341a4d1c:	eeb4 8bc9 	vcmpe.f64	d8, d9
341a4d20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a4d24:	d505      	bpl.n	341a4d32 <sqrt+0x32>
341a4d26:	f7ff f88b 	bl	341a3e40 <__errno>
341a4d2a:	ee89 0b09 	vdiv.f64	d0, d9, d9
341a4d2e:	2321      	movs	r3, #33	@ 0x21
341a4d30:	6003      	str	r3, [r0, #0]
341a4d32:	ecbd 8b04 	vpop	{d8-d9}
341a4d36:	bd08      	pop	{r3, pc}
	...

341a4d40 <nan>:
341a4d40:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a4d48 <nan+0x8>
341a4d44:	4770      	bx	lr
341a4d46:	bf00      	nop
341a4d48:	00000000 	.word	0x00000000
341a4d4c:	7ff80000 	.word	0x7ff80000

341a4d50 <checkint>:
341a4d50:	f3c1 520a 	ubfx	r2, r1, #20, #11
341a4d54:	f240 33fe 	movw	r3, #1022	@ 0x3fe
341a4d58:	429a      	cmp	r2, r3
341a4d5a:	b570      	push	{r4, r5, r6, lr}
341a4d5c:	dd2a      	ble.n	341a4db4 <checkint+0x64>
341a4d5e:	f240 4333 	movw	r3, #1075	@ 0x433
341a4d62:	429a      	cmp	r2, r3
341a4d64:	dc24      	bgt.n	341a4db0 <checkint+0x60>
341a4d66:	1a9b      	subs	r3, r3, r2
341a4d68:	f04f 32ff 	mov.w	r2, #4294967295
341a4d6c:	f1a3 0620 	sub.w	r6, r3, #32
341a4d70:	fa02 f403 	lsl.w	r4, r2, r3
341a4d74:	f1c3 0520 	rsb	r5, r3, #32
341a4d78:	fa02 f606 	lsl.w	r6, r2, r6
341a4d7c:	fa22 f505 	lsr.w	r5, r2, r5
341a4d80:	409a      	lsls	r2, r3
341a4d82:	4334      	orrs	r4, r6
341a4d84:	ea20 0202 	bic.w	r2, r0, r2
341a4d88:	432c      	orrs	r4, r5
341a4d8a:	ea21 0404 	bic.w	r4, r1, r4
341a4d8e:	4322      	orrs	r2, r4
341a4d90:	f1a3 0420 	sub.w	r4, r3, #32
341a4d94:	f1c3 0220 	rsb	r2, r3, #32
341a4d98:	d10c      	bne.n	341a4db4 <checkint+0x64>
341a4d9a:	40d8      	lsrs	r0, r3
341a4d9c:	fa01 f302 	lsl.w	r3, r1, r2
341a4da0:	40e1      	lsrs	r1, r4
341a4da2:	4318      	orrs	r0, r3
341a4da4:	4308      	orrs	r0, r1
341a4da6:	f000 0001 	and.w	r0, r0, #1
341a4daa:	f1d0 0002 	rsbs	r0, r0, #2
341a4dae:	bd70      	pop	{r4, r5, r6, pc}
341a4db0:	2002      	movs	r0, #2
341a4db2:	e7fc      	b.n	341a4dae <checkint+0x5e>
341a4db4:	2000      	movs	r0, #0
341a4db6:	e7fa      	b.n	341a4dae <checkint+0x5e>

341a4db8 <pow>:
341a4db8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a4dbc:	ee10 4a90 	vmov	r4, s1
341a4dc0:	f240 73fd 	movw	r3, #2045	@ 0x7fd
341a4dc4:	ee11 aa90 	vmov	sl, s3
341a4dc8:	ee10 5a10 	vmov	r5, s0
341a4dcc:	ea4f 5814 	mov.w	r8, r4, lsr #20
341a4dd0:	ee11 0a10 	vmov	r0, s2
341a4dd4:	ea4f 561a 	mov.w	r6, sl, lsr #20
341a4dd8:	f108 32ff 	add.w	r2, r8, #4294967295
341a4ddc:	46c4      	mov	ip, r8
341a4dde:	429a      	cmp	r2, r3
341a4de0:	ed2d 8b0a 	vpush	{d8-d12}
341a4de4:	b087      	sub	sp, #28
341a4de6:	d806      	bhi.n	341a4df6 <pow+0x3e>
341a4de8:	f3c6 030a 	ubfx	r3, r6, #0, #11
341a4dec:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
341a4df0:	2b7f      	cmp	r3, #127	@ 0x7f
341a4df2:	f240 8157 	bls.w	341a50a4 <pow+0x2ec>
341a4df6:	1802      	adds	r2, r0, r0
341a4df8:	f06f 0b01 	mvn.w	fp, #1
341a4dfc:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
341a4e00:	eb4a 010a 	adc.w	r1, sl, sl
341a4e04:	1e57      	subs	r7, r2, #1
341a4e06:	f141 33ff 	adc.w	r3, r1, #4294967295
341a4e0a:	45bb      	cmp	fp, r7
341a4e0c:	eb7e 0303 	sbcs.w	r3, lr, r3
341a4e10:	d242      	bcs.n	341a4e98 <pow+0xe0>
341a4e12:	ea52 0301 	orrs.w	r3, r2, r1
341a4e16:	f04f 0300 	mov.w	r3, #0
341a4e1a:	d10c      	bne.n	341a4e36 <pow+0x7e>
341a4e1c:	196d      	adds	r5, r5, r5
341a4e1e:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
341a4e22:	4164      	adcs	r4, r4
341a4e24:	42ab      	cmp	r3, r5
341a4e26:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
341a4e2a:	41a3      	sbcs	r3, r4
341a4e2c:	f0c0 808f 	bcc.w	341a4f4e <pow+0x196>
341a4e30:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a4e34:	e02b      	b.n	341a4e8e <pow+0xd6>
341a4e36:	4ed4      	ldr	r6, [pc, #848]	@ (341a5188 <pow+0x3d0>)
341a4e38:	42b4      	cmp	r4, r6
341a4e3a:	bf08      	it	eq
341a4e3c:	429d      	cmpeq	r5, r3
341a4e3e:	d109      	bne.n	341a4e54 <pow+0x9c>
341a4e40:	1800      	adds	r0, r0, r0
341a4e42:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
341a4e46:	eb4a 0a0a 	adc.w	sl, sl, sl
341a4e4a:	4283      	cmp	r3, r0
341a4e4c:	4bcf      	ldr	r3, [pc, #828]	@ (341a518c <pow+0x3d4>)
341a4e4e:	eb73 030a 	sbcs.w	r3, r3, sl
341a4e52:	e7eb      	b.n	341a4e2c <pow+0x74>
341a4e54:	196d      	adds	r5, r5, r5
341a4e56:	48ce      	ldr	r0, [pc, #824]	@ (341a5190 <pow+0x3d8>)
341a4e58:	4164      	adcs	r4, r4
341a4e5a:	42ab      	cmp	r3, r5
341a4e5c:	eb70 0604 	sbcs.w	r6, r0, r4
341a4e60:	d375      	bcc.n	341a4f4e <pow+0x196>
341a4e62:	4281      	cmp	r1, r0
341a4e64:	bf08      	it	eq
341a4e66:	429a      	cmpeq	r2, r3
341a4e68:	d171      	bne.n	341a4f4e <pow+0x196>
341a4e6a:	4aca      	ldr	r2, [pc, #808]	@ (341a5194 <pow+0x3dc>)
341a4e6c:	4294      	cmp	r4, r2
341a4e6e:	bf08      	it	eq
341a4e70:	429d      	cmpeq	r5, r3
341a4e72:	d0dd      	beq.n	341a4e30 <pow+0x78>
341a4e74:	4294      	cmp	r4, r2
341a4e76:	ea6f 0a0a 	mvn.w	sl, sl
341a4e7a:	bf34      	ite	cc
341a4e7c:	2400      	movcc	r4, #0
341a4e7e:	2401      	movcs	r4, #1
341a4e80:	ea4f 7ada 	mov.w	sl, sl, lsr #31
341a4e84:	4554      	cmp	r4, sl
341a4e86:	f040 81dc 	bne.w	341a5242 <pow+0x48a>
341a4e8a:	ee21 0b01 	vmul.f64	d0, d1, d1
341a4e8e:	b007      	add	sp, #28
341a4e90:	ecbd 8b0a 	vpop	{d8-d12}
341a4e94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a4e98:	196f      	adds	r7, r5, r5
341a4e9a:	eb44 0904 	adc.w	r9, r4, r4
341a4e9e:	1e7a      	subs	r2, r7, #1
341a4ea0:	f169 0300 	sbc.w	r3, r9, #0
341a4ea4:	4593      	cmp	fp, r2
341a4ea6:	eb7e 0303 	sbcs.w	r3, lr, r3
341a4eaa:	d225      	bcs.n	341a4ef8 <pow+0x140>
341a4eac:	2c00      	cmp	r4, #0
341a4eae:	ee20 0b00 	vmul.f64	d0, d0, d0
341a4eb2:	da13      	bge.n	341a4edc <pow+0x124>
341a4eb4:	4651      	mov	r1, sl
341a4eb6:	f7ff ff4b 	bl	341a4d50 <checkint>
341a4eba:	2801      	cmp	r0, #1
341a4ebc:	d10e      	bne.n	341a4edc <pow+0x124>
341a4ebe:	eeb1 0b40 	vneg.f64	d0, d0
341a4ec2:	ea57 0909 	orrs.w	r9, r7, r9
341a4ec6:	d10b      	bne.n	341a4ee0 <pow+0x128>
341a4ec8:	f1ba 0f00 	cmp.w	sl, #0
341a4ecc:	dadf      	bge.n	341a4e8e <pow+0xd6>
341a4ece:	b007      	add	sp, #28
341a4ed0:	ecbd 8b0a 	vpop	{d8-d12}
341a4ed4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a4ed8:	f000 bc26 	b.w	341a5728 <__math_divzero>
341a4edc:	2000      	movs	r0, #0
341a4ede:	e7f0      	b.n	341a4ec2 <pow+0x10a>
341a4ee0:	f1ba 0f00 	cmp.w	sl, #0
341a4ee4:	dad3      	bge.n	341a4e8e <pow+0xd6>
341a4ee6:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
341a4eea:	ee86 7b00 	vdiv.f64	d7, d6, d0
341a4eee:	ed8d 7b00 	vstr	d7, [sp]
341a4ef2:	ed9d 0b00 	vldr	d0, [sp]
341a4ef6:	e7ca      	b.n	341a4e8e <pow+0xd6>
341a4ef8:	2c00      	cmp	r4, #0
341a4efa:	da2b      	bge.n	341a4f54 <pow+0x19c>
341a4efc:	4651      	mov	r1, sl
341a4efe:	f7ff ff27 	bl	341a4d50 <checkint>
341a4f02:	b930      	cbnz	r0, 341a4f12 <pow+0x15a>
341a4f04:	b007      	add	sp, #28
341a4f06:	ecbd 8b0a 	vpop	{d8-d12}
341a4f0a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a4f0e:	f000 bc27 	b.w	341a5760 <__math_invalid>
341a4f12:	1e41      	subs	r1, r0, #1
341a4f14:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
341a4f18:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
341a4f1c:	4248      	negs	r0, r1
341a4f1e:	4148      	adcs	r0, r1
341a4f20:	0480      	lsls	r0, r0, #18
341a4f22:	f3c6 020a 	ubfx	r2, r6, #0, #11
341a4f26:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
341a4f2a:	2b7f      	cmp	r3, #127	@ 0x7f
341a4f2c:	d92d      	bls.n	341a4f8a <pow+0x1d2>
341a4f2e:	2000      	movs	r0, #0
341a4f30:	4b95      	ldr	r3, [pc, #596]	@ (341a5188 <pow+0x3d0>)
341a4f32:	429c      	cmp	r4, r3
341a4f34:	bf08      	it	eq
341a4f36:	4285      	cmpeq	r5, r0
341a4f38:	f43f af7a 	beq.w	341a4e30 <pow+0x78>
341a4f3c:	f240 31bd 	movw	r1, #957	@ 0x3bd
341a4f40:	428a      	cmp	r2, r1
341a4f42:	d80c      	bhi.n	341a4f5e <pow+0x1a6>
341a4f44:	42a8      	cmp	r0, r5
341a4f46:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a4f4a:	41a3      	sbcs	r3, r4
341a4f4c:	d204      	bcs.n	341a4f58 <pow+0x1a0>
341a4f4e:	ee31 0b00 	vadd.f64	d0, d1, d0
341a4f52:	e79c      	b.n	341a4e8e <pow+0xd6>
341a4f54:	2000      	movs	r0, #0
341a4f56:	e7e4      	b.n	341a4f22 <pow+0x16a>
341a4f58:	ee30 0b41 	vsub.f64	d0, d0, d1
341a4f5c:	e797      	b.n	341a4e8e <pow+0xd6>
341a4f5e:	2d01      	cmp	r5, #1
341a4f60:	f240 72ff 	movw	r2, #2047	@ 0x7ff
341a4f64:	eb74 0303 	sbcs.w	r3, r4, r3
341a4f68:	bf34      	ite	cc
341a4f6a:	2301      	movcc	r3, #1
341a4f6c:	2300      	movcs	r3, #0
341a4f6e:	4296      	cmp	r6, r2
341a4f70:	bf8c      	ite	hi
341a4f72:	2600      	movhi	r6, #0
341a4f74:	2601      	movls	r6, #1
341a4f76:	42b3      	cmp	r3, r6
341a4f78:	f000 809c 	beq.w	341a50b4 <pow+0x2fc>
341a4f7c:	b007      	add	sp, #28
341a4f7e:	ecbd 8b0a 	vpop	{d8-d12}
341a4f82:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a4f86:	f000 bbc7 	b.w	341a5718 <__math_oflow>
341a4f8a:	f1bc 0f00 	cmp.w	ip, #0
341a4f8e:	d10a      	bne.n	341a4fa6 <pow+0x1ee>
341a4f90:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 341a5178 <pow+0x3c0>
341a4f94:	ee20 7b07 	vmul.f64	d7, d0, d7
341a4f98:	ec53 2b17 	vmov	r2, r3, d7
341a4f9c:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
341a4fa0:	4615      	mov	r5, r2
341a4fa2:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
341a4fa6:	4a7c      	ldr	r2, [pc, #496]	@ (341a5198 <pow+0x3e0>)
341a4fa8:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
341a4fac:	4422      	add	r2, r4
341a4fae:	1513      	asrs	r3, r2, #20
341a4fb0:	f3c2 3146 	ubfx	r1, r2, #13, #7
341a4fb4:	f36f 0213 	bfc	r2, #0, #20
341a4fb8:	ee03 3a10 	vmov	s6, r3
341a4fbc:	4b77      	ldr	r3, [pc, #476]	@ (341a519c <pow+0x3e4>)
341a4fbe:	1aa7      	subs	r7, r4, r2
341a4fc0:	eb03 1641 	add.w	r6, r3, r1, lsl #5
341a4fc4:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
341a4fc8:	eb03 1241 	add.w	r2, r3, r1, lsl #5
341a4fcc:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
341a4fd0:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
341a4fd4:	1e2e      	subs	r6, r5, #0
341a4fd6:	ec47 6b14 	vmov	d4, r6, r7
341a4fda:	eea4 6b05 	vfma.f64	d6, d4, d5
341a4fde:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
341a4fe2:	ed93 5b00 	vldr	d5, [r3]
341a4fe6:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
341a4fea:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
341a4fee:	eea3 2b05 	vfma.f64	d2, d3, d5
341a4ff2:	ed93 5b02 	vldr	d5, [r3, #8]
341a4ff6:	eea3 7b05 	vfma.f64	d7, d3, d5
341a4ffa:	ee36 4b02 	vadd.f64	d4, d6, d2
341a4ffe:	ed93 5b04 	vldr	d5, [r3, #16]
341a5002:	ee32 2b44 	vsub.f64	d2, d2, d4
341a5006:	ee26 5b05 	vmul.f64	d5, d6, d5
341a500a:	ee32 2b06 	vadd.f64	d2, d2, d6
341a500e:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
341a5012:	ee26 0b05 	vmul.f64	d0, d6, d5
341a5016:	ee37 7b02 	vadd.f64	d7, d7, d2
341a501a:	ee34 8b00 	vadd.f64	d8, d4, d0
341a501e:	eeb0 9b40 	vmov.f64	d9, d0
341a5022:	ee26 bb00 	vmul.f64	d11, d6, d0
341a5026:	ee34 4b48 	vsub.f64	d4, d4, d8
341a502a:	ee96 9b05 	vfnms.f64	d9, d6, d5
341a502e:	ee34 ab00 	vadd.f64	d10, d4, d0
341a5032:	ed93 5b06 	vldr	d5, [r3, #24]
341a5036:	ed93 4b08 	vldr	d4, [r3, #32]
341a503a:	eea6 5b04 	vfma.f64	d5, d6, d4
341a503e:	ee37 7b09 	vadd.f64	d7, d7, d9
341a5042:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
341a5046:	ee37 7b0a 	vadd.f64	d7, d7, d10
341a504a:	eea6 4b03 	vfma.f64	d4, d6, d3
341a504e:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
341a5052:	eea6 3b0c 	vfma.f64	d3, d6, d12
341a5056:	eea0 4b03 	vfma.f64	d4, d0, d3
341a505a:	eea0 5b04 	vfma.f64	d5, d0, d4
341a505e:	eeab 7b05 	vfma.f64	d7, d11, d5
341a5062:	ee38 4b07 	vadd.f64	d4, d8, d7
341a5066:	ee21 6b04 	vmul.f64	d6, d1, d4
341a506a:	ee38 8b44 	vsub.f64	d8, d8, d4
341a506e:	eeb0 5b46 	vmov.f64	d5, d6
341a5072:	ee16 3a90 	vmov	r3, s13
341a5076:	ee38 8b07 	vadd.f64	d8, d8, d7
341a507a:	f3c3 560a 	ubfx	r6, r3, #20, #11
341a507e:	ee91 5b04 	vfnms.f64	d5, d1, d4
341a5082:	18b2      	adds	r2, r6, r2
341a5084:	2a3e      	cmp	r2, #62	@ 0x3e
341a5086:	eea1 5b08 	vfma.f64	d5, d1, d8
341a508a:	d91b      	bls.n	341a50c4 <pow+0x30c>
341a508c:	2a00      	cmp	r2, #0
341a508e:	da0b      	bge.n	341a50a8 <pow+0x2f0>
341a5090:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a5094:	ee36 0b00 	vadd.f64	d0, d6, d0
341a5098:	2800      	cmp	r0, #0
341a509a:	f43f aef8 	beq.w	341a4e8e <pow+0xd6>
341a509e:	eeb1 0b40 	vneg.f64	d0, d0
341a50a2:	e6f4      	b.n	341a4e8e <pow+0xd6>
341a50a4:	2000      	movs	r0, #0
341a50a6:	e77e      	b.n	341a4fa6 <pow+0x1ee>
341a50a8:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
341a50ac:	d909      	bls.n	341a50c2 <pow+0x30a>
341a50ae:	2b00      	cmp	r3, #0
341a50b0:	f6bf af64 	bge.w	341a4f7c <pow+0x1c4>
341a50b4:	b007      	add	sp, #28
341a50b6:	ecbd 8b0a 	vpop	{d8-d12}
341a50ba:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a50be:	f000 bb23 	b.w	341a5708 <__math_uflow>
341a50c2:	2600      	movs	r6, #0
341a50c4:	4936      	ldr	r1, [pc, #216]	@ (341a51a0 <pow+0x3e8>)
341a50c6:	2700      	movs	r7, #0
341a50c8:	ed91 4b02 	vldr	d4, [r1, #8]
341a50cc:	ed91 3b00 	vldr	d3, [r1]
341a50d0:	eeb0 7b44 	vmov.f64	d7, d4
341a50d4:	eea6 7b03 	vfma.f64	d7, d6, d3
341a50d8:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
341a50dc:	ee17 5a10 	vmov	r5, s14
341a50e0:	ee37 7b44 	vsub.f64	d7, d7, d4
341a50e4:	ed91 4b04 	vldr	d4, [r1, #16]
341a50e8:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
341a50ec:	eea7 6b04 	vfma.f64	d6, d7, d4
341a50f0:	18dc      	adds	r4, r3, r3
341a50f2:	1940      	adds	r0, r0, r5
341a50f4:	f104 030f 	add.w	r3, r4, #15
341a50f8:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
341a50fc:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
341a5100:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
341a5104:	ed91 4b06 	vldr	d4, [r1, #24]
341a5108:	f8d2 e004 	ldr.w	lr, [r2, #4]
341a510c:	eb17 020c 	adds.w	r2, r7, ip
341a5110:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
341a5114:	eea7 6b04 	vfma.f64	d6, d7, d4
341a5118:	ed91 4b08 	vldr	d4, [r1, #32]
341a511c:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
341a5120:	ee35 5b06 	vadd.f64	d5, d5, d6
341a5124:	eea5 4b03 	vfma.f64	d4, d5, d3
341a5128:	ee25 6b05 	vmul.f64	d6, d5, d5
341a512c:	ee35 7b07 	vadd.f64	d7, d5, d7
341a5130:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
341a5134:	eea6 7b04 	vfma.f64	d7, d6, d4
341a5138:	ee26 6b06 	vmul.f64	d6, d6, d6
341a513c:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
341a5140:	eea5 4b03 	vfma.f64	d4, d5, d3
341a5144:	eea6 7b04 	vfma.f64	d7, d6, d4
341a5148:	2e00      	cmp	r6, #0
341a514a:	d175      	bne.n	341a5238 <pow+0x480>
341a514c:	42bd      	cmp	r5, r7
341a514e:	db29      	blt.n	341a51a4 <pow+0x3ec>
341a5150:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
341a5154:	4610      	mov	r0, r2
341a5156:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
341a515a:	ec41 0b10 	vmov	d0, r0, r1
341a515e:	eea7 0b00 	vfma.f64	d0, d7, d0
341a5162:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 341a5180 <pow+0x3c8>
341a5166:	ee20 0b07 	vmul.f64	d0, d0, d7
341a516a:	b007      	add	sp, #28
341a516c:	ecbd 8b0a 	vpop	{d8-d12}
341a5170:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a5174:	f000 bb0c 	b.w	341a5790 <__math_check_oflow>
341a5178:	00000000 	.word	0x00000000
341a517c:	43300000 	.word	0x43300000
341a5180:	00000000 	.word	0x00000000
341a5184:	7f000000 	.word	0x7f000000
341a5188:	3ff00000 	.word	0x3ff00000
341a518c:	fff00000 	.word	0xfff00000
341a5190:	ffe00000 	.word	0xffe00000
341a5194:	7fe00000 	.word	0x7fe00000
341a5198:	c0196aab 	.word	0xc0196aab
341a519c:	341b7d90 	.word	0x341b7d90
341a51a0:	341b8dd8 	.word	0x341b8dd8
341a51a4:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
341a51a8:	4610      	mov	r0, r2
341a51aa:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
341a51ae:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
341a51b2:	ec41 0b15 	vmov	d5, r0, r1
341a51b6:	ee27 6b05 	vmul.f64	d6, d7, d5
341a51ba:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 341a5248 <pow+0x490>
341a51be:	ee35 7b06 	vadd.f64	d7, d5, d6
341a51c2:	eeb0 4bc7 	vabs.f64	d4, d7
341a51c6:	eeb4 4bc3 	vcmpe.f64	d4, d3
341a51ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a51ce:	d52a      	bpl.n	341a5226 <pow+0x46e>
341a51d0:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
341a51d4:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
341a51d8:	ee35 5b47 	vsub.f64	d5, d5, d7
341a51dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a51e0:	ee35 5b06 	vadd.f64	d5, d5, d6
341a51e4:	bf58      	it	pl
341a51e6:	eeb0 4b43 	vmovpl.f64	d4, d3
341a51ea:	ee37 3b04 	vadd.f64	d3, d7, d4
341a51ee:	ee34 6b43 	vsub.f64	d6, d4, d3
341a51f2:	ee36 6b07 	vadd.f64	d6, d6, d7
341a51f6:	ee36 6b05 	vadd.f64	d6, d6, d5
341a51fa:	ee36 6b03 	vadd.f64	d6, d6, d3
341a51fe:	ee36 7b44 	vsub.f64	d7, d6, d4
341a5202:	eeb5 7b40 	vcmp.f64	d7, #0.0
341a5206:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a520a:	d104      	bne.n	341a5216 <pow+0x45e>
341a520c:	4632      	mov	r2, r6
341a520e:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
341a5212:	ec43 2b17 	vmov	d7, r2, r3
341a5216:	ed8d 0b02 	vstr	d0, [sp, #8]
341a521a:	ed9d 6b02 	vldr	d6, [sp, #8]
341a521e:	ee26 6b00 	vmul.f64	d6, d6, d0
341a5222:	ed8d 6b04 	vstr	d6, [sp, #16]
341a5226:	ee27 0b00 	vmul.f64	d0, d7, d0
341a522a:	b007      	add	sp, #28
341a522c:	ecbd 8b0a 	vpop	{d8-d12}
341a5230:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a5234:	f000 baa3 	b.w	341a577e <__math_check_uflow>
341a5238:	ec43 2b10 	vmov	d0, r2, r3
341a523c:	eea7 0b00 	vfma.f64	d0, d7, d0
341a5240:	e625      	b.n	341a4e8e <pow+0xd6>
341a5242:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 341a5250 <pow+0x498>
341a5246:	e622      	b.n	341a4e8e <pow+0xd6>
341a5248:	00000000 	.word	0x00000000
341a524c:	00100000 	.word	0x00100000
	...

341a5258 <checkint>:
341a5258:	f3c0 53c7 	ubfx	r3, r0, #23, #8
341a525c:	2b7e      	cmp	r3, #126	@ 0x7e
341a525e:	d910      	bls.n	341a5282 <checkint+0x2a>
341a5260:	2b96      	cmp	r3, #150	@ 0x96
341a5262:	d80c      	bhi.n	341a527e <checkint+0x26>
341a5264:	2201      	movs	r2, #1
341a5266:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
341a526a:	fa02 f303 	lsl.w	r3, r2, r3
341a526e:	1e5a      	subs	r2, r3, #1
341a5270:	4202      	tst	r2, r0
341a5272:	d106      	bne.n	341a5282 <checkint+0x2a>
341a5274:	4203      	tst	r3, r0
341a5276:	bf14      	ite	ne
341a5278:	2001      	movne	r0, #1
341a527a:	2002      	moveq	r0, #2
341a527c:	4770      	bx	lr
341a527e:	2002      	movs	r0, #2
341a5280:	4770      	bx	lr
341a5282:	2000      	movs	r0, #0
341a5284:	4770      	bx	lr
	...

341a5288 <powf>:
341a5288:	b537      	push	{r0, r1, r2, r4, r5, lr}
341a528a:	ee10 1a10 	vmov	r1, s0
341a528e:	ee10 4a90 	vmov	r4, s1
341a5292:	eef0 7a40 	vmov.f32	s15, s0
341a5296:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
341a529a:	0063      	lsls	r3, r4, #1
341a529c:	eeb0 7a60 	vmov.f32	s14, s1
341a52a0:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
341a52a4:	f103 30ff 	add.w	r0, r3, #4294967295
341a52a8:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
341a52ac:	d252      	bcs.n	341a5354 <powf+0xcc>
341a52ae:	4290      	cmp	r0, r2
341a52b0:	d258      	bcs.n	341a5364 <powf+0xdc>
341a52b2:	2000      	movs	r0, #0
341a52b4:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
341a52b8:	4a9f      	ldr	r2, [pc, #636]	@ (341a5538 <powf+0x2b0>)
341a52ba:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
341a52be:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
341a52c2:	f3c3 44c3 	ubfx	r4, r3, #19, #4
341a52c6:	f36f 0316 	bfc	r3, #0, #23
341a52ca:	1ac9      	subs	r1, r1, r3
341a52cc:	eb02 1404 	add.w	r4, r2, r4, lsl #4
341a52d0:	15db      	asrs	r3, r3, #23
341a52d2:	ee07 1a90 	vmov	s15, r1
341a52d6:	ed94 4b00 	vldr	d4, [r4]
341a52da:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
341a52de:	ee07 3a90 	vmov	s15, r3
341a52e2:	ed94 5b02 	vldr	d5, [r4, #8]
341a52e6:	eea4 2b06 	vfma.f64	d2, d4, d6
341a52ea:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341a52ee:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
341a52f2:	ee36 6b05 	vadd.f64	d6, d6, d5
341a52f6:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
341a52fa:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
341a52fe:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
341a5302:	ee22 4b02 	vmul.f64	d4, d2, d2
341a5306:	eea2 1b05 	vfma.f64	d1, d2, d5
341a530a:	ee24 0b04 	vmul.f64	d0, d4, d4
341a530e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
341a5312:	eea2 5b03 	vfma.f64	d5, d2, d3
341a5316:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
341a531a:	eea2 6b03 	vfma.f64	d6, d2, d3
341a531e:	eea4 6b05 	vfma.f64	d6, d4, d5
341a5322:	eea1 6b00 	vfma.f64	d6, d1, d0
341a5326:	ee27 7b06 	vmul.f64	d7, d7, d6
341a532a:	ee17 3a90 	vmov	r3, s15
341a532e:	f3c3 32cf 	ubfx	r2, r3, #15, #16
341a5332:	f248 03bf 	movw	r3, #32959	@ 0x80bf
341a5336:	429a      	cmp	r2, r3
341a5338:	f0c0 8098 	bcc.w	341a546c <powf+0x1e4>
341a533c:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 341a5518 <powf+0x290>
341a5340:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a5344:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a5348:	dd79      	ble.n	341a543e <powf+0x1b6>
341a534a:	b003      	add	sp, #12
341a534c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a5350:	f000 b920 	b.w	341a5594 <__math_oflowf>
341a5354:	4290      	cmp	r0, r2
341a5356:	d330      	bcc.n	341a53ba <powf+0x132>
341a5358:	b12b      	cbz	r3, 341a5366 <powf+0xde>
341a535a:	0049      	lsls	r1, r1, #1
341a535c:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
341a5360:	d808      	bhi.n	341a5374 <powf+0xec>
341a5362:	e015      	b.n	341a5390 <powf+0x108>
341a5364:	b953      	cbnz	r3, 341a537c <powf+0xf4>
341a5366:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
341a536a:	0049      	lsls	r1, r1, #1
341a536c:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
341a5370:	f240 80ca 	bls.w	341a5508 <powf+0x280>
341a5374:	ee37 0a87 	vadd.f32	s0, s15, s14
341a5378:	b003      	add	sp, #12
341a537a:	bd30      	pop	{r4, r5, pc}
341a537c:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
341a5380:	d105      	bne.n	341a538e <powf+0x106>
341a5382:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
341a5386:	0064      	lsls	r4, r4, #1
341a5388:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
341a538c:	e7f0      	b.n	341a5370 <powf+0xe8>
341a538e:	0049      	lsls	r1, r1, #1
341a5390:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
341a5394:	d1ee      	bne.n	341a5374 <powf+0xec>
341a5396:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
341a539a:	f000 80b5 	beq.w	341a5508 <powf+0x280>
341a539e:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
341a53a2:	ea6f 0404 	mvn.w	r4, r4
341a53a6:	bf34      	ite	cc
341a53a8:	2100      	movcc	r1, #0
341a53aa:	2101      	movcs	r1, #1
341a53ac:	0fe4      	lsrs	r4, r4, #31
341a53ae:	42a1      	cmp	r1, r4
341a53b0:	f040 80ad 	bne.w	341a550e <powf+0x286>
341a53b4:	ee27 0a07 	vmul.f32	s0, s14, s14
341a53b8:	e7de      	b.n	341a5378 <powf+0xf0>
341a53ba:	004d      	lsls	r5, r1, #1
341a53bc:	1e6b      	subs	r3, r5, #1
341a53be:	4293      	cmp	r3, r2
341a53c0:	d31b      	bcc.n	341a53fa <powf+0x172>
341a53c2:	2900      	cmp	r1, #0
341a53c4:	ee20 0a00 	vmul.f32	s0, s0, s0
341a53c8:	da0e      	bge.n	341a53e8 <powf+0x160>
341a53ca:	4620      	mov	r0, r4
341a53cc:	f7ff ff44 	bl	341a5258 <checkint>
341a53d0:	2801      	cmp	r0, #1
341a53d2:	d109      	bne.n	341a53e8 <powf+0x160>
341a53d4:	eeb1 0a40 	vneg.f32	s0, s0
341a53d8:	b945      	cbnz	r5, 341a53ec <powf+0x164>
341a53da:	2c00      	cmp	r4, #0
341a53dc:	dacc      	bge.n	341a5378 <powf+0xf0>
341a53de:	b003      	add	sp, #12
341a53e0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a53e4:	f000 b8dc 	b.w	341a55a0 <__math_divzerof>
341a53e8:	2000      	movs	r0, #0
341a53ea:	e7f5      	b.n	341a53d8 <powf+0x150>
341a53ec:	2c00      	cmp	r4, #0
341a53ee:	dac3      	bge.n	341a5378 <powf+0xf0>
341a53f0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341a53f4:	ee87 0a80 	vdiv.f32	s0, s15, s0
341a53f8:	e7be      	b.n	341a5378 <powf+0xf0>
341a53fa:	2900      	cmp	r1, #0
341a53fc:	da1d      	bge.n	341a543a <powf+0x1b2>
341a53fe:	4620      	mov	r0, r4
341a5400:	f7ff ff2a 	bl	341a5258 <checkint>
341a5404:	b920      	cbnz	r0, 341a5410 <powf+0x188>
341a5406:	b003      	add	sp, #12
341a5408:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a540c:	f000 b8da 	b.w	341a55c4 <__math_invalidf>
341a5410:	1e43      	subs	r3, r0, #1
341a5412:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
341a5416:	4258      	negs	r0, r3
341a5418:	4158      	adcs	r0, r3
341a541a:	0400      	lsls	r0, r0, #16
341a541c:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
341a5420:	f4bf af48 	bcs.w	341a52b4 <powf+0x2c>
341a5424:	eddf 6a45 	vldr	s13, [pc, #276]	@ 341a553c <powf+0x2b4>
341a5428:	ee27 0aa6 	vmul.f32	s0, s15, s13
341a542c:	ee10 3a10 	vmov	r3, s0
341a5430:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341a5434:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
341a5438:	e73c      	b.n	341a52b4 <powf+0x2c>
341a543a:	2000      	movs	r0, #0
341a543c:	e7ee      	b.n	341a541c <powf+0x194>
341a543e:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 341a5520 <powf+0x298>
341a5442:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a5446:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a544a:	dd45      	ble.n	341a54d8 <powf+0x250>
341a544c:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
341a5450:	b3d0      	cbz	r0, 341a54c8 <powf+0x240>
341a5452:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
341a5456:	9301      	str	r3, [sp, #4]
341a5458:	eddd 6a01 	vldr	s13, [sp, #4]
341a545c:	ee76 6a66 	vsub.f32	s13, s12, s13
341a5460:	eef4 6a46 	vcmp.f32	s13, s12
341a5464:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a5468:	f47f af6f 	bne.w	341a534a <powf+0xc2>
341a546c:	4b34      	ldr	r3, [pc, #208]	@ (341a5540 <powf+0x2b8>)
341a546e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a5472:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
341a5476:	ee37 6b05 	vadd.f64	d6, d7, d5
341a547a:	ee16 2a10 	vmov	r2, s12
341a547e:	ee36 6b45 	vsub.f64	d6, d6, d5
341a5482:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
341a5486:	ee37 7b46 	vsub.f64	d7, d7, d6
341a548a:	f002 011f 	and.w	r1, r2, #31
341a548e:	1880      	adds	r0, r0, r2
341a5490:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
341a5494:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
341a5498:	ee27 4b07 	vmul.f64	d4, d7, d7
341a549c:	2100      	movs	r1, #0
341a549e:	686d      	ldr	r5, [r5, #4]
341a54a0:	190a      	adds	r2, r1, r4
341a54a2:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
341a54a6:	eea7 6b05 	vfma.f64	d6, d7, d5
341a54aa:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
341a54ae:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
341a54b2:	eea7 0b05 	vfma.f64	d0, d7, d5
341a54b6:	ec43 2b17 	vmov	d7, r2, r3
341a54ba:	eea6 0b04 	vfma.f64	d0, d6, d4
341a54be:	ee20 0b07 	vmul.f64	d0, d0, d7
341a54c2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
341a54c6:	e757      	b.n	341a5378 <powf+0xf0>
341a54c8:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
341a54cc:	9300      	str	r3, [sp, #0]
341a54ce:	eddd 6a00 	vldr	s13, [sp]
341a54d2:	ee76 6a86 	vadd.f32	s13, s13, s12
341a54d6:	e7c3      	b.n	341a5460 <powf+0x1d8>
341a54d8:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 341a5528 <powf+0x2a0>
341a54dc:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a54e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a54e4:	d804      	bhi.n	341a54f0 <powf+0x268>
341a54e6:	b003      	add	sp, #12
341a54e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a54ec:	f000 b846 	b.w	341a557c <__math_uflowf>
341a54f0:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 341a5530 <powf+0x2a8>
341a54f4:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a54f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a54fc:	d5b6      	bpl.n	341a546c <powf+0x1e4>
341a54fe:	b003      	add	sp, #12
341a5500:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a5504:	f000 b840 	b.w	341a5588 <__math_may_uflowf>
341a5508:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
341a550c:	e734      	b.n	341a5378 <powf+0xf0>
341a550e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 341a5544 <powf+0x2bc>
341a5512:	e731      	b.n	341a5378 <powf+0xf0>
341a5514:	f3af 8000 	nop.w
341a5518:	ffd1d571 	.word	0xffd1d571
341a551c:	405fffff 	.word	0x405fffff
341a5520:	ffa3aae2 	.word	0xffa3aae2
341a5524:	405fffff 	.word	0x405fffff
341a5528:	00000000 	.word	0x00000000
341a552c:	c062c000 	.word	0xc062c000
341a5530:	00000000 	.word	0x00000000
341a5534:	c062a000 	.word	0xc062a000
341a5538:	341ba020 	.word	0x341ba020
341a553c:	4b000000 	.word	0x4b000000
341a5540:	341b9ed8 	.word	0x341b9ed8
341a5544:	00000000 	.word	0x00000000

341a5548 <with_errnof>:
341a5548:	b510      	push	{r4, lr}
341a554a:	ed2d 8b02 	vpush	{d8}
341a554e:	eeb0 8a40 	vmov.f32	s16, s0
341a5552:	4604      	mov	r4, r0
341a5554:	f7fe fc74 	bl	341a3e40 <__errno>
341a5558:	6004      	str	r4, [r0, #0]
341a555a:	eeb0 0a48 	vmov.f32	s0, s16
341a555e:	ecbd 8b02 	vpop	{d8}
341a5562:	bd10      	pop	{r4, pc}

341a5564 <xflowf>:
341a5564:	b130      	cbz	r0, 341a5574 <xflowf+0x10>
341a5566:	eef1 7a40 	vneg.f32	s15, s0
341a556a:	ee27 0a80 	vmul.f32	s0, s15, s0
341a556e:	2022      	movs	r0, #34	@ 0x22
341a5570:	f7ff bfea 	b.w	341a5548 <with_errnof>
341a5574:	eef0 7a40 	vmov.f32	s15, s0
341a5578:	e7f7      	b.n	341a556a <xflowf+0x6>
	...

341a557c <__math_uflowf>:
341a557c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a5584 <__math_uflowf+0x8>
341a5580:	f7ff bff0 	b.w	341a5564 <xflowf>
341a5584:	10000000 	.word	0x10000000

341a5588 <__math_may_uflowf>:
341a5588:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a5590 <__math_may_uflowf+0x8>
341a558c:	f7ff bfea 	b.w	341a5564 <xflowf>
341a5590:	1a200000 	.word	0x1a200000

341a5594 <__math_oflowf>:
341a5594:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a559c <__math_oflowf+0x8>
341a5598:	f7ff bfe4 	b.w	341a5564 <xflowf>
341a559c:	70000000 	.word	0x70000000

341a55a0 <__math_divzerof>:
341a55a0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341a55a4:	2800      	cmp	r0, #0
341a55a6:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
341a55aa:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 341a55c0 <__math_divzerof+0x20>
341a55ae:	f04f 0022 	mov.w	r0, #34	@ 0x22
341a55b2:	fe47 7a87 	vseleq.f32	s15, s15, s14
341a55b6:	ee87 0a80 	vdiv.f32	s0, s15, s0
341a55ba:	f7ff bfc5 	b.w	341a5548 <with_errnof>
341a55be:	bf00      	nop
341a55c0:	00000000 	.word	0x00000000

341a55c4 <__math_invalidf>:
341a55c4:	eef0 7a40 	vmov.f32	s15, s0
341a55c8:	ee30 7a40 	vsub.f32	s14, s0, s0
341a55cc:	eef4 7a67 	vcmp.f32	s15, s15
341a55d0:	ee87 0a07 	vdiv.f32	s0, s14, s14
341a55d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a55d8:	d602      	bvs.n	341a55e0 <__math_invalidf+0x1c>
341a55da:	2021      	movs	r0, #33	@ 0x21
341a55dc:	f7ff bfb4 	b.w	341a5548 <with_errnof>
341a55e0:	4770      	bx	lr

341a55e2 <__ieee754_sqrt>:
341a55e2:	eeb1 0bc0 	vsqrt.f64	d0, d0
341a55e6:	4770      	bx	lr

341a55e8 <__ieee754_log10>:
341a55e8:	ee10 3a90 	vmov	r3, s1
341a55ec:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341a55f0:	b510      	push	{r4, lr}
341a55f2:	ed2d 8b02 	vpush	{d8}
341a55f6:	da21      	bge.n	341a563c <__ieee754_log10+0x54>
341a55f8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
341a55fc:	ee10 1a10 	vmov	r1, s0
341a5600:	430a      	orrs	r2, r1
341a5602:	d108      	bne.n	341a5616 <__ieee754_log10+0x2e>
341a5604:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 341a5690 <__ieee754_log10+0xa8>
341a5608:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 341a5698 <__ieee754_log10+0xb0>
341a560c:	ee86 0b07 	vdiv.f64	d0, d6, d7
341a5610:	ecbd 8b02 	vpop	{d8}
341a5614:	bd10      	pop	{r4, pc}
341a5616:	2b00      	cmp	r3, #0
341a5618:	da02      	bge.n	341a5620 <__ieee754_log10+0x38>
341a561a:	ee30 6b40 	vsub.f64	d6, d0, d0
341a561e:	e7f3      	b.n	341a5608 <__ieee754_log10+0x20>
341a5620:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 341a56a0 <__ieee754_log10+0xb8>
341a5624:	f06f 0235 	mvn.w	r2, #53	@ 0x35
341a5628:	ee20 0b07 	vmul.f64	d0, d0, d7
341a562c:	ee10 3a90 	vmov	r3, s1
341a5630:	4923      	ldr	r1, [pc, #140]	@ (341a56c0 <__ieee754_log10+0xd8>)
341a5632:	428b      	cmp	r3, r1
341a5634:	dd04      	ble.n	341a5640 <__ieee754_log10+0x58>
341a5636:	ee30 0b00 	vadd.f64	d0, d0, d0
341a563a:	e7e9      	b.n	341a5610 <__ieee754_log10+0x28>
341a563c:	2200      	movs	r2, #0
341a563e:	e7f7      	b.n	341a5630 <__ieee754_log10+0x48>
341a5640:	1518      	asrs	r0, r3, #20
341a5642:	f240 34ff 	movw	r4, #1023	@ 0x3ff
341a5646:	f3c3 0113 	ubfx	r1, r3, #0, #20
341a564a:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
341a564e:	4410      	add	r0, r2
341a5650:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
341a5654:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
341a5658:	ee08 3a10 	vmov	s16, r3
341a565c:	ec53 2b10 	vmov	r2, r3, d0
341a5660:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
341a5664:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
341a5668:	ec43 2b10 	vmov	d0, r2, r3
341a566c:	f000 f8a4 	bl	341a57b8 <log>
341a5670:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a56a8 <__ieee754_log10+0xc0>
341a5674:	ee20 0b07 	vmul.f64	d0, d0, d7
341a5678:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a56b0 <__ieee754_log10+0xc8>
341a567c:	eea8 0b07 	vfma.f64	d0, d8, d7
341a5680:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a56b8 <__ieee754_log10+0xd0>
341a5684:	eea8 0b07 	vfma.f64	d0, d8, d7
341a5688:	e7c2      	b.n	341a5610 <__ieee754_log10+0x28>
341a568a:	bf00      	nop
341a568c:	f3af 8000 	nop.w
341a5690:	00000000 	.word	0x00000000
341a5694:	c3500000 	.word	0xc3500000
	...
341a56a4:	43500000 	.word	0x43500000
341a56a8:	1526e50e 	.word	0x1526e50e
341a56ac:	3fdbcb7b 	.word	0x3fdbcb7b
341a56b0:	11f12b36 	.word	0x11f12b36
341a56b4:	3d59fef3 	.word	0x3d59fef3
341a56b8:	509f6000 	.word	0x509f6000
341a56bc:	3fd34413 	.word	0x3fd34413
341a56c0:	7fefffff 	.word	0x7fefffff

341a56c4 <with_errno>:
341a56c4:	b510      	push	{r4, lr}
341a56c6:	ed2d 8b02 	vpush	{d8}
341a56ca:	eeb0 8b40 	vmov.f64	d8, d0
341a56ce:	4604      	mov	r4, r0
341a56d0:	f7fe fbb6 	bl	341a3e40 <__errno>
341a56d4:	6004      	str	r4, [r0, #0]
341a56d6:	eeb0 0b48 	vmov.f64	d0, d8
341a56da:	ecbd 8b02 	vpop	{d8}
341a56de:	bd10      	pop	{r4, pc}

341a56e0 <xflow>:
341a56e0:	b082      	sub	sp, #8
341a56e2:	b158      	cbz	r0, 341a56fc <xflow+0x1c>
341a56e4:	eeb1 7b40 	vneg.f64	d7, d0
341a56e8:	2022      	movs	r0, #34	@ 0x22
341a56ea:	ed8d 7b00 	vstr	d7, [sp]
341a56ee:	ed9d 7b00 	vldr	d7, [sp]
341a56f2:	ee20 0b07 	vmul.f64	d0, d0, d7
341a56f6:	b002      	add	sp, #8
341a56f8:	f7ff bfe4 	b.w	341a56c4 <with_errno>
341a56fc:	eeb0 7b40 	vmov.f64	d7, d0
341a5700:	e7f2      	b.n	341a56e8 <xflow+0x8>
341a5702:	0000      	movs	r0, r0
341a5704:	0000      	movs	r0, r0
	...

341a5708 <__math_uflow>:
341a5708:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a5710 <__math_uflow+0x8>
341a570c:	f7ff bfe8 	b.w	341a56e0 <xflow>
341a5710:	00000000 	.word	0x00000000
341a5714:	10000000 	.word	0x10000000

341a5718 <__math_oflow>:
341a5718:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a5720 <__math_oflow+0x8>
341a571c:	f7ff bfe0 	b.w	341a56e0 <xflow>
341a5720:	00000000 	.word	0x00000000
341a5724:	70000000 	.word	0x70000000

341a5728 <__math_divzero>:
341a5728:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
341a572c:	b082      	sub	sp, #8
341a572e:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
341a5732:	2800      	cmp	r0, #0
341a5734:	f04f 0022 	mov.w	r0, #34	@ 0x22
341a5738:	fe07 7b06 	vseleq.f64	d7, d7, d6
341a573c:	ed8d 7b00 	vstr	d7, [sp]
341a5740:	ed9d 0b00 	vldr	d0, [sp]
341a5744:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 341a5758 <__math_divzero+0x30>
341a5748:	ee80 0b07 	vdiv.f64	d0, d0, d7
341a574c:	b002      	add	sp, #8
341a574e:	f7ff bfb9 	b.w	341a56c4 <with_errno>
341a5752:	bf00      	nop
341a5754:	f3af 8000 	nop.w
	...

341a5760 <__math_invalid>:
341a5760:	eeb0 7b40 	vmov.f64	d7, d0
341a5764:	ee30 6b40 	vsub.f64	d6, d0, d0
341a5768:	eeb4 7b47 	vcmp.f64	d7, d7
341a576c:	ee86 0b06 	vdiv.f64	d0, d6, d6
341a5770:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a5774:	d602      	bvs.n	341a577c <__math_invalid+0x1c>
341a5776:	2021      	movs	r0, #33	@ 0x21
341a5778:	f7ff bfa4 	b.w	341a56c4 <with_errno>
341a577c:	4770      	bx	lr

341a577e <__math_check_uflow>:
341a577e:	eeb5 0b40 	vcmp.f64	d0, #0.0
341a5782:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a5786:	d102      	bne.n	341a578e <__math_check_uflow+0x10>
341a5788:	2022      	movs	r0, #34	@ 0x22
341a578a:	f7ff bf9b 	b.w	341a56c4 <with_errno>
341a578e:	4770      	bx	lr

341a5790 <__math_check_oflow>:
341a5790:	eeb0 7bc0 	vabs.f64	d7, d0
341a5794:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 341a57b0 <__math_check_oflow+0x20>
341a5798:	eeb4 7b46 	vcmp.f64	d7, d6
341a579c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a57a0:	dd02      	ble.n	341a57a8 <__math_check_oflow+0x18>
341a57a2:	2022      	movs	r0, #34	@ 0x22
341a57a4:	f7ff bf8e 	b.w	341a56c4 <with_errno>
341a57a8:	4770      	bx	lr
341a57aa:	bf00      	nop
341a57ac:	f3af 8000 	nop.w
341a57b0:	ffffffff 	.word	0xffffffff
341a57b4:	7fefffff 	.word	0x7fefffff

341a57b8 <log>:
341a57b8:	ee10 0a90 	vmov	r0, s1
341a57bc:	ee10 3a10 	vmov	r3, s0
341a57c0:	b4f0      	push	{r4, r5, r6, r7}
341a57c2:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
341a57c6:	f04f 34ff 	mov.w	r4, #4294967295
341a57ca:	0c02      	lsrs	r2, r0, #16
341a57cc:	429c      	cmp	r4, r3
341a57ce:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
341a57d2:	4c71      	ldr	r4, [pc, #452]	@ (341a5998 <log+0x1e0>)
341a57d4:	418c      	sbcs	r4, r1
341a57d6:	ed2d 8b02 	vpush	{d8}
341a57da:	d35a      	bcc.n	341a5892 <log+0xda>
341a57dc:	4a6f      	ldr	r2, [pc, #444]	@ (341a599c <log+0x1e4>)
341a57de:	4290      	cmp	r0, r2
341a57e0:	bf08      	it	eq
341a57e2:	2b00      	cmpeq	r3, #0
341a57e4:	f000 80c7 	beq.w	341a5976 <log+0x1be>
341a57e8:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
341a57ec:	4b6c      	ldr	r3, [pc, #432]	@ (341a59a0 <log+0x1e8>)
341a57ee:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
341a57f2:	ee30 0b47 	vsub.f64	d0, d0, d7
341a57f6:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
341a57fa:	ee20 2b00 	vmul.f64	d2, d0, d0
341a57fe:	eea6 7b00 	vfma.f64	d7, d6, d0
341a5802:	ee20 4b02 	vmul.f64	d4, d0, d2
341a5806:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
341a580a:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
341a580e:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
341a5812:	eea6 7b02 	vfma.f64	d7, d6, d2
341a5816:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
341a581a:	eea5 6b00 	vfma.f64	d6, d5, d0
341a581e:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
341a5822:	eea5 6b02 	vfma.f64	d6, d5, d2
341a5826:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
341a582a:	eea3 5b00 	vfma.f64	d5, d3, d0
341a582e:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
341a5832:	eea3 5b02 	vfma.f64	d5, d3, d2
341a5836:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
341a583a:	eea3 5b04 	vfma.f64	d5, d3, d4
341a583e:	eeb0 3b40 	vmov.f64	d3, d0
341a5842:	eea5 6b04 	vfma.f64	d6, d5, d4
341a5846:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
341a584a:	eea6 7b04 	vfma.f64	d7, d6, d4
341a584e:	eeb0 6b40 	vmov.f64	d6, d0
341a5852:	eeb0 2b47 	vmov.f64	d2, d7
341a5856:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 341a5980 <log+0x1c8>
341a585a:	eea0 6b07 	vfma.f64	d6, d0, d7
341a585e:	eea0 6b47 	vfms.f64	d6, d0, d7
341a5862:	ee26 1b06 	vmul.f64	d1, d6, d6
341a5866:	ee30 8b46 	vsub.f64	d8, d0, d6
341a586a:	eea1 3b05 	vfma.f64	d3, d1, d5
341a586e:	ee30 7b43 	vsub.f64	d7, d0, d3
341a5872:	ee30 0b06 	vadd.f64	d0, d0, d6
341a5876:	eea1 7b05 	vfma.f64	d7, d1, d5
341a587a:	ee25 5b08 	vmul.f64	d5, d5, d8
341a587e:	eea5 7b00 	vfma.f64	d7, d5, d0
341a5882:	eea2 7b04 	vfma.f64	d7, d2, d4
341a5886:	ee33 0b07 	vadd.f64	d0, d3, d7
341a588a:	ecbd 8b02 	vpop	{d8}
341a588e:	bcf0      	pop	{r4, r5, r6, r7}
341a5890:	4770      	bx	lr
341a5892:	f1a2 0410 	sub.w	r4, r2, #16
341a5896:	f647 71df 	movw	r1, #32735	@ 0x7fdf
341a589a:	428c      	cmp	r4, r1
341a589c:	d923      	bls.n	341a58e6 <log+0x12e>
341a589e:	18d9      	adds	r1, r3, r3
341a58a0:	eb40 0400 	adc.w	r4, r0, r0
341a58a4:	4321      	orrs	r1, r4
341a58a6:	d105      	bne.n	341a58b4 <log+0xfc>
341a58a8:	2001      	movs	r0, #1
341a58aa:	ecbd 8b02 	vpop	{d8}
341a58ae:	bcf0      	pop	{r4, r5, r6, r7}
341a58b0:	f7ff bf3a 	b.w	341a5728 <__math_divzero>
341a58b4:	493b      	ldr	r1, [pc, #236]	@ (341a59a4 <log+0x1ec>)
341a58b6:	4288      	cmp	r0, r1
341a58b8:	bf08      	it	eq
341a58ba:	2b00      	cmpeq	r3, #0
341a58bc:	d0e5      	beq.n	341a588a <log+0xd2>
341a58be:	0413      	lsls	r3, r2, #16
341a58c0:	d403      	bmi.n	341a58ca <log+0x112>
341a58c2:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
341a58c6:	4393      	bics	r3, r2
341a58c8:	d104      	bne.n	341a58d4 <log+0x11c>
341a58ca:	ecbd 8b02 	vpop	{d8}
341a58ce:	bcf0      	pop	{r4, r5, r6, r7}
341a58d0:	f7ff bf46 	b.w	341a5760 <__math_invalid>
341a58d4:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 341a5988 <log+0x1d0>
341a58d8:	ee20 7b07 	vmul.f64	d7, d0, d7
341a58dc:	ec53 2b17 	vmov	r2, r3, d7
341a58e0:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
341a58e4:	4613      	mov	r3, r2
341a58e6:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
341a58ea:	492d      	ldr	r1, [pc, #180]	@ (341a59a0 <log+0x1e8>)
341a58ec:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
341a58f0:	1e1e      	subs	r6, r3, #0
341a58f2:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
341a58f6:	f3c2 3446 	ubfx	r4, r2, #13, #7
341a58fa:	ea4f 5c12 	mov.w	ip, r2, lsr #20
341a58fe:	1512      	asrs	r2, r2, #20
341a5900:	eb01 1504 	add.w	r5, r1, r4, lsl #4
341a5904:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
341a5908:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
341a590c:	eba0 070c 	sub.w	r7, r0, ip
341a5910:	ec47 6b16 	vmov	d6, r6, r7
341a5914:	eea7 5b06 	vfma.f64	d5, d7, d6
341a5918:	ee07 2a90 	vmov	s15, r2
341a591c:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341a5920:	ed91 4b00 	vldr	d4, [r1]
341a5924:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
341a5928:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
341a592c:	eea4 7b06 	vfma.f64	d7, d4, d6
341a5930:	ee25 2b05 	vmul.f64	d2, d5, d5
341a5934:	ee35 4b07 	vadd.f64	d4, d5, d7
341a5938:	ee25 1b02 	vmul.f64	d1, d5, d2
341a593c:	ee37 0b44 	vsub.f64	d0, d7, d4
341a5940:	ed91 7b02 	vldr	d7, [r1, #8]
341a5944:	ee30 0b05 	vadd.f64	d0, d0, d5
341a5948:	eea7 0b06 	vfma.f64	d0, d7, d6
341a594c:	ed91 7b04 	vldr	d7, [r1, #16]
341a5950:	ed91 6b08 	vldr	d6, [r1, #32]
341a5954:	eea7 0b02 	vfma.f64	d0, d7, d2
341a5958:	ed91 7b06 	vldr	d7, [r1, #24]
341a595c:	eea6 7b05 	vfma.f64	d7, d6, d5
341a5960:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
341a5964:	eea3 6b05 	vfma.f64	d6, d3, d5
341a5968:	eea6 7b02 	vfma.f64	d7, d6, d2
341a596c:	eea1 0b07 	vfma.f64	d0, d1, d7
341a5970:	ee30 0b04 	vadd.f64	d0, d0, d4
341a5974:	e789      	b.n	341a588a <log+0xd2>
341a5976:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 341a5990 <log+0x1d8>
341a597a:	e786      	b.n	341a588a <log+0xd2>
341a597c:	f3af 8000 	nop.w
341a5980:	00000000 	.word	0x00000000
341a5984:	41a00000 	.word	0x41a00000
341a5988:	00000000 	.word	0x00000000
341a598c:	43300000 	.word	0x43300000
	...
341a5998:	000308ff 	.word	0x000308ff
341a599c:	3ff00000 	.word	0x3ff00000
341a59a0:	341b9648 	.word	0x341b9648
341a59a4:	7ff00000 	.word	0x7ff00000

341a59a8 <_init>:
341a59a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a59aa:	bf00      	nop
341a59ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
341a59ae:	bc08      	pop	{r3}
341a59b0:	469e      	mov	lr, r3
341a59b2:	4770      	bx	lr

341a59b4 <_fini>:
341a59b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a59b6:	bf00      	nop
341a59b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
341a59ba:	bc08      	pop	{r3}
341a59bc:	469e      	mov	lr, r3
341a59be:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

341ba300 <SECURE_SystemCoreClockUpdate>:
341ba300:	e97f e97f 	sg
341ba304:	f7c9 bb04 	b.w	34183910 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
