
STM32N6DK2_FSBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34180400  34180400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000269c0  34180750  34180750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000af10  341a7110  341a7110  00027110  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .version      0000000c  341b2020  341b2020  00032020  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  341b202c  341b202c  00033200  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  341b202c  341b202c  0003202c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  341b2034  341b2034  00033200  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  341b2034  341b2034  00032034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  341b2038  341b2038  00032038  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000194  341c0000  341b203c  00033000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000004  341c0194  341b21d0  00033194  2**0
                  ALLOC
 11 .gnu.sgstubs  00000020  341b21e0  341b21e0  000331e0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00001e84  341c0198  341c0198  00034198  2**3
                  ALLOC
 13 ._user_heap_stack 00000a04  341c201c  341c201c  00034198  2**0
                  ALLOC
 14 .psram_section 00232800  91000000  91000000  00034000  2**5
                  ALLOC
 15 .ARM.attributes 0000003a  00000000  00000000  00033200  2**0
                  CONTENTS, READONLY
 16 .debug_info   0005c058  00000000  00000000  0003323a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00007fac  00000000  00000000  0008f292  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00003c28  00000000  00000000  00097240  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00002e58  00000000  00000000  0009ae68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  000678a0  00000000  00000000  0009dcc0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0004394b  00000000  00000000  00105560  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    002d7b84  00000000  00000000  00148eab  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  00420a2f  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0001132c  00000000  00000000  00420ab8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 00000073  00000000  00000000  00431de4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34180750 <__do_global_dtors_aux>:
34180750:	b510      	push	{r4, lr}
34180752:	4c05      	ldr	r4, [pc, #20]	@ (34180768 <__do_global_dtors_aux+0x18>)
34180754:	7823      	ldrb	r3, [r4, #0]
34180756:	b933      	cbnz	r3, 34180766 <__do_global_dtors_aux+0x16>
34180758:	4b04      	ldr	r3, [pc, #16]	@ (3418076c <__do_global_dtors_aux+0x1c>)
3418075a:	b113      	cbz	r3, 34180762 <__do_global_dtors_aux+0x12>
3418075c:	4804      	ldr	r0, [pc, #16]	@ (34180770 <__do_global_dtors_aux+0x20>)
3418075e:	f3af 8000 	nop.w
34180762:	2301      	movs	r3, #1
34180764:	7023      	strb	r3, [r4, #0]
34180766:	bd10      	pop	{r4, pc}
34180768:	341c0198 	.word	0x341c0198
3418076c:	00000000 	.word	0x00000000
34180770:	341a70f8 	.word	0x341a70f8

34180774 <frame_dummy>:
34180774:	b508      	push	{r3, lr}
34180776:	4b03      	ldr	r3, [pc, #12]	@ (34180784 <frame_dummy+0x10>)
34180778:	b11b      	cbz	r3, 34180782 <frame_dummy+0xe>
3418077a:	4903      	ldr	r1, [pc, #12]	@ (34180788 <frame_dummy+0x14>)
3418077c:	4803      	ldr	r0, [pc, #12]	@ (3418078c <frame_dummy+0x18>)
3418077e:	f3af 8000 	nop.w
34180782:	bd08      	pop	{r3, pc}
34180784:	00000000 	.word	0x00000000
34180788:	341c019c 	.word	0x341c019c
3418078c:	341a70f8 	.word	0x341a70f8

34180790 <vVjsiRnEsi>:
34180790:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
34180794:	b530      	push	{r4, r5, lr}
34180796:	ed2d 8b10 	vpush	{d8-d15}
3418079a:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
3418079e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
341807a2:	b087      	sub	sp, #28
341807a4:	ed8d 7b00 	vstr	d7, [sp]
341807a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341807ac:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
341807b0:	4604      	mov	r4, r0
341807b2:	ed91 5a01 	vldr	s10, [r1, #4]
341807b6:	ed91 4a00 	vldr	s8, [r1]
341807ba:	ed91 fb02 	vldr	d15, [r1, #8]
341807be:	ed91 8b04 	vldr	d8, [r1, #16]
341807c2:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
341807c6:	ed90 dbaa 	vldr	d13, [r0, #680]	@ 0x2a8
341807ca:	ed90 bb16 	vldr	d11, [r0, #88]	@ 0x58
341807ce:	ed8d 7b04 	vstr	d7, [sp, #16]
341807d2:	ed90 eba6 	vldr	d14, [r0, #664]	@ 0x298
341807d6:	dc09      	bgt.n	341807ec <vVjsiRnEsi+0x5c>
341807d8:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
341807dc:	48d4      	ldr	r0, [pc, #848]	@ (34180b30 <vVjsiRnEsi+0x3a0>)
341807de:	4798      	blx	r3
341807e0:	f04f 30ff 	mov.w	r0, #4294967295
341807e4:	b007      	add	sp, #28
341807e6:	ecbd 8b10 	vpop	{d8-d15}
341807ea:	bd30      	pop	{r4, r5, pc}
341807ec:	eeb8 5b45 	vcvt.f64.u32	d5, s10
341807f0:	ed9f 7bc1 	vldr	d7, [pc, #772]	@ 34180af8 <vVjsiRnEsi+0x368>
341807f4:	eeb8 4b44 	vcvt.f64.u32	d4, s8
341807f8:	ee25 7b07 	vmul.f64	d7, d5, d7
341807fc:	eeb4 7bc4 	vcmpe.f64	d7, d4
34180800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180804:	dd0f      	ble.n	34180826 <vVjsiRnEsi+0x96>
34180806:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
3418080a:	ed9f 2bbd 	vldr	d2, [pc, #756]	@ 34180b00 <vVjsiRnEsi+0x370>
3418080e:	ee37 2b02 	vadd.f64	d2, d7, d2
34180812:	ed9f 7bbd 	vldr	d7, [pc, #756]	@ 34180b08 <vVjsiRnEsi+0x378>
34180816:	eeb4 2bc7 	vcmpe.f64	d2, d7
3418081a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418081e:	fe37 7b02 	vselgt.f64	d7, d7, d2
34180822:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
34180826:	ed9f 7bba 	vldr	d7, [pc, #744]	@ 34180b10 <vVjsiRnEsi+0x380>
3418082a:	ee25 5b07 	vmul.f64	d5, d5, d7
3418082e:	eeb4 5bc4 	vcmpe.f64	d5, d4
34180832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180836:	d510      	bpl.n	3418085a <vVjsiRnEsi+0xca>
34180838:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
3418083c:	ed9f 5bb0 	vldr	d5, [pc, #704]	@ 34180b00 <vVjsiRnEsi+0x370>
34180840:	ee37 7b45 	vsub.f64	d7, d7, d5
34180844:	ed9f 5bb4 	vldr	d5, [pc, #720]	@ 34180b18 <vVjsiRnEsi+0x388>
34180848:	eeb4 7bc5 	vcmpe.f64	d7, d5
3418084c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180850:	bf58      	it	pl
34180852:	eeb0 5b47 	vmovpl.f64	d5, d7
34180856:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
3418085a:	ee83 9b0d 	vdiv.f64	d9, d3, d13
3418085e:	eebc 9bc9 	vcvt.u32.f64	s18, d9
34180862:	eeb8 9b49 	vcvt.f64.u32	d9, s18
34180866:	ee29 9b0d 	vmul.f64	d9, d9, d13
3418086a:	eefc 7bc9 	vcvt.u32.f64	s15, d9
3418086e:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34180872:	edcd 7a03 	vstr	s15, [sp, #12]
34180876:	2d01      	cmp	r5, #1
34180878:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3418087c:	d152      	bne.n	34180924 <vVjsiRnEsi+0x194>
3418087e:	ed9f 7ba8 	vldr	d7, [pc, #672]	@ 34180b20 <vVjsiRnEsi+0x390>
34180882:	ee3f 5b48 	vsub.f64	d5, d15, d8
34180886:	ee85 cb07 	vdiv.f64	d12, d5, d7
3418088a:	ee3f 5b08 	vadd.f64	d5, d15, d8
3418088e:	ee85 ab07 	vdiv.f64	d10, d5, d7
34180892:	eeb0 7bcc 	vabs.f64	d7, d12
34180896:	eeb4 6bc7 	vcmpe.f64	d6, d7
3418089a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418089e:	eeb0 5bca 	vabs.f64	d5, d10
341808a2:	db0d      	blt.n	341808c0 <vVjsiRnEsi+0x130>
341808a4:	eeb4 6bc5 	vcmpe.f64	d6, d5
341808a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808ac:	db08      	blt.n	341808c0 <vVjsiRnEsi+0x130>
341808ae:	2300      	movs	r3, #0
341808b0:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
341808b4:	2300      	movs	r3, #0
341808b6:	eeb0 8b49 	vmov.f64	d8, d9
341808ba:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341808be:	e049      	b.n	34180954 <vVjsiRnEsi+0x1c4>
341808c0:	eeb4 6bc5 	vcmpe.f64	d6, d5
341808c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808c8:	d50c      	bpl.n	341808e4 <vVjsiRnEsi+0x154>
341808ca:	ee8a 5b0c 	vdiv.f64	d5, d10, d12
341808ce:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
341808d2:	eeb0 5bc5 	vabs.f64	d5, d5
341808d6:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
341808da:	eeb4 5bc6 	vcmpe.f64	d5, d6
341808de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341808e2:	dae7      	bge.n	341808b4 <vVjsiRnEsi+0x124>
341808e4:	2300      	movs	r3, #0
341808e6:	eef7 0bcb 	vcvt.f32.f64	s1, d11
341808ea:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
341808ee:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341808f2:	f026 f871 	bl	341a69d8 <powf>
341808f6:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
341808fa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341808fe:	eeb0 6bc8 	vabs.f64	d6, d8
34180902:	ee20 0b07 	vmul.f64	d0, d0, d7
34180906:	eeb0 7bcf 	vabs.f64	d7, d15
3418090a:	eeb4 7bc6 	vcmpe.f64	d7, d6
3418090e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180912:	dd6f      	ble.n	341809f4 <vVjsiRnEsi+0x264>
34180914:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34180918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418091c:	d56f      	bpl.n	341809fe <vVjsiRnEsi+0x26e>
3418091e:	ee39 0b40 	vsub.f64	d0, d9, d0
34180922:	e06e      	b.n	34180a02 <vVjsiRnEsi+0x272>
34180924:	eeb0 5bcf 	vabs.f64	d5, d15
34180928:	eeb0 7bc8 	vabs.f64	d7, d8
3418092c:	eeb4 7bc5 	vcmpe.f64	d7, d5
34180930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180934:	fe37 7b05 	vselgt.f64	d7, d7, d5
34180938:	eeb4 7bc6 	vcmpe.f64	d7, d6
3418093c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180940:	d853      	bhi.n	341809ea <vVjsiRnEsi+0x25a>
34180942:	ed9f ab79 	vldr	d10, [pc, #484]	@ 34180b28 <vVjsiRnEsi+0x398>
34180946:	2300      	movs	r3, #0
34180948:	eeb0 8b49 	vmov.f64	d8, d9
3418094c:	eeb0 cb4a 	vmov.f64	d12, d10
34180950:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34180954:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34180958:	bb2b      	cbnz	r3, 341809a6 <vVjsiRnEsi+0x216>
3418095a:	2210      	movs	r2, #16
3418095c:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34180960:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34180964:	f024 fdaa 	bl	341a54bc <memmove>
34180968:	2210      	movs	r2, #16
3418096a:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
3418096e:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34180972:	f024 fda3 	bl	341a54bc <memmove>
34180976:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
3418097a:	ed84 9b24 	vstr	d9, [r4, #144]	@ 0x90
3418097e:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34180982:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34180986:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
3418098a:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
3418098e:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34180992:	ed84 cb34 	vstr	d12, [r4, #208]	@ 0xd0
34180996:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
3418099a:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
3418099e:	ed84 ab36 	vstr	d10, [r4, #216]	@ 0xd8
341809a2:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
341809a6:	eefc 7bc8 	vcvt.u32.f64	s15, d8
341809aa:	ee17 3a90 	vmov	r3, s15
341809ae:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
341809b2:	9a03      	ldr	r2, [sp, #12]
341809b4:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
341809b8:	4293      	cmp	r3, r2
341809ba:	bf1c      	itt	ne
341809bc:	2301      	movne	r3, #1
341809be:	f884 3060 	strbne.w	r3, [r4, #96]	@ 0x60
341809c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809c6:	f340 80b5 	ble.w	34180b34 <vVjsiRnEsi+0x3a4>
341809ca:	2301      	movs	r3, #1
341809cc:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
341809d0:	ed9d 7b00 	vldr	d7, [sp]
341809d4:	eeb4 bbc7 	vcmpe.f64	d11, d7
341809d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809dc:	f140 80bd 	bpl.w	34180b5a <vVjsiRnEsi+0x3ca>
341809e0:	ed9d 7b04 	vldr	d7, [sp, #16]
341809e4:	ee3b eb07 	vadd.f64	d14, d11, d7
341809e8:	e0a9      	b.n	34180b3e <vVjsiRnEsi+0x3ae>
341809ea:	ed9f ab4f 	vldr	d10, [pc, #316]	@ 34180b28 <vVjsiRnEsi+0x398>
341809ee:	eeb0 cb4a 	vmov.f64	d12, d10
341809f2:	e777      	b.n	341808e4 <vVjsiRnEsi+0x154>
341809f4:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
341809f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341809fc:	d58f      	bpl.n	3418091e <vVjsiRnEsi+0x18e>
341809fe:	ee39 0b00 	vadd.f64	d0, d9, d0
34180a02:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
34180a06:	eeb4 7bc0 	vcmpe.f64	d7, d0
34180a0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a0e:	d42c      	bmi.n	34180a6a <vVjsiRnEsi+0x2da>
34180a10:	eeb0 7b40 	vmov.f64	d7, d0
34180a14:	ed94 6b3a 	vldr	d6, [r4, #232]	@ 0xe8
34180a18:	eeb4 6bc7 	vcmpe.f64	d6, d7
34180a1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a20:	dc26      	bgt.n	34180a70 <vVjsiRnEsi+0x2e0>
34180a22:	eeb0 6b47 	vmov.f64	d6, d7
34180a26:	ee86 8b0d 	vdiv.f64	d8, d6, d13
34180a2a:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34180a2e:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34180a32:	2d01      	cmp	r5, #1
34180a34:	ee2d 8b08 	vmul.f64	d8, d13, d8
34180a38:	d18c      	bne.n	34180954 <vVjsiRnEsi+0x1c4>
34180a3a:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
34180a3e:	2b02      	cmp	r3, #2
34180a40:	d819      	bhi.n	34180a76 <vVjsiRnEsi+0x2e6>
34180a42:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34180a46:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34180a4a:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
34180a4e:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
34180a52:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
34180a56:	eb04 1203 	add.w	r2, r4, r3, lsl #4
34180a5a:	3301      	adds	r3, #1
34180a5c:	ed82 cb2c 	vstr	d12, [r2, #176]	@ 0xb0
34180a60:	ed82 ab2e 	vstr	d10, [r2, #184]	@ 0xb8
34180a64:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34180a68:	e774      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180a6a:	eeb0 bb4e 	vmov.f64	d11, d14
34180a6e:	e7d1      	b.n	34180a14 <vVjsiRnEsi+0x284>
34180a70:	eeb0 bb4e 	vmov.f64	d11, d14
34180a74:	e7d7      	b.n	34180a26 <vVjsiRnEsi+0x296>
34180a76:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34180a7a:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34180a7e:	ee38 7b47 	vsub.f64	d7, d8, d7
34180a82:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34180a86:	eeb0 7bc7 	vabs.f64	d7, d7
34180a8a:	eeb4 7bc6 	vcmpe.f64	d7, d6
34180a8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180a92:	db28      	blt.n	34180ae6 <vVjsiRnEsi+0x356>
34180a94:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34180a98:	ee38 7b47 	vsub.f64	d7, d8, d7
34180a9c:	eeb0 7bc7 	vabs.f64	d7, d7
34180aa0:	eeb4 6bc7 	vcmpe.f64	d6, d7
34180aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180aa8:	dd1d      	ble.n	34180ae6 <vVjsiRnEsi+0x356>
34180aaa:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34180aae:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34180ab2:	ee3a 0b40 	vsub.f64	d0, d10, d0
34180ab6:	ee3c 7b47 	vsub.f64	d7, d12, d7
34180aba:	ee20 0b00 	vmul.f64	d0, d0, d0
34180abe:	eea7 0b07 	vfma.f64	d0, d7, d7
34180ac2:	f025 fcc5 	bl	341a6450 <sqrt>
34180ac6:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34180aca:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180ace:	eeb4 0bc7 	vcmpe.f64	d0, d7
34180ad2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180ad6:	d506      	bpl.n	34180ae6 <vVjsiRnEsi+0x356>
34180ad8:	eefc 7bc9 	vcvt.u32.f64	s15, d9
34180adc:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34180ae0:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34180ae4:	e736      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180ae6:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34180aea:	2b01      	cmp	r3, #1
34180aec:	f47f af32 	bne.w	34180954 <vVjsiRnEsi+0x1c4>
34180af0:	2300      	movs	r3, #0
34180af2:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34180af6:	e72d      	b.n	34180954 <vVjsiRnEsi+0x1c4>
34180af8:	9999999a 	.word	0x9999999a
34180afc:	3fa99999 	.word	0x3fa99999
34180b00:	47ae147b 	.word	0x47ae147b
34180b04:	3f847ae1 	.word	0x3f847ae1
34180b08:	33333334 	.word	0x33333334
34180b0c:	3fc33333 	.word	0x3fc33333
34180b10:	33333333 	.word	0x33333333
34180b14:	3fc33333 	.word	0x3fc33333
34180b18:	11111111 	.word	0x11111111
34180b1c:	3fb11111 	.word	0x3fb11111
34180b20:	667f3bcd 	.word	0x667f3bcd
34180b24:	3ff6a09e 	.word	0x3ff6a09e
	...
34180b30:	341af550 	.word	0x341af550
34180b34:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34180b38:	2b00      	cmp	r3, #0
34180b3a:	f47f af49 	bne.w	341809d0 <vVjsiRnEsi+0x240>
34180b3e:	ee88 7b0d 	vdiv.f64	d7, d8, d13
34180b42:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34180b46:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34180b4a:	ee27 7b0d 	vmul.f64	d7, d7, d13
34180b4e:	ed84 eb16 	vstr	d14, [r4, #88]	@ 0x58
34180b52:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34180b56:	2001      	movs	r0, #1
34180b58:	e644      	b.n	341807e4 <vVjsiRnEsi+0x54>
34180b5a:	ed9d eb00 	vldr	d14, [sp]
34180b5e:	e7ee      	b.n	34180b3e <vVjsiRnEsi+0x3ae>

34180b60 <RGqhTVOsSg>:
34180b60:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34180b64:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34180b68:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34180b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180b70:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34180b74:	eeb0 7b46 	vmov.f64	d7, d6
34180b78:	bfdf      	itttt	le
34180b7a:	ee84 7b05 	vdivle.f64	d7, d4, d5
34180b7e:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34180b82:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34180b86:	ee27 7b05 	vmulle.f64	d7, d7, d5
34180b8a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34180b8e:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34180b92:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34180b96:	eeb4 4bc5 	vcmpe.f64	d4, d5
34180b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180b9e:	bfc8      	it	gt
34180ba0:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34180ba4:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34180ba8:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34180bac:	eeb4 4bc5 	vcmpe.f64	d4, d5
34180bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180bb4:	bf48      	it	mi
34180bb6:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34180bba:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34180bbe:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34180bc2:	b530      	push	{r4, r5, lr}
34180bc4:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34180bc8:	ed93 5a00 	vldr	s10, [r3]
34180bcc:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34180bd0:	eeb4 5ac7 	vcmpe.f32	s10, s14
34180bd4:	eef1 5a67 	vneg.f32	s11, s15
34180bd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180bdc:	f04f 0100 	mov.w	r1, #0
34180be0:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34180be4:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34180be8:	3b01      	subs	r3, #1
34180bea:	b28a      	uxth	r2, r1
34180bec:	4293      	cmp	r3, r2
34180bee:	d805      	bhi.n	34180bfc <RGqhTVOsSg+0x9c>
34180bf0:	2244      	movs	r2, #68	@ 0x44
34180bf2:	fb02 0303 	mla	r3, r2, r3, r0
34180bf6:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34180bfa:	e011      	b.n	34180c20 <RGqhTVOsSg+0xc0>
34180bfc:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34180c00:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34180c04:	ee77 5aa5 	vadd.f32	s11, s15, s11
34180c08:	eef4 5ac7 	vcmpe.f32	s11, s14
34180c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180c10:	f101 0101 	add.w	r1, r1, #1
34180c14:	dbe9      	blt.n	34180bea <RGqhTVOsSg+0x8a>
34180c16:	2344      	movs	r3, #68	@ 0x44
34180c18:	fb03 0202 	mla	r2, r3, r2, r0
34180c1c:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34180c20:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34180c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180c28:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34180c2c:	dc05      	bgt.n	34180c3a <RGqhTVOsSg+0xda>
34180c2e:	ed93 7a00 	vldr	s14, [r3]
34180c32:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180c36:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34180c3a:	685a      	ldr	r2, [r3, #4]
34180c3c:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34180c40:	6042      	str	r2, [r0, #4]
34180c42:	689a      	ldr	r2, [r3, #8]
34180c44:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34180c48:	6082      	str	r2, [r0, #8]
34180c4a:	68da      	ldr	r2, [r3, #12]
34180c4c:	60c2      	str	r2, [r0, #12]
34180c4e:	691a      	ldr	r2, [r3, #16]
34180c50:	6102      	str	r2, [r0, #16]
34180c52:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34180c56:	695d      	ldr	r5, [r3, #20]
34180c58:	330c      	adds	r3, #12
34180c5a:	6145      	str	r5, [r0, #20]
34180c5c:	68dd      	ldr	r5, [r3, #12]
34180c5e:	300c      	adds	r0, #12
34180c60:	60c5      	str	r5, [r0, #12]
34180c62:	691d      	ldr	r5, [r3, #16]
34180c64:	42a3      	cmp	r3, r4
34180c66:	6105      	str	r5, [r0, #16]
34180c68:	f851 5b04 	ldr.w	r5, [r1], #4
34180c6c:	f842 5b04 	str.w	r5, [r2], #4
34180c70:	d1f1      	bne.n	34180c56 <RGqhTVOsSg+0xf6>
34180c72:	2001      	movs	r0, #1
34180c74:	bd30      	pop	{r4, r5, pc}

34180c76 <evision_api_awb_new>:
34180c76:	b510      	push	{r4, lr}
34180c78:	b090      	sub	sp, #64	@ 0x40
34180c7a:	b178      	cbz	r0, 34180c9c <evision_api_awb_new+0x26>
34180c7c:	2200      	movs	r2, #0
34180c7e:	4c08      	ldr	r4, [pc, #32]	@ (34180ca0 <evision_api_awb_new+0x2a>)
34180c80:	2140      	movs	r1, #64	@ 0x40
34180c82:	4b08      	ldr	r3, [pc, #32]	@ (34180ca4 <evision_api_awb_new+0x2e>)
34180c84:	7022      	strb	r2, [r4, #0]
34180c86:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34180c8a:	4a07      	ldr	r2, [pc, #28]	@ (34180ca8 <evision_api_awb_new+0x32>)
34180c8c:	4668      	mov	r0, sp
34180c8e:	f024 fb07 	bl	341a52a0 <sniprintf>
34180c92:	4668      	mov	r0, sp
34180c94:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180c98:	4798      	blx	r3
34180c9a:	4620      	mov	r0, r4
34180c9c:	b010      	add	sp, #64	@ 0x40
34180c9e:	bd10      	pop	{r4, pc}
34180ca0:	341c01b8 	.word	0x341c01b8
34180ca4:	341b2020 	.word	0x341b2020
34180ca8:	341af590 	.word	0x341af590

34180cac <evision_api_awb_delete>:
34180cac:	2800      	cmp	r0, #0
34180cae:	bf0c      	ite	eq
34180cb0:	f04f 30ff 	moveq.w	r0, #4294967295
34180cb4:	2001      	movne	r0, #1
34180cb6:	4770      	bx	lr

34180cb8 <evision_api_awb_set_profile>:
34180cb8:	b530      	push	{r4, r5, lr}
34180cba:	ed80 0a00 	vstr	s0, [r0]
34180cbe:	680c      	ldr	r4, [r1, #0]
34180cc0:	6044      	str	r4, [r0, #4]
34180cc2:	684c      	ldr	r4, [r1, #4]
34180cc4:	6084      	str	r4, [r0, #8]
34180cc6:	688c      	ldr	r4, [r1, #8]
34180cc8:	60c4      	str	r4, [r0, #12]
34180cca:	68c9      	ldr	r1, [r1, #12]
34180ccc:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34180cd0:	6101      	str	r1, [r0, #16]
34180cd2:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34180cd6:	6815      	ldr	r5, [r2, #0]
34180cd8:	320c      	adds	r2, #12
34180cda:	6145      	str	r5, [r0, #20]
34180cdc:	f852 5c08 	ldr.w	r5, [r2, #-8]
34180ce0:	300c      	adds	r0, #12
34180ce2:	60c5      	str	r5, [r0, #12]
34180ce4:	f852 5c04 	ldr.w	r5, [r2, #-4]
34180ce8:	42a2      	cmp	r2, r4
34180cea:	6105      	str	r5, [r0, #16]
34180cec:	f853 5b04 	ldr.w	r5, [r3], #4
34180cf0:	f841 5b04 	str.w	r5, [r1], #4
34180cf4:	d1ef      	bne.n	34180cd6 <evision_api_awb_set_profile+0x1e>
34180cf6:	bd30      	pop	{r4, r5, pc}

34180cf8 <evision_api_awb_init_profiles>:
34180cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34180cfc:	ed2d 8b06 	vpush	{d8-d10}
34180d00:	460d      	mov	r5, r1
34180d02:	eeb0 9b40 	vmov.f64	d9, d0
34180d06:	eeb0 8b41 	vmov.f64	d8, d1
34180d0a:	461e      	mov	r6, r3
34180d0c:	4604      	mov	r4, r0
34180d0e:	b0c9      	sub	sp, #292	@ 0x124
34180d10:	2800      	cmp	r0, #0
34180d12:	f000 8185 	beq.w	34181020 <evision_api_awb_init_profiles+0x328>
34180d16:	ed9f abc6 	vldr	d10, [pc, #792]	@ 34181030 <evision_api_awb_init_profiles+0x338>
34180d1a:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34180d1e:	2000      	movs	r0, #0
34180d20:	49c9      	ldr	r1, [pc, #804]	@ (34181048 <evision_api_awb_init_profiles+0x350>)
34180d22:	f04f 0800 	mov.w	r8, #0
34180d26:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34180d2a:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34180d2e:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34180d32:	49c6      	ldr	r1, [pc, #792]	@ (3418104c <evision_api_awb_init_profiles+0x354>)
34180d34:	f8df 9348 	ldr.w	r9, [pc, #840]	@ 34181080 <evision_api_awb_init_profiles+0x388>
34180d38:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34180d3c:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34180d40:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34180d44:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34180d48:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34180d4c:	f20f 29e8 	addw	r9, pc, #744	@ 0x2e8
34180d50:	e9d9 8900 	ldrd	r8, r9, [r9]
34180d54:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34180d58:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34180d5c:	f04f 0800 	mov.w	r8, #0
34180d60:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34180d64:	49ba      	ldr	r1, [pc, #744]	@ (34181050 <evision_api_awb_init_profiles+0x358>)
34180d66:	f8df 931c 	ldr.w	r9, [pc, #796]	@ 34181084 <evision_api_awb_init_profiles+0x38c>
34180d6a:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34180d6e:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34180d72:	2300      	movs	r3, #0
34180d74:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34180d78:	2701      	movs	r7, #1
34180d7a:	f04f 0800 	mov.w	r8, #0
34180d7e:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34180d82:	1e69      	subs	r1, r5, #1
34180d84:	f8df 9300 	ldr.w	r9, [pc, #768]	@ 34181088 <evision_api_awb_init_profiles+0x390>
34180d88:	b288      	uxth	r0, r1
34180d8a:	2804      	cmp	r0, #4
34180d8c:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34180d90:	f20f 29ac 	addw	r9, pc, #684	@ 0x2ac
34180d94:	e9d9 8900 	ldrd	r8, r9, [r9]
34180d98:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34180d9c:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34180da0:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34180da4:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34180da8:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34180dac:	d914      	bls.n	34180dd8 <evision_api_awb_init_profiles+0xe0>
34180dae:	2305      	movs	r3, #5
34180db0:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180db4:	4aa7      	ldr	r2, [pc, #668]	@ (34181054 <evision_api_awb_init_profiles+0x35c>)
34180db6:	a808      	add	r0, sp, #32
34180db8:	f024 fa72 	bl	341a52a0 <sniprintf>
34180dbc:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180dc0:	a808      	add	r0, sp, #32
34180dc2:	4798      	blx	r3
34180dc4:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34180dc8:	4620      	mov	r0, r4
34180dca:	b049      	add	sp, #292	@ 0x124
34180dcc:	ecbd 8b06 	vpop	{d8-d10}
34180dd0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34180dd4:	f7ff bec4 	b.w	34180b60 <RGqhTVOsSg>
34180dd8:	ed96 7a00 	vldr	s14, [r6]
34180ddc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180de0:	eeb4 0bc7 	vcmpe.f64	d0, d7
34180de4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180de8:	dd12      	ble.n	34180e10 <evision_api_awb_init_profiles+0x118>
34180dea:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180dee:	489a      	ldr	r0, [pc, #616]	@ (34181058 <evision_api_awb_init_profiles+0x360>)
34180df0:	4798      	blx	r3
34180df2:	ed96 7a00 	vldr	s14, [r6]
34180df6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180dfa:	ed8d 9b00 	vstr	d9, [sp]
34180dfe:	ed8d 7b02 	vstr	d7, [sp, #8]
34180e02:	4a96      	ldr	r2, [pc, #600]	@ (3418105c <evision_api_awb_init_profiles+0x364>)
34180e04:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180e08:	a808      	add	r0, sp, #32
34180e0a:	f024 fa49 	bl	341a52a0 <sniprintf>
34180e0e:	e7d5      	b.n	34180dbc <evision_api_awb_init_profiles+0xc4>
34180e10:	f04f 0844 	mov.w	r8, #68	@ 0x44
34180e14:	fb08 f805 	mul.w	r8, r8, r5
34180e18:	eb06 0908 	add.w	r9, r6, r8
34180e1c:	ed19 7a11 	vldr	s14, [r9, #-68]	@ 0xffffffbc
34180e20:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180e24:	eeb4 1bc7 	vcmpe.f64	d1, d7
34180e28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180e2c:	d445      	bmi.n	34180eba <evision_api_awb_init_profiles+0x1c2>
34180e2e:	46b3      	mov	fp, r6
34180e30:	4637      	mov	r7, r6
34180e32:	4699      	mov	r9, r3
34180e34:	4628      	mov	r0, r5
34180e36:	3801      	subs	r0, #1
34180e38:	d14d      	bne.n	34180ed6 <evision_api_awb_init_profiles+0x1de>
34180e3a:	4610      	mov	r0, r2
34180e3c:	4691      	mov	r9, r2
34180e3e:	2700      	movs	r7, #0
34180e40:	f1a5 0e02 	sub.w	lr, r5, #2
34180e44:	f101 0c01 	add.w	ip, r1, #1
34180e48:	f1bc 0c01 	subs.w	ip, ip, #1
34180e4c:	d175      	bne.n	34180f3a <evision_api_awb_init_profiles+0x242>
34180e4e:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34180e52:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
34180e56:	f021 4140 	bic.w	r1, r1, #3221225472	@ 0xc0000000
34180e5a:	f8a4 50f8 	strh.w	r5, [r4, #248]	@ 0xf8
34180e5e:	f504 7388 	add.w	r3, r4, #272	@ 0x110
34180e62:	3101      	adds	r1, #1
34180e64:	3901      	subs	r1, #1
34180e66:	f040 80bf 	bne.w	34180fe8 <evision_api_awb_init_profiles+0x2f0>
34180e6a:	2700      	movs	r7, #0
34180e6c:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34180e70:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34180e74:	eb06 0b07 	add.w	fp, r6, r7
34180e78:	eb09 0007 	add.w	r0, r9, r7
34180e7c:	2244      	movs	r2, #68	@ 0x44
34180e7e:	4659      	mov	r1, fp
34180e80:	f024 fbb1 	bl	341a55e6 <memcpy>
34180e84:	3744      	adds	r7, #68	@ 0x44
34180e86:	f8db 3000 	ldr.w	r3, [fp]
34180e8a:	45b8      	cmp	r8, r7
34180e8c:	f84a 3b04 	str.w	r3, [sl], #4
34180e90:	d1f0      	bne.n	34180e74 <evision_api_awb_init_profiles+0x17c>
34180e92:	1e6b      	subs	r3, r5, #1
34180e94:	b29b      	uxth	r3, r3
34180e96:	2d00      	cmp	r5, #0
34180e98:	f103 0301 	add.w	r3, r3, #1
34180e9c:	bf14      	ite	ne
34180e9e:	461a      	movne	r2, r3
34180ea0:	2201      	moveq	r2, #1
34180ea2:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34180ea6:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34180eaa:	3a01      	subs	r2, #1
34180eac:	f040 80a1 	bne.w	34180ff2 <evision_api_awb_init_profiles+0x2fa>
34180eb0:	2301      	movs	r3, #1
34180eb2:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34180eb6:	7023      	strb	r3, [r4, #0]
34180eb8:	e786      	b.n	34180dc8 <evision_api_awb_init_profiles+0xd0>
34180eba:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180ebe:	4868      	ldr	r0, [pc, #416]	@ (34181060 <evision_api_awb_init_profiles+0x368>)
34180ec0:	4798      	blx	r3
34180ec2:	ed99 7a00 	vldr	s14, [r9]
34180ec6:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180eca:	ed8d 8b00 	vstr	d8, [sp]
34180ece:	ed8d 7b02 	vstr	d7, [sp, #8]
34180ed2:	4a64      	ldr	r2, [pc, #400]	@ (34181064 <evision_api_awb_init_profiles+0x36c>)
34180ed4:	e796      	b.n	34180e04 <evision_api_awb_init_profiles+0x10c>
34180ed6:	46ba      	mov	sl, r7
34180ed8:	ed9a 7a00 	vldr	s14, [sl]
34180edc:	edda 7a11 	vldr	s15, [sl, #68]	@ 0x44
34180ee0:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180ee8:	f109 0301 	add.w	r3, r9, #1
34180eec:	f107 0744 	add.w	r7, r7, #68	@ 0x44
34180ef0:	db21      	blt.n	34180f36 <evision_api_awb_init_profiles+0x23e>
34180ef2:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34180ef6:	485c      	ldr	r0, [pc, #368]	@ (34181068 <evision_api_awb_init_profiles+0x370>)
34180ef8:	9307      	str	r3, [sp, #28]
34180efa:	4790      	blx	r2
34180efc:	ed97 7a00 	vldr	s14, [r7]
34180f00:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f04:	ed8d 7b04 	vstr	d7, [sp, #16]
34180f08:	9b07      	ldr	r3, [sp, #28]
34180f0a:	4a58      	ldr	r2, [pc, #352]	@ (3418106c <evision_api_awb_init_profiles+0x374>)
34180f0c:	9302      	str	r3, [sp, #8]
34180f0e:	ed9a 7a00 	vldr	s14, [sl]
34180f12:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f16:	464b      	mov	r3, r9
34180f18:	ed8d 7b00 	vstr	d7, [sp]
34180f1c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180f20:	a808      	add	r0, sp, #32
34180f22:	f024 f9bd 	bl	341a52a0 <sniprintf>
34180f26:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180f2a:	a808      	add	r0, sp, #32
34180f2c:	4798      	blx	r3
34180f2e:	2301      	movs	r3, #1
34180f30:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34180f34:	e748      	b.n	34180dc8 <evision_api_awb_init_profiles+0xd0>
34180f36:	4699      	mov	r9, r3
34180f38:	e77d      	b.n	34180e36 <evision_api_awb_init_profiles+0x13e>
34180f3a:	45be      	cmp	lr, r7
34180f3c:	46ca      	mov	sl, r9
34180f3e:	f107 0201 	add.w	r2, r7, #1
34180f42:	ecf9 7a01 	vldmia	r9!, {s15}
34180f46:	d91c      	bls.n	34180f82 <evision_api_awb_init_profiles+0x28a>
34180f48:	ed99 7a00 	vldr	s14, [r9]
34180f4c:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180f54:	d815      	bhi.n	34180f82 <evision_api_awb_init_profiles+0x28a>
34180f56:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34180f5a:	4845      	ldr	r0, [pc, #276]	@ (34181070 <evision_api_awb_init_profiles+0x378>)
34180f5c:	9207      	str	r2, [sp, #28]
34180f5e:	4798      	blx	r3
34180f60:	ed99 7a00 	vldr	s14, [r9]
34180f64:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f68:	ed8d 7b04 	vstr	d7, [sp, #16]
34180f6c:	9a07      	ldr	r2, [sp, #28]
34180f6e:	463b      	mov	r3, r7
34180f70:	9202      	str	r2, [sp, #8]
34180f72:	ed9a 7a00 	vldr	s14, [sl]
34180f76:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180f7a:	4a3e      	ldr	r2, [pc, #248]	@ (34181074 <evision_api_awb_init_profiles+0x37c>)
34180f7c:	ed8d 7b00 	vstr	d7, [sp]
34180f80:	e7cc      	b.n	34180f1c <evision_api_awb_init_profiles+0x224>
34180f82:	465b      	mov	r3, fp
34180f84:	ed93 7a00 	vldr	s14, [r3]
34180f88:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180f90:	f10b 0b44 	add.w	fp, fp, #68	@ 0x44
34180f94:	da06      	bge.n	34180fa4 <evision_api_awb_init_profiles+0x2ac>
34180f96:	ed93 7a11 	vldr	s14, [r3, #68]	@ 0x44
34180f9a:	eeb4 7ae7 	vcmpe.f32	s14, s15
34180f9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34180fa2:	d81f      	bhi.n	34180fe4 <evision_api_awb_init_profiles+0x2ec>
34180fa4:	f8d4 22c8 	ldr.w	r2, [r4, #712]	@ 0x2c8
34180fa8:	4833      	ldr	r0, [pc, #204]	@ (34181078 <evision_api_awb_init_profiles+0x380>)
34180faa:	9307      	str	r3, [sp, #28]
34180fac:	4790      	blx	r2
34180fae:	ed9b 7a00 	vldr	s14, [fp]
34180fb2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fb6:	ed8d 7b04 	vstr	d7, [sp, #16]
34180fba:	9b07      	ldr	r3, [sp, #28]
34180fbc:	f44f 7180 	mov.w	r1, #256	@ 0x100
34180fc0:	ed93 7a00 	vldr	s14, [r3]
34180fc4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fc8:	ed8d 7b02 	vstr	d7, [sp, #8]
34180fcc:	ed9a 7a00 	vldr	s14, [sl]
34180fd0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34180fd4:	463b      	mov	r3, r7
34180fd6:	ed8d 7b00 	vstr	d7, [sp]
34180fda:	4a28      	ldr	r2, [pc, #160]	@ (3418107c <evision_api_awb_init_profiles+0x384>)
34180fdc:	a808      	add	r0, sp, #32
34180fde:	f024 f95f 	bl	341a52a0 <sniprintf>
34180fe2:	e7a0      	b.n	34180f26 <evision_api_awb_init_profiles+0x22e>
34180fe4:	4617      	mov	r7, r2
34180fe6:	e72f      	b.n	34180e48 <evision_api_awb_init_profiles+0x150>
34180fe8:	f850 2b04 	ldr.w	r2, [r0], #4
34180fec:	f843 2b04 	str.w	r2, [r3], #4
34180ff0:	e738      	b.n	34180e64 <evision_api_awb_init_profiles+0x16c>
34180ff2:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34180ff6:	ed91 6a00 	vldr	s12, [r1]
34180ffa:	ed93 7a00 	vldr	s14, [r3]
34180ffe:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34181002:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34181006:	ee36 6b4a 	vsub.f64	d6, d6, d10
3418100a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3418100e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34181012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181016:	bf48      	it	mi
34181018:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3418101c:	3144      	adds	r1, #68	@ 0x44
3418101e:	e744      	b.n	34180eaa <evision_api_awb_init_profiles+0x1b2>
34181020:	f04f 30ff 	mov.w	r0, #4294967295
34181024:	b049      	add	sp, #292	@ 0x124
34181026:	ecbd 8b06 	vpop	{d8-d10}
3418102a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3418102e:	bf00      	nop
34181030:	00000000 	.word	0x00000000
34181034:	40b38800 	.word	0x40b38800
34181038:	9999999a 	.word	0x9999999a
3418103c:	3fb99999 	.word	0x3fb99999
34181040:	00000000 	.word	0x00000000
34181044:	406ea000 	.word	0x406ea000
34181048:	3ff00000 	.word	0x3ff00000
3418104c:	42480000 	.word	0x42480000
34181050:	432f0000 	.word	0x432f0000
34181054:	341af5a0 	.word	0x341af5a0
34181058:	341af5e4 	.word	0x341af5e4
3418105c:	341af66b 	.word	0x341af66b
34181060:	341af6c9 	.word	0x341af6c9
34181064:	341af751 	.word	0x341af751
34181068:	341af7ae 	.word	0x341af7ae
3418106c:	341af812 	.word	0x341af812
34181070:	341af86a 	.word	0x341af86a
34181074:	341af8d9 	.word	0x341af8d9
34181078:	341af943 	.word	0x341af943
3418107c:	341af99a 	.word	0x341af99a
34181080:	bff00000 	.word	0xbff00000
34181084:	40080000 	.word	0x40080000
34181088:	40240000 	.word	0x40240000

3418108c <evision_api_awb_run_average>:
3418108c:	b530      	push	{r4, r5, lr}
3418108e:	4605      	mov	r5, r0
34181090:	4614      	mov	r4, r2
34181092:	b08d      	sub	sp, #52	@ 0x34
34181094:	b952      	cbnz	r2, 341810ac <evision_api_awb_run_average+0x20>
34181096:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
3418109a:	481d      	ldr	r0, [pc, #116]	@ (34181110 <evision_api_awb_run_average+0x84>)
3418109c:	4798      	blx	r3
3418109e:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
341810a2:	481c      	ldr	r0, [pc, #112]	@ (34181114 <evision_api_awb_run_average+0x88>)
341810a4:	4798      	blx	r3
341810a6:	4620      	mov	r0, r4
341810a8:	b00d      	add	sp, #52	@ 0x34
341810aa:	bd30      	pop	{r4, r5, pc}
341810ac:	ed93 2b04 	vldr	d2, [r3, #16]
341810b0:	ed93 1b02 	vldr	d1, [r3, #8]
341810b4:	ed93 0b00 	vldr	d0, [r3]
341810b8:	aa0a      	add	r2, sp, #40	@ 0x28
341810ba:	a908      	add	r1, sp, #32
341810bc:	a806      	add	r0, sp, #24
341810be:	f000 f82f 	bl	34181120 <VGuzhuiVXN>
341810c2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
341810c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
341810ca:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
341810ce:	e9cd 2304 	strd	r2, r3, [sp, #16]
341810d2:	2301      	movs	r3, #1
341810d4:	4298      	cmp	r0, r3
341810d6:	4604      	mov	r4, r0
341810d8:	e9cd 3300 	strd	r3, r3, [sp]
341810dc:	d1df      	bne.n	3418109e <evision_api_awb_run_average+0x12>
341810de:	4669      	mov	r1, sp
341810e0:	4628      	mov	r0, r5
341810e2:	f7ff fb55 	bl	34180790 <vVjsiRnEsi>
341810e6:	2801      	cmp	r0, #1
341810e8:	4604      	mov	r4, r0
341810ea:	d003      	beq.n	341810f4 <evision_api_awb_run_average+0x68>
341810ec:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
341810f0:	4809      	ldr	r0, [pc, #36]	@ (34181118 <evision_api_awb_run_average+0x8c>)
341810f2:	e7d7      	b.n	341810a4 <evision_api_awb_run_average+0x18>
341810f4:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
341810f8:	2b01      	cmp	r3, #1
341810fa:	d1d4      	bne.n	341810a6 <evision_api_awb_run_average+0x1a>
341810fc:	4628      	mov	r0, r5
341810fe:	f7ff fd2f 	bl	34180b60 <RGqhTVOsSg>
34181102:	2801      	cmp	r0, #1
34181104:	4604      	mov	r4, r0
34181106:	d0ce      	beq.n	341810a6 <evision_api_awb_run_average+0x1a>
34181108:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3418110c:	4803      	ldr	r0, [pc, #12]	@ (3418111c <evision_api_awb_run_average+0x90>)
3418110e:	e7c9      	b.n	341810a4 <evision_api_awb_run_average+0x18>
34181110:	341afa20 	.word	0x341afa20
34181114:	341afa81 	.word	0x341afa81
34181118:	341afaaa 	.word	0x341afaaa
3418111c:	341afade 	.word	0x341afade

34181120 <VGuzhuiVXN>:
34181120:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34181124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3418112a:	eeb0 7b41 	vmov.f64	d7, d1
3418112e:	4613      	mov	r3, r2
34181130:	d409      	bmi.n	34181146 <VGuzhuiVXN+0x26>
34181132:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
34181136:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418113a:	d404      	bmi.n	34181146 <VGuzhuiVXN+0x26>
3418113c:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
34181140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181144:	d50d      	bpl.n	34181162 <VGuzhuiVXN+0x42>
34181146:	ed8d 2b02 	vstr	d2, [sp, #8]
3418114a:	ed8d 7b00 	vstr	d7, [sp]
3418114e:	ec53 2b10 	vmov	r2, r3, d0
34181152:	4845      	ldr	r0, [pc, #276]	@ (34181268 <VGuzhuiVXN+0x148>)
34181154:	f024 f834 	bl	341a51c0 <iprintf>
34181158:	f04f 30ff 	mov.w	r0, #4294967295
3418115c:	b005      	add	sp, #20
3418115e:	f85d fb04 	ldr.w	pc, [sp], #4
34181162:	ed9f 6b33 	vldr	d6, [pc, #204]	@ 34181230 <VGuzhuiVXN+0x110>
34181166:	eeb4 0bc6 	vcmpe.f64	d0, d6
3418116a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418116e:	dc09      	bgt.n	34181184 <VGuzhuiVXN+0x64>
34181170:	eeb4 1bc6 	vcmpe.f64	d1, d6
34181174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181178:	dc04      	bgt.n	34181184 <VGuzhuiVXN+0x64>
3418117a:	eeb4 2bc6 	vcmpe.f64	d2, d6
3418117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181182:	dd07      	ble.n	34181194 <VGuzhuiVXN+0x74>
34181184:	ed8d 2b02 	vstr	d2, [sp, #8]
34181188:	ed8d 7b00 	vstr	d7, [sp]
3418118c:	ec53 2b10 	vmov	r2, r3, d0
34181190:	4836      	ldr	r0, [pc, #216]	@ (3418126c <VGuzhuiVXN+0x14c>)
34181192:	e7df      	b.n	34181154 <VGuzhuiVXN+0x34>
34181194:	b128      	cbz	r0, 341811a2 <VGuzhuiVXN+0x82>
34181196:	b181      	cbz	r1, 341811ba <VGuzhuiVXN+0x9a>
34181198:	b9aa      	cbnz	r2, 341811c6 <VGuzhuiVXN+0xa6>
3418119a:	4935      	ldr	r1, [pc, #212]	@ (34181270 <VGuzhuiVXN+0x150>)
3418119c:	4b35      	ldr	r3, [pc, #212]	@ (34181274 <VGuzhuiVXN+0x154>)
3418119e:	460a      	mov	r2, r1
341811a0:	e007      	b.n	341811b2 <VGuzhuiVXN+0x92>
341811a2:	b969      	cbnz	r1, 341811c0 <VGuzhuiVXN+0xa0>
341811a4:	4933      	ldr	r1, [pc, #204]	@ (34181274 <VGuzhuiVXN+0x154>)
341811a6:	460a      	mov	r2, r1
341811a8:	4832      	ldr	r0, [pc, #200]	@ (34181274 <VGuzhuiVXN+0x154>)
341811aa:	2b00      	cmp	r3, #0
341811ac:	4b30      	ldr	r3, [pc, #192]	@ (34181270 <VGuzhuiVXN+0x150>)
341811ae:	bf08      	it	eq
341811b0:	4603      	moveq	r3, r0
341811b2:	4831      	ldr	r0, [pc, #196]	@ (34181278 <VGuzhuiVXN+0x158>)
341811b4:	f024 f804 	bl	341a51c0 <iprintf>
341811b8:	e7ce      	b.n	34181158 <VGuzhuiVXN+0x38>
341811ba:	492d      	ldr	r1, [pc, #180]	@ (34181270 <VGuzhuiVXN+0x150>)
341811bc:	4a2d      	ldr	r2, [pc, #180]	@ (34181274 <VGuzhuiVXN+0x154>)
341811be:	e7f3      	b.n	341811a8 <VGuzhuiVXN+0x88>
341811c0:	492c      	ldr	r1, [pc, #176]	@ (34181274 <VGuzhuiVXN+0x154>)
341811c2:	4a2b      	ldr	r2, [pc, #172]	@ (34181270 <VGuzhuiVXN+0x150>)
341811c4:	e7f0      	b.n	341811a8 <VGuzhuiVXN+0x88>
341811c6:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 34181238 <VGuzhuiVXN+0x118>
341811ca:	ed9f 5b1d 	vldr	d5, [pc, #116]	@ 34181240 <VGuzhuiVXN+0x120>
341811ce:	ee21 6b06 	vmul.f64	d6, d1, d6
341811d2:	eeb3 4b00 	vmov.f64	d4, #48	@ 0x41800000  16.0
341811d6:	eea0 6b05 	vfma.f64	d6, d0, d5
341811da:	ed9f 5b1b 	vldr	d5, [pc, #108]	@ 34181248 <VGuzhuiVXN+0x128>
341811de:	eea2 6b04 	vfma.f64	d6, d2, d4
341811e2:	eea6 4b05 	vfma.f64	d4, d6, d5
341811e6:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 34181250 <VGuzhuiVXN+0x130>
341811ea:	ed80 4b00 	vstr	d4, [r0]
341811ee:	ee26 6b41 	vnmul.f64	d6, d6, d1
341811f2:	eebb 4b0a 	vmov.f64	d4, #186	@ 0xc1d00000 -26.0
341811f6:	ed9f 1b18 	vldr	d1, [pc, #96]	@ 34181258 <VGuzhuiVXN+0x138>
341811fa:	eea0 6b04 	vfma.f64	d6, d0, d4
341811fe:	ee21 1b47 	vnmul.f64	d1, d1, d7
34181202:	ed9f 4b17 	vldr	d4, [pc, #92]	@ 34181260 <VGuzhuiVXN+0x140>
34181206:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
3418120a:	eea0 1b04 	vfma.f64	d1, d0, d4
3418120e:	eea2 6b04 	vfma.f64	d6, d2, d4
34181212:	eea2 1b47 	vfms.f64	d1, d2, d7
34181216:	ee26 6b05 	vmul.f64	d6, d6, d5
3418121a:	ee21 1b05 	vmul.f64	d1, d1, d5
3418121e:	ed81 6b00 	vstr	d6, [r1]
34181222:	2001      	movs	r0, #1
34181224:	ed82 1b00 	vstr	d1, [r2]
34181228:	e798      	b.n	3418115c <VGuzhuiVXN+0x3c>
3418122a:	bf00      	nop
3418122c:	f3af 8000 	nop.w
34181230:	00000000 	.word	0x00000000
34181234:	406fe000 	.word	0x406fe000
34181238:	00000000 	.word	0x00000000
3418123c:	4063a000 	.word	0x4063a000
34181240:	00000000 	.word	0x00000000
34181244:	40478000 	.word	0x40478000
34181248:	00000000 	.word	0x00000000
3418124c:	3f700000 	.word	0x3f700000
34181250:	00000000 	.word	0x00000000
34181254:	40558000 	.word	0x40558000
34181258:	00000000 	.word	0x00000000
3418125c:	40598000 	.word	0x40598000
34181260:	00000000 	.word	0x00000000
34181264:	405c0000 	.word	0x405c0000
34181268:	341afb1b 	.word	0x341afb1b
3418126c:	341afb59 	.word	0x341afb59
34181270:	341afb15 	.word	0x341afb15
34181274:	341afb13 	.word	0x341afb13
34181278:	341afb99 	.word	0x341afb99
3418127c:	00000000 	.word	0x00000000

34181280 <GTePMGhCOh>:
34181280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34181284:	4606      	mov	r6, r0
34181286:	4698      	mov	r8, r3
34181288:	6d73      	ldr	r3, [r6, #84]	@ 0x54
3418128a:	460f      	mov	r7, r1
3418128c:	4610      	mov	r0, r2
3418128e:	9906      	ldr	r1, [sp, #24]
34181290:	b923      	cbnz	r3, 3418129c <GTePMGhCOh+0x1c>
34181292:	f8c8 7000 	str.w	r7, [r8]
34181296:	6008      	str	r0, [r1, #0]
34181298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3418129c:	4d20      	ldr	r5, [pc, #128]	@ (34181320 <GTePMGhCOh+0xa0>)
3418129e:	005b      	lsls	r3, r3, #1
341812a0:	fbb5 f5f3 	udiv	r5, r5, r3
341812a4:	4295      	cmp	r5, r2
341812a6:	d2f4      	bcs.n	34181292 <GTePMGhCOh+0x12>
341812a8:	fbb2 f4f5 	udiv	r4, r2, r5
341812ac:	ee07 2a90 	vmov	s15, r2
341812b0:	fb04 5205 	mla	r2, r4, r5, r5
341812b4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341812b8:	ee07 2a90 	vmov	s15, r2
341812bc:	eddf 6a19 	vldr	s13, [pc, #100]	@ 34181324 <GTePMGhCOh+0xa4>
341812c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
341812c4:	ee67 7aa6 	vmul.f32	s15, s15, s13
341812c8:	eeb4 7ae7 	vcmpe.f32	s14, s15
341812cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341812d0:	d5df      	bpl.n	34181292 <GTePMGhCOh+0x12>
341812d2:	1b52      	subs	r2, r2, r5
341812d4:	600a      	str	r2, [r1, #0]
341812d6:	3201      	adds	r2, #1
341812d8:	ee07 2a90 	vmov	s15, r2
341812dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
341812e0:	ee87 0a27 	vdiv.f32	s0, s14, s15
341812e4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341812e8:	f025 f87e 	bl	341a63e8 <log10>
341812ec:	ed9f 7b0a 	vldr	d7, [pc, #40]	@ 34181318 <GTePMGhCOh+0x98>
341812f0:	ee20 0b07 	vmul.f64	d0, d0, d7
341812f4:	eebc 0bc0 	vcvt.u32.f64	s0, d0
341812f8:	ee10 3a10 	vmov	r3, s0
341812fc:	443b      	add	r3, r7
341812fe:	461f      	mov	r7, r3
34181300:	f8c8 3000 	str.w	r3, [r8]
34181304:	6cf3      	ldr	r3, [r6, #76]	@ 0x4c
34181306:	42bb      	cmp	r3, r7
34181308:	bf94      	ite	ls
3418130a:	f8c8 3000 	strls.w	r3, [r8]
3418130e:	f8c8 7000 	strhi.w	r7, [r8]
34181312:	e7c1      	b.n	34181298 <GTePMGhCOh+0x18>
34181314:	f3af 8000 	nop.w
34181318:	00000000 	.word	0x00000000
3418131c:	40d38800 	.word	0x40d38800
34181320:	000f4240 	.word	0x000f4240
34181324:	3f733333 	.word	0x3f733333

34181328 <jHlPSTIzmc>:
34181328:	ee07 1a90 	vmov	s15, r1
3418132c:	ed9f 7a28 	vldr	s14, [pc, #160]	@ 341813d0 <jHlPSTIzmc+0xa8>
34181330:	eef8 7a67 	vcvt.f32.u32	s15, s15
34181334:	b570      	push	{r4, r5, r6, lr}
34181336:	ee87 1a87 	vdiv.f32	s2, s15, s14
3418133a:	ed2d 8b02 	vpush	{d8}
3418133e:	ee08 2a10 	vmov	s16, r2
34181342:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
34181346:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3418134a:	4605      	mov	r5, r0
3418134c:	461c      	mov	r4, r3
3418134e:	9e06      	ldr	r6, [sp, #24]
34181350:	f025 f8da 	bl	341a6508 <pow>
34181354:	eeb8 7b48 	vcvt.f64.u32	d7, s16
34181358:	ee27 7b00 	vmul.f64	d7, d7, d0
3418135c:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34181360:	ee17 2a90 	vmov	r2, s15
34181364:	6c69      	ldr	r1, [r5, #68]	@ 0x44
34181366:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3418136a:	4291      	cmp	r1, r2
3418136c:	d916      	bls.n	3418139c <jHlPSTIzmc+0x74>
3418136e:	2300      	movs	r3, #0
34181370:	6023      	str	r3, [r4, #0]
34181372:	edc6 7a00 	vstr	s15, [r6]
34181376:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
34181378:	eddf 6a16 	vldr	s13, [pc, #88]	@ 341813d4 <jHlPSTIzmc+0xac>
3418137c:	ee07 3a90 	vmov	s15, r3
34181380:	eef8 7a67 	vcvt.f32.u32	s15, s15
34181384:	ee67 7aa6 	vmul.f32	s15, s15, s13
34181388:	eeb4 7a67 	vcmp.f32	s14, s15
3418138c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181390:	bfc8      	it	gt
34181392:	461a      	movgt	r2, r3
34181394:	6032      	str	r2, [r6, #0]
34181396:	ecbd 8b02 	vpop	{d8}
3418139a:	bd70      	pop	{r4, r5, r6, pc}
3418139c:	ee07 1a90 	vmov	s15, r1
341813a0:	eef8 7a67 	vcvt.f32.u32	s15, s15
341813a4:	ee87 0a27 	vdiv.f32	s0, s14, s15
341813a8:	6031      	str	r1, [r6, #0]
341813aa:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341813ae:	f025 f81b 	bl	341a63e8 <log10>
341813b2:	ed9f 7b05 	vldr	d7, [pc, #20]	@ 341813c8 <jHlPSTIzmc+0xa0>
341813b6:	ee20 0b07 	vmul.f64	d0, d0, d7
341813ba:	eebc 0bc0 	vcvt.u32.f64	s0, d0
341813be:	ed84 0a00 	vstr	s0, [r4]
341813c2:	e7e8      	b.n	34181396 <jHlPSTIzmc+0x6e>
341813c4:	f3af 8000 	nop.w
341813c8:	00000000 	.word	0x00000000
341813cc:	40d38800 	.word	0x40d38800
341813d0:	469c4000 	.word	0x469c4000
341813d4:	3f7ae148 	.word	0x3f7ae148

341813d8 <evision_api_st_ae_new>:
341813d8:	b510      	push	{r4, lr}
341813da:	b090      	sub	sp, #64	@ 0x40
341813dc:	b168      	cbz	r0, 341813fa <evision_api_st_ae_new+0x22>
341813de:	2200      	movs	r2, #0
341813e0:	4c07      	ldr	r4, [pc, #28]	@ (34181400 <evision_api_st_ae_new+0x28>)
341813e2:	2140      	movs	r1, #64	@ 0x40
341813e4:	4b07      	ldr	r3, [pc, #28]	@ (34181404 <evision_api_st_ae_new+0x2c>)
341813e6:	7022      	strb	r2, [r4, #0]
341813e8:	65a0      	str	r0, [r4, #88]	@ 0x58
341813ea:	4a07      	ldr	r2, [pc, #28]	@ (34181408 <evision_api_st_ae_new+0x30>)
341813ec:	4668      	mov	r0, sp
341813ee:	f023 ff57 	bl	341a52a0 <sniprintf>
341813f2:	4668      	mov	r0, sp
341813f4:	6da3      	ldr	r3, [r4, #88]	@ 0x58
341813f6:	4798      	blx	r3
341813f8:	4620      	mov	r0, r4
341813fa:	b010      	add	sp, #64	@ 0x40
341813fc:	bd10      	pop	{r4, pc}
341813fe:	bf00      	nop
34181400:	341c0488 	.word	0x341c0488
34181404:	341b2026 	.word	0x341b2026
34181408:	341afbe3 	.word	0x341afbe3

3418140c <evision_api_st_ae_delete>:
3418140c:	2800      	cmp	r0, #0
3418140e:	bf0c      	ite	eq
34181410:	f04f 30ff 	moveq.w	r0, #4294967295
34181414:	2001      	movne	r0, #1
34181416:	4770      	bx	lr

34181418 <BnNqZEfmZx>:
34181418:	2238      	movs	r2, #56	@ 0x38
3418141a:	230a      	movs	r3, #10
3418141c:	b530      	push	{r4, r5, lr}
3418141e:	e9c0 2304 	strd	r2, r3, [r0, #16]
34181422:	2264      	movs	r2, #100	@ 0x64
34181424:	232d      	movs	r3, #45	@ 0x2d
34181426:	2178      	movs	r1, #120	@ 0x78
34181428:	e9c0 2306 	strd	r2, r3, [r0, #24]
3418142c:	f240 53dc 	movw	r3, #1500	@ 0x5dc
34181430:	f241 7470 	movw	r4, #6000	@ 0x1770
34181434:	e9c0 1308 	strd	r1, r3, [r0, #32]
34181438:	f642 63e0 	movw	r3, #12000	@ 0x2ee0
3418143c:	e9c0 430a 	strd	r4, r3, [r0, #40]	@ 0x28
34181440:	a50b      	add	r5, pc, #44	@ (adr r5, 34181470 <BnNqZEfmZx+0x58>)
34181442:	e9d5 4500 	ldrd	r4, r5, [r5]
34181446:	2305      	movs	r3, #5
34181448:	f248 01e8 	movw	r1, #33000	@ 0x80e8
3418144c:	6503      	str	r3, [r0, #80]	@ 0x50
3418144e:	2300      	movs	r3, #0
34181450:	e9c0 3110 	strd	r3, r1, [r0, #64]	@ 0x40
34181454:	2101      	movs	r1, #1
34181456:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3418145a:	a507      	add	r5, pc, #28	@ (adr r5, 34181478 <BnNqZEfmZx+0x60>)
3418145c:	e9d5 4500 	ldrd	r4, r5, [r5]
34181460:	e9c0 1212 	strd	r1, r2, [r0, #72]	@ 0x48
34181464:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
34181468:	6543      	str	r3, [r0, #84]	@ 0x54
3418146a:	bd30      	pop	{r4, r5, pc}
3418146c:	f3af 8000 	nop.w
34181470:	40000000 	.word	0x40000000
34181474:	3f947ae1 	.word	0x3f947ae1
34181478:	e0000000 	.word	0xe0000000
3418147c:	3f70624d 	.word	0x3f70624d

34181480 <evision_api_st_ae_init>:
34181480:	b510      	push	{r4, lr}
34181482:	4604      	mov	r4, r0
34181484:	b120      	cbz	r0, 34181490 <evision_api_st_ae_init+0x10>
34181486:	f7ff ffc7 	bl	34181418 <BnNqZEfmZx>
3418148a:	2001      	movs	r0, #1
3418148c:	7020      	strb	r0, [r4, #0]
3418148e:	bd10      	pop	{r4, pc}
34181490:	f04f 30ff 	mov.w	r0, #4294967295
34181494:	e7fb      	b.n	3418148e <evision_api_st_ae_init+0xe>

34181496 <evision_api_st_ae_process>:
34181496:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3418149a:	460f      	mov	r7, r1
3418149c:	4615      	mov	r5, r2
3418149e:	4698      	mov	r8, r3
341814a0:	4604      	mov	r4, r0
341814a2:	b089      	sub	sp, #36	@ 0x24
341814a4:	2800      	cmp	r0, #0
341814a6:	f000 813b 	beq.w	34181720 <evision_api_st_ae_process+0x28a>
341814aa:	7803      	ldrb	r3, [r0, #0]
341814ac:	2b01      	cmp	r3, #1
341814ae:	d11c      	bne.n	341814ea <evision_api_st_ae_process+0x54>
341814b0:	2302      	movs	r3, #2
341814b2:	7003      	strb	r3, [r0, #0]
341814b4:	f8d4 9054 	ldr.w	r9, [r4, #84]	@ 0x54
341814b8:	f1b9 0f00 	cmp.w	r9, #0
341814bc:	d019      	beq.n	341814f2 <evision_api_st_ae_process+0x5c>
341814be:	4b9c      	ldr	r3, [pc, #624]	@ (34181730 <evision_api_st_ae_process+0x29a>)
341814c0:	ea4f 0249 	mov.w	r2, r9, lsl #1
341814c4:	fbb3 f3f2 	udiv	r3, r3, r2
341814c8:	6ca6      	ldr	r6, [r4, #72]	@ 0x48
341814ca:	42be      	cmp	r6, r7
341814cc:	d213      	bcs.n	341814f6 <evision_api_st_ae_process+0x60>
341814ce:	6c62      	ldr	r2, [r4, #68]	@ 0x44
341814d0:	42aa      	cmp	r2, r5
341814d2:	d910      	bls.n	341814f6 <evision_api_st_ae_process+0x60>
341814d4:	fbb5 f2f3 	udiv	r2, r5, r3
341814d8:	fb03 5312 	mls	r3, r3, r2, r5
341814dc:	b15b      	cbz	r3, 341814f6 <evision_api_st_ae_process+0x60>
341814de:	e9c4 5601 	strd	r5, r6, [r4, #4]
341814e2:	2001      	movs	r0, #1
341814e4:	b009      	add	sp, #36	@ 0x24
341814e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341814ea:	2b02      	cmp	r3, #2
341814ec:	d0e2      	beq.n	341814b4 <evision_api_st_ae_process+0x1e>
341814ee:	2000      	movs	r0, #0
341814f0:	e7f8      	b.n	341814e4 <evision_api_st_ae_process+0x4e>
341814f2:	2301      	movs	r3, #1
341814f4:	e7e8      	b.n	341814c8 <evision_api_st_ae_process+0x32>
341814f6:	f10d 0a14 	add.w	sl, sp, #20
341814fa:	4639      	mov	r1, r7
341814fc:	ab04      	add	r3, sp, #16
341814fe:	462a      	mov	r2, r5
34181500:	4620      	mov	r0, r4
34181502:	f8cd a000 	str.w	sl, [sp]
34181506:	f7ff ff0f 	bl	34181328 <jHlPSTIzmc>
3418150a:	e9dd b104 	ldrd	fp, r1, [sp, #16]
3418150e:	f8d4 c010 	ldr.w	ip, [r4, #16]
34181512:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34181516:	ee07 ca90 	vmov	s15, ip
3418151a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3418151e:	ee07 8a90 	vmov	s15, r8
34181522:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34181526:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
3418152a:	ee37 7b05 	vadd.f64	d7, d7, d5
3418152e:	ee86 0b07 	vdiv.f64	d0, d6, d7
34181532:	6d23      	ldr	r3, [r4, #80]	@ 0x50
34181534:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34181538:	4598      	cmp	r8, r3
3418153a:	d30e      	bcc.n	3418155a <evision_api_st_ae_process+0xc4>
3418153c:	ebac 0008 	sub.w	r0, ip, r8
34181540:	69e3      	ldr	r3, [r4, #28]
34181542:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
34181546:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
3418154a:	429a      	cmp	r2, r3
3418154c:	d959      	bls.n	34181602 <evision_api_st_ae_process+0x16c>
3418154e:	6a23      	ldr	r3, [r4, #32]
34181550:	429a      	cmp	r2, r3
34181552:	bf2c      	ite	cs
34181554:	6ae3      	ldrcs	r3, [r4, #44]	@ 0x2c
34181556:	6aa3      	ldrcc	r3, [r4, #40]	@ 0x28
34181558:	e054      	b.n	34181604 <evision_api_st_ae_process+0x16e>
3418155a:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
3418155e:	eeb4 0ae7 	vcmpe.f32	s0, s15
34181562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34181566:	d4e9      	bmi.n	3418153c <evision_api_st_ae_process+0xa6>
34181568:	6c62      	ldr	r2, [r4, #68]	@ 0x44
3418156a:	4291      	cmp	r1, r2
3418156c:	d22b      	bcs.n	341815c6 <evision_api_st_ae_process+0x130>
3418156e:	2901      	cmp	r1, #1
34181570:	460b      	mov	r3, r1
34181572:	bf38      	it	cc
34181574:	2301      	movcc	r3, #1
34181576:	ee07 3a90 	vmov	s15, r3
3418157a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
3418157e:	ee67 7a80 	vmul.f32	s15, s15, s0
34181582:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34181586:	ee17 3a90 	vmov	r3, s15
3418158a:	4293      	cmp	r3, r2
3418158c:	dc0e      	bgt.n	341815ac <evision_api_st_ae_process+0x116>
3418158e:	edc4 7a01 	vstr	s15, [r4, #4]
34181592:	ab07      	add	r3, sp, #28
34181594:	9300      	str	r3, [sp, #0]
34181596:	4620      	mov	r0, r4
34181598:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3418159c:	ab06      	add	r3, sp, #24
3418159e:	f7ff fe6f 	bl	34181280 <GTePMGhCOh>
341815a2:	9b06      	ldr	r3, [sp, #24]
341815a4:	60a3      	str	r3, [r4, #8]
341815a6:	9b07      	ldr	r3, [sp, #28]
341815a8:	6063      	str	r3, [r4, #4]
341815aa:	e79a      	b.n	341814e2 <evision_api_st_ae_process+0x4c>
341815ac:	ee07 2a90 	vmov	s15, r2
341815b0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
341815b4:	ee07 1a90 	vmov	s15, r1
341815b8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341815bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
341815c0:	ee80 0a27 	vdiv.f32	s0, s0, s15
341815c4:	6062      	str	r2, [r4, #4]
341815c6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341815ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
341815ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341815d2:	ddde      	ble.n	34181592 <evision_api_st_ae_process+0xfc>
341815d4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
341815d8:	f024 ff06 	bl	341a63e8 <log10>
341815dc:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
341815e0:	ee20 0b07 	vmul.f64	d0, d0, d7
341815e4:	ed9f 7b50 	vldr	d7, [pc, #320]	@ 34181728 <evision_api_st_ae_process+0x292>
341815e8:	ee20 0b07 	vmul.f64	d0, d0, d7
341815ec:	eebd 0bc0 	vcvt.s32.f64	s0, d0
341815f0:	ee10 3a10 	vmov	r3, s0
341815f4:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
341815f6:	445b      	add	r3, fp
341815f8:	4293      	cmp	r3, r2
341815fa:	bfd4      	ite	le
341815fc:	60a3      	strle	r3, [r4, #8]
341815fe:	60a2      	strgt	r2, [r4, #8]
34181600:	e7c7      	b.n	34181592 <evision_api_st_ae_process+0xfc>
34181602:	6a63      	ldr	r3, [r4, #36]	@ 0x24
34181604:	f8d4 e014 	ldr.w	lr, [r4, #20]
34181608:	69a2      	ldr	r2, [r4, #24]
3418160a:	9303      	str	r3, [sp, #12]
3418160c:	eb0e 030c 	add.w	r3, lr, ip
34181610:	4543      	cmp	r3, r8
34181612:	fb00 f202 	mul.w	r2, r0, r2
34181616:	d24c      	bcs.n	341816b2 <evision_api_st_ae_process+0x21c>
34181618:	eddd 7a03 	vldr	s15, [sp, #12]
3418161c:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 34181734 <evision_api_st_ae_process+0x29e>
34181620:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34181624:	ee67 7a87 	vmul.f32	s15, s15, s14
34181628:	ee07 2a10 	vmov	s14, r2
3418162c:	eef1 6a67 	vneg.f32	s13, s15
34181630:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34181634:	eeb4 7ae6 	vcmpe.f32	s14, s13
34181638:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3418163c:	d504      	bpl.n	34181648 <evision_api_st_ae_process+0x1b2>
3418163e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34181642:	ee17 3a90 	vmov	r3, s15
34181646:	425a      	negs	r2, r3
34181648:	2a00      	cmp	r2, #0
3418164a:	d057      	beq.n	341816fc <evision_api_st_ae_process+0x266>
3418164c:	455e      	cmp	r6, fp
3418164e:	d14a      	bne.n	341816e6 <evision_api_st_ae_process+0x250>
34181650:	6c65      	ldr	r5, [r4, #68]	@ 0x44
34181652:	42a9      	cmp	r1, r5
34181654:	d336      	bcc.n	341816c4 <evision_api_st_ae_process+0x22e>
34181656:	2a00      	cmp	r2, #0
34181658:	da45      	bge.n	341816e6 <evision_api_st_ae_process+0x250>
3418165a:	fb01 0000 	mla	r0, r1, r0, r0
3418165e:	ee07 0a90 	vmov	s15, r0
34181662:	eeb8 6be7 	vcvt.f64.s32	d6, s15
34181666:	ee07 1a90 	vmov	s15, r1
3418166a:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
3418166e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34181672:	eea6 7b05 	vfma.f64	d7, d6, d5
34181676:	eebd 7bc7 	vcvt.s32.f64	s14, d7
3418167a:	ee17 2a10 	vmov	r2, s14
3418167e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34181680:	f8c4 b008 	str.w	fp, [r4, #8]
34181684:	429a      	cmp	r2, r3
34181686:	bfb8      	it	lt
34181688:	461a      	movlt	r2, r3
3418168a:	42aa      	cmp	r2, r5
3418168c:	bfd4      	ite	le
3418168e:	6062      	strle	r2, [r4, #4]
34181690:	6065      	strgt	r5, [r4, #4]
34181692:	4620      	mov	r0, r4
34181694:	f8cd a000 	str.w	sl, [sp]
34181698:	ab04      	add	r3, sp, #16
3418169a:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
3418169e:	f7ff fdef 	bl	34181280 <GTePMGhCOh>
341816a2:	9b04      	ldr	r3, [sp, #16]
341816a4:	9d05      	ldr	r5, [sp, #20]
341816a6:	60a3      	str	r3, [r4, #8]
341816a8:	4b23      	ldr	r3, [pc, #140]	@ (34181738 <evision_api_st_ae_process+0x2a2>)
341816aa:	6065      	str	r5, [r4, #4]
341816ac:	f8c3 9060 	str.w	r9, [r3, #96]	@ 0x60
341816b0:	e717      	b.n	341814e2 <evision_api_st_ae_process+0x4c>
341816b2:	ebac 0c0e 	sub.w	ip, ip, lr
341816b6:	45c4      	cmp	ip, r8
341816b8:	dd20      	ble.n	341816fc <evision_api_st_ae_process+0x266>
341816ba:	9b03      	ldr	r3, [sp, #12]
341816bc:	429a      	cmp	r2, r3
341816be:	bfa8      	it	ge
341816c0:	461a      	movge	r2, r3
341816c2:	e7c1      	b.n	34181648 <evision_api_st_ae_process+0x1b2>
341816c4:	2a00      	cmp	r2, #0
341816c6:	dbc8      	blt.n	3418165a <evision_api_st_ae_process+0x1c4>
341816c8:	fb01 0000 	mla	r0, r1, r0, r0
341816cc:	ee07 0a90 	vmov	s15, r0
341816d0:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341816d4:	ee07 1a90 	vmov	s15, r1
341816d8:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
341816dc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
341816e0:	eea5 7b06 	vfma.f64	d7, d5, d6
341816e4:	e7c7      	b.n	34181676 <evision_api_st_ae_process+0x1e0>
341816e6:	4493      	add	fp, r2
341816e8:	455e      	cmp	r6, fp
341816ea:	dc04      	bgt.n	341816f6 <evision_api_st_ae_process+0x260>
341816ec:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
341816ee:	465e      	mov	r6, fp
341816f0:	459b      	cmp	fp, r3
341816f2:	bfa8      	it	ge
341816f4:	461e      	movge	r6, r3
341816f6:	e9c4 1601 	strd	r1, r6, [r4, #4]
341816fa:	e7ca      	b.n	34181692 <evision_api_st_ae_process+0x1fc>
341816fc:	4b0e      	ldr	r3, [pc, #56]	@ (34181738 <evision_api_st_ae_process+0x2a2>)
341816fe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34181700:	4599      	cmp	r9, r3
34181702:	d00b      	beq.n	3418171c <evision_api_st_ae_process+0x286>
34181704:	462a      	mov	r2, r5
34181706:	4639      	mov	r1, r7
34181708:	4620      	mov	r0, r4
3418170a:	f8cd a000 	str.w	sl, [sp]
3418170e:	ab04      	add	r3, sp, #16
34181710:	f1b9 0f00 	cmp.w	r9, #0
34181714:	d1c3      	bne.n	3418169e <evision_api_st_ae_process+0x208>
34181716:	f7ff fe07 	bl	34181328 <jHlPSTIzmc>
3418171a:	e7c2      	b.n	341816a2 <evision_api_st_ae_process+0x20c>
3418171c:	60a7      	str	r7, [r4, #8]
3418171e:	e7c3      	b.n	341816a8 <evision_api_st_ae_process+0x212>
34181720:	f04f 30ff 	mov.w	r0, #4294967295
34181724:	e6de      	b.n	341814e4 <evision_api_st_ae_process+0x4e>
34181726:	bf00      	nop
34181728:	00000000 	.word	0x00000000
3418172c:	408f4000 	.word	0x408f4000
34181730:	000f4240 	.word	0x000f4240
34181734:	3f59999a 	.word	0x3f59999a
34181738:	341c0488 	.word	0x341c0488

3418173c <__aeabi_ldivmod>:
3418173c:	b97b      	cbnz	r3, 3418175e <__aeabi_ldivmod+0x22>
3418173e:	b972      	cbnz	r2, 3418175e <__aeabi_ldivmod+0x22>
34181740:	2900      	cmp	r1, #0
34181742:	bfbe      	ittt	lt
34181744:	2000      	movlt	r0, #0
34181746:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
3418174a:	e006      	blt.n	3418175a <__aeabi_ldivmod+0x1e>
3418174c:	bf08      	it	eq
3418174e:	2800      	cmpeq	r0, #0
34181750:	bf1c      	itt	ne
34181752:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34181756:	f04f 30ff 	movne.w	r0, #4294967295
3418175a:	f000 b9fb 	b.w	34181b54 <__aeabi_idiv0>
3418175e:	f1ad 0c08 	sub.w	ip, sp, #8
34181762:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34181766:	2900      	cmp	r1, #0
34181768:	db09      	blt.n	3418177e <__aeabi_ldivmod+0x42>
3418176a:	2b00      	cmp	r3, #0
3418176c:	db1a      	blt.n	341817a4 <__aeabi_ldivmod+0x68>
3418176e:	f000 f84d 	bl	3418180c <__udivmoddi4>
34181772:	f8dd e004 	ldr.w	lr, [sp, #4]
34181776:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
3418177a:	b004      	add	sp, #16
3418177c:	4770      	bx	lr
3418177e:	4240      	negs	r0, r0
34181780:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34181784:	2b00      	cmp	r3, #0
34181786:	db1b      	blt.n	341817c0 <__aeabi_ldivmod+0x84>
34181788:	f000 f840 	bl	3418180c <__udivmoddi4>
3418178c:	f8dd e004 	ldr.w	lr, [sp, #4]
34181790:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34181794:	b004      	add	sp, #16
34181796:	4240      	negs	r0, r0
34181798:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
3418179c:	4252      	negs	r2, r2
3418179e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817a2:	4770      	bx	lr
341817a4:	4252      	negs	r2, r2
341817a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817aa:	f000 f82f 	bl	3418180c <__udivmoddi4>
341817ae:	f8dd e004 	ldr.w	lr, [sp, #4]
341817b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
341817b6:	b004      	add	sp, #16
341817b8:	4240      	negs	r0, r0
341817ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
341817be:	4770      	bx	lr
341817c0:	4252      	negs	r2, r2
341817c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817c6:	f000 f821 	bl	3418180c <__udivmoddi4>
341817ca:	f8dd e004 	ldr.w	lr, [sp, #4]
341817ce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
341817d2:	b004      	add	sp, #16
341817d4:	4252      	negs	r2, r2
341817d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
341817da:	4770      	bx	lr

341817dc <__aeabi_uldivmod>:
341817dc:	b953      	cbnz	r3, 341817f4 <__aeabi_uldivmod+0x18>
341817de:	b94a      	cbnz	r2, 341817f4 <__aeabi_uldivmod+0x18>
341817e0:	2900      	cmp	r1, #0
341817e2:	bf08      	it	eq
341817e4:	2800      	cmpeq	r0, #0
341817e6:	bf1c      	itt	ne
341817e8:	f04f 31ff 	movne.w	r1, #4294967295
341817ec:	f04f 30ff 	movne.w	r0, #4294967295
341817f0:	f000 b9b0 	b.w	34181b54 <__aeabi_idiv0>
341817f4:	f1ad 0c08 	sub.w	ip, sp, #8
341817f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
341817fc:	f000 f806 	bl	3418180c <__udivmoddi4>
34181800:	f8dd e004 	ldr.w	lr, [sp, #4]
34181804:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34181808:	b004      	add	sp, #16
3418180a:	4770      	bx	lr

3418180c <__udivmoddi4>:
3418180c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34181810:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34181812:	4688      	mov	r8, r1
34181814:	4604      	mov	r4, r0
34181816:	468e      	mov	lr, r1
34181818:	2b00      	cmp	r3, #0
3418181a:	d14a      	bne.n	341818b2 <__udivmoddi4+0xa6>
3418181c:	428a      	cmp	r2, r1
3418181e:	4617      	mov	r7, r2
34181820:	d95f      	bls.n	341818e2 <__udivmoddi4+0xd6>
34181822:	fab2 f682 	clz	r6, r2
34181826:	b14e      	cbz	r6, 3418183c <__udivmoddi4+0x30>
34181828:	f1c6 0320 	rsb	r3, r6, #32
3418182c:	fa01 fe06 	lsl.w	lr, r1, r6
34181830:	40b7      	lsls	r7, r6
34181832:	40b4      	lsls	r4, r6
34181834:	fa20 f303 	lsr.w	r3, r0, r3
34181838:	ea43 0e0e 	orr.w	lr, r3, lr
3418183c:	ea4f 4817 	mov.w	r8, r7, lsr #16
34181840:	fa1f fc87 	uxth.w	ip, r7
34181844:	0c23      	lsrs	r3, r4, #16
34181846:	fbbe f1f8 	udiv	r1, lr, r8
3418184a:	fb08 ee11 	mls	lr, r8, r1, lr
3418184e:	fb01 f20c 	mul.w	r2, r1, ip
34181852:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34181856:	429a      	cmp	r2, r3
34181858:	d907      	bls.n	3418186a <__udivmoddi4+0x5e>
3418185a:	18fb      	adds	r3, r7, r3
3418185c:	f101 30ff 	add.w	r0, r1, #4294967295
34181860:	d202      	bcs.n	34181868 <__udivmoddi4+0x5c>
34181862:	429a      	cmp	r2, r3
34181864:	f200 8154 	bhi.w	34181b10 <__udivmoddi4+0x304>
34181868:	4601      	mov	r1, r0
3418186a:	1a9b      	subs	r3, r3, r2
3418186c:	b2a2      	uxth	r2, r4
3418186e:	fbb3 f0f8 	udiv	r0, r3, r8
34181872:	fb08 3310 	mls	r3, r8, r0, r3
34181876:	fb00 fc0c 	mul.w	ip, r0, ip
3418187a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3418187e:	4594      	cmp	ip, r2
34181880:	d90b      	bls.n	3418189a <__udivmoddi4+0x8e>
34181882:	18ba      	adds	r2, r7, r2
34181884:	f100 33ff 	add.w	r3, r0, #4294967295
34181888:	bf2c      	ite	cs
3418188a:	2401      	movcs	r4, #1
3418188c:	2400      	movcc	r4, #0
3418188e:	4594      	cmp	ip, r2
34181890:	d902      	bls.n	34181898 <__udivmoddi4+0x8c>
34181892:	2c00      	cmp	r4, #0
34181894:	f000 813f 	beq.w	34181b16 <__udivmoddi4+0x30a>
34181898:	4618      	mov	r0, r3
3418189a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3418189e:	eba2 020c 	sub.w	r2, r2, ip
341818a2:	2100      	movs	r1, #0
341818a4:	b11d      	cbz	r5, 341818ae <__udivmoddi4+0xa2>
341818a6:	40f2      	lsrs	r2, r6
341818a8:	2300      	movs	r3, #0
341818aa:	e9c5 2300 	strd	r2, r3, [r5]
341818ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341818b2:	428b      	cmp	r3, r1
341818b4:	d905      	bls.n	341818c2 <__udivmoddi4+0xb6>
341818b6:	b10d      	cbz	r5, 341818bc <__udivmoddi4+0xb0>
341818b8:	e9c5 0100 	strd	r0, r1, [r5]
341818bc:	2100      	movs	r1, #0
341818be:	4608      	mov	r0, r1
341818c0:	e7f5      	b.n	341818ae <__udivmoddi4+0xa2>
341818c2:	fab3 f183 	clz	r1, r3
341818c6:	2900      	cmp	r1, #0
341818c8:	d14e      	bne.n	34181968 <__udivmoddi4+0x15c>
341818ca:	4543      	cmp	r3, r8
341818cc:	f0c0 8112 	bcc.w	34181af4 <__udivmoddi4+0x2e8>
341818d0:	4282      	cmp	r2, r0
341818d2:	f240 810f 	bls.w	34181af4 <__udivmoddi4+0x2e8>
341818d6:	4608      	mov	r0, r1
341818d8:	2d00      	cmp	r5, #0
341818da:	d0e8      	beq.n	341818ae <__udivmoddi4+0xa2>
341818dc:	e9c5 4e00 	strd	r4, lr, [r5]
341818e0:	e7e5      	b.n	341818ae <__udivmoddi4+0xa2>
341818e2:	2a00      	cmp	r2, #0
341818e4:	f000 80ac 	beq.w	34181a40 <__udivmoddi4+0x234>
341818e8:	fab2 f682 	clz	r6, r2
341818ec:	2e00      	cmp	r6, #0
341818ee:	f040 80bb 	bne.w	34181a68 <__udivmoddi4+0x25c>
341818f2:	1a8b      	subs	r3, r1, r2
341818f4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
341818f8:	b2bc      	uxth	r4, r7
341818fa:	2101      	movs	r1, #1
341818fc:	0c02      	lsrs	r2, r0, #16
341818fe:	b280      	uxth	r0, r0
34181900:	fbb3 fcfe 	udiv	ip, r3, lr
34181904:	fb0e 331c 	mls	r3, lr, ip, r3
34181908:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
3418190c:	fb04 f20c 	mul.w	r2, r4, ip
34181910:	429a      	cmp	r2, r3
34181912:	d90e      	bls.n	34181932 <__udivmoddi4+0x126>
34181914:	18fb      	adds	r3, r7, r3
34181916:	f10c 38ff 	add.w	r8, ip, #4294967295
3418191a:	bf2c      	ite	cs
3418191c:	f04f 0901 	movcs.w	r9, #1
34181920:	f04f 0900 	movcc.w	r9, #0
34181924:	429a      	cmp	r2, r3
34181926:	d903      	bls.n	34181930 <__udivmoddi4+0x124>
34181928:	f1b9 0f00 	cmp.w	r9, #0
3418192c:	f000 80ec 	beq.w	34181b08 <__udivmoddi4+0x2fc>
34181930:	46c4      	mov	ip, r8
34181932:	1a9b      	subs	r3, r3, r2
34181934:	fbb3 f8fe 	udiv	r8, r3, lr
34181938:	fb0e 3318 	mls	r3, lr, r8, r3
3418193c:	fb04 f408 	mul.w	r4, r4, r8
34181940:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34181944:	4294      	cmp	r4, r2
34181946:	d90b      	bls.n	34181960 <__udivmoddi4+0x154>
34181948:	18ba      	adds	r2, r7, r2
3418194a:	f108 33ff 	add.w	r3, r8, #4294967295
3418194e:	bf2c      	ite	cs
34181950:	2001      	movcs	r0, #1
34181952:	2000      	movcc	r0, #0
34181954:	4294      	cmp	r4, r2
34181956:	d902      	bls.n	3418195e <__udivmoddi4+0x152>
34181958:	2800      	cmp	r0, #0
3418195a:	f000 80d1 	beq.w	34181b00 <__udivmoddi4+0x2f4>
3418195e:	4698      	mov	r8, r3
34181960:	1b12      	subs	r2, r2, r4
34181962:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34181966:	e79d      	b.n	341818a4 <__udivmoddi4+0x98>
34181968:	f1c1 0620 	rsb	r6, r1, #32
3418196c:	408b      	lsls	r3, r1
3418196e:	fa08 f401 	lsl.w	r4, r8, r1
34181972:	fa00 f901 	lsl.w	r9, r0, r1
34181976:	fa22 f706 	lsr.w	r7, r2, r6
3418197a:	fa28 f806 	lsr.w	r8, r8, r6
3418197e:	408a      	lsls	r2, r1
34181980:	431f      	orrs	r7, r3
34181982:	fa20 f306 	lsr.w	r3, r0, r6
34181986:	0c38      	lsrs	r0, r7, #16
34181988:	4323      	orrs	r3, r4
3418198a:	fa1f fc87 	uxth.w	ip, r7
3418198e:	0c1c      	lsrs	r4, r3, #16
34181990:	fbb8 fef0 	udiv	lr, r8, r0
34181994:	fb00 881e 	mls	r8, r0, lr, r8
34181998:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3418199c:	fb0e f80c 	mul.w	r8, lr, ip
341819a0:	45a0      	cmp	r8, r4
341819a2:	d90e      	bls.n	341819c2 <__udivmoddi4+0x1b6>
341819a4:	193c      	adds	r4, r7, r4
341819a6:	f10e 3aff 	add.w	sl, lr, #4294967295
341819aa:	bf2c      	ite	cs
341819ac:	f04f 0b01 	movcs.w	fp, #1
341819b0:	f04f 0b00 	movcc.w	fp, #0
341819b4:	45a0      	cmp	r8, r4
341819b6:	d903      	bls.n	341819c0 <__udivmoddi4+0x1b4>
341819b8:	f1bb 0f00 	cmp.w	fp, #0
341819bc:	f000 80b8 	beq.w	34181b30 <__udivmoddi4+0x324>
341819c0:	46d6      	mov	lr, sl
341819c2:	eba4 0408 	sub.w	r4, r4, r8
341819c6:	fa1f f883 	uxth.w	r8, r3
341819ca:	fbb4 f3f0 	udiv	r3, r4, r0
341819ce:	fb00 4413 	mls	r4, r0, r3, r4
341819d2:	fb03 fc0c 	mul.w	ip, r3, ip
341819d6:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
341819da:	45a4      	cmp	ip, r4
341819dc:	d90e      	bls.n	341819fc <__udivmoddi4+0x1f0>
341819de:	193c      	adds	r4, r7, r4
341819e0:	f103 30ff 	add.w	r0, r3, #4294967295
341819e4:	bf2c      	ite	cs
341819e6:	f04f 0801 	movcs.w	r8, #1
341819ea:	f04f 0800 	movcc.w	r8, #0
341819ee:	45a4      	cmp	ip, r4
341819f0:	d903      	bls.n	341819fa <__udivmoddi4+0x1ee>
341819f2:	f1b8 0f00 	cmp.w	r8, #0
341819f6:	f000 809f 	beq.w	34181b38 <__udivmoddi4+0x32c>
341819fa:	4603      	mov	r3, r0
341819fc:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34181a00:	eba4 040c 	sub.w	r4, r4, ip
34181a04:	fba0 ec02 	umull	lr, ip, r0, r2
34181a08:	4564      	cmp	r4, ip
34181a0a:	4673      	mov	r3, lr
34181a0c:	46e0      	mov	r8, ip
34181a0e:	d302      	bcc.n	34181a16 <__udivmoddi4+0x20a>
34181a10:	d107      	bne.n	34181a22 <__udivmoddi4+0x216>
34181a12:	45f1      	cmp	r9, lr
34181a14:	d205      	bcs.n	34181a22 <__udivmoddi4+0x216>
34181a16:	ebbe 0302 	subs.w	r3, lr, r2
34181a1a:	eb6c 0c07 	sbc.w	ip, ip, r7
34181a1e:	3801      	subs	r0, #1
34181a20:	46e0      	mov	r8, ip
34181a22:	b15d      	cbz	r5, 34181a3c <__udivmoddi4+0x230>
34181a24:	ebb9 0203 	subs.w	r2, r9, r3
34181a28:	eb64 0408 	sbc.w	r4, r4, r8
34181a2c:	fa04 f606 	lsl.w	r6, r4, r6
34181a30:	fa22 f301 	lsr.w	r3, r2, r1
34181a34:	40cc      	lsrs	r4, r1
34181a36:	431e      	orrs	r6, r3
34181a38:	e9c5 6400 	strd	r6, r4, [r5]
34181a3c:	2100      	movs	r1, #0
34181a3e:	e736      	b.n	341818ae <__udivmoddi4+0xa2>
34181a40:	fbb1 fcf2 	udiv	ip, r1, r2
34181a44:	0c01      	lsrs	r1, r0, #16
34181a46:	4614      	mov	r4, r2
34181a48:	b280      	uxth	r0, r0
34181a4a:	4696      	mov	lr, r2
34181a4c:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34181a50:	2620      	movs	r6, #32
34181a52:	4690      	mov	r8, r2
34181a54:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34181a58:	4610      	mov	r0, r2
34181a5a:	fbb1 f1f2 	udiv	r1, r1, r2
34181a5e:	eba3 0308 	sub.w	r3, r3, r8
34181a62:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34181a66:	e74b      	b.n	34181900 <__udivmoddi4+0xf4>
34181a68:	40b7      	lsls	r7, r6
34181a6a:	f1c6 0320 	rsb	r3, r6, #32
34181a6e:	fa01 f206 	lsl.w	r2, r1, r6
34181a72:	fa21 f803 	lsr.w	r8, r1, r3
34181a76:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34181a7a:	fa20 f303 	lsr.w	r3, r0, r3
34181a7e:	b2bc      	uxth	r4, r7
34181a80:	40b0      	lsls	r0, r6
34181a82:	4313      	orrs	r3, r2
34181a84:	0c02      	lsrs	r2, r0, #16
34181a86:	0c19      	lsrs	r1, r3, #16
34181a88:	b280      	uxth	r0, r0
34181a8a:	fbb8 f9fe 	udiv	r9, r8, lr
34181a8e:	fb0e 8819 	mls	r8, lr, r9, r8
34181a92:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34181a96:	fb09 f804 	mul.w	r8, r9, r4
34181a9a:	4588      	cmp	r8, r1
34181a9c:	d951      	bls.n	34181b42 <__udivmoddi4+0x336>
34181a9e:	1879      	adds	r1, r7, r1
34181aa0:	f109 3cff 	add.w	ip, r9, #4294967295
34181aa4:	bf2c      	ite	cs
34181aa6:	f04f 0a01 	movcs.w	sl, #1
34181aaa:	f04f 0a00 	movcc.w	sl, #0
34181aae:	4588      	cmp	r8, r1
34181ab0:	d902      	bls.n	34181ab8 <__udivmoddi4+0x2ac>
34181ab2:	f1ba 0f00 	cmp.w	sl, #0
34181ab6:	d031      	beq.n	34181b1c <__udivmoddi4+0x310>
34181ab8:	eba1 0108 	sub.w	r1, r1, r8
34181abc:	fbb1 f9fe 	udiv	r9, r1, lr
34181ac0:	fb09 f804 	mul.w	r8, r9, r4
34181ac4:	fb0e 1119 	mls	r1, lr, r9, r1
34181ac8:	b29b      	uxth	r3, r3
34181aca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34181ace:	4543      	cmp	r3, r8
34181ad0:	d235      	bcs.n	34181b3e <__udivmoddi4+0x332>
34181ad2:	18fb      	adds	r3, r7, r3
34181ad4:	f109 31ff 	add.w	r1, r9, #4294967295
34181ad8:	bf2c      	ite	cs
34181ada:	f04f 0a01 	movcs.w	sl, #1
34181ade:	f04f 0a00 	movcc.w	sl, #0
34181ae2:	4543      	cmp	r3, r8
34181ae4:	d2bb      	bcs.n	34181a5e <__udivmoddi4+0x252>
34181ae6:	f1ba 0f00 	cmp.w	sl, #0
34181aea:	d1b8      	bne.n	34181a5e <__udivmoddi4+0x252>
34181aec:	f1a9 0102 	sub.w	r1, r9, #2
34181af0:	443b      	add	r3, r7
34181af2:	e7b4      	b.n	34181a5e <__udivmoddi4+0x252>
34181af4:	1a84      	subs	r4, r0, r2
34181af6:	eb68 0203 	sbc.w	r2, r8, r3
34181afa:	2001      	movs	r0, #1
34181afc:	4696      	mov	lr, r2
34181afe:	e6eb      	b.n	341818d8 <__udivmoddi4+0xcc>
34181b00:	443a      	add	r2, r7
34181b02:	f1a8 0802 	sub.w	r8, r8, #2
34181b06:	e72b      	b.n	34181960 <__udivmoddi4+0x154>
34181b08:	f1ac 0c02 	sub.w	ip, ip, #2
34181b0c:	443b      	add	r3, r7
34181b0e:	e710      	b.n	34181932 <__udivmoddi4+0x126>
34181b10:	3902      	subs	r1, #2
34181b12:	443b      	add	r3, r7
34181b14:	e6a9      	b.n	3418186a <__udivmoddi4+0x5e>
34181b16:	443a      	add	r2, r7
34181b18:	3802      	subs	r0, #2
34181b1a:	e6be      	b.n	3418189a <__udivmoddi4+0x8e>
34181b1c:	eba7 0808 	sub.w	r8, r7, r8
34181b20:	f1a9 0c02 	sub.w	ip, r9, #2
34181b24:	4441      	add	r1, r8
34181b26:	fbb1 f9fe 	udiv	r9, r1, lr
34181b2a:	fb09 f804 	mul.w	r8, r9, r4
34181b2e:	e7c9      	b.n	34181ac4 <__udivmoddi4+0x2b8>
34181b30:	f1ae 0e02 	sub.w	lr, lr, #2
34181b34:	443c      	add	r4, r7
34181b36:	e744      	b.n	341819c2 <__udivmoddi4+0x1b6>
34181b38:	3b02      	subs	r3, #2
34181b3a:	443c      	add	r4, r7
34181b3c:	e75e      	b.n	341819fc <__udivmoddi4+0x1f0>
34181b3e:	4649      	mov	r1, r9
34181b40:	e78d      	b.n	34181a5e <__udivmoddi4+0x252>
34181b42:	eba1 0108 	sub.w	r1, r1, r8
34181b46:	46cc      	mov	ip, r9
34181b48:	fbb1 f9fe 	udiv	r9, r1, lr
34181b4c:	fb09 f804 	mul.w	r8, r9, r4
34181b50:	e7b8      	b.n	34181ac4 <__udivmoddi4+0x2b8>
34181b52:	bf00      	nop

34181b54 <__aeabi_idiv0>:
34181b54:	4770      	bx	lr
34181b56:	bf00      	nop

34181b58 <DCMIPP_PipeInitDisplay>:
#define CAMERA_FPS 30

extern int32_t cameraFrameReceived;

static void DCMIPP_PipeInitDisplay(CMW_CameraInit_t *camConf, uint32_t *bg_width, uint32_t *bg_height)
{
34181b58:	b580      	push	{r7, lr}
34181b5a:	b094      	sub	sp, #80	@ 0x50
34181b5c:	af00      	add	r7, sp, #0
34181b5e:	60f8      	str	r0, [r7, #12]
34181b60:	60b9      	str	r1, [r7, #8]
34181b62:	607a      	str	r2, [r7, #4]
  CMW_Aspect_Ratio_Mode_t aspect_ratio;
  CMW_DCMIPP_Conf_t dcmipp_conf = {0};
34181b64:	f107 0314 	add.w	r3, r7, #20
34181b68:	222c      	movs	r2, #44	@ 0x2c
34181b6a:	2100      	movs	r1, #0
34181b6c:	4618      	mov	r0, r3
34181b6e:	f023 fcbf 	bl	341a54f0 <memset>
  int ret;

  if (ASPECT_RATIO_MODE == ASPECT_RATIO_CROP)
  {
    aspect_ratio = CMW_Aspect_ratio_crop;
34181b72:	2300      	movs	r3, #0
34181b74:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  }

  int lcd_bg_width;
  int lcd_bg_height;

  lcd_bg_height = (camConf->height <= SCREEN_HEIGHT) ? camConf->height : SCREEN_HEIGHT;
34181b78:	68fb      	ldr	r3, [r7, #12]
34181b7a:	685b      	ldr	r3, [r3, #4]
34181b7c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34181b80:	bf28      	it	cs
34181b82:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
34181b86:	64bb      	str	r3, [r7, #72]	@ 0x48

#if ASPECT_RATIO_MODE == ASPECT_RATIO_FULLSCREEN
  lcd_bg_width = (((camConf->width*lcd_bg_height)/camConf->height) - ((camConf->width*lcd_bg_height)/camConf->height) % 16);
#else
  lcd_bg_width = (camConf->height <= SCREEN_HEIGHT) ? camConf->height : SCREEN_HEIGHT;
34181b88:	68fb      	ldr	r3, [r7, #12]
34181b8a:	685b      	ldr	r3, [r3, #4]
34181b8c:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
34181b90:	bf28      	it	cs
34181b92:	f44f 73f0 	movcs.w	r3, #480	@ 0x1e0
34181b96:	647b      	str	r3, [r7, #68]	@ 0x44
#endif

  *bg_width = lcd_bg_width;
34181b98:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34181b9a:	68bb      	ldr	r3, [r7, #8]
34181b9c:	601a      	str	r2, [r3, #0]
  *bg_height = lcd_bg_height;
34181b9e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34181ba0:	687b      	ldr	r3, [r7, #4]
34181ba2:	601a      	str	r2, [r3, #0]

  dcmipp_conf.output_width = lcd_bg_width;
34181ba4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34181ba6:	617b      	str	r3, [r7, #20]
  dcmipp_conf.output_height = lcd_bg_height;
34181ba8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34181baa:	61bb      	str	r3, [r7, #24]
  dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34181bac:	2301      	movs	r3, #1
34181bae:	61fb      	str	r3, [r7, #28]
  dcmipp_conf.output_bpp = 2;
34181bb0:	2302      	movs	r3, #2
34181bb2:	623b      	str	r3, [r7, #32]
  dcmipp_conf.mode = aspect_ratio;
34181bb4:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34181bb8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  dcmipp_conf.enable_gamma_conversion = GAMMA_CONVERSION;
34181bba:	2300      	movs	r3, #0
34181bbc:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t pitch;
  ret = CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &dcmipp_conf, &pitch);
34181bbe:	f107 0210 	add.w	r2, r7, #16
34181bc2:	f107 0314 	add.w	r3, r7, #20
34181bc6:	4619      	mov	r1, r3
34181bc8:	2001      	movs	r0, #1
34181bca:	f019 fcab 	bl	3419b524 <CMW_CAMERA_SetPipeConfig>
34181bce:	6438      	str	r0, [r7, #64]	@ 0x40
  assert(ret == HAL_OK);
34181bd0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34181bd2:	2b00      	cmp	r3, #0
34181bd4:	d005      	beq.n	34181be2 <DCMIPP_PipeInitDisplay+0x8a>
34181bd6:	4b0b      	ldr	r3, [pc, #44]	@ (34181c04 <DCMIPP_PipeInitDisplay+0xac>)
34181bd8:	4a0b      	ldr	r2, [pc, #44]	@ (34181c08 <DCMIPP_PipeInitDisplay+0xb0>)
34181bda:	2151      	movs	r1, #81	@ 0x51
34181bdc:	480b      	ldr	r0, [pc, #44]	@ (34181c0c <DCMIPP_PipeInitDisplay+0xb4>)
34181bde:	f023 f9fd 	bl	341a4fdc <__assert_func>
  assert(dcmipp_conf.output_width * dcmipp_conf.output_bpp == pitch);
34181be2:	697b      	ldr	r3, [r7, #20]
34181be4:	6a3a      	ldr	r2, [r7, #32]
34181be6:	fb03 f202 	mul.w	r2, r3, r2
34181bea:	693b      	ldr	r3, [r7, #16]
34181bec:	429a      	cmp	r2, r3
34181bee:	d005      	beq.n	34181bfc <DCMIPP_PipeInitDisplay+0xa4>
34181bf0:	4b07      	ldr	r3, [pc, #28]	@ (34181c10 <DCMIPP_PipeInitDisplay+0xb8>)
34181bf2:	4a05      	ldr	r2, [pc, #20]	@ (34181c08 <DCMIPP_PipeInitDisplay+0xb0>)
34181bf4:	2152      	movs	r1, #82	@ 0x52
34181bf6:	4805      	ldr	r0, [pc, #20]	@ (34181c0c <DCMIPP_PipeInitDisplay+0xb4>)
34181bf8:	f023 f9f0 	bl	341a4fdc <__assert_func>
}
34181bfc:	bf00      	nop
34181bfe:	3750      	adds	r7, #80	@ 0x50
34181c00:	46bd      	mov	sp, r7
34181c02:	bd80      	pop	{r7, pc}
34181c04:	341a7110 	.word	0x341a7110
34181c08:	341a7de0 	.word	0x341a7de0
34181c0c:	341a7120 	.word	0x341a7120
34181c10:	341a7150 	.word	0x341a7150

34181c14 <CameraPipeline_Init>:
* @param lcd_bg_width display width
* @param lcd_bg_height display height
* @param pitch_nn output pitch computed by the CMW
*/
void CameraPipeline_Init(uint32_t *lcd_bg_width, uint32_t *lcd_bg_height, uint32_t *pitch_nn)
{
34181c14:	b580      	push	{r7, lr}
34181c16:	b08c      	sub	sp, #48	@ 0x30
34181c18:	af00      	add	r7, sp, #0
34181c1a:	60f8      	str	r0, [r7, #12]
34181c1c:	60b9      	str	r1, [r7, #8]
34181c1e:	607a      	str	r2, [r7, #4]
  int ret;
  CMW_CameraInit_t cam_conf;

  cam_conf.width = CAMERA_WIDTH;
34181c20:	2300      	movs	r3, #0
34181c22:	617b      	str	r3, [r7, #20]
  cam_conf.height = CAMERA_HEIGHT;
34181c24:	2300      	movs	r3, #0
34181c26:	61bb      	str	r3, [r7, #24]
  cam_conf.fps = CAMERA_FPS;
34181c28:	231e      	movs	r3, #30
34181c2a:	61fb      	str	r3, [r7, #28]
  cam_conf.pixel_format = 0; /* Default; Not implemented yet */
34181c2c:	2300      	movs	r3, #0
34181c2e:	623b      	str	r3, [r7, #32]
  cam_conf.anti_flicker = 0;
34181c30:	2300      	movs	r3, #0
34181c32:	627b      	str	r3, [r7, #36]	@ 0x24
  cam_conf.mirror_flip = CAMERA_FLIP;
34181c34:	2300      	movs	r3, #0
34181c36:	62bb      	str	r3, [r7, #40]	@ 0x28

  ret = CMW_CAMERA_Init(&cam_conf, NULL);
34181c38:	f107 0314 	add.w	r3, r7, #20
34181c3c:	2100      	movs	r1, #0
34181c3e:	4618      	mov	r0, r3
34181c40:	f019 fcb4 	bl	3419b5ac <CMW_CAMERA_Init>
34181c44:	62f8      	str	r0, [r7, #44]	@ 0x2c
  assert(ret == CMW_ERROR_NONE);
34181c46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34181c48:	2b00      	cmp	r3, #0
34181c4a:	d005      	beq.n	34181c58 <CameraPipeline_Init+0x44>
34181c4c:	4b08      	ldr	r3, [pc, #32]	@ (34181c70 <CameraPipeline_Init+0x5c>)
34181c4e:	4a09      	ldr	r2, [pc, #36]	@ (34181c74 <CameraPipeline_Init+0x60>)
34181c50:	2186      	movs	r1, #134	@ 0x86
34181c52:	4809      	ldr	r0, [pc, #36]	@ (34181c78 <CameraPipeline_Init+0x64>)
34181c54:	f023 f9c2 	bl	341a4fdc <__assert_func>
  DCMIPP_PipeInitDisplay(&cam_conf, lcd_bg_width, lcd_bg_height);
34181c58:	f107 0314 	add.w	r3, r7, #20
34181c5c:	68ba      	ldr	r2, [r7, #8]
34181c5e:	68f9      	ldr	r1, [r7, #12]
34181c60:	4618      	mov	r0, r3
34181c62:	f7ff ff79 	bl	34181b58 <DCMIPP_PipeInitDisplay>
//  DCMIPP_PipeInitNn(pitch_nn);
}
34181c66:	bf00      	nop
34181c68:	3730      	adds	r7, #48	@ 0x30
34181c6a:	46bd      	mov	sp, r7
34181c6c:	bd80      	pop	{r7, pc}
34181c6e:	bf00      	nop
34181c70:	341a718c 	.word	0x341a718c
34181c74:	341a7df8 	.word	0x341a7df8
34181c78:	341a7120 	.word	0x341a7120

34181c7c <CameraPipeline_DisplayPipe_Start>:
  ret = CMW_CAMERA_DeInit();
  assert(ret == CMW_ERROR_NONE);
}

void CameraPipeline_DisplayPipe_Start(uint8_t *display_pipe_dst, uint32_t cam_mode)
{
34181c7c:	b580      	push	{r7, lr}
34181c7e:	b084      	sub	sp, #16
34181c80:	af00      	add	r7, sp, #0
34181c82:	6078      	str	r0, [r7, #4]
34181c84:	6039      	str	r1, [r7, #0]
  int ret;
  ret = CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_dst, cam_mode);
34181c86:	683a      	ldr	r2, [r7, #0]
34181c88:	6879      	ldr	r1, [r7, #4]
34181c8a:	2001      	movs	r0, #1
34181c8c:	f019 fd3c 	bl	3419b708 <CMW_CAMERA_Start>
34181c90:	60f8      	str	r0, [r7, #12]
  assert(ret == CMW_ERROR_NONE);
34181c92:	68fb      	ldr	r3, [r7, #12]
34181c94:	2b00      	cmp	r3, #0
34181c96:	d005      	beq.n	34181ca4 <CameraPipeline_DisplayPipe_Start+0x28>
34181c98:	4b04      	ldr	r3, [pc, #16]	@ (34181cac <CameraPipeline_DisplayPipe_Start+0x30>)
34181c9a:	4a05      	ldr	r2, [pc, #20]	@ (34181cb0 <CameraPipeline_DisplayPipe_Start+0x34>)
34181c9c:	2196      	movs	r1, #150	@ 0x96
34181c9e:	4805      	ldr	r0, [pc, #20]	@ (34181cb4 <CameraPipeline_DisplayPipe_Start+0x38>)
34181ca0:	f023 f99c 	bl	341a4fdc <__assert_func>
}
34181ca4:	bf00      	nop
34181ca6:	3710      	adds	r7, #16
34181ca8:	46bd      	mov	sp, r7
34181caa:	bd80      	pop	{r7, pc}
34181cac:	341a718c 	.word	0x341a718c
34181cb0:	341a7e0c 	.word	0x341a7e0c
34181cb4:	341a7120 	.word	0x341a7120

34181cb8 <CameraPipeline_IspUpdate>:
  ret = CMW_CAMERA_Suspend(DCMIPP_PIPE1);
  assert(ret == CMW_ERROR_NONE);
}

void CameraPipeline_IspUpdate(void)
{
34181cb8:	b580      	push	{r7, lr}
34181cba:	b082      	sub	sp, #8
34181cbc:	af00      	add	r7, sp, #0
  int ret = CMW_ERROR_NONE;
34181cbe:	2300      	movs	r3, #0
34181cc0:	607b      	str	r3, [r7, #4]
  ret = CMW_CAMERA_Run();
34181cc2:	f019 fdfd 	bl	3419b8c0 <CMW_CAMERA_Run>
34181cc6:	6078      	str	r0, [r7, #4]
  assert(ret == CMW_ERROR_NONE);
34181cc8:	687b      	ldr	r3, [r7, #4]
34181cca:	2b00      	cmp	r3, #0
34181ccc:	d005      	beq.n	34181cda <CameraPipeline_IspUpdate+0x22>
34181cce:	4b05      	ldr	r3, [pc, #20]	@ (34181ce4 <CameraPipeline_IspUpdate+0x2c>)
34181cd0:	4a05      	ldr	r2, [pc, #20]	@ (34181ce8 <CameraPipeline_IspUpdate+0x30>)
34181cd2:	21ac      	movs	r1, #172	@ 0xac
34181cd4:	4805      	ldr	r0, [pc, #20]	@ (34181cec <CameraPipeline_IspUpdate+0x34>)
34181cd6:	f023 f981 	bl	341a4fdc <__assert_func>
}
34181cda:	bf00      	nop
34181cdc:	3708      	adds	r7, #8
34181cde:	46bd      	mov	sp, r7
34181ce0:	bd80      	pop	{r7, pc}
34181ce2:	bf00      	nop
34181ce4:	341a718c 	.word	0x341a718c
34181ce8:	341a7e30 	.word	0x341a7e30
34181cec:	341a7120 	.word	0x341a7120

34181cf0 <MX_BSEC_Init>:

/* USER CODE END 0 */

/* BSEC init function */
void MX_BSEC_Init(void)
{
34181cf0:	b480      	push	{r7}
34181cf2:	af00      	add	r7, sp, #0
  /* USER CODE END BSEC_Init 1 */
  /* USER CODE BEGIN BSEC_Init 2 */

  /* USER CODE END BSEC_Init 2 */

}
34181cf4:	bf00      	nop
34181cf6:	46bd      	mov	sp, r7
34181cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
34181cfc:	4770      	bx	lr
	...

34181d00 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34181d00:	b480      	push	{r7}
34181d02:	b085      	sub	sp, #20
34181d04:	af00      	add	r7, sp, #0
34181d06:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34181d08:	4a07      	ldr	r2, [pc, #28]	@ (34181d28 <LL_AHB5_GRP1_EnableClock+0x28>)
34181d0a:	687b      	ldr	r3, [r7, #4]
34181d0c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34181d10:	4b05      	ldr	r3, [pc, #20]	@ (34181d28 <LL_AHB5_GRP1_EnableClock+0x28>)
34181d12:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34181d16:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34181d18:	68fb      	ldr	r3, [r7, #12]
}
34181d1a:	bf00      	nop
34181d1c:	3714      	adds	r7, #20
34181d1e:	46bd      	mov	sp, r7
34181d20:	f85d 7b04 	ldr.w	r7, [sp], #4
34181d24:	4770      	bx	lr
34181d26:	bf00      	nop
34181d28:	56028000 	.word	0x56028000

34181d2c <MX_CACHEAXI_Init>:

CACHEAXI_HandleTypeDef hcacheaxi;

/* CACHEAXI init function */
void MX_CACHEAXI_Init(void)
{
34181d2c:	b580      	push	{r7, lr}
34181d2e:	af00      	add	r7, sp, #0
  /* USER CODE END CACHEAXI_Init 0 */

  /* USER CODE BEGIN CACHEAXI_Init 1 */

  /* USER CODE END CACHEAXI_Init 1 */
  hcacheaxi.Instance = CACHEAXI;
34181d30:	4b06      	ldr	r3, [pc, #24]	@ (34181d4c <MX_CACHEAXI_Init+0x20>)
34181d32:	4a07      	ldr	r2, [pc, #28]	@ (34181d50 <MX_CACHEAXI_Init+0x24>)
34181d34:	601a      	str	r2, [r3, #0]
  if (HAL_CACHEAXI_Init(&hcacheaxi) != HAL_OK)
34181d36:	4805      	ldr	r0, [pc, #20]	@ (34181d4c <MX_CACHEAXI_Init+0x20>)
34181d38:	f004 fc1a 	bl	34186570 <HAL_CACHEAXI_Init>
34181d3c:	4603      	mov	r3, r0
34181d3e:	2b00      	cmp	r3, #0
34181d40:	d001      	beq.n	34181d46 <MX_CACHEAXI_Init+0x1a>
  {
    Error_Handler();
34181d42:	f001 f90d 	bl	34182f60 <Error_Handler>
  }
  /* USER CODE BEGIN CACHEAXI_Init 2 */

  /* USER CODE END CACHEAXI_Init 2 */

}
34181d46:	bf00      	nop
34181d48:	bd80      	pop	{r7, pc}
34181d4a:	bf00      	nop
34181d4c:	341c04ec 	.word	0x341c04ec
34181d50:	580dfc00 	.word	0x580dfc00

34181d54 <HAL_CACHEAXI_MspInit>:

void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef* cacheaxiHandle)
{
34181d54:	b580      	push	{r7, lr}
34181d56:	b082      	sub	sp, #8
34181d58:	af00      	add	r7, sp, #0
34181d5a:	6078      	str	r0, [r7, #4]

  if(cacheaxiHandle->Instance==CACHEAXI)
34181d5c:	687b      	ldr	r3, [r7, #4]
34181d5e:	681b      	ldr	r3, [r3, #0]
34181d60:	4a05      	ldr	r2, [pc, #20]	@ (34181d78 <HAL_CACHEAXI_MspInit+0x24>)
34181d62:	4293      	cmp	r3, r2
34181d64:	d103      	bne.n	34181d6e <HAL_CACHEAXI_MspInit+0x1a>
  {
  /* USER CODE BEGIN CACHEAXI_MspInit 0 */

  /* USER CODE END CACHEAXI_MspInit 0 */
    /* CACHEAXI clock enable */
    __HAL_RCC_CACHEAXI_CLK_ENABLE();
34181d66:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34181d6a:	f7ff ffc9 	bl	34181d00 <LL_AHB5_GRP1_EnableClock>
  /* USER CODE BEGIN CACHEAXI_MspInit 1 */

  /* USER CODE END CACHEAXI_MspInit 1 */
  }
}
34181d6e:	bf00      	nop
34181d70:	3708      	adds	r7, #8
34181d72:	46bd      	mov	sp, r7
34181d74:	bd80      	pop	{r7, pc}
34181d76:	bf00      	nop
34181d78:	580dfc00 	.word	0x580dfc00

34181d7c <LL_APB5_GRP1_EnableClock>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
34181d7c:	b480      	push	{r7}
34181d7e:	b085      	sub	sp, #20
34181d80:	af00      	add	r7, sp, #0
34181d82:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
34181d84:	4a07      	ldr	r2, [pc, #28]	@ (34181da4 <LL_APB5_GRP1_EnableClock+0x28>)
34181d86:	687b      	ldr	r3, [r7, #4]
34181d88:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
34181d8c:	4b05      	ldr	r3, [pc, #20]	@ (34181da4 <LL_APB5_GRP1_EnableClock+0x28>)
34181d8e:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
34181d92:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34181d94:	68fb      	ldr	r3, [r7, #12]
}
34181d96:	bf00      	nop
34181d98:	3714      	adds	r7, #20
34181d9a:	46bd      	mov	sp, r7
34181d9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34181da0:	4770      	bx	lr
34181da2:	bf00      	nop
34181da4:	56028000 	.word	0x56028000

34181da8 <LL_APB5_GRP1_ForceReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ForceReset(uint32_t Periphs)
{
34181da8:	b480      	push	{r7}
34181daa:	b083      	sub	sp, #12
34181dac:	af00      	add	r7, sp, #0
34181dae:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34181db0:	4a04      	ldr	r2, [pc, #16]	@ (34181dc4 <LL_APB5_GRP1_ForceReset+0x1c>)
34181db2:	687b      	ldr	r3, [r7, #4]
34181db4:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34181db8:	bf00      	nop
34181dba:	370c      	adds	r7, #12
34181dbc:	46bd      	mov	sp, r7
34181dbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34181dc2:	4770      	bx	lr
34181dc4:	56028000 	.word	0x56028000

34181dc8 <LL_APB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34181dc8:	b480      	push	{r7}
34181dca:	b083      	sub	sp, #12
34181dcc:	af00      	add	r7, sp, #0
34181dce:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34181dd0:	4b06      	ldr	r3, [pc, #24]	@ (34181dec <LL_APB5_GRP1_ReleaseReset+0x24>)
34181dd2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34181dd6:	461a      	mov	r2, r3
34181dd8:	687b      	ldr	r3, [r7, #4]
34181dda:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34181dde:	bf00      	nop
34181de0:	370c      	adds	r7, #12
34181de2:	46bd      	mov	sp, r7
34181de4:	f85d 7b04 	ldr.w	r7, [sp], #4
34181de8:	4770      	bx	lr
34181dea:	bf00      	nop
34181dec:	56028000 	.word	0x56028000

34181df0 <MX_DCMIPP_Init>:

DCMIPP_HandleTypeDef hdcmipp;

/* DCMIPP init function */
void MX_DCMIPP_Init(void)
{
34181df0:	b580      	push	{r7, lr}
34181df2:	b08a      	sub	sp, #40	@ 0x28
34181df4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DCMIPP_Init 0 */

  /* USER CODE END DCMIPP_Init 0 */

  DCMIPP_CSI_PIPE_ConfTypeDef pCSI_PipeConfig = {0};
34181df6:	f107 031c 	add.w	r3, r7, #28
34181dfa:	2200      	movs	r2, #0
34181dfc:	601a      	str	r2, [r3, #0]
34181dfe:	605a      	str	r2, [r3, #4]
34181e00:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_ConfTypeDef pCSI_Config = {0};
34181e02:	f107 0310 	add.w	r3, r7, #16
34181e06:	2200      	movs	r2, #0
34181e08:	601a      	str	r2, [r3, #0]
34181e0a:	605a      	str	r2, [r3, #4]
34181e0c:	609a      	str	r2, [r3, #8]
  DCMIPP_PipeConfTypeDef pPipeConfig = {0};
34181e0e:	1d3b      	adds	r3, r7, #4
34181e10:	2200      	movs	r2, #0
34181e12:	601a      	str	r2, [r3, #0]
34181e14:	605a      	str	r2, [r3, #4]
34181e16:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN DCMIPP_Init 1 */

  /* USER CODE END DCMIPP_Init 1 */
  hdcmipp.Instance = DCMIPP;
34181e18:	4b48      	ldr	r3, [pc, #288]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e1a:	4a49      	ldr	r2, [pc, #292]	@ (34181f40 <MX_DCMIPP_Init+0x150>)
34181e1c:	601a      	str	r2, [r3, #0]
  if (HAL_DCMIPP_Init(&hdcmipp) != HAL_OK)
34181e1e:	4847      	ldr	r0, [pc, #284]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e20:	f004 fd1e 	bl	34186860 <HAL_DCMIPP_Init>
34181e24:	4603      	mov	r3, r0
34181e26:	2b00      	cmp	r3, #0
34181e28:	d001      	beq.n	34181e2e <MX_DCMIPP_Init+0x3e>
  {
    Error_Handler();
34181e2a:	f001 f899 	bl	34182f60 <Error_Handler>
  }

  /** Pipe 0 Config
  */
  pCSI_PipeConfig.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34181e2e:	2300      	movs	r3, #0
34181e30:	61fb      	str	r3, [r7, #28]
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV420_8;
34181e32:	2318      	movs	r3, #24
34181e34:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_YUV420_8;
34181e36:	2318      	movs	r3, #24
34181e38:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pCSI_PipeConfig) != HAL_OK)
34181e3a:	f107 031c 	add.w	r3, r7, #28
34181e3e:	461a      	mov	r2, r3
34181e40:	2100      	movs	r1, #0
34181e42:	483e      	ldr	r0, [pc, #248]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e44:	f004 fe9e 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181e48:	4603      	mov	r3, r0
34181e4a:	2b00      	cmp	r3, #0
34181e4c:	d001      	beq.n	34181e52 <MX_DCMIPP_Init+0x62>
  {
    Error_Handler();
34181e4e:	f001 f887 	bl	34182f60 <Error_Handler>
  }
  pCSI_Config.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
34181e52:	231c      	movs	r3, #28
34181e54:	61bb      	str	r3, [r7, #24]
  pCSI_Config.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34181e56:	2301      	movs	r3, #1
34181e58:	617b      	str	r3, [r7, #20]
  pCSI_Config.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
34181e5a:	f44f 7380 	mov.w	r3, #256	@ 0x100
34181e5e:	613b      	str	r3, [r7, #16]
  if (HAL_DCMIPP_CSI_SetConfig(&hdcmipp, &pCSI_Config) != HAL_OK)
34181e60:	f107 0310 	add.w	r3, r7, #16
34181e64:	4619      	mov	r1, r3
34181e66:	4835      	ldr	r0, [pc, #212]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e68:	f004 fd28 	bl	341868bc <HAL_DCMIPP_CSI_SetConfig>
34181e6c:	4603      	mov	r3, r0
34181e6e:	2b00      	cmp	r3, #0
34181e70:	d001      	beq.n	34181e76 <MX_DCMIPP_Init+0x86>
  {
    Error_Handler();
34181e72:	f001 f875 	bl	34182f60 <Error_Handler>
  }
  pPipeConfig.FrameRate = DCMIPP_FRAME_RATE_ALL;
34181e76:	2300      	movs	r3, #0
34181e78:	607b      	str	r3, [r7, #4]
  pPipeConfig.PixelPipePitch = 240;
34181e7a:	23f0      	movs	r3, #240	@ 0xf0
34181e7c:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34181e7e:	2300      	movs	r3, #0
34181e80:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE0, &pPipeConfig) != HAL_OK)
34181e82:	1d3b      	adds	r3, r7, #4
34181e84:	461a      	mov	r2, r3
34181e86:	2100      	movs	r1, #0
34181e88:	482c      	ldr	r0, [pc, #176]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e8a:	f004 ff5d 	bl	34186d48 <HAL_DCMIPP_PIPE_SetConfig>
34181e8e:	4603      	mov	r3, r0
34181e90:	2b00      	cmp	r3, #0
34181e92:	d001      	beq.n	34181e98 <MX_DCMIPP_Init+0xa8>
  {
    Error_Handler();
34181e94:	f001 f864 	bl	34182f60 <Error_Handler>
  }
  HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP8);
34181e98:	2202      	movs	r2, #2
34181e9a:	2100      	movs	r1, #0
34181e9c:	4827      	ldr	r0, [pc, #156]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181e9e:	f004 ff11 	bl	34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>

  /** Pipe 1 Config
  */
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_RGB565;
34181ea2:	2322      	movs	r3, #34	@ 0x22
34181ea4:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB565;
34181ea6:	2322      	movs	r3, #34	@ 0x22
34181ea8:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pCSI_PipeConfig) != HAL_OK)
34181eaa:	f107 031c 	add.w	r3, r7, #28
34181eae:	461a      	mov	r2, r3
34181eb0:	2101      	movs	r1, #1
34181eb2:	4822      	ldr	r0, [pc, #136]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181eb4:	f004 fe66 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181eb8:	4603      	mov	r3, r0
34181eba:	2b00      	cmp	r3, #0
34181ebc:	d001      	beq.n	34181ec2 <MX_DCMIPP_Init+0xd2>
  {
    Error_Handler();
34181ebe:	f001 f84f 	bl	34182f60 <Error_Handler>
  }
  pPipeConfig.PixelPipePitch = 480;
34181ec2:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
34181ec6:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34181ec8:	2301      	movs	r3, #1
34181eca:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pPipeConfig) != HAL_OK)
34181ecc:	1d3b      	adds	r3, r7, #4
34181ece:	461a      	mov	r2, r3
34181ed0:	2101      	movs	r1, #1
34181ed2:	481a      	ldr	r0, [pc, #104]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181ed4:	f004 ff38 	bl	34186d48 <HAL_DCMIPP_PIPE_SetConfig>
34181ed8:	4603      	mov	r3, r0
34181eda:	2b00      	cmp	r3, #0
34181edc:	d001      	beq.n	34181ee2 <MX_DCMIPP_Init+0xf2>
  {
    Error_Handler();
34181ede:	f001 f83f 	bl	34182f60 <Error_Handler>
  }
  if (HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP6) != HAL_OK)
34181ee2:	2200      	movs	r2, #0
34181ee4:	2100      	movs	r1, #0
34181ee6:	4815      	ldr	r0, [pc, #84]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181ee8:	f004 feec 	bl	34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>
34181eec:	4603      	mov	r3, r0
34181eee:	2b00      	cmp	r3, #0
34181ef0:	d001      	beq.n	34181ef6 <MX_DCMIPP_Init+0x106>
  {
    Error_Handler();
34181ef2:	f001 f835 	bl	34182f60 <Error_Handler>
  }

  /** Pipe 2 Config
  */
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV422_8;
34181ef6:	231e      	movs	r3, #30
34181ef8:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB888;
34181efa:	2324      	movs	r3, #36	@ 0x24
34181efc:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pCSI_PipeConfig) != HAL_OK)
34181efe:	f107 031c 	add.w	r3, r7, #28
34181f02:	461a      	mov	r2, r3
34181f04:	2102      	movs	r1, #2
34181f06:	480d      	ldr	r0, [pc, #52]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181f08:	f004 fe3c 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34181f0c:	4603      	mov	r3, r0
34181f0e:	2b00      	cmp	r3, #0
34181f10:	d001      	beq.n	34181f16 <MX_DCMIPP_Init+0x126>
  {
    Error_Handler();
34181f12:	f001 f825 	bl	34182f60 <Error_Handler>
  }
  pPipeConfig.PixelPipePitch = 10;
34181f16:	230a      	movs	r3, #10
34181f18:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34181f1a:	2300      	movs	r3, #0
34181f1c:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pPipeConfig) != HAL_OK)
34181f1e:	1d3b      	adds	r3, r7, #4
34181f20:	461a      	mov	r2, r3
34181f22:	2102      	movs	r1, #2
34181f24:	4805      	ldr	r0, [pc, #20]	@ (34181f3c <MX_DCMIPP_Init+0x14c>)
34181f26:	f004 ff0f 	bl	34186d48 <HAL_DCMIPP_PIPE_SetConfig>
34181f2a:	4603      	mov	r3, r0
34181f2c:	2b00      	cmp	r3, #0
34181f2e:	d001      	beq.n	34181f34 <MX_DCMIPP_Init+0x144>
  {
    Error_Handler();
34181f30:	f001 f816 	bl	34182f60 <Error_Handler>
  }
  /* USER CODE BEGIN DCMIPP_Init 2 */

  /* USER CODE END DCMIPP_Init 2 */

}
34181f34:	bf00      	nop
34181f36:	3728      	adds	r7, #40	@ 0x28
34181f38:	46bd      	mov	sp, r7
34181f3a:	bd80      	pop	{r7, pc}
34181f3c:	341c04f8 	.word	0x341c04f8
34181f40:	58002000 	.word	0x58002000

34181f44 <HAL_DCMIPP_MspInit>:

void HAL_DCMIPP_MspInit(DCMIPP_HandleTypeDef* dcmippHandle)
{
34181f44:	b580      	push	{r7, lr}
34181f46:	b0e6      	sub	sp, #408	@ 0x198
34181f48:	af00      	add	r7, sp, #0
34181f4a:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f4e:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34181f52:	6018      	str	r0, [r3, #0]

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34181f54:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f58:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181f5c:	4618      	mov	r0, r3
34181f5e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34181f62:	461a      	mov	r2, r3
34181f64:	2100      	movs	r1, #0
34181f66:	f023 fac3 	bl	341a54f0 <memset>
  if(dcmippHandle->Instance==DCMIPP)
34181f6a:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f6e:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34181f72:	681b      	ldr	r3, [r3, #0]
34181f74:	681b      	ldr	r3, [r3, #0]
34181f76:	4a2f      	ldr	r2, [pc, #188]	@ (34182034 <HAL_DCMIPP_MspInit+0xf0>)
34181f78:	4293      	cmp	r3, r2
34181f7a:	d155      	bne.n	34182028 <HAL_DCMIPP_MspInit+0xe4>

  /* USER CODE END DCMIPP_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP|RCC_PERIPHCLK_CSI;
34181f7c:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f80:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34181f84:	f04f 0218 	mov.w	r2, #24
34181f88:	f04f 0300 	mov.w	r3, #0
34181f8c:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34181f90:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181f94:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181f98:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34181f9c:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
    PeriphClkInitStruct.ICSelection[RCC_IC17].ClockSelection = RCC_ICCLKSOURCE_PLL3;
34181fa0:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181fa4:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181fa8:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34181fac:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    PeriphClkInitStruct.ICSelection[RCC_IC17].ClockDivider = 3;
34181fb0:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181fb4:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181fb8:	2203      	movs	r2, #3
34181fba:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL3;
34181fbe:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181fc2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181fc6:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34181fca:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockDivider = 60;
34181fce:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34181fd2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34181fd6:	223c      	movs	r2, #60	@ 0x3c
34181fd8:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34181fdc:	f107 0308 	add.w	r3, r7, #8
34181fe0:	4618      	mov	r0, r3
34181fe2:	f00d fccd 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
34181fe6:	4603      	mov	r3, r0
34181fe8:	2b00      	cmp	r3, #0
34181fea:	d001      	beq.n	34181ff0 <HAL_DCMIPP_MspInit+0xac>
    {
      Error_Handler();
34181fec:	f000 ffb8 	bl	34182f60 <Error_Handler>
    }

    /* DCMIPP clock enable */
    __HAL_RCC_DCMIPP_CLK_ENABLE();
34181ff0:	2004      	movs	r0, #4
34181ff2:	f7ff fec3 	bl	34181d7c <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_CLK_ENABLE();
34181ff6:	2040      	movs	r0, #64	@ 0x40
34181ff8:	f7ff fec0 	bl	34181d7c <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_FORCE_RESET();
34181ffc:	2040      	movs	r0, #64	@ 0x40
34181ffe:	f7ff fed3 	bl	34181da8 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_CSI_RELEASE_RESET();
34182002:	2040      	movs	r0, #64	@ 0x40
34182004:	f7ff fee0 	bl	34181dc8 <LL_APB5_GRP1_ReleaseReset>

    /* DCMIPP interrupt Init */
    HAL_NVIC_SetPriority(DCMIPP_IRQn, 0, 0);
34182008:	2200      	movs	r2, #0
3418200a:	2100      	movs	r1, #0
3418200c:	2030      	movs	r0, #48	@ 0x30
3418200e:	f004 fbf0 	bl	341867f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
34182012:	2030      	movs	r0, #48	@ 0x30
34182014:	f004 fc0a 	bl	3418682c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(CSI_IRQn, 0, 0);
34182018:	2200      	movs	r2, #0
3418201a:	2100      	movs	r1, #0
3418201c:	202f      	movs	r0, #47	@ 0x2f
3418201e:	f004 fbe8 	bl	341867f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CSI_IRQn);
34182022:	202f      	movs	r0, #47	@ 0x2f
34182024:	f004 fc02 	bl	3418682c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN DCMIPP_MspInit 1 */

  /* USER CODE END DCMIPP_MspInit 1 */
  }
}
34182028:	bf00      	nop
3418202a:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
3418202e:	46bd      	mov	sp, r7
34182030:	bd80      	pop	{r7, pc}
34182032:	bf00      	nop
34182034:	58002000 	.word	0x58002000

34182038 <MX_EXTMEM_MANAGER_Init>:
/**
  * Init External memory manager
  * @retval None
  */
void MX_EXTMEM_MANAGER_Init(void)
{
34182038:	b580      	push	{r7, lr}
3418203a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_EXTMEM_Init_PreTreatment */

  /* USER CODE END MX_EXTMEM_Init_PreTreatment */

  /* Initialization of the memory parameters */
  memset(extmem_list_config, 0x0, sizeof(extmem_list_config));
3418203c:	f44f 72ac 	mov.w	r2, #344	@ 0x158
34182040:	2100      	movs	r1, #0
34182042:	4830      	ldr	r0, [pc, #192]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182044:	f023 fa54 	bl	341a54f0 <memset>

  /* EXTMEMORY_1 */
  extmem_list_config[0].MemType = EXTMEM_NOR_SFDP;
34182048:	4b2e      	ldr	r3, [pc, #184]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418204a:	2200      	movs	r2, #0
3418204c:	701a      	strb	r2, [r3, #0]
  extmem_list_config[0].Handle = (void*)&hxspi2;
3418204e:	4b2d      	ldr	r3, [pc, #180]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182050:	4a2d      	ldr	r2, [pc, #180]	@ (34182108 <MX_EXTMEM_MANAGER_Init+0xd0>)
34182052:	605a      	str	r2, [r3, #4]
  extmem_list_config[0].ConfigType = EXTMEM_LINK_CONFIG_8LINES;
34182054:	4b2b      	ldr	r3, [pc, #172]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182056:	2203      	movs	r2, #3
34182058:	721a      	strb	r2, [r3, #8]

  /* EXTMEMORY_2 */
  extmem_list_config[1].MemType = EXTMEM_PSRAM;
3418205a:	4b2a      	ldr	r3, [pc, #168]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418205c:	2202      	movs	r2, #2
3418205e:	f883 20ac 	strb.w	r2, [r3, #172]	@ 0xac
  extmem_list_config[1].Handle = (void*)&hxspi1;
34182062:	4b28      	ldr	r3, [pc, #160]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182064:	4a29      	ldr	r2, [pc, #164]	@ (3418210c <MX_EXTMEM_MANAGER_Init+0xd4>)
34182066:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
  extmem_list_config[1].ConfigType = EXTMEM_LINK_CONFIG_1LINE;
3418206a:	4b26      	ldr	r3, [pc, #152]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418206c:	2200      	movs	r2, #0
3418206e:	f883 20b4 	strb.w	r2, [r3, #180]	@ 0xb4

  extmem_list_config[1].PsramObject.psram_public.MemorySize = HAL_XSPI_SIZE_256MB;
34182072:	4b24      	ldr	r3, [pc, #144]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182074:	2218      	movs	r2, #24
34182076:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  extmem_list_config[1].PsramObject.psram_public.FreqMax = 200 * 1000000u;
3418207a:	4b22      	ldr	r3, [pc, #136]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418207c:	4a24      	ldr	r2, [pc, #144]	@ (34182110 <MX_EXTMEM_MANAGER_Init+0xd8>)
3418207e:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  extmem_list_config[1].PsramObject.psram_public.NumberOfConfig = 0u;
34182082:	4b20      	ldr	r3, [pc, #128]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182084:	2200      	movs	r2, #0
34182086:	f883 2114 	strb.w	r2, [r3, #276]	@ 0x114

  /* Memory command configuration */
  extmem_list_config[1].PsramObject.psram_public.ReadREG           = 0x40u;
3418208a:	4b1e      	ldr	r3, [pc, #120]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418208c:	2240      	movs	r2, #64	@ 0x40
3418208e:	f883 211e 	strb.w	r2, [r3, #286]	@ 0x11e
  extmem_list_config[1].PsramObject.psram_public.WriteREG          = 0xC0u;
34182092:	4b1c      	ldr	r3, [pc, #112]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
34182094:	22c0      	movs	r2, #192	@ 0xc0
34182096:	f883 211f 	strb.w	r2, [r3, #287]	@ 0x11f
  extmem_list_config[1].PsramObject.psram_public.ReadREGSize       = 2u;
3418209a:	4b1a      	ldr	r3, [pc, #104]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
3418209c:	2202      	movs	r2, #2
3418209e:	f883 2120 	strb.w	r2, [r3, #288]	@ 0x120
  extmem_list_config[1].PsramObject.psram_public.REG_DummyCycle    = 4u;
341820a2:	4b18      	ldr	r3, [pc, #96]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820a4:	2204      	movs	r2, #4
341820a6:	f883 2121 	strb.w	r2, [r3, #289]	@ 0x121
  extmem_list_config[1].PsramObject.psram_public.Write_command     = 0xA0u;
341820aa:	4b16      	ldr	r3, [pc, #88]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820ac:	22a0      	movs	r2, #160	@ 0xa0
341820ae:	f883 2122 	strb.w	r2, [r3, #290]	@ 0x122
  extmem_list_config[1].PsramObject.psram_public.Write_DummyCycle  = 4u;
341820b2:	4b14      	ldr	r3, [pc, #80]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820b4:	2204      	movs	r2, #4
341820b6:	f883 2123 	strb.w	r2, [r3, #291]	@ 0x123
  extmem_list_config[1].PsramObject.psram_public.Read_command      = 0x20u;
341820ba:	4b12      	ldr	r3, [pc, #72]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820bc:	2220      	movs	r2, #32
341820be:	f883 2124 	strb.w	r2, [r3, #292]	@ 0x124
  extmem_list_config[1].PsramObject.psram_public.WrapRead_command  = 0x00u;
341820c2:	4b10      	ldr	r3, [pc, #64]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820c4:	2200      	movs	r2, #0
341820c6:	f883 2125 	strb.w	r2, [r3, #293]	@ 0x125
  extmem_list_config[1].PsramObject.psram_public.Read_DummyCycle   = 4u;
341820ca:	4b0e      	ldr	r3, [pc, #56]	@ (34182104 <MX_EXTMEM_MANAGER_Init+0xcc>)
341820cc:	2204      	movs	r2, #4
341820ce:	f883 2126 	strb.w	r2, [r3, #294]	@ 0x126

  EXTMEM_Init(EXTMEMORY_1, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI2));
341820d2:	f04f 0000 	mov.w	r0, #0
341820d6:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
341820da:	f00f ff35 	bl	34191f48 <HAL_RCCEx_GetPeriphCLKFreq>
341820de:	4603      	mov	r3, r0
341820e0:	4619      	mov	r1, r3
341820e2:	2000      	movs	r0, #0
341820e4:	f020 f9e8 	bl	341a24b8 <EXTMEM_Init>
  EXTMEM_Init(EXTMEMORY_2, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1));
341820e8:	f04f 0000 	mov.w	r0, #0
341820ec:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
341820f0:	f00f ff2a 	bl	34191f48 <HAL_RCCEx_GetPeriphCLKFreq>
341820f4:	4603      	mov	r3, r0
341820f6:	4619      	mov	r1, r3
341820f8:	2001      	movs	r0, #1
341820fa:	f020 f9dd 	bl	341a24b8 <EXTMEM_Init>

  /* USER CODE BEGIN MX_EXTMEM_Init_PostTreatment */

  /* USER CODE END MX_EXTMEM_Init_PostTreatment */
}
341820fe:	bf00      	nop
34182100:	bd80      	pop	{r7, pc}
34182102:	bf00      	nop
34182104:	341c1b84 	.word	0x341c1b84
34182108:	341c0630 	.word	0x341c0630
3418210c:	341c05cc 	.word	0x341c05cc
34182110:	0bebc200 	.word	0x0bebc200

34182114 <LL_AHB4_GRP1_EnableClock>:
{
34182114:	b480      	push	{r7}
34182116:	b085      	sub	sp, #20
34182118:	af00      	add	r7, sp, #0
3418211a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3418211c:	4a07      	ldr	r2, [pc, #28]	@ (3418213c <LL_AHB4_GRP1_EnableClock+0x28>)
3418211e:	687b      	ldr	r3, [r7, #4]
34182120:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34182124:	4b05      	ldr	r3, [pc, #20]	@ (3418213c <LL_AHB4_GRP1_EnableClock+0x28>)
34182126:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418212a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418212c:	68fb      	ldr	r3, [r7, #12]
}
3418212e:	bf00      	nop
34182130:	3714      	adds	r7, #20
34182132:	46bd      	mov	sp, r7
34182134:	f85d 7b04 	ldr.w	r7, [sp], #4
34182138:	4770      	bx	lr
3418213a:	bf00      	nop
3418213c:	56028000 	.word	0x56028000

34182140 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
34182140:	b580      	push	{r7, lr}
34182142:	b086      	sub	sp, #24
34182144:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34182146:	1d3b      	adds	r3, r7, #4
34182148:	2200      	movs	r2, #0
3418214a:	601a      	str	r2, [r3, #0]
3418214c:	605a      	str	r2, [r3, #4]
3418214e:	609a      	str	r2, [r3, #8]
34182150:	60da      	str	r2, [r3, #12]
34182152:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOQ_CLK_ENABLE();
34182154:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34182158:	f7ff ffdc 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOC_CLK_ENABLE();
3418215c:	2004      	movs	r0, #4
3418215e:	f7ff ffd9 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34182162:	2080      	movs	r0, #128	@ 0x80
34182164:	f7ff ffd6 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
34182168:	2002      	movs	r0, #2
3418216a:	f7ff ffd3 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOD_CLK_ENABLE();
3418216e:	2008      	movs	r0, #8
34182170:	f7ff ffd0 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
34182174:	2010      	movs	r0, #16
34182176:	f7ff ffcd 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOP_CLK_ENABLE();
3418217a:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418217e:	f7ff ffc9 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34182182:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34182186:	f7ff ffc5 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
3418218a:	2040      	movs	r0, #64	@ 0x40
3418218c:	f7ff ffc2 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
34182190:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34182194:	f7ff ffbe 	bl	34182114 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
34182198:	2001      	movs	r0, #1
3418219a:	f7ff ffbb 	bl	34182114 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOQ, LCD_BL_CTRL_Pin|LCD_ONOFF_Pin, GPIO_PIN_SET);
3418219e:	2201      	movs	r2, #1
341821a0:	2148      	movs	r1, #72	@ 0x48
341821a2:	483c      	ldr	r0, [pc, #240]	@ (34182294 <MX_GPIO_Init+0x154>)
341821a4:	f008 fabc 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(EN_CAM_GPIO_Port, EN_CAM_Pin, GPIO_PIN_RESET);
341821a8:	2200      	movs	r2, #0
341821aa:	2104      	movs	r1, #4
341821ac:	483a      	ldr	r0, [pc, #232]	@ (34182298 <MX_GPIO_Init+0x158>)
341821ae:	f008 fab7 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(NRST_CAM_GPIO_Port, NRST_CAM_Pin, GPIO_PIN_RESET);
341821b2:	2200      	movs	r2, #0
341821b4:	f44f 7180 	mov.w	r1, #256	@ 0x100
341821b8:	4838      	ldr	r0, [pc, #224]	@ (3418229c <MX_GPIO_Init+0x15c>)
341821ba:	f008 fab1 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_NRST_GPIO_Port, LCD_NRST_Pin, GPIO_PIN_SET);
341821be:	2201      	movs	r2, #1
341821c0:	2102      	movs	r1, #2
341821c2:	4837      	ldr	r0, [pc, #220]	@ (341822a0 <MX_GPIO_Init+0x160>)
341821c4:	f008 faac 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
341821c8:	2200      	movs	r2, #0
341821ca:	2102      	movs	r1, #2
341821cc:	4835      	ldr	r0, [pc, #212]	@ (341822a4 <MX_GPIO_Init+0x164>)
341821ce:	f008 faa7 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
341821d2:	2200      	movs	r2, #0
341821d4:	f44f 6180 	mov.w	r1, #1024	@ 0x400
341821d8:	4833      	ldr	r0, [pc, #204]	@ (341822a8 <MX_GPIO_Init+0x168>)
341821da:	f008 faa1 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_DE_GPIO_Port, LCD_DE_Pin, GPIO_PIN_SET);
341821de:	2201      	movs	r2, #1
341821e0:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
341821e4:	4830      	ldr	r0, [pc, #192]	@ (341822a8 <MX_GPIO_Init+0x168>)
341821e6:	f008 fa9b 	bl	3418a720 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LCD_BL_CTRL_Pin LCD_ONOFF_Pin */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin|LCD_ONOFF_Pin;
341821ea:	2348      	movs	r3, #72	@ 0x48
341821ec:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
341821ee:	2301      	movs	r3, #1
341821f0:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
341821f2:	2300      	movs	r3, #0
341821f4:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
341821f6:	2302      	movs	r3, #2
341821f8:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOQ, &GPIO_InitStruct);
341821fa:	1d3b      	adds	r3, r7, #4
341821fc:	4619      	mov	r1, r3
341821fe:	4825      	ldr	r0, [pc, #148]	@ (34182294 <MX_GPIO_Init+0x154>)
34182200:	f007 ff9c 	bl	3418a13c <HAL_GPIO_Init>

  /*Configure GPIO pin : EN_CAM_Pin */
  GPIO_InitStruct.Pin = EN_CAM_Pin;
34182204:	2304      	movs	r3, #4
34182206:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182208:	2301      	movs	r3, #1
3418220a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
3418220c:	2300      	movs	r3, #0
3418220e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
34182210:	2302      	movs	r3, #2
34182212:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(EN_CAM_GPIO_Port, &GPIO_InitStruct);
34182214:	1d3b      	adds	r3, r7, #4
34182216:	4619      	mov	r1, r3
34182218:	481f      	ldr	r0, [pc, #124]	@ (34182298 <MX_GPIO_Init+0x158>)
3418221a:	f007 ff8f 	bl	3418a13c <HAL_GPIO_Init>

  /*Configure GPIO pin : NRST_CAM_Pin */
  GPIO_InitStruct.Pin = NRST_CAM_Pin;
3418221e:	f44f 7380 	mov.w	r3, #256	@ 0x100
34182222:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182224:	2301      	movs	r3, #1
34182226:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34182228:	2300      	movs	r3, #0
3418222a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
3418222c:	2302      	movs	r3, #2
3418222e:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(NRST_CAM_GPIO_Port, &GPIO_InitStruct);
34182230:	1d3b      	adds	r3, r7, #4
34182232:	4619      	mov	r1, r3
34182234:	4819      	ldr	r0, [pc, #100]	@ (3418229c <MX_GPIO_Init+0x15c>)
34182236:	f007 ff81 	bl	3418a13c <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_NRST_Pin */
  GPIO_InitStruct.Pin = LCD_NRST_Pin;
3418223a:	2302      	movs	r3, #2
3418223c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
3418223e:	2301      	movs	r3, #1
34182240:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34182242:	2300      	movs	r3, #0
34182244:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
34182246:	2302      	movs	r3, #2
34182248:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LCD_NRST_GPIO_Port, &GPIO_InitStruct);
3418224a:	1d3b      	adds	r3, r7, #4
3418224c:	4619      	mov	r1, r3
3418224e:	4814      	ldr	r0, [pc, #80]	@ (341822a0 <MX_GPIO_Init+0x160>)
34182250:	f007 ff74 	bl	3418a13c <HAL_GPIO_Init>

  /*Configure GPIO pin : LED1_Pin */
  GPIO_InitStruct.Pin = LED1_Pin;
34182254:	2302      	movs	r3, #2
34182256:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182258:	2301      	movs	r3, #1
3418225a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
3418225c:	2300      	movs	r3, #0
3418225e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182260:	2300      	movs	r3, #0
34182262:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
34182264:	1d3b      	adds	r3, r7, #4
34182266:	4619      	mov	r1, r3
34182268:	480e      	ldr	r0, [pc, #56]	@ (341822a4 <MX_GPIO_Init+0x164>)
3418226a:	f007 ff67 	bl	3418a13c <HAL_GPIO_Init>

  /*Configure GPIO pins : LED2_Pin LCD_DE_Pin */
  GPIO_InitStruct.Pin = LED2_Pin|LCD_DE_Pin;
3418226e:	f44f 5310 	mov.w	r3, #9216	@ 0x2400
34182272:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34182274:	2301      	movs	r3, #1
34182276:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34182278:	2300      	movs	r3, #0
3418227a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
3418227c:	2300      	movs	r3, #0
3418227e:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34182280:	1d3b      	adds	r3, r7, #4
34182282:	4619      	mov	r1, r3
34182284:	4808      	ldr	r0, [pc, #32]	@ (341822a8 <MX_GPIO_Init+0x168>)
34182286:	f007 ff59 	bl	3418a13c <HAL_GPIO_Init>

}
3418228a:	bf00      	nop
3418228c:	3718      	adds	r7, #24
3418228e:	46bd      	mov	sp, r7
34182290:	bd80      	pop	{r7, pc}
34182292:	bf00      	nop
34182294:	56024000 	.word	0x56024000
34182298:	56020c00 	.word	0x56020c00
3418229c:	56020800 	.word	0x56020800
341822a0:	56021000 	.word	0x56021000
341822a4:	56023800 	.word	0x56023800
341822a8:	56021800 	.word	0x56021800

341822ac <LL_AHB4_GRP1_EnableClock>:
{
341822ac:	b480      	push	{r7}
341822ae:	b085      	sub	sp, #20
341822b0:	af00      	add	r7, sp, #0
341822b2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341822b4:	4a07      	ldr	r2, [pc, #28]	@ (341822d4 <LL_AHB4_GRP1_EnableClock+0x28>)
341822b6:	687b      	ldr	r3, [r7, #4]
341822b8:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341822bc:	4b05      	ldr	r3, [pc, #20]	@ (341822d4 <LL_AHB4_GRP1_EnableClock+0x28>)
341822be:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341822c2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341822c4:	68fb      	ldr	r3, [r7, #12]
}
341822c6:	bf00      	nop
341822c8:	3714      	adds	r7, #20
341822ca:	46bd      	mov	sp, r7
341822cc:	f85d 7b04 	ldr.w	r7, [sp], #4
341822d0:	4770      	bx	lr
341822d2:	bf00      	nop
341822d4:	56028000 	.word	0x56028000

341822d8 <LL_APB1_GRP1_EnableClock>:
{
341822d8:	b480      	push	{r7}
341822da:	b085      	sub	sp, #20
341822dc:	af00      	add	r7, sp, #0
341822de:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
341822e0:	4a07      	ldr	r2, [pc, #28]	@ (34182300 <LL_APB1_GRP1_EnableClock+0x28>)
341822e2:	687b      	ldr	r3, [r7, #4]
341822e4:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
341822e8:	4b05      	ldr	r3, [pc, #20]	@ (34182300 <LL_APB1_GRP1_EnableClock+0x28>)
341822ea:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
341822ee:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341822f0:	68fb      	ldr	r3, [r7, #12]
}
341822f2:	bf00      	nop
341822f4:	3714      	adds	r7, #20
341822f6:	46bd      	mov	sp, r7
341822f8:	f85d 7b04 	ldr.w	r7, [sp], #4
341822fc:	4770      	bx	lr
341822fe:	bf00      	nop
34182300:	56028000 	.word	0x56028000

34182304 <LL_APB1_GRP1_DisableClock>:
{
34182304:	b480      	push	{r7}
34182306:	b083      	sub	sp, #12
34182308:	af00      	add	r7, sp, #0
3418230a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
3418230c:	4b06      	ldr	r3, [pc, #24]	@ (34182328 <LL_APB1_GRP1_DisableClock+0x24>)
3418230e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34182312:	461a      	mov	r2, r3
34182314:	687b      	ldr	r3, [r7, #4]
34182316:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
3418231a:	bf00      	nop
3418231c:	370c      	adds	r7, #12
3418231e:	46bd      	mov	sp, r7
34182320:	f85d 7b04 	ldr.w	r7, [sp], #4
34182324:	4770      	bx	lr
34182326:	bf00      	nop
34182328:	56028000 	.word	0x56028000

3418232c <HAL_I2C_MspInit>:
  /* USER CODE END I2C1_Init 2 */

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
3418232c:	b580      	push	{r7, lr}
3418232e:	b0ec      	sub	sp, #432	@ 0x1b0
34182330:	af00      	add	r7, sp, #0
34182332:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182336:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3418233a:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
3418233c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182340:	2200      	movs	r2, #0
34182342:	601a      	str	r2, [r3, #0]
34182344:	605a      	str	r2, [r3, #4]
34182346:	609a      	str	r2, [r3, #8]
34182348:	60da      	str	r2, [r3, #12]
3418234a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
3418234c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182350:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182354:	4618      	mov	r0, r3
34182356:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3418235a:	461a      	mov	r2, r3
3418235c:	2100      	movs	r1, #0
3418235e:	f023 f8c7 	bl	341a54f0 <memset>
  if(i2cHandle->Instance==I2C1)
34182362:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182366:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3418236a:	681b      	ldr	r3, [r3, #0]
3418236c:	681b      	ldr	r3, [r3, #0]
3418236e:	4a2c      	ldr	r2, [pc, #176]	@ (34182420 <HAL_I2C_MspInit+0xf4>)
34182370:	4293      	cmp	r3, r2
34182372:	d14f      	bne.n	34182414 <HAL_I2C_MspInit+0xe8>

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
34182374:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182378:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
3418237c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34182380:	f04f 0300 	mov.w	r3, #0
34182384:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
34182388:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418238c:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34182390:	4a24      	ldr	r2, [pc, #144]	@ (34182424 <HAL_I2C_MspInit+0xf8>)
34182392:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34182396:	f107 0308 	add.w	r3, r7, #8
3418239a:	4618      	mov	r0, r3
3418239c:	f00d faf0 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
341823a0:	4603      	mov	r3, r0
341823a2:	2b00      	cmp	r3, #0
341823a4:	d001      	beq.n	341823aa <HAL_I2C_MspInit+0x7e>
    {
      Error_Handler();
341823a6:	f000 fddb 	bl	34182f60 <Error_Handler>
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
341823aa:	2004      	movs	r0, #4
341823ac:	f7ff ff7e 	bl	341822ac <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
341823b0:	2080      	movs	r0, #128	@ 0x80
341823b2:	f7ff ff7b 	bl	341822ac <LL_AHB4_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1;
341823b6:	2302      	movs	r3, #2
341823b8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
341823bc:	2312      	movs	r3, #18
341823be:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341823c2:	2300      	movs	r3, #0
341823c4:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341823c8:	2300      	movs	r3, #0
341823ca:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
341823ce:	2304      	movs	r3, #4
341823d0:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
341823d4:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341823d8:	4619      	mov	r1, r3
341823da:	4813      	ldr	r0, [pc, #76]	@ (34182428 <HAL_I2C_MspInit+0xfc>)
341823dc:	f007 feae 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
341823e0:	f44f 7300 	mov.w	r3, #512	@ 0x200
341823e4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
341823e8:	2312      	movs	r3, #18
341823ea:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341823ee:	2300      	movs	r3, #0
341823f0:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341823f4:	2300      	movs	r3, #0
341823f6:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
341823fa:	2304      	movs	r3, #4
341823fc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
34182400:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182404:	4619      	mov	r1, r3
34182406:	4809      	ldr	r0, [pc, #36]	@ (3418242c <HAL_I2C_MspInit+0x100>)
34182408:	f007 fe98 	bl	3418a13c <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
3418240c:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34182410:	f7ff ff62 	bl	341822d8 <LL_APB1_GRP1_EnableClock>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
34182414:	bf00      	nop
34182416:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
3418241a:	46bd      	mov	sp, r7
3418241c:	bd80      	pop	{r7, pc}
3418241e:	bf00      	nop
34182420:	50005400 	.word	0x50005400
34182424:	0700000c 	.word	0x0700000c
34182428:	56020800 	.word	0x56020800
3418242c:	56021c00 	.word	0x56021c00

34182430 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
34182430:	b580      	push	{r7, lr}
34182432:	b082      	sub	sp, #8
34182434:	af00      	add	r7, sp, #0
34182436:	6078      	str	r0, [r7, #4]

  if(i2cHandle->Instance==I2C1)
34182438:	687b      	ldr	r3, [r7, #4]
3418243a:	681b      	ldr	r3, [r3, #0]
3418243c:	4a09      	ldr	r2, [pc, #36]	@ (34182464 <HAL_I2C_MspDeInit+0x34>)
3418243e:	4293      	cmp	r3, r2
34182440:	d10c      	bne.n	3418245c <HAL_I2C_MspDeInit+0x2c>
  {
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();
34182442:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34182446:	f7ff ff5d 	bl	34182304 <LL_APB1_GRP1_DisableClock>

    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_1);
3418244a:	2102      	movs	r1, #2
3418244c:	4806      	ldr	r0, [pc, #24]	@ (34182468 <HAL_I2C_MspDeInit+0x38>)
3418244e:	f008 f827 	bl	3418a4a0 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOH, GPIO_PIN_9);
34182452:	f44f 7100 	mov.w	r1, #512	@ 0x200
34182456:	4805      	ldr	r0, [pc, #20]	@ (3418246c <HAL_I2C_MspDeInit+0x3c>)
34182458:	f008 f822 	bl	3418a4a0 <HAL_GPIO_DeInit>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
}
3418245c:	bf00      	nop
3418245e:	3708      	adds	r7, #8
34182460:	46bd      	mov	sp, r7
34182462:	bd80      	pop	{r7, pc}
34182464:	50005400 	.word	0x50005400
34182468:	56020800 	.word	0x56020800
3418246c:	56021c00 	.word	0x56021c00

34182470 <LL_AHB4_GRP1_EnableClock>:
{
34182470:	b480      	push	{r7}
34182472:	b085      	sub	sp, #20
34182474:	af00      	add	r7, sp, #0
34182476:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34182478:	4a07      	ldr	r2, [pc, #28]	@ (34182498 <LL_AHB4_GRP1_EnableClock+0x28>)
3418247a:	687b      	ldr	r3, [r7, #4]
3418247c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34182480:	4b05      	ldr	r3, [pc, #20]	@ (34182498 <LL_AHB4_GRP1_EnableClock+0x28>)
34182482:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34182486:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34182488:	68fb      	ldr	r3, [r7, #12]
}
3418248a:	bf00      	nop
3418248c:	3714      	adds	r7, #20
3418248e:	46bd      	mov	sp, r7
34182490:	f85d 7b04 	ldr.w	r7, [sp], #4
34182494:	4770      	bx	lr
34182496:	bf00      	nop
34182498:	56028000 	.word	0x56028000

3418249c <LL_APB5_GRP1_EnableClock>:
{
3418249c:	b480      	push	{r7}
3418249e:	b085      	sub	sp, #20
341824a0:	af00      	add	r7, sp, #0
341824a2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
341824a4:	4a07      	ldr	r2, [pc, #28]	@ (341824c4 <LL_APB5_GRP1_EnableClock+0x28>)
341824a6:	687b      	ldr	r3, [r7, #4]
341824a8:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
341824ac:	4b05      	ldr	r3, [pc, #20]	@ (341824c4 <LL_APB5_GRP1_EnableClock+0x28>)
341824ae:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
341824b2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341824b4:	68fb      	ldr	r3, [r7, #12]
}
341824b6:	bf00      	nop
341824b8:	3714      	adds	r7, #20
341824ba:	46bd      	mov	sp, r7
341824bc:	f85d 7b04 	ldr.w	r7, [sp], #4
341824c0:	4770      	bx	lr
341824c2:	bf00      	nop
341824c4:	56028000 	.word	0x56028000

341824c8 <MX_LTDC_Init_CubeMX>:

LTDC_HandleTypeDef hltdc;

/* LTDC init function */
void MX_LTDC_Init_CubeMX(void)
{
341824c8:	b580      	push	{r7, lr}
341824ca:	b09c      	sub	sp, #112	@ 0x70
341824cc:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
341824ce:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
341824d2:	2234      	movs	r2, #52	@ 0x34
341824d4:	2100      	movs	r1, #0
341824d6:	4618      	mov	r0, r3
341824d8:	f023 f80a 	bl	341a54f0 <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
341824dc:	f107 0308 	add.w	r3, r7, #8
341824e0:	2234      	movs	r2, #52	@ 0x34
341824e2:	2100      	movs	r1, #0
341824e4:	4618      	mov	r0, r3
341824e6:	f023 f803 	bl	341a54f0 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
341824ea:	4b58      	ldr	r3, [pc, #352]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
341824ec:	4a58      	ldr	r2, [pc, #352]	@ (34182650 <MX_LTDC_Init_CubeMX+0x188>)
341824ee:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
341824f0:	4b56      	ldr	r3, [pc, #344]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
341824f2:	2200      	movs	r2, #0
341824f4:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
341824f6:	4b55      	ldr	r3, [pc, #340]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
341824f8:	2200      	movs	r2, #0
341824fa:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
341824fc:	4b53      	ldr	r3, [pc, #332]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
341824fe:	2200      	movs	r2, #0
34182500:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34182502:	4b52      	ldr	r3, [pc, #328]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182504:	2200      	movs	r2, #0
34182506:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 4;
34182508:	4b50      	ldr	r3, [pc, #320]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418250a:	2204      	movs	r2, #4
3418250c:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 4;
3418250e:	4b4f      	ldr	r3, [pc, #316]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182510:	2204      	movs	r2, #4
34182512:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 12;
34182514:	4b4d      	ldr	r3, [pc, #308]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182516:	220c      	movs	r2, #12
34182518:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 12;
3418251a:	4b4c      	ldr	r3, [pc, #304]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418251c:	220c      	movs	r2, #12
3418251e:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 812;
34182520:	4b4a      	ldr	r3, [pc, #296]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182522:	f44f 724b 	mov.w	r2, #812	@ 0x32c
34182526:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc.Init.AccumulatedActiveH = 492;
34182528:	4b48      	ldr	r3, [pc, #288]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418252a:	f44f 72f6 	mov.w	r2, #492	@ 0x1ec
3418252e:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc.Init.TotalWidth = 820;
34182530:	4b46      	ldr	r3, [pc, #280]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182532:	f44f 724d 	mov.w	r2, #820	@ 0x334
34182536:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc.Init.TotalHeigh = 500;
34182538:	4b44      	ldr	r3, [pc, #272]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418253a:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3418253e:	631a      	str	r2, [r3, #48]	@ 0x30
  hltdc.Init.Backcolor.Blue = 0;
34182540:	4b42      	ldr	r3, [pc, #264]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182542:	2200      	movs	r2, #0
34182544:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc.Init.Backcolor.Green = 0;
34182548:	4b40      	ldr	r3, [pc, #256]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418254a:	2200      	movs	r2, #0
3418254c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc.Init.Backcolor.Red = 0;
34182550:	4b3e      	ldr	r3, [pc, #248]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182552:	2200      	movs	r2, #0
34182554:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
34182558:	483c      	ldr	r0, [pc, #240]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
3418255a:	f008 ffac 	bl	3418b4b6 <HAL_LTDC_Init>
3418255e:	4603      	mov	r3, r0
34182560:	2b00      	cmp	r3, #0
34182562:	d001      	beq.n	34182568 <MX_LTDC_Init_CubeMX+0xa0>
  {
    Error_Handler();
34182564:	f000 fcfc 	bl	34182f60 <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
34182568:	2300      	movs	r3, #0
3418256a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.WindowX1 = 100;
3418256c:	2364      	movs	r3, #100	@ 0x64
3418256e:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.WindowY0 = 0;
34182570:	2300      	movs	r3, #0
34182572:	647b      	str	r3, [r7, #68]	@ 0x44
  pLayerCfg.WindowY1 = 100;
34182574:	2364      	movs	r3, #100	@ 0x64
34182576:	64bb      	str	r3, [r7, #72]	@ 0x48
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34182578:	2304      	movs	r3, #4
3418257a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  pLayerCfg.Alpha = 255;
3418257c:	23ff      	movs	r3, #255	@ 0xff
3418257e:	653b      	str	r3, [r7, #80]	@ 0x50
  pLayerCfg.Alpha0 = 128;
34182580:	2380      	movs	r3, #128	@ 0x80
34182582:	657b      	str	r3, [r7, #84]	@ 0x54
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
34182584:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34182588:	65bb      	str	r3, [r7, #88]	@ 0x58
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
3418258a:	2305      	movs	r3, #5
3418258c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  pLayerCfg.FBStartAdress = 0;
3418258e:	2300      	movs	r3, #0
34182590:	663b      	str	r3, [r7, #96]	@ 0x60
  pLayerCfg.ImageWidth = 100;
34182592:	2364      	movs	r3, #100	@ 0x64
34182594:	667b      	str	r3, [r7, #100]	@ 0x64
  pLayerCfg.ImageHeight = 100;
34182596:	2364      	movs	r3, #100	@ 0x64
34182598:	66bb      	str	r3, [r7, #104]	@ 0x68
  pLayerCfg.Backcolor.Blue = 0;
3418259a:	2300      	movs	r3, #0
3418259c:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
  pLayerCfg.Backcolor.Green = 255;
341825a0:	23ff      	movs	r3, #255	@ 0xff
341825a2:	f887 306d 	strb.w	r3, [r7, #109]	@ 0x6d
  pLayerCfg.Backcolor.Red = 0;
341825a6:	2300      	movs	r3, #0
341825a8:	f887 306e 	strb.w	r3, [r7, #110]	@ 0x6e
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
341825ac:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
341825b0:	2200      	movs	r2, #0
341825b2:	4619      	mov	r1, r3
341825b4:	4825      	ldr	r0, [pc, #148]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
341825b6:	f009 f829 	bl	3418b60c <HAL_LTDC_ConfigLayer>
341825ba:	4603      	mov	r3, r0
341825bc:	2b00      	cmp	r3, #0
341825be:	d001      	beq.n	341825c4 <MX_LTDC_Init_CubeMX+0xfc>
  {
    Error_Handler();
341825c0:	f000 fcce 	bl	34182f60 <Error_Handler>
  }
  pLayerCfg1.WindowX0 = 0;
341825c4:	2300      	movs	r3, #0
341825c6:	60bb      	str	r3, [r7, #8]
  pLayerCfg1.WindowX1 = 50;
341825c8:	2332      	movs	r3, #50	@ 0x32
341825ca:	60fb      	str	r3, [r7, #12]
  pLayerCfg1.WindowY0 = 0;
341825cc:	2300      	movs	r3, #0
341825ce:	613b      	str	r3, [r7, #16]
  pLayerCfg1.WindowY1 = 200;
341825d0:	23c8      	movs	r3, #200	@ 0xc8
341825d2:	617b      	str	r3, [r7, #20]
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
341825d4:	2308      	movs	r3, #8
341825d6:	61bb      	str	r3, [r7, #24]
  pLayerCfg1.Alpha = 255;
341825d8:	23ff      	movs	r3, #255	@ 0xff
341825da:	61fb      	str	r3, [r7, #28]
  pLayerCfg1.Alpha0 = 0;
341825dc:	2300      	movs	r3, #0
341825de:	623b      	str	r3, [r7, #32]
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
341825e0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341825e4:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
341825e6:	2305      	movs	r3, #5
341825e8:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg1.FBStartAdress = 0;
341825ea:	2300      	movs	r3, #0
341825ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg1.ImageWidth = 50;
341825ee:	2332      	movs	r3, #50	@ 0x32
341825f0:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg1.ImageHeight = 200;
341825f2:	23c8      	movs	r3, #200	@ 0xc8
341825f4:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg1.Backcolor.Blue = 0;
341825f6:	2300      	movs	r3, #0
341825f8:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  pLayerCfg1.Backcolor.Green = 255;
341825fc:	23ff      	movs	r3, #255	@ 0xff
341825fe:	f887 3039 	strb.w	r3, [r7, #57]	@ 0x39
  pLayerCfg1.Backcolor.Red = 0;
34182602:	2300      	movs	r3, #0
34182604:	f887 303a 	strb.w	r3, [r7, #58]	@ 0x3a
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
34182608:	f107 0308 	add.w	r3, r7, #8
3418260c:	2201      	movs	r2, #1
3418260e:	4619      	mov	r1, r3
34182610:	480e      	ldr	r0, [pc, #56]	@ (3418264c <MX_LTDC_Init_CubeMX+0x184>)
34182612:	f008 fffb 	bl	3418b60c <HAL_LTDC_ConfigLayer>
34182616:	4603      	mov	r3, r0
34182618:	2b00      	cmp	r3, #0
3418261a:	d001      	beq.n	34182620 <MX_LTDC_Init_CubeMX+0x158>
  {
    Error_Handler();
3418261c:	f000 fca0 	bl	34182f60 <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */
  RIMC_MasterConfig_t RIMC_master = {0};
34182620:	463b      	mov	r3, r7
34182622:	2200      	movs	r2, #0
34182624:	601a      	str	r2, [r3, #0]
34182626:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34182628:	2302      	movs	r3, #2
3418262a:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
3418262c:	2303      	movs	r3, #3
3418262e:	607b      	str	r3, [r7, #4]
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34182630:	463b      	mov	r3, r7
34182632:	4619      	mov	r1, r3
34182634:	200a      	movs	r0, #10
34182636:	f013 fe4f 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
3418263a:	2103      	movs	r1, #3
3418263c:	4805      	ldr	r0, [pc, #20]	@ (34182654 <MX_LTDC_Init_CubeMX+0x18c>)
3418263e:	f013 fe87 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  /* USER CODE END LTDC_Init 2 */

}
34182642:	bf00      	nop
34182644:	3770      	adds	r7, #112	@ 0x70
34182646:	46bd      	mov	sp, r7
34182648:	bd80      	pop	{r7, pc}
3418264a:	bf00      	nop
3418264c:	341c0504 	.word	0x341c0504
34182650:	58001000 	.word	0x58001000
34182654:	30000007 	.word	0x30000007

34182658 <MX_LTDC_Init>:
HAL_StatusTypeDef MX_LTDC_Init(LTDC_HandleTypeDef *hltdc, uint32_t Width, uint32_t Height)
{
34182658:	b580      	push	{r7, lr}
3418265a:	b084      	sub	sp, #16
3418265c:	af00      	add	r7, sp, #0
3418265e:	60f8      	str	r0, [r7, #12]
34182660:	60b9      	str	r1, [r7, #8]
34182662:	607a      	str	r2, [r7, #4]
  (void)hltdc;
  (void)Width;
  (void)Height;
  MX_LTDC_Init_CubeMX();
34182664:	f7ff ff30 	bl	341824c8 <MX_LTDC_Init_CubeMX>
  return HAL_OK;
34182668:	2300      	movs	r3, #0
}void HAL_LTDC_MspInit(LTDC_HandleTypeDef* ltdcHandle)
3418266a:	4618      	mov	r0, r3
3418266c:	3710      	adds	r7, #16
3418266e:	46bd      	mov	sp, r7
34182670:	bd80      	pop	{r7, pc}
	...

34182674 <HAL_LTDC_MspInit>:
{
34182674:	b580      	push	{r7, lr}
34182676:	b0ec      	sub	sp, #432	@ 0x1b0
34182678:	af00      	add	r7, sp, #0
3418267a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3418267e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34182682:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34182684:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182688:	2200      	movs	r2, #0
3418268a:	601a      	str	r2, [r3, #0]
3418268c:	605a      	str	r2, [r3, #4]
3418268e:	609a      	str	r2, [r3, #8]
34182690:	60da      	str	r2, [r3, #12]
34182692:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34182694:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34182698:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3418269c:	4618      	mov	r0, r3
3418269e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
341826a2:	461a      	mov	r2, r3
341826a4:	2100      	movs	r1, #0
341826a6:	f022 ff23 	bl	341a54f0 <memset>
  if(ltdcHandle->Instance==LTDC)
341826aa:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826ae:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
341826b2:	681b      	ldr	r3, [r3, #0]
341826b4:	681b      	ldr	r3, [r3, #0]
341826b6:	4a7c      	ldr	r2, [pc, #496]	@ (341828a8 <HAL_LTDC_MspInit+0x234>)
341826b8:	4293      	cmp	r3, r2
341826ba:	f040 80f0 	bne.w	3418289e <HAL_LTDC_MspInit+0x22a>

  /* USER CODE END LTDC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
341826be:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826c2:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
341826c6:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
341826ca:	f04f 0300 	mov.w	r3, #0
341826ce:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
341826d2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826d6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341826da:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
341826de:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL4;
341826e2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826e6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341826ea:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
341826ee:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
341826f2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341826f6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341826fa:	2202      	movs	r2, #2
341826fc:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34182700:	f107 0308 	add.w	r3, r7, #8
34182704:	4618      	mov	r0, r3
34182706:	f00d f93b 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
3418270a:	4603      	mov	r3, r0
3418270c:	2b00      	cmp	r3, #0
3418270e:	d001      	beq.n	34182714 <HAL_LTDC_MspInit+0xa0>
    {
      Error_Handler();
34182710:	f000 fc26 	bl	34182f60 <Error_Handler>
    }

    /* LTDC clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
34182714:	2002      	movs	r0, #2
34182716:	f7ff fec1 	bl	3418249c <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_GPIOC_CLK_ENABLE();
3418271a:	2004      	movs	r0, #4
3418271c:	f7ff fea8 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34182720:	2080      	movs	r0, #128	@ 0x80
34182722:	f7ff fea5 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
34182726:	2002      	movs	r0, #2
34182728:	f7ff fea2 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
3418272c:	2008      	movs	r0, #8
3418272e:	f7ff fe9f 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
34182732:	2010      	movs	r0, #16
34182734:	f7ff fe9c 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
34182738:	2040      	movs	r0, #64	@ 0x40
3418273a:	f7ff fe99 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
3418273e:	2001      	movs	r0, #1
34182740:	f7ff fe96 	bl	34182470 <LL_AHB4_GRP1_EnableClock>
    PB4(NJTRST)     ------> LTDC_R3
    PG8     ------> LTDC_G7
    PA8     ------> LTDC_B6
    PA0     ------> LTDC_G3
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_0;
34182744:	2311      	movs	r3, #17
34182746:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418274a:	2302      	movs	r3, #2
3418274c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182750:	2300      	movs	r3, #0
34182752:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182756:	2300      	movs	r3, #0
34182758:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3418275c:	230e      	movs	r3, #14
3418275e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
34182762:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182766:	4619      	mov	r1, r3
34182768:	4850      	ldr	r0, [pc, #320]	@ (341828ac <HAL_LTDC_MspInit+0x238>)
3418276a:	f007 fce7 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_6;
3418276e:	2348      	movs	r3, #72	@ 0x48
34182770:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34182774:	2302      	movs	r3, #2
34182776:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418277a:	2300      	movs	r3, #0
3418277c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182780:	2300      	movs	r3, #0
34182782:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34182786:	230e      	movs	r3, #14
34182788:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
3418278c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182790:	4619      	mov	r1, r3
34182792:	4847      	ldr	r0, [pc, #284]	@ (341828b0 <HAL_LTDC_MspInit+0x23c>)
34182794:	f007 fcd2 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_15|GPIO_PIN_11
34182798:	f64f 0310 	movw	r3, #63504	@ 0xf810
3418279c:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_12|GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827a0:	2302      	movs	r3, #2
341827a2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341827a6:	2300      	movs	r3, #0
341827a8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341827ac:	2300      	movs	r3, #0
341827ae:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
341827b2:	230e      	movs	r3, #14
341827b4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
341827b8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341827bc:	4619      	mov	r1, r3
341827be:	483d      	ldr	r0, [pc, #244]	@ (341828b4 <HAL_LTDC_MspInit+0x240>)
341827c0:	f007 fcbc 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_8;
341827c4:	f44f 5304 	mov.w	r3, #8448	@ 0x2100
341827c8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827cc:	2302      	movs	r3, #2
341827ce:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341827d2:	2300      	movs	r3, #0
341827d4:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
341827d8:	2300      	movs	r3, #0
341827da:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
341827de:	230e      	movs	r3, #14
341827e0:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
341827e4:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
341827e8:	4619      	mov	r1, r3
341827ea:	4833      	ldr	r0, [pc, #204]	@ (341828b8 <HAL_LTDC_MspInit+0x244>)
341827ec:	f007 fca6 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
341827f0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341827f4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
341827f8:	2302      	movs	r3, #2
341827fa:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
341827fe:	2300      	movs	r3, #0
34182800:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182804:	2300      	movs	r3, #0
34182806:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3418280a:	230e      	movs	r3, #14
3418280c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34182810:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182814:	4619      	mov	r1, r3
34182816:	4829      	ldr	r0, [pc, #164]	@ (341828bc <HAL_LTDC_MspInit+0x248>)
34182818:	f007 fc90 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_8;
3418281c:	f44f 73a0 	mov.w	r3, #320	@ 0x140
34182820:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34182824:	2302      	movs	r3, #2
34182826:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418282a:	2300      	movs	r3, #0
3418282c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182830:	2300      	movs	r3, #0
34182832:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34182836:	230e      	movs	r3, #14
34182838:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
3418283c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182840:	4619      	mov	r1, r3
34182842:	481f      	ldr	r0, [pc, #124]	@ (341828c0 <HAL_LTDC_MspInit+0x24c>)
34182844:	f007 fc7a 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
34182848:	2340      	movs	r3, #64	@ 0x40
3418284a:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418284e:	2302      	movs	r3, #2
34182850:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182854:	2300      	movs	r3, #0
34182856:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
3418285a:	2300      	movs	r3, #0
3418285c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF12_LCD;
34182860:	230c      	movs	r3, #12
34182862:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34182866:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3418286a:	4619      	mov	r1, r3
3418286c:	4815      	ldr	r0, [pc, #84]	@ (341828c4 <HAL_LTDC_MspInit+0x250>)
3418286e:	f007 fc65 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_8|GPIO_PIN_0;
34182872:	f248 1303 	movw	r3, #33027	@ 0x8103
34182876:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418287a:	2302      	movs	r3, #2
3418287c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34182880:	2300      	movs	r3, #0
34182882:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34182886:	2300      	movs	r3, #0
34182888:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3418288c:	230e      	movs	r3, #14
3418288e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34182892:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34182896:	4619      	mov	r1, r3
34182898:	480a      	ldr	r0, [pc, #40]	@ (341828c4 <HAL_LTDC_MspInit+0x250>)
3418289a:	f007 fc4f 	bl	3418a13c <HAL_GPIO_Init>

  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }
}
3418289e:	bf00      	nop
341828a0:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
341828a4:	46bd      	mov	sp, r7
341828a6:	bd80      	pop	{r7, pc}
341828a8:	58001000 	.word	0x58001000
341828ac:	56020800 	.word	0x56020800
341828b0:	56021c00 	.word	0x56021c00
341828b4:	56020400 	.word	0x56020400
341828b8:	56020c00 	.word	0x56020c00
341828bc:	56021000 	.word	0x56021000
341828c0:	56021800 	.word	0x56021800
341828c4:	56020000 	.word	0x56020000

341828c8 <LL_AHB3_GRP1_EnableClock>:
{
341828c8:	b480      	push	{r7}
341828ca:	b085      	sub	sp, #20
341828cc:	af00      	add	r7, sp, #0
341828ce:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3ENSR, Periphs);
341828d0:	4a07      	ldr	r2, [pc, #28]	@ (341828f0 <LL_AHB3_GRP1_EnableClock+0x28>)
341828d2:	687b      	ldr	r3, [r7, #4]
341828d4:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
341828d8:	4b05      	ldr	r3, [pc, #20]	@ (341828f0 <LL_AHB3_GRP1_EnableClock+0x28>)
341828da:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
341828de:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341828e0:	68fb      	ldr	r3, [r7, #12]
}
341828e2:	bf00      	nop
341828e4:	3714      	adds	r7, #20
341828e6:	46bd      	mov	sp, r7
341828e8:	f85d 7b04 	ldr.w	r7, [sp], #4
341828ec:	4770      	bx	lr
341828ee:	bf00      	nop
341828f0:	56028000 	.word	0x56028000

341828f4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
341828f4:	b580      	push	{r7, lr}
341828f6:	b086      	sub	sp, #24
341828f8:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
341828fa:	4b52      	ldr	r3, [pc, #328]	@ (34182a44 <main+0x150>)
341828fc:	695b      	ldr	r3, [r3, #20]
341828fe:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34182902:	2b00      	cmp	r3, #0
34182904:	d11b      	bne.n	3418293e <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
34182906:	f3bf 8f4f 	dsb	sy
}
3418290a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3418290c:	f3bf 8f6f 	isb	sy
}
34182910:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
34182912:	4b4c      	ldr	r3, [pc, #304]	@ (34182a44 <main+0x150>)
34182914:	2200      	movs	r2, #0
34182916:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
3418291a:	f3bf 8f4f 	dsb	sy
}
3418291e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34182920:	f3bf 8f6f 	isb	sy
}
34182924:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
34182926:	4b47      	ldr	r3, [pc, #284]	@ (34182a44 <main+0x150>)
34182928:	695b      	ldr	r3, [r3, #20]
3418292a:	4a46      	ldr	r2, [pc, #280]	@ (34182a44 <main+0x150>)
3418292c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34182930:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34182932:	f3bf 8f4f 	dsb	sy
}
34182936:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34182938:	f3bf 8f6f 	isb	sy
}
3418293c:	e000      	b.n	34182940 <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
3418293e:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34182940:	4b40      	ldr	r3, [pc, #256]	@ (34182a44 <main+0x150>)
34182942:	695b      	ldr	r3, [r3, #20]
34182944:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34182948:	2b00      	cmp	r3, #0
3418294a:	d138      	bne.n	341829be <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
3418294c:	4b3d      	ldr	r3, [pc, #244]	@ (34182a44 <main+0x150>)
3418294e:	2200      	movs	r2, #0
34182950:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
34182954:	f3bf 8f4f 	dsb	sy
}
34182958:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
3418295a:	4b3a      	ldr	r3, [pc, #232]	@ (34182a44 <main+0x150>)
3418295c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34182960:	617b      	str	r3, [r7, #20]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
34182962:	697b      	ldr	r3, [r7, #20]
34182964:	0b5b      	lsrs	r3, r3, #13
34182966:	f3c3 030e 	ubfx	r3, r3, #0, #15
3418296a:	613b      	str	r3, [r7, #16]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
3418296c:	697b      	ldr	r3, [r7, #20]
3418296e:	08db      	lsrs	r3, r3, #3
34182970:	f3c3 0309 	ubfx	r3, r3, #0, #10
34182974:	60fb      	str	r3, [r7, #12]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34182976:	693b      	ldr	r3, [r7, #16]
34182978:	015a      	lsls	r2, r3, #5
3418297a:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
3418297e:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
34182980:	68fa      	ldr	r2, [r7, #12]
34182982:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34182984:	492f      	ldr	r1, [pc, #188]	@ (34182a44 <main+0x150>)
34182986:	4313      	orrs	r3, r2
34182988:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
3418298c:	68fb      	ldr	r3, [r7, #12]
3418298e:	1e5a      	subs	r2, r3, #1
34182990:	60fa      	str	r2, [r7, #12]
34182992:	2b00      	cmp	r3, #0
34182994:	d1ef      	bne.n	34182976 <main+0x82>
    } while(sets-- != 0U);
34182996:	693b      	ldr	r3, [r7, #16]
34182998:	1e5a      	subs	r2, r3, #1
3418299a:	613a      	str	r2, [r7, #16]
3418299c:	2b00      	cmp	r3, #0
3418299e:	d1e5      	bne.n	3418296c <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
341829a0:	f3bf 8f4f 	dsb	sy
}
341829a4:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
341829a6:	4b27      	ldr	r3, [pc, #156]	@ (34182a44 <main+0x150>)
341829a8:	695b      	ldr	r3, [r3, #20]
341829aa:	4a26      	ldr	r2, [pc, #152]	@ (34182a44 <main+0x150>)
341829ac:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341829b0:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
341829b2:	f3bf 8f4f 	dsb	sy
}
341829b6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
341829b8:	f3bf 8f6f 	isb	sy
}
341829bc:	e000      	b.n	341829c0 <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
341829be:	bf00      	nop

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
341829c0:	f003 fd48 	bl	34186454 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
341829c4:	f000 f848 	bl	34182a58 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
341829c8:	f7ff fbba 	bl	34182140 <MX_GPIO_Init>
  MX_BSEC_Init();
341829cc:	f7ff f990 	bl	34181cf0 <MX_BSEC_Init>
  MX_CACHEAXI_Init();
341829d0:	f7ff f9ac 	bl	34181d2c <MX_CACHEAXI_Init>
  MX_DCMIPP_Init();
341829d4:	f7ff fa0c 	bl	34181df0 <MX_DCMIPP_Init>
//  MX_I2C1_Init();
//  MX_LTDC_Init_CubeMX();
  MX_XSPI1_Init();
341829d8:	f000 fc1e 	bl	34183218 <MX_XSPI1_Init>
  MX_XSPI2_Init();
341829dc:	f000 fc78 	bl	341832d0 <MX_XSPI2_Init>
  SystemIsolation_Config();
341829e0:	f000 f916 	bl	34182c10 <SystemIsolation_Config>
  MX_EXTMEM_MANAGER_Init();
341829e4:	f7ff fb28 	bl	34182038 <MX_EXTMEM_MANAGER_Init>
  /* USER CODE BEGIN 2 */

  BSP_XSPI_RAM_Init(0);
341829e8:	2000      	movs	r0, #0
341829ea:	f002 ff45 	bl	34185878 <BSP_XSPI_RAM_Init>
  BSP_XSPI_RAM_EnableMemoryMappedMode(0);
341829ee:	2000      	movs	r0, #0
341829f0:	f003 f810 	bl	34185a14 <BSP_XSPI_RAM_EnableMemoryMappedMode>

  BSP_XSPI_NOR_Init_t NOR_Init;
  NOR_Init.InterfaceMode = BSP_XSPI_NOR_OPI_MODE;
341829f4:	2301      	movs	r3, #1
341829f6:	723b      	strb	r3, [r7, #8]
  NOR_Init.TransferRate = BSP_XSPI_NOR_DTR_TRANSFER;
341829f8:	2301      	movs	r3, #1
341829fa:	727b      	strb	r3, [r7, #9]
  BSP_XSPI_NOR_Init(0, &NOR_Init);
341829fc:	f107 0308 	add.w	r3, r7, #8
34182a00:	4619      	mov	r1, r3
34182a02:	2000      	movs	r0, #0
34182a04:	f002 fd56 	bl	341854b4 <BSP_XSPI_NOR_Init>
  BSP_XSPI_NOR_EnableMemoryMappedMode(0);
34182a08:	2000      	movs	r0, #0
34182a0a:	f002 fe3d 	bl	34185688 <BSP_XSPI_NOR_EnableMemoryMappedMode>
	    done = 1U;
	  }
  }
*/

  uint32_t pitch_nn = 0;
34182a0e:	2300      	movs	r3, #0
34182a10:	607b      	str	r3, [r7, #4]
  Security_Config();
34182a12:	f000 fa59 	bl	34182ec8 <Security_Config>
  /*** Camera Init ************************************************************/
  CameraPipeline_Init(&lcd_bg_area.XSize, &lcd_bg_area.YSize, &pitch_nn);
34182a16:	1d3b      	adds	r3, r7, #4
34182a18:	461a      	mov	r2, r3
34182a1a:	490b      	ldr	r1, [pc, #44]	@ (34182a48 <main+0x154>)
34182a1c:	480b      	ldr	r0, [pc, #44]	@ (34182a4c <main+0x158>)
34182a1e:	f7ff f8f9 	bl	34181c14 <CameraPipeline_Init>

  /*** Display Init ************************************************************/
  LCD_init();
34182a22:	f000 f9e5 	bl	34182df0 <LCD_init>

  /* Start LCD Display camera pipe stream */
   CameraPipeline_DisplayPipe_Start(lcd_bg_buffer, CMW_MODE_CONTINUOUS);
34182a26:	2100      	movs	r1, #0
34182a28:	4809      	ldr	r0, [pc, #36]	@ (34182a50 <main+0x15c>)
34182a2a:	f7ff f927 	bl	34181c7c <CameraPipeline_DisplayPipe_Start>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  CameraPipeline_IspUpdate();
34182a2e:	f7ff f943 	bl	34181cb8 <CameraPipeline_IspUpdate>

	  while (cameraFrameReceived == 0) {};
34182a32:	bf00      	nop
34182a34:	4b07      	ldr	r3, [pc, #28]	@ (34182a54 <main+0x160>)
34182a36:	681b      	ldr	r3, [r3, #0]
34182a38:	2b00      	cmp	r3, #0
34182a3a:	d0fb      	beq.n	34182a34 <main+0x140>
	  cameraFrameReceived = 0;
34182a3c:	4b05      	ldr	r3, [pc, #20]	@ (34182a54 <main+0x160>)
34182a3e:	2200      	movs	r2, #0
34182a40:	601a      	str	r2, [r3, #0]
	  CameraPipeline_IspUpdate();
34182a42:	e7f4      	b.n	34182a2e <main+0x13a>
34182a44:	e000ed00 	.word	0xe000ed00
34182a48:	341c000c 	.word	0x341c000c
34182a4c:	341c0008 	.word	0x341c0008
34182a50:	91000000 	.word	0x91000000
34182a54:	341c05c4 	.word	0x341c05c4

34182a58 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
34182a58:	b580      	push	{r7, lr}
34182a5a:	b0b6      	sub	sp, #216	@ 0xd8
34182a5c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
34182a5e:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182a62:	2298      	movs	r2, #152	@ 0x98
34182a64:	2100      	movs	r1, #0
34182a66:	4618      	mov	r0, r3
34182a68:	f022 fd42 	bl	341a54f0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34182a6c:	463b      	mov	r3, r7
34182a6e:	2240      	movs	r2, #64	@ 0x40
34182a70:	2100      	movs	r1, #0
34182a72:	4618      	mov	r0, r3
34182a74:	f022 fd3c 	bl	341a54f0 <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_EXTERNAL_SOURCE_SUPPLY) != HAL_OK)
34182a78:	2000      	movs	r0, #0
34182a7a:	f009 febb 	bl	3418c7f4 <HAL_PWREx_ConfigSupply>
34182a7e:	4603      	mov	r3, r0
34182a80:	2b00      	cmp	r3, #0
34182a82:	d001      	beq.n	34182a88 <SystemClock_Config+0x30>
  {
    Error_Handler();
34182a84:	f000 fa6c 	bl	34182f60 <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
34182a88:	2302      	movs	r3, #2
34182a8a:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
34182a8c:	2308      	movs	r3, #8
34182a8e:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
34182a90:	2300      	movs	r3, #0
34182a92:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
34182a94:	2300      	movs	r3, #0
34182a96:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
34182a98:	2300      	movs	r3, #0
34182a9a:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34182a9c:	2300      	movs	r3, #0
34182a9e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
34182aa2:	2300      	movs	r3, #0
34182aa4:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
34182aa8:	2300      	movs	r3, #0
34182aaa:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34182aae:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182ab2:	4618      	mov	r0, r3
34182ab4:	f00a f9e0 	bl	3418ce78 <HAL_RCC_OscConfig>
34182ab8:	4603      	mov	r3, r0
34182aba:	2b00      	cmp	r3, #0
34182abc:	d001      	beq.n	34182ac2 <SystemClock_Config+0x6a>
  {
    Error_Handler();
34182abe:	f000 fa4f 	bl	34182f60 <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
34182ac2:	463b      	mov	r3, r7
34182ac4:	4618      	mov	r0, r3
34182ac6:	f00b f85f 	bl	3418db88 <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34182aca:	687b      	ldr	r3, [r7, #4]
34182acc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34182ad0:	d003      	beq.n	34182ada <SystemClock_Config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
34182ad2:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34182ad4:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34182ad8:	d10e      	bne.n	34182af8 <SystemClock_Config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
34182ada:	2303      	movs	r3, #3
34182adc:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
34182ade:	2300      	movs	r3, #0
34182ae0:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
34182ae2:	2300      	movs	r3, #0
34182ae4:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34182ae6:	463b      	mov	r3, r7
34182ae8:	4618      	mov	r0, r3
34182aea:	f00a fda5 	bl	3418d638 <HAL_RCC_ClockConfig>
34182aee:	4603      	mov	r3, r0
34182af0:	2b00      	cmp	r3, #0
34182af2:	d001      	beq.n	34182af8 <SystemClock_Config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
34182af4:	f000 fa34 	bl	34182f60 <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
34182af8:	2300      	movs	r3, #0
34182afa:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
34182afc:	2302      	movs	r3, #2
34182afe:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
34182b00:	2300      	movs	r3, #0
34182b02:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 2;
34182b04:	2302      	movs	r3, #2
34182b06:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 25;
34182b08:	2319      	movs	r3, #25
34182b0a:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
34182b0c:	2300      	movs	r3, #0
34182b0e:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
34182b10:	2301      	movs	r3, #1
34182b12:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
34182b14:	2301      	movs	r3, #1
34182b16:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
34182b1a:	2302      	movs	r3, #2
34182b1c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
34182b20:	2300      	movs	r3, #0
34182b22:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  RCC_OscInitStruct.PLL2.PLLM = 8;
34182b26:	2308      	movs	r3, #8
34182b28:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  RCC_OscInitStruct.PLL2.PLLN = 125;
34182b2c:	237d      	movs	r3, #125	@ 0x7d
34182b2e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
34182b32:	2300      	movs	r3, #0
34182b34:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
34182b38:	2301      	movs	r3, #1
34182b3a:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
  RCC_OscInitStruct.PLL2.PLLP2 = 1;
34182b3e:	2301      	movs	r3, #1
34182b40:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
34182b44:	2302      	movs	r3, #2
34182b46:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
34182b4a:	2300      	movs	r3, #0
34182b4c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLM = 8;
34182b50:	2308      	movs	r3, #8
34182b52:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  RCC_OscInitStruct.PLL3.PLLN = 225;
34182b56:	23e1      	movs	r3, #225	@ 0xe1
34182b58:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34182b5c:	2300      	movs	r3, #0
34182b5e:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
34182b62:	2301      	movs	r3, #1
34182b64:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34182b68:	2302      	movs	r3, #2
34182b6a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
34182b6e:	2302      	movs	r3, #2
34182b70:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34182b74:	2300      	movs	r3, #0
34182b76:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  RCC_OscInitStruct.PLL4.PLLM = 8;
34182b7a:	2308      	movs	r3, #8
34182b7c:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  RCC_OscInitStruct.PLL4.PLLN = 225;
34182b80:	23e1      	movs	r3, #225	@ 0xe1
34182b82:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34182b86:	2300      	movs	r3, #0
34182b88:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
  RCC_OscInitStruct.PLL4.PLLP1 = 6;
34182b8c:	2306      	movs	r3, #6
34182b8e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
34182b92:	2306      	movs	r3, #6
34182b94:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34182b98:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34182b9c:	4618      	mov	r0, r3
34182b9e:	f00a f96b 	bl	3418ce78 <HAL_RCC_OscConfig>
34182ba2:	4603      	mov	r3, r0
34182ba4:	2b00      	cmp	r3, #0
34182ba6:	d001      	beq.n	34182bac <SystemClock_Config+0x154>
  {
    Error_Handler();
34182ba8:	f000 f9da 	bl	34182f60 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34182bac:	237f      	movs	r3, #127	@ 0x7f
34182bae:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
34182bb0:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34182bb4:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34182bb6:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34182bba:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34182bbc:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
34182bc0:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
34182bc2:	2300      	movs	r3, #0
34182bc4:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34182bc6:	2300      	movs	r3, #0
34182bc8:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34182bca:	2300      	movs	r3, #0
34182bcc:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
34182bce:	2300      	movs	r3, #0
34182bd0:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34182bd2:	2300      	movs	r3, #0
34182bd4:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34182bd6:	2301      	movs	r3, #1
34182bd8:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34182bda:	2300      	movs	r3, #0
34182bdc:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
34182bde:	2302      	movs	r3, #2
34182be0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
34182be2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34182be6:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34182be8:	2301      	movs	r3, #1
34182bea:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34182bec:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34182bf0:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
34182bf2:	2301      	movs	r3, #1
34182bf4:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34182bf6:	463b      	mov	r3, r7
34182bf8:	4618      	mov	r0, r3
34182bfa:	f00a fd1d 	bl	3418d638 <HAL_RCC_ClockConfig>
34182bfe:	4603      	mov	r3, r0
34182c00:	2b00      	cmp	r3, #0
34182c02:	d001      	beq.n	34182c08 <SystemClock_Config+0x1b0>
  {
    Error_Handler();
34182c04:	f000 f9ac 	bl	34182f60 <Error_Handler>
  }
}
34182c08:	bf00      	nop
34182c0a:	37d8      	adds	r7, #216	@ 0xd8
34182c0c:	46bd      	mov	sp, r7
34182c0e:	bd80      	pop	{r7, pc}

34182c10 <SystemIsolation_Config>:
  * @brief RIF Initialization Function
  * @param None
  * @retval None
  */
  static void SystemIsolation_Config(void)
{
34182c10:	b580      	push	{r7, lr}
34182c12:	b082      	sub	sp, #8
34182c14:	af00      	add	r7, sp, #0
/* USER CODE BEGIN RIF_Init 0 */

/* USER CODE END RIF_Init 0 */

  /* set all required IPs as secure privileged */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34182c16:	f44f 7000 	mov.w	r0, #512	@ 0x200
34182c1a:	f7ff fe55 	bl	341828c8 <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34182c1e:	463b      	mov	r3, r7
34182c20:	2200      	movs	r2, #0
34182c22:	601a      	str	r2, [r3, #0]
34182c24:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34182c26:	2302      	movs	r3, #2
34182c28:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34182c2a:	2303      	movs	r3, #3
34182c2c:	607b      	str	r3, [r7, #4]

  /*RIMC configuration*/
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34182c2e:	463b      	mov	r3, r7
34182c30:	4619      	mov	r1, r3
34182c32:	2009      	movs	r0, #9
34182c34:	f013 fb50 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1, &RIMC_master);
34182c38:	463b      	mov	r3, r7
34182c3a:	4619      	mov	r1, r3
34182c3c:	200a      	movs	r0, #10
34182c3e:	f013 fb4b 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2, &RIMC_master);
34182c42:	463b      	mov	r3, r7
34182c44:	4619      	mov	r1, r3
34182c46:	200b      	movs	r0, #11
34182c48:	f013 fb46 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>

  /* RIF-Aware IPs Config */

  /* set up PWR configuration */
  HAL_PWR_ConfigAttributes(PWR_ITEM_WKUP1,PWR_SEC_NPRIV);
34182c4c:	2120      	movs	r1, #32
34182c4e:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34182c52:	f009 fd7b 	bl	3418c74c <HAL_PWR_ConfigAttributes>

  /* set up GPIO configuration */
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c56:	f240 3201 	movw	r2, #769	@ 0x301
34182c5a:	2101      	movs	r1, #1
34182c5c:	485b      	ldr	r0, [pc, #364]	@ (34182dcc <SystemIsolation_Config+0x1bc>)
34182c5e:	f007 fd77 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c62:	f240 3201 	movw	r2, #769	@ 0x301
34182c66:	2102      	movs	r1, #2
34182c68:	4858      	ldr	r0, [pc, #352]	@ (34182dcc <SystemIsolation_Config+0x1bc>)
34182c6a:	f007 fd71 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c6e:	f240 3201 	movw	r2, #769	@ 0x301
34182c72:	2140      	movs	r1, #64	@ 0x40
34182c74:	4855      	ldr	r0, [pc, #340]	@ (34182dcc <SystemIsolation_Config+0x1bc>)
34182c76:	f007 fd6b 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c7a:	f240 3201 	movw	r2, #769	@ 0x301
34182c7e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182c82:	4852      	ldr	r0, [pc, #328]	@ (34182dcc <SystemIsolation_Config+0x1bc>)
34182c84:	f007 fd64 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c88:	f240 3201 	movw	r2, #769	@ 0x301
34182c8c:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34182c90:	484f      	ldr	r0, [pc, #316]	@ (34182dd0 <SystemIsolation_Config+0x1c0>)
34182c92:	f007 fd5d 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_12,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182c96:	f240 3201 	movw	r2, #769	@ 0x301
34182c9a:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
34182c9e:	484c      	ldr	r0, [pc, #304]	@ (34182dd0 <SystemIsolation_Config+0x1c0>)
34182ca0:	f007 fd56 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182ca4:	f240 3201 	movw	r2, #769	@ 0x301
34182ca8:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34182cac:	4848      	ldr	r0, [pc, #288]	@ (34182dd0 <SystemIsolation_Config+0x1c0>)
34182cae:	f007 fd4f 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_14,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cb2:	f240 3201 	movw	r2, #769	@ 0x301
34182cb6:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
34182cba:	4845      	ldr	r0, [pc, #276]	@ (34182dd0 <SystemIsolation_Config+0x1c0>)
34182cbc:	f007 fd48 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB,GPIO_PIN_15,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cc0:	f240 3201 	movw	r2, #769	@ 0x301
34182cc4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
34182cc8:	4841      	ldr	r0, [pc, #260]	@ (34182dd0 <SystemIsolation_Config+0x1c0>)
34182cca:	f007 fd41 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cce:	f240 3201 	movw	r2, #769	@ 0x301
34182cd2:	2101      	movs	r1, #1
34182cd4:	483f      	ldr	r0, [pc, #252]	@ (34182dd4 <SystemIsolation_Config+0x1c4>)
34182cd6:	f007 fd3b 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cda:	f240 3201 	movw	r2, #769	@ 0x301
34182cde:	2102      	movs	r1, #2
34182ce0:	483c      	ldr	r0, [pc, #240]	@ (34182dd4 <SystemIsolation_Config+0x1c4>)
34182ce2:	f007 fd35 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182ce6:	f240 3201 	movw	r2, #769	@ 0x301
34182cea:	2110      	movs	r1, #16
34182cec:	4839      	ldr	r0, [pc, #228]	@ (34182dd4 <SystemIsolation_Config+0x1c4>)
34182cee:	f007 fd2f 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182cf2:	f240 3201 	movw	r2, #769	@ 0x301
34182cf6:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182cfa:	4836      	ldr	r0, [pc, #216]	@ (34182dd4 <SystemIsolation_Config+0x1c4>)
34182cfc:	f007 fd28 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d00:	f240 3201 	movw	r2, #769	@ 0x301
34182d04:	2104      	movs	r1, #4
34182d06:	4834      	ldr	r0, [pc, #208]	@ (34182dd8 <SystemIsolation_Config+0x1c8>)
34182d08:	f007 fd22 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d0c:	f240 3201 	movw	r2, #769	@ 0x301
34182d10:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182d14:	4830      	ldr	r0, [pc, #192]	@ (34182dd8 <SystemIsolation_Config+0x1c8>)
34182d16:	f007 fd1b 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d1a:	f240 3201 	movw	r2, #769	@ 0x301
34182d1e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34182d22:	482d      	ldr	r0, [pc, #180]	@ (34182dd8 <SystemIsolation_Config+0x1c8>)
34182d24:	f007 fd14 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d28:	f240 3201 	movw	r2, #769	@ 0x301
34182d2c:	2102      	movs	r1, #2
34182d2e:	482b      	ldr	r0, [pc, #172]	@ (34182ddc <SystemIsolation_Config+0x1cc>)
34182d30:	f007 fd0e 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d34:	f240 3201 	movw	r2, #769	@ 0x301
34182d38:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34182d3c:	4827      	ldr	r0, [pc, #156]	@ (34182ddc <SystemIsolation_Config+0x1cc>)
34182d3e:	f007 fd07 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d42:	f240 3201 	movw	r2, #769	@ 0x301
34182d46:	2140      	movs	r1, #64	@ 0x40
34182d48:	4825      	ldr	r0, [pc, #148]	@ (34182de0 <SystemIsolation_Config+0x1d0>)
34182d4a:	f007 fd01 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d4e:	f240 3201 	movw	r2, #769	@ 0x301
34182d52:	f44f 7180 	mov.w	r1, #256	@ 0x100
34182d56:	4822      	ldr	r0, [pc, #136]	@ (34182de0 <SystemIsolation_Config+0x1d0>)
34182d58:	f007 fcfa 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d5c:	f240 3201 	movw	r2, #769	@ 0x301
34182d60:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34182d64:	481e      	ldr	r0, [pc, #120]	@ (34182de0 <SystemIsolation_Config+0x1d0>)
34182d66:	f007 fcf3 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_13,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d6a:	f240 3201 	movw	r2, #769	@ 0x301
34182d6e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34182d72:	481b      	ldr	r0, [pc, #108]	@ (34182de0 <SystemIsolation_Config+0x1d0>)
34182d74:	f007 fcec 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d78:	f240 3201 	movw	r2, #769	@ 0x301
34182d7c:	2108      	movs	r1, #8
34182d7e:	4819      	ldr	r0, [pc, #100]	@ (34182de4 <SystemIsolation_Config+0x1d4>)
34182d80:	f007 fce6 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d84:	f240 3201 	movw	r2, #769	@ 0x301
34182d88:	2140      	movs	r1, #64	@ 0x40
34182d8a:	4816      	ldr	r0, [pc, #88]	@ (34182de4 <SystemIsolation_Config+0x1d4>)
34182d8c:	f007 fce0 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d90:	f240 3201 	movw	r2, #769	@ 0x301
34182d94:	f44f 7100 	mov.w	r1, #512	@ 0x200
34182d98:	4812      	ldr	r0, [pc, #72]	@ (34182de4 <SystemIsolation_Config+0x1d4>)
34182d9a:	f007 fcd9 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182d9e:	f240 3201 	movw	r2, #769	@ 0x301
34182da2:	2102      	movs	r1, #2
34182da4:	4810      	ldr	r0, [pc, #64]	@ (34182de8 <SystemIsolation_Config+0x1d8>)
34182da6:	f007 fcd3 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOQ,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182daa:	f240 3201 	movw	r2, #769	@ 0x301
34182dae:	2108      	movs	r1, #8
34182db0:	480e      	ldr	r0, [pc, #56]	@ (34182dec <SystemIsolation_Config+0x1dc>)
34182db2:	f007 fccd 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOQ,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34182db6:	f240 3201 	movw	r2, #769	@ 0x301
34182dba:	2140      	movs	r1, #64	@ 0x40
34182dbc:	480b      	ldr	r0, [pc, #44]	@ (34182dec <SystemIsolation_Config+0x1dc>)
34182dbe:	f007 fcc7 	bl	3418a750 <HAL_GPIO_ConfigPinAttributes>
/* USER CODE END RIF_Init 1 */
/* USER CODE BEGIN RIF_Init 2 */

/* USER CODE END RIF_Init 2 */

}
34182dc2:	bf00      	nop
34182dc4:	3708      	adds	r7, #8
34182dc6:	46bd      	mov	sp, r7
34182dc8:	bd80      	pop	{r7, pc}
34182dca:	bf00      	nop
34182dcc:	56020000 	.word	0x56020000
34182dd0:	56020400 	.word	0x56020400
34182dd4:	56020800 	.word	0x56020800
34182dd8:	56020c00 	.word	0x56020c00
34182ddc:	56021000 	.word	0x56021000
34182de0:	56021800 	.word	0x56021800
34182de4:	56021c00 	.word	0x56021c00
34182de8:	56023800 	.word	0x56023800
34182dec:	56024000 	.word	0x56024000

34182df0 <LCD_init>:

/* USER CODE BEGIN 4 */
  static void LCD_init(void)
  {
34182df0:	b580      	push	{r7, lr}
34182df2:	af00      	add	r7, sp, #0
    BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34182df4:	2101      	movs	r1, #1
34182df6:	2000      	movs	r0, #0
34182df8:	f001 fb98 	bl	3418452c <BSP_LCD_Init>

    /* Preview layer Init */
    LayerConfig.X0          = lcd_bg_area.X0;
34182dfc:	4b2b      	ldr	r3, [pc, #172]	@ (34182eac <LCD_init+0xbc>)
34182dfe:	681b      	ldr	r3, [r3, #0]
34182e00:	4a2b      	ldr	r2, [pc, #172]	@ (34182eb0 <LCD_init+0xc0>)
34182e02:	6013      	str	r3, [r2, #0]
    LayerConfig.Y0          = lcd_bg_area.Y0;
34182e04:	4b29      	ldr	r3, [pc, #164]	@ (34182eac <LCD_init+0xbc>)
34182e06:	685b      	ldr	r3, [r3, #4]
34182e08:	4a29      	ldr	r2, [pc, #164]	@ (34182eb0 <LCD_init+0xc0>)
34182e0a:	6093      	str	r3, [r2, #8]
    LayerConfig.X1          = lcd_bg_area.X0 + lcd_bg_area.XSize;
34182e0c:	4b27      	ldr	r3, [pc, #156]	@ (34182eac <LCD_init+0xbc>)
34182e0e:	681a      	ldr	r2, [r3, #0]
34182e10:	4b26      	ldr	r3, [pc, #152]	@ (34182eac <LCD_init+0xbc>)
34182e12:	689b      	ldr	r3, [r3, #8]
34182e14:	4413      	add	r3, r2
34182e16:	4a26      	ldr	r2, [pc, #152]	@ (34182eb0 <LCD_init+0xc0>)
34182e18:	6053      	str	r3, [r2, #4]
    LayerConfig.Y1          = lcd_bg_area.Y0 + lcd_bg_area.YSize;
34182e1a:	4b24      	ldr	r3, [pc, #144]	@ (34182eac <LCD_init+0xbc>)
34182e1c:	685a      	ldr	r2, [r3, #4]
34182e1e:	4b23      	ldr	r3, [pc, #140]	@ (34182eac <LCD_init+0xbc>)
34182e20:	68db      	ldr	r3, [r3, #12]
34182e22:	4413      	add	r3, r2
34182e24:	4a22      	ldr	r2, [pc, #136]	@ (34182eb0 <LCD_init+0xc0>)
34182e26:	60d3      	str	r3, [r2, #12]
    LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34182e28:	4b21      	ldr	r3, [pc, #132]	@ (34182eb0 <LCD_init+0xc0>)
34182e2a:	2202      	movs	r2, #2
34182e2c:	611a      	str	r2, [r3, #16]
    LayerConfig.Address     = (uint32_t) lcd_bg_buffer;
34182e2e:	4a21      	ldr	r2, [pc, #132]	@ (34182eb4 <LCD_init+0xc4>)
34182e30:	4b1f      	ldr	r3, [pc, #124]	@ (34182eb0 <LCD_init+0xc0>)
34182e32:	615a      	str	r2, [r3, #20]

    BSP_LCD_ConfigLayer(0, LTDC_LAYER_1, &LayerConfig);
34182e34:	4a1e      	ldr	r2, [pc, #120]	@ (34182eb0 <LCD_init+0xc0>)
34182e36:	2100      	movs	r1, #0
34182e38:	2000      	movs	r0, #0
34182e3a:	f001 fcdf 	bl	341847fc <BSP_LCD_ConfigLayer>

    LayerConfig.X0 = lcd_fg_area.X0;
34182e3e:	4b1e      	ldr	r3, [pc, #120]	@ (34182eb8 <LCD_init+0xc8>)
34182e40:	681b      	ldr	r3, [r3, #0]
34182e42:	4a1b      	ldr	r2, [pc, #108]	@ (34182eb0 <LCD_init+0xc0>)
34182e44:	6013      	str	r3, [r2, #0]
    LayerConfig.Y0 = lcd_fg_area.Y0;
34182e46:	4b1c      	ldr	r3, [pc, #112]	@ (34182eb8 <LCD_init+0xc8>)
34182e48:	685b      	ldr	r3, [r3, #4]
34182e4a:	4a19      	ldr	r2, [pc, #100]	@ (34182eb0 <LCD_init+0xc0>)
34182e4c:	6093      	str	r3, [r2, #8]
    LayerConfig.X1 = lcd_fg_area.X0 + lcd_fg_area.XSize;
34182e4e:	4b1a      	ldr	r3, [pc, #104]	@ (34182eb8 <LCD_init+0xc8>)
34182e50:	681a      	ldr	r2, [r3, #0]
34182e52:	4b19      	ldr	r3, [pc, #100]	@ (34182eb8 <LCD_init+0xc8>)
34182e54:	689b      	ldr	r3, [r3, #8]
34182e56:	4413      	add	r3, r2
34182e58:	4a15      	ldr	r2, [pc, #84]	@ (34182eb0 <LCD_init+0xc0>)
34182e5a:	6053      	str	r3, [r2, #4]
    LayerConfig.Y1 = lcd_fg_area.Y0 + lcd_fg_area.YSize;
34182e5c:	4b16      	ldr	r3, [pc, #88]	@ (34182eb8 <LCD_init+0xc8>)
34182e5e:	685a      	ldr	r2, [r3, #4]
34182e60:	4b15      	ldr	r3, [pc, #84]	@ (34182eb8 <LCD_init+0xc8>)
34182e62:	68db      	ldr	r3, [r3, #12]
34182e64:	4413      	add	r3, r2
34182e66:	4a12      	ldr	r2, [pc, #72]	@ (34182eb0 <LCD_init+0xc0>)
34182e68:	60d3      	str	r3, [r2, #12]
    LayerConfig.PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34182e6a:	4b11      	ldr	r3, [pc, #68]	@ (34182eb0 <LCD_init+0xc0>)
34182e6c:	2204      	movs	r2, #4
34182e6e:	611a      	str	r2, [r3, #16]
    LayerConfig.Address = (uint32_t) lcd_fg_buffer; /* External XSPI1 PSRAM */
34182e70:	4a12      	ldr	r2, [pc, #72]	@ (34182ebc <LCD_init+0xcc>)
34182e72:	4b0f      	ldr	r3, [pc, #60]	@ (34182eb0 <LCD_init+0xc0>)
34182e74:	615a      	str	r2, [r3, #20]

    BSP_LCD_ConfigLayer(0, LTDC_LAYER_2, &LayerConfig);
34182e76:	4a0e      	ldr	r2, [pc, #56]	@ (34182eb0 <LCD_init+0xc0>)
34182e78:	2101      	movs	r1, #1
34182e7a:	2000      	movs	r0, #0
34182e7c:	f001 fcbe 	bl	341847fc <BSP_LCD_ConfigLayer>
    UTIL_LCD_SetFuncDriver(&LCD_Driver);
34182e80:	480f      	ldr	r0, [pc, #60]	@ (34182ec0 <LCD_init+0xd0>)
34182e82:	f021 ff29 	bl	341a4cd8 <UTIL_LCD_SetFuncDriver>
    UTIL_LCD_SetLayer(LTDC_LAYER_2);
34182e86:	2001      	movs	r0, #1
34182e88:	f021 ff88 	bl	341a4d9c <UTIL_LCD_SetLayer>
    UTIL_LCD_Clear(0x00000000);
34182e8c:	2000      	movs	r0, #0
34182e8e:	f022 f805 	bl	341a4e9c <UTIL_LCD_Clear>
    UTIL_LCD_SetFont(&Font20);
34182e92:	480c      	ldr	r0, [pc, #48]	@ (34182ec4 <LCD_init+0xd4>)
34182e94:	f021 ffee 	bl	341a4e74 <UTIL_LCD_SetFont>
    UTIL_LCD_SetBackColor(0x40000000);
34182e98:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34182e9c:	f021 ffd6 	bl	341a4e4c <UTIL_LCD_SetBackColor>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
34182ea0:	f04f 30ff 	mov.w	r0, #4294967295
34182ea4:	f021 ffbe 	bl	341a4e24 <UTIL_LCD_SetTextColor>
  }
34182ea8:	bf00      	nop
34182eaa:	bd80      	pop	{r7, pc}
34182eac:	341c0000 	.word	0x341c0000
34182eb0:	341c05ac 	.word	0x341c05ac
34182eb4:	91000000 	.word	0x91000000
34182eb8:	341c0010 	.word	0x341c0010
34182ebc:	910bb800 	.word	0x910bb800
34182ec0:	341a7ed0 	.word	0x341a7ed0
34182ec4:	341c0130 	.word	0x341c0130

34182ec8 <Security_Config>:
    UTIL_LCDEx_PrintfAt(0, LINE(18), CENTER_MODE, WELCOME_MSG_2);
  }
}

static void Security_Config(void)
{
34182ec8:	b580      	push	{r7, lr}
34182eca:	b082      	sub	sp, #8
34182ecc:	af00      	add	r7, sp, #0
  __HAL_RCC_RIFSC_CLK_ENABLE();
34182ece:	f44f 7000 	mov.w	r0, #512	@ 0x200
34182ed2:	f7ff fcf9 	bl	341828c8 <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34182ed6:	463b      	mov	r3, r7
34182ed8:	2200      	movs	r2, #0
34182eda:	601a      	str	r2, [r3, #0]
34182edc:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34182ede:	2302      	movs	r3, #2
34182ee0:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34182ee2:	2303      	movs	r3, #3
34182ee4:	607b      	str	r3, [r7, #4]
//  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34182ee6:	463b      	mov	r3, r7
34182ee8:	4619      	mov	r1, r3
34182eea:	2008      	movs	r0, #8
34182eec:	f013 f9f4 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34182ef0:	463b      	mov	r3, r7
34182ef2:	4619      	mov	r1, r3
34182ef4:	2009      	movs	r0, #9
34182ef6:	f013 f9ef 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1 , &RIMC_master);
34182efa:	463b      	mov	r3, r7
34182efc:	4619      	mov	r1, r3
34182efe:	200a      	movs	r0, #10
34182f00:	f013 f9ea 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2 , &RIMC_master);
34182f04:	463b      	mov	r3, r7
34182f06:	4619      	mov	r1, r3
34182f08:	200b      	movs	r0, #11
34182f0a:	f013 f9e5 	bl	341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>
//  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f0e:	2103      	movs	r1, #3
34182f10:	480d      	ldr	r0, [pc, #52]	@ (34182f48 <Security_Config+0x80>)
34182f12:	f013 fa1d 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI    , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f16:	2103      	movs	r1, #3
34182f18:	480c      	ldr	r0, [pc, #48]	@ (34182f4c <Security_Config+0x84>)
34182f1a:	f013 fa19 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f1e:	2103      	movs	r1, #3
34182f20:	480b      	ldr	r0, [pc, #44]	@ (34182f50 <Security_Config+0x88>)
34182f22:	f013 fa15 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC   , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f26:	2103      	movs	r1, #3
34182f28:	480a      	ldr	r0, [pc, #40]	@ (34182f54 <Security_Config+0x8c>)
34182f2a:	f013 fa11 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f2e:	2103      	movs	r1, #3
34182f30:	4809      	ldr	r0, [pc, #36]	@ (34182f58 <Security_Config+0x90>)
34182f32:	f013 fa0d 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34182f36:	2103      	movs	r1, #3
34182f38:	4808      	ldr	r0, [pc, #32]	@ (34182f5c <Security_Config+0x94>)
34182f3a:	f013 fa09 	bl	34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>
}
34182f3e:	bf00      	nop
34182f40:	3708      	adds	r7, #8
34182f42:	46bd      	mov	sp, r7
34182f44:	bd80      	pop	{r7, pc}
34182f46:	bf00      	nop
34182f48:	30000005 	.word	0x30000005
34182f4c:	2000001c 	.word	0x2000001c
34182f50:	2000001d 	.word	0x2000001d
34182f54:	30000006 	.word	0x30000006
34182f58:	30000007 	.word	0x30000007
34182f5c:	30000008 	.word	0x30000008

34182f60 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34182f60:	b480      	push	{r7}
34182f62:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34182f64:	b672      	cpsid	i
}
34182f66:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34182f68:	bf00      	nop
34182f6a:	e7fd      	b.n	34182f68 <Error_Handler+0x8>

34182f6c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34182f6c:	b580      	push	{r7, lr}
34182f6e:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34182f70:	f009 fcba 	bl	3418c8e8 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2,PWR_VDDIO_RANGE_3V3);
34182f74:	2100      	movs	r1, #0
34182f76:	2001      	movs	r0, #1
34182f78:	f009 fc64 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO3();
34182f7c:	f009 fcc4 	bl	3418c908 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3,PWR_VDDIO_RANGE_1V8);
34182f80:	2101      	movs	r1, #1
34182f82:	2002      	movs	r0, #2
34182f84:	f009 fc5e 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO4();
34182f88:	f009 fcce 	bl	3418c928 <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);
34182f8c:	2100      	movs	r1, #0
34182f8e:	2003      	movs	r0, #3
34182f90:	f009 fc58 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO5();
34182f94:	f009 fcd8 	bl	3418c948 <HAL_PWREx_EnableVddIO5>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO5,PWR_VDDIO_RANGE_3V3);
34182f98:	2100      	movs	r1, #0
34182f9a:	2004      	movs	r0, #4
34182f9c:	f009 fc52 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34182fa0:	bf00      	nop
34182fa2:	bd80      	pop	{r7, pc}

34182fa4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34182fa4:	b480      	push	{r7}
34182fa6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34182fa8:	bf00      	nop
34182faa:	e7fd      	b.n	34182fa8 <NMI_Handler+0x4>

34182fac <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34182fac:	b480      	push	{r7}
34182fae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34182fb0:	bf00      	nop
34182fb2:	e7fd      	b.n	34182fb0 <HardFault_Handler+0x4>

34182fb4 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34182fb4:	b480      	push	{r7}
34182fb6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34182fb8:	bf00      	nop
34182fba:	e7fd      	b.n	34182fb8 <MemManage_Handler+0x4>

34182fbc <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34182fbc:	b480      	push	{r7}
34182fbe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34182fc0:	bf00      	nop
34182fc2:	e7fd      	b.n	34182fc0 <BusFault_Handler+0x4>

34182fc4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34182fc4:	b480      	push	{r7}
34182fc6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34182fc8:	bf00      	nop
34182fca:	e7fd      	b.n	34182fc8 <UsageFault_Handler+0x4>

34182fcc <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34182fcc:	b480      	push	{r7}
34182fce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34182fd0:	bf00      	nop
34182fd2:	e7fd      	b.n	34182fd0 <SecureFault_Handler+0x4>

34182fd4 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34182fd4:	b480      	push	{r7}
34182fd6:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34182fd8:	bf00      	nop
34182fda:	46bd      	mov	sp, r7
34182fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
34182fe0:	4770      	bx	lr

34182fe2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34182fe2:	b480      	push	{r7}
34182fe4:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34182fe6:	bf00      	nop
34182fe8:	46bd      	mov	sp, r7
34182fea:	f85d 7b04 	ldr.w	r7, [sp], #4
34182fee:	4770      	bx	lr

34182ff0 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
34182ff0:	b480      	push	{r7}
34182ff2:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
34182ff4:	bf00      	nop
34182ff6:	46bd      	mov	sp, r7
34182ff8:	f85d 7b04 	ldr.w	r7, [sp], #4
34182ffc:	4770      	bx	lr

34182ffe <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
34182ffe:	b580      	push	{r7, lr}
34183000:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
34183002:	f003 fa71 	bl	341864e8 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34183006:	bf00      	nop
34183008:	bd80      	pop	{r7, pc}
	...

3418300c <DCMIPP_IRQHandler>:

/**
  * @brief This function handles DCMIPP global interrupt.
  */
void DCMIPP_IRQHandler(void)
{
3418300c:	b580      	push	{r7, lr}
3418300e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DCMIPP_IRQn 0 */

  /* USER CODE END DCMIPP_IRQn 0 */
  HAL_DCMIPP_IRQHandler(&hdcmipp);
34183010:	4802      	ldr	r0, [pc, #8]	@ (3418301c <DCMIPP_IRQHandler+0x10>)
34183012:	f003 ff19 	bl	34186e48 <HAL_DCMIPP_IRQHandler>
  /* USER CODE BEGIN DCMIPP_IRQn 1 */

  /* USER CODE END DCMIPP_IRQn 1 */
}
34183016:	bf00      	nop
34183018:	bd80      	pop	{r7, pc}
3418301a:	bf00      	nop
3418301c:	341c04f8 	.word	0x341c04f8

34183020 <CSI_IRQHandler>:

/**
  * @brief This function handles CSI global interrupt.
  */
void CSI_IRQHandler(void)
{
34183020:	b580      	push	{r7, lr}
34183022:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN CSI_IRQn 0 */

  /* USER CODE END CSI_IRQn 0 */
  HAL_DCMIPP_CSI_IRQHandler(&hdcmipp);
34183024:	4802      	ldr	r0, [pc, #8]	@ (34183030 <CSI_IRQHandler+0x10>)
34183026:	f004 f8f3 	bl	34187210 <HAL_DCMIPP_CSI_IRQHandler>
  /* USER CODE BEGIN CSI_IRQn 1 */

  /* USER CODE END CSI_IRQn 1 */
}
3418302a:	bf00      	nop
3418302c:	bd80      	pop	{r7, pc}
3418302e:	bf00      	nop
34183030:	341c04f8 	.word	0x341c04f8

34183034 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
34183034:	b480      	push	{r7}
34183036:	af00      	add	r7, sp, #0
  return 1;
34183038:	2301      	movs	r3, #1
}
3418303a:	4618      	mov	r0, r3
3418303c:	46bd      	mov	sp, r7
3418303e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183042:	4770      	bx	lr

34183044 <_kill>:

int _kill(int pid, int sig)
{
34183044:	b580      	push	{r7, lr}
34183046:	b082      	sub	sp, #8
34183048:	af00      	add	r7, sp, #0
3418304a:	6078      	str	r0, [r7, #4]
3418304c:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
3418304e:	f022 fa9d 	bl	341a558c <__errno>
34183052:	4603      	mov	r3, r0
34183054:	2216      	movs	r2, #22
34183056:	601a      	str	r2, [r3, #0]
  return -1;
34183058:	f04f 33ff 	mov.w	r3, #4294967295
}
3418305c:	4618      	mov	r0, r3
3418305e:	3708      	adds	r7, #8
34183060:	46bd      	mov	sp, r7
34183062:	bd80      	pop	{r7, pc}

34183064 <_exit>:

void _exit (int status)
{
34183064:	b580      	push	{r7, lr}
34183066:	b082      	sub	sp, #8
34183068:	af00      	add	r7, sp, #0
3418306a:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
3418306c:	f04f 31ff 	mov.w	r1, #4294967295
34183070:	6878      	ldr	r0, [r7, #4]
34183072:	f7ff ffe7 	bl	34183044 <_kill>
  while (1) {}    /* Make sure we hang here */
34183076:	bf00      	nop
34183078:	e7fd      	b.n	34183076 <_exit+0x12>

3418307a <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
3418307a:	b580      	push	{r7, lr}
3418307c:	b086      	sub	sp, #24
3418307e:	af00      	add	r7, sp, #0
34183080:	60f8      	str	r0, [r7, #12]
34183082:	60b9      	str	r1, [r7, #8]
34183084:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34183086:	2300      	movs	r3, #0
34183088:	617b      	str	r3, [r7, #20]
3418308a:	e00a      	b.n	341830a2 <_read+0x28>
  {
    *ptr++ = __io_getchar();
3418308c:	f3af 8000 	nop.w
34183090:	4601      	mov	r1, r0
34183092:	68bb      	ldr	r3, [r7, #8]
34183094:	1c5a      	adds	r2, r3, #1
34183096:	60ba      	str	r2, [r7, #8]
34183098:	b2ca      	uxtb	r2, r1
3418309a:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
3418309c:	697b      	ldr	r3, [r7, #20]
3418309e:	3301      	adds	r3, #1
341830a0:	617b      	str	r3, [r7, #20]
341830a2:	697a      	ldr	r2, [r7, #20]
341830a4:	687b      	ldr	r3, [r7, #4]
341830a6:	429a      	cmp	r2, r3
341830a8:	dbf0      	blt.n	3418308c <_read+0x12>
  }

  return len;
341830aa:	687b      	ldr	r3, [r7, #4]
}
341830ac:	4618      	mov	r0, r3
341830ae:	3718      	adds	r7, #24
341830b0:	46bd      	mov	sp, r7
341830b2:	bd80      	pop	{r7, pc}

341830b4 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
341830b4:	b580      	push	{r7, lr}
341830b6:	b086      	sub	sp, #24
341830b8:	af00      	add	r7, sp, #0
341830ba:	60f8      	str	r0, [r7, #12]
341830bc:	60b9      	str	r1, [r7, #8]
341830be:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
341830c0:	2300      	movs	r3, #0
341830c2:	617b      	str	r3, [r7, #20]
341830c4:	e009      	b.n	341830da <_write+0x26>
  {
    __io_putchar(*ptr++);
341830c6:	68bb      	ldr	r3, [r7, #8]
341830c8:	1c5a      	adds	r2, r3, #1
341830ca:	60ba      	str	r2, [r7, #8]
341830cc:	781b      	ldrb	r3, [r3, #0]
341830ce:	4618      	mov	r0, r3
341830d0:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
341830d4:	697b      	ldr	r3, [r7, #20]
341830d6:	3301      	adds	r3, #1
341830d8:	617b      	str	r3, [r7, #20]
341830da:	697a      	ldr	r2, [r7, #20]
341830dc:	687b      	ldr	r3, [r7, #4]
341830de:	429a      	cmp	r2, r3
341830e0:	dbf1      	blt.n	341830c6 <_write+0x12>
  }
  return len;
341830e2:	687b      	ldr	r3, [r7, #4]
}
341830e4:	4618      	mov	r0, r3
341830e6:	3718      	adds	r7, #24
341830e8:	46bd      	mov	sp, r7
341830ea:	bd80      	pop	{r7, pc}

341830ec <_close>:

int _close(int file)
{
341830ec:	b480      	push	{r7}
341830ee:	b083      	sub	sp, #12
341830f0:	af00      	add	r7, sp, #0
341830f2:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
341830f4:	f04f 33ff 	mov.w	r3, #4294967295
}
341830f8:	4618      	mov	r0, r3
341830fa:	370c      	adds	r7, #12
341830fc:	46bd      	mov	sp, r7
341830fe:	f85d 7b04 	ldr.w	r7, [sp], #4
34183102:	4770      	bx	lr

34183104 <_fstat>:


int _fstat(int file, struct stat *st)
{
34183104:	b480      	push	{r7}
34183106:	b083      	sub	sp, #12
34183108:	af00      	add	r7, sp, #0
3418310a:	6078      	str	r0, [r7, #4]
3418310c:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
3418310e:	683b      	ldr	r3, [r7, #0]
34183110:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34183114:	605a      	str	r2, [r3, #4]
  return 0;
34183116:	2300      	movs	r3, #0
}
34183118:	4618      	mov	r0, r3
3418311a:	370c      	adds	r7, #12
3418311c:	46bd      	mov	sp, r7
3418311e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183122:	4770      	bx	lr

34183124 <_isatty>:

int _isatty(int file)
{
34183124:	b480      	push	{r7}
34183126:	b083      	sub	sp, #12
34183128:	af00      	add	r7, sp, #0
3418312a:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
3418312c:	2301      	movs	r3, #1
}
3418312e:	4618      	mov	r0, r3
34183130:	370c      	adds	r7, #12
34183132:	46bd      	mov	sp, r7
34183134:	f85d 7b04 	ldr.w	r7, [sp], #4
34183138:	4770      	bx	lr

3418313a <_lseek>:

int _lseek(int file, int ptr, int dir)
{
3418313a:	b480      	push	{r7}
3418313c:	b085      	sub	sp, #20
3418313e:	af00      	add	r7, sp, #0
34183140:	60f8      	str	r0, [r7, #12]
34183142:	60b9      	str	r1, [r7, #8]
34183144:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
34183146:	2300      	movs	r3, #0
}
34183148:	4618      	mov	r0, r3
3418314a:	3714      	adds	r7, #20
3418314c:	46bd      	mov	sp, r7
3418314e:	f85d 7b04 	ldr.w	r7, [sp], #4
34183152:	4770      	bx	lr

34183154 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
34183154:	b580      	push	{r7, lr}
34183156:	b086      	sub	sp, #24
34183158:	af00      	add	r7, sp, #0
3418315a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
3418315c:	4a14      	ldr	r2, [pc, #80]	@ (341831b0 <_sbrk+0x5c>)
3418315e:	4b15      	ldr	r3, [pc, #84]	@ (341831b4 <_sbrk+0x60>)
34183160:	1ad3      	subs	r3, r2, r3
34183162:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
34183164:	697b      	ldr	r3, [r7, #20]
34183166:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
34183168:	4b13      	ldr	r3, [pc, #76]	@ (341831b8 <_sbrk+0x64>)
3418316a:	681b      	ldr	r3, [r3, #0]
3418316c:	2b00      	cmp	r3, #0
3418316e:	d102      	bne.n	34183176 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
34183170:	4b11      	ldr	r3, [pc, #68]	@ (341831b8 <_sbrk+0x64>)
34183172:	4a12      	ldr	r2, [pc, #72]	@ (341831bc <_sbrk+0x68>)
34183174:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
34183176:	4b10      	ldr	r3, [pc, #64]	@ (341831b8 <_sbrk+0x64>)
34183178:	681a      	ldr	r2, [r3, #0]
3418317a:	687b      	ldr	r3, [r7, #4]
3418317c:	4413      	add	r3, r2
3418317e:	693a      	ldr	r2, [r7, #16]
34183180:	429a      	cmp	r2, r3
34183182:	d207      	bcs.n	34183194 <_sbrk+0x40>
  {
    errno = ENOMEM;
34183184:	f022 fa02 	bl	341a558c <__errno>
34183188:	4603      	mov	r3, r0
3418318a:	220c      	movs	r2, #12
3418318c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
3418318e:	f04f 33ff 	mov.w	r3, #4294967295
34183192:	e009      	b.n	341831a8 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
34183194:	4b08      	ldr	r3, [pc, #32]	@ (341831b8 <_sbrk+0x64>)
34183196:	681b      	ldr	r3, [r3, #0]
34183198:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
3418319a:	4b07      	ldr	r3, [pc, #28]	@ (341831b8 <_sbrk+0x64>)
3418319c:	681a      	ldr	r2, [r3, #0]
3418319e:	687b      	ldr	r3, [r7, #4]
341831a0:	4413      	add	r3, r2
341831a2:	4a05      	ldr	r2, [pc, #20]	@ (341831b8 <_sbrk+0x64>)
341831a4:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
341831a6:	68fb      	ldr	r3, [r7, #12]
}
341831a8:	4618      	mov	r0, r3
341831aa:	3718      	adds	r7, #24
341831ac:	46bd      	mov	sp, r7
341831ae:	bd80      	pop	{r7, pc}
341831b0:	34200000 	.word	0x34200000
341831b4:	00000800 	.word	0x00000800
341831b8:	341c05c8 	.word	0x341c05c8
341831bc:	341c2020 	.word	0x341c2020

341831c0 <LL_AHB4_GRP1_EnableClock>:
{
341831c0:	b480      	push	{r7}
341831c2:	b085      	sub	sp, #20
341831c4:	af00      	add	r7, sp, #0
341831c6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
341831c8:	4a07      	ldr	r2, [pc, #28]	@ (341831e8 <LL_AHB4_GRP1_EnableClock+0x28>)
341831ca:	687b      	ldr	r3, [r7, #4]
341831cc:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
341831d0:	4b05      	ldr	r3, [pc, #20]	@ (341831e8 <LL_AHB4_GRP1_EnableClock+0x28>)
341831d2:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
341831d6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341831d8:	68fb      	ldr	r3, [r7, #12]
}
341831da:	bf00      	nop
341831dc:	3714      	adds	r7, #20
341831de:	46bd      	mov	sp, r7
341831e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341831e4:	4770      	bx	lr
341831e6:	bf00      	nop
341831e8:	56028000 	.word	0x56028000

341831ec <LL_AHB5_GRP1_EnableClock>:
{
341831ec:	b480      	push	{r7}
341831ee:	b085      	sub	sp, #20
341831f0:	af00      	add	r7, sp, #0
341831f2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
341831f4:	4a07      	ldr	r2, [pc, #28]	@ (34183214 <LL_AHB5_GRP1_EnableClock+0x28>)
341831f6:	687b      	ldr	r3, [r7, #4]
341831f8:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
341831fc:	4b05      	ldr	r3, [pc, #20]	@ (34183214 <LL_AHB5_GRP1_EnableClock+0x28>)
341831fe:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34183202:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183204:	68fb      	ldr	r3, [r7, #12]
}
34183206:	bf00      	nop
34183208:	3714      	adds	r7, #20
3418320a:	46bd      	mov	sp, r7
3418320c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183210:	4770      	bx	lr
34183212:	bf00      	nop
34183214:	56028000 	.word	0x56028000

34183218 <MX_XSPI1_Init>:
XSPI_HandleTypeDef hxspi1;
XSPI_HandleTypeDef hxspi2;

/* XSPI1 init function */
void MX_XSPI1_Init(void)
{
34183218:	b580      	push	{r7, lr}
3418321a:	b084      	sub	sp, #16
3418321c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
3418321e:	1d3b      	adds	r3, r7, #4
34183220:	2200      	movs	r2, #0
34183222:	601a      	str	r2, [r3, #0]
34183224:	605a      	str	r2, [r3, #4]
34183226:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  hxspi1.Instance = XSPI1;
34183228:	4b27      	ldr	r3, [pc, #156]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418322a:	4a28      	ldr	r2, [pc, #160]	@ (341832cc <MX_XSPI1_Init+0xb4>)
3418322c:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 8;
3418322e:	4b26      	ldr	r3, [pc, #152]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183230:	2208      	movs	r2, #8
34183232:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34183234:	4b24      	ldr	r3, [pc, #144]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183236:	2200      	movs	r2, #0
34183238:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_APMEM_16BITS;
3418323a:	4b23      	ldr	r3, [pc, #140]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418323c:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
34183240:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34183242:	4b21      	ldr	r3, [pc, #132]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183244:	2218      	movs	r2, #24
34183246:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 5;
34183248:	4b1f      	ldr	r3, [pc, #124]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418324a:	2205      	movs	r2, #5
3418324c:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
3418324e:	4b1e      	ldr	r3, [pc, #120]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183250:	2200      	movs	r2, #0
34183252:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34183254:	4b1c      	ldr	r3, [pc, #112]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183256:	2200      	movs	r2, #0
34183258:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
3418325a:	4b1b      	ldr	r3, [pc, #108]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418325c:	2200      	movs	r2, #0
3418325e:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 3;
34183260:	4b19      	ldr	r3, [pc, #100]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183262:	2203      	movs	r2, #3
34183264:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34183266:	4b18      	ldr	r3, [pc, #96]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183268:	2200      	movs	r2, #0
3418326a:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
3418326c:	4b16      	ldr	r3, [pc, #88]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418326e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34183272:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34183274:	4b14      	ldr	r3, [pc, #80]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183276:	2200      	movs	r2, #0
34183278:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
3418327a:	4b13      	ldr	r3, [pc, #76]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418327c:	2200      	movs	r2, #0
3418327e:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
34183280:	4b11      	ldr	r3, [pc, #68]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183282:	2200      	movs	r2, #0
34183284:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34183286:	4b10      	ldr	r3, [pc, #64]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
34183288:	2200      	movs	r2, #0
3418328a:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
3418328c:	480e      	ldr	r0, [pc, #56]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
3418328e:	f013 f8c9 	bl	34196424 <HAL_XSPI_Init>
34183292:	4603      	mov	r3, r0
34183294:	2b00      	cmp	r3, #0
34183296:	d001      	beq.n	3418329c <MX_XSPI1_Init+0x84>
  {
    Error_Handler();
34183298:	f7ff fe62 	bl	34182f60 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3418329c:	2310      	movs	r3, #16
3418329e:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
341832a0:	2300      	movs	r3, #0
341832a2:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
341832a4:	2301      	movs	r3, #1
341832a6:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341832a8:	1d3b      	adds	r3, r7, #4
341832aa:	f241 3288 	movw	r2, #5000	@ 0x1388
341832ae:	4619      	mov	r1, r3
341832b0:	4805      	ldr	r0, [pc, #20]	@ (341832c8 <MX_XSPI1_Init+0xb0>)
341832b2:	f013 fd21 	bl	34196cf8 <HAL_XSPIM_Config>
341832b6:	4603      	mov	r3, r0
341832b8:	2b00      	cmp	r3, #0
341832ba:	d001      	beq.n	341832c0 <MX_XSPI1_Init+0xa8>
  {
    Error_Handler();
341832bc:	f7ff fe50 	bl	34182f60 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
341832c0:	bf00      	nop
341832c2:	3710      	adds	r7, #16
341832c4:	46bd      	mov	sp, r7
341832c6:	bd80      	pop	{r7, pc}
341832c8:	341c05cc 	.word	0x341c05cc
341832cc:	58025000 	.word	0x58025000

341832d0 <MX_XSPI2_Init>:
/* XSPI2 init function */
void MX_XSPI2_Init(void)
{
341832d0:	b580      	push	{r7, lr}
341832d2:	b084      	sub	sp, #16
341832d4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI2_Init 0 */

  /* USER CODE END XSPI2_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
341832d6:	1d3b      	adds	r3, r7, #4
341832d8:	2200      	movs	r2, #0
341832da:	601a      	str	r2, [r3, #0]
341832dc:	605a      	str	r2, [r3, #4]
341832de:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  hxspi2.Instance = XSPI2;
341832e0:	4b27      	ldr	r3, [pc, #156]	@ (34183380 <MX_XSPI2_Init+0xb0>)
341832e2:	4a28      	ldr	r2, [pc, #160]	@ (34183384 <MX_XSPI2_Init+0xb4>)
341832e4:	601a      	str	r2, [r3, #0]
  hxspi2.Init.FifoThresholdByte = 4;
341832e6:	4b26      	ldr	r3, [pc, #152]	@ (34183380 <MX_XSPI2_Init+0xb0>)
341832e8:	2204      	movs	r2, #4
341832ea:	605a      	str	r2, [r3, #4]
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
341832ec:	4b24      	ldr	r3, [pc, #144]	@ (34183380 <MX_XSPI2_Init+0xb0>)
341832ee:	2200      	movs	r2, #0
341832f0:	609a      	str	r2, [r3, #8]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MACRONIX;
341832f2:	4b23      	ldr	r3, [pc, #140]	@ (34183380 <MX_XSPI2_Init+0xb0>)
341832f4:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
341832f8:	60da      	str	r2, [r3, #12]
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_1GB;
341832fa:	4b21      	ldr	r3, [pc, #132]	@ (34183380 <MX_XSPI2_Init+0xb0>)
341832fc:	221a      	movs	r2, #26
341832fe:	611a      	str	r2, [r3, #16]
  hxspi2.Init.ChipSelectHighTimeCycle = 2;
34183300:	4b1f      	ldr	r3, [pc, #124]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183302:	2202      	movs	r2, #2
34183304:	615a      	str	r2, [r3, #20]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34183306:	4b1e      	ldr	r3, [pc, #120]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183308:	2200      	movs	r2, #0
3418330a:	619a      	str	r2, [r3, #24]
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
3418330c:	4b1c      	ldr	r3, [pc, #112]	@ (34183380 <MX_XSPI2_Init+0xb0>)
3418330e:	2200      	movs	r2, #0
34183310:	61da      	str	r2, [r3, #28]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34183312:	4b1b      	ldr	r3, [pc, #108]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183314:	2200      	movs	r2, #0
34183316:	621a      	str	r2, [r3, #32]
  hxspi2.Init.ClockPrescaler = 0;
34183318:	4b19      	ldr	r3, [pc, #100]	@ (34183380 <MX_XSPI2_Init+0xb0>)
3418331a:	2200      	movs	r2, #0
3418331c:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
3418331e:	4b18      	ldr	r3, [pc, #96]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183320:	2200      	movs	r2, #0
34183322:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34183324:	4b16      	ldr	r3, [pc, #88]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183326:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
3418332a:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
3418332c:	4b14      	ldr	r3, [pc, #80]	@ (34183380 <MX_XSPI2_Init+0xb0>)
3418332e:	2200      	movs	r2, #0
34183330:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi2.Init.MaxTran = 0;
34183332:	4b13      	ldr	r3, [pc, #76]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183334:	2200      	movs	r2, #0
34183336:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi2.Init.Refresh = 0;
34183338:	4b11      	ldr	r3, [pc, #68]	@ (34183380 <MX_XSPI2_Init+0xb0>)
3418333a:	2200      	movs	r2, #0
3418333c:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
3418333e:	4b10      	ldr	r3, [pc, #64]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183340:	2200      	movs	r2, #0
34183342:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34183344:	480e      	ldr	r0, [pc, #56]	@ (34183380 <MX_XSPI2_Init+0xb0>)
34183346:	f013 f86d 	bl	34196424 <HAL_XSPI_Init>
3418334a:	4603      	mov	r3, r0
3418334c:	2b00      	cmp	r3, #0
3418334e:	d001      	beq.n	34183354 <MX_XSPI2_Init+0x84>
  {
    Error_Handler();
34183350:	f7ff fe06 	bl	34182f60 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34183354:	2310      	movs	r3, #16
34183356:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34183358:	2301      	movs	r3, #1
3418335a:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
3418335c:	2301      	movs	r3, #1
3418335e:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34183360:	1d3b      	adds	r3, r7, #4
34183362:	f241 3288 	movw	r2, #5000	@ 0x1388
34183366:	4619      	mov	r1, r3
34183368:	4805      	ldr	r0, [pc, #20]	@ (34183380 <MX_XSPI2_Init+0xb0>)
3418336a:	f013 fcc5 	bl	34196cf8 <HAL_XSPIM_Config>
3418336e:	4603      	mov	r3, r0
34183370:	2b00      	cmp	r3, #0
34183372:	d001      	beq.n	34183378 <MX_XSPI2_Init+0xa8>
  {
    Error_Handler();
34183374:	f7ff fdf4 	bl	34182f60 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
34183378:	bf00      	nop
3418337a:	3710      	adds	r7, #16
3418337c:	46bd      	mov	sp, r7
3418337e:	bd80      	pop	{r7, pc}
34183380:	341c0630 	.word	0x341c0630
34183384:	5802a000 	.word	0x5802a000

34183388 <HAL_XSPI_MspInit>:

static uint32_t HAL_RCC_XSPIM_CLK_ENABLED=0;

void HAL_XSPI_MspInit(XSPI_HandleTypeDef* xspiHandle)
{
34183388:	b580      	push	{r7, lr}
3418338a:	b0ec      	sub	sp, #432	@ 0x1b0
3418338c:	af00      	add	r7, sp, #0
3418338e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34183392:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34183396:	6018      	str	r0, [r3, #0]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
34183398:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3418339c:	2200      	movs	r2, #0
3418339e:	601a      	str	r2, [r3, #0]
341833a0:	605a      	str	r2, [r3, #4]
341833a2:	609a      	str	r2, [r3, #8]
341833a4:	60da      	str	r2, [r3, #12]
341833a6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
341833a8:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341833ac:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341833b0:	4618      	mov	r0, r3
341833b2:	f44f 73c8 	mov.w	r3, #400	@ 0x190
341833b6:	461a      	mov	r2, r3
341833b8:	2100      	movs	r1, #0
341833ba:	f022 f899 	bl	341a54f0 <memset>
  if(xspiHandle->Instance==XSPI1)
341833be:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341833c2:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
341833c6:	681b      	ldr	r3, [r3, #0]
341833c8:	681b      	ldr	r3, [r3, #0]
341833ca:	4a5b      	ldr	r2, [pc, #364]	@ (34183538 <HAL_XSPI_MspInit+0x1b0>)
341833cc:	4293      	cmp	r3, r2
341833ce:	d15e      	bne.n	3418348e <HAL_XSPI_MspInit+0x106>

  /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
341833d0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341833d4:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
341833d8:	f04f 0200 	mov.w	r2, #0
341833dc:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
341833e0:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
341833e4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341833e8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341833ec:	4a53      	ldr	r2, [pc, #332]	@ (3418353c <HAL_XSPI_MspInit+0x1b4>)
341833ee:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
341833f2:	f107 0308 	add.w	r3, r7, #8
341833f6:	4618      	mov	r0, r3
341833f8:	f00c fac2 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
341833fc:	4603      	mov	r3, r0
341833fe:	2b00      	cmp	r3, #0
34183400:	d001      	beq.n	34183406 <HAL_XSPI_MspInit+0x7e>
    {
      Error_Handler();
34183402:	f7ff fdad 	bl	34182f60 <Error_Handler>
    }

    /* XSPI1 clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34183406:	4b4e      	ldr	r3, [pc, #312]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
34183408:	681b      	ldr	r3, [r3, #0]
3418340a:	3301      	adds	r3, #1
3418340c:	4a4c      	ldr	r2, [pc, #304]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
3418340e:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34183410:	4b4b      	ldr	r3, [pc, #300]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
34183412:	681b      	ldr	r3, [r3, #0]
34183414:	2b01      	cmp	r3, #1
34183416:	d103      	bne.n	34183420 <HAL_XSPI_MspInit+0x98>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34183418:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418341c:	f7ff fee6 	bl	341831ec <LL_AHB5_GRP1_EnableClock>
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
34183420:	2020      	movs	r0, #32
34183422:	f7ff fee3 	bl	341831ec <LL_AHB5_GRP1_EnableClock>

    __HAL_RCC_GPIOP_CLK_ENABLE();
34183426:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418342a:	f7ff fec9 	bl	341831c0 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOO_CLK_ENABLE();
3418342e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34183432:	f7ff fec5 	bl	341831c0 <LL_AHB4_GRP1_EnableClock>
    PO0     ------> XSPIM_P1_NCS1
    PP9     ------> XSPIM_P1_IO9
    PP10     ------> XSPIM_P1_IO10
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_0|GPIO_PIN_4
34183436:	f64f 73ff 	movw	r3, #65535	@ 0xffff
3418343a:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_5|GPIO_PIN_12
                          |GPIO_PIN_3|GPIO_PIN_2|GPIO_PIN_13|GPIO_PIN_11
                          |GPIO_PIN_8|GPIO_PIN_14|GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3418343e:	2302      	movs	r3, #2
34183440:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34183444:	2300      	movs	r3, #0
34183446:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3418344a:	2303      	movs	r3, #3
3418344c:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34183450:	2309      	movs	r3, #9
34183452:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34183456:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3418345a:	4619      	mov	r1, r3
3418345c:	4839      	ldr	r0, [pc, #228]	@ (34183544 <HAL_XSPI_MspInit+0x1bc>)
3418345e:	f006 fe6d 	bl	3418a13c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_0|GPIO_PIN_4;
34183462:	231d      	movs	r3, #29
34183464:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34183468:	2302      	movs	r3, #2
3418346a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418346e:	2300      	movs	r3, #0
34183470:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34183474:	2303      	movs	r3, #3
34183476:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
3418347a:	2309      	movs	r3, #9
3418347c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34183480:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34183484:	4619      	mov	r1, r3
34183486:	4830      	ldr	r0, [pc, #192]	@ (34183548 <HAL_XSPI_MspInit+0x1c0>)
34183488:	f006 fe58 	bl	3418a13c <HAL_GPIO_Init>

  /* USER CODE BEGIN XSPI2_MspInit 1 */

  /* USER CODE END XSPI2_MspInit 1 */
  }
}
3418348c:	e04e      	b.n	3418352c <HAL_XSPI_MspInit+0x1a4>
  else if(xspiHandle->Instance==XSPI2)
3418348e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34183492:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34183496:	681b      	ldr	r3, [r3, #0]
34183498:	681b      	ldr	r3, [r3, #0]
3418349a:	4a2c      	ldr	r2, [pc, #176]	@ (3418354c <HAL_XSPI_MspInit+0x1c4>)
3418349c:	4293      	cmp	r3, r2
3418349e:	d145      	bne.n	3418352c <HAL_XSPI_MspInit+0x1a4>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
341834a0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341834a4:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
341834a8:	f04f 0200 	mov.w	r2, #0
341834ac:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
341834b0:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
341834b4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
341834b8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
341834bc:	4a24      	ldr	r2, [pc, #144]	@ (34183550 <HAL_XSPI_MspInit+0x1c8>)
341834be:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
341834c2:	f107 0308 	add.w	r3, r7, #8
341834c6:	4618      	mov	r0, r3
341834c8:	f00c fa5a 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
341834cc:	4603      	mov	r3, r0
341834ce:	2b00      	cmp	r3, #0
341834d0:	d001      	beq.n	341834d6 <HAL_XSPI_MspInit+0x14e>
      Error_Handler();
341834d2:	f7ff fd45 	bl	34182f60 <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
341834d6:	4b1a      	ldr	r3, [pc, #104]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
341834d8:	681b      	ldr	r3, [r3, #0]
341834da:	3301      	adds	r3, #1
341834dc:	4a18      	ldr	r2, [pc, #96]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
341834de:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
341834e0:	4b17      	ldr	r3, [pc, #92]	@ (34183540 <HAL_XSPI_MspInit+0x1b8>)
341834e2:	681b      	ldr	r3, [r3, #0]
341834e4:	2b01      	cmp	r3, #1
341834e6:	d103      	bne.n	341834f0 <HAL_XSPI_MspInit+0x168>
      __HAL_RCC_XSPIM_CLK_ENABLE();
341834e8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341834ec:	f7ff fe7e 	bl	341831ec <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_XSPI2_CLK_ENABLE();
341834f0:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
341834f4:	f7ff fe7a 	bl	341831ec <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_GPION_CLK_ENABLE();
341834f8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
341834fc:	f7ff fe60 	bl	341831c0 <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_0
34183500:	f640 737f 	movw	r3, #3967	@ 0xf7f
34183504:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34183508:	2302      	movs	r3, #2
3418350a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3418350e:	2300      	movs	r3, #0
34183510:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34183514:	2303      	movs	r3, #3
34183516:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
3418351a:	2309      	movs	r3, #9
3418351c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34183520:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34183524:	4619      	mov	r1, r3
34183526:	480b      	ldr	r0, [pc, #44]	@ (34183554 <HAL_XSPI_MspInit+0x1cc>)
34183528:	f006 fe08 	bl	3418a13c <HAL_GPIO_Init>
}
3418352c:	bf00      	nop
3418352e:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34183532:	46bd      	mov	sp, r7
34183534:	bd80      	pop	{r7, pc}
34183536:	bf00      	nop
34183538:	58025000 	.word	0x58025000
3418353c:	03000014 	.word	0x03000014
34183540:	341c0694 	.word	0x341c0694
34183544:	56023c00 	.word	0x56023c00
34183548:	56023800 	.word	0x56023800
3418354c:	5802a000 	.word	0x5802a000
34183550:	03000414 	.word	0x03000414
34183554:	56023400 	.word	0x56023400

34183558 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34183558:	480f      	ldr	r0, [pc, #60]	@ (34183598 <LoopForever+0x4>)
  msr   MSPLIM, r0
3418355a:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
3418355e:	480f      	ldr	r0, [pc, #60]	@ (3418359c <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34183560:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34183562:	f000 f829 	bl	341835b8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34183566:	480e      	ldr	r0, [pc, #56]	@ (341835a0 <LoopForever+0xc>)
  ldr r1, =_edata
34183568:	490e      	ldr	r1, [pc, #56]	@ (341835a4 <LoopForever+0x10>)
  ldr r2, =_sidata
3418356a:	4a0f      	ldr	r2, [pc, #60]	@ (341835a8 <LoopForever+0x14>)
  movs r3, #0
3418356c:	2300      	movs	r3, #0
  b LoopCopyDataInit
3418356e:	e002      	b.n	34183576 <LoopCopyDataInit>

34183570 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34183570:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34183572:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34183574:	3304      	adds	r3, #4

34183576 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34183576:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34183578:	428c      	cmp	r4, r1
  bcc CopyDataInit
3418357a:	d3f9      	bcc.n	34183570 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
3418357c:	4a0b      	ldr	r2, [pc, #44]	@ (341835ac <LoopForever+0x18>)
  ldr r4, =_ebss
3418357e:	4c0c      	ldr	r4, [pc, #48]	@ (341835b0 <LoopForever+0x1c>)
  movs r3, #0
34183580:	2300      	movs	r3, #0
  b LoopFillZerobss
34183582:	e001      	b.n	34183588 <LoopFillZerobss>

34183584 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34183584:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34183586:	3204      	adds	r2, #4

34183588 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34183588:	42a2      	cmp	r2, r4
  bcc FillZerobss
3418358a:	d3fb      	bcc.n	34183584 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
3418358c:	f022 f804 	bl	341a5598 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34183590:	f7ff f9b0 	bl	341828f4 <main>

34183594 <LoopForever>:

LoopForever:
  b LoopForever
34183594:	e7fe      	b.n	34183594 <LoopForever>
34183596:	0000      	.short	0x0000
  ldr   r0, =_sstack
34183598:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
3418359c:	34200000 	.word	0x34200000
  ldr r0, =_sdata
341835a0:	341c0000 	.word	0x341c0000
  ldr r1, =_edata
341835a4:	341c0194 	.word	0x341c0194
  ldr r2, =_sidata
341835a8:	341b203c 	.word	0x341b203c
  ldr r2, =_sbss
341835ac:	341c0198 	.word	0x341c0198
  ldr r4, =_ebss
341835b0:	341c201c 	.word	0x341c201c

341835b4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
341835b4:	e7fe      	b.n	341835b4 <ADC1_2_IRQHandler>
	...

341835b8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
341835b8:	b480      	push	{r7}
341835ba:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
341835bc:	4b6a      	ldr	r3, [pc, #424]	@ (34183768 <SystemInit+0x1b0>)
341835be:	4a6b      	ldr	r2, [pc, #428]	@ (3418376c <SystemInit+0x1b4>)
341835c0:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* RNG reset */
  RCC->AHB3RSTSR = RCC_AHB3RSTSR_RNGRSTS;
341835c2:	4b6b      	ldr	r3, [pc, #428]	@ (34183770 <SystemInit+0x1b8>)
341835c4:	2201      	movs	r2, #1
341835c6:	f8c3 2a18 	str.w	r2, [r3, #2584]	@ 0xa18
  RCC->AHB3RSTCR = RCC_AHB3RSTCR_RNGRSTC;
341835ca:	4b69      	ldr	r3, [pc, #420]	@ (34183770 <SystemInit+0x1b8>)
341835cc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341835d0:	461a      	mov	r2, r3
341835d2:	2301      	movs	r3, #1
341835d4:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
  /* Deactivate RNG clock */
  RCC->AHB3ENCR = RCC_AHB3ENCR_RNGENC;
341835d8:	4b65      	ldr	r3, [pc, #404]	@ (34183770 <SystemInit+0x1b8>)
341835da:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341835de:	461a      	mov	r2, r3
341835e0:	2301      	movs	r3, #1
341835e2:	f8c2 3258 	str.w	r3, [r2, #600]	@ 0x258

  /* Clear SAU regions */
  SAU->RNR = 0;
341835e6:	4b63      	ldr	r3, [pc, #396]	@ (34183774 <SystemInit+0x1bc>)
341835e8:	2200      	movs	r2, #0
341835ea:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341835ec:	4b61      	ldr	r3, [pc, #388]	@ (34183774 <SystemInit+0x1bc>)
341835ee:	2200      	movs	r2, #0
341835f0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
341835f2:	4b60      	ldr	r3, [pc, #384]	@ (34183774 <SystemInit+0x1bc>)
341835f4:	2200      	movs	r2, #0
341835f6:	611a      	str	r2, [r3, #16]
  SAU->RNR = 1;
341835f8:	4b5e      	ldr	r3, [pc, #376]	@ (34183774 <SystemInit+0x1bc>)
341835fa:	2201      	movs	r2, #1
341835fc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
341835fe:	4b5d      	ldr	r3, [pc, #372]	@ (34183774 <SystemInit+0x1bc>)
34183600:	2200      	movs	r2, #0
34183602:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183604:	4b5b      	ldr	r3, [pc, #364]	@ (34183774 <SystemInit+0x1bc>)
34183606:	2200      	movs	r2, #0
34183608:	611a      	str	r2, [r3, #16]
  SAU->RNR = 2;
3418360a:	4b5a      	ldr	r3, [pc, #360]	@ (34183774 <SystemInit+0x1bc>)
3418360c:	2202      	movs	r2, #2
3418360e:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183610:	4b58      	ldr	r3, [pc, #352]	@ (34183774 <SystemInit+0x1bc>)
34183612:	2200      	movs	r2, #0
34183614:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183616:	4b57      	ldr	r3, [pc, #348]	@ (34183774 <SystemInit+0x1bc>)
34183618:	2200      	movs	r2, #0
3418361a:	611a      	str	r2, [r3, #16]
  SAU->RNR = 3;
3418361c:	4b55      	ldr	r3, [pc, #340]	@ (34183774 <SystemInit+0x1bc>)
3418361e:	2203      	movs	r2, #3
34183620:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183622:	4b54      	ldr	r3, [pc, #336]	@ (34183774 <SystemInit+0x1bc>)
34183624:	2200      	movs	r2, #0
34183626:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183628:	4b52      	ldr	r3, [pc, #328]	@ (34183774 <SystemInit+0x1bc>)
3418362a:	2200      	movs	r2, #0
3418362c:	611a      	str	r2, [r3, #16]
  SAU->RNR = 4;
3418362e:	4b51      	ldr	r3, [pc, #324]	@ (34183774 <SystemInit+0x1bc>)
34183630:	2204      	movs	r2, #4
34183632:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183634:	4b4f      	ldr	r3, [pc, #316]	@ (34183774 <SystemInit+0x1bc>)
34183636:	2200      	movs	r2, #0
34183638:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418363a:	4b4e      	ldr	r3, [pc, #312]	@ (34183774 <SystemInit+0x1bc>)
3418363c:	2200      	movs	r2, #0
3418363e:	611a      	str	r2, [r3, #16]
  SAU->RNR = 5;
34183640:	4b4c      	ldr	r3, [pc, #304]	@ (34183774 <SystemInit+0x1bc>)
34183642:	2205      	movs	r2, #5
34183644:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183646:	4b4b      	ldr	r3, [pc, #300]	@ (34183774 <SystemInit+0x1bc>)
34183648:	2200      	movs	r2, #0
3418364a:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418364c:	4b49      	ldr	r3, [pc, #292]	@ (34183774 <SystemInit+0x1bc>)
3418364e:	2200      	movs	r2, #0
34183650:	611a      	str	r2, [r3, #16]
  SAU->RNR = 6;
34183652:	4b48      	ldr	r3, [pc, #288]	@ (34183774 <SystemInit+0x1bc>)
34183654:	2206      	movs	r2, #6
34183656:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
34183658:	4b46      	ldr	r3, [pc, #280]	@ (34183774 <SystemInit+0x1bc>)
3418365a:	2200      	movs	r2, #0
3418365c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
3418365e:	4b45      	ldr	r3, [pc, #276]	@ (34183774 <SystemInit+0x1bc>)
34183660:	2200      	movs	r2, #0
34183662:	611a      	str	r2, [r3, #16]
  SAU->RNR = 7;
34183664:	4b43      	ldr	r3, [pc, #268]	@ (34183774 <SystemInit+0x1bc>)
34183666:	2207      	movs	r2, #7
34183668:	609a      	str	r2, [r3, #8]
  SAU->RBAR = 0;
3418366a:	4b42      	ldr	r3, [pc, #264]	@ (34183774 <SystemInit+0x1bc>)
3418366c:	2200      	movs	r2, #0
3418366e:	60da      	str	r2, [r3, #12]
  SAU->RLAR = 0;
34183670:	4b40      	ldr	r3, [pc, #256]	@ (34183774 <SystemInit+0x1bc>)
34183672:	2200      	movs	r2, #0
34183674:	611a      	str	r2, [r3, #16]

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34183676:	4b3e      	ldr	r3, [pc, #248]	@ (34183770 <SystemInit+0x1b8>)
34183678:	2201      	movs	r2, #1
3418367a:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
3418367e:	4b3c      	ldr	r3, [pc, #240]	@ (34183770 <SystemInit+0x1b8>)
34183680:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34183684:	4b38      	ldr	r3, [pc, #224]	@ (34183768 <SystemInit+0x1b0>)
34183686:	4a3c      	ldr	r2, [pc, #240]	@ (34183778 <SystemInit+0x1c0>)
34183688:	689b      	ldr	r3, [r3, #8]
3418368a:	6113      	str	r3, [r2, #16]

  /* Enable VDDADC CLAMP */
  PWR->SVMCR3 |= PWR_SVMCR3_ASV;
3418368c:	4b3b      	ldr	r3, [pc, #236]	@ (3418377c <SystemInit+0x1c4>)
3418368e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34183690:	4a3a      	ldr	r2, [pc, #232]	@ (3418377c <SystemInit+0x1c4>)
34183692:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
34183696:	63d3      	str	r3, [r2, #60]	@ 0x3c
  PWR->SVMCR3 |= PWR_SVMCR3_AVMEN;
34183698:	4b38      	ldr	r3, [pc, #224]	@ (3418377c <SystemInit+0x1c4>)
3418369a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418369c:	4a37      	ldr	r2, [pc, #220]	@ (3418377c <SystemInit+0x1c4>)
3418369e:	f043 0310 	orr.w	r3, r3, #16
341836a2:	63d3      	str	r3, [r2, #60]	@ 0x3c
  /* read back the register to make sure that the transaction has taken place */
  (void) PWR->SVMCR3;
341836a4:	4b35      	ldr	r3, [pc, #212]	@ (3418377c <SystemInit+0x1c4>)
341836a6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
  /* enable VREF */
  RCC->APB4ENR1 |= RCC_APB4ENR1_VREFBUFEN;
341836a8:	4b31      	ldr	r3, [pc, #196]	@ (34183770 <SystemInit+0x1b8>)
341836aa:	f8d3 3274 	ldr.w	r3, [r3, #628]	@ 0x274
341836ae:	4a30      	ldr	r2, [pc, #192]	@ (34183770 <SystemInit+0x1b8>)
341836b0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
341836b4:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274

  /* RCC Fix to lower power consumption */
  RCC->APB4ENR2 |= 0x00000010UL;
341836b8:	4b2d      	ldr	r3, [pc, #180]	@ (34183770 <SystemInit+0x1b8>)
341836ba:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
341836be:	4a2c      	ldr	r2, [pc, #176]	@ (34183770 <SystemInit+0x1b8>)
341836c0:	f043 0310 	orr.w	r3, r3, #16
341836c4:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  (void) RCC->APB4ENR2;
341836c8:	4b29      	ldr	r3, [pc, #164]	@ (34183770 <SystemInit+0x1b8>)
341836ca:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
  RCC->APB4ENR2 &= ~(0x00000010UL);
341836ce:	4b28      	ldr	r3, [pc, #160]	@ (34183770 <SystemInit+0x1b8>)
341836d0:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278
341836d4:	4a26      	ldr	r2, [pc, #152]	@ (34183770 <SystemInit+0x1b8>)
341836d6:	f023 0310 	bic.w	r3, r3, #16
341836da:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278

  /* XSPI2 & XSPIM reset                                  */
  RCC->AHB5RSTSR = RCC_AHB5RSTSR_XSPIMRSTS | RCC_AHB5RSTSR_XSPI2RSTS;
341836de:	4b24      	ldr	r3, [pc, #144]	@ (34183770 <SystemInit+0x1b8>)
341836e0:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
341836e4:	f8c3 2a20 	str.w	r2, [r3, #2592]	@ 0xa20
  RCC->AHB5RSTCR = RCC_AHB5RSTCR_XSPIMRSTC | RCC_AHB5RSTCR_XSPI2RSTC;
341836e8:	4b21      	ldr	r3, [pc, #132]	@ (34183770 <SystemInit+0x1b8>)
341836ea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341836ee:	461a      	mov	r2, r3
341836f0:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341836f4:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220

  /* TIM2 reset */
  RCC->APB1RSTSR1 = RCC_APB1RSTSR1_TIM2RSTS;
341836f8:	4b1d      	ldr	r3, [pc, #116]	@ (34183770 <SystemInit+0x1b8>)
341836fa:	2201      	movs	r2, #1
341836fc:	f8c3 2a24 	str.w	r2, [r3, #2596]	@ 0xa24
  RCC->APB1RSTCR1 = RCC_APB1RSTCR1_TIM2RSTC;
34183700:	4b1b      	ldr	r3, [pc, #108]	@ (34183770 <SystemInit+0x1b8>)
34183702:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183706:	461a      	mov	r2, r3
34183708:	2301      	movs	r3, #1
3418370a:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
  /* Deactivate TIM2 clock */
  RCC->APB1ENCR1 = RCC_APB1ENCR1_TIM2ENC;
3418370e:	4b18      	ldr	r3, [pc, #96]	@ (34183770 <SystemInit+0x1b8>)
34183710:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183714:	461a      	mov	r2, r3
34183716:	2301      	movs	r3, #1
34183718:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264

  /* Deactivate GPIOG clock */
  RCC->AHB4ENCR = RCC_AHB4ENCR_GPIOGENC;
3418371c:	4b14      	ldr	r3, [pc, #80]	@ (34183770 <SystemInit+0x1b8>)
3418371e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183722:	461a      	mov	r2, r3
34183724:	2340      	movs	r3, #64	@ 0x40
34183726:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c

  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
3418372a:	4b13      	ldr	r3, [pc, #76]	@ (34183778 <SystemInit+0x1c0>)
3418372c:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
3418372e:	4b10      	ldr	r3, [pc, #64]	@ (34183770 <SystemInit+0x1b8>)
34183730:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183734:	461a      	mov	r2, r3
34183736:	2301      	movs	r3, #1
34183738:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  TZ_SAU_Setup();
#endif /* USER_TZ_SAU_SETUP */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
3418373c:	4b0a      	ldr	r3, [pc, #40]	@ (34183768 <SystemInit+0x1b0>)
3418373e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34183742:	4a09      	ldr	r2, [pc, #36]	@ (34183768 <SystemInit+0x1b0>)
34183744:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34183748:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
3418374c:	4b0c      	ldr	r3, [pc, #48]	@ (34183780 <SystemInit+0x1c8>)
3418374e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34183752:	4a0b      	ldr	r2, [pc, #44]	@ (34183780 <SystemInit+0x1c8>)
34183754:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34183758:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
3418375c:	bf00      	nop
3418375e:	46bd      	mov	sp, r7
34183760:	f85d 7b04 	ldr.w	r7, [sp], #4
34183764:	4770      	bx	lr
34183766:	bf00      	nop
34183768:	e000ed00 	.word	0xe000ed00
3418376c:	34180400 	.word	0x34180400
34183770:	56028000 	.word	0x56028000
34183774:	e000edd0 	.word	0xe000edd0
34183778:	56008000 	.word	0x56008000
3418377c:	56024800 	.word	0x56024800
34183780:	e002ed00 	.word	0xe002ed00

34183784 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34183784:	b480      	push	{r7}
34183786:	b08d      	sub	sp, #52	@ 0x34
34183788:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
3418378a:	2300      	movs	r3, #0
3418378c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
3418378e:	2300      	movs	r3, #0
34183790:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34183792:	2300      	movs	r3, #0
34183794:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34183796:	2300      	movs	r3, #0
34183798:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
3418379a:	2300      	movs	r3, #0
3418379c:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
3418379e:	2300      	movs	r3, #0
341837a0:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
341837a2:	4b9b      	ldr	r3, [pc, #620]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341837a4:	6a1b      	ldr	r3, [r3, #32]
341837a6:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
341837aa:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341837ae:	d029      	beq.n	34183804 <SystemCoreClockUpdate+0x80>
341837b0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341837b4:	f200 8180 	bhi.w	34183ab8 <SystemCoreClockUpdate+0x334>
341837b8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341837bc:	d01f      	beq.n	341837fe <SystemCoreClockUpdate+0x7a>
341837be:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341837c2:	f200 8179 	bhi.w	34183ab8 <SystemCoreClockUpdate+0x334>
341837c6:	2b00      	cmp	r3, #0
341837c8:	d003      	beq.n	341837d2 <SystemCoreClockUpdate+0x4e>
341837ca:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341837ce:	d00a      	beq.n	341837e6 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
341837d0:	e172      	b.n	34183ab8 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
341837d2:	4b8f      	ldr	r3, [pc, #572]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341837d4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341837d6:	09db      	lsrs	r3, r3, #7
341837d8:	f003 0303 	and.w	r3, r3, #3
341837dc:	4a8d      	ldr	r2, [pc, #564]	@ (34183a14 <SystemCoreClockUpdate+0x290>)
341837de:	fa22 f303 	lsr.w	r3, r2, r3
341837e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341837e4:	e169      	b.n	34183aba <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
341837e6:	4b8a      	ldr	r3, [pc, #552]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341837e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341837ea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341837ee:	2b00      	cmp	r3, #0
341837f0:	d102      	bne.n	341837f8 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
341837f2:	4b89      	ldr	r3, [pc, #548]	@ (34183a18 <SystemCoreClockUpdate+0x294>)
341837f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341837f6:	e160      	b.n	34183aba <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
341837f8:	4b88      	ldr	r3, [pc, #544]	@ (34183a1c <SystemCoreClockUpdate+0x298>)
341837fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
341837fc:	e15d      	b.n	34183aba <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
341837fe:	4b88      	ldr	r3, [pc, #544]	@ (34183a20 <SystemCoreClockUpdate+0x29c>)
34183800:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34183802:	e15a      	b.n	34183aba <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34183804:	4b82      	ldr	r3, [pc, #520]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183806:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418380a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
3418380e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183812:	d066      	beq.n	341838e2 <SystemCoreClockUpdate+0x15e>
34183814:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34183818:	f200 8091 	bhi.w	3418393e <SystemCoreClockUpdate+0x1ba>
3418381c:	2b00      	cmp	r3, #0
3418381e:	d003      	beq.n	34183828 <SystemCoreClockUpdate+0xa4>
34183820:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34183824:	d02f      	beq.n	34183886 <SystemCoreClockUpdate+0x102>
34183826:	e08a      	b.n	3418393e <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34183828:	4b79      	ldr	r3, [pc, #484]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
3418382a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418382e:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34183830:	68fb      	ldr	r3, [r7, #12]
34183832:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34183836:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34183838:	68fb      	ldr	r3, [r7, #12]
3418383a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418383e:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34183840:	693b      	ldr	r3, [r7, #16]
34183842:	2b00      	cmp	r3, #0
34183844:	f040 80a9 	bne.w	3418399a <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34183848:	68fb      	ldr	r3, [r7, #12]
3418384a:	0d1b      	lsrs	r3, r3, #20
3418384c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34183850:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34183852:	68fb      	ldr	r3, [r7, #12]
34183854:	0a1b      	lsrs	r3, r3, #8
34183856:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418385a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
3418385c:	4b6c      	ldr	r3, [pc, #432]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
3418385e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34183862:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34183866:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34183868:	4b69      	ldr	r3, [pc, #420]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
3418386a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418386e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34183870:	68fb      	ldr	r3, [r7, #12]
34183872:	0edb      	lsrs	r3, r3, #27
34183874:	f003 0307 	and.w	r3, r3, #7
34183878:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
3418387a:	68fb      	ldr	r3, [r7, #12]
3418387c:	0e1b      	lsrs	r3, r3, #24
3418387e:	f003 0307 	and.w	r3, r3, #7
34183882:	61bb      	str	r3, [r7, #24]
      break;
34183884:	e089      	b.n	3418399a <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34183886:	4b62      	ldr	r3, [pc, #392]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183888:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418388c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
3418388e:	68fb      	ldr	r3, [r7, #12]
34183890:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34183894:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34183896:	68fb      	ldr	r3, [r7, #12]
34183898:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418389c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3418389e:	693b      	ldr	r3, [r7, #16]
341838a0:	2b00      	cmp	r3, #0
341838a2:	d17c      	bne.n	3418399e <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
341838a4:	68fb      	ldr	r3, [r7, #12]
341838a6:	0d1b      	lsrs	r3, r3, #20
341838a8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341838ac:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
341838ae:	68fb      	ldr	r3, [r7, #12]
341838b0:	0a1b      	lsrs	r3, r3, #8
341838b2:	f3c3 030b 	ubfx	r3, r3, #0, #12
341838b6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
341838b8:	4b55      	ldr	r3, [pc, #340]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341838ba:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341838be:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341838c2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
341838c4:	4b52      	ldr	r3, [pc, #328]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341838c6:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
341838ca:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
341838cc:	68fb      	ldr	r3, [r7, #12]
341838ce:	0edb      	lsrs	r3, r3, #27
341838d0:	f003 0307 	and.w	r3, r3, #7
341838d4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
341838d6:	68fb      	ldr	r3, [r7, #12]
341838d8:	0e1b      	lsrs	r3, r3, #24
341838da:	f003 0307 	and.w	r3, r3, #7
341838de:	61bb      	str	r3, [r7, #24]
      break;
341838e0:	e05d      	b.n	3418399e <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
341838e2:	4b4b      	ldr	r3, [pc, #300]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341838e4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
341838e8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
341838ea:	68fb      	ldr	r3, [r7, #12]
341838ec:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
341838f0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
341838f2:	68fb      	ldr	r3, [r7, #12]
341838f4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
341838f8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
341838fa:	693b      	ldr	r3, [r7, #16]
341838fc:	2b00      	cmp	r3, #0
341838fe:	d150      	bne.n	341839a2 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34183900:	68fb      	ldr	r3, [r7, #12]
34183902:	0d1b      	lsrs	r3, r3, #20
34183904:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34183908:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
3418390a:	68fb      	ldr	r3, [r7, #12]
3418390c:	0a1b      	lsrs	r3, r3, #8
3418390e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34183912:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34183914:	4b3e      	ldr	r3, [pc, #248]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183916:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418391a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418391e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34183920:	4b3b      	ldr	r3, [pc, #236]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183922:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34183926:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34183928:	68fb      	ldr	r3, [r7, #12]
3418392a:	0edb      	lsrs	r3, r3, #27
3418392c:	f003 0307 	and.w	r3, r3, #7
34183930:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34183932:	68fb      	ldr	r3, [r7, #12]
34183934:	0e1b      	lsrs	r3, r3, #24
34183936:	f003 0307 	and.w	r3, r3, #7
3418393a:	61bb      	str	r3, [r7, #24]
      break;
3418393c:	e031      	b.n	341839a2 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
3418393e:	4b34      	ldr	r3, [pc, #208]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183940:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34183944:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34183946:	68fb      	ldr	r3, [r7, #12]
34183948:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3418394c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
3418394e:	68fb      	ldr	r3, [r7, #12]
34183950:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34183954:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34183956:	693b      	ldr	r3, [r7, #16]
34183958:	2b00      	cmp	r3, #0
3418395a:	d124      	bne.n	341839a6 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
3418395c:	68fb      	ldr	r3, [r7, #12]
3418395e:	0d1b      	lsrs	r3, r3, #20
34183960:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34183964:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34183966:	68fb      	ldr	r3, [r7, #12]
34183968:	0a1b      	lsrs	r3, r3, #8
3418396a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418396e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34183970:	4b27      	ldr	r3, [pc, #156]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
34183972:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34183976:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3418397a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
3418397c:	4b24      	ldr	r3, [pc, #144]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
3418397e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34183982:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34183984:	68fb      	ldr	r3, [r7, #12]
34183986:	0edb      	lsrs	r3, r3, #27
34183988:	f003 0307 	and.w	r3, r3, #7
3418398c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
3418398e:	68fb      	ldr	r3, [r7, #12]
34183990:	0e1b      	lsrs	r3, r3, #24
34183992:	f003 0307 	and.w	r3, r3, #7
34183996:	61bb      	str	r3, [r7, #24]
      break;
34183998:	e005      	b.n	341839a6 <SystemCoreClockUpdate+0x222>
      break;
3418399a:	bf00      	nop
3418399c:	e004      	b.n	341839a8 <SystemCoreClockUpdate+0x224>
      break;
3418399e:	bf00      	nop
341839a0:	e002      	b.n	341839a8 <SystemCoreClockUpdate+0x224>
      break;
341839a2:	bf00      	nop
341839a4:	e000      	b.n	341839a8 <SystemCoreClockUpdate+0x224>
      break;
341839a6:	bf00      	nop
    switch (pllsource)
341839a8:	697b      	ldr	r3, [r7, #20]
341839aa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341839ae:	d02c      	beq.n	34183a0a <SystemCoreClockUpdate+0x286>
341839b0:	697b      	ldr	r3, [r7, #20]
341839b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341839b6:	d839      	bhi.n	34183a2c <SystemCoreClockUpdate+0x2a8>
341839b8:	697b      	ldr	r3, [r7, #20]
341839ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341839be:	d021      	beq.n	34183a04 <SystemCoreClockUpdate+0x280>
341839c0:	697b      	ldr	r3, [r7, #20]
341839c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341839c6:	d831      	bhi.n	34183a2c <SystemCoreClockUpdate+0x2a8>
341839c8:	697b      	ldr	r3, [r7, #20]
341839ca:	2b00      	cmp	r3, #0
341839cc:	d004      	beq.n	341839d8 <SystemCoreClockUpdate+0x254>
341839ce:	697b      	ldr	r3, [r7, #20]
341839d0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341839d4:	d00a      	beq.n	341839ec <SystemCoreClockUpdate+0x268>
      break;
341839d6:	e029      	b.n	34183a2c <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
341839d8:	4b0d      	ldr	r3, [pc, #52]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341839da:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341839dc:	09db      	lsrs	r3, r3, #7
341839de:	f003 0303 	and.w	r3, r3, #3
341839e2:	4a0c      	ldr	r2, [pc, #48]	@ (34183a14 <SystemCoreClockUpdate+0x290>)
341839e4:	fa22 f303 	lsr.w	r3, r2, r3
341839e8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
341839ea:	e020      	b.n	34183a2e <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
341839ec:	4b08      	ldr	r3, [pc, #32]	@ (34183a10 <SystemCoreClockUpdate+0x28c>)
341839ee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341839f0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341839f4:	2b00      	cmp	r3, #0
341839f6:	d102      	bne.n	341839fe <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
341839f8:	4b07      	ldr	r3, [pc, #28]	@ (34183a18 <SystemCoreClockUpdate+0x294>)
341839fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
341839fc:	e017      	b.n	34183a2e <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
341839fe:	4b07      	ldr	r3, [pc, #28]	@ (34183a1c <SystemCoreClockUpdate+0x298>)
34183a00:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183a02:	e014      	b.n	34183a2e <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34183a04:	4b06      	ldr	r3, [pc, #24]	@ (34183a20 <SystemCoreClockUpdate+0x29c>)
34183a06:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183a08:	e011      	b.n	34183a2e <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34183a0a:	4b06      	ldr	r3, [pc, #24]	@ (34183a24 <SystemCoreClockUpdate+0x2a0>)
34183a0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34183a0e:	e00e      	b.n	34183a2e <SystemCoreClockUpdate+0x2aa>
34183a10:	56028000 	.word	0x56028000
34183a14:	03d09000 	.word	0x03d09000
34183a18:	003d0900 	.word	0x003d0900
34183a1c:	00f42400 	.word	0x00f42400
34183a20:	02dc6c00 	.word	0x02dc6c00
34183a24:	00bb8000 	.word	0x00bb8000
34183a28:	4b800000 	.word	0x4b800000
      break;
34183a2c:	bf00      	nop
    if (pllbypass == 0U)
34183a2e:	693b      	ldr	r3, [r7, #16]
34183a30:	2b00      	cmp	r3, #0
34183a32:	d134      	bne.n	34183a9e <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34183a34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183a36:	ee07 3a90 	vmov	s15, r3
34183a3a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34183a3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34183a40:	ee07 3a90 	vmov	s15, r3
34183a44:	eef8 6a67 	vcvt.f32.u32	s13, s15
34183a48:	6a3b      	ldr	r3, [r7, #32]
34183a4a:	ee07 3a90 	vmov	s15, r3
34183a4e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34183a52:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34183a28 <SystemCoreClockUpdate+0x2a4>
34183a56:	eec6 7a25 	vdiv.f32	s15, s12, s11
34183a5a:	ee76 7aa7 	vadd.f32	s15, s13, s15
34183a5e:	ee67 6a27 	vmul.f32	s13, s14, s15
34183a62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34183a64:	ee07 3a90 	vmov	s15, r3
34183a68:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34183a6c:	eec6 7a87 	vdiv.f32	s15, s13, s14
34183a70:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34183a74:	69fb      	ldr	r3, [r7, #28]
34183a76:	ee07 3a90 	vmov	s15, r3
34183a7a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34183a7e:	69bb      	ldr	r3, [r7, #24]
34183a80:	ee07 3a90 	vmov	s15, r3
34183a84:	eef8 7a67 	vcvt.f32.u32	s15, s15
34183a88:	ee27 7a27 	vmul.f32	s14, s14, s15
34183a8c:	edd7 6a02 	vldr	s13, [r7, #8]
34183a90:	eec6 7a87 	vdiv.f32	s15, s13, s14
34183a94:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34183a98:	ee17 3a90 	vmov	r3, s15
34183a9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34183a9e:	4b0b      	ldr	r3, [pc, #44]	@ (34183acc <SystemCoreClockUpdate+0x348>)
34183aa0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34183aa4:	0c1b      	lsrs	r3, r3, #16
34183aa6:	b2db      	uxtb	r3, r3
34183aa8:	3301      	adds	r3, #1
34183aaa:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34183aac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34183aae:	687b      	ldr	r3, [r7, #4]
34183ab0:	fbb2 f3f3 	udiv	r3, r2, r3
34183ab4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34183ab6:	e000      	b.n	34183aba <SystemCoreClockUpdate+0x336>
    break;
34183ab8:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34183aba:	4a05      	ldr	r2, [pc, #20]	@ (34183ad0 <SystemCoreClockUpdate+0x34c>)
34183abc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34183abe:	6013      	str	r3, [r2, #0]
}
34183ac0:	bf00      	nop
34183ac2:	3734      	adds	r7, #52	@ 0x34
34183ac4:	46bd      	mov	sp, r7
34183ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
34183aca:	4770      	bx	lr
34183acc:	56028000 	.word	0x56028000
34183ad0:	341c0020 	.word	0x341c0020

34183ad4 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34183ad4:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34183ad8:	b588      	push	{r3, r7, lr}
34183ada:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34183adc:	f7ff fe52 	bl	34183784 <SystemCoreClockUpdate>

  return SystemCoreClock;
34183ae0:	4b06      	ldr	r3, [pc, #24]	@ (34183afc <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34183ae2:	681b      	ldr	r3, [r3, #0]
}
34183ae4:	4618      	mov	r0, r3
34183ae6:	46bd      	mov	sp, r7
34183ae8:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34183aec:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34183af0:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34183af4:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34183af8:	4774      	bxns	lr
34183afa:	bf00      	nop
34183afc:	341c0020 	.word	0x341c0020

34183b00 <LL_AHB4_GRP1_EnableClock>:
{
34183b00:	b480      	push	{r7}
34183b02:	b085      	sub	sp, #20
34183b04:	af00      	add	r7, sp, #0
34183b06:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34183b08:	4a07      	ldr	r2, [pc, #28]	@ (34183b28 <LL_AHB4_GRP1_EnableClock+0x28>)
34183b0a:	687b      	ldr	r3, [r7, #4]
34183b0c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34183b10:	4b05      	ldr	r3, [pc, #20]	@ (34183b28 <LL_AHB4_GRP1_EnableClock+0x28>)
34183b12:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34183b16:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183b18:	68fb      	ldr	r3, [r7, #12]
}
34183b1a:	bf00      	nop
34183b1c:	3714      	adds	r7, #20
34183b1e:	46bd      	mov	sp, r7
34183b20:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b24:	4770      	bx	lr
34183b26:	bf00      	nop
34183b28:	56028000 	.word	0x56028000

34183b2c <LL_APB1_GRP1_EnableClock>:
{
34183b2c:	b480      	push	{r7}
34183b2e:	b085      	sub	sp, #20
34183b30:	af00      	add	r7, sp, #0
34183b32:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34183b34:	4a07      	ldr	r2, [pc, #28]	@ (34183b54 <LL_APB1_GRP1_EnableClock+0x28>)
34183b36:	687b      	ldr	r3, [r7, #4]
34183b38:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
34183b3c:	4b05      	ldr	r3, [pc, #20]	@ (34183b54 <LL_APB1_GRP1_EnableClock+0x28>)
34183b3e:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
34183b42:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34183b44:	68fb      	ldr	r3, [r7, #12]
}
34183b46:	bf00      	nop
34183b48:	3714      	adds	r7, #20
34183b4a:	46bd      	mov	sp, r7
34183b4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b50:	4770      	bx	lr
34183b52:	bf00      	nop
34183b54:	56028000 	.word	0x56028000

34183b58 <LL_APB1_GRP1_DisableClock>:
{
34183b58:	b480      	push	{r7}
34183b5a:	b083      	sub	sp, #12
34183b5c:	af00      	add	r7, sp, #0
34183b5e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
34183b60:	4b06      	ldr	r3, [pc, #24]	@ (34183b7c <LL_APB1_GRP1_DisableClock+0x24>)
34183b62:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183b66:	461a      	mov	r2, r3
34183b68:	687b      	ldr	r3, [r7, #4]
34183b6a:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
34183b6e:	bf00      	nop
34183b70:	370c      	adds	r7, #12
34183b72:	46bd      	mov	sp, r7
34183b74:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b78:	4770      	bx	lr
34183b7a:	bf00      	nop
34183b7c:	56028000 	.word	0x56028000

34183b80 <LL_APB1_GRP1_ForceReset>:
{
34183b80:	b480      	push	{r7}
34183b82:	b083      	sub	sp, #12
34183b84:	af00      	add	r7, sp, #0
34183b86:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTSR1, Periphs);
34183b88:	4a04      	ldr	r2, [pc, #16]	@ (34183b9c <LL_APB1_GRP1_ForceReset+0x1c>)
34183b8a:	687b      	ldr	r3, [r7, #4]
34183b8c:	f8c2 3a24 	str.w	r3, [r2, #2596]	@ 0xa24
}
34183b90:	bf00      	nop
34183b92:	370c      	adds	r7, #12
34183b94:	46bd      	mov	sp, r7
34183b96:	f85d 7b04 	ldr.w	r7, [sp], #4
34183b9a:	4770      	bx	lr
34183b9c:	56028000 	.word	0x56028000

34183ba0 <LL_APB1_GRP1_ReleaseReset>:
{
34183ba0:	b480      	push	{r7}
34183ba2:	b083      	sub	sp, #12
34183ba4:	af00      	add	r7, sp, #0
34183ba6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1RSTCR1, Periphs);
34183ba8:	4b06      	ldr	r3, [pc, #24]	@ (34183bc4 <LL_APB1_GRP1_ReleaseReset+0x24>)
34183baa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34183bae:	461a      	mov	r2, r3
34183bb0:	687b      	ldr	r3, [r7, #4]
34183bb2:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
}
34183bb6:	bf00      	nop
34183bb8:	370c      	adds	r7, #12
34183bba:	46bd      	mov	sp, r7
34183bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
34183bc0:	4770      	bx	lr
34183bc2:	bf00      	nop
34183bc4:	56028000 	.word	0x56028000

34183bc8 <BSP_I2C1_Init>:
/**
  * @brief  Initializes I2C1 HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_Init(void)
{
34183bc8:	b580      	push	{r7, lr}
34183bca:	b082      	sub	sp, #8
34183bcc:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
34183bce:	2300      	movs	r3, #0
34183bd0:	607b      	str	r3, [r7, #4]

  hbus_i2c1.Instance = BUS_I2C1;
34183bd2:	4b16      	ldr	r3, [pc, #88]	@ (34183c2c <BSP_I2C1_Init+0x64>)
34183bd4:	4a16      	ldr	r2, [pc, #88]	@ (34183c30 <BSP_I2C1_Init+0x68>)
34183bd6:	601a      	str	r2, [r3, #0]

  if (I2c1InitCounter == 0U)
34183bd8:	4b16      	ldr	r3, [pc, #88]	@ (34183c34 <BSP_I2C1_Init+0x6c>)
34183bda:	681b      	ldr	r3, [r3, #0]
34183bdc:	2b00      	cmp	r3, #0
34183bde:	d11f      	bne.n	34183c20 <BSP_I2C1_Init+0x58>
  {
    I2c1InitCounter++;
34183be0:	4b14      	ldr	r3, [pc, #80]	@ (34183c34 <BSP_I2C1_Init+0x6c>)
34183be2:	681b      	ldr	r3, [r3, #0]
34183be4:	3301      	adds	r3, #1
34183be6:	4a13      	ldr	r2, [pc, #76]	@ (34183c34 <BSP_I2C1_Init+0x6c>)
34183be8:	6013      	str	r3, [r2, #0]

    if (HAL_I2C_GetState(&hbus_i2c1) == HAL_I2C_STATE_RESET)
34183bea:	4810      	ldr	r0, [pc, #64]	@ (34183c2c <BSP_I2C1_Init+0x64>)
34183bec:	f007 f8f0 	bl	3418add0 <HAL_I2C_GetState>
34183bf0:	4603      	mov	r3, r0
34183bf2:	2b00      	cmp	r3, #0
34183bf4:	d114      	bne.n	34183c20 <BSP_I2C1_Init+0x58>
        BspI2cSemaphore = osSemaphoreCreate(osSemaphore(BSP_I2C_SEM), 1);
      }
#endif /* BSP_USE_CMSIS_OS */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
      /* Init the I2C1 Msp */
      I2C1_MspInit(&hbus_i2c1);
34183bf6:	480d      	ldr	r0, [pc, #52]	@ (34183c2c <BSP_I2C1_Init+0x64>)
34183bf8:	f000 f8e2 	bl	34183dc0 <I2C1_MspInit>
        }
      }
      if (ret == BSP_ERROR_NONE)
      {
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */
        if (MX_I2C1_Init(&hbus_i2c1, I2C_GetTiming(HAL_RCC_GetPCLK1Freq(), BUS_I2C1_FREQUENCY)) != HAL_OK)
34183bfc:	f009 ffaf 	bl	3418db5e <HAL_RCC_GetPCLK1Freq>
34183c00:	4603      	mov	r3, r0
34183c02:	490d      	ldr	r1, [pc, #52]	@ (34183c38 <BSP_I2C1_Init+0x70>)
34183c04:	4618      	mov	r0, r3
34183c06:	f000 f991 	bl	34183f2c <I2C_GetTiming>
34183c0a:	4603      	mov	r3, r0
34183c0c:	4619      	mov	r1, r3
34183c0e:	4807      	ldr	r0, [pc, #28]	@ (34183c2c <BSP_I2C1_Init+0x64>)
34183c10:	f000 f838 	bl	34183c84 <MX_I2C1_Init>
34183c14:	4603      	mov	r3, r0
34183c16:	2b00      	cmp	r3, #0
34183c18:	d002      	beq.n	34183c20 <BSP_I2C1_Init+0x58>
        {
          ret = BSP_ERROR_BUS_FAILURE;
34183c1a:	f06f 0307 	mvn.w	r3, #7
34183c1e:	607b      	str	r3, [r7, #4]
      }
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 1) */
    }
  }

  return ret;
34183c20:	687b      	ldr	r3, [r7, #4]
}
34183c22:	4618      	mov	r0, r3
34183c24:	3708      	adds	r7, #8
34183c26:	46bd      	mov	sp, r7
34183c28:	bd80      	pop	{r7, pc}
34183c2a:	bf00      	nop
34183c2c:	341c10a0 	.word	0x341c10a0
34183c30:	50005400 	.word	0x50005400
34183c34:	341c0698 	.word	0x341c0698
34183c38:	000186a0 	.word	0x000186a0

34183c3c <BSP_I2C1_DeInit>:
/**
  * @brief  DeInitializes I2C1 HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_DeInit(void)
{
34183c3c:	b580      	push	{r7, lr}
34183c3e:	b082      	sub	sp, #8
34183c40:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
34183c42:	2300      	movs	r3, #0
34183c44:	607b      	str	r3, [r7, #4]

  I2c1InitCounter--;
34183c46:	4b0d      	ldr	r3, [pc, #52]	@ (34183c7c <BSP_I2C1_DeInit+0x40>)
34183c48:	681b      	ldr	r3, [r3, #0]
34183c4a:	3b01      	subs	r3, #1
34183c4c:	4a0b      	ldr	r2, [pc, #44]	@ (34183c7c <BSP_I2C1_DeInit+0x40>)
34183c4e:	6013      	str	r3, [r2, #0]

  if (I2c1InitCounter == 0U)
34183c50:	4b0a      	ldr	r3, [pc, #40]	@ (34183c7c <BSP_I2C1_DeInit+0x40>)
34183c52:	681b      	ldr	r3, [r3, #0]
34183c54:	2b00      	cmp	r3, #0
34183c56:	d10b      	bne.n	34183c70 <BSP_I2C1_DeInit+0x34>
  {
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    I2C1_MspDeInit(&hbus_i2c1);
34183c58:	4809      	ldr	r0, [pc, #36]	@ (34183c80 <BSP_I2C1_DeInit+0x44>)
34183c5a:	f000 f8f3 	bl	34183e44 <I2C1_MspDeInit>
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */

    /* Init the I2C */
    if (HAL_I2C_DeInit(&hbus_i2c1) != HAL_OK)
34183c5e:	4808      	ldr	r0, [pc, #32]	@ (34183c80 <BSP_I2C1_DeInit+0x44>)
34183c60:	f006 fe58 	bl	3418a914 <HAL_I2C_DeInit>
34183c64:	4603      	mov	r3, r0
34183c66:	2b00      	cmp	r3, #0
34183c68:	d002      	beq.n	34183c70 <BSP_I2C1_DeInit+0x34>
    {
      ret = BSP_ERROR_BUS_FAILURE;
34183c6a:	f06f 0307 	mvn.w	r3, #7
34183c6e:	607b      	str	r3, [r7, #4]
    }
  }

  return ret;
34183c70:	687b      	ldr	r3, [r7, #4]
}
34183c72:	4618      	mov	r0, r3
34183c74:	3708      	adds	r7, #8
34183c76:	46bd      	mov	sp, r7
34183c78:	bd80      	pop	{r7, pc}
34183c7a:	bf00      	nop
34183c7c:	341c0698 	.word	0x341c0698
34183c80:	341c10a0 	.word	0x341c10a0

34183c84 <MX_I2C1_Init>:
  * @param  hI2c I2C handle
  * @param  timing I2C timing
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_I2C1_Init(I2C_HandleTypeDef *hI2c, uint32_t timing)
{
34183c84:	b580      	push	{r7, lr}
34183c86:	b084      	sub	sp, #16
34183c88:	af00      	add	r7, sp, #0
34183c8a:	6078      	str	r0, [r7, #4]
34183c8c:	6039      	str	r1, [r7, #0]
 HAL_StatusTypeDef status = HAL_OK;
34183c8e:	2300      	movs	r3, #0
34183c90:	73fb      	strb	r3, [r7, #15]

 hI2c->Init.Timing           = timing;
34183c92:	687b      	ldr	r3, [r7, #4]
34183c94:	683a      	ldr	r2, [r7, #0]
34183c96:	605a      	str	r2, [r3, #4]
 hI2c->Init.OwnAddress1      = 0;
34183c98:	687b      	ldr	r3, [r7, #4]
34183c9a:	2200      	movs	r2, #0
34183c9c:	609a      	str	r2, [r3, #8]
 hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
34183c9e:	687b      	ldr	r3, [r7, #4]
34183ca0:	2201      	movs	r2, #1
34183ca2:	60da      	str	r2, [r3, #12]
 hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
34183ca4:	687b      	ldr	r3, [r7, #4]
34183ca6:	2200      	movs	r2, #0
34183ca8:	611a      	str	r2, [r3, #16]
 hI2c->Init.OwnAddress2      = 0;
34183caa:	687b      	ldr	r3, [r7, #4]
34183cac:	2200      	movs	r2, #0
34183cae:	615a      	str	r2, [r3, #20]
 hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
34183cb0:	687b      	ldr	r3, [r7, #4]
34183cb2:	2200      	movs	r2, #0
34183cb4:	619a      	str	r2, [r3, #24]
 hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
34183cb6:	687b      	ldr	r3, [r7, #4]
34183cb8:	2200      	movs	r2, #0
34183cba:	61da      	str	r2, [r3, #28]
 hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
34183cbc:	687b      	ldr	r3, [r7, #4]
34183cbe:	2200      	movs	r2, #0
34183cc0:	621a      	str	r2, [r3, #32]

 if (HAL_I2C_Init(hI2c) != HAL_OK)
34183cc2:	6878      	ldr	r0, [r7, #4]
34183cc4:	f006 fd8b 	bl	3418a7de <HAL_I2C_Init>
34183cc8:	4603      	mov	r3, r0
34183cca:	2b00      	cmp	r3, #0
34183ccc:	d002      	beq.n	34183cd4 <MX_I2C1_Init+0x50>
 {
   status = HAL_ERROR;
34183cce:	2301      	movs	r3, #1
34183cd0:	73fb      	strb	r3, [r7, #15]
34183cd2:	e014      	b.n	34183cfe <MX_I2C1_Init+0x7a>
 }
 else
 {
   uint32_t analog_filter;

   analog_filter = I2C_ANALOGFILTER_ENABLE;
34183cd4:	2300      	movs	r3, #0
34183cd6:	60bb      	str	r3, [r7, #8]
   if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
34183cd8:	68b9      	ldr	r1, [r7, #8]
34183cda:	6878      	ldr	r0, [r7, #4]
34183cdc:	f007 fb54 	bl	3418b388 <HAL_I2CEx_ConfigAnalogFilter>
34183ce0:	4603      	mov	r3, r0
34183ce2:	2b00      	cmp	r3, #0
34183ce4:	d002      	beq.n	34183cec <MX_I2C1_Init+0x68>
   {
     status = HAL_ERROR;
34183ce6:	2301      	movs	r3, #1
34183ce8:	73fb      	strb	r3, [r7, #15]
34183cea:	e008      	b.n	34183cfe <MX_I2C1_Init+0x7a>
   }
   else
   {
     if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
34183cec:	2100      	movs	r1, #0
34183cee:	6878      	ldr	r0, [r7, #4]
34183cf0:	f007 fb95 	bl	3418b41e <HAL_I2CEx_ConfigDigitalFilter>
34183cf4:	4603      	mov	r3, r0
34183cf6:	2b00      	cmp	r3, #0
34183cf8:	d001      	beq.n	34183cfe <MX_I2C1_Init+0x7a>
     {
       status = HAL_ERROR;
34183cfa:	2301      	movs	r3, #1
34183cfc:	73fb      	strb	r3, [r7, #15]
     }
   }
 }

 return status;
34183cfe:	7bfb      	ldrb	r3, [r7, #15]
}
34183d00:	4618      	mov	r0, r3
34183d02:	3710      	adds	r7, #16
34183d04:	46bd      	mov	sp, r7
34183d06:	bd80      	pop	{r7, pc}

34183d08 <BSP_I2C1_WriteReg16>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval BSP status
  */
int32_t BSP_I2C1_WriteReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
34183d08:	b580      	push	{r7, lr}
34183d0a:	b088      	sub	sp, #32
34183d0c:	af02      	add	r7, sp, #8
34183d0e:	60ba      	str	r2, [r7, #8]
34183d10:	461a      	mov	r2, r3
34183d12:	4603      	mov	r3, r0
34183d14:	81fb      	strh	r3, [r7, #14]
34183d16:	460b      	mov	r3, r1
34183d18:	81bb      	strh	r3, [r7, #12]
34183d1a:	4613      	mov	r3, r2
34183d1c:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C1_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
34183d1e:	89b9      	ldrh	r1, [r7, #12]
34183d20:	89f8      	ldrh	r0, [r7, #14]
34183d22:	88fb      	ldrh	r3, [r7, #6]
34183d24:	9300      	str	r3, [sp, #0]
34183d26:	68bb      	ldr	r3, [r7, #8]
34183d28:	2202      	movs	r2, #2
34183d2a:	f000 f8ab 	bl	34183e84 <I2C1_WriteReg>
34183d2e:	4603      	mov	r3, r0
34183d30:	2b00      	cmp	r3, #0
34183d32:	d102      	bne.n	34183d3a <BSP_I2C1_WriteReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
34183d34:	2300      	movs	r3, #0
34183d36:	617b      	str	r3, [r7, #20]
34183d38:	e00c      	b.n	34183d54 <BSP_I2C1_WriteReg16+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34183d3a:	4809      	ldr	r0, [pc, #36]	@ (34183d60 <BSP_I2C1_WriteReg16+0x58>)
34183d3c:	f007 f856 	bl	3418adec <HAL_I2C_GetError>
34183d40:	4603      	mov	r3, r0
34183d42:	2b04      	cmp	r3, #4
34183d44:	d103      	bne.n	34183d4e <BSP_I2C1_WriteReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183d46:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183d4a:	617b      	str	r3, [r7, #20]
34183d4c:	e002      	b.n	34183d54 <BSP_I2C1_WriteReg16+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183d4e:	f06f 0303 	mvn.w	r3, #3
34183d52:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183d54:	697b      	ldr	r3, [r7, #20]
}
34183d56:	4618      	mov	r0, r3
34183d58:	3718      	adds	r7, #24
34183d5a:	46bd      	mov	sp, r7
34183d5c:	bd80      	pop	{r7, pc}
34183d5e:	bf00      	nop
34183d60:	341c10a0 	.word	0x341c10a0

34183d64 <BSP_I2C1_ReadReg16>:
  * @param  pData   Pointer to data buffer
  * @param  Length  Length of the data
  * @retval BSP status
  */
int32_t BSP_I2C1_ReadReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
34183d64:	b580      	push	{r7, lr}
34183d66:	b088      	sub	sp, #32
34183d68:	af02      	add	r7, sp, #8
34183d6a:	60ba      	str	r2, [r7, #8]
34183d6c:	461a      	mov	r2, r3
34183d6e:	4603      	mov	r3, r0
34183d70:	81fb      	strh	r3, [r7, #14]
34183d72:	460b      	mov	r3, r1
34183d74:	81bb      	strh	r3, [r7, #12]
34183d76:	4613      	mov	r3, r2
34183d78:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif /* BSP_USE_CMSIS_OS */
  if (I2C1_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
34183d7a:	89b9      	ldrh	r1, [r7, #12]
34183d7c:	89f8      	ldrh	r0, [r7, #14]
34183d7e:	88fb      	ldrh	r3, [r7, #6]
34183d80:	9300      	str	r3, [sp, #0]
34183d82:	68bb      	ldr	r3, [r7, #8]
34183d84:	2202      	movs	r2, #2
34183d86:	f000 f8a3 	bl	34183ed0 <I2C1_ReadReg>
34183d8a:	4603      	mov	r3, r0
34183d8c:	2b00      	cmp	r3, #0
34183d8e:	d102      	bne.n	34183d96 <BSP_I2C1_ReadReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
34183d90:	2300      	movs	r3, #0
34183d92:	617b      	str	r3, [r7, #20]
34183d94:	e00c      	b.n	34183db0 <BSP_I2C1_ReadReg16+0x4c>
  }
  else
  {
    if (HAL_I2C_GetError(&hbus_i2c1) == HAL_I2C_ERROR_AF)
34183d96:	4809      	ldr	r0, [pc, #36]	@ (34183dbc <BSP_I2C1_ReadReg16+0x58>)
34183d98:	f007 f828 	bl	3418adec <HAL_I2C_GetError>
34183d9c:	4603      	mov	r3, r0
34183d9e:	2b04      	cmp	r3, #4
34183da0:	d103      	bne.n	34183daa <BSP_I2C1_ReadReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
34183da2:	f06f 0365 	mvn.w	r3, #101	@ 0x65
34183da6:	617b      	str	r3, [r7, #20]
34183da8:	e002      	b.n	34183db0 <BSP_I2C1_ReadReg16+0x4c>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34183daa:	f06f 0303 	mvn.w	r3, #3
34183dae:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif /* BSP_USE_CMSIS_OS */
  return ret;
34183db0:	697b      	ldr	r3, [r7, #20]
}
34183db2:	4618      	mov	r0, r3
34183db4:	3718      	adds	r7, #24
34183db6:	46bd      	mov	sp, r7
34183db8:	bd80      	pop	{r7, pc}
34183dba:	bf00      	nop
34183dbc:	341c10a0 	.word	0x341c10a0

34183dc0 <I2C1_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C1_MspInit(I2C_HandleTypeDef *phi2c)
{
34183dc0:	b580      	push	{r7, lr}
34183dc2:	b088      	sub	sp, #32
34183dc4:	af00      	add	r7, sp, #0
34183dc6:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Enable PWR for I2C1 pins */
  HAL_PWREx_EnableVddIO4();
34183dc8:	f008 fdae 	bl	3418c928 <HAL_PWREx_EnableVddIO4>

  /*** Configure the GPIOs ***/
  /* Enable SCL GPIO clock */
  BUS_I2C1_SCL_GPIO_CLK_ENABLE();
34183dcc:	2080      	movs	r0, #128	@ 0x80
34183dce:	f7ff fe97 	bl	34183b00 <LL_AHB4_GRP1_EnableClock>
  /* Enable SDA GPIO clock */
  BUS_I2C1_SDA_GPIO_CLK_ENABLE();
34183dd2:	2004      	movs	r0, #4
34183dd4:	f7ff fe94 	bl	34183b00 <LL_AHB4_GRP1_EnableClock>

  /* Configure I2C Tx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C1_SCL_PIN;
34183dd8:	f44f 7300 	mov.w	r3, #512	@ 0x200
34183ddc:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183dde:	2312      	movs	r3, #18
34183de0:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183de2:	2300      	movs	r3, #0
34183de4:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183de6:	2302      	movs	r3, #2
34183de8:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C1_SCL_AF;
34183dea:	2304      	movs	r3, #4
34183dec:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &gpio_init_structure);
34183dee:	f107 030c 	add.w	r3, r7, #12
34183df2:	4619      	mov	r1, r3
34183df4:	4811      	ldr	r0, [pc, #68]	@ (34183e3c <I2C1_MspInit+0x7c>)
34183df6:	f006 f9a1 	bl	3418a13c <HAL_GPIO_Init>

  /* Configure I2C Rx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C1_SDA_PIN;
34183dfa:	2302      	movs	r3, #2
34183dfc:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
34183dfe:	2312      	movs	r3, #18
34183e00:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull      = GPIO_NOPULL;
34183e02:	2300      	movs	r3, #0
34183e04:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
34183e06:	2302      	movs	r3, #2
34183e08:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Alternate = BUS_I2C1_SDA_AF;
34183e0a:	2304      	movs	r3, #4
34183e0c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &gpio_init_structure);
34183e0e:	f107 030c 	add.w	r3, r7, #12
34183e12:	4619      	mov	r1, r3
34183e14:	480a      	ldr	r0, [pc, #40]	@ (34183e40 <I2C1_MspInit+0x80>)
34183e16:	f006 f991 	bl	3418a13c <HAL_GPIO_Init>

  /*** Configure the I2C peripheral ***/
  /* Enable I2C clock */
  BUS_I2C1_CLK_ENABLE();
34183e1a:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183e1e:	f7ff fe85 	bl	34183b2c <LL_APB1_GRP1_EnableClock>

  /* Force the I2C peripheral clock reset */
  BUS_I2C1_FORCE_RESET();
34183e22:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183e26:	f7ff feab 	bl	34183b80 <LL_APB1_GRP1_ForceReset>

  /* Release the I2C peripheral clock reset */
  BUS_I2C1_RELEASE_RESET();
34183e2a:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183e2e:	f7ff feb7 	bl	34183ba0 <LL_APB1_GRP1_ReleaseReset>
}
34183e32:	bf00      	nop
34183e34:	3720      	adds	r7, #32
34183e36:	46bd      	mov	sp, r7
34183e38:	bd80      	pop	{r7, pc}
34183e3a:	bf00      	nop
34183e3c:	56021c00 	.word	0x56021c00
34183e40:	56020800 	.word	0x56020800

34183e44 <I2C1_MspDeInit>:
  * @brief  DeInitializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C1_MspDeInit(I2C_HandleTypeDef *phi2c)
{
34183e44:	b580      	push	{r7, lr}
34183e46:	b088      	sub	sp, #32
34183e48:	af00      	add	r7, sp, #0
34183e4a:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Configure I2C Tx, Rx as alternate function */
  gpio_init_structure.Pin = BUS_I2C1_SCL_PIN;
34183e4c:	f44f 7300 	mov.w	r3, #512	@ 0x200
34183e50:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, gpio_init_structure.Pin );
34183e52:	68fb      	ldr	r3, [r7, #12]
34183e54:	4619      	mov	r1, r3
34183e56:	4809      	ldr	r0, [pc, #36]	@ (34183e7c <I2C1_MspDeInit+0x38>)
34183e58:	f006 fb22 	bl	3418a4a0 <HAL_GPIO_DeInit>
  gpio_init_structure.Pin = BUS_I2C1_SDA_PIN;
34183e5c:	2302      	movs	r3, #2
34183e5e:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, gpio_init_structure.Pin);
34183e60:	68fb      	ldr	r3, [r7, #12]
34183e62:	4619      	mov	r1, r3
34183e64:	4806      	ldr	r0, [pc, #24]	@ (34183e80 <I2C1_MspDeInit+0x3c>)
34183e66:	f006 fb1b 	bl	3418a4a0 <HAL_GPIO_DeInit>

  /* Disable I2C clock */
  BUS_I2C1_CLK_DISABLE();
34183e6a:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34183e6e:	f7ff fe73 	bl	34183b58 <LL_APB1_GRP1_DisableClock>
}
34183e72:	bf00      	nop
34183e74:	3720      	adds	r7, #32
34183e76:	46bd      	mov	sp, r7
34183e78:	bd80      	pop	{r7, pc}
34183e7a:	bf00      	nop
34183e7c:	56021c00 	.word	0x56021c00
34183e80:	56020800 	.word	0x56020800

34183e84 <I2C1_WriteReg>:
  * @param  pData      The target register value to be written
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C1_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
34183e84:	b580      	push	{r7, lr}
34183e86:	b088      	sub	sp, #32
34183e88:	af04      	add	r7, sp, #16
34183e8a:	607b      	str	r3, [r7, #4]
34183e8c:	4603      	mov	r3, r0
34183e8e:	81fb      	strh	r3, [r7, #14]
34183e90:	460b      	mov	r3, r1
34183e92:	81bb      	strh	r3, [r7, #12]
34183e94:	4613      	mov	r3, r2
34183e96:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Write(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34183e98:	8978      	ldrh	r0, [r7, #10]
34183e9a:	89ba      	ldrh	r2, [r7, #12]
34183e9c:	89f9      	ldrh	r1, [r7, #14]
34183e9e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34183ea2:	9302      	str	r3, [sp, #8]
34183ea4:	8b3b      	ldrh	r3, [r7, #24]
34183ea6:	9301      	str	r3, [sp, #4]
34183ea8:	687b      	ldr	r3, [r7, #4]
34183eaa:	9300      	str	r3, [sp, #0]
34183eac:	4603      	mov	r3, r0
34183eae:	4807      	ldr	r0, [pc, #28]	@ (34183ecc <I2C1_WriteReg+0x48>)
34183eb0:	f006 fd60 	bl	3418a974 <HAL_I2C_Mem_Write>
34183eb4:	4603      	mov	r3, r0
34183eb6:	2b00      	cmp	r3, #0
34183eb8:	d101      	bne.n	34183ebe <I2C1_WriteReg+0x3a>
  {
    return BSP_ERROR_NONE;
34183eba:	2300      	movs	r3, #0
34183ebc:	e001      	b.n	34183ec2 <I2C1_WriteReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
34183ebe:	f06f 0307 	mvn.w	r3, #7
}
34183ec2:	4618      	mov	r0, r3
34183ec4:	3710      	adds	r7, #16
34183ec6:	46bd      	mov	sp, r7
34183ec8:	bd80      	pop	{r7, pc}
34183eca:	bf00      	nop
34183ecc:	341c10a0 	.word	0x341c10a0

34183ed0 <I2C1_ReadReg>:
  * @param  pData      The target register value to be read
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C1_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
34183ed0:	b580      	push	{r7, lr}
34183ed2:	b088      	sub	sp, #32
34183ed4:	af04      	add	r7, sp, #16
34183ed6:	607b      	str	r3, [r7, #4]
34183ed8:	4603      	mov	r3, r0
34183eda:	81fb      	strh	r3, [r7, #14]
34183edc:	460b      	mov	r3, r1
34183ede:	81bb      	strh	r3, [r7, #12]
34183ee0:	4613      	mov	r3, r2
34183ee2:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Read(&hbus_i2c1, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
34183ee4:	8978      	ldrh	r0, [r7, #10]
34183ee6:	89ba      	ldrh	r2, [r7, #12]
34183ee8:	89f9      	ldrh	r1, [r7, #14]
34183eea:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34183eee:	9302      	str	r3, [sp, #8]
34183ef0:	8b3b      	ldrh	r3, [r7, #24]
34183ef2:	9301      	str	r3, [sp, #4]
34183ef4:	687b      	ldr	r3, [r7, #4]
34183ef6:	9300      	str	r3, [sp, #0]
34183ef8:	4603      	mov	r3, r0
34183efa:	4807      	ldr	r0, [pc, #28]	@ (34183f18 <I2C1_ReadReg+0x48>)
34183efc:	f006 fe4e 	bl	3418ab9c <HAL_I2C_Mem_Read>
34183f00:	4603      	mov	r3, r0
34183f02:	2b00      	cmp	r3, #0
34183f04:	d101      	bne.n	34183f0a <I2C1_ReadReg+0x3a>
  {
    return BSP_ERROR_NONE;
34183f06:	2300      	movs	r3, #0
34183f08:	e001      	b.n	34183f0e <I2C1_ReadReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
34183f0a:	f06f 0307 	mvn.w	r3, #7
}
34183f0e:	4618      	mov	r0, r3
34183f10:	3710      	adds	r7, #16
34183f12:	46bd      	mov	sp, r7
34183f14:	bd80      	pop	{r7, pc}
34183f16:	bf00      	nop
34183f18:	341c10a0 	.word	0x341c10a0

34183f1c <BSP_GetTick>:
/**
  * @brief  Delay function
  * @retval Tick value
  */
int32_t BSP_GetTick(void)
{
34183f1c:	b580      	push	{r7, lr}
34183f1e:	af00      	add	r7, sp, #0
  return (int32_t)HAL_GetTick();
34183f20:	f002 faf6 	bl	34186510 <HAL_GetTick>
34183f24:	4603      	mov	r3, r0
}
34183f26:	4618      	mov	r0, r3
34183f28:	bd80      	pop	{r7, pc}
	...

34183f2c <I2C_GetTiming>:
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
{
34183f2c:	b580      	push	{r7, lr}
34183f2e:	b086      	sub	sp, #24
34183f30:	af00      	add	r7, sp, #0
34183f32:	6078      	str	r0, [r7, #4]
34183f34:	6039      	str	r1, [r7, #0]
  uint32_t ret = 0;
34183f36:	2300      	movs	r3, #0
34183f38:	617b      	str	r3, [r7, #20]
  uint32_t speed;
  uint32_t idx;

  if ((clock_src_freq != 0U) && (i2c_freq != 0U))
34183f3a:	687b      	ldr	r3, [r7, #4]
34183f3c:	2b00      	cmp	r3, #0
34183f3e:	d06b      	beq.n	34184018 <I2C_GetTiming+0xec>
34183f40:	683b      	ldr	r3, [r7, #0]
34183f42:	2b00      	cmp	r3, #0
34183f44:	d068      	beq.n	34184018 <I2C_GetTiming+0xec>
  {
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34183f46:	2300      	movs	r3, #0
34183f48:	613b      	str	r3, [r7, #16]
34183f4a:	e060      	b.n	3418400e <I2C_GetTiming+0xe2>
    {
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183f4c:	4a35      	ldr	r2, [pc, #212]	@ (34184024 <I2C_GetTiming+0xf8>)
34183f4e:	693b      	ldr	r3, [r7, #16]
34183f50:	212c      	movs	r1, #44	@ 0x2c
34183f52:	fb01 f303 	mul.w	r3, r1, r3
34183f56:	4413      	add	r3, r2
34183f58:	3304      	adds	r3, #4
34183f5a:	681b      	ldr	r3, [r3, #0]
34183f5c:	683a      	ldr	r2, [r7, #0]
34183f5e:	429a      	cmp	r2, r3
34183f60:	d352      	bcc.n	34184008 <I2C_GetTiming+0xdc>
          (i2c_freq <= I2C_Charac[speed].freq_max))
34183f62:	4a30      	ldr	r2, [pc, #192]	@ (34184024 <I2C_GetTiming+0xf8>)
34183f64:	693b      	ldr	r3, [r7, #16]
34183f66:	212c      	movs	r1, #44	@ 0x2c
34183f68:	fb01 f303 	mul.w	r3, r1, r3
34183f6c:	4413      	add	r3, r2
34183f6e:	3308      	adds	r3, #8
34183f70:	681b      	ldr	r3, [r3, #0]
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
34183f72:	683a      	ldr	r2, [r7, #0]
34183f74:	429a      	cmp	r2, r3
34183f76:	d847      	bhi.n	34184008 <I2C_GetTiming+0xdc>
      {
        I2C_Compute_PRESC_SCLDEL_SDADEL(clock_src_freq, speed);
34183f78:	6939      	ldr	r1, [r7, #16]
34183f7a:	6878      	ldr	r0, [r7, #4]
34183f7c:	f000 f856 	bl	3418402c <I2C_Compute_PRESC_SCLDEL_SDADEL>
        idx = I2C_Compute_SCLL_SCLH(clock_src_freq, speed);
34183f80:	6939      	ldr	r1, [r7, #16]
34183f82:	6878      	ldr	r0, [r7, #4]
34183f84:	f000 f940 	bl	34184208 <I2C_Compute_SCLL_SCLH>
34183f88:	60f8      	str	r0, [r7, #12]

        if (idx < I2C_VALID_TIMING_NBR)
34183f8a:	68fb      	ldr	r3, [r7, #12]
34183f8c:	2b7f      	cmp	r3, #127	@ 0x7f
34183f8e:	d842      	bhi.n	34184016 <I2C_GetTiming+0xea>
        {
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183f90:	4925      	ldr	r1, [pc, #148]	@ (34184028 <I2C_GetTiming+0xfc>)
34183f92:	68fa      	ldr	r2, [r7, #12]
34183f94:	4613      	mov	r3, r2
34183f96:	009b      	lsls	r3, r3, #2
34183f98:	4413      	add	r3, r2
34183f9a:	009b      	lsls	r3, r3, #2
34183f9c:	440b      	add	r3, r1
34183f9e:	681b      	ldr	r3, [r3, #0]
34183fa0:	0719      	lsls	r1, r3, #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183fa2:	4821      	ldr	r0, [pc, #132]	@ (34184028 <I2C_GetTiming+0xfc>)
34183fa4:	68fa      	ldr	r2, [r7, #12]
34183fa6:	4613      	mov	r3, r2
34183fa8:	009b      	lsls	r3, r3, #2
34183faa:	4413      	add	r3, r2
34183fac:	009b      	lsls	r3, r3, #2
34183fae:	4403      	add	r3, r0
34183fb0:	3304      	adds	r3, #4
34183fb2:	681b      	ldr	r3, [r3, #0]
34183fb4:	051b      	lsls	r3, r3, #20
34183fb6:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34183fba:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183fbc:	481a      	ldr	r0, [pc, #104]	@ (34184028 <I2C_GetTiming+0xfc>)
34183fbe:	68fa      	ldr	r2, [r7, #12]
34183fc0:	4613      	mov	r3, r2
34183fc2:	009b      	lsls	r3, r3, #2
34183fc4:	4413      	add	r3, r2
34183fc6:	009b      	lsls	r3, r3, #2
34183fc8:	4403      	add	r3, r0
34183fca:	3308      	adds	r3, #8
34183fcc:	681b      	ldr	r3, [r3, #0]
34183fce:	041b      	lsls	r3, r3, #16
34183fd0:	f403 2370 	and.w	r3, r3, #983040	@ 0xf0000
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
34183fd4:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
34183fd6:	4814      	ldr	r0, [pc, #80]	@ (34184028 <I2C_GetTiming+0xfc>)
34183fd8:	68fa      	ldr	r2, [r7, #12]
34183fda:	4613      	mov	r3, r2
34183fdc:	009b      	lsls	r3, r3, #2
34183fde:	4413      	add	r3, r2
34183fe0:	009b      	lsls	r3, r3, #2
34183fe2:	4403      	add	r3, r0
34183fe4:	330c      	adds	r3, #12
34183fe6:	681b      	ldr	r3, [r3, #0]
34183fe8:	021b      	lsls	r3, r3, #8
34183fea:	b29b      	uxth	r3, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
34183fec:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
34183fee:	480e      	ldr	r0, [pc, #56]	@ (34184028 <I2C_GetTiming+0xfc>)
34183ff0:	68fa      	ldr	r2, [r7, #12]
34183ff2:	4613      	mov	r3, r2
34183ff4:	009b      	lsls	r3, r3, #2
34183ff6:	4413      	add	r3, r2
34183ff8:	009b      	lsls	r3, r3, #2
34183ffa:	4403      	add	r3, r0
34183ffc:	3310      	adds	r3, #16
34183ffe:	681b      	ldr	r3, [r3, #0]
34184000:	b2db      	uxtb	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
34184002:	430b      	orrs	r3, r1
34184004:	617b      	str	r3, [r7, #20]
        }
        break;
34184006:	e006      	b.n	34184016 <I2C_GetTiming+0xea>
    for (speed = 0; speed <= (uint32_t)I2C_SPEED_FREQ_FAST_PLUS; speed++)
34184008:	693b      	ldr	r3, [r7, #16]
3418400a:	3301      	adds	r3, #1
3418400c:	613b      	str	r3, [r7, #16]
3418400e:	693b      	ldr	r3, [r7, #16]
34184010:	2b02      	cmp	r3, #2
34184012:	d99b      	bls.n	34183f4c <I2C_GetTiming+0x20>
34184014:	e000      	b.n	34184018 <I2C_GetTiming+0xec>
        break;
34184016:	bf00      	nop
      }
    }
  }

  return ret;
34184018:	697b      	ldr	r3, [r7, #20]
}
3418401a:	4618      	mov	r0, r3
3418401c:	3718      	adds	r7, #24
3418401e:	46bd      	mov	sp, r7
34184020:	bd80      	pop	{r7, pc}
34184022:	bf00      	nop
34184024:	341a7e4c 	.word	0x341a7e4c
34184028:	341c069c 	.word	0x341c069c

3418402c <I2C_Compute_PRESC_SCLDEL_SDADEL>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval None.
  */
static void I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed)
{
3418402c:	b480      	push	{r7}
3418402e:	b08f      	sub	sp, #60	@ 0x3c
34184030:	af00      	add	r7, sp, #0
34184032:	6078      	str	r0, [r7, #4]
34184034:	6039      	str	r1, [r7, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
34184036:	2310      	movs	r3, #16
34184038:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t scldel;
  uint32_t sdadel;
  uint32_t tafdel_min;
  uint32_t tafdel_max;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
3418403a:	687b      	ldr	r3, [r7, #4]
3418403c:	085a      	lsrs	r2, r3, #1
3418403e:	4b6e      	ldr	r3, [pc, #440]	@ (341841f8 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1cc>)
34184040:	4413      	add	r3, r2
34184042:	687a      	ldr	r2, [r7, #4]
34184044:	fbb3 f3f2 	udiv	r3, r3, r2
34184048:	61fb      	str	r3, [r7, #28]

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
3418404a:	2332      	movs	r3, #50	@ 0x32
3418404c:	61bb      	str	r3, [r7, #24]
  tafdel_max = I2C_ANALOG_FILTER_DELAY_MAX;
3418404e:	f44f 7382 	mov.w	r3, #260	@ 0x104
34184052:	617b      	str	r3, [r7, #20]
  /* tDNF = DNF x tI2CCLK
     tPRESC = (PRESC+1) x tI2CCLK
     SDADEL >= {tf +tHD;DAT(min) - tAF(min) - tDNF - [3 x tI2CCLK]} / tPRESC
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / tPRESC */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34184054:	4a69      	ldr	r2, [pc, #420]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34184056:	683b      	ldr	r3, [r7, #0]
34184058:	212c      	movs	r1, #44	@ 0x2c
3418405a:	fb01 f303 	mul.w	r3, r1, r3
3418405e:	4413      	add	r3, r2
34184060:	3324      	adds	r3, #36	@ 0x24
34184062:	681b      	ldr	r3, [r3, #0]
34184064:	4618      	mov	r0, r3
34184066:	4a65      	ldr	r2, [pc, #404]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
34184068:	683b      	ldr	r3, [r7, #0]
3418406a:	212c      	movs	r1, #44	@ 0x2c
3418406c:	fb01 f303 	mul.w	r3, r1, r3
34184070:	4413      	add	r3, r2
34184072:	330c      	adds	r3, #12
34184074:	681b      	ldr	r3, [r3, #0]
34184076:	18c2      	adds	r2, r0, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
34184078:	69bb      	ldr	r3, [r7, #24]
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
3418407a:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
3418407c:	495f      	ldr	r1, [pc, #380]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
3418407e:	683b      	ldr	r3, [r7, #0]
34184080:	202c      	movs	r0, #44	@ 0x2c
34184082:	fb00 f303 	mul.w	r3, r0, r3
34184086:	440b      	add	r3, r1
34184088:	3328      	adds	r3, #40	@ 0x28
3418408a:	681b      	ldr	r3, [r3, #0]
3418408c:	3303      	adds	r3, #3
3418408e:	69f9      	ldr	r1, [r7, #28]
34184090:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
34184094:	1ad3      	subs	r3, r2, r3
34184096:	633b      	str	r3, [r7, #48]	@ 0x30

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
34184098:	4a58      	ldr	r2, [pc, #352]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
3418409a:	683b      	ldr	r3, [r7, #0]
3418409c:	212c      	movs	r1, #44	@ 0x2c
3418409e:	fb01 f303 	mul.w	r3, r1, r3
341840a2:	4413      	add	r3, r2
341840a4:	3310      	adds	r3, #16
341840a6:	681b      	ldr	r3, [r3, #0]
341840a8:	4618      	mov	r0, r3
341840aa:	4a54      	ldr	r2, [pc, #336]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
341840ac:	683b      	ldr	r3, [r7, #0]
341840ae:	212c      	movs	r1, #44	@ 0x2c
341840b0:	fb01 f303 	mul.w	r3, r1, r3
341840b4:	4413      	add	r3, r2
341840b6:	3320      	adds	r3, #32
341840b8:	681b      	ldr	r3, [r3, #0]
341840ba:	1ac2      	subs	r2, r0, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
341840bc:	697b      	ldr	r3, [r7, #20]
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
341840be:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
341840c0:	494e      	ldr	r1, [pc, #312]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
341840c2:	683b      	ldr	r3, [r7, #0]
341840c4:	202c      	movs	r0, #44	@ 0x2c
341840c6:	fb00 f303 	mul.w	r3, r0, r3
341840ca:	440b      	add	r3, r1
341840cc:	3328      	adds	r3, #40	@ 0x28
341840ce:	681b      	ldr	r3, [r3, #0]
341840d0:	3304      	adds	r3, #4
341840d2:	69f9      	ldr	r1, [r7, #28]
341840d4:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
341840d8:	1ad3      	subs	r3, r2, r3
341840da:	62fb      	str	r3, [r7, #44]	@ 0x2c


  /* {[tr+ tSU;DAT(min)] / [tPRESC]} - 1 <= SCLDEL */
  tscldel_min = (int32_t)I2C_Charac[I2C_speed].trise + (int32_t)I2C_Charac[I2C_speed].sudat_min;
341840dc:	4a47      	ldr	r2, [pc, #284]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
341840de:	683b      	ldr	r3, [r7, #0]
341840e0:	212c      	movs	r1, #44	@ 0x2c
341840e2:	fb01 f303 	mul.w	r3, r1, r3
341840e6:	4413      	add	r3, r2
341840e8:	3320      	adds	r3, #32
341840ea:	681b      	ldr	r3, [r3, #0]
341840ec:	4618      	mov	r0, r3
341840ee:	4a43      	ldr	r2, [pc, #268]	@ (341841fc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
341840f0:	683b      	ldr	r3, [r7, #0]
341840f2:	212c      	movs	r1, #44	@ 0x2c
341840f4:	fb01 f303 	mul.w	r3, r1, r3
341840f8:	4413      	add	r3, r2
341840fa:	3314      	adds	r3, #20
341840fc:	681b      	ldr	r3, [r3, #0]
341840fe:	4403      	add	r3, r0
34184100:	613b      	str	r3, [r7, #16]

  if (tsdadel_min <= 0)
34184102:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34184104:	2b00      	cmp	r3, #0
34184106:	dc01      	bgt.n	3418410c <I2C_Compute_PRESC_SCLDEL_SDADEL+0xe0>
  {
    tsdadel_min = 0;
34184108:	2300      	movs	r3, #0
3418410a:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (tsdadel_max <= 0)
3418410c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418410e:	2b00      	cmp	r3, #0
34184110:	dc01      	bgt.n	34184116 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xea>
  {
    tsdadel_max = 0;
34184112:	2300      	movs	r3, #0
34184114:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
34184116:	2300      	movs	r3, #0
34184118:	62bb      	str	r3, [r7, #40]	@ 0x28
3418411a:	e062      	b.n	341841e2 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1b6>
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
3418411c:	2300      	movs	r3, #0
3418411e:	627b      	str	r3, [r7, #36]	@ 0x24
34184120:	e059      	b.n	341841d6 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1aa>
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
34184122:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184124:	3301      	adds	r3, #1
34184126:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34184128:	3201      	adds	r2, #1
3418412a:	fb03 f202 	mul.w	r2, r3, r2
3418412e:	69fb      	ldr	r3, [r7, #28]
34184130:	fb02 f303 	mul.w	r3, r2, r3
34184134:	60fb      	str	r3, [r7, #12]

      if (tscldel >= (uint32_t)tscldel_min)
34184136:	693b      	ldr	r3, [r7, #16]
34184138:	68fa      	ldr	r2, [r7, #12]
3418413a:	429a      	cmp	r2, r3
3418413c:	d348      	bcc.n	341841d0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1a4>
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
3418413e:	2300      	movs	r3, #0
34184140:	623b      	str	r3, [r7, #32]
34184142:	e042      	b.n	341841ca <I2C_Compute_PRESC_SCLDEL_SDADEL+0x19e>
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;
34184144:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184146:	3301      	adds	r3, #1
34184148:	6a3a      	ldr	r2, [r7, #32]
3418414a:	fb03 f202 	mul.w	r2, r3, r2
3418414e:	69fb      	ldr	r3, [r7, #28]
34184150:	fb02 f303 	mul.w	r3, r2, r3
34184154:	60bb      	str	r3, [r7, #8]

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
34184156:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34184158:	68ba      	ldr	r2, [r7, #8]
3418415a:	429a      	cmp	r2, r3
3418415c:	d332      	bcc.n	341841c4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
3418415e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184160:	68ba      	ldr	r2, [r7, #8]
34184162:	429a      	cmp	r2, r3
34184164:	d82e      	bhi.n	341841c4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
          {
            if (presc != prev_presc)
34184166:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34184168:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418416a:	429a      	cmp	r2, r3
3418416c:	d02a      	beq.n	341841c4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
3418416e:	4b24      	ldr	r3, [pc, #144]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34184170:	681a      	ldr	r2, [r3, #0]
34184172:	4924      	ldr	r1, [pc, #144]	@ (34184204 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34184174:	4613      	mov	r3, r2
34184176:	009b      	lsls	r3, r3, #2
34184178:	4413      	add	r3, r2
3418417a:	009b      	lsls	r3, r3, #2
3418417c:	440b      	add	r3, r1
3418417e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34184180:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
34184182:	4b1f      	ldr	r3, [pc, #124]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
34184184:	681a      	ldr	r2, [r3, #0]
34184186:	491f      	ldr	r1, [pc, #124]	@ (34184204 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
34184188:	4613      	mov	r3, r2
3418418a:	009b      	lsls	r3, r3, #2
3418418c:	4413      	add	r3, r2
3418418e:	009b      	lsls	r3, r3, #2
34184190:	440b      	add	r3, r1
34184192:	3304      	adds	r3, #4
34184194:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34184196:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
34184198:	4b19      	ldr	r3, [pc, #100]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
3418419a:	681a      	ldr	r2, [r3, #0]
3418419c:	4919      	ldr	r1, [pc, #100]	@ (34184204 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
3418419e:	4613      	mov	r3, r2
341841a0:	009b      	lsls	r3, r3, #2
341841a2:	4413      	add	r3, r2
341841a4:	009b      	lsls	r3, r3, #2
341841a6:	440b      	add	r3, r1
341841a8:	3308      	adds	r3, #8
341841aa:	6a3a      	ldr	r2, [r7, #32]
341841ac:	601a      	str	r2, [r3, #0]
              prev_presc = presc;
341841ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341841b0:	637b      	str	r3, [r7, #52]	@ 0x34
              I2c_valid_timing_nbr ++;
341841b2:	4b13      	ldr	r3, [pc, #76]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
341841b4:	681b      	ldr	r3, [r3, #0]
341841b6:	3301      	adds	r3, #1
341841b8:	4a11      	ldr	r2, [pc, #68]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
341841ba:	6013      	str	r3, [r2, #0]

              if (I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
341841bc:	4b10      	ldr	r3, [pc, #64]	@ (34184200 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
341841be:	681b      	ldr	r3, [r3, #0]
341841c0:	2b7f      	cmp	r3, #127	@ 0x7f
341841c2:	d812      	bhi.n	341841ea <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1be>
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
341841c4:	6a3b      	ldr	r3, [r7, #32]
341841c6:	3301      	adds	r3, #1
341841c8:	623b      	str	r3, [r7, #32]
341841ca:	6a3b      	ldr	r3, [r7, #32]
341841cc:	2b0f      	cmp	r3, #15
341841ce:	d9b9      	bls.n	34184144 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x118>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
341841d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341841d2:	3301      	adds	r3, #1
341841d4:	627b      	str	r3, [r7, #36]	@ 0x24
341841d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341841d8:	2b0f      	cmp	r3, #15
341841da:	d9a2      	bls.n	34184122 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf6>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
341841dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341841de:	3301      	adds	r3, #1
341841e0:	62bb      	str	r3, [r7, #40]	@ 0x28
341841e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
341841e4:	2b0f      	cmp	r3, #15
341841e6:	d999      	bls.n	3418411c <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf0>
341841e8:	e000      	b.n	341841ec <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1c0>
              {
                return;
341841ea:	bf00      	nop
          }
        }
      }
    }
  }
}
341841ec:	373c      	adds	r7, #60	@ 0x3c
341841ee:	46bd      	mov	sp, r7
341841f0:	f85d 7b04 	ldr.w	r7, [sp], #4
341841f4:	4770      	bx	lr
341841f6:	bf00      	nop
341841f8:	3b9aca00 	.word	0x3b9aca00
341841fc:	341a7e4c 	.word	0x341a7e4c
34184200:	341c109c 	.word	0x341c109c
34184204:	341c069c 	.word	0x341c069c

34184208 <I2C_Compute_SCLL_SCLH>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval config index (0 to I2C_VALID_TIMING_NBR], 0xFFFFFFFF for no valid config.
  */
static uint32_t I2C_Compute_SCLL_SCLH (uint32_t clock_src_freq, uint32_t I2C_speed)
{
34184208:	b480      	push	{r7}
3418420a:	b093      	sub	sp, #76	@ 0x4c
3418420c:	af00      	add	r7, sp, #0
3418420e:	6078      	str	r0, [r7, #4]
34184210:	6039      	str	r1, [r7, #0]
 uint32_t ret = 0xFFFFFFFFU;
34184212:	f04f 33ff 	mov.w	r3, #4294967295
34184216:	647b      	str	r3, [r7, #68]	@ 0x44
  uint32_t clk_max;
  uint32_t scll;
  uint32_t sclh;
  uint32_t tafdel_min;

  ti2cclk = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
34184218:	687b      	ldr	r3, [r7, #4]
3418421a:	085a      	lsrs	r2, r3, #1
3418421c:	4b7a      	ldr	r3, [pc, #488]	@ (34184408 <I2C_Compute_SCLL_SCLH+0x200>)
3418421e:	4413      	add	r3, r2
34184220:	687a      	ldr	r2, [r7, #4]
34184222:	fbb3 f3f2 	udiv	r3, r3, r2
34184226:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ti2cspeed = (SEC2NSEC + (I2C_Charac[I2C_speed].freq / 2U))/ I2C_Charac[I2C_speed].freq;
34184228:	4a78      	ldr	r2, [pc, #480]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
3418422a:	683b      	ldr	r3, [r7, #0]
3418422c:	212c      	movs	r1, #44	@ 0x2c
3418422e:	fb01 f303 	mul.w	r3, r1, r3
34184232:	4413      	add	r3, r2
34184234:	681b      	ldr	r3, [r3, #0]
34184236:	085a      	lsrs	r2, r3, #1
34184238:	4b73      	ldr	r3, [pc, #460]	@ (34184408 <I2C_Compute_SCLL_SCLH+0x200>)
3418423a:	4413      	add	r3, r2
3418423c:	4973      	ldr	r1, [pc, #460]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
3418423e:	683a      	ldr	r2, [r7, #0]
34184240:	202c      	movs	r0, #44	@ 0x2c
34184242:	fb00 f202 	mul.w	r2, r0, r2
34184246:	440a      	add	r2, r1
34184248:	6812      	ldr	r2, [r2, #0]
3418424a:	fbb3 f3f2 	udiv	r3, r3, r2
3418424e:	62bb      	str	r3, [r7, #40]	@ 0x28

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
34184250:	2332      	movs	r3, #50	@ 0x32
34184252:	627b      	str	r3, [r7, #36]	@ 0x24

  /* tDNF = DNF x tI2CCLK */
  dnf_delay = I2C_Charac[I2C_speed].dnf * ti2cclk;
34184254:	4a6d      	ldr	r2, [pc, #436]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
34184256:	683b      	ldr	r3, [r7, #0]
34184258:	212c      	movs	r1, #44	@ 0x2c
3418425a:	fb01 f303 	mul.w	r3, r1, r3
3418425e:	4413      	add	r3, r2
34184260:	3328      	adds	r3, #40	@ 0x28
34184262:	681a      	ldr	r2, [r3, #0]
34184264:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184266:	fb02 f303 	mul.w	r3, r2, r3
3418426a:	623b      	str	r3, [r7, #32]

  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
3418426c:	4a67      	ldr	r2, [pc, #412]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
3418426e:	683b      	ldr	r3, [r7, #0]
34184270:	212c      	movs	r1, #44	@ 0x2c
34184272:	fb01 f303 	mul.w	r3, r1, r3
34184276:	4413      	add	r3, r2
34184278:	3304      	adds	r3, #4
3418427a:	681b      	ldr	r3, [r3, #0]
3418427c:	4a62      	ldr	r2, [pc, #392]	@ (34184408 <I2C_Compute_SCLL_SCLH+0x200>)
3418427e:	fbb2 f3f3 	udiv	r3, r2, r3
34184282:	61fb      	str	r3, [r7, #28]
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;
34184284:	4a61      	ldr	r2, [pc, #388]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
34184286:	683b      	ldr	r3, [r7, #0]
34184288:	212c      	movs	r1, #44	@ 0x2c
3418428a:	fb01 f303 	mul.w	r3, r1, r3
3418428e:	4413      	add	r3, r2
34184290:	3308      	adds	r3, #8
34184292:	681b      	ldr	r3, [r3, #0]
34184294:	4a5c      	ldr	r2, [pc, #368]	@ (34184408 <I2C_Compute_SCLL_SCLH+0x200>)
34184296:	fbb2 f3f3 	udiv	r3, r2, r3
3418429a:	61bb      	str	r3, [r7, #24]

  prev_error = ti2cspeed;
3418429c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418429e:	643b      	str	r3, [r7, #64]	@ 0x40

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
341842a0:	2300      	movs	r3, #0
341842a2:	637b      	str	r3, [r7, #52]	@ 0x34
341842a4:	e0a3      	b.n	341843ee <I2C_Compute_SCLL_SCLH+0x1e6>
  {
    /* tPRESC = (PRESC+1) x tI2CCLK*/
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
341842a6:	495a      	ldr	r1, [pc, #360]	@ (34184410 <I2C_Compute_SCLL_SCLH+0x208>)
341842a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341842aa:	4613      	mov	r3, r2
341842ac:	009b      	lsls	r3, r3, #2
341842ae:	4413      	add	r3, r2
341842b0:	009b      	lsls	r3, r3, #2
341842b2:	440b      	add	r3, r1
341842b4:	681b      	ldr	r3, [r3, #0]
341842b6:	1c5a      	adds	r2, r3, #1
341842b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341842ba:	fb02 f303 	mul.w	r3, r2, r3
341842be:	617b      	str	r3, [r7, #20]

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
341842c0:	2300      	movs	r3, #0
341842c2:	63fb      	str	r3, [r7, #60]	@ 0x3c
341842c4:	e08c      	b.n	341843e0 <I2C_Compute_SCLL_SCLH+0x1d8>
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
341842c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
341842c8:	6a3b      	ldr	r3, [r7, #32]
341842ca:	441a      	add	r2, r3
341842cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341842ce:	3301      	adds	r3, #1
341842d0:	6979      	ldr	r1, [r7, #20]
341842d2:	fb03 f101 	mul.w	r1, r3, r1
341842d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341842d8:	005b      	lsls	r3, r3, #1
341842da:	440b      	add	r3, r1
341842dc:	4413      	add	r3, r2
341842de:	613b      	str	r3, [r7, #16]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
341842e0:	4a4a      	ldr	r2, [pc, #296]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
341842e2:	683b      	ldr	r3, [r7, #0]
341842e4:	212c      	movs	r1, #44	@ 0x2c
341842e6:	fb01 f303 	mul.w	r3, r1, r3
341842ea:	4413      	add	r3, r2
341842ec:	3318      	adds	r3, #24
341842ee:	681b      	ldr	r3, [r3, #0]
341842f0:	693a      	ldr	r2, [r7, #16]
341842f2:	429a      	cmp	r2, r3
341842f4:	d971      	bls.n	341843da <I2C_Compute_SCLL_SCLH+0x1d2>
341842f6:	693a      	ldr	r2, [r7, #16]
341842f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341842fa:	1ad2      	subs	r2, r2, r3
341842fc:	6a3b      	ldr	r3, [r7, #32]
341842fe:	1ad3      	subs	r3, r2, r3
34184300:	089b      	lsrs	r3, r3, #2
34184302:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34184304:	429a      	cmp	r2, r3
34184306:	d268      	bcs.n	341843da <I2C_Compute_SCLL_SCLH+0x1d2>
      {
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
34184308:	2300      	movs	r3, #0
3418430a:	63bb      	str	r3, [r7, #56]	@ 0x38
3418430c:	e062      	b.n	341843d4 <I2C_Compute_SCLL_SCLH+0x1cc>
        {
          /* tHIGH(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLH+1) x tPRESC] */
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
3418430e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34184310:	6a3b      	ldr	r3, [r7, #32]
34184312:	441a      	add	r2, r3
34184314:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34184316:	3301      	adds	r3, #1
34184318:	6979      	ldr	r1, [r7, #20]
3418431a:	fb03 f101 	mul.w	r1, r3, r1
3418431e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184320:	005b      	lsls	r3, r3, #1
34184322:	440b      	add	r3, r1
34184324:	4413      	add	r3, r2
34184326:	60fb      	str	r3, [r7, #12]

          /* tSCL = tf + tLOW + tr + tHIGH */
          uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;
34184328:	693a      	ldr	r2, [r7, #16]
3418432a:	68fb      	ldr	r3, [r7, #12]
3418432c:	441a      	add	r2, r3
3418432e:	4937      	ldr	r1, [pc, #220]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
34184330:	683b      	ldr	r3, [r7, #0]
34184332:	202c      	movs	r0, #44	@ 0x2c
34184334:	fb00 f303 	mul.w	r3, r0, r3
34184338:	440b      	add	r3, r1
3418433a:	3320      	adds	r3, #32
3418433c:	681b      	ldr	r3, [r3, #0]
3418433e:	441a      	add	r2, r3
34184340:	4932      	ldr	r1, [pc, #200]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
34184342:	683b      	ldr	r3, [r7, #0]
34184344:	202c      	movs	r0, #44	@ 0x2c
34184346:	fb00 f303 	mul.w	r3, r0, r3
3418434a:	440b      	add	r3, r1
3418434c:	3324      	adds	r3, #36	@ 0x24
3418434e:	681b      	ldr	r3, [r3, #0]
34184350:	4413      	add	r3, r2
34184352:	60bb      	str	r3, [r7, #8]

          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
34184354:	68ba      	ldr	r2, [r7, #8]
34184356:	69bb      	ldr	r3, [r7, #24]
34184358:	429a      	cmp	r2, r3
3418435a:	d338      	bcc.n	341843ce <I2C_Compute_SCLL_SCLH+0x1c6>
3418435c:	68ba      	ldr	r2, [r7, #8]
3418435e:	69fb      	ldr	r3, [r7, #28]
34184360:	429a      	cmp	r2, r3
34184362:	d834      	bhi.n	341843ce <I2C_Compute_SCLL_SCLH+0x1c6>
34184364:	4a29      	ldr	r2, [pc, #164]	@ (3418440c <I2C_Compute_SCLL_SCLH+0x204>)
34184366:	683b      	ldr	r3, [r7, #0]
34184368:	212c      	movs	r1, #44	@ 0x2c
3418436a:	fb01 f303 	mul.w	r3, r1, r3
3418436e:	4413      	add	r3, r2
34184370:	331c      	adds	r3, #28
34184372:	681b      	ldr	r3, [r3, #0]
34184374:	68fa      	ldr	r2, [r7, #12]
34184376:	429a      	cmp	r2, r3
34184378:	d329      	bcc.n	341843ce <I2C_Compute_SCLL_SCLH+0x1c6>
3418437a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3418437c:	68fb      	ldr	r3, [r7, #12]
3418437e:	429a      	cmp	r2, r3
34184380:	d225      	bcs.n	341843ce <I2C_Compute_SCLL_SCLH+0x1c6>
          {
            int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;
34184382:	68ba      	ldr	r2, [r7, #8]
34184384:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184386:	1ad3      	subs	r3, r2, r3
34184388:	633b      	str	r3, [r7, #48]	@ 0x30

            if (error < 0)
3418438a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418438c:	2b00      	cmp	r3, #0
3418438e:	da02      	bge.n	34184396 <I2C_Compute_SCLL_SCLH+0x18e>
            {
              error = -error;
34184390:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34184392:	425b      	negs	r3, r3
34184394:	633b      	str	r3, [r7, #48]	@ 0x30
            }

            /* look for the timings with the lowest clock error */
            if ((uint32_t)error < prev_error)
34184396:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34184398:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3418439a:	429a      	cmp	r2, r3
3418439c:	d917      	bls.n	341843ce <I2C_Compute_SCLL_SCLH+0x1c6>
            {
              prev_error = (uint32_t)error;
3418439e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341843a0:	643b      	str	r3, [r7, #64]	@ 0x40
              I2c_valid_timing[count].scll = scll;
341843a2:	491b      	ldr	r1, [pc, #108]	@ (34184410 <I2C_Compute_SCLL_SCLH+0x208>)
341843a4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341843a6:	4613      	mov	r3, r2
341843a8:	009b      	lsls	r3, r3, #2
341843aa:	4413      	add	r3, r2
341843ac:	009b      	lsls	r3, r3, #2
341843ae:	440b      	add	r3, r1
341843b0:	3310      	adds	r3, #16
341843b2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
341843b4:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[count].sclh = sclh;
341843b6:	4916      	ldr	r1, [pc, #88]	@ (34184410 <I2C_Compute_SCLL_SCLH+0x208>)
341843b8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341843ba:	4613      	mov	r3, r2
341843bc:	009b      	lsls	r3, r3, #2
341843be:	4413      	add	r3, r2
341843c0:	009b      	lsls	r3, r3, #2
341843c2:	440b      	add	r3, r1
341843c4:	330c      	adds	r3, #12
341843c6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
341843c8:	601a      	str	r2, [r3, #0]
              ret = count;
341843ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341843cc:	647b      	str	r3, [r7, #68]	@ 0x44
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
341843ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341843d0:	3301      	adds	r3, #1
341843d2:	63bb      	str	r3, [r7, #56]	@ 0x38
341843d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
341843d6:	2bff      	cmp	r3, #255	@ 0xff
341843d8:	d999      	bls.n	3418430e <I2C_Compute_SCLL_SCLH+0x106>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
341843da:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341843dc:	3301      	adds	r3, #1
341843de:	63fb      	str	r3, [r7, #60]	@ 0x3c
341843e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
341843e2:	2bff      	cmp	r3, #255	@ 0xff
341843e4:	f67f af6f 	bls.w	341842c6 <I2C_Compute_SCLL_SCLH+0xbe>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
341843e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341843ea:	3301      	adds	r3, #1
341843ec:	637b      	str	r3, [r7, #52]	@ 0x34
341843ee:	4b09      	ldr	r3, [pc, #36]	@ (34184414 <I2C_Compute_SCLL_SCLH+0x20c>)
341843f0:	681b      	ldr	r3, [r3, #0]
341843f2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
341843f4:	429a      	cmp	r2, r3
341843f6:	f4ff af56 	bcc.w	341842a6 <I2C_Compute_SCLL_SCLH+0x9e>
        }
      }
    }
  }

  return ret;
341843fa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
341843fc:	4618      	mov	r0, r3
341843fe:	374c      	adds	r7, #76	@ 0x4c
34184400:	46bd      	mov	sp, r7
34184402:	f85d 7b04 	ldr.w	r7, [sp], #4
34184406:	4770      	bx	lr
34184408:	3b9aca00 	.word	0x3b9aca00
3418440c:	341a7e4c 	.word	0x341a7e4c
34184410:	341c069c 	.word	0x341c069c
34184414:	341c109c 	.word	0x341c109c

34184418 <LL_AHB4_GRP1_EnableClock>:
{
34184418:	b480      	push	{r7}
3418441a:	b085      	sub	sp, #20
3418441c:	af00      	add	r7, sp, #0
3418441e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34184420:	4a07      	ldr	r2, [pc, #28]	@ (34184440 <LL_AHB4_GRP1_EnableClock+0x28>)
34184422:	687b      	ldr	r3, [r7, #4]
34184424:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34184428:	4b05      	ldr	r3, [pc, #20]	@ (34184440 <LL_AHB4_GRP1_EnableClock+0x28>)
3418442a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418442e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34184430:	68fb      	ldr	r3, [r7, #12]
}
34184432:	bf00      	nop
34184434:	3714      	adds	r7, #20
34184436:	46bd      	mov	sp, r7
34184438:	f85d 7b04 	ldr.w	r7, [sp], #4
3418443c:	4770      	bx	lr
3418443e:	bf00      	nop
34184440:	56028000 	.word	0x56028000

34184444 <LL_AHB5_GRP1_EnableClock>:
{
34184444:	b480      	push	{r7}
34184446:	b085      	sub	sp, #20
34184448:	af00      	add	r7, sp, #0
3418444a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
3418444c:	4a07      	ldr	r2, [pc, #28]	@ (3418446c <LL_AHB5_GRP1_EnableClock+0x28>)
3418444e:	687b      	ldr	r3, [r7, #4]
34184450:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34184454:	4b05      	ldr	r3, [pc, #20]	@ (3418446c <LL_AHB5_GRP1_EnableClock+0x28>)
34184456:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
3418445a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418445c:	68fb      	ldr	r3, [r7, #12]
}
3418445e:	bf00      	nop
34184460:	3714      	adds	r7, #20
34184462:	46bd      	mov	sp, r7
34184464:	f85d 7b04 	ldr.w	r7, [sp], #4
34184468:	4770      	bx	lr
3418446a:	bf00      	nop
3418446c:	56028000 	.word	0x56028000

34184470 <LL_AHB5_GRP1_ForceReset>:
{
34184470:	b480      	push	{r7}
34184472:	b083      	sub	sp, #12
34184474:	af00      	add	r7, sp, #0
34184476:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34184478:	4a04      	ldr	r2, [pc, #16]	@ (3418448c <LL_AHB5_GRP1_ForceReset+0x1c>)
3418447a:	687b      	ldr	r3, [r7, #4]
3418447c:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34184480:	bf00      	nop
34184482:	370c      	adds	r7, #12
34184484:	46bd      	mov	sp, r7
34184486:	f85d 7b04 	ldr.w	r7, [sp], #4
3418448a:	4770      	bx	lr
3418448c:	56028000 	.word	0x56028000

34184490 <LL_AHB5_GRP1_ReleaseReset>:
{
34184490:	b480      	push	{r7}
34184492:	b083      	sub	sp, #12
34184494:	af00      	add	r7, sp, #0
34184496:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34184498:	4b06      	ldr	r3, [pc, #24]	@ (341844b4 <LL_AHB5_GRP1_ReleaseReset+0x24>)
3418449a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418449e:	461a      	mov	r2, r3
341844a0:	687b      	ldr	r3, [r7, #4]
341844a2:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
341844a6:	bf00      	nop
341844a8:	370c      	adds	r7, #12
341844aa:	46bd      	mov	sp, r7
341844ac:	f85d 7b04 	ldr.w	r7, [sp], #4
341844b0:	4770      	bx	lr
341844b2:	bf00      	nop
341844b4:	56028000 	.word	0x56028000

341844b8 <LL_APB5_GRP1_EnableClock>:
{
341844b8:	b480      	push	{r7}
341844ba:	b085      	sub	sp, #20
341844bc:	af00      	add	r7, sp, #0
341844be:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
341844c0:	4a07      	ldr	r2, [pc, #28]	@ (341844e0 <LL_APB5_GRP1_EnableClock+0x28>)
341844c2:	687b      	ldr	r3, [r7, #4]
341844c4:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
341844c8:	4b05      	ldr	r3, [pc, #20]	@ (341844e0 <LL_APB5_GRP1_EnableClock+0x28>)
341844ca:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
341844ce:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
341844d0:	68fb      	ldr	r3, [r7, #12]
}
341844d2:	bf00      	nop
341844d4:	3714      	adds	r7, #20
341844d6:	46bd      	mov	sp, r7
341844d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341844dc:	4770      	bx	lr
341844de:	bf00      	nop
341844e0:	56028000 	.word	0x56028000

341844e4 <LL_APB5_GRP1_ForceReset>:
{
341844e4:	b480      	push	{r7}
341844e6:	b083      	sub	sp, #12
341844e8:	af00      	add	r7, sp, #0
341844ea:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
341844ec:	4a04      	ldr	r2, [pc, #16]	@ (34184500 <LL_APB5_GRP1_ForceReset+0x1c>)
341844ee:	687b      	ldr	r3, [r7, #4]
341844f0:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
341844f4:	bf00      	nop
341844f6:	370c      	adds	r7, #12
341844f8:	46bd      	mov	sp, r7
341844fa:	f85d 7b04 	ldr.w	r7, [sp], #4
341844fe:	4770      	bx	lr
34184500:	56028000 	.word	0x56028000

34184504 <LL_APB5_GRP1_ReleaseReset>:
{
34184504:	b480      	push	{r7}
34184506:	b083      	sub	sp, #12
34184508:	af00      	add	r7, sp, #0
3418450a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
3418450c:	4b06      	ldr	r3, [pc, #24]	@ (34184528 <LL_APB5_GRP1_ReleaseReset+0x24>)
3418450e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34184512:	461a      	mov	r2, r3
34184514:	687b      	ldr	r3, [r7, #4]
34184516:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
3418451a:	bf00      	nop
3418451c:	370c      	adds	r7, #12
3418451e:	46bd      	mov	sp, r7
34184520:	f85d 7b04 	ldr.w	r7, [sp], #4
34184524:	4770      	bx	lr
34184526:	bf00      	nop
34184528:	56028000 	.word	0x56028000

3418452c <BSP_LCD_Init>:
  * @param  Orientation LCD_ORIENTATION_LANDSCAPE
  * @retval BSP status
  */

int32_t BSP_LCD_Init(uint32_t Instance, uint32_t Orientation)
{
3418452c:	b580      	push	{r7, lr}
3418452e:	b084      	sub	sp, #16
34184530:	af02      	add	r7, sp, #8
34184532:	6078      	str	r0, [r7, #4]
34184534:	6039      	str	r1, [r7, #0]
   return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34184536:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
3418453a:	9300      	str	r3, [sp, #0]
3418453c:	f44f 7348 	mov.w	r3, #800	@ 0x320
34184540:	2202      	movs	r2, #2
34184542:	6839      	ldr	r1, [r7, #0]
34184544:	6878      	ldr	r0, [r7, #4]
34184546:	f000 f805 	bl	34184554 <BSP_LCD_InitEx>
3418454a:	4603      	mov	r3, r0
}
3418454c:	4618      	mov	r0, r3
3418454e:	3708      	adds	r7, #8
34184550:	46bd      	mov	sp, r7
34184552:	bd80      	pop	{r7, pc}

34184554 <BSP_LCD_InitEx>:
  * @param  Width       Display width
  * @param  Height      Display height
  * @retval BSP status
  */
int32_t BSP_LCD_InitEx(uint32_t Instance, uint32_t Orientation, uint32_t PixelFormat, uint32_t Width, uint32_t Height)
{
34184554:	b580      	push	{r7, lr}
34184556:	b08c      	sub	sp, #48	@ 0x30
34184558:	af00      	add	r7, sp, #0
3418455a:	60f8      	str	r0, [r7, #12]
3418455c:	60b9      	str	r1, [r7, #8]
3418455e:	607a      	str	r2, [r7, #4]
34184560:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34184562:	2300      	movs	r3, #0
34184564:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ltdc_pixel_format;
  MX_LTDC_LayerConfig_t config = {0};
34184566:	f107 0310 	add.w	r3, r7, #16
3418456a:	2200      	movs	r2, #0
3418456c:	601a      	str	r2, [r3, #0]
3418456e:	605a      	str	r2, [r3, #4]
34184570:	609a      	str	r2, [r3, #8]
34184572:	60da      	str	r2, [r3, #12]
34184574:	611a      	str	r2, [r3, #16]
34184576:	615a      	str	r2, [r3, #20]

  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
34184578:	68bb      	ldr	r3, [r7, #8]
3418457a:	2b01      	cmp	r3, #1
3418457c:	d80e      	bhi.n	3418459c <BSP_LCD_InitEx+0x48>
3418457e:	68fb      	ldr	r3, [r7, #12]
34184580:	2b00      	cmp	r3, #0
34184582:	d10b      	bne.n	3418459c <BSP_LCD_InitEx+0x48>
34184584:	687b      	ldr	r3, [r7, #4]
34184586:	2b02      	cmp	r3, #2
34184588:	d00c      	beq.n	341845a4 <BSP_LCD_InitEx+0x50>
     ((PixelFormat != LCD_PIXEL_FORMAT_RGB565) && (PixelFormat != LCD_PIXEL_FORMAT_RGB888) && \
3418458a:	687b      	ldr	r3, [r7, #4]
3418458c:	2b01      	cmp	r3, #1
3418458e:	d009      	beq.n	341845a4 <BSP_LCD_InitEx+0x50>
34184590:	687b      	ldr	r3, [r7, #4]
34184592:	2b00      	cmp	r3, #0
34184594:	d006      	beq.n	341845a4 <BSP_LCD_InitEx+0x50>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34184596:	687b      	ldr	r3, [r7, #4]
34184598:	2b04      	cmp	r3, #4
3418459a:	d003      	beq.n	341845a4 <BSP_LCD_InitEx+0x50>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3418459c:	f06f 0301 	mvn.w	r3, #1
341845a0:	62fb      	str	r3, [r7, #44]	@ 0x2c
341845a2:	e087      	b.n	341846b4 <BSP_LCD_InitEx+0x160>
  }
  else
  {
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
341845a4:	687b      	ldr	r3, [r7, #4]
341845a6:	2b02      	cmp	r3, #2
341845a8:	d109      	bne.n	341845be <BSP_LCD_InitEx+0x6a>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
341845aa:	2304      	movs	r3, #4
341845ac:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
341845ae:	4a44      	ldr	r2, [pc, #272]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
341845b0:	68fb      	ldr	r3, [r7, #12]
341845b2:	015b      	lsls	r3, r3, #5
341845b4:	4413      	add	r3, r2
341845b6:	3310      	adds	r3, #16
341845b8:	2202      	movs	r2, #2
341845ba:	601a      	str	r2, [r3, #0]
341845bc:	e022      	b.n	34184604 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
341845be:	687b      	ldr	r3, [r7, #4]
341845c0:	2b01      	cmp	r3, #1
341845c2:	d109      	bne.n	341845d8 <BSP_LCD_InitEx+0x84>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB888;
341845c4:	2306      	movs	r3, #6
341845c6:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 3U;
341845c8:	4a3d      	ldr	r2, [pc, #244]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
341845ca:	68fb      	ldr	r3, [r7, #12]
341845cc:	015b      	lsls	r3, r3, #5
341845ce:	4413      	add	r3, r2
341845d0:	3310      	adds	r3, #16
341845d2:	2203      	movs	r2, #3
341845d4:	601a      	str	r2, [r3, #0]
341845d6:	e015      	b.n	34184604 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
341845d8:	687b      	ldr	r3, [r7, #4]
341845da:	2b04      	cmp	r3, #4
341845dc:	d109      	bne.n	341845f2 <BSP_LCD_InitEx+0x9e>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
341845de:	2308      	movs	r3, #8
341845e0:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
341845e2:	4a37      	ldr	r2, [pc, #220]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
341845e4:	68fb      	ldr	r3, [r7, #12]
341845e6:	015b      	lsls	r3, r3, #5
341845e8:	4413      	add	r3, r2
341845ea:	3310      	adds	r3, #16
341845ec:	2202      	movs	r2, #2
341845ee:	601a      	str	r2, [r3, #0]
341845f0:	e008      	b.n	34184604 <BSP_LCD_InitEx+0xb0>
    }
    else /* LCD_PIXEL_FORMAT_ARGB8888 */
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB8888;
341845f2:	2300      	movs	r3, #0
341845f4:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 4U;
341845f6:	4a32      	ldr	r2, [pc, #200]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
341845f8:	68fb      	ldr	r3, [r7, #12]
341845fa:	015b      	lsls	r3, r3, #5
341845fc:	4413      	add	r3, r2
341845fe:	3310      	adds	r3, #16
34184600:	2204      	movs	r2, #4
34184602:	601a      	str	r2, [r3, #0]
    }

    /* Store pixel format, xsize and ysize information */
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
34184604:	4a2e      	ldr	r2, [pc, #184]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
34184606:	68fb      	ldr	r3, [r7, #12]
34184608:	015b      	lsls	r3, r3, #5
3418460a:	4413      	add	r3, r2
3418460c:	330c      	adds	r3, #12
3418460e:	687a      	ldr	r2, [r7, #4]
34184610:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize  = Width;
34184612:	4a2b      	ldr	r2, [pc, #172]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
34184614:	68fb      	ldr	r3, [r7, #12]
34184616:	015b      	lsls	r3, r3, #5
34184618:	4413      	add	r3, r2
3418461a:	683a      	ldr	r2, [r7, #0]
3418461c:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize  = Height;
3418461e:	4a28      	ldr	r2, [pc, #160]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
34184620:	68fb      	ldr	r3, [r7, #12]
34184622:	015b      	lsls	r3, r3, #5
34184624:	4413      	add	r3, r2
34184626:	3304      	adds	r3, #4
34184628:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3418462a:	601a      	str	r2, [r3, #0]

    /* Initializes peripherals instance value */
    hlcd_ltdc.Instance = LTDC;
3418462c:	4b25      	ldr	r3, [pc, #148]	@ (341846c4 <BSP_LCD_InitEx+0x170>)
3418462e:	4a26      	ldr	r2, [pc, #152]	@ (341846c8 <BSP_LCD_InitEx+0x174>)
34184630:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34184632:	4b26      	ldr	r3, [pc, #152]	@ (341846cc <BSP_LCD_InitEx+0x178>)
34184634:	4a26      	ldr	r2, [pc, #152]	@ (341846d0 <BSP_LCD_InitEx+0x17c>)
34184636:	601a      	str	r2, [r3, #0]
      {
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    LTDC_MspInit(&hlcd_ltdc);
34184638:	4822      	ldr	r0, [pc, #136]	@ (341846c4 <BSP_LCD_InitEx+0x170>)
3418463a:	f000 fe17 	bl	3418526c <LTDC_MspInit>
#endif /* (USE_HAL_LTDC_REGISTER_CALLBACKS == 1) */

    DMA2D_MspInit(&hlcd_dma2d);
3418463e:	4823      	ldr	r0, [pc, #140]	@ (341846cc <BSP_LCD_InitEx+0x178>)
34184640:	f000 fed0 	bl	341853e4 <DMA2D_MspInit>

    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34184644:	481f      	ldr	r0, [pc, #124]	@ (341846c4 <BSP_LCD_InitEx+0x170>)
34184646:	f000 f890 	bl	3418476a <MX_LTDC_ClockConfig>
3418464a:	4603      	mov	r3, r0
3418464c:	2b00      	cmp	r3, #0
3418464e:	d003      	beq.n	34184658 <BSP_LCD_InitEx+0x104>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34184650:	f06f 0303 	mvn.w	r3, #3
34184654:	62fb      	str	r3, [r7, #44]	@ 0x2c
34184656:	e00a      	b.n	3418466e <BSP_LCD_InitEx+0x11a>
    }
    else
    {
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34184658:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3418465a:	6839      	ldr	r1, [r7, #0]
3418465c:	4819      	ldr	r0, [pc, #100]	@ (341846c4 <BSP_LCD_InitEx+0x170>)
3418465e:	f7fd fffb 	bl	34182658 <MX_LTDC_Init>
34184662:	4603      	mov	r3, r0
34184664:	2b00      	cmp	r3, #0
34184666:	d002      	beq.n	3418466e <BSP_LCD_InitEx+0x11a>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34184668:	f06f 0303 	mvn.w	r3, #3
3418466c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      }
    }

    if (ret == BSP_ERROR_NONE)
3418466e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184670:	2b00      	cmp	r3, #0
34184672:	d11f      	bne.n	341846b4 <BSP_LCD_InitEx+0x160>
      else
      {
#endif /* DATA_IN_ExtRAM */
        /* Configure default LTDC Layer 0. This configuration can be override by calling
        BSP_LCD_ConfigLayer() at application level */
        config.X0          = 0;
34184674:	2300      	movs	r3, #0
34184676:	613b      	str	r3, [r7, #16]
        config.X1          = Width;
34184678:	683b      	ldr	r3, [r7, #0]
3418467a:	617b      	str	r3, [r7, #20]
        config.Y0          = 0;
3418467c:	2300      	movs	r3, #0
3418467e:	61bb      	str	r3, [r7, #24]
        config.Y1          = Height;
34184680:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34184682:	61fb      	str	r3, [r7, #28]
        config.PixelFormat = ltdc_pixel_format;
34184684:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184686:	623b      	str	r3, [r7, #32]
        config.Address     = LCD_LAYER_0_ADDRESS;
34184688:	4b12      	ldr	r3, [pc, #72]	@ (341846d4 <BSP_LCD_InitEx+0x180>)
3418468a:	627b      	str	r3, [r7, #36]	@ 0x24

        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
3418468c:	f107 0310 	add.w	r3, r7, #16
34184690:	461a      	mov	r2, r3
34184692:	2100      	movs	r1, #0
34184694:	480b      	ldr	r0, [pc, #44]	@ (341846c4 <BSP_LCD_InitEx+0x170>)
34184696:	f000 f81f 	bl	341846d8 <MX_LTDC_ConfigLayer>
3418469a:	4603      	mov	r3, r0
3418469c:	2b00      	cmp	r3, #0
3418469e:	d002      	beq.n	341846a6 <BSP_LCD_InitEx+0x152>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
341846a0:	f06f 0303 	mvn.w	r3, #3
341846a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }

        /* By default the reload is activated and executed immediately */
        Lcd_Ctx[Instance].ReloadEnable = 1U;
341846a6:	4a06      	ldr	r2, [pc, #24]	@ (341846c0 <BSP_LCD_InitEx+0x16c>)
341846a8:	68fb      	ldr	r3, [r7, #12]
341846aa:	015b      	lsls	r3, r3, #5
341846ac:	4413      	add	r3, r2
341846ae:	3318      	adds	r3, #24
341846b0:	2201      	movs	r2, #1
341846b2:	601a      	str	r2, [r3, #0]
      }
#endif /* DATA_IN_ExtRAM */
    }
  }

  return ret;
341846b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
341846b6:	4618      	mov	r0, r3
341846b8:	3730      	adds	r7, #48	@ 0x30
341846ba:	46bd      	mov	sp, r7
341846bc:	bd80      	pop	{r7, pc}
341846be:	bf00      	nop
341846c0:	341c1204 	.word	0x341c1204
341846c4:	341c115c 	.word	0x341c115c
341846c8:	58001000 	.word	0x58001000
341846cc:	341c10f4 	.word	0x341c10f4
341846d0:	58021000 	.word	0x58021000
341846d4:	34200000 	.word	0x34200000

341846d8 <MX_LTDC_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, uint32_t LayerIndex, MX_LTDC_LayerConfig_t *Config)
{
341846d8:	b580      	push	{r7, lr}
341846da:	b092      	sub	sp, #72	@ 0x48
341846dc:	af00      	add	r7, sp, #0
341846de:	60f8      	str	r0, [r7, #12]
341846e0:	60b9      	str	r1, [r7, #8]
341846e2:	607a      	str	r2, [r7, #4]
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
341846e4:	f107 0314 	add.w	r3, r7, #20
341846e8:	2234      	movs	r2, #52	@ 0x34
341846ea:	2100      	movs	r1, #0
341846ec:	4618      	mov	r0, r3
341846ee:	f020 feff 	bl	341a54f0 <memset>

  pLayerCfg.WindowX0 = Config->X0;
341846f2:	687b      	ldr	r3, [r7, #4]
341846f4:	681b      	ldr	r3, [r3, #0]
341846f6:	617b      	str	r3, [r7, #20]
  pLayerCfg.WindowX1 = Config->X1;
341846f8:	687b      	ldr	r3, [r7, #4]
341846fa:	685b      	ldr	r3, [r3, #4]
341846fc:	61bb      	str	r3, [r7, #24]
  pLayerCfg.WindowY0 = Config->Y0;
341846fe:	687b      	ldr	r3, [r7, #4]
34184700:	689b      	ldr	r3, [r3, #8]
34184702:	61fb      	str	r3, [r7, #28]
  pLayerCfg.WindowY1 = Config->Y1;
34184704:	687b      	ldr	r3, [r7, #4]
34184706:	68db      	ldr	r3, [r3, #12]
34184708:	623b      	str	r3, [r7, #32]
  pLayerCfg.PixelFormat = Config->PixelFormat;
3418470a:	687b      	ldr	r3, [r7, #4]
3418470c:	691b      	ldr	r3, [r3, #16]
3418470e:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34184710:	23ff      	movs	r3, #255	@ 0xff
34184712:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg.Alpha0 = 0;
34184714:	2300      	movs	r3, #0
34184716:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
34184718:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
3418471c:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
3418471e:	2307      	movs	r3, #7
34184720:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg.FBStartAdress = Config->Address;
34184722:	687b      	ldr	r3, [r7, #4]
34184724:	695b      	ldr	r3, [r3, #20]
34184726:	63bb      	str	r3, [r7, #56]	@ 0x38
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34184728:	687b      	ldr	r3, [r7, #4]
3418472a:	685a      	ldr	r2, [r3, #4]
3418472c:	687b      	ldr	r3, [r7, #4]
3418472e:	681b      	ldr	r3, [r3, #0]
34184730:	1ad3      	subs	r3, r2, r3
34184732:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34184734:	687b      	ldr	r3, [r7, #4]
34184736:	68da      	ldr	r2, [r3, #12]
34184738:	687b      	ldr	r3, [r7, #4]
3418473a:	689b      	ldr	r3, [r3, #8]
3418473c:	1ad3      	subs	r3, r2, r3
3418473e:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.Backcolor.Blue = 0;
34184740:	2300      	movs	r3, #0
34184742:	f887 3044 	strb.w	r3, [r7, #68]	@ 0x44
  pLayerCfg.Backcolor.Green = 0;
34184746:	2300      	movs	r3, #0
34184748:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
  pLayerCfg.Backcolor.Red = 0;
3418474c:	2300      	movs	r3, #0
3418474e:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34184752:	f107 0314 	add.w	r3, r7, #20
34184756:	68ba      	ldr	r2, [r7, #8]
34184758:	4619      	mov	r1, r3
3418475a:	68f8      	ldr	r0, [r7, #12]
3418475c:	f006 ff56 	bl	3418b60c <HAL_LTDC_ConfigLayer>
34184760:	4603      	mov	r3, r0
}
34184762:	4618      	mov	r0, r3
34184764:	3748      	adds	r7, #72	@ 0x48
34184766:	46bd      	mov	sp, r7
34184768:	bd80      	pop	{r7, pc}

3418476a <MX_LTDC_ClockConfig>:
  * @param  hltdc  LTDC Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_LTDC_ClockConfig(LTDC_HandleTypeDef *hltdc)
{
3418476a:	b580      	push	{r7, lr}
3418476c:	b0e8      	sub	sp, #416	@ 0x1a0
3418476e:	af00      	add	r7, sp, #0
34184770:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34184774:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
34184778:	6018      	str	r0, [r3, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hltdc);

  HAL_StatusTypeDef   status =  HAL_OK;
3418477a:	2300      	movs	r3, #0
3418477c:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34184780:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34184784:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34184788:	4618      	mov	r0, r3
3418478a:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3418478e:	461a      	mov	r2, r3
34184790:	2100      	movs	r1, #0
34184792:	f020 fead 	bl	341a54f0 <memset>
  /* PLL3_VCO Input = HSE_VALUE/PLLM = 48 Mhz / 192 = 0.25 */
  /* PLL3_VCO Output = PLL3_VCO Input * PLLN = 0.25 Mhz * 100 = 25 */
  /* PLLLCDCLK = PLL3_VCO Output/(PLLP1 * PLLP2) = 25/1 = 25Mhz */
  /* LTDC clock frequency = PLLLCDCLK = 25 Mhz */

  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34184796:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
3418479a:	f5a3 71cc 	sub.w	r1, r3, #408	@ 0x198
3418479e:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
341847a2:	f04f 0300 	mov.w	r3, #0
341847a6:	e9c1 2300 	strd	r2, r3, [r1]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
341847aa:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
341847ae:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
341847b2:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
341847b6:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL4;
341847ba:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
341847be:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
341847c2:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
341847c6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
341847ca:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
341847ce:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
341847d2:	2202      	movs	r2, #2
341847d4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
341847d8:	f107 0308 	add.w	r3, r7, #8
341847dc:	4618      	mov	r0, r3
341847de:	f00b f8cf 	bl	3418f980 <HAL_RCCEx_PeriphCLKConfig>
341847e2:	4603      	mov	r3, r0
341847e4:	2b00      	cmp	r3, #0
341847e6:	d002      	beq.n	341847ee <MX_LTDC_ClockConfig+0x84>
  {
    status = HAL_ERROR;
341847e8:	2301      	movs	r3, #1
341847ea:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  }

  return status;
341847ee:	f897 319f 	ldrb.w	r3, [r7, #415]	@ 0x19f
}
341847f2:	4618      	mov	r0, r3
341847f4:	f507 77d0 	add.w	r7, r7, #416	@ 0x1a0
341847f8:	46bd      	mov	sp, r7
341847fa:	bd80      	pop	{r7, pc}

341847fc <BSP_LCD_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
int32_t BSP_LCD_ConfigLayer(uint32_t Instance, uint32_t LayerIndex, BSP_LCD_LayerConfig_t *Config)
{
341847fc:	b580      	push	{r7, lr}
341847fe:	b086      	sub	sp, #24
34184800:	af00      	add	r7, sp, #0
34184802:	60f8      	str	r0, [r7, #12]
34184804:	60b9      	str	r1, [r7, #8]
34184806:	607a      	str	r2, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34184808:	2300      	movs	r3, #0
3418480a:	617b      	str	r3, [r7, #20]
  if(Instance >= LCD_INSTANCES_NBR)
3418480c:	68fb      	ldr	r3, [r7, #12]
3418480e:	2b00      	cmp	r3, #0
34184810:	d003      	beq.n	3418481a <BSP_LCD_ConfigLayer+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184812:	f06f 0301 	mvn.w	r3, #1
34184816:	617b      	str	r3, [r7, #20]
34184818:	e025      	b.n	34184866 <BSP_LCD_ConfigLayer+0x6a>
  }
  else
  {
    if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_RGB565)
3418481a:	687b      	ldr	r3, [r7, #4]
3418481c:	691b      	ldr	r3, [r3, #16]
3418481e:	2b02      	cmp	r3, #2
34184820:	d103      	bne.n	3418482a <BSP_LCD_ConfigLayer+0x2e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34184822:	687b      	ldr	r3, [r7, #4]
34184824:	2204      	movs	r2, #4
34184826:	611a      	str	r2, [r3, #16]
34184828:	e012      	b.n	34184850 <BSP_LCD_ConfigLayer+0x54>
    }
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB4444)
3418482a:	687b      	ldr	r3, [r7, #4]
3418482c:	691b      	ldr	r3, [r3, #16]
3418482e:	2b04      	cmp	r3, #4
34184830:	d103      	bne.n	3418483a <BSP_LCD_ConfigLayer+0x3e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34184832:	687b      	ldr	r3, [r7, #4]
34184834:	2208      	movs	r2, #8
34184836:	611a      	str	r2, [r3, #16]
34184838:	e00a      	b.n	34184850 <BSP_LCD_ConfigLayer+0x54>
    }
    else if (Config->PixelFormat ==  LCD_PIXEL_FORMAT_ARGB8888)
3418483a:	687b      	ldr	r3, [r7, #4]
3418483c:	691b      	ldr	r3, [r3, #16]
3418483e:	2b00      	cmp	r3, #0
34184840:	d103      	bne.n	3418484a <BSP_LCD_ConfigLayer+0x4e>
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
34184842:	687b      	ldr	r3, [r7, #4]
34184844:	2200      	movs	r2, #0
34184846:	611a      	str	r2, [r3, #16]
34184848:	e002      	b.n	34184850 <BSP_LCD_ConfigLayer+0x54>
    }
    else
    {
      Config->PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
3418484a:	687b      	ldr	r3, [r7, #4]
3418484c:	2206      	movs	r2, #6
3418484e:	611a      	str	r2, [r3, #16]
    }
    if (MX_LTDC_ConfigLayer(&hlcd_ltdc, LayerIndex, Config) != HAL_OK)
34184850:	687a      	ldr	r2, [r7, #4]
34184852:	68b9      	ldr	r1, [r7, #8]
34184854:	4806      	ldr	r0, [pc, #24]	@ (34184870 <BSP_LCD_ConfigLayer+0x74>)
34184856:	f7ff ff3f 	bl	341846d8 <MX_LTDC_ConfigLayer>
3418485a:	4603      	mov	r3, r0
3418485c:	2b00      	cmp	r3, #0
3418485e:	d002      	beq.n	34184866 <BSP_LCD_ConfigLayer+0x6a>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34184860:	f06f 0303 	mvn.w	r3, #3
34184864:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
34184866:	697b      	ldr	r3, [r7, #20]
}
34184868:	4618      	mov	r0, r3
3418486a:	3718      	adds	r7, #24
3418486c:	46bd      	mov	sp, r7
3418486e:	bd80      	pop	{r7, pc}
34184870:	341c115c 	.word	0x341c115c

34184874 <BSP_LCD_GetPixelFormat>:
  * @param  Instance    LCD Instance
  * @param  PixelFormat Active LCD Pixel Format
  * @retval BSP status
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
34184874:	b480      	push	{r7}
34184876:	b085      	sub	sp, #20
34184878:	af00      	add	r7, sp, #0
3418487a:	6078      	str	r0, [r7, #4]
3418487c:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
3418487e:	2300      	movs	r3, #0
34184880:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34184882:	687b      	ldr	r3, [r7, #4]
34184884:	2b00      	cmp	r3, #0
34184886:	d003      	beq.n	34184890 <BSP_LCD_GetPixelFormat+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184888:	f06f 0301 	mvn.w	r3, #1
3418488c:	60fb      	str	r3, [r7, #12]
3418488e:	e007      	b.n	341848a0 <BSP_LCD_GetPixelFormat+0x2c>
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat =  Lcd_Ctx[Instance].PixelFormat;
34184890:	4a07      	ldr	r2, [pc, #28]	@ (341848b0 <BSP_LCD_GetPixelFormat+0x3c>)
34184892:	687b      	ldr	r3, [r7, #4]
34184894:	015b      	lsls	r3, r3, #5
34184896:	4413      	add	r3, r2
34184898:	330c      	adds	r3, #12
3418489a:	681a      	ldr	r2, [r3, #0]
3418489c:	683b      	ldr	r3, [r7, #0]
3418489e:	601a      	str	r2, [r3, #0]
  }

  return ret;
341848a0:	68fb      	ldr	r3, [r7, #12]
}
341848a2:	4618      	mov	r0, r3
341848a4:	3714      	adds	r7, #20
341848a6:	46bd      	mov	sp, r7
341848a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341848ac:	4770      	bx	lr
341848ae:	bf00      	nop
341848b0:	341c1204 	.word	0x341c1204

341848b4 <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
341848b4:	b480      	push	{r7}
341848b6:	b085      	sub	sp, #20
341848b8:	af00      	add	r7, sp, #0
341848ba:	6078      	str	r0, [r7, #4]
341848bc:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
341848be:	2300      	movs	r3, #0
341848c0:	60fb      	str	r3, [r7, #12]
  LTDC_LayerCfgTypeDef *pLayerCfg;

  if(Instance >= LCD_INSTANCES_NBR)
341848c2:	687b      	ldr	r3, [r7, #4]
341848c4:	2b00      	cmp	r3, #0
341848c6:	d003      	beq.n	341848d0 <BSP_LCD_SetActiveLayer+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341848c8:	f06f 0301 	mvn.w	r3, #1
341848cc:	60fb      	str	r3, [r7, #12]
341848ce:	e064      	b.n	3418499a <BSP_LCD_SetActiveLayer+0xe6>
  }
  else
  {
    pLayerCfg = &hlcd_ltdc.LayerCfg[LayerIndex];
341848d0:	683b      	ldr	r3, [r7, #0]
341848d2:	2234      	movs	r2, #52	@ 0x34
341848d4:	fb02 f303 	mul.w	r3, r2, r3
341848d8:	3338      	adds	r3, #56	@ 0x38
341848da:	4a33      	ldr	r2, [pc, #204]	@ (341849a8 <BSP_LCD_SetActiveLayer+0xf4>)
341848dc:	4413      	add	r3, r2
341848de:	60bb      	str	r3, [r7, #8]

    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
341848e0:	4a32      	ldr	r2, [pc, #200]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
341848e2:	687b      	ldr	r3, [r7, #4]
341848e4:	015b      	lsls	r3, r3, #5
341848e6:	4413      	add	r3, r2
341848e8:	3308      	adds	r3, #8
341848ea:	683a      	ldr	r2, [r7, #0]
341848ec:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize = pLayerCfg->ImageWidth;
341848ee:	68bb      	ldr	r3, [r7, #8]
341848f0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
341848f2:	492e      	ldr	r1, [pc, #184]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
341848f4:	687b      	ldr	r3, [r7, #4]
341848f6:	015b      	lsls	r3, r3, #5
341848f8:	440b      	add	r3, r1
341848fa:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize = pLayerCfg->ImageHeight;
341848fc:	68bb      	ldr	r3, [r7, #8]
341848fe:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34184900:	492a      	ldr	r1, [pc, #168]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184902:	687b      	ldr	r3, [r7, #4]
34184904:	015b      	lsls	r3, r3, #5
34184906:	440b      	add	r3, r1
34184908:	3304      	adds	r3, #4
3418490a:	601a      	str	r2, [r3, #0]

    if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB565)
3418490c:	68bb      	ldr	r3, [r7, #8]
3418490e:	691b      	ldr	r3, [r3, #16]
34184910:	2b04      	cmp	r3, #4
34184912:	d10e      	bne.n	34184932 <BSP_LCD_SetActiveLayer+0x7e>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
34184914:	4a25      	ldr	r2, [pc, #148]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184916:	687b      	ldr	r3, [r7, #4]
34184918:	015b      	lsls	r3, r3, #5
3418491a:	4413      	add	r3, r2
3418491c:	3310      	adds	r3, #16
3418491e:	2202      	movs	r2, #2
34184920:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB565;
34184922:	4a22      	ldr	r2, [pc, #136]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184924:	687b      	ldr	r3, [r7, #4]
34184926:	015b      	lsls	r3, r3, #5
34184928:	4413      	add	r3, r2
3418492a:	330c      	adds	r3, #12
3418492c:	2202      	movs	r2, #2
3418492e:	601a      	str	r2, [r3, #0]
34184930:	e033      	b.n	3418499a <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_ARGB4444)
34184932:	68bb      	ldr	r3, [r7, #8]
34184934:	691b      	ldr	r3, [r3, #16]
34184936:	2b08      	cmp	r3, #8
34184938:	d10e      	bne.n	34184958 <BSP_LCD_SetActiveLayer+0xa4>
    {
      Lcd_Ctx[Instance].BppFactor = 2;
3418493a:	4a1c      	ldr	r2, [pc, #112]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
3418493c:	687b      	ldr	r3, [r7, #4]
3418493e:	015b      	lsls	r3, r3, #5
34184940:	4413      	add	r3, r2
34184942:	3310      	adds	r3, #16
34184944:	2202      	movs	r2, #2
34184946:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB4444;
34184948:	4a18      	ldr	r2, [pc, #96]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
3418494a:	687b      	ldr	r3, [r7, #4]
3418494c:	015b      	lsls	r3, r3, #5
3418494e:	4413      	add	r3, r2
34184950:	330c      	adds	r3, #12
34184952:	2204      	movs	r2, #4
34184954:	601a      	str	r2, [r3, #0]
34184956:	e020      	b.n	3418499a <BSP_LCD_SetActiveLayer+0xe6>
    }
    else if (pLayerCfg->PixelFormat ==  LTDC_PIXEL_FORMAT_RGB888)
34184958:	68bb      	ldr	r3, [r7, #8]
3418495a:	691b      	ldr	r3, [r3, #16]
3418495c:	2b06      	cmp	r3, #6
3418495e:	d10e      	bne.n	3418497e <BSP_LCD_SetActiveLayer+0xca>
    {
      Lcd_Ctx[Instance].BppFactor = 3;
34184960:	4a12      	ldr	r2, [pc, #72]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184962:	687b      	ldr	r3, [r7, #4]
34184964:	015b      	lsls	r3, r3, #5
34184966:	4413      	add	r3, r2
34184968:	3310      	adds	r3, #16
3418496a:	2203      	movs	r2, #3
3418496c:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_RGB888;
3418496e:	4a0f      	ldr	r2, [pc, #60]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184970:	687b      	ldr	r3, [r7, #4]
34184972:	015b      	lsls	r3, r3, #5
34184974:	4413      	add	r3, r2
34184976:	330c      	adds	r3, #12
34184978:	2201      	movs	r2, #1
3418497a:	601a      	str	r2, [r3, #0]
3418497c:	e00d      	b.n	3418499a <BSP_LCD_SetActiveLayer+0xe6>
    }
    else
    {
      Lcd_Ctx[Instance].BppFactor = 4;
3418497e:	4a0b      	ldr	r2, [pc, #44]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
34184980:	687b      	ldr	r3, [r7, #4]
34184982:	015b      	lsls	r3, r3, #5
34184984:	4413      	add	r3, r2
34184986:	3310      	adds	r3, #16
34184988:	2204      	movs	r2, #4
3418498a:	601a      	str	r2, [r3, #0]
      Lcd_Ctx[Instance].PixelFormat = LCD_PIXEL_FORMAT_ARGB8888;
3418498c:	4a07      	ldr	r2, [pc, #28]	@ (341849ac <BSP_LCD_SetActiveLayer+0xf8>)
3418498e:	687b      	ldr	r3, [r7, #4]
34184990:	015b      	lsls	r3, r3, #5
34184992:	4413      	add	r3, r2
34184994:	330c      	adds	r3, #12
34184996:	2200      	movs	r2, #0
34184998:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
3418499a:	68fb      	ldr	r3, [r7, #12]
}
3418499c:	4618      	mov	r0, r3
3418499e:	3714      	adds	r7, #20
341849a0:	46bd      	mov	sp, r7
341849a2:	f85d 7b04 	ldr.w	r7, [sp], #4
341849a6:	4770      	bx	lr
341849a8:	341c115c 	.word	0x341c115c
341849ac:	341c1204 	.word	0x341c1204

341849b0 <BSP_LCD_GetXSize>:
  * @param  Instance  LCD Instance
  * @param  XSize     LCD width
  * @retval BSP status
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
341849b0:	b480      	push	{r7}
341849b2:	b085      	sub	sp, #20
341849b4:	af00      	add	r7, sp, #0
341849b6:	6078      	str	r0, [r7, #4]
341849b8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
341849ba:	2300      	movs	r3, #0
341849bc:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
341849be:	687b      	ldr	r3, [r7, #4]
341849c0:	2b00      	cmp	r3, #0
341849c2:	d003      	beq.n	341849cc <BSP_LCD_GetXSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341849c4:	f06f 0301 	mvn.w	r3, #1
341849c8:	60fb      	str	r3, [r7, #12]
341849ca:	e006      	b.n	341849da <BSP_LCD_GetXSize+0x2a>
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
341849cc:	4a06      	ldr	r2, [pc, #24]	@ (341849e8 <BSP_LCD_GetXSize+0x38>)
341849ce:	687b      	ldr	r3, [r7, #4]
341849d0:	015b      	lsls	r3, r3, #5
341849d2:	4413      	add	r3, r2
341849d4:	681a      	ldr	r2, [r3, #0]
341849d6:	683b      	ldr	r3, [r7, #0]
341849d8:	601a      	str	r2, [r3, #0]
  }

  return ret;
341849da:	68fb      	ldr	r3, [r7, #12]
}
341849dc:	4618      	mov	r0, r3
341849de:	3714      	adds	r7, #20
341849e0:	46bd      	mov	sp, r7
341849e2:	f85d 7b04 	ldr.w	r7, [sp], #4
341849e6:	4770      	bx	lr
341849e8:	341c1204 	.word	0x341c1204

341849ec <BSP_LCD_GetYSize>:
  * @param  Instance  LCD Instance
  * @param  YSize     LCD Height
  * @retval BSP status
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
341849ec:	b480      	push	{r7}
341849ee:	b085      	sub	sp, #20
341849f0:	af00      	add	r7, sp, #0
341849f2:	6078      	str	r0, [r7, #4]
341849f4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
341849f6:	2300      	movs	r3, #0
341849f8:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
341849fa:	687b      	ldr	r3, [r7, #4]
341849fc:	2b00      	cmp	r3, #0
341849fe:	d003      	beq.n	34184a08 <BSP_LCD_GetYSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34184a00:	f06f 0301 	mvn.w	r3, #1
34184a04:	60fb      	str	r3, [r7, #12]
34184a06:	e007      	b.n	34184a18 <BSP_LCD_GetYSize+0x2c>
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34184a08:	4a07      	ldr	r2, [pc, #28]	@ (34184a28 <BSP_LCD_GetYSize+0x3c>)
34184a0a:	687b      	ldr	r3, [r7, #4]
34184a0c:	015b      	lsls	r3, r3, #5
34184a0e:	4413      	add	r3, r2
34184a10:	3304      	adds	r3, #4
34184a12:	681a      	ldr	r2, [r3, #0]
34184a14:	683b      	ldr	r3, [r7, #0]
34184a16:	601a      	str	r2, [r3, #0]
  }

  return ret;
34184a18:	68fb      	ldr	r3, [r7, #12]
}
34184a1a:	4618      	mov	r0, r3
34184a1c:	3714      	adds	r7, #20
34184a1e:	46bd      	mov	sp, r7
34184a20:	f85d 7b04 	ldr.w	r7, [sp], #4
34184a24:	4770      	bx	lr
34184a26:	bf00      	nop
34184a28:	341c1204 	.word	0x341c1204

34184a2c <BSP_LCD_DrawBitmap>:
  * @param  Ypos Bmp Y position in the LCD
  * @param  pBmp Pointer to Bmp picture address in the internal Flash.
  * @retval BSP status
  */
int32_t BSP_LCD_DrawBitmap(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pBmp)
{
34184a2c:	b580      	push	{r7, lr}
34184a2e:	b08e      	sub	sp, #56	@ 0x38
34184a30:	af02      	add	r7, sp, #8
34184a32:	60f8      	str	r0, [r7, #12]
34184a34:	60b9      	str	r1, [r7, #8]
34184a36:	607a      	str	r2, [r7, #4]
34184a38:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34184a3a:	2300      	movs	r3, #0
34184a3c:	61fb      	str	r3, [r7, #28]
  uint32_t Address;
  uint32_t input_color_mode;
  uint8_t *pbmp;

  /* Get bitmap data address offset */
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
34184a3e:	683b      	ldr	r3, [r7, #0]
34184a40:	330a      	adds	r3, #10
34184a42:	781b      	ldrb	r3, [r3, #0]
34184a44:	461a      	mov	r2, r3
34184a46:	683b      	ldr	r3, [r7, #0]
34184a48:	330b      	adds	r3, #11
34184a4a:	781b      	ldrb	r3, [r3, #0]
34184a4c:	021b      	lsls	r3, r3, #8
34184a4e:	441a      	add	r2, r3
34184a50:	683b      	ldr	r3, [r7, #0]
34184a52:	330c      	adds	r3, #12
34184a54:	781b      	ldrb	r3, [r3, #0]
34184a56:	041b      	lsls	r3, r3, #16
34184a58:	441a      	add	r2, r3
34184a5a:	683b      	ldr	r3, [r7, #0]
34184a5c:	330d      	adds	r3, #13
34184a5e:	781b      	ldrb	r3, [r3, #0]
34184a60:	061b      	lsls	r3, r3, #24
34184a62:	4413      	add	r3, r2
34184a64:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Read bitmap width */
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
34184a66:	683b      	ldr	r3, [r7, #0]
34184a68:	3312      	adds	r3, #18
34184a6a:	781b      	ldrb	r3, [r3, #0]
34184a6c:	461a      	mov	r2, r3
34184a6e:	683b      	ldr	r3, [r7, #0]
34184a70:	3313      	adds	r3, #19
34184a72:	781b      	ldrb	r3, [r3, #0]
34184a74:	021b      	lsls	r3, r3, #8
34184a76:	441a      	add	r2, r3
34184a78:	683b      	ldr	r3, [r7, #0]
34184a7a:	3314      	adds	r3, #20
34184a7c:	781b      	ldrb	r3, [r3, #0]
34184a7e:	041b      	lsls	r3, r3, #16
34184a80:	441a      	add	r2, r3
34184a82:	683b      	ldr	r3, [r7, #0]
34184a84:	3315      	adds	r3, #21
34184a86:	781b      	ldrb	r3, [r3, #0]
34184a88:	061b      	lsls	r3, r3, #24
34184a8a:	4413      	add	r3, r2
34184a8c:	61bb      	str	r3, [r7, #24]

  /* Read bitmap height */
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
34184a8e:	683b      	ldr	r3, [r7, #0]
34184a90:	3316      	adds	r3, #22
34184a92:	781b      	ldrb	r3, [r3, #0]
34184a94:	461a      	mov	r2, r3
34184a96:	683b      	ldr	r3, [r7, #0]
34184a98:	3317      	adds	r3, #23
34184a9a:	781b      	ldrb	r3, [r3, #0]
34184a9c:	021b      	lsls	r3, r3, #8
34184a9e:	441a      	add	r2, r3
34184aa0:	683b      	ldr	r3, [r7, #0]
34184aa2:	3318      	adds	r3, #24
34184aa4:	781b      	ldrb	r3, [r3, #0]
34184aa6:	041b      	lsls	r3, r3, #16
34184aa8:	441a      	add	r2, r3
34184aaa:	683b      	ldr	r3, [r7, #0]
34184aac:	3319      	adds	r3, #25
34184aae:	781b      	ldrb	r3, [r3, #0]
34184ab0:	061b      	lsls	r3, r3, #24
34184ab2:	4413      	add	r3, r2
34184ab4:	617b      	str	r3, [r7, #20]

  /* Read bit/pixel */
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
34184ab6:	683b      	ldr	r3, [r7, #0]
34184ab8:	331c      	adds	r3, #28
34184aba:	781b      	ldrb	r3, [r3, #0]
34184abc:	461a      	mov	r2, r3
34184abe:	683b      	ldr	r3, [r7, #0]
34184ac0:	331d      	adds	r3, #29
34184ac2:	781b      	ldrb	r3, [r3, #0]
34184ac4:	021b      	lsls	r3, r3, #8
34184ac6:	4413      	add	r3, r2
34184ac8:	613b      	str	r3, [r7, #16]

  /* Set the address */
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
34184aca:	4a37      	ldr	r2, [pc, #220]	@ (34184ba8 <BSP_LCD_DrawBitmap+0x17c>)
34184acc:	68fb      	ldr	r3, [r7, #12]
34184ace:	015b      	lsls	r3, r3, #5
34184ad0:	4413      	add	r3, r2
34184ad2:	3308      	adds	r3, #8
34184ad4:	681b      	ldr	r3, [r3, #0]
34184ad6:	4a35      	ldr	r2, [pc, #212]	@ (34184bac <BSP_LCD_DrawBitmap+0x180>)
34184ad8:	2134      	movs	r1, #52	@ 0x34
34184ada:	fb01 f303 	mul.w	r3, r1, r3
34184ade:	4413      	add	r3, r2
34184ae0:	335c      	adds	r3, #92	@ 0x5c
34184ae2:	681a      	ldr	r2, [r3, #0]
34184ae4:	4930      	ldr	r1, [pc, #192]	@ (34184ba8 <BSP_LCD_DrawBitmap+0x17c>)
34184ae6:	68fb      	ldr	r3, [r7, #12]
34184ae8:	015b      	lsls	r3, r3, #5
34184aea:	440b      	add	r3, r1
34184aec:	681b      	ldr	r3, [r3, #0]
34184aee:	6879      	ldr	r1, [r7, #4]
34184af0:	fb03 f101 	mul.w	r1, r3, r1
34184af4:	68bb      	ldr	r3, [r7, #8]
34184af6:	440b      	add	r3, r1
34184af8:	482b      	ldr	r0, [pc, #172]	@ (34184ba8 <BSP_LCD_DrawBitmap+0x17c>)
34184afa:	68f9      	ldr	r1, [r7, #12]
34184afc:	0149      	lsls	r1, r1, #5
34184afe:	4401      	add	r1, r0
34184b00:	3110      	adds	r1, #16
34184b02:	6809      	ldr	r1, [r1, #0]
34184b04:	fb01 f303 	mul.w	r3, r1, r3
34184b08:	4413      	add	r3, r2
34184b0a:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Get the layer pixel format */
  if ((bit_pixel/8U) == 4U)
34184b0c:	693b      	ldr	r3, [r7, #16]
34184b0e:	3b20      	subs	r3, #32
34184b10:	2b07      	cmp	r3, #7
34184b12:	d802      	bhi.n	34184b1a <BSP_LCD_DrawBitmap+0xee>
  {
    input_color_mode = DMA2D_INPUT_ARGB8888;
34184b14:	2300      	movs	r3, #0
34184b16:	627b      	str	r3, [r7, #36]	@ 0x24
34184b18:	e008      	b.n	34184b2c <BSP_LCD_DrawBitmap+0x100>
  }
  else if ((bit_pixel/8U) == 2U)
34184b1a:	693b      	ldr	r3, [r7, #16]
34184b1c:	3b10      	subs	r3, #16
34184b1e:	2b07      	cmp	r3, #7
34184b20:	d802      	bhi.n	34184b28 <BSP_LCD_DrawBitmap+0xfc>
  {
    input_color_mode = DMA2D_INPUT_RGB565;
34184b22:	2302      	movs	r3, #2
34184b24:	627b      	str	r3, [r7, #36]	@ 0x24
34184b26:	e001      	b.n	34184b2c <BSP_LCD_DrawBitmap+0x100>
  }
  else
  {
    input_color_mode = DMA2D_INPUT_RGB888;
34184b28:	2301      	movs	r3, #1
34184b2a:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Bypass the bitmap header */
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
34184b2c:	697b      	ldr	r3, [r7, #20]
34184b2e:	3b01      	subs	r3, #1
34184b30:	69ba      	ldr	r2, [r7, #24]
34184b32:	fb02 f303 	mul.w	r3, r2, r3
34184b36:	693a      	ldr	r2, [r7, #16]
34184b38:	08d2      	lsrs	r2, r2, #3
34184b3a:	fb03 f202 	mul.w	r2, r3, r2
34184b3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184b40:	4413      	add	r3, r2
34184b42:	683a      	ldr	r2, [r7, #0]
34184b44:	4413      	add	r3, r2
34184b46:	623b      	str	r3, [r7, #32]

  /* Convert picture to ARGB8888 pixel format */
  for(index=0; index < height; index++)
34184b48:	2300      	movs	r3, #0
34184b4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
34184b4c:	e023      	b.n	34184b96 <BSP_LCD_DrawBitmap+0x16a>
  {
    /* Pixel format conversion */
    LL_ConvertLineToRGB(Instance, (uint32_t *)pbmp, (uint32_t *)Address, width, input_color_mode);
34184b4e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34184b50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34184b52:	9300      	str	r3, [sp, #0]
34184b54:	69bb      	ldr	r3, [r7, #24]
34184b56:	6a39      	ldr	r1, [r7, #32]
34184b58:	68f8      	ldr	r0, [r7, #12]
34184b5a:	f000 fb27 	bl	341851ac <LL_ConvertLineToRGB>

    /* Increment the source and destination buffers */
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
34184b5e:	4a12      	ldr	r2, [pc, #72]	@ (34184ba8 <BSP_LCD_DrawBitmap+0x17c>)
34184b60:	68fb      	ldr	r3, [r7, #12]
34184b62:	015b      	lsls	r3, r3, #5
34184b64:	4413      	add	r3, r2
34184b66:	681b      	ldr	r3, [r3, #0]
34184b68:	490f      	ldr	r1, [pc, #60]	@ (34184ba8 <BSP_LCD_DrawBitmap+0x17c>)
34184b6a:	68fa      	ldr	r2, [r7, #12]
34184b6c:	0152      	lsls	r2, r2, #5
34184b6e:	440a      	add	r2, r1
34184b70:	3210      	adds	r2, #16
34184b72:	6812      	ldr	r2, [r2, #0]
34184b74:	fb02 f303 	mul.w	r3, r2, r3
34184b78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34184b7a:	4413      	add	r3, r2
34184b7c:	62bb      	str	r3, [r7, #40]	@ 0x28
    pbmp -= width*(bit_pixel/8U);
34184b7e:	693b      	ldr	r3, [r7, #16]
34184b80:	08db      	lsrs	r3, r3, #3
34184b82:	69ba      	ldr	r2, [r7, #24]
34184b84:	fb02 f303 	mul.w	r3, r2, r3
34184b88:	425b      	negs	r3, r3
34184b8a:	6a3a      	ldr	r2, [r7, #32]
34184b8c:	4413      	add	r3, r2
34184b8e:	623b      	str	r3, [r7, #32]
  for(index=0; index < height; index++)
34184b90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184b92:	3301      	adds	r3, #1
34184b94:	62fb      	str	r3, [r7, #44]	@ 0x2c
34184b96:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34184b98:	697b      	ldr	r3, [r7, #20]
34184b9a:	429a      	cmp	r2, r3
34184b9c:	d3d7      	bcc.n	34184b4e <BSP_LCD_DrawBitmap+0x122>
  }

  return ret;
34184b9e:	69fb      	ldr	r3, [r7, #28]
}
34184ba0:	4618      	mov	r0, r3
34184ba2:	3730      	adds	r7, #48	@ 0x30
34184ba4:	46bd      	mov	sp, r7
34184ba6:	bd80      	pop	{r7, pc}
34184ba8:	341c1204 	.word	0x341c1204
34184bac:	341c115c 	.word	0x341c115c

34184bb0 <BSP_LCD_FillRGBRect>:
  * @param  Width Rectangle width.
  * @param  Height Rectangle Height.
  * @retval BSP status.
  */
int32_t BSP_LCD_FillRGBRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
34184bb0:	b580      	push	{r7, lr}
34184bb2:	b088      	sub	sp, #32
34184bb4:	af00      	add	r7, sp, #0
34184bb6:	60f8      	str	r0, [r7, #12]
34184bb8:	60b9      	str	r1, [r7, #8]
34184bba:	607a      	str	r2, [r7, #4]
34184bbc:	603b      	str	r3, [r7, #0]
  uint32_t i;
  uint8_t *pdata = pData;
34184bbe:	683b      	ldr	r3, [r7, #0]
34184bc0:	61bb      	str	r3, [r7, #24]
    pdata += Lcd_Ctx[Instance].BppFactor*Width;
  }
#else
  uint32_t color;
  uint32_t j;
  for(i = 0; i < Height; i++)
34184bc2:	2300      	movs	r3, #0
34184bc4:	61fb      	str	r3, [r7, #28]
34184bc6:	e032      	b.n	34184c2e <BSP_LCD_FillRGBRect+0x7e>
  {
    for(j = 0; j < Width; j++)
34184bc8:	2300      	movs	r3, #0
34184bca:	617b      	str	r3, [r7, #20]
34184bcc:	e028      	b.n	34184c20 <BSP_LCD_FillRGBRect+0x70>
    {
      color = (uint32_t)((uint32_t)*pdata | ((uint32_t)(*(pdata + 1U)) << 8U) | ((uint32_t)(*(pdata + 2U)) << 16U) | ((uint32_t)(*(pdata + 3U)) << 24U));
34184bce:	69bb      	ldr	r3, [r7, #24]
34184bd0:	781b      	ldrb	r3, [r3, #0]
34184bd2:	461a      	mov	r2, r3
34184bd4:	69bb      	ldr	r3, [r7, #24]
34184bd6:	3301      	adds	r3, #1
34184bd8:	781b      	ldrb	r3, [r3, #0]
34184bda:	021b      	lsls	r3, r3, #8
34184bdc:	431a      	orrs	r2, r3
34184bde:	69bb      	ldr	r3, [r7, #24]
34184be0:	3302      	adds	r3, #2
34184be2:	781b      	ldrb	r3, [r3, #0]
34184be4:	041b      	lsls	r3, r3, #16
34184be6:	431a      	orrs	r2, r3
34184be8:	69bb      	ldr	r3, [r7, #24]
34184bea:	3303      	adds	r3, #3
34184bec:	781b      	ldrb	r3, [r3, #0]
34184bee:	061b      	lsls	r3, r3, #24
34184bf0:	4313      	orrs	r3, r2
34184bf2:	613b      	str	r3, [r7, #16]
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
34184bf4:	68ba      	ldr	r2, [r7, #8]
34184bf6:	697b      	ldr	r3, [r7, #20]
34184bf8:	18d1      	adds	r1, r2, r3
34184bfa:	687a      	ldr	r2, [r7, #4]
34184bfc:	69fb      	ldr	r3, [r7, #28]
34184bfe:	441a      	add	r2, r3
34184c00:	693b      	ldr	r3, [r7, #16]
34184c02:	68f8      	ldr	r0, [r7, #12]
34184c04:	f000 f96c 	bl	34184ee0 <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
34184c08:	4a0d      	ldr	r2, [pc, #52]	@ (34184c40 <BSP_LCD_FillRGBRect+0x90>)
34184c0a:	68fb      	ldr	r3, [r7, #12]
34184c0c:	015b      	lsls	r3, r3, #5
34184c0e:	4413      	add	r3, r2
34184c10:	3310      	adds	r3, #16
34184c12:	681b      	ldr	r3, [r3, #0]
34184c14:	69ba      	ldr	r2, [r7, #24]
34184c16:	4413      	add	r3, r2
34184c18:	61bb      	str	r3, [r7, #24]
    for(j = 0; j < Width; j++)
34184c1a:	697b      	ldr	r3, [r7, #20]
34184c1c:	3301      	adds	r3, #1
34184c1e:	617b      	str	r3, [r7, #20]
34184c20:	697a      	ldr	r2, [r7, #20]
34184c22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34184c24:	429a      	cmp	r2, r3
34184c26:	d3d2      	bcc.n	34184bce <BSP_LCD_FillRGBRect+0x1e>
  for(i = 0; i < Height; i++)
34184c28:	69fb      	ldr	r3, [r7, #28]
34184c2a:	3301      	adds	r3, #1
34184c2c:	61fb      	str	r3, [r7, #28]
34184c2e:	69fa      	ldr	r2, [r7, #28]
34184c30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34184c32:	429a      	cmp	r2, r3
34184c34:	d3c8      	bcc.n	34184bc8 <BSP_LCD_FillRGBRect+0x18>
    }
  }
#endif /* (USE_DMA2D_TO_FILL_RGB_RECT == 1) */

  return BSP_ERROR_NONE;
34184c36:	2300      	movs	r3, #0
}
34184c38:	4618      	mov	r0, r3
34184c3a:	3720      	adds	r7, #32
34184c3c:	46bd      	mov	sp, r7
34184c3e:	bd80      	pop	{r7, pc}
34184c40:	341c1204 	.word	0x341c1204

34184c44 <BSP_LCD_DrawHLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawHLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34184c44:	b580      	push	{r7, lr}
34184c46:	b088      	sub	sp, #32
34184c48:	af02      	add	r7, sp, #8
34184c4a:	60f8      	str	r0, [r7, #12]
34184c4c:	60b9      	str	r1, [r7, #8]
34184c4e:	607a      	str	r2, [r7, #4]
34184c50:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34184c52:	4a18      	ldr	r2, [pc, #96]	@ (34184cb4 <BSP_LCD_DrawHLine+0x70>)
34184c54:	68fb      	ldr	r3, [r7, #12]
34184c56:	015b      	lsls	r3, r3, #5
34184c58:	4413      	add	r3, r2
34184c5a:	3308      	adds	r3, #8
34184c5c:	681b      	ldr	r3, [r3, #0]
34184c5e:	4a16      	ldr	r2, [pc, #88]	@ (34184cb8 <BSP_LCD_DrawHLine+0x74>)
34184c60:	2134      	movs	r1, #52	@ 0x34
34184c62:	fb01 f303 	mul.w	r3, r1, r3
34184c66:	4413      	add	r3, r2
34184c68:	335c      	adds	r3, #92	@ 0x5c
34184c6a:	681a      	ldr	r2, [r3, #0]
34184c6c:	4911      	ldr	r1, [pc, #68]	@ (34184cb4 <BSP_LCD_DrawHLine+0x70>)
34184c6e:	68fb      	ldr	r3, [r7, #12]
34184c70:	015b      	lsls	r3, r3, #5
34184c72:	440b      	add	r3, r1
34184c74:	3310      	adds	r3, #16
34184c76:	681b      	ldr	r3, [r3, #0]
34184c78:	480e      	ldr	r0, [pc, #56]	@ (34184cb4 <BSP_LCD_DrawHLine+0x70>)
34184c7a:	68f9      	ldr	r1, [r7, #12]
34184c7c:	0149      	lsls	r1, r1, #5
34184c7e:	4401      	add	r1, r0
34184c80:	6809      	ldr	r1, [r1, #0]
34184c82:	6878      	ldr	r0, [r7, #4]
34184c84:	fb01 f000 	mul.w	r0, r1, r0
34184c88:	68b9      	ldr	r1, [r7, #8]
34184c8a:	4401      	add	r1, r0
34184c8c:	fb01 f303 	mul.w	r3, r1, r3
34184c90:	4413      	add	r3, r2
34184c92:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
34184c94:	6979      	ldr	r1, [r7, #20]
34184c96:	6a3b      	ldr	r3, [r7, #32]
34184c98:	9301      	str	r3, [sp, #4]
34184c9a:	2300      	movs	r3, #0
34184c9c:	9300      	str	r3, [sp, #0]
34184c9e:	2301      	movs	r3, #1
34184ca0:	683a      	ldr	r2, [r7, #0]
34184ca2:	68f8      	ldr	r0, [r7, #12]
34184ca4:	f000 f9e6 	bl	34185074 <LL_FillBuffer>

  return BSP_ERROR_NONE;
34184ca8:	2300      	movs	r3, #0
}
34184caa:	4618      	mov	r0, r3
34184cac:	3718      	adds	r7, #24
34184cae:	46bd      	mov	sp, r7
34184cb0:	bd80      	pop	{r7, pc}
34184cb2:	bf00      	nop
34184cb4:	341c1204 	.word	0x341c1204
34184cb8:	341c115c 	.word	0x341c115c

34184cbc <BSP_LCD_DrawVLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawVLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34184cbc:	b580      	push	{r7, lr}
34184cbe:	b088      	sub	sp, #32
34184cc0:	af02      	add	r7, sp, #8
34184cc2:	60f8      	str	r0, [r7, #12]
34184cc4:	60b9      	str	r1, [r7, #8]
34184cc6:	607a      	str	r2, [r7, #4]
34184cc8:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34184cca:	4a1a      	ldr	r2, [pc, #104]	@ (34184d34 <BSP_LCD_DrawVLine+0x78>)
34184ccc:	68fb      	ldr	r3, [r7, #12]
34184cce:	015b      	lsls	r3, r3, #5
34184cd0:	4413      	add	r3, r2
34184cd2:	3308      	adds	r3, #8
34184cd4:	681b      	ldr	r3, [r3, #0]
34184cd6:	4a18      	ldr	r2, [pc, #96]	@ (34184d38 <BSP_LCD_DrawVLine+0x7c>)
34184cd8:	2134      	movs	r1, #52	@ 0x34
34184cda:	fb01 f303 	mul.w	r3, r1, r3
34184cde:	4413      	add	r3, r2
34184ce0:	335c      	adds	r3, #92	@ 0x5c
34184ce2:	681a      	ldr	r2, [r3, #0]
34184ce4:	4913      	ldr	r1, [pc, #76]	@ (34184d34 <BSP_LCD_DrawVLine+0x78>)
34184ce6:	68fb      	ldr	r3, [r7, #12]
34184ce8:	015b      	lsls	r3, r3, #5
34184cea:	440b      	add	r3, r1
34184cec:	3310      	adds	r3, #16
34184cee:	681b      	ldr	r3, [r3, #0]
34184cf0:	4810      	ldr	r0, [pc, #64]	@ (34184d34 <BSP_LCD_DrawVLine+0x78>)
34184cf2:	68f9      	ldr	r1, [r7, #12]
34184cf4:	0149      	lsls	r1, r1, #5
34184cf6:	4401      	add	r1, r0
34184cf8:	6809      	ldr	r1, [r1, #0]
34184cfa:	6878      	ldr	r0, [r7, #4]
34184cfc:	fb01 f000 	mul.w	r0, r1, r0
34184d00:	68b9      	ldr	r1, [r7, #8]
34184d02:	4401      	add	r1, r0
34184d04:	fb01 f303 	mul.w	r3, r1, r3
34184d08:	4413      	add	r3, r2
34184d0a:	617b      	str	r3, [r7, #20]

  /* Write line */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
34184d0c:	6979      	ldr	r1, [r7, #20]
34184d0e:	4a09      	ldr	r2, [pc, #36]	@ (34184d34 <BSP_LCD_DrawVLine+0x78>)
34184d10:	68fb      	ldr	r3, [r7, #12]
34184d12:	015b      	lsls	r3, r3, #5
34184d14:	4413      	add	r3, r2
34184d16:	681b      	ldr	r3, [r3, #0]
34184d18:	3b01      	subs	r3, #1
34184d1a:	6a3a      	ldr	r2, [r7, #32]
34184d1c:	9201      	str	r2, [sp, #4]
34184d1e:	9300      	str	r3, [sp, #0]
34184d20:	683b      	ldr	r3, [r7, #0]
34184d22:	2201      	movs	r2, #1
34184d24:	68f8      	ldr	r0, [r7, #12]
34184d26:	f000 f9a5 	bl	34185074 <LL_FillBuffer>

  return BSP_ERROR_NONE;
34184d2a:	2300      	movs	r3, #0
}
34184d2c:	4618      	mov	r0, r3
34184d2e:	3718      	adds	r7, #24
34184d30:	46bd      	mov	sp, r7
34184d32:	bd80      	pop	{r7, pc}
34184d34:	341c1204 	.word	0x341c1204
34184d38:	341c115c 	.word	0x341c115c

34184d3c <BSP_LCD_FillRect>:
  * @param  Height Rectangle height
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_FillRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34184d3c:	b580      	push	{r7, lr}
34184d3e:	b088      	sub	sp, #32
34184d40:	af02      	add	r7, sp, #8
34184d42:	60f8      	str	r0, [r7, #12]
34184d44:	60b9      	str	r1, [r7, #8]
34184d46:	607a      	str	r2, [r7, #4]
34184d48:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the rectangle start address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
34184d4a:	4a1b      	ldr	r2, [pc, #108]	@ (34184db8 <BSP_LCD_FillRect+0x7c>)
34184d4c:	68fb      	ldr	r3, [r7, #12]
34184d4e:	015b      	lsls	r3, r3, #5
34184d50:	4413      	add	r3, r2
34184d52:	3308      	adds	r3, #8
34184d54:	681b      	ldr	r3, [r3, #0]
34184d56:	4a19      	ldr	r2, [pc, #100]	@ (34184dbc <BSP_LCD_FillRect+0x80>)
34184d58:	2134      	movs	r1, #52	@ 0x34
34184d5a:	fb01 f303 	mul.w	r3, r1, r3
34184d5e:	4413      	add	r3, r2
34184d60:	335c      	adds	r3, #92	@ 0x5c
34184d62:	681a      	ldr	r2, [r3, #0]
34184d64:	4914      	ldr	r1, [pc, #80]	@ (34184db8 <BSP_LCD_FillRect+0x7c>)
34184d66:	68fb      	ldr	r3, [r7, #12]
34184d68:	015b      	lsls	r3, r3, #5
34184d6a:	440b      	add	r3, r1
34184d6c:	3310      	adds	r3, #16
34184d6e:	681b      	ldr	r3, [r3, #0]
34184d70:	4811      	ldr	r0, [pc, #68]	@ (34184db8 <BSP_LCD_FillRect+0x7c>)
34184d72:	68f9      	ldr	r1, [r7, #12]
34184d74:	0149      	lsls	r1, r1, #5
34184d76:	4401      	add	r1, r0
34184d78:	6809      	ldr	r1, [r1, #0]
34184d7a:	6878      	ldr	r0, [r7, #4]
34184d7c:	fb01 f000 	mul.w	r0, r1, r0
34184d80:	68b9      	ldr	r1, [r7, #8]
34184d82:	4401      	add	r1, r0
34184d84:	fb01 f303 	mul.w	r3, r1, r3
34184d88:	4413      	add	r3, r2
34184d8a:	617b      	str	r3, [r7, #20]

  /* Fill the rectangle */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34184d8c:	6979      	ldr	r1, [r7, #20]
34184d8e:	4a0a      	ldr	r2, [pc, #40]	@ (34184db8 <BSP_LCD_FillRect+0x7c>)
34184d90:	68fb      	ldr	r3, [r7, #12]
34184d92:	015b      	lsls	r3, r3, #5
34184d94:	4413      	add	r3, r2
34184d96:	681a      	ldr	r2, [r3, #0]
34184d98:	683b      	ldr	r3, [r7, #0]
34184d9a:	1ad3      	subs	r3, r2, r3
34184d9c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34184d9e:	9201      	str	r2, [sp, #4]
34184da0:	9300      	str	r3, [sp, #0]
34184da2:	6a3b      	ldr	r3, [r7, #32]
34184da4:	683a      	ldr	r2, [r7, #0]
34184da6:	68f8      	ldr	r0, [r7, #12]
34184da8:	f000 f964 	bl	34185074 <LL_FillBuffer>

  return BSP_ERROR_NONE;
34184dac:	2300      	movs	r3, #0
}
34184dae:	4618      	mov	r0, r3
34184db0:	3718      	adds	r7, #24
34184db2:	46bd      	mov	sp, r7
34184db4:	bd80      	pop	{r7, pc}
34184db6:	bf00      	nop
34184db8:	341c1204 	.word	0x341c1204
34184dbc:	341c115c 	.word	0x341c115c

34184dc0 <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
34184dc0:	b480      	push	{r7}
34184dc2:	b085      	sub	sp, #20
34184dc4:	af00      	add	r7, sp, #0
34184dc6:	60f8      	str	r0, [r7, #12]
34184dc8:	60b9      	str	r1, [r7, #8]
34184dca:	607a      	str	r2, [r7, #4]
34184dcc:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34184dce:	4a42      	ldr	r2, [pc, #264]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184dd0:	68fb      	ldr	r3, [r7, #12]
34184dd2:	015b      	lsls	r3, r3, #5
34184dd4:	4413      	add	r3, r2
34184dd6:	3308      	adds	r3, #8
34184dd8:	681b      	ldr	r3, [r3, #0]
34184dda:	4a40      	ldr	r2, [pc, #256]	@ (34184edc <BSP_LCD_ReadPixel+0x11c>)
34184ddc:	2134      	movs	r1, #52	@ 0x34
34184dde:	fb01 f303 	mul.w	r3, r1, r3
34184de2:	4413      	add	r3, r2
34184de4:	3348      	adds	r3, #72	@ 0x48
34184de6:	681b      	ldr	r3, [r3, #0]
34184de8:	2b00      	cmp	r3, #0
34184dea:	d11c      	bne.n	34184e26 <BSP_LCD_ReadPixel+0x66>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34184dec:	4a3a      	ldr	r2, [pc, #232]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184dee:	68fb      	ldr	r3, [r7, #12]
34184df0:	015b      	lsls	r3, r3, #5
34184df2:	4413      	add	r3, r2
34184df4:	3308      	adds	r3, #8
34184df6:	681b      	ldr	r3, [r3, #0]
34184df8:	4a38      	ldr	r2, [pc, #224]	@ (34184edc <BSP_LCD_ReadPixel+0x11c>)
34184dfa:	2134      	movs	r1, #52	@ 0x34
34184dfc:	fb01 f303 	mul.w	r3, r1, r3
34184e00:	4413      	add	r3, r2
34184e02:	335c      	adds	r3, #92	@ 0x5c
34184e04:	681a      	ldr	r2, [r3, #0]
34184e06:	4934      	ldr	r1, [pc, #208]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184e08:	68fb      	ldr	r3, [r7, #12]
34184e0a:	015b      	lsls	r3, r3, #5
34184e0c:	440b      	add	r3, r1
34184e0e:	681b      	ldr	r3, [r3, #0]
34184e10:	6879      	ldr	r1, [r7, #4]
34184e12:	fb03 f101 	mul.w	r1, r3, r1
34184e16:	68bb      	ldr	r3, [r7, #8]
34184e18:	440b      	add	r3, r1
34184e1a:	009b      	lsls	r3, r3, #2
34184e1c:	4413      	add	r3, r2
34184e1e:	681a      	ldr	r2, [r3, #0]
34184e20:	683b      	ldr	r3, [r7, #0]
34184e22:	601a      	str	r2, [r3, #0]
34184e24:	e051      	b.n	34184eca <BSP_LCD_ReadPixel+0x10a>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34184e26:	4a2c      	ldr	r2, [pc, #176]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184e28:	68fb      	ldr	r3, [r7, #12]
34184e2a:	015b      	lsls	r3, r3, #5
34184e2c:	4413      	add	r3, r2
34184e2e:	3308      	adds	r3, #8
34184e30:	681b      	ldr	r3, [r3, #0]
34184e32:	4a2a      	ldr	r2, [pc, #168]	@ (34184edc <BSP_LCD_ReadPixel+0x11c>)
34184e34:	2134      	movs	r1, #52	@ 0x34
34184e36:	fb01 f303 	mul.w	r3, r1, r3
34184e3a:	4413      	add	r3, r2
34184e3c:	3348      	adds	r3, #72	@ 0x48
34184e3e:	681b      	ldr	r3, [r3, #0]
34184e40:	2b06      	cmp	r3, #6
34184e42:	d124      	bne.n	34184e8e <BSP_LCD_ReadPixel+0xce>
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34184e44:	4a24      	ldr	r2, [pc, #144]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184e46:	68fb      	ldr	r3, [r7, #12]
34184e48:	015b      	lsls	r3, r3, #5
34184e4a:	4413      	add	r3, r2
34184e4c:	3308      	adds	r3, #8
34184e4e:	681b      	ldr	r3, [r3, #0]
34184e50:	4a22      	ldr	r2, [pc, #136]	@ (34184edc <BSP_LCD_ReadPixel+0x11c>)
34184e52:	2134      	movs	r1, #52	@ 0x34
34184e54:	fb01 f303 	mul.w	r3, r1, r3
34184e58:	4413      	add	r3, r2
34184e5a:	335c      	adds	r3, #92	@ 0x5c
34184e5c:	6819      	ldr	r1, [r3, #0]
34184e5e:	4a1e      	ldr	r2, [pc, #120]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184e60:	68fb      	ldr	r3, [r7, #12]
34184e62:	015b      	lsls	r3, r3, #5
34184e64:	4413      	add	r3, r2
34184e66:	681b      	ldr	r3, [r3, #0]
34184e68:	687a      	ldr	r2, [r7, #4]
34184e6a:	fb03 f202 	mul.w	r2, r3, r2
34184e6e:	68bb      	ldr	r3, [r7, #8]
34184e70:	441a      	add	r2, r3
34184e72:	4613      	mov	r3, r2
34184e74:	005b      	lsls	r3, r3, #1
34184e76:	4413      	add	r3, r2
34184e78:	440b      	add	r3, r1
34184e7a:	681a      	ldr	r2, [r3, #0]
34184e7c:	683b      	ldr	r3, [r7, #0]
34184e7e:	601a      	str	r2, [r3, #0]
    *Color = CONVERTARGB88882RGB888(*Color);
34184e80:	683b      	ldr	r3, [r7, #0]
34184e82:	681b      	ldr	r3, [r3, #0]
34184e84:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34184e88:	683b      	ldr	r3, [r7, #0]
34184e8a:	601a      	str	r2, [r3, #0]
34184e8c:	e01d      	b.n	34184eca <BSP_LCD_ReadPixel+0x10a>
  }
  else /* if((hlcd_ltdc.LayerCfg[layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565) */
  {
    /* Read data value from RAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
34184e8e:	4a12      	ldr	r2, [pc, #72]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184e90:	68fb      	ldr	r3, [r7, #12]
34184e92:	015b      	lsls	r3, r3, #5
34184e94:	4413      	add	r3, r2
34184e96:	3308      	adds	r3, #8
34184e98:	681b      	ldr	r3, [r3, #0]
34184e9a:	4a10      	ldr	r2, [pc, #64]	@ (34184edc <BSP_LCD_ReadPixel+0x11c>)
34184e9c:	2134      	movs	r1, #52	@ 0x34
34184e9e:	fb01 f303 	mul.w	r3, r1, r3
34184ea2:	4413      	add	r3, r2
34184ea4:	335c      	adds	r3, #92	@ 0x5c
34184ea6:	681a      	ldr	r2, [r3, #0]
34184ea8:	490b      	ldr	r1, [pc, #44]	@ (34184ed8 <BSP_LCD_ReadPixel+0x118>)
34184eaa:	68fb      	ldr	r3, [r7, #12]
34184eac:	015b      	lsls	r3, r3, #5
34184eae:	440b      	add	r3, r1
34184eb0:	681b      	ldr	r3, [r3, #0]
34184eb2:	6879      	ldr	r1, [r7, #4]
34184eb4:	fb03 f101 	mul.w	r1, r3, r1
34184eb8:	68bb      	ldr	r3, [r7, #8]
34184eba:	440b      	add	r3, r1
34184ebc:	005b      	lsls	r3, r3, #1
34184ebe:	4413      	add	r3, r2
34184ec0:	881b      	ldrh	r3, [r3, #0]
34184ec2:	b29b      	uxth	r3, r3
34184ec4:	461a      	mov	r2, r3
34184ec6:	683b      	ldr	r3, [r7, #0]
34184ec8:	601a      	str	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
34184eca:	2300      	movs	r3, #0
}
34184ecc:	4618      	mov	r0, r3
34184ece:	3714      	adds	r7, #20
34184ed0:	46bd      	mov	sp, r7
34184ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
34184ed6:	4770      	bx	lr
34184ed8:	341c1204 	.word	0x341c1204
34184edc:	341c115c 	.word	0x341c115c

34184ee0 <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
34184ee0:	b480      	push	{r7}
34184ee2:	b085      	sub	sp, #20
34184ee4:	af00      	add	r7, sp, #0
34184ee6:	60f8      	str	r0, [r7, #12]
34184ee8:	60b9      	str	r1, [r7, #8]
34184eea:	607a      	str	r2, [r7, #4]
34184eec:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34184eee:	4a5f      	ldr	r2, [pc, #380]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184ef0:	68fb      	ldr	r3, [r7, #12]
34184ef2:	015b      	lsls	r3, r3, #5
34184ef4:	4413      	add	r3, r2
34184ef6:	3308      	adds	r3, #8
34184ef8:	681b      	ldr	r3, [r3, #0]
34184efa:	4a5d      	ldr	r2, [pc, #372]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184efc:	2134      	movs	r1, #52	@ 0x34
34184efe:	fb01 f303 	mul.w	r3, r1, r3
34184f02:	4413      	add	r3, r2
34184f04:	3348      	adds	r3, #72	@ 0x48
34184f06:	681b      	ldr	r3, [r3, #0]
34184f08:	2b00      	cmp	r3, #0
34184f0a:	d11c      	bne.n	34184f46 <BSP_LCD_WritePixel+0x66>
  {
    /* Write data value to RAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
34184f0c:	4a57      	ldr	r2, [pc, #348]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184f0e:	68fb      	ldr	r3, [r7, #12]
34184f10:	015b      	lsls	r3, r3, #5
34184f12:	4413      	add	r3, r2
34184f14:	3308      	adds	r3, #8
34184f16:	681b      	ldr	r3, [r3, #0]
34184f18:	4a55      	ldr	r2, [pc, #340]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184f1a:	2134      	movs	r1, #52	@ 0x34
34184f1c:	fb01 f303 	mul.w	r3, r1, r3
34184f20:	4413      	add	r3, r2
34184f22:	335c      	adds	r3, #92	@ 0x5c
34184f24:	681a      	ldr	r2, [r3, #0]
34184f26:	4951      	ldr	r1, [pc, #324]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184f28:	68fb      	ldr	r3, [r7, #12]
34184f2a:	015b      	lsls	r3, r3, #5
34184f2c:	440b      	add	r3, r1
34184f2e:	681b      	ldr	r3, [r3, #0]
34184f30:	6879      	ldr	r1, [r7, #4]
34184f32:	fb03 f101 	mul.w	r1, r3, r1
34184f36:	68bb      	ldr	r3, [r7, #8]
34184f38:	440b      	add	r3, r1
34184f3a:	009b      	lsls	r3, r3, #2
34184f3c:	4413      	add	r3, r2
34184f3e:	461a      	mov	r2, r3
34184f40:	683b      	ldr	r3, [r7, #0]
34184f42:	6013      	str	r3, [r2, #0]
34184f44:	e08a      	b.n	3418505c <BSP_LCD_WritePixel+0x17c>
  }
  else if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34184f46:	4a49      	ldr	r2, [pc, #292]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184f48:	68fb      	ldr	r3, [r7, #12]
34184f4a:	015b      	lsls	r3, r3, #5
34184f4c:	4413      	add	r3, r2
34184f4e:	3308      	adds	r3, #8
34184f50:	681b      	ldr	r3, [r3, #0]
34184f52:	4a47      	ldr	r2, [pc, #284]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184f54:	2134      	movs	r1, #52	@ 0x34
34184f56:	fb01 f303 	mul.w	r3, r1, r3
34184f5a:	4413      	add	r3, r2
34184f5c:	3348      	adds	r3, #72	@ 0x48
34184f5e:	681b      	ldr	r3, [r3, #0]
34184f60:	2b06      	cmp	r3, #6
34184f62:	d15f      	bne.n	34185024 <BSP_LCD_WritePixel+0x144>
  {
    /* Write data value to RAM memory */
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-3U)) = (uint8_t) (Color);
34184f64:	4a41      	ldr	r2, [pc, #260]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184f66:	68fb      	ldr	r3, [r7, #12]
34184f68:	015b      	lsls	r3, r3, #5
34184f6a:	4413      	add	r3, r2
34184f6c:	3308      	adds	r3, #8
34184f6e:	681b      	ldr	r3, [r3, #0]
34184f70:	4a3f      	ldr	r2, [pc, #252]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184f72:	2134      	movs	r1, #52	@ 0x34
34184f74:	fb01 f303 	mul.w	r3, r1, r3
34184f78:	4413      	add	r3, r2
34184f7a:	335c      	adds	r3, #92	@ 0x5c
34184f7c:	6819      	ldr	r1, [r3, #0]
34184f7e:	4a3b      	ldr	r2, [pc, #236]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184f80:	68fb      	ldr	r3, [r7, #12]
34184f82:	015b      	lsls	r3, r3, #5
34184f84:	4413      	add	r3, r2
34184f86:	681b      	ldr	r3, [r3, #0]
34184f88:	687a      	ldr	r2, [r7, #4]
34184f8a:	fb03 f202 	mul.w	r2, r3, r2
34184f8e:	68bb      	ldr	r3, [r7, #8]
34184f90:	441a      	add	r2, r3
34184f92:	4613      	mov	r3, r2
34184f94:	005b      	lsls	r3, r3, #1
34184f96:	4413      	add	r3, r2
34184f98:	440b      	add	r3, r1
34184f9a:	3b03      	subs	r3, #3
34184f9c:	683a      	ldr	r2, [r7, #0]
34184f9e:	b2d2      	uxtb	r2, r2
34184fa0:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-2U)) = (uint8_t) (Color>>8U);
34184fa2:	683b      	ldr	r3, [r7, #0]
34184fa4:	0a18      	lsrs	r0, r3, #8
34184fa6:	4a31      	ldr	r2, [pc, #196]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184fa8:	68fb      	ldr	r3, [r7, #12]
34184faa:	015b      	lsls	r3, r3, #5
34184fac:	4413      	add	r3, r2
34184fae:	3308      	adds	r3, #8
34184fb0:	681b      	ldr	r3, [r3, #0]
34184fb2:	4a2f      	ldr	r2, [pc, #188]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184fb4:	2134      	movs	r1, #52	@ 0x34
34184fb6:	fb01 f303 	mul.w	r3, r1, r3
34184fba:	4413      	add	r3, r2
34184fbc:	335c      	adds	r3, #92	@ 0x5c
34184fbe:	6819      	ldr	r1, [r3, #0]
34184fc0:	4a2a      	ldr	r2, [pc, #168]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184fc2:	68fb      	ldr	r3, [r7, #12]
34184fc4:	015b      	lsls	r3, r3, #5
34184fc6:	4413      	add	r3, r2
34184fc8:	681b      	ldr	r3, [r3, #0]
34184fca:	687a      	ldr	r2, [r7, #4]
34184fcc:	fb03 f202 	mul.w	r2, r3, r2
34184fd0:	68bb      	ldr	r3, [r7, #8]
34184fd2:	441a      	add	r2, r3
34184fd4:	4613      	mov	r3, r2
34184fd6:	005b      	lsls	r3, r3, #1
34184fd8:	4413      	add	r3, r2
34184fda:	440b      	add	r3, r1
34184fdc:	3b02      	subs	r3, #2
34184fde:	b2c2      	uxtb	r2, r0
34184fe0:	701a      	strb	r2, [r3, #0]
    *(__IO uint8_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + ((3U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))-1U)) = (uint8_t) (Color>>16U);
34184fe2:	683b      	ldr	r3, [r7, #0]
34184fe4:	0c18      	lsrs	r0, r3, #16
34184fe6:	4a21      	ldr	r2, [pc, #132]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34184fe8:	68fb      	ldr	r3, [r7, #12]
34184fea:	015b      	lsls	r3, r3, #5
34184fec:	4413      	add	r3, r2
34184fee:	3308      	adds	r3, #8
34184ff0:	681b      	ldr	r3, [r3, #0]
34184ff2:	4a1f      	ldr	r2, [pc, #124]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34184ff4:	2134      	movs	r1, #52	@ 0x34
34184ff6:	fb01 f303 	mul.w	r3, r1, r3
34184ffa:	4413      	add	r3, r2
34184ffc:	335c      	adds	r3, #92	@ 0x5c
34184ffe:	6819      	ldr	r1, [r3, #0]
34185000:	4a1a      	ldr	r2, [pc, #104]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34185002:	68fb      	ldr	r3, [r7, #12]
34185004:	015b      	lsls	r3, r3, #5
34185006:	4413      	add	r3, r2
34185008:	681b      	ldr	r3, [r3, #0]
3418500a:	687a      	ldr	r2, [r7, #4]
3418500c:	fb03 f202 	mul.w	r2, r3, r2
34185010:	68bb      	ldr	r3, [r7, #8]
34185012:	441a      	add	r2, r3
34185014:	4613      	mov	r3, r2
34185016:	005b      	lsls	r3, r3, #1
34185018:	4413      	add	r3, r2
3418501a:	440b      	add	r3, r1
3418501c:	3b01      	subs	r3, #1
3418501e:	b2c2      	uxtb	r2, r0
34185020:	701a      	strb	r2, [r3, #0]
34185022:	e01b      	b.n	3418505c <BSP_LCD_WritePixel+0x17c>
  }
  else
  {
    /* Write data value to RAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
34185024:	4a11      	ldr	r2, [pc, #68]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34185026:	68fb      	ldr	r3, [r7, #12]
34185028:	015b      	lsls	r3, r3, #5
3418502a:	4413      	add	r3, r2
3418502c:	3308      	adds	r3, #8
3418502e:	681b      	ldr	r3, [r3, #0]
34185030:	4a0f      	ldr	r2, [pc, #60]	@ (34185070 <BSP_LCD_WritePixel+0x190>)
34185032:	2134      	movs	r1, #52	@ 0x34
34185034:	fb01 f303 	mul.w	r3, r1, r3
34185038:	4413      	add	r3, r2
3418503a:	335c      	adds	r3, #92	@ 0x5c
3418503c:	681a      	ldr	r2, [r3, #0]
3418503e:	490b      	ldr	r1, [pc, #44]	@ (3418506c <BSP_LCD_WritePixel+0x18c>)
34185040:	68fb      	ldr	r3, [r7, #12]
34185042:	015b      	lsls	r3, r3, #5
34185044:	440b      	add	r3, r1
34185046:	681b      	ldr	r3, [r3, #0]
34185048:	6879      	ldr	r1, [r7, #4]
3418504a:	fb03 f101 	mul.w	r1, r3, r1
3418504e:	68bb      	ldr	r3, [r7, #8]
34185050:	440b      	add	r3, r1
34185052:	005b      	lsls	r3, r3, #1
34185054:	4413      	add	r3, r2
34185056:	683a      	ldr	r2, [r7, #0]
34185058:	b292      	uxth	r2, r2
3418505a:	801a      	strh	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
3418505c:	2300      	movs	r3, #0
}
3418505e:	4618      	mov	r0, r3
34185060:	3714      	adds	r7, #20
34185062:	46bd      	mov	sp, r7
34185064:	f85d 7b04 	ldr.w	r7, [sp], #4
34185068:	4770      	bx	lr
3418506a:	bf00      	nop
3418506c:	341c1204 	.word	0x341c1204
34185070:	341c115c 	.word	0x341c115c

34185074 <LL_FillBuffer>:
  * @param  ySize Buffer height
  * @param  OffLine Offset
  * @param  Color RGB color
  */
static void LL_FillBuffer(uint32_t Instance, uint32_t *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t Color)
{
34185074:	b580      	push	{r7, lr}
34185076:	b088      	sub	sp, #32
34185078:	af02      	add	r7, sp, #8
3418507a:	60f8      	str	r0, [r7, #12]
3418507c:	60b9      	str	r1, [r7, #8]
3418507e:	607a      	str	r2, [r7, #4]
34185080:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;
  uint32_t input_color = Color;
34185082:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34185084:	613b      	str	r3, [r7, #16]

  switch(Lcd_Ctx[Instance].PixelFormat)
34185086:	4a46      	ldr	r2, [pc, #280]	@ (341851a0 <LL_FillBuffer+0x12c>)
34185088:	68fb      	ldr	r3, [r7, #12]
3418508a:	015b      	lsls	r3, r3, #5
3418508c:	4413      	add	r3, r2
3418508e:	330c      	adds	r3, #12
34185090:	681b      	ldr	r3, [r3, #0]
34185092:	2b04      	cmp	r3, #4
34185094:	d02f      	beq.n	341850f6 <LL_FillBuffer+0x82>
34185096:	2b04      	cmp	r3, #4
34185098:	d859      	bhi.n	3418514e <LL_FillBuffer+0xda>
3418509a:	2b01      	cmp	r3, #1
3418509c:	d050      	beq.n	34185140 <LL_FillBuffer+0xcc>
3418509e:	2b02      	cmp	r3, #2
341850a0:	d155      	bne.n	3418514e <LL_FillBuffer+0xda>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
341850a2:	2302      	movs	r3, #2
341850a4:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB5652ARGB8888(Color);
341850a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341850a8:	0adb      	lsrs	r3, r3, #11
341850aa:	f003 021f 	and.w	r2, r3, #31
341850ae:	4613      	mov	r3, r2
341850b0:	011b      	lsls	r3, r3, #4
341850b2:	4413      	add	r3, r2
341850b4:	015a      	lsls	r2, r3, #5
341850b6:	1ad3      	subs	r3, r2, r3
341850b8:	3317      	adds	r3, #23
341850ba:	099b      	lsrs	r3, r3, #6
341850bc:	0419      	lsls	r1, r3, #16
341850be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341850c0:	095b      	lsrs	r3, r3, #5
341850c2:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
341850c6:	4613      	mov	r3, r2
341850c8:	01db      	lsls	r3, r3, #7
341850ca:	4413      	add	r3, r2
341850cc:	005b      	lsls	r3, r3, #1
341850ce:	4413      	add	r3, r2
341850d0:	3321      	adds	r3, #33	@ 0x21
341850d2:	099b      	lsrs	r3, r3, #6
341850d4:	021b      	lsls	r3, r3, #8
341850d6:	4319      	orrs	r1, r3
341850d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341850da:	f003 021f 	and.w	r2, r3, #31
341850de:	4613      	mov	r3, r2
341850e0:	011b      	lsls	r3, r3, #4
341850e2:	4413      	add	r3, r2
341850e4:	015a      	lsls	r2, r3, #5
341850e6:	1ad3      	subs	r3, r2, r3
341850e8:	3317      	adds	r3, #23
341850ea:	099b      	lsrs	r3, r3, #6
341850ec:	430b      	orrs	r3, r1
341850ee:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
341850f2:	613b      	str	r3, [r7, #16]
    break;
341850f4:	e02e      	b.n	34185154 <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
341850f6:	2304      	movs	r3, #4
341850f8:	617b      	str	r3, [r7, #20]
    input_color = CONVERTARGB44442ARGB8888(Color);
341850fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
341850fc:	0b1b      	lsrs	r3, r3, #12
341850fe:	f003 020f 	and.w	r2, r3, #15
34185102:	4613      	mov	r3, r2
34185104:	011b      	lsls	r3, r3, #4
34185106:	4413      	add	r3, r2
34185108:	0619      	lsls	r1, r3, #24
3418510a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418510c:	0a1b      	lsrs	r3, r3, #8
3418510e:	f003 020f 	and.w	r2, r3, #15
34185112:	4613      	mov	r3, r2
34185114:	011b      	lsls	r3, r3, #4
34185116:	4413      	add	r3, r2
34185118:	041b      	lsls	r3, r3, #16
3418511a:	4319      	orrs	r1, r3
3418511c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418511e:	091b      	lsrs	r3, r3, #4
34185120:	f003 020f 	and.w	r2, r3, #15
34185124:	4613      	mov	r3, r2
34185126:	011b      	lsls	r3, r3, #4
34185128:	4413      	add	r3, r2
3418512a:	021b      	lsls	r3, r3, #8
3418512c:	4319      	orrs	r1, r3
3418512e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34185130:	f003 020f 	and.w	r2, r3, #15
34185134:	4613      	mov	r3, r2
34185136:	011b      	lsls	r3, r3, #4
34185138:	4413      	add	r3, r2
3418513a:	430b      	orrs	r3, r1
3418513c:	613b      	str	r3, [r7, #16]
    break;
3418513e:	e009      	b.n	34185154 <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
34185140:	2301      	movs	r3, #1
34185142:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB8882ARGB8888(Color);
34185144:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34185146:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
3418514a:	613b      	str	r3, [r7, #16]
    break;
3418514c:	e002      	b.n	34185154 <LL_FillBuffer+0xe0>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
3418514e:	2300      	movs	r3, #0
34185150:	617b      	str	r3, [r7, #20]
    break;
34185152:	bf00      	nop
  }

  /* Register to memory mode with ARGB8888 as color Mode */
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
34185154:	4b13      	ldr	r3, [pc, #76]	@ (341851a4 <LL_FillBuffer+0x130>)
34185156:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
3418515a:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
3418515c:	4a11      	ldr	r2, [pc, #68]	@ (341851a4 <LL_FillBuffer+0x130>)
3418515e:	697b      	ldr	r3, [r7, #20]
34185160:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = OffLine;
34185162:	4a10      	ldr	r2, [pc, #64]	@ (341851a4 <LL_FillBuffer+0x130>)
34185164:	6a3b      	ldr	r3, [r7, #32]
34185166:	60d3      	str	r3, [r2, #12]

  hlcd_dma2d.Instance = DMA2D;
34185168:	4b0e      	ldr	r3, [pc, #56]	@ (341851a4 <LL_FillBuffer+0x130>)
3418516a:	4a0f      	ldr	r2, [pc, #60]	@ (341851a8 <LL_FillBuffer+0x134>)
3418516c:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
3418516e:	480d      	ldr	r0, [pc, #52]	@ (341851a4 <LL_FillBuffer+0x130>)
34185170:	f004 fd10 	bl	34189b94 <HAL_DMA2D_Init>
34185174:	4603      	mov	r3, r0
34185176:	2b00      	cmp	r3, #0
34185178:	d10e      	bne.n	34185198 <LL_FillBuffer+0x124>
  {
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
3418517a:	68ba      	ldr	r2, [r7, #8]
3418517c:	683b      	ldr	r3, [r7, #0]
3418517e:	9300      	str	r3, [sp, #0]
34185180:	687b      	ldr	r3, [r7, #4]
34185182:	6939      	ldr	r1, [r7, #16]
34185184:	4807      	ldr	r0, [pc, #28]	@ (341851a4 <LL_FillBuffer+0x130>)
34185186:	f004 fd70 	bl	34189c6a <HAL_DMA2D_Start>
3418518a:	4603      	mov	r3, r0
3418518c:	2b00      	cmp	r3, #0
3418518e:	d103      	bne.n	34185198 <LL_FillBuffer+0x124>
    {
      /* Polling For DMA transfer */
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34185190:	2132      	movs	r1, #50	@ 0x32
34185192:	4804      	ldr	r0, [pc, #16]	@ (341851a4 <LL_FillBuffer+0x130>)
34185194:	f004 fd94 	bl	34189cc0 <HAL_DMA2D_PollForTransfer>
    }
  }
}
34185198:	bf00      	nop
3418519a:	3718      	adds	r7, #24
3418519c:	46bd      	mov	sp, r7
3418519e:	bd80      	pop	{r7, pc}
341851a0:	341c1204 	.word	0x341c1204
341851a4:	341c10f4 	.word	0x341c10f4
341851a8:	58021000 	.word	0x58021000

341851ac <LL_ConvertLineToRGB>:
  * @param  pDst Output color
  * @param  xSize Buffer width
  * @param  ColorMode Input color mode
  */
static void LL_ConvertLineToRGB(uint32_t Instance, uint32_t *pSrc, uint32_t *pDst, uint32_t xSize, uint32_t ColorMode)
{
341851ac:	b580      	push	{r7, lr}
341851ae:	b088      	sub	sp, #32
341851b0:	af02      	add	r7, sp, #8
341851b2:	60f8      	str	r0, [r7, #12]
341851b4:	60b9      	str	r1, [r7, #8]
341851b6:	607a      	str	r2, [r7, #4]
341851b8:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;

  switch(Lcd_Ctx[Instance].PixelFormat)
341851ba:	4a29      	ldr	r2, [pc, #164]	@ (34185260 <LL_ConvertLineToRGB+0xb4>)
341851bc:	68fb      	ldr	r3, [r7, #12]
341851be:	015b      	lsls	r3, r3, #5
341851c0:	4413      	add	r3, r2
341851c2:	330c      	adds	r3, #12
341851c4:	681b      	ldr	r3, [r3, #0]
341851c6:	2b04      	cmp	r3, #4
341851c8:	d008      	beq.n	341851dc <LL_ConvertLineToRGB+0x30>
341851ca:	2b04      	cmp	r3, #4
341851cc:	d80c      	bhi.n	341851e8 <LL_ConvertLineToRGB+0x3c>
341851ce:	2b01      	cmp	r3, #1
341851d0:	d007      	beq.n	341851e2 <LL_ConvertLineToRGB+0x36>
341851d2:	2b02      	cmp	r3, #2
341851d4:	d108      	bne.n	341851e8 <LL_ConvertLineToRGB+0x3c>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
341851d6:	2302      	movs	r3, #2
341851d8:	617b      	str	r3, [r7, #20]
    break;
341851da:	e008      	b.n	341851ee <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
341851dc:	2304      	movs	r3, #4
341851de:	617b      	str	r3, [r7, #20]
    break;
341851e0:	e005      	b.n	341851ee <LL_ConvertLineToRGB+0x42>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
341851e2:	2301      	movs	r3, #1
341851e4:	617b      	str	r3, [r7, #20]
    break;
341851e6:	e002      	b.n	341851ee <LL_ConvertLineToRGB+0x42>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
341851e8:	2300      	movs	r3, #0
341851ea:	617b      	str	r3, [r7, #20]
    break;
341851ec:	bf00      	nop
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
341851ee:	4b1d      	ldr	r3, [pc, #116]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
341851f0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341851f4:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
341851f6:	4a1b      	ldr	r2, [pc, #108]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
341851f8:	697b      	ldr	r3, [r7, #20]
341851fa:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = 0;
341851fc:	4b19      	ldr	r3, [pc, #100]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
341851fe:	2200      	movs	r2, #0
34185200:	60da      	str	r2, [r3, #12]

  /* Foreground Configuration */
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34185202:	4b18      	ldr	r3, [pc, #96]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185204:	2200      	movs	r2, #0
34185206:	64da      	str	r2, [r3, #76]	@ 0x4c
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
34185208:	4b16      	ldr	r3, [pc, #88]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
3418520a:	22ff      	movs	r2, #255	@ 0xff
3418520c:	651a      	str	r2, [r3, #80]	@ 0x50
  hlcd_dma2d.LayerCfg[1].InputColorMode = ColorMode;
3418520e:	4a15      	ldr	r2, [pc, #84]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185210:	6a3b      	ldr	r3, [r7, #32]
34185212:	6493      	str	r3, [r2, #72]	@ 0x48
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
34185214:	4b13      	ldr	r3, [pc, #76]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185216:	2200      	movs	r2, #0
34185218:	645a      	str	r2, [r3, #68]	@ 0x44

  hlcd_dma2d.Instance = DMA2D;
3418521a:	4b12      	ldr	r3, [pc, #72]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
3418521c:	4a12      	ldr	r2, [pc, #72]	@ (34185268 <LL_ConvertLineToRGB+0xbc>)
3418521e:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34185220:	4810      	ldr	r0, [pc, #64]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185222:	f004 fcb7 	bl	34189b94 <HAL_DMA2D_Init>
34185226:	4603      	mov	r3, r0
34185228:	2b00      	cmp	r3, #0
3418522a:	d115      	bne.n	34185258 <LL_ConvertLineToRGB+0xac>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
3418522c:	2101      	movs	r1, #1
3418522e:	480d      	ldr	r0, [pc, #52]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185230:	f004 fe30 	bl	34189e94 <HAL_DMA2D_ConfigLayer>
34185234:	4603      	mov	r3, r0
34185236:	2b00      	cmp	r3, #0
34185238:	d10e      	bne.n	34185258 <LL_ConvertLineToRGB+0xac>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
3418523a:	68b9      	ldr	r1, [r7, #8]
3418523c:	687a      	ldr	r2, [r7, #4]
3418523e:	2301      	movs	r3, #1
34185240:	9300      	str	r3, [sp, #0]
34185242:	683b      	ldr	r3, [r7, #0]
34185244:	4807      	ldr	r0, [pc, #28]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185246:	f004 fd10 	bl	34189c6a <HAL_DMA2D_Start>
3418524a:	4603      	mov	r3, r0
3418524c:	2b00      	cmp	r3, #0
3418524e:	d103      	bne.n	34185258 <LL_ConvertLineToRGB+0xac>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34185250:	2132      	movs	r1, #50	@ 0x32
34185252:	4804      	ldr	r0, [pc, #16]	@ (34185264 <LL_ConvertLineToRGB+0xb8>)
34185254:	f004 fd34 	bl	34189cc0 <HAL_DMA2D_PollForTransfer>
      }
    }
  }
}
34185258:	bf00      	nop
3418525a:	3718      	adds	r7, #24
3418525c:	46bd      	mov	sp, r7
3418525e:	bd80      	pop	{r7, pc}
34185260:	341c1204 	.word	0x341c1204
34185264:	341c10f4 	.word	0x341c10f4
34185268:	58021000 	.word	0x58021000

3418526c <LTDC_MspInit>:
  * @brief  Initialize the BSP LTDC Msp.
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
3418526c:	b580      	push	{r7, lr}
3418526e:	b088      	sub	sp, #32
34185270:	af00      	add	r7, sp, #0
34185272:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure = {0};
34185274:	f107 030c 	add.w	r3, r7, #12
34185278:	2200      	movs	r2, #0
3418527a:	601a      	str	r2, [r3, #0]
3418527c:	605a      	str	r2, [r3, #4]
3418527e:	609a      	str	r2, [r3, #8]
34185280:	60da      	str	r2, [r3, #12]
34185282:	611a      	str	r2, [r3, #16]

  if (hltdc->Instance == LTDC)
34185284:	687b      	ldr	r3, [r7, #4]
34185286:	681b      	ldr	r3, [r3, #0]
34185288:	4a4e      	ldr	r2, [pc, #312]	@ (341853c4 <LTDC_MspInit+0x158>)
3418528a:	4293      	cmp	r3, r2
3418528c:	f040 8095 	bne.w	341853ba <LTDC_MspInit+0x14e>
  {
    __HAL_RCC_LTDC_CLK_ENABLE();
34185290:	2002      	movs	r0, #2
34185292:	f7ff f911 	bl	341844b8 <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_LTDC_FORCE_RESET();
34185296:	2002      	movs	r0, #2
34185298:	f7ff f924 	bl	341844e4 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_LTDC_RELEASE_RESET();
3418529c:	2002      	movs	r0, #2
3418529e:	f7ff f931 	bl	34184504 <LL_APB5_GRP1_ReleaseReset>
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
341852a2:	2001      	movs	r0, #1
341852a4:	f7ff f8b8 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
341852a8:	2002      	movs	r0, #2
341852aa:	f7ff f8b5 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
341852ae:	2008      	movs	r0, #8
341852b0:	f7ff f8b2 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
341852b4:	2010      	movs	r0, #16
341852b6:	f7ff f8af 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
341852ba:	2040      	movs	r0, #64	@ 0x40
341852bc:	f7ff f8ac 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
341852c0:	2080      	movs	r0, #128	@ 0x80
341852c2:	f7ff f8a9 	bl	34184418 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
341852c6:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
341852ca:	f7ff f8a5 	bl	34184418 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
341852ce:	2302      	movs	r3, #2
341852d0:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pull      = GPIO_NOPULL;
341852d2:	2300      	movs	r3, #0
341852d4:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
341852d6:	2302      	movs	r3, #2
341852d8:	61bb      	str	r3, [r7, #24]

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
341852da:	f248 1387 	movw	r3, #33159	@ 0x8187
341852de:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
341852e0:	230e      	movs	r3, #14
341852e2:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
341852e4:	f107 030c 	add.w	r3, r7, #12
341852e8:	4619      	mov	r1, r3
341852ea:	4837      	ldr	r0, [pc, #220]	@ (341853c8 <LTDC_MspInit+0x15c>)
341852ec:	f004 ff26 	bl	3418a13c <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
341852f0:	f64f 0314 	movw	r3, #63508	@ 0xf814
341852f4:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
341852f6:	230e      	movs	r3, #14
341852f8:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
341852fa:	f107 030c 	add.w	r3, r7, #12
341852fe:	4619      	mov	r1, r3
34185300:	4832      	ldr	r0, [pc, #200]	@ (341853cc <LTDC_MspInit+0x160>)
34185302:	f004 ff1b 	bl	3418a13c <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
34185306:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
3418530a:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
3418530c:	230e      	movs	r3, #14
3418530e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34185310:	f107 030c 	add.w	r3, r7, #12
34185314:	4619      	mov	r1, r3
34185316:	482e      	ldr	r0, [pc, #184]	@ (341853d0 <LTDC_MspInit+0x164>)
34185318:	f004 ff10 	bl	3418a13c <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
3418531c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34185320:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34185322:	230e      	movs	r3, #14
34185324:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34185326:	f107 030c 	add.w	r3, r7, #12
3418532a:	4619      	mov	r1, r3
3418532c:	4829      	ldr	r0, [pc, #164]	@ (341853d4 <LTDC_MspInit+0x168>)
3418532e:	f004 ff05 	bl	3418a13c <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
34185332:	f641 1343 	movw	r3, #6467	@ 0x1943
34185336:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34185338:	230e      	movs	r3, #14
3418533a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
3418533c:	f107 030c 	add.w	r3, r7, #12
34185340:	4619      	mov	r1, r3
34185342:	4825      	ldr	r0, [pc, #148]	@ (341853d8 <LTDC_MspInit+0x16c>)
34185344:	f004 fefa 	bl	3418a13c <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34185348:	2358      	movs	r3, #88	@ 0x58
3418534a:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
3418534c:	230e      	movs	r3, #14
3418534e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34185350:	f107 030c 	add.w	r3, r7, #12
34185354:	4619      	mov	r1, r3
34185356:	4821      	ldr	r0, [pc, #132]	@ (341853dc <LTDC_MspInit+0x170>)
34185358:	f004 fef0 	bl	3418a13c <HAL_GPIO_Init>

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
3418535c:	2302      	movs	r3, #2
3418535e:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34185360:	2301      	movs	r3, #1
34185362:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
34185364:	f107 030c 	add.w	r3, r7, #12
34185368:	4619      	mov	r1, r3
3418536a:	481a      	ldr	r0, [pc, #104]	@ (341853d4 <LTDC_MspInit+0x168>)
3418536c:	f004 fee6 	bl	3418a13c <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
34185370:	2348      	movs	r3, #72	@ 0x48
34185372:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34185374:	2301      	movs	r3, #1
34185376:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
34185378:	f107 030c 	add.w	r3, r7, #12
3418537c:	4619      	mov	r1, r3
3418537e:	4818      	ldr	r0, [pc, #96]	@ (341853e0 <LTDC_MspInit+0x174>)
34185380:	f004 fedc 	bl	3418a13c <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
34185384:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34185388:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3418538a:	2301      	movs	r3, #1
3418538c:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
3418538e:	f107 030c 	add.w	r3, r7, #12
34185392:	4619      	mov	r1, r3
34185394:	4810      	ldr	r0, [pc, #64]	@ (341853d8 <LTDC_MspInit+0x16c>)
34185396:	f004 fed1 	bl	3418a13c <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
3418539a:	2201      	movs	r2, #1
3418539c:	2108      	movs	r1, #8
3418539e:	4810      	ldr	r0, [pc, #64]	@ (341853e0 <LTDC_MspInit+0x174>)
341853a0:	f005 f9be 	bl	3418a720 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
341853a4:	2201      	movs	r2, #1
341853a6:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
341853aa:	480b      	ldr	r0, [pc, #44]	@ (341853d8 <LTDC_MspInit+0x16c>)
341853ac:	f005 f9b8 	bl	3418a720 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
341853b0:	2201      	movs	r2, #1
341853b2:	2140      	movs	r1, #64	@ 0x40
341853b4:	480a      	ldr	r0, [pc, #40]	@ (341853e0 <LTDC_MspInit+0x174>)
341853b6:	f005 f9b3 	bl	3418a720 <HAL_GPIO_WritePin>

  }
}
341853ba:	bf00      	nop
341853bc:	3720      	adds	r7, #32
341853be:	46bd      	mov	sp, r7
341853c0:	bd80      	pop	{r7, pc}
341853c2:	bf00      	nop
341853c4:	58001000 	.word	0x58001000
341853c8:	56020000 	.word	0x56020000
341853cc:	56020400 	.word	0x56020400
341853d0:	56020c00 	.word	0x56020c00
341853d4:	56021000 	.word	0x56021000
341853d8:	56021800 	.word	0x56021800
341853dc:	56021c00 	.word	0x56021c00
341853e0:	56024000 	.word	0x56024000

341853e4 <DMA2D_MspInit>:
  * @brief  Initialize the BSP DMA2D Msp.
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
341853e4:	b580      	push	{r7, lr}
341853e6:	b082      	sub	sp, #8
341853e8:	af00      	add	r7, sp, #0
341853ea:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
341853ec:	687b      	ldr	r3, [r7, #4]
341853ee:	681b      	ldr	r3, [r3, #0]
341853f0:	4a07      	ldr	r2, [pc, #28]	@ (34185410 <DMA2D_MspInit+0x2c>)
341853f2:	4293      	cmp	r3, r2
341853f4:	d108      	bne.n	34185408 <DMA2D_MspInit+0x24>
  {
    /** Enable the DMA2D clock */
    __HAL_RCC_DMA2D_CLK_ENABLE();
341853f6:	2002      	movs	r0, #2
341853f8:	f7ff f824 	bl	34184444 <LL_AHB5_GRP1_EnableClock>

    /** Toggle Sw reset of DMA2D IP */
    __HAL_RCC_DMA2D_FORCE_RESET();
341853fc:	2002      	movs	r0, #2
341853fe:	f7ff f837 	bl	34184470 <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_DMA2D_RELEASE_RESET();
34185402:	2002      	movs	r0, #2
34185404:	f7ff f844 	bl	34184490 <LL_AHB5_GRP1_ReleaseReset>
  }
}
34185408:	bf00      	nop
3418540a:	3708      	adds	r7, #8
3418540c:	46bd      	mov	sp, r7
3418540e:	bd80      	pop	{r7, pc}
34185410:	58021000 	.word	0x58021000

34185414 <LL_AHB4_GRP1_EnableClock>:
{
34185414:	b480      	push	{r7}
34185416:	b085      	sub	sp, #20
34185418:	af00      	add	r7, sp, #0
3418541a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3418541c:	4a07      	ldr	r2, [pc, #28]	@ (3418543c <LL_AHB4_GRP1_EnableClock+0x28>)
3418541e:	687b      	ldr	r3, [r7, #4]
34185420:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34185424:	4b05      	ldr	r3, [pc, #20]	@ (3418543c <LL_AHB4_GRP1_EnableClock+0x28>)
34185426:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3418542a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3418542c:	68fb      	ldr	r3, [r7, #12]
}
3418542e:	bf00      	nop
34185430:	3714      	adds	r7, #20
34185432:	46bd      	mov	sp, r7
34185434:	f85d 7b04 	ldr.w	r7, [sp], #4
34185438:	4770      	bx	lr
3418543a:	bf00      	nop
3418543c:	56028000 	.word	0x56028000

34185440 <LL_AHB5_GRP1_EnableClock>:
{
34185440:	b480      	push	{r7}
34185442:	b085      	sub	sp, #20
34185444:	af00      	add	r7, sp, #0
34185446:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34185448:	4a07      	ldr	r2, [pc, #28]	@ (34185468 <LL_AHB5_GRP1_EnableClock+0x28>)
3418544a:	687b      	ldr	r3, [r7, #4]
3418544c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34185450:	4b05      	ldr	r3, [pc, #20]	@ (34185468 <LL_AHB5_GRP1_EnableClock+0x28>)
34185452:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34185456:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34185458:	68fb      	ldr	r3, [r7, #12]
}
3418545a:	bf00      	nop
3418545c:	3714      	adds	r7, #20
3418545e:	46bd      	mov	sp, r7
34185460:	f85d 7b04 	ldr.w	r7, [sp], #4
34185464:	4770      	bx	lr
34185466:	bf00      	nop
34185468:	56028000 	.word	0x56028000

3418546c <LL_AHB5_GRP1_ForceReset>:
{
3418546c:	b480      	push	{r7}
3418546e:	b083      	sub	sp, #12
34185470:	af00      	add	r7, sp, #0
34185472:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34185474:	4a04      	ldr	r2, [pc, #16]	@ (34185488 <LL_AHB5_GRP1_ForceReset+0x1c>)
34185476:	687b      	ldr	r3, [r7, #4]
34185478:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
3418547c:	bf00      	nop
3418547e:	370c      	adds	r7, #12
34185480:	46bd      	mov	sp, r7
34185482:	f85d 7b04 	ldr.w	r7, [sp], #4
34185486:	4770      	bx	lr
34185488:	56028000 	.word	0x56028000

3418548c <LL_AHB5_GRP1_ReleaseReset>:
{
3418548c:	b480      	push	{r7}
3418548e:	b083      	sub	sp, #12
34185490:	af00      	add	r7, sp, #0
34185492:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34185494:	4b06      	ldr	r3, [pc, #24]	@ (341854b0 <LL_AHB5_GRP1_ReleaseReset+0x24>)
34185496:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418549a:	461a      	mov	r2, r3
3418549c:	687b      	ldr	r3, [r7, #4]
3418549e:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
341854a2:	bf00      	nop
341854a4:	370c      	adds	r7, #12
341854a6:	46bd      	mov	sp, r7
341854a8:	f85d 7b04 	ldr.w	r7, [sp], #4
341854ac:	4770      	bx	lr
341854ae:	bf00      	nop
341854b0:	56028000 	.word	0x56028000

341854b4 <BSP_XSPI_NOR_Init>:
  * @param  Instance   XSPI Instance
  * @param  Init       XSPI Init structure
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_Init(uint32_t Instance, BSP_XSPI_NOR_Init_t *Init)
{
341854b4:	b590      	push	{r4, r7, lr}
341854b6:	b095      	sub	sp, #84	@ 0x54
341854b8:	af00      	add	r7, sp, #0
341854ba:	6078      	str	r0, [r7, #4]
341854bc:	6039      	str	r1, [r7, #0]
  int32_t ret;
  BSP_XSPI_NOR_Info_t pInfo;
  MX_XSPI_InitTypeDef xspi_init;

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
341854be:	687b      	ldr	r3, [r7, #4]
341854c0:	2b00      	cmp	r3, #0
341854c2:	d003      	beq.n	341854cc <BSP_XSPI_NOR_Init+0x18>
  {
    ret = BSP_ERROR_WRONG_PARAM;
341854c4:	f06f 0301 	mvn.w	r3, #1
341854c8:	64fb      	str	r3, [r7, #76]	@ 0x4c
341854ca:	e080      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
341854cc:	4947      	ldr	r1, [pc, #284]	@ (341855ec <BSP_XSPI_NOR_Init+0x138>)
341854ce:	687a      	ldr	r2, [r7, #4]
341854d0:	4613      	mov	r3, r2
341854d2:	005b      	lsls	r3, r3, #1
341854d4:	4413      	add	r3, r2
341854d6:	440b      	add	r3, r1
341854d8:	781b      	ldrb	r3, [r3, #0]
341854da:	2b00      	cmp	r3, #0
341854dc:	d175      	bne.n	341855ca <BSP_XSPI_NOR_Init+0x116>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_NOR_MspInit(&hxspi_nor[Instance]);
341854de:	687b      	ldr	r3, [r7, #4]
341854e0:	2264      	movs	r2, #100	@ 0x64
341854e2:	fb02 f303 	mul.w	r3, r2, r3
341854e6:	4a42      	ldr	r2, [pc, #264]	@ (341855f0 <BSP_XSPI_NOR_Init+0x13c>)
341854e8:	4413      	add	r3, r2
341854ea:	4618      	mov	r0, r3
341854ec:	f000 faba 	bl	34185a64 <XSPI_NOR_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Get Flash information of one memory */
      (void)MX66UW1G45G_GetFlashInfo(&pInfo);
341854f0:	f107 031c 	add.w	r3, r7, #28
341854f4:	4618      	mov	r0, r3
341854f6:	f012 f830 	bl	3419755a <MX66UW1G45G_GetFlashInfo>

      /* Fill config structure */
      xspi_init.ClockPrescaler = 0x03; /* XSPI clock = 200MHz / ClockPrescaler = 50MHz, then switch to 200MHz*/
341854fa:	2303      	movs	r3, #3
341854fc:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
341854fe:	69fb      	ldr	r3, [r7, #28]
34185500:	647b      	str	r3, [r7, #68]	@ 0x44
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
34185502:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34185504:	fa93 f3a3 	rbit	r3, r3
34185508:	643b      	str	r3, [r7, #64]	@ 0x40
  return result;
3418550a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3418550c:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (value == 0U)
3418550e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34185510:	2b00      	cmp	r3, #0
34185512:	d101      	bne.n	34185518 <BSP_XSPI_NOR_Init+0x64>
    return 32U;
34185514:	2320      	movs	r3, #32
34185516:	e003      	b.n	34185520 <BSP_XSPI_NOR_Init+0x6c>
  return __builtin_clz(value);
34185518:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418551a:	fab3 f383 	clz	r3, r3
3418551e:	b2db      	uxtb	r3, r3
34185520:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34185522:	2300      	movs	r3, #0
34185524:	617b      	str	r3, [r7, #20]
      xspi_init.TransferRate   = (uint32_t)Init->TransferRate;
34185526:	683b      	ldr	r3, [r7, #0]
34185528:	785b      	ldrb	r3, [r3, #1]
3418552a:	61bb      	str	r3, [r7, #24]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_NOR_Init(&hxspi_nor[Instance], &xspi_init) != HAL_OK)
3418552c:	687b      	ldr	r3, [r7, #4]
3418552e:	2264      	movs	r2, #100	@ 0x64
34185530:	fb02 f303 	mul.w	r3, r2, r3
34185534:	4a2e      	ldr	r2, [pc, #184]	@ (341855f0 <BSP_XSPI_NOR_Init+0x13c>)
34185536:	4413      	add	r3, r2
34185538:	f107 020c 	add.w	r2, r7, #12
3418553c:	4611      	mov	r1, r2
3418553e:	4618      	mov	r0, r3
34185540:	f000 f858 	bl	341855f4 <MX_XSPI_NOR_Init>
34185544:	4603      	mov	r3, r0
34185546:	2b00      	cmp	r3, #0
34185548:	d003      	beq.n	34185552 <BSP_XSPI_NOR_Init+0x9e>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
3418554a:	f06f 0303 	mvn.w	r3, #3
3418554e:	64fb      	str	r3, [r7, #76]	@ 0x4c
34185550:	e03d      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
      }
      /* XSPI memory reset */
      else if (XSPI_NOR_ResetMemory(Instance) != BSP_ERROR_NONE)
34185552:	6878      	ldr	r0, [r7, #4]
34185554:	f000 fb4c 	bl	34185bf0 <XSPI_NOR_ResetMemory>
34185558:	4603      	mov	r3, r0
3418555a:	2b00      	cmp	r3, #0
3418555c:	d003      	beq.n	34185566 <BSP_XSPI_NOR_Init+0xb2>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
3418555e:	f06f 0304 	mvn.w	r3, #4
34185562:	64fb      	str	r3, [r7, #76]	@ 0x4c
34185564:	e033      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Check if memory is ready */
      else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185566:	687b      	ldr	r3, [r7, #4]
34185568:	2264      	movs	r2, #100	@ 0x64
3418556a:	fb02 f303 	mul.w	r3, r2, r3
3418556e:	4a20      	ldr	r2, [pc, #128]	@ (341855f0 <BSP_XSPI_NOR_Init+0x13c>)
34185570:	1898      	adds	r0, r3, r2
34185572:	491e      	ldr	r1, [pc, #120]	@ (341855ec <BSP_XSPI_NOR_Init+0x138>)
34185574:	687a      	ldr	r2, [r7, #4]
34185576:	4613      	mov	r3, r2
34185578:	005b      	lsls	r3, r3, #1
3418557a:	4413      	add	r3, r2
3418557c:	440b      	add	r3, r1
3418557e:	3301      	adds	r3, #1
34185580:	7819      	ldrb	r1, [r3, #0]
34185582:	4c1a      	ldr	r4, [pc, #104]	@ (341855ec <BSP_XSPI_NOR_Init+0x138>)
34185584:	687a      	ldr	r2, [r7, #4]
34185586:	4613      	mov	r3, r2
34185588:	005b      	lsls	r3, r3, #1
3418558a:	4413      	add	r3, r2
3418558c:	4423      	add	r3, r4
3418558e:	3302      	adds	r3, #2
34185590:	781b      	ldrb	r3, [r3, #0]
34185592:	461a      	mov	r2, r3
34185594:	f012 f810 	bl	341975b8 <MX66UW1G45G_AutoPollingMemReady>
34185598:	4603      	mov	r3, r0
3418559a:	2b00      	cmp	r3, #0
3418559c:	d003      	beq.n	341855a6 <BSP_XSPI_NOR_Init+0xf2>
                                                XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
3418559e:	f06f 0304 	mvn.w	r3, #4
341855a2:	64fb      	str	r3, [r7, #76]	@ 0x4c
341855a4:	e013      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
      }
      /* Configure the memory */
      else if (BSP_XSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
341855a6:	683b      	ldr	r3, [r7, #0]
341855a8:	7819      	ldrb	r1, [r3, #0]
341855aa:	683b      	ldr	r3, [r7, #0]
341855ac:	785b      	ldrb	r3, [r3, #1]
341855ae:	461a      	mov	r2, r3
341855b0:	6878      	ldr	r0, [r7, #4]
341855b2:	f000 f8d5 	bl	34185760 <BSP_XSPI_NOR_ConfigFlash>
341855b6:	4603      	mov	r3, r0
341855b8:	2b00      	cmp	r3, #0
341855ba:	d003      	beq.n	341855c4 <BSP_XSPI_NOR_Init+0x110>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
341855bc:	f06f 0304 	mvn.w	r3, #4
341855c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
341855c2:	e004      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
      }
      else
      {
        ret = BSP_ERROR_NONE;
341855c4:	2300      	movs	r3, #0
341855c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
341855c8:	e001      	b.n	341855ce <BSP_XSPI_NOR_Init+0x11a>
      }
    }
    else
    {
      ret = BSP_ERROR_NONE;
341855ca:	2300      	movs	r3, #0
341855cc:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

 (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
341855ce:	687b      	ldr	r3, [r7, #4]
341855d0:	2264      	movs	r2, #100	@ 0x64
341855d2:	fb02 f303 	mul.w	r3, r2, r3
341855d6:	4a06      	ldr	r2, [pc, #24]	@ (341855f0 <BSP_XSPI_NOR_Init+0x13c>)
341855d8:	4413      	add	r3, r2
341855da:	2100      	movs	r1, #0
341855dc:	4618      	mov	r0, r3
341855de:	f011 fb54 	bl	34196c8a <HAL_XSPI_SetClockPrescaler>

  /* Return BSP status */
  return ret;
341855e2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
341855e4:	4618      	mov	r0, r3
341855e6:	3754      	adds	r7, #84	@ 0x54
341855e8:	46bd      	mov	sp, r7
341855ea:	bd90      	pop	{r4, r7, pc}
341855ec:	341c1288 	.word	0x341c1288
341855f0:	341c1224 	.word	0x341c1224

341855f4 <MX_XSPI_NOR_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_NOR_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
341855f4:	b580      	push	{r7, lr}
341855f6:	b082      	sub	sp, #8
341855f8:	af00      	add	r7, sp, #0
341855fa:	6078      	str	r0, [r7, #4]
341855fc:	6039      	str	r1, [r7, #0]
  /* XSPI initialization */
  hxspi->Instance = XSPI2;
341855fe:	687b      	ldr	r3, [r7, #4]
34185600:	4a20      	ldr	r2, [pc, #128]	@ (34185684 <MX_XSPI_NOR_Init+0x90>)
34185602:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte       = 1;
34185604:	687b      	ldr	r3, [r7, #4]
34185606:	2201      	movs	r2, #1
34185608:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemorySize              = Init->MemorySize; /* 1 GBits */
3418560a:	683b      	ldr	r3, [r7, #0]
3418560c:	681a      	ldr	r2, [r3, #0]
3418560e:	687b      	ldr	r3, [r7, #4]
34185610:	611a      	str	r2, [r3, #16]
  hxspi->Init.ChipSelectHighTimeCycle = 2;
34185612:	687b      	ldr	r3, [r7, #4]
34185614:	2202      	movs	r2, #2
34185616:	615a      	str	r2, [r3, #20]
  hxspi->Init.FreeRunningClock        = HAL_XSPI_FREERUNCLK_DISABLE;
34185618:	687b      	ldr	r3, [r7, #4]
3418561a:	2200      	movs	r2, #0
3418561c:	619a      	str	r2, [r3, #24]
  hxspi->Init.ClockMode               = HAL_XSPI_CLOCK_MODE_0;
3418561e:	687b      	ldr	r3, [r7, #4]
34185620:	2200      	movs	r2, #0
34185622:	61da      	str	r2, [r3, #28]
  hxspi->Init.DelayHoldQuarterCycle   = HAL_XSPI_DHQC_DISABLE;
34185624:	687b      	ldr	r3, [r7, #4]
34185626:	2200      	movs	r2, #0
34185628:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ClockPrescaler          = Init->ClockPrescaler;
3418562a:	683b      	ldr	r3, [r7, #0]
3418562c:	685a      	ldr	r2, [r3, #4]
3418562e:	687b      	ldr	r3, [r7, #4]
34185630:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting          = Init->SampleShifting;
34185632:	683b      	ldr	r3, [r7, #0]
34185634:	689a      	ldr	r2, [r3, #8]
34185636:	687b      	ldr	r3, [r7, #4]
34185638:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.ChipSelectBoundary      = HAL_XSPI_BONDARYOF_NONE;
3418563a:	687b      	ldr	r3, [r7, #4]
3418563c:	2200      	movs	r2, #0
3418563e:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.MemoryMode              = HAL_XSPI_SINGLE_MEM;
34185640:	687b      	ldr	r3, [r7, #4]
34185642:	2200      	movs	r2, #0
34185644:	609a      	str	r2, [r3, #8]
  hxspi->Init.WrapSize                = HAL_XSPI_WRAP_NOT_SUPPORTED;
34185646:	687b      	ldr	r3, [r7, #4]
34185648:	2200      	movs	r2, #0
3418564a:	621a      	str	r2, [r3, #32]

  if (Init->TransferRate == (uint32_t) BSP_XSPI_NOR_DTR_TRANSFER)
3418564c:	683b      	ldr	r3, [r7, #0]
3418564e:	68db      	ldr	r3, [r3, #12]
34185650:	2b01      	cmp	r3, #1
34185652:	d108      	bne.n	34185666 <MX_XSPI_NOR_Init+0x72>
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34185654:	687b      	ldr	r3, [r7, #4]
34185656:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3418565a:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
3418565c:	687b      	ldr	r3, [r7, #4]
3418565e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34185662:	62da      	str	r2, [r3, #44]	@ 0x2c
34185664:	e006      	b.n	34185674 <MX_XSPI_NOR_Init+0x80>
  }
  else
  {
    hxspi->Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34185666:	687b      	ldr	r3, [r7, #4]
34185668:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3418566c:	60da      	str	r2, [r3, #12]
    hxspi->Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
3418566e:	687b      	ldr	r3, [r7, #4]
34185670:	2200      	movs	r2, #0
34185672:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
  return HAL_XSPI_Init(hxspi);
34185674:	6878      	ldr	r0, [r7, #4]
34185676:	f010 fed5 	bl	34196424 <HAL_XSPI_Init>
3418567a:	4603      	mov	r3, r0
}
3418567c:	4618      	mov	r0, r3
3418567e:	3708      	adds	r7, #8
34185680:	46bd      	mov	sp, r7
34185682:	bd80      	pop	{r7, pc}
34185684:	5802a000 	.word	0x5802a000

34185688 <BSP_XSPI_NOR_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_EnableMemoryMappedMode(uint32_t Instance)
{
34185688:	b580      	push	{r7, lr}
3418568a:	b084      	sub	sp, #16
3418568c:	af00      	add	r7, sp, #0
3418568e:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34185690:	2300      	movs	r3, #0
34185692:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34185694:	687b      	ldr	r3, [r7, #4]
34185696:	2b00      	cmp	r3, #0
34185698:	d003      	beq.n	341856a2 <BSP_XSPI_NOR_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3418569a:	f06f 0301 	mvn.w	r3, #1
3418569e:	60fb      	str	r3, [r7, #12]
341856a0:	e055      	b.n	3418574e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
  }
  else
  {

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_nor[Instance], 0));
341856a2:	687b      	ldr	r3, [r7, #4]
341856a4:	2264      	movs	r2, #100	@ 0x64
341856a6:	fb02 f303 	mul.w	r3, r2, r3
341856aa:	4a2b      	ldr	r2, [pc, #172]	@ (34185758 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
341856ac:	4413      	add	r3, r2
341856ae:	2100      	movs	r1, #0
341856b0:	4618      	mov	r0, r3
341856b2:	f011 faea 	bl	34196c8a <HAL_XSPI_SetClockPrescaler>

    if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
341856b6:	4929      	ldr	r1, [pc, #164]	@ (3418575c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
341856b8:	687a      	ldr	r2, [r7, #4]
341856ba:	4613      	mov	r3, r2
341856bc:	005b      	lsls	r3, r3, #1
341856be:	4413      	add	r3, r2
341856c0:	440b      	add	r3, r1
341856c2:	3302      	adds	r3, #2
341856c4:	781b      	ldrb	r3, [r3, #0]
341856c6:	2b00      	cmp	r3, #0
341856c8:	d121      	bne.n	3418570e <BSP_XSPI_NOR_EnableMemoryMappedMode+0x86>
    {
      if (MX66UW1G45G_EnableMemoryMappedModeSTR(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
341856ca:	687b      	ldr	r3, [r7, #4]
341856cc:	2264      	movs	r2, #100	@ 0x64
341856ce:	fb02 f303 	mul.w	r3, r2, r3
341856d2:	4a21      	ldr	r2, [pc, #132]	@ (34185758 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
341856d4:	1898      	adds	r0, r3, r2
341856d6:	4921      	ldr	r1, [pc, #132]	@ (3418575c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
341856d8:	687a      	ldr	r2, [r7, #4]
341856da:	4613      	mov	r3, r2
341856dc:	005b      	lsls	r3, r3, #1
341856de:	4413      	add	r3, r2
341856e0:	440b      	add	r3, r1
341856e2:	3301      	adds	r3, #1
341856e4:	781b      	ldrb	r3, [r3, #0]
341856e6:	2201      	movs	r2, #1
341856e8:	4619      	mov	r1, r3
341856ea:	f012 f813 	bl	34197714 <MX66UW1G45G_EnableSTRMemoryMappedMode>
341856ee:	4603      	mov	r3, r0
341856f0:	2b00      	cmp	r3, #0
341856f2:	d003      	beq.n	341856fc <BSP_XSPI_NOR_EnableMemoryMappedMode+0x74>
                                                 MX66UW1G45G_4BYTES_SIZE) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
341856f4:	f06f 0304 	mvn.w	r3, #4
341856f8:	60fb      	str	r3, [r7, #12]
341856fa:	e028      	b.n	3418574e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
341856fc:	4917      	ldr	r1, [pc, #92]	@ (3418575c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
341856fe:	687a      	ldr	r2, [r7, #4]
34185700:	4613      	mov	r3, r2
34185702:	005b      	lsls	r3, r3, #1
34185704:	4413      	add	r3, r2
34185706:	440b      	add	r3, r1
34185708:	2202      	movs	r2, #2
3418570a:	701a      	strb	r2, [r3, #0]
3418570c:	e01f      	b.n	3418574e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
    }
    else
    {
      if (MX66UW1G45G_EnableMemoryMappedModeDTR(&hxspi_nor[Instance],
3418570e:	687b      	ldr	r3, [r7, #4]
34185710:	2264      	movs	r2, #100	@ 0x64
34185712:	fb02 f303 	mul.w	r3, r2, r3
34185716:	4a10      	ldr	r2, [pc, #64]	@ (34185758 <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd0>)
34185718:	1898      	adds	r0, r3, r2
3418571a:	4910      	ldr	r1, [pc, #64]	@ (3418575c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
3418571c:	687a      	ldr	r2, [r7, #4]
3418571e:	4613      	mov	r3, r2
34185720:	005b      	lsls	r3, r3, #1
34185722:	4413      	add	r3, r2
34185724:	440b      	add	r3, r1
34185726:	3301      	adds	r3, #1
34185728:	781b      	ldrb	r3, [r3, #0]
3418572a:	4619      	mov	r1, r3
3418572c:	f012 f89a 	bl	34197864 <MX66UW1G45G_EnableDTRMemoryMappedMode>
34185730:	4603      	mov	r3, r0
34185732:	2b00      	cmp	r3, #0
34185734:	d003      	beq.n	3418573e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xb6>
                                                 XSPI_Nor_Ctx[Instance].InterfaceMode) != MX66UW1G45G_OK)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
34185736:	f06f 0304 	mvn.w	r3, #4
3418573a:	60fb      	str	r3, [r7, #12]
3418573c:	e007      	b.n	3418574e <BSP_XSPI_NOR_EnableMemoryMappedMode+0xc6>
      }
      else /* Update XSPI context if all operations are well done */
      {

       XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_MMP;
3418573e:	4907      	ldr	r1, [pc, #28]	@ (3418575c <BSP_XSPI_NOR_EnableMemoryMappedMode+0xd4>)
34185740:	687a      	ldr	r2, [r7, #4]
34185742:	4613      	mov	r3, r2
34185744:	005b      	lsls	r3, r3, #1
34185746:	4413      	add	r3, r2
34185748:	440b      	add	r3, r1
3418574a:	2202      	movs	r2, #2
3418574c:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
3418574e:	68fb      	ldr	r3, [r7, #12]
}
34185750:	4618      	mov	r0, r3
34185752:	3710      	adds	r7, #16
34185754:	46bd      	mov	sp, r7
34185756:	bd80      	pop	{r7, pc}
34185758:	341c1224 	.word	0x341c1224
3418575c:	341c1288 	.word	0x341c1288

34185760 <BSP_XSPI_NOR_ConfigFlash>:
  * @param  Mode      XSPI mode
  * @param  Rate      XSPI transfer rate
  * @retval BSP status
  */
int32_t BSP_XSPI_NOR_ConfigFlash(uint32_t Instance, BSP_XSPI_NOR_Interface_t Mode, BSP_XSPI_NOR_Transfer_t Rate)
{
34185760:	b580      	push	{r7, lr}
34185762:	b084      	sub	sp, #16
34185764:	af00      	add	r7, sp, #0
34185766:	6078      	str	r0, [r7, #4]
34185768:	460b      	mov	r3, r1
3418576a:	70fb      	strb	r3, [r7, #3]
3418576c:	4613      	mov	r3, r2
3418576e:	70bb      	strb	r3, [r7, #2]
  int32_t ret = BSP_ERROR_NONE;
34185770:	2300      	movs	r3, #0
34185772:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_NOR_INSTANCES_NUMBER)
34185774:	687b      	ldr	r3, [r7, #4]
34185776:	2b00      	cmp	r3, #0
34185778:	d003      	beq.n	34185782 <BSP_XSPI_NOR_ConfigFlash+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3418577a:	f06f 0301 	mvn.w	r3, #1
3418577e:	60fb      	str	r3, [r7, #12]
34185780:	e072      	b.n	34185868 <BSP_XSPI_NOR_ConfigFlash+0x108>
  }
  else
  {
    /* Check if MMP mode locked ************************************************/
    if (XSPI_Nor_Ctx[Instance].IsInitialized == XSPI_ACCESS_MMP)
34185782:	493c      	ldr	r1, [pc, #240]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34185784:	687a      	ldr	r2, [r7, #4]
34185786:	4613      	mov	r3, r2
34185788:	005b      	lsls	r3, r3, #1
3418578a:	4413      	add	r3, r2
3418578c:	440b      	add	r3, r1
3418578e:	781b      	ldrb	r3, [r3, #0]
34185790:	2b02      	cmp	r3, #2
34185792:	d103      	bne.n	3418579c <BSP_XSPI_NOR_ConfigFlash+0x3c>
    {
      ret = BSP_ERROR_XSPI_MMP_LOCK_FAILURE;
34185794:	f06f 0319 	mvn.w	r3, #25
34185798:	60fb      	str	r3, [r7, #12]
3418579a:	e065      	b.n	34185868 <BSP_XSPI_NOR_ConfigFlash+0x108>
    }
    else
    {
      /* Setup Flash interface ***************************************************/
      switch (XSPI_Nor_Ctx[Instance].InterfaceMode)
3418579c:	4935      	ldr	r1, [pc, #212]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
3418579e:	687a      	ldr	r2, [r7, #4]
341857a0:	4613      	mov	r3, r2
341857a2:	005b      	lsls	r3, r3, #1
341857a4:	4413      	add	r3, r2
341857a6:	440b      	add	r3, r1
341857a8:	3301      	adds	r3, #1
341857aa:	781b      	ldrb	r3, [r3, #0]
341857ac:	2b01      	cmp	r3, #1
341857ae:	d12b      	bne.n	34185808 <BSP_XSPI_NOR_ConfigFlash+0xa8>
      {
        case BSP_XSPI_NOR_OPI_MODE :  /* 8-8-8 commands */
          if ((Mode != BSP_XSPI_NOR_OPI_MODE) || (Rate != XSPI_Nor_Ctx[Instance].TransferRate))
341857b0:	78fb      	ldrb	r3, [r7, #3]
341857b2:	2b01      	cmp	r3, #1
341857b4:	d10a      	bne.n	341857cc <BSP_XSPI_NOR_ConfigFlash+0x6c>
341857b6:	492f      	ldr	r1, [pc, #188]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
341857b8:	687a      	ldr	r2, [r7, #4]
341857ba:	4613      	mov	r3, r2
341857bc:	005b      	lsls	r3, r3, #1
341857be:	4413      	add	r3, r2
341857c0:	440b      	add	r3, r1
341857c2:	3302      	adds	r3, #2
341857c4:	781b      	ldrb	r3, [r3, #0]
341857c6:	78ba      	ldrb	r2, [r7, #2]
341857c8:	429a      	cmp	r2, r3
341857ca:	d02d      	beq.n	34185828 <BSP_XSPI_NOR_ConfigFlash+0xc8>
          {
            /* Exit OPI mode */
            ret = XSPI_NOR_ExitOPIMode(Instance);
341857cc:	6878      	ldr	r0, [r7, #4]
341857ce:	f000 fc57 	bl	34186080 <XSPI_NOR_ExitOPIMode>
341857d2:	60f8      	str	r0, [r7, #12]

            if ((ret == BSP_ERROR_NONE) && (Mode == BSP_XSPI_NOR_OPI_MODE))
341857d4:	68fb      	ldr	r3, [r7, #12]
341857d6:	2b00      	cmp	r3, #0
341857d8:	d126      	bne.n	34185828 <BSP_XSPI_NOR_ConfigFlash+0xc8>
341857da:	78fb      	ldrb	r3, [r7, #3]
341857dc:	2b01      	cmp	r3, #1
341857de:	d123      	bne.n	34185828 <BSP_XSPI_NOR_ConfigFlash+0xc8>
            {

              if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_STR_TRANSFER)
341857e0:	4924      	ldr	r1, [pc, #144]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
341857e2:	687a      	ldr	r2, [r7, #4]
341857e4:	4613      	mov	r3, r2
341857e6:	005b      	lsls	r3, r3, #1
341857e8:	4413      	add	r3, r2
341857ea:	440b      	add	r3, r1
341857ec:	3302      	adds	r3, #2
341857ee:	781b      	ldrb	r3, [r3, #0]
341857f0:	2b00      	cmp	r3, #0
341857f2:	d104      	bne.n	341857fe <BSP_XSPI_NOR_ConfigFlash+0x9e>
              {
                /* Enter DTR OPI mode */
                ret = XSPI_NOR_EnterDOPIMode(Instance);
341857f4:	6878      	ldr	r0, [r7, #4]
341857f6:	f000 fa93 	bl	34185d20 <XSPI_NOR_EnterDOPIMode>
341857fa:	60f8      	str	r0, [r7, #12]
                /* Enter STR OPI mode */
                ret = XSPI_NOR_EnterSOPIMode(Instance);
              }
            }
          }
          break;
341857fc:	e014      	b.n	34185828 <BSP_XSPI_NOR_ConfigFlash+0xc8>
                ret = XSPI_NOR_EnterSOPIMode(Instance);
341857fe:	6878      	ldr	r0, [r7, #4]
34185800:	f000 fb78 	bl	34185ef4 <XSPI_NOR_EnterSOPIMode>
34185804:	60f8      	str	r0, [r7, #12]
          break;
34185806:	e00f      	b.n	34185828 <BSP_XSPI_NOR_ConfigFlash+0xc8>

        case BSP_XSPI_NOR_SPI_MODE :  /* 1-1-1 commands, Power on H/W default setting */
        default :
          if (Mode == BSP_XSPI_NOR_OPI_MODE)
34185808:	78fb      	ldrb	r3, [r7, #3]
3418580a:	2b01      	cmp	r3, #1
3418580c:	d10e      	bne.n	3418582c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          {
            if (Rate == BSP_XSPI_NOR_STR_TRANSFER)
3418580e:	78bb      	ldrb	r3, [r7, #2]
34185810:	2b00      	cmp	r3, #0
34185812:	d104      	bne.n	3418581e <BSP_XSPI_NOR_ConfigFlash+0xbe>
            {
              /* Enter STR OPI mode */
              ret = XSPI_NOR_EnterSOPIMode(Instance);
34185814:	6878      	ldr	r0, [r7, #4]
34185816:	f000 fb6d 	bl	34185ef4 <XSPI_NOR_EnterSOPIMode>
3418581a:	60f8      	str	r0, [r7, #12]
            {
              /* Enter DTR OPI mode */
              ret = XSPI_NOR_EnterDOPIMode(Instance);
            }
          }
          break;
3418581c:	e006      	b.n	3418582c <BSP_XSPI_NOR_ConfigFlash+0xcc>
              ret = XSPI_NOR_EnterDOPIMode(Instance);
3418581e:	6878      	ldr	r0, [r7, #4]
34185820:	f000 fa7e 	bl	34185d20 <XSPI_NOR_EnterDOPIMode>
34185824:	60f8      	str	r0, [r7, #12]
          break;
34185826:	e001      	b.n	3418582c <BSP_XSPI_NOR_ConfigFlash+0xcc>
          break;
34185828:	bf00      	nop
3418582a:	e000      	b.n	3418582e <BSP_XSPI_NOR_ConfigFlash+0xce>
          break;
3418582c:	bf00      	nop
      }

      /* Update XSPI context if all operations are well done */
      if (ret == BSP_ERROR_NONE)
3418582e:	68fb      	ldr	r3, [r7, #12]
34185830:	2b00      	cmp	r3, #0
34185832:	d119      	bne.n	34185868 <BSP_XSPI_NOR_ConfigFlash+0x108>
      {
        /* Update current status parameter *****************************************/
        XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
34185834:	490f      	ldr	r1, [pc, #60]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34185836:	687a      	ldr	r2, [r7, #4]
34185838:	4613      	mov	r3, r2
3418583a:	005b      	lsls	r3, r3, #1
3418583c:	4413      	add	r3, r2
3418583e:	440b      	add	r3, r1
34185840:	2201      	movs	r2, #1
34185842:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].InterfaceMode = Mode;
34185844:	490b      	ldr	r1, [pc, #44]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34185846:	687a      	ldr	r2, [r7, #4]
34185848:	4613      	mov	r3, r2
3418584a:	005b      	lsls	r3, r3, #1
3418584c:	4413      	add	r3, r2
3418584e:	440b      	add	r3, r1
34185850:	3301      	adds	r3, #1
34185852:	78fa      	ldrb	r2, [r7, #3]
34185854:	701a      	strb	r2, [r3, #0]
        XSPI_Nor_Ctx[Instance].TransferRate  = Rate;
34185856:	4907      	ldr	r1, [pc, #28]	@ (34185874 <BSP_XSPI_NOR_ConfigFlash+0x114>)
34185858:	687a      	ldr	r2, [r7, #4]
3418585a:	4613      	mov	r3, r2
3418585c:	005b      	lsls	r3, r3, #1
3418585e:	4413      	add	r3, r2
34185860:	440b      	add	r3, r1
34185862:	3302      	adds	r3, #2
34185864:	78ba      	ldrb	r2, [r7, #2]
34185866:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
34185868:	68fb      	ldr	r3, [r7, #12]
}
3418586a:	4618      	mov	r0, r3
3418586c:	3710      	adds	r7, #16
3418586e:	46bd      	mov	sp, r7
34185870:	bd80      	pop	{r7, pc}
34185872:	bf00      	nop
34185874:	341c1288 	.word	0x341c1288

34185878 <BSP_XSPI_RAM_Init>:
  * @brief  Initializes the XSPI interface.
  * @param  Instance   XSPI Instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_Init(uint32_t Instance)
{
34185878:	b580      	push	{r7, lr}
3418587a:	b088      	sub	sp, #32
3418587c:	af00      	add	r7, sp, #0
3418587e:	6078      	str	r0, [r7, #4]
  MX_XSPI_InitTypeDef xspi_init;
  int32_t ret = BSP_ERROR_NONE;
34185880:	2300      	movs	r3, #0
34185882:	61fb      	str	r3, [r7, #28]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34185884:	687b      	ldr	r3, [r7, #4]
34185886:	2b00      	cmp	r3, #0
34185888:	d003      	beq.n	34185892 <BSP_XSPI_RAM_Init+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3418588a:	f06f 0301 	mvn.w	r3, #1
3418588e:	61fb      	str	r3, [r7, #28]
34185890:	e062      	b.n	34185958 <BSP_XSPI_RAM_Init+0xe0>
  }
  else
  {
    /* Check if the instance is already initialized */
    if (XSPI_Ram_Ctx[Instance].IsInitialized == XSPI_ACCESS_NONE)
34185892:	4a34      	ldr	r2, [pc, #208]	@ (34185964 <BSP_XSPI_RAM_Init+0xec>)
34185894:	687b      	ldr	r3, [r7, #4]
34185896:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
3418589a:	2b00      	cmp	r3, #0
3418589c:	d131      	bne.n	34185902 <BSP_XSPI_RAM_Init+0x8a>
    {
#if (USE_HAL_XSPI_REGISTER_CALLBACKS == 0)
      /* Msp XSPI initialization */
      XSPI_RAM_MspInit(&hxspi_ram[Instance]);
3418589e:	687b      	ldr	r3, [r7, #4]
341858a0:	2264      	movs	r2, #100	@ 0x64
341858a2:	fb02 f303 	mul.w	r3, r2, r3
341858a6:	4a30      	ldr	r2, [pc, #192]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
341858a8:	4413      	add	r3, r2
341858aa:	4618      	mov	r0, r3
341858ac:	f000 fc9c 	bl	341861e8 <XSPI_RAM_MspInit>
        }
      }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

      /* Fill config structure */
      xspi_init.ClockPrescaler = 3;
341858b0:	2303      	movs	r3, #3
341858b2:	613b      	str	r3, [r7, #16]
      xspi_init.MemorySize     = HAL_XSPI_SIZE_256MB;
341858b4:	2318      	movs	r3, #24
341858b6:	60fb      	str	r3, [r7, #12]
      xspi_init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
341858b8:	2300      	movs	r3, #0
341858ba:	617b      	str	r3, [r7, #20]

      /* STM32 XSPI interface initialization */
      if (MX_XSPI_RAM_Init(&hxspi_ram[Instance], &xspi_init) != HAL_OK)
341858bc:	687b      	ldr	r3, [r7, #4]
341858be:	2264      	movs	r2, #100	@ 0x64
341858c0:	fb02 f303 	mul.w	r3, r2, r3
341858c4:	4a28      	ldr	r2, [pc, #160]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
341858c6:	4413      	add	r3, r2
341858c8:	f107 020c 	add.w	r2, r7, #12
341858cc:	4611      	mov	r1, r2
341858ce:	4618      	mov	r0, r3
341858d0:	f000 f84c 	bl	3418596c <MX_XSPI_RAM_Init>
341858d4:	4603      	mov	r3, r0
341858d6:	2b00      	cmp	r3, #0
341858d8:	d002      	beq.n	341858e0 <BSP_XSPI_RAM_Init+0x68>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
341858da:	f06f 0303 	mvn.w	r3, #3
341858de:	61fb      	str	r3, [r7, #28]
      }
      /* Update current status parameter */
      XSPI_Ram_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;
341858e0:	4a20      	ldr	r2, [pc, #128]	@ (34185964 <BSP_XSPI_RAM_Init+0xec>)
341858e2:	687b      	ldr	r3, [r7, #4]
341858e4:	2101      	movs	r1, #1
341858e6:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
      XSPI_Ram_Ctx[Instance].LatencyType   = BSP_XSPI_RAM_FIXED_LATENCY;
341858ea:	4a1e      	ldr	r2, [pc, #120]	@ (34185964 <BSP_XSPI_RAM_Init+0xec>)
341858ec:	687b      	ldr	r3, [r7, #4]
341858ee:	009b      	lsls	r3, r3, #2
341858f0:	4413      	add	r3, r2
341858f2:	2201      	movs	r2, #1
341858f4:	705a      	strb	r2, [r3, #1]
      XSPI_Ram_Ctx[Instance].BurstType     = BSP_XSPI_RAM_LINEAR_BURST;
341858f6:	4a1b      	ldr	r2, [pc, #108]	@ (34185964 <BSP_XSPI_RAM_Init+0xec>)
341858f8:	687b      	ldr	r3, [r7, #4]
341858fa:	009b      	lsls	r3, r3, #2
341858fc:	4413      	add	r3, r2
341858fe:	2201      	movs	r2, #1
34185900:	709a      	strb	r2, [r3, #2]
    }

    /* Read Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 0, 0x30));
34185902:	687b      	ldr	r3, [r7, #4]
34185904:	2264      	movs	r2, #100	@ 0x64
34185906:	fb02 f303 	mul.w	r3, r2, r3
3418590a:	4a17      	ldr	r2, [pc, #92]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
3418590c:	4413      	add	r3, r2
3418590e:	2230      	movs	r2, #48	@ 0x30
34185910:	2100      	movs	r1, #0
34185912:	4618      	mov	r0, r3
34185914:	f011 fdd0 	bl	341974b8 <APS256XX_WriteReg>

    /* Write Latency=7 up to 200MHz */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 4, 0x20));
34185918:	687b      	ldr	r3, [r7, #4]
3418591a:	2264      	movs	r2, #100	@ 0x64
3418591c:	fb02 f303 	mul.w	r3, r2, r3
34185920:	4a11      	ldr	r2, [pc, #68]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
34185922:	4413      	add	r3, r2
34185924:	2220      	movs	r2, #32
34185926:	2104      	movs	r1, #4
34185928:	4618      	mov	r0, r3
3418592a:	f011 fdc5 	bl	341974b8 <APS256XX_WriteReg>

    /* Switch to x16 mode */
    (void) (APS256XX_WriteReg(&hxspi_ram[Instance], 8, 0x40));
3418592e:	687b      	ldr	r3, [r7, #4]
34185930:	2264      	movs	r2, #100	@ 0x64
34185932:	fb02 f303 	mul.w	r3, r2, r3
34185936:	4a0c      	ldr	r2, [pc, #48]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
34185938:	4413      	add	r3, r2
3418593a:	2240      	movs	r2, #64	@ 0x40
3418593c:	2108      	movs	r1, #8
3418593e:	4618      	mov	r0, r3
34185940:	f011 fdba 	bl	341974b8 <APS256XX_WriteReg>

    /* Bypass the Pre-scaler */
    (void) (HAL_XSPI_SetClockPrescaler(&hxspi_ram[Instance], 0));
34185944:	687b      	ldr	r3, [r7, #4]
34185946:	2264      	movs	r2, #100	@ 0x64
34185948:	fb02 f303 	mul.w	r3, r2, r3
3418594c:	4a06      	ldr	r2, [pc, #24]	@ (34185968 <BSP_XSPI_RAM_Init+0xf0>)
3418594e:	4413      	add	r3, r2
34185950:	2100      	movs	r1, #0
34185952:	4618      	mov	r0, r3
34185954:	f011 f999 	bl	34196c8a <HAL_XSPI_SetClockPrescaler>

  }

  /* Return BSP status */
  return ret;
34185958:	69fb      	ldr	r3, [r7, #28]
}
3418595a:	4618      	mov	r0, r3
3418595c:	3720      	adds	r7, #32
3418595e:	46bd      	mov	sp, r7
34185960:	bd80      	pop	{r7, pc}
34185962:	bf00      	nop
34185964:	341c12f0 	.word	0x341c12f0
34185968:	341c128c 	.word	0x341c128c

3418596c <MX_XSPI_RAM_Init>:
  * @param  hxspi          XSPI handle
  * @param  Init           XSPI config structure
  * @retval BSP status
  */
__weak HAL_StatusTypeDef MX_XSPI_RAM_Init(XSPI_HandleTypeDef *hxspi, MX_XSPI_InitTypeDef *Init)
{
3418596c:	b580      	push	{r7, lr}
3418596e:	b084      	sub	sp, #16
34185970:	af00      	add	r7, sp, #0
34185972:	6078      	str	r0, [r7, #4]
34185974:	6039      	str	r1, [r7, #0]
  uint32_t hspi_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1);
34185976:	f04f 0000 	mov.w	r0, #0
3418597a:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
3418597e:	f00c fae3 	bl	34191f48 <HAL_RCCEx_GetPeriphCLKFreq>
34185982:	60f8      	str	r0, [r7, #12]

  /* XSPI initialization */
  hxspi->Instance = XSPI1;
34185984:	687b      	ldr	r3, [r7, #4]
34185986:	4a21      	ldr	r2, [pc, #132]	@ (34185a0c <MX_XSPI_RAM_Init+0xa0>)
34185988:	601a      	str	r2, [r3, #0]

  hxspi->Init.FifoThresholdByte          = 8;
3418598a:	687b      	ldr	r3, [r7, #4]
3418598c:	2208      	movs	r2, #8
3418598e:	605a      	str	r2, [r3, #4]
  hxspi->Init.MemoryType                 = HAL_XSPI_MEMTYPE_APMEM_16BITS;
34185990:	687b      	ldr	r3, [r7, #4]
34185992:	f04f 62c0 	mov.w	r2, #100663296	@ 0x6000000
34185996:	60da      	str	r2, [r3, #12]
  hxspi->Init.MemoryMode                 = HAL_XSPI_SINGLE_MEM;
34185998:	687b      	ldr	r3, [r7, #4]
3418599a:	2200      	movs	r2, #0
3418599c:	609a      	str	r2, [r3, #8]
  hxspi->Init.MemorySize                 = Init->MemorySize;
3418599e:	683b      	ldr	r3, [r7, #0]
341859a0:	681a      	ldr	r2, [r3, #0]
341859a2:	687b      	ldr	r3, [r7, #4]
341859a4:	611a      	str	r2, [r3, #16]
  hxspi->Init.MemorySelect               = HAL_XSPI_CSSEL_NCS1;
341859a6:	687b      	ldr	r3, [r7, #4]
341859a8:	2200      	movs	r2, #0
341859aa:	63da      	str	r2, [r3, #60]	@ 0x3c
  hxspi->Init.ChipSelectHighTimeCycle    = 5;
341859ac:	687b      	ldr	r3, [r7, #4]
341859ae:	2205      	movs	r2, #5
341859b0:	615a      	str	r2, [r3, #20]
  hxspi->Init.ClockMode                  = HAL_XSPI_CLOCK_MODE_0;
341859b2:	687b      	ldr	r3, [r7, #4]
341859b4:	2200      	movs	r2, #0
341859b6:	61da      	str	r2, [r3, #28]
  hxspi->Init.ClockPrescaler             = Init->ClockPrescaler;
341859b8:	683b      	ldr	r3, [r7, #0]
341859ba:	685a      	ldr	r2, [r3, #4]
341859bc:	687b      	ldr	r3, [r7, #4]
341859be:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi->Init.SampleShifting             = Init->SampleShifting;
341859c0:	683b      	ldr	r3, [r7, #0]
341859c2:	689a      	ldr	r2, [r3, #8]
341859c4:	687b      	ldr	r3, [r7, #4]
341859c6:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi->Init.DelayHoldQuarterCycle      = HAL_XSPI_DHQC_ENABLE;
341859c8:	687b      	ldr	r3, [r7, #4]
341859ca:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
341859ce:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi->Init.ChipSelectBoundary         = HAL_XSPI_BONDARYOF_16KB;
341859d0:	687b      	ldr	r3, [r7, #4]
341859d2:	220b      	movs	r2, #11
341859d4:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi->Init.FreeRunningClock           = HAL_XSPI_FREERUNCLK_DISABLE;
341859d6:	687b      	ldr	r3, [r7, #4]
341859d8:	2200      	movs	r2, #0
341859da:	619a      	str	r2, [r3, #24]
  hxspi->Init.Refresh                    = ((2U * (hspi_clk / hxspi->Init.ClockPrescaler)) / 1000000U) - 4U;
341859dc:	687b      	ldr	r3, [r7, #4]
341859de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341859e0:	68fa      	ldr	r2, [r7, #12]
341859e2:	fbb2 f3f3 	udiv	r3, r2, r3
341859e6:	005b      	lsls	r3, r3, #1
341859e8:	4a09      	ldr	r2, [pc, #36]	@ (34185a10 <MX_XSPI_RAM_Init+0xa4>)
341859ea:	fba2 2303 	umull	r2, r3, r2, r3
341859ee:	0c9b      	lsrs	r3, r3, #18
341859f0:	1f1a      	subs	r2, r3, #4
341859f2:	687b      	ldr	r3, [r7, #4]
341859f4:	639a      	str	r2, [r3, #56]	@ 0x38
#if defined (OCTOSPI_DCR1_DLYBYP)
  hxspi->Init.DelayBlockBypass           = HAL_XSPI_DELAY_BLOCK_BYPASS;
#endif /* defined (OCTOSPI_DCR1_DLYBYP) */
  hxspi->Init.WrapSize                   = HAL_XSPI_WRAP_NOT_SUPPORTED;
341859f6:	687b      	ldr	r3, [r7, #4]
341859f8:	2200      	movs	r2, #0
341859fa:	621a      	str	r2, [r3, #32]

  return HAL_XSPI_Init(hxspi);
341859fc:	6878      	ldr	r0, [r7, #4]
341859fe:	f010 fd11 	bl	34196424 <HAL_XSPI_Init>
34185a02:	4603      	mov	r3, r0
}
34185a04:	4618      	mov	r0, r3
34185a06:	3710      	adds	r7, #16
34185a08:	46bd      	mov	sp, r7
34185a0a:	bd80      	pop	{r7, pc}
34185a0c:	58025000 	.word	0x58025000
34185a10:	431bde83 	.word	0x431bde83

34185a14 <BSP_XSPI_RAM_EnableMemoryMappedMode>:
  * @brief  Configure the XSPI in memory-mapped mode
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
int32_t BSP_XSPI_RAM_EnableMemoryMappedMode(uint32_t Instance)
{
34185a14:	b580      	push	{r7, lr}
34185a16:	b086      	sub	sp, #24
34185a18:	af02      	add	r7, sp, #8
34185a1a:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34185a1c:	2300      	movs	r3, #0
34185a1e:	60fb      	str	r3, [r7, #12]

  /* Check if the instance is supported */
  if (Instance >= XSPI_RAM_INSTANCES_NUMBER)
34185a20:	687b      	ldr	r3, [r7, #4]
34185a22:	2b00      	cmp	r3, #0
34185a24:	d003      	beq.n	34185a2e <BSP_XSPI_RAM_EnableMemoryMappedMode+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34185a26:	f06f 0301 	mvn.w	r3, #1
34185a2a:	60fb      	str	r3, [r7, #12]
34185a2c:	e012      	b.n	34185a54 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
  }
  else
  {
    if (APS256XX_EnableMemoryMappedMode(&hxspi_ram[Instance], 7, 7, 1, 0) != APS256XX_OK)
34185a2e:	687b      	ldr	r3, [r7, #4]
34185a30:	2264      	movs	r2, #100	@ 0x64
34185a32:	fb02 f303 	mul.w	r3, r2, r3
34185a36:	4a0a      	ldr	r2, [pc, #40]	@ (34185a60 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x4c>)
34185a38:	1898      	adds	r0, r3, r2
34185a3a:	2300      	movs	r3, #0
34185a3c:	9300      	str	r3, [sp, #0]
34185a3e:	2301      	movs	r3, #1
34185a40:	2207      	movs	r2, #7
34185a42:	2107      	movs	r1, #7
34185a44:	f011 fcbc 	bl	341973c0 <APS256XX_EnableMemoryMappedMode>
34185a48:	4603      	mov	r3, r0
34185a4a:	2b00      	cmp	r3, #0
34185a4c:	d002      	beq.n	34185a54 <BSP_XSPI_RAM_EnableMemoryMappedMode+0x40>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34185a4e:	f06f 0303 	mvn.w	r3, #3
34185a52:	60fb      	str	r3, [r7, #12]
    }
  }


  /* Return BSP status */
  return ret;
34185a54:	68fb      	ldr	r3, [r7, #12]
}
34185a56:	4618      	mov	r0, r3
34185a58:	3710      	adds	r7, #16
34185a5a:	46bd      	mov	sp, r7
34185a5c:	bd80      	pop	{r7, pc}
34185a5e:	bf00      	nop
34185a60:	341c128c 	.word	0x341c128c

34185a64 <XSPI_NOR_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_NOR_MspInit(const XSPI_HandleTypeDef *hxspi)
{
34185a64:	b580      	push	{r7, lr}
34185a66:	b088      	sub	sp, #32
34185a68:	af00      	add	r7, sp, #0
34185a6a:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

  /* Enable the XSPI memory interface clock */
  XSPI_NOR_CLK_ENABLE();
34185a6c:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34185a70:	f7ff fce6 	bl	34185440 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_NOR_FORCE_RESET();
34185a74:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34185a78:	f7ff fcf8 	bl	3418546c <LL_AHB5_GRP1_ForceReset>
  XSPI_NOR_RELEASE_RESET();
34185a7c:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34185a80:	f7ff fd04 	bl	3418548c <LL_AHB5_GRP1_ReleaseReset>

  /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
34185a84:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
34185a88:	f7ff fcc4 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO3();
34185a8c:	f006 ff3c 	bl	3418c908 <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3, PWR_VDDIO_RANGE_1V8);
34185a90:	2101      	movs	r1, #1
34185a92:	2002      	movs	r0, #2
34185a94:	f006 fed6 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  /* Enable GPIO clocks */
  XSPI_NOR_CLK_GPIO_CLK_ENABLE();
34185a98:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185a9c:	f7ff fcba 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_DQS_GPIO_CLK_ENABLE();
34185aa0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185aa4:	f7ff fcb6 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_CS_GPIO_CLK_ENABLE();
34185aa8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185aac:	f7ff fcb2 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D0_GPIO_CLK_ENABLE();
34185ab0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185ab4:	f7ff fcae 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D1_GPIO_CLK_ENABLE();
34185ab8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185abc:	f7ff fcaa 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D2_GPIO_CLK_ENABLE();
34185ac0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185ac4:	f7ff fca6 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D3_GPIO_CLK_ENABLE();
34185ac8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185acc:	f7ff fca2 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D4_GPIO_CLK_ENABLE();
34185ad0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185ad4:	f7ff fc9e 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D5_GPIO_CLK_ENABLE();
34185ad8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185adc:	f7ff fc9a 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D6_GPIO_CLK_ENABLE();
34185ae0:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185ae4:	f7ff fc96 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_NOR_D7_GPIO_CLK_ENABLE();
34185ae8:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34185aec:	f7ff fc92 	bl	34185414 <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CS_PIN;
34185af0:	2302      	movs	r3, #2
34185af2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
34185af4:	2302      	movs	r3, #2
34185af6:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
34185af8:	2301      	movs	r3, #1
34185afa:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34185afc:	2303      	movs	r3, #3
34185afe:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_NOR_CS_PIN_AF;
34185b00:	2309      	movs	r3, #9
34185b02:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CS_GPIO_PORT, &GPIO_InitStruct);
34185b04:	f107 030c 	add.w	r3, r7, #12
34185b08:	4619      	mov	r1, r3
34185b0a:	4838      	ldr	r0, [pc, #224]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b0c:	f004 fb16 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI DQS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_DQS_PIN;
34185b10:	2301      	movs	r3, #1
34185b12:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_DQS_PIN_AF;
34185b14:	2309      	movs	r3, #9
34185b16:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_DQS_GPIO_PORT, &GPIO_InitStruct);
34185b18:	f107 030c 	add.w	r3, r7, #12
34185b1c:	4619      	mov	r1, r3
34185b1e:	4833      	ldr	r0, [pc, #204]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b20:	f004 fb0c 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_CLK_PIN;
34185b24:	2340      	movs	r3, #64	@ 0x40
34185b26:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
34185b28:	2300      	movs	r3, #0
34185b2a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_NOR_CLK_PIN_AF;
34185b2c:	2309      	movs	r3, #9
34185b2e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_CLK_GPIO_PORT, &GPIO_InitStruct);
34185b30:	f107 030c 	add.w	r3, r7, #12
34185b34:	4619      	mov	r1, r3
34185b36:	482d      	ldr	r0, [pc, #180]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b38:	f004 fb00 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D0_PIN;
34185b3c:	2304      	movs	r3, #4
34185b3e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D0_PIN_AF;
34185b40:	2309      	movs	r3, #9
34185b42:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D0_GPIO_PORT, &GPIO_InitStruct);
34185b44:	f107 030c 	add.w	r3, r7, #12
34185b48:	4619      	mov	r1, r3
34185b4a:	4828      	ldr	r0, [pc, #160]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b4c:	f004 faf6 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D1_PIN;
34185b50:	2308      	movs	r3, #8
34185b52:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D1_PIN_AF;
34185b54:	2309      	movs	r3, #9
34185b56:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D1_GPIO_PORT, &GPIO_InitStruct);
34185b58:	f107 030c 	add.w	r3, r7, #12
34185b5c:	4619      	mov	r1, r3
34185b5e:	4823      	ldr	r0, [pc, #140]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b60:	f004 faec 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D2_PIN;
34185b64:	2310      	movs	r3, #16
34185b66:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D2_PIN_AF;
34185b68:	2309      	movs	r3, #9
34185b6a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D2_GPIO_PORT, &GPIO_InitStruct);
34185b6c:	f107 030c 	add.w	r3, r7, #12
34185b70:	4619      	mov	r1, r3
34185b72:	481e      	ldr	r0, [pc, #120]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b74:	f004 fae2 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D3_PIN;
34185b78:	2320      	movs	r3, #32
34185b7a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D3_PIN_AF;
34185b7c:	2309      	movs	r3, #9
34185b7e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D3_GPIO_PORT, &GPIO_InitStruct);
34185b80:	f107 030c 	add.w	r3, r7, #12
34185b84:	4619      	mov	r1, r3
34185b86:	4819      	ldr	r0, [pc, #100]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b88:	f004 fad8 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D4_PIN;
34185b8c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34185b90:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D4_PIN_AF;
34185b92:	2309      	movs	r3, #9
34185b94:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D4_GPIO_PORT, &GPIO_InitStruct);
34185b96:	f107 030c 	add.w	r3, r7, #12
34185b9a:	4619      	mov	r1, r3
34185b9c:	4813      	ldr	r0, [pc, #76]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185b9e:	f004 facd 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D5_PIN;
34185ba2:	f44f 7300 	mov.w	r3, #512	@ 0x200
34185ba6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D5_PIN_AF;
34185ba8:	2309      	movs	r3, #9
34185baa:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D5_GPIO_PORT, &GPIO_InitStruct);
34185bac:	f107 030c 	add.w	r3, r7, #12
34185bb0:	4619      	mov	r1, r3
34185bb2:	480e      	ldr	r0, [pc, #56]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185bb4:	f004 fac2 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D6_PIN;
34185bb8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34185bbc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D6_PIN_AF;
34185bbe:	2309      	movs	r3, #9
34185bc0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D6_GPIO_PORT, &GPIO_InitStruct);
34185bc2:	f107 030c 	add.w	r3, r7, #12
34185bc6:	4619      	mov	r1, r3
34185bc8:	4808      	ldr	r0, [pc, #32]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185bca:	f004 fab7 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_NOR_D7_PIN;
34185bce:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34185bd2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_NOR_D7_PIN_AF;
34185bd4:	2309      	movs	r3, #9
34185bd6:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_NOR_D7_GPIO_PORT, &GPIO_InitStruct);
34185bd8:	f107 030c 	add.w	r3, r7, #12
34185bdc:	4619      	mov	r1, r3
34185bde:	4803      	ldr	r0, [pc, #12]	@ (34185bec <XSPI_NOR_MspInit+0x188>)
34185be0:	f004 faac 	bl	3418a13c <HAL_GPIO_Init>
}
34185be4:	bf00      	nop
34185be6:	3720      	adds	r7, #32
34185be8:	46bd      	mov	sp, r7
34185bea:	bd80      	pop	{r7, pc}
34185bec:	56023400 	.word	0x56023400

34185bf0 <XSPI_NOR_ResetMemory>:
  * @brief  This function reset the XSPI memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ResetMemory(uint32_t Instance)
{
34185bf0:	b580      	push	{r7, lr}
34185bf2:	b084      	sub	sp, #16
34185bf4:	af00      	add	r7, sp, #0
34185bf6:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34185bf8:	2300      	movs	r3, #0
34185bfa:	60fb      	str	r3, [r7, #12]

  if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34185bfc:	687b      	ldr	r3, [r7, #4]
34185bfe:	2264      	movs	r2, #100	@ 0x64
34185c00:	fb02 f303 	mul.w	r3, r2, r3
34185c04:	4a44      	ldr	r2, [pc, #272]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185c06:	4413      	add	r3, r2
34185c08:	2200      	movs	r2, #0
34185c0a:	2100      	movs	r1, #0
34185c0c:	4618      	mov	r0, r3
34185c0e:	f012 f88e 	bl	34197d2e <MX66UW1G45G_ResetEnable>
34185c12:	4603      	mov	r3, r0
34185c14:	2b00      	cmp	r3, #0
34185c16:	d003      	beq.n	34185c20 <XSPI_NOR_ResetMemory+0x30>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185c18:	f06f 0304 	mvn.w	r3, #4
34185c1c:	60fb      	str	r3, [r7, #12]
34185c1e:	e076      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
34185c20:	687b      	ldr	r3, [r7, #4]
34185c22:	2264      	movs	r2, #100	@ 0x64
34185c24:	fb02 f303 	mul.w	r3, r2, r3
34185c28:	4a3b      	ldr	r2, [pc, #236]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185c2a:	4413      	add	r3, r2
34185c2c:	2200      	movs	r2, #0
34185c2e:	2100      	movs	r1, #0
34185c30:	4618      	mov	r0, r3
34185c32:	f012 f8d2 	bl	34197dda <MX66UW1G45G_ResetMemory>
34185c36:	4603      	mov	r3, r0
34185c38:	2b00      	cmp	r3, #0
34185c3a:	d003      	beq.n	34185c44 <XSPI_NOR_ResetMemory+0x54>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185c3c:	f06f 0304 	mvn.w	r3, #4
34185c40:	60fb      	str	r3, [r7, #12]
34185c42:	e064      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34185c44:	687b      	ldr	r3, [r7, #4]
34185c46:	2264      	movs	r2, #100	@ 0x64
34185c48:	fb02 f303 	mul.w	r3, r2, r3
34185c4c:	4a32      	ldr	r2, [pc, #200]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185c4e:	4413      	add	r3, r2
34185c50:	2200      	movs	r2, #0
34185c52:	2101      	movs	r1, #1
34185c54:	4618      	mov	r0, r3
34185c56:	f012 f86a 	bl	34197d2e <MX66UW1G45G_ResetEnable>
34185c5a:	4603      	mov	r3, r0
34185c5c:	2b00      	cmp	r3, #0
34185c5e:	d003      	beq.n	34185c68 <XSPI_NOR_ResetMemory+0x78>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185c60:	f06f 0304 	mvn.w	r3, #4
34185c64:	60fb      	str	r3, [r7, #12]
34185c66:	e052      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34185c68:	687b      	ldr	r3, [r7, #4]
34185c6a:	2264      	movs	r2, #100	@ 0x64
34185c6c:	fb02 f303 	mul.w	r3, r2, r3
34185c70:	4a29      	ldr	r2, [pc, #164]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185c72:	4413      	add	r3, r2
34185c74:	2200      	movs	r2, #0
34185c76:	2101      	movs	r1, #1
34185c78:	4618      	mov	r0, r3
34185c7a:	f012 f8ae 	bl	34197dda <MX66UW1G45G_ResetMemory>
34185c7e:	4603      	mov	r3, r0
34185c80:	2b00      	cmp	r3, #0
34185c82:	d003      	beq.n	34185c8c <XSPI_NOR_ResetMemory+0x9c>
                                    BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185c84:	f06f 0304 	mvn.w	r3, #4
34185c88:	60fb      	str	r3, [r7, #12]
34185c8a:	e040      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetEnable(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34185c8c:	687b      	ldr	r3, [r7, #4]
34185c8e:	2264      	movs	r2, #100	@ 0x64
34185c90:	fb02 f303 	mul.w	r3, r2, r3
34185c94:	4a20      	ldr	r2, [pc, #128]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185c96:	4413      	add	r3, r2
34185c98:	2201      	movs	r2, #1
34185c9a:	2101      	movs	r1, #1
34185c9c:	4618      	mov	r0, r3
34185c9e:	f012 f846 	bl	34197d2e <MX66UW1G45G_ResetEnable>
34185ca2:	4603      	mov	r3, r0
34185ca4:	2b00      	cmp	r3, #0
34185ca6:	d003      	beq.n	34185cb0 <XSPI_NOR_ResetMemory+0xc0>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185ca8:	f06f 0304 	mvn.w	r3, #4
34185cac:	60fb      	str	r3, [r7, #12]
34185cae:	e02e      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else if (MX66UW1G45G_ResetMemory(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34185cb0:	687b      	ldr	r3, [r7, #4]
34185cb2:	2264      	movs	r2, #100	@ 0x64
34185cb4:	fb02 f303 	mul.w	r3, r2, r3
34185cb8:	4a17      	ldr	r2, [pc, #92]	@ (34185d18 <XSPI_NOR_ResetMemory+0x128>)
34185cba:	4413      	add	r3, r2
34185cbc:	2201      	movs	r2, #1
34185cbe:	2101      	movs	r1, #1
34185cc0:	4618      	mov	r0, r3
34185cc2:	f012 f88a 	bl	34197dda <MX66UW1G45G_ResetMemory>
34185cc6:	4603      	mov	r3, r0
34185cc8:	2b00      	cmp	r3, #0
34185cca:	d003      	beq.n	34185cd4 <XSPI_NOR_ResetMemory+0xe4>
                                    BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185ccc:	f06f 0304 	mvn.w	r3, #4
34185cd0:	60fb      	str	r3, [r7, #12]
34185cd2:	e01c      	b.n	34185d0e <XSPI_NOR_ResetMemory+0x11e>
  }
  else
  {
    XSPI_Nor_Ctx[Instance].IsInitialized = XSPI_ACCESS_INDIRECT;     /* After reset S/W setting to indirect access  */
34185cd4:	4911      	ldr	r1, [pc, #68]	@ (34185d1c <XSPI_NOR_ResetMemory+0x12c>)
34185cd6:	687a      	ldr	r2, [r7, #4]
34185cd8:	4613      	mov	r3, r2
34185cda:	005b      	lsls	r3, r3, #1
34185cdc:	4413      	add	r3, r2
34185cde:	440b      	add	r3, r1
34185ce0:	2201      	movs	r2, #1
34185ce2:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].InterfaceMode = BSP_XSPI_NOR_SPI_MODE;    /* After reset H/W back to SPI mode by default */
34185ce4:	490d      	ldr	r1, [pc, #52]	@ (34185d1c <XSPI_NOR_ResetMemory+0x12c>)
34185ce6:	687a      	ldr	r2, [r7, #4]
34185ce8:	4613      	mov	r3, r2
34185cea:	005b      	lsls	r3, r3, #1
34185cec:	4413      	add	r3, r2
34185cee:	440b      	add	r3, r1
34185cf0:	3301      	adds	r3, #1
34185cf2:	2200      	movs	r2, #0
34185cf4:	701a      	strb	r2, [r3, #0]
    XSPI_Nor_Ctx[Instance].TransferRate  = BSP_XSPI_NOR_STR_TRANSFER; /* After reset S/W setting to STR mode        */
34185cf6:	4909      	ldr	r1, [pc, #36]	@ (34185d1c <XSPI_NOR_ResetMemory+0x12c>)
34185cf8:	687a      	ldr	r2, [r7, #4]
34185cfa:	4613      	mov	r3, r2
34185cfc:	005b      	lsls	r3, r3, #1
34185cfe:	4413      	add	r3, r2
34185d00:	440b      	add	r3, r1
34185d02:	3302      	adds	r3, #2
34185d04:	2200      	movs	r2, #0
34185d06:	701a      	strb	r2, [r3, #0]

    /* After SWreset CMD, wait in case SWReset occurred during erase operation */
    HAL_Delay(MX66UW1G45G_RESET_MAX_TIME);
34185d08:	2064      	movs	r0, #100	@ 0x64
34185d0a:	f000 fc0d 	bl	34186528 <HAL_Delay>
  }

  /* Return BSP status */
  return ret;
34185d0e:	68fb      	ldr	r3, [r7, #12]
}
34185d10:	4618      	mov	r0, r3
34185d12:	3710      	adds	r7, #16
34185d14:	46bd      	mov	sp, r7
34185d16:	bd80      	pop	{r7, pc}
34185d18:	341c1224 	.word	0x341c1224
34185d1c:	341c1288 	.word	0x341c1288

34185d20 <XSPI_NOR_EnterDOPIMode>:
  * @brief  This function enables the octal DTR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterDOPIMode(uint32_t Instance)
{
34185d20:	b590      	push	{r4, r7, lr}
34185d22:	b087      	sub	sp, #28
34185d24:	af02      	add	r7, sp, #8
34185d26:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185d28:	687b      	ldr	r3, [r7, #4]
34185d2a:	2264      	movs	r2, #100	@ 0x64
34185d2c:	fb02 f303 	mul.w	r3, r2, r3
34185d30:	4a6e      	ldr	r2, [pc, #440]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185d32:	1898      	adds	r0, r3, r2
34185d34:	496e      	ldr	r1, [pc, #440]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185d36:	687a      	ldr	r2, [r7, #4]
34185d38:	4613      	mov	r3, r2
34185d3a:	005b      	lsls	r3, r3, #1
34185d3c:	4413      	add	r3, r2
34185d3e:	440b      	add	r3, r1
34185d40:	3301      	adds	r3, #1
34185d42:	7819      	ldrb	r1, [r3, #0]
34185d44:	4c6a      	ldr	r4, [pc, #424]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185d46:	687a      	ldr	r2, [r7, #4]
34185d48:	4613      	mov	r3, r2
34185d4a:	005b      	lsls	r3, r3, #1
34185d4c:	4413      	add	r3, r2
34185d4e:	4423      	add	r3, r4
34185d50:	3302      	adds	r3, #2
34185d52:	781b      	ldrb	r3, [r3, #0]
34185d54:	461a      	mov	r2, r3
34185d56:	f011 fdf2 	bl	3419793e <MX66UW1G45G_WriteEnable>
34185d5a:	4603      	mov	r3, r0
34185d5c:	2b00      	cmp	r3, #0
34185d5e:	d003      	beq.n	34185d68 <XSPI_NOR_EnterDOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185d60:	f06f 0304 	mvn.w	r3, #4
34185d64:	60fb      	str	r3, [r7, #12]
34185d66:	e0bb      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185d68:	687b      	ldr	r3, [r7, #4]
34185d6a:	2264      	movs	r2, #100	@ 0x64
34185d6c:	fb02 f303 	mul.w	r3, r2, r3
34185d70:	4a5e      	ldr	r2, [pc, #376]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185d72:	1898      	adds	r0, r3, r2
34185d74:	495e      	ldr	r1, [pc, #376]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185d76:	687a      	ldr	r2, [r7, #4]
34185d78:	4613      	mov	r3, r2
34185d7a:	005b      	lsls	r3, r3, #1
34185d7c:	4413      	add	r3, r2
34185d7e:	440b      	add	r3, r1
34185d80:	3301      	adds	r3, #1
34185d82:	7819      	ldrb	r1, [r3, #0]
34185d84:	4c5a      	ldr	r4, [pc, #360]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185d86:	687a      	ldr	r2, [r7, #4]
34185d88:	4613      	mov	r3, r2
34185d8a:	005b      	lsls	r3, r3, #1
34185d8c:	4413      	add	r3, r2
34185d8e:	4423      	add	r3, r4
34185d90:	3302      	adds	r3, #2
34185d92:	781a      	ldrb	r2, [r3, #0]
34185d94:	2300      	movs	r3, #0
34185d96:	9300      	str	r3, [sp, #0]
34185d98:	f44f 7340 	mov.w	r3, #768	@ 0x300
34185d9c:	f011 fe9b 	bl	34197ad6 <MX66UW1G45G_WriteCfg2Register>
34185da0:	4603      	mov	r3, r0
34185da2:	2b00      	cmp	r3, #0
34185da4:	d003      	beq.n	34185dae <XSPI_NOR_EnterDOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185da6:	f06f 0304 	mvn.w	r3, #4
34185daa:	60fb      	str	r3, [r7, #12]
34185dac:	e098      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185dae:	687b      	ldr	r3, [r7, #4]
34185db0:	2264      	movs	r2, #100	@ 0x64
34185db2:	fb02 f303 	mul.w	r3, r2, r3
34185db6:	4a4d      	ldr	r2, [pc, #308]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185db8:	1898      	adds	r0, r3, r2
34185dba:	494d      	ldr	r1, [pc, #308]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185dbc:	687a      	ldr	r2, [r7, #4]
34185dbe:	4613      	mov	r3, r2
34185dc0:	005b      	lsls	r3, r3, #1
34185dc2:	4413      	add	r3, r2
34185dc4:	440b      	add	r3, r1
34185dc6:	3301      	adds	r3, #1
34185dc8:	7819      	ldrb	r1, [r3, #0]
34185dca:	4c49      	ldr	r4, [pc, #292]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185dcc:	687a      	ldr	r2, [r7, #4]
34185dce:	4613      	mov	r3, r2
34185dd0:	005b      	lsls	r3, r3, #1
34185dd2:	4413      	add	r3, r2
34185dd4:	4423      	add	r3, r4
34185dd6:	3302      	adds	r3, #2
34185dd8:	781b      	ldrb	r3, [r3, #0]
34185dda:	461a      	mov	r2, r3
34185ddc:	f011 fdaf 	bl	3419793e <MX66UW1G45G_WriteEnable>
34185de0:	4603      	mov	r3, r0
34185de2:	2b00      	cmp	r3, #0
34185de4:	d003      	beq.n	34185dee <XSPI_NOR_EnterDOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185de6:	f06f 0304 	mvn.w	r3, #4
34185dea:	60fb      	str	r3, [r7, #12]
34185dec:	e078      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185dee:	687b      	ldr	r3, [r7, #4]
34185df0:	2264      	movs	r2, #100	@ 0x64
34185df2:	fb02 f303 	mul.w	r3, r2, r3
34185df6:	4a3d      	ldr	r2, [pc, #244]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185df8:	1898      	adds	r0, r3, r2
34185dfa:	493d      	ldr	r1, [pc, #244]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185dfc:	687a      	ldr	r2, [r7, #4]
34185dfe:	4613      	mov	r3, r2
34185e00:	005b      	lsls	r3, r3, #1
34185e02:	4413      	add	r3, r2
34185e04:	440b      	add	r3, r1
34185e06:	3301      	adds	r3, #1
34185e08:	7819      	ldrb	r1, [r3, #0]
34185e0a:	4c39      	ldr	r4, [pc, #228]	@ (34185ef0 <XSPI_NOR_EnterDOPIMode+0x1d0>)
34185e0c:	687a      	ldr	r2, [r7, #4]
34185e0e:	4613      	mov	r3, r2
34185e10:	005b      	lsls	r3, r3, #1
34185e12:	4413      	add	r3, r2
34185e14:	4423      	add	r3, r4
34185e16:	3302      	adds	r3, #2
34185e18:	781a      	ldrb	r2, [r3, #0]
34185e1a:	2302      	movs	r3, #2
34185e1c:	9300      	str	r3, [sp, #0]
34185e1e:	2300      	movs	r3, #0
34185e20:	f011 fe59 	bl	34197ad6 <MX66UW1G45G_WriteCfg2Register>
34185e24:	4603      	mov	r3, r0
34185e26:	2b00      	cmp	r3, #0
34185e28:	d003      	beq.n	34185e32 <XSPI_NOR_EnterDOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_DOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185e2a:	f06f 0304 	mvn.w	r3, #4
34185e2e:	60fb      	str	r3, [r7, #12]
34185e30:	e056      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34185e32:	2028      	movs	r0, #40	@ 0x28
34185e34:	f000 fb78 	bl	34186528 <HAL_Delay>

    /* Reconfigure the memory type of the peripheral */
    hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MACRONIX;
34185e38:	4a2c      	ldr	r2, [pc, #176]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185e3a:	687b      	ldr	r3, [r7, #4]
34185e3c:	2164      	movs	r1, #100	@ 0x64
34185e3e:	fb01 f303 	mul.w	r3, r1, r3
34185e42:	4413      	add	r3, r2
34185e44:	330c      	adds	r3, #12
34185e46:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34185e4a:	601a      	str	r2, [r3, #0]
    hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_ENABLE;
34185e4c:	4a27      	ldr	r2, [pc, #156]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185e4e:	687b      	ldr	r3, [r7, #4]
34185e50:	2164      	movs	r1, #100	@ 0x64
34185e52:	fb01 f303 	mul.w	r3, r1, r3
34185e56:	4413      	add	r3, r2
34185e58:	332c      	adds	r3, #44	@ 0x2c
34185e5a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34185e5e:	601a      	str	r2, [r3, #0]
    if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34185e60:	687b      	ldr	r3, [r7, #4]
34185e62:	2264      	movs	r2, #100	@ 0x64
34185e64:	fb02 f303 	mul.w	r3, r2, r3
34185e68:	4a20      	ldr	r2, [pc, #128]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185e6a:	4413      	add	r3, r2
34185e6c:	4618      	mov	r0, r3
34185e6e:	f010 fad9 	bl	34196424 <HAL_XSPI_Init>
34185e72:	4603      	mov	r3, r0
34185e74:	2b00      	cmp	r3, #0
34185e76:	d003      	beq.n	34185e80 <XSPI_NOR_EnterDOPIMode+0x160>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34185e78:	f06f 0303 	mvn.w	r3, #3
34185e7c:	60fb      	str	r3, [r7, #12]
34185e7e:	e02f      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check Flash busy ? */
    else if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
34185e80:	687b      	ldr	r3, [r7, #4]
34185e82:	2264      	movs	r2, #100	@ 0x64
34185e84:	fb02 f303 	mul.w	r3, r2, r3
34185e88:	4a18      	ldr	r2, [pc, #96]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185e8a:	4413      	add	r3, r2
34185e8c:	2201      	movs	r2, #1
34185e8e:	2101      	movs	r1, #1
34185e90:	4618      	mov	r0, r3
34185e92:	f011 fb91 	bl	341975b8 <MX66UW1G45G_AutoPollingMemReady>
34185e96:	4603      	mov	r3, r0
34185e98:	2b00      	cmp	r3, #0
34185e9a:	d003      	beq.n	34185ea4 <XSPI_NOR_EnterDOPIMode+0x184>
                                              BSP_XSPI_NOR_DTR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34185e9c:	f06f 0304 	mvn.w	r3, #4
34185ea0:	60fb      	str	r3, [r7, #12]
34185ea2:	e01d      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_DTR_TRANSFER,
34185ea4:	687b      	ldr	r3, [r7, #4]
34185ea6:	2264      	movs	r2, #100	@ 0x64
34185ea8:	fb02 f303 	mul.w	r3, r2, r3
34185eac:	4a0f      	ldr	r2, [pc, #60]	@ (34185eec <XSPI_NOR_EnterDOPIMode+0x1cc>)
34185eae:	1898      	adds	r0, r3, r2
34185eb0:	f107 0308 	add.w	r3, r7, #8
34185eb4:	9300      	str	r3, [sp, #0]
34185eb6:	2300      	movs	r3, #0
34185eb8:	2201      	movs	r2, #1
34185eba:	2101      	movs	r1, #1
34185ebc:	f011 fe9c 	bl	34197bf8 <MX66UW1G45G_ReadCfg2Register>
34185ec0:	4603      	mov	r3, r0
34185ec2:	2b00      	cmp	r3, #0
34185ec4:	d003      	beq.n	34185ece <XSPI_NOR_EnterDOPIMode+0x1ae>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34185ec6:	f06f 0304 	mvn.w	r3, #4
34185eca:	60fb      	str	r3, [r7, #12]
34185ecc:	e008      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else if (reg[0] != MX66UW1G45G_CR2_DOPI)
34185ece:	7a3b      	ldrb	r3, [r7, #8]
34185ed0:	2b02      	cmp	r3, #2
34185ed2:	d003      	beq.n	34185edc <XSPI_NOR_EnterDOPIMode+0x1bc>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34185ed4:	f06f 0304 	mvn.w	r3, #4
34185ed8:	60fb      	str	r3, [r7, #12]
34185eda:	e001      	b.n	34185ee0 <XSPI_NOR_EnterDOPIMode+0x1c0>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34185edc:	2300      	movs	r3, #0
34185ede:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
34185ee0:	68fb      	ldr	r3, [r7, #12]
}
34185ee2:	4618      	mov	r0, r3
34185ee4:	3714      	adds	r7, #20
34185ee6:	46bd      	mov	sp, r7
34185ee8:	bd90      	pop	{r4, r7, pc}
34185eea:	bf00      	nop
34185eec:	341c1224 	.word	0x341c1224
34185ef0:	341c1288 	.word	0x341c1288

34185ef4 <XSPI_NOR_EnterSOPIMode>:
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_EnterSOPIMode(uint32_t Instance)
{
34185ef4:	b590      	push	{r4, r7, lr}
34185ef6:	b087      	sub	sp, #28
34185ef8:	af02      	add	r7, sp, #8
34185efa:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185efc:	687b      	ldr	r3, [r7, #4]
34185efe:	2264      	movs	r2, #100	@ 0x64
34185f00:	fb02 f303 	mul.w	r3, r2, r3
34185f04:	4a5c      	ldr	r2, [pc, #368]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
34185f06:	1898      	adds	r0, r3, r2
34185f08:	495c      	ldr	r1, [pc, #368]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185f0a:	687a      	ldr	r2, [r7, #4]
34185f0c:	4613      	mov	r3, r2
34185f0e:	005b      	lsls	r3, r3, #1
34185f10:	4413      	add	r3, r2
34185f12:	440b      	add	r3, r1
34185f14:	3301      	adds	r3, #1
34185f16:	7819      	ldrb	r1, [r3, #0]
34185f18:	4c58      	ldr	r4, [pc, #352]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185f1a:	687a      	ldr	r2, [r7, #4]
34185f1c:	4613      	mov	r3, r2
34185f1e:	005b      	lsls	r3, r3, #1
34185f20:	4413      	add	r3, r2
34185f22:	4423      	add	r3, r4
34185f24:	3302      	adds	r3, #2
34185f26:	781b      	ldrb	r3, [r3, #0]
34185f28:	461a      	mov	r2, r3
34185f2a:	f011 fd08 	bl	3419793e <MX66UW1G45G_WriteEnable>
34185f2e:	4603      	mov	r3, r0
34185f30:	2b00      	cmp	r3, #0
34185f32:	d003      	beq.n	34185f3c <XSPI_NOR_EnterSOPIMode+0x48>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185f34:	f06f 0304 	mvn.w	r3, #4
34185f38:	60fb      	str	r3, [r7, #12]
34185f3a:	e097      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with new dummy cycles) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185f3c:	687b      	ldr	r3, [r7, #4]
34185f3e:	2264      	movs	r2, #100	@ 0x64
34185f40:	fb02 f303 	mul.w	r3, r2, r3
34185f44:	4a4c      	ldr	r2, [pc, #304]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
34185f46:	1898      	adds	r0, r3, r2
34185f48:	494c      	ldr	r1, [pc, #304]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185f4a:	687a      	ldr	r2, [r7, #4]
34185f4c:	4613      	mov	r3, r2
34185f4e:	005b      	lsls	r3, r3, #1
34185f50:	4413      	add	r3, r2
34185f52:	440b      	add	r3, r1
34185f54:	3301      	adds	r3, #1
34185f56:	7819      	ldrb	r1, [r3, #0]
34185f58:	4c48      	ldr	r4, [pc, #288]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185f5a:	687a      	ldr	r2, [r7, #4]
34185f5c:	4613      	mov	r3, r2
34185f5e:	005b      	lsls	r3, r3, #1
34185f60:	4413      	add	r3, r2
34185f62:	4423      	add	r3, r4
34185f64:	3302      	adds	r3, #2
34185f66:	781a      	ldrb	r2, [r3, #0]
34185f68:	2300      	movs	r3, #0
34185f6a:	9300      	str	r3, [sp, #0]
34185f6c:	f44f 7340 	mov.w	r3, #768	@ 0x300
34185f70:	f011 fdb1 	bl	34197ad6 <MX66UW1G45G_WriteCfg2Register>
34185f74:	4603      	mov	r3, r0
34185f76:	2b00      	cmp	r3, #0
34185f78:	d003      	beq.n	34185f82 <XSPI_NOR_EnterSOPIMode+0x8e>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG3_ADDR,
                                          MX66UW1G45G_CR2_DC_20_CYCLES) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185f7a:	f06f 0304 	mvn.w	r3, #4
34185f7e:	60fb      	str	r3, [r7, #12]
34185f80:	e074      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Enable write operations */
  else if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185f82:	687b      	ldr	r3, [r7, #4]
34185f84:	2264      	movs	r2, #100	@ 0x64
34185f86:	fb02 f303 	mul.w	r3, r2, r3
34185f8a:	4a3b      	ldr	r2, [pc, #236]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
34185f8c:	1898      	adds	r0, r3, r2
34185f8e:	493b      	ldr	r1, [pc, #236]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185f90:	687a      	ldr	r2, [r7, #4]
34185f92:	4613      	mov	r3, r2
34185f94:	005b      	lsls	r3, r3, #1
34185f96:	4413      	add	r3, r2
34185f98:	440b      	add	r3, r1
34185f9a:	3301      	adds	r3, #1
34185f9c:	7819      	ldrb	r1, [r3, #0]
34185f9e:	4c37      	ldr	r4, [pc, #220]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185fa0:	687a      	ldr	r2, [r7, #4]
34185fa2:	4613      	mov	r3, r2
34185fa4:	005b      	lsls	r3, r3, #1
34185fa6:	4413      	add	r3, r2
34185fa8:	4423      	add	r3, r4
34185faa:	3302      	adds	r3, #2
34185fac:	781b      	ldrb	r3, [r3, #0]
34185fae:	461a      	mov	r2, r3
34185fb0:	f011 fcc5 	bl	3419793e <MX66UW1G45G_WriteEnable>
34185fb4:	4603      	mov	r3, r0
34185fb6:	2b00      	cmp	r3, #0
34185fb8:	d003      	beq.n	34185fc2 <XSPI_NOR_EnterSOPIMode+0xce>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185fba:	f06f 0304 	mvn.w	r3, #4
34185fbe:	60fb      	str	r3, [r7, #12]
34185fc0:	e054      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
  }
  /* Write Configuration register 2 (with Octal I/O SPI protocol) */
  else if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
34185fc2:	687b      	ldr	r3, [r7, #4]
34185fc4:	2264      	movs	r2, #100	@ 0x64
34185fc6:	fb02 f303 	mul.w	r3, r2, r3
34185fca:	4a2b      	ldr	r2, [pc, #172]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
34185fcc:	1898      	adds	r0, r3, r2
34185fce:	492b      	ldr	r1, [pc, #172]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185fd0:	687a      	ldr	r2, [r7, #4]
34185fd2:	4613      	mov	r3, r2
34185fd4:	005b      	lsls	r3, r3, #1
34185fd6:	4413      	add	r3, r2
34185fd8:	440b      	add	r3, r1
34185fda:	3301      	adds	r3, #1
34185fdc:	7819      	ldrb	r1, [r3, #0]
34185fde:	4c27      	ldr	r4, [pc, #156]	@ (3418607c <XSPI_NOR_EnterSOPIMode+0x188>)
34185fe0:	687a      	ldr	r2, [r7, #4]
34185fe2:	4613      	mov	r3, r2
34185fe4:	005b      	lsls	r3, r3, #1
34185fe6:	4413      	add	r3, r2
34185fe8:	4423      	add	r3, r4
34185fea:	3302      	adds	r3, #2
34185fec:	781a      	ldrb	r2, [r3, #0]
34185fee:	2301      	movs	r3, #1
34185ff0:	9300      	str	r3, [sp, #0]
34185ff2:	2300      	movs	r3, #0
34185ff4:	f011 fd6f 	bl	34197ad6 <MX66UW1G45G_WriteCfg2Register>
34185ff8:	4603      	mov	r3, r0
34185ffa:	2b00      	cmp	r3, #0
34185ffc:	d003      	beq.n	34186006 <XSPI_NOR_EnterSOPIMode+0x112>
                                          XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                          MX66UW1G45G_CR2_SOPI) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
34185ffe:	f06f 0304 	mvn.w	r3, #4
34186002:	60fb      	str	r3, [r7, #12]
34186004:	e032      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
  }
  else
  {
    /* Wait that the configuration is effective and check that memory is ready */
    HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34186006:	2028      	movs	r0, #40	@ 0x28
34186008:	f000 fa8e 	bl	34186528 <HAL_Delay>

    /* Check Flash busy ? */
    if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE,
3418600c:	687b      	ldr	r3, [r7, #4]
3418600e:	2264      	movs	r2, #100	@ 0x64
34186010:	fb02 f303 	mul.w	r3, r2, r3
34186014:	4a18      	ldr	r2, [pc, #96]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
34186016:	4413      	add	r3, r2
34186018:	2200      	movs	r2, #0
3418601a:	2101      	movs	r1, #1
3418601c:	4618      	mov	r0, r3
3418601e:	f011 facb 	bl	341975b8 <MX66UW1G45G_AutoPollingMemReady>
34186022:	4603      	mov	r3, r0
34186024:	2b00      	cmp	r3, #0
34186026:	d003      	beq.n	34186030 <XSPI_NOR_EnterSOPIMode+0x13c>
                                         BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34186028:	f06f 0304 	mvn.w	r3, #4
3418602c:	60fb      	str	r3, [r7, #12]
3418602e:	e01d      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
    }
    /* Check the configuration has been correctly done */
    else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_OPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
34186030:	687b      	ldr	r3, [r7, #4]
34186032:	2264      	movs	r2, #100	@ 0x64
34186034:	fb02 f303 	mul.w	r3, r2, r3
34186038:	4a0f      	ldr	r2, [pc, #60]	@ (34186078 <XSPI_NOR_EnterSOPIMode+0x184>)
3418603a:	1898      	adds	r0, r3, r2
3418603c:	f107 0308 	add.w	r3, r7, #8
34186040:	9300      	str	r3, [sp, #0]
34186042:	2300      	movs	r3, #0
34186044:	2200      	movs	r2, #0
34186046:	2101      	movs	r1, #1
34186048:	f011 fdd6 	bl	34197bf8 <MX66UW1G45G_ReadCfg2Register>
3418604c:	4603      	mov	r3, r0
3418604e:	2b00      	cmp	r3, #0
34186050:	d003      	beq.n	3418605a <XSPI_NOR_EnterSOPIMode+0x166>
                                           MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34186052:	f06f 0304 	mvn.w	r3, #4
34186056:	60fb      	str	r3, [r7, #12]
34186058:	e008      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else if (reg[0] != MX66UW1G45G_CR2_SOPI)
3418605a:	7a3b      	ldrb	r3, [r7, #8]
3418605c:	2b01      	cmp	r3, #1
3418605e:	d003      	beq.n	34186068 <XSPI_NOR_EnterSOPIMode+0x174>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34186060:	f06f 0304 	mvn.w	r3, #4
34186064:	60fb      	str	r3, [r7, #12]
34186066:	e001      	b.n	3418606c <XSPI_NOR_EnterSOPIMode+0x178>
    }
    else
    {
      ret = BSP_ERROR_NONE;
34186068:	2300      	movs	r3, #0
3418606a:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Return BSP status */
  return ret;
3418606c:	68fb      	ldr	r3, [r7, #12]
}
3418606e:	4618      	mov	r0, r3
34186070:	3714      	adds	r7, #20
34186072:	46bd      	mov	sp, r7
34186074:	bd90      	pop	{r4, r7, pc}
34186076:	bf00      	nop
34186078:	341c1224 	.word	0x341c1224
3418607c:	341c1288 	.word	0x341c1288

34186080 <XSPI_NOR_ExitOPIMode>:
  * @brief  This function disables the octal DTR or STR mode of the memory.
  * @param  Instance  XSPI instance
  * @retval BSP status
  */
static int32_t XSPI_NOR_ExitOPIMode(uint32_t Instance)
{
34186080:	b590      	push	{r4, r7, lr}
34186082:	b087      	sub	sp, #28
34186084:	af02      	add	r7, sp, #8
34186086:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34186088:	2300      	movs	r3, #0
3418608a:	60fb      	str	r3, [r7, #12]
  uint8_t reg[2];

  if (MX66UW1G45G_WriteEnable(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
3418608c:	687b      	ldr	r3, [r7, #4]
3418608e:	2264      	movs	r2, #100	@ 0x64
34186090:	fb02 f303 	mul.w	r3, r2, r3
34186094:	4a52      	ldr	r2, [pc, #328]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
34186096:	1898      	adds	r0, r3, r2
34186098:	4952      	ldr	r1, [pc, #328]	@ (341861e4 <XSPI_NOR_ExitOPIMode+0x164>)
3418609a:	687a      	ldr	r2, [r7, #4]
3418609c:	4613      	mov	r3, r2
3418609e:	005b      	lsls	r3, r3, #1
341860a0:	4413      	add	r3, r2
341860a2:	440b      	add	r3, r1
341860a4:	3301      	adds	r3, #1
341860a6:	7819      	ldrb	r1, [r3, #0]
341860a8:	4c4e      	ldr	r4, [pc, #312]	@ (341861e4 <XSPI_NOR_ExitOPIMode+0x164>)
341860aa:	687a      	ldr	r2, [r7, #4]
341860ac:	4613      	mov	r3, r2
341860ae:	005b      	lsls	r3, r3, #1
341860b0:	4413      	add	r3, r2
341860b2:	4423      	add	r3, r4
341860b4:	3302      	adds	r3, #2
341860b6:	781b      	ldrb	r3, [r3, #0]
341860b8:	461a      	mov	r2, r3
341860ba:	f011 fc40 	bl	3419793e <MX66UW1G45G_WriteEnable>
341860be:	4603      	mov	r3, r0
341860c0:	2b00      	cmp	r3, #0
341860c2:	d003      	beq.n	341860cc <XSPI_NOR_ExitOPIMode+0x4c>
                                    XSPI_Nor_Ctx[Instance].TransferRate) != MX66UW1G45G_OK)
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
341860c4:	f06f 0304 	mvn.w	r3, #4
341860c8:	60fb      	str	r3, [r7, #12]
341860ca:	e083      	b.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
341860cc:	2300      	movs	r3, #0
341860ce:	723b      	strb	r3, [r7, #8]
    reg[1] = 0;
341860d0:	2300      	movs	r3, #0
341860d2:	727b      	strb	r3, [r7, #9]
    if (MX66UW1G45G_WriteCfg2Register(&hxspi_nor[Instance], XSPI_Nor_Ctx[Instance].InterfaceMode,
341860d4:	687b      	ldr	r3, [r7, #4]
341860d6:	2264      	movs	r2, #100	@ 0x64
341860d8:	fb02 f303 	mul.w	r3, r2, r3
341860dc:	4a40      	ldr	r2, [pc, #256]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
341860de:	1898      	adds	r0, r3, r2
341860e0:	4940      	ldr	r1, [pc, #256]	@ (341861e4 <XSPI_NOR_ExitOPIMode+0x164>)
341860e2:	687a      	ldr	r2, [r7, #4]
341860e4:	4613      	mov	r3, r2
341860e6:	005b      	lsls	r3, r3, #1
341860e8:	4413      	add	r3, r2
341860ea:	440b      	add	r3, r1
341860ec:	3301      	adds	r3, #1
341860ee:	7819      	ldrb	r1, [r3, #0]
341860f0:	4c3c      	ldr	r4, [pc, #240]	@ (341861e4 <XSPI_NOR_ExitOPIMode+0x164>)
341860f2:	687a      	ldr	r2, [r7, #4]
341860f4:	4613      	mov	r3, r2
341860f6:	005b      	lsls	r3, r3, #1
341860f8:	4413      	add	r3, r2
341860fa:	4423      	add	r3, r4
341860fc:	3302      	adds	r3, #2
341860fe:	781a      	ldrb	r2, [r3, #0]
34186100:	7a3b      	ldrb	r3, [r7, #8]
34186102:	9300      	str	r3, [sp, #0]
34186104:	2300      	movs	r3, #0
34186106:	f011 fce6 	bl	34197ad6 <MX66UW1G45G_WriteCfg2Register>
3418610a:	4603      	mov	r3, r0
3418610c:	2b00      	cmp	r3, #0
3418610e:	d003      	beq.n	34186118 <XSPI_NOR_ExitOPIMode+0x98>
                                       XSPI_Nor_Ctx[Instance].TransferRate, MX66UW1G45G_CR2_REG1_ADDR,
                                       reg[0]) != MX66UW1G45G_OK)
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
34186110:	f06f 0304 	mvn.w	r3, #4
34186114:	60fb      	str	r3, [r7, #12]
34186116:	e05d      	b.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX66UW1G45G_WRITE_REG_MAX_TIME);
34186118:	2028      	movs	r0, #40	@ 0x28
3418611a:	f000 fa05 	bl	34186528 <HAL_Delay>

      if (XSPI_Nor_Ctx[Instance].TransferRate == BSP_XSPI_NOR_DTR_TRANSFER)
3418611e:	4931      	ldr	r1, [pc, #196]	@ (341861e4 <XSPI_NOR_ExitOPIMode+0x164>)
34186120:	687a      	ldr	r2, [r7, #4]
34186122:	4613      	mov	r3, r2
34186124:	005b      	lsls	r3, r3, #1
34186126:	4413      	add	r3, r2
34186128:	440b      	add	r3, r1
3418612a:	3302      	adds	r3, #2
3418612c:	781b      	ldrb	r3, [r3, #0]
3418612e:	2b01      	cmp	r3, #1
34186130:	d120      	bne.n	34186174 <XSPI_NOR_ExitOPIMode+0xf4>
      {
        /* Reconfigure the memory type of the peripheral */
        hxspi_nor[Instance].Init.MemoryType            = HAL_XSPI_MEMTYPE_MICRON;
34186132:	4a2b      	ldr	r2, [pc, #172]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
34186134:	687b      	ldr	r3, [r7, #4]
34186136:	2164      	movs	r1, #100	@ 0x64
34186138:	fb01 f303 	mul.w	r3, r1, r3
3418613c:	4413      	add	r3, r2
3418613e:	330c      	adds	r3, #12
34186140:	2200      	movs	r2, #0
34186142:	601a      	str	r2, [r3, #0]
        hxspi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34186144:	4a26      	ldr	r2, [pc, #152]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
34186146:	687b      	ldr	r3, [r7, #4]
34186148:	2164      	movs	r1, #100	@ 0x64
3418614a:	fb01 f303 	mul.w	r3, r1, r3
3418614e:	4413      	add	r3, r2
34186150:	332c      	adds	r3, #44	@ 0x2c
34186152:	2200      	movs	r2, #0
34186154:	601a      	str	r2, [r3, #0]
        if (HAL_XSPI_Init(&hxspi_nor[Instance]) != HAL_OK)
34186156:	687b      	ldr	r3, [r7, #4]
34186158:	2264      	movs	r2, #100	@ 0x64
3418615a:	fb02 f303 	mul.w	r3, r2, r3
3418615e:	4a20      	ldr	r2, [pc, #128]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
34186160:	4413      	add	r3, r2
34186162:	4618      	mov	r0, r3
34186164:	f010 f95e 	bl	34196424 <HAL_XSPI_Init>
34186168:	4603      	mov	r3, r0
3418616a:	2b00      	cmp	r3, #0
3418616c:	d002      	beq.n	34186174 <XSPI_NOR_ExitOPIMode+0xf4>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
3418616e:	f06f 0303 	mvn.w	r3, #3
34186172:	60fb      	str	r3, [r7, #12]
        }
      }

      if (ret == BSP_ERROR_NONE)
34186174:	68fb      	ldr	r3, [r7, #12]
34186176:	2b00      	cmp	r3, #0
34186178:	d12c      	bne.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
      {
        /* Check Flash busy ? */
        if (MX66UW1G45G_AutoPollingMemReady(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE,
3418617a:	687b      	ldr	r3, [r7, #4]
3418617c:	2264      	movs	r2, #100	@ 0x64
3418617e:	fb02 f303 	mul.w	r3, r2, r3
34186182:	4a17      	ldr	r2, [pc, #92]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
34186184:	4413      	add	r3, r2
34186186:	2200      	movs	r2, #0
34186188:	2100      	movs	r1, #0
3418618a:	4618      	mov	r0, r3
3418618c:	f011 fa14 	bl	341975b8 <MX66UW1G45G_AutoPollingMemReady>
34186190:	4603      	mov	r3, r0
34186192:	2b00      	cmp	r3, #0
34186194:	d003      	beq.n	3418619e <XSPI_NOR_ExitOPIMode+0x11e>
                                             BSP_XSPI_NOR_STR_TRANSFER) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
34186196:	f06f 0304 	mvn.w	r3, #4
3418619a:	60fb      	str	r3, [r7, #12]
3418619c:	e01a      	b.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
        }
        /* Check the configuration has been correctly done */
        else if (MX66UW1G45G_ReadCfg2Register(&hxspi_nor[Instance], BSP_XSPI_NOR_SPI_MODE, BSP_XSPI_NOR_STR_TRANSFER,
3418619e:	687b      	ldr	r3, [r7, #4]
341861a0:	2264      	movs	r2, #100	@ 0x64
341861a2:	fb02 f303 	mul.w	r3, r2, r3
341861a6:	4a0e      	ldr	r2, [pc, #56]	@ (341861e0 <XSPI_NOR_ExitOPIMode+0x160>)
341861a8:	1898      	adds	r0, r3, r2
341861aa:	f107 0308 	add.w	r3, r7, #8
341861ae:	9300      	str	r3, [sp, #0]
341861b0:	2300      	movs	r3, #0
341861b2:	2200      	movs	r2, #0
341861b4:	2100      	movs	r1, #0
341861b6:	f011 fd1f 	bl	34197bf8 <MX66UW1G45G_ReadCfg2Register>
341861ba:	4603      	mov	r3, r0
341861bc:	2b00      	cmp	r3, #0
341861be:	d003      	beq.n	341861c8 <XSPI_NOR_ExitOPIMode+0x148>
                                               MX66UW1G45G_CR2_REG1_ADDR, reg) != MX66UW1G45G_OK)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
341861c0:	f06f 0304 	mvn.w	r3, #4
341861c4:	60fb      	str	r3, [r7, #12]
341861c6:	e005      	b.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
        }
        else if (reg[0] != 0U)
341861c8:	7a3b      	ldrb	r3, [r7, #8]
341861ca:	2b00      	cmp	r3, #0
341861cc:	d002      	beq.n	341861d4 <XSPI_NOR_ExitOPIMode+0x154>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
341861ce:	f06f 0304 	mvn.w	r3, #4
341861d2:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  /* Return BSP status */
  return ret;
341861d4:	68fb      	ldr	r3, [r7, #12]
}
341861d6:	4618      	mov	r0, r3
341861d8:	3714      	adds	r7, #20
341861da:	46bd      	mov	sp, r7
341861dc:	bd90      	pop	{r4, r7, pc}
341861de:	bf00      	nop
341861e0:	341c1224 	.word	0x341c1224
341861e4:	341c1288 	.word	0x341c1288

341861e8 <XSPI_RAM_MspInit>:
  * @brief  Initializes the XSPI MSP.
  * @param  hxspi XSPI handle
  * @retval None
  */
static void XSPI_RAM_MspInit(const XSPI_HandleTypeDef *hxspi)
{
341861e8:	b580      	push	{r7, lr}
341861ea:	b088      	sub	sp, #32
341861ec:	af00      	add	r7, sp, #0
341861ee:	6078      	str	r0, [r7, #4]

  /* hxspi unused argument(s) compilation warning */
  UNUSED(hxspi);

 /* XSPI power enable */
  __HAL_RCC_PWR_CLK_ENABLE();
341861f0:	f44f 2080 	mov.w	r0, #262144	@ 0x40000
341861f4:	f7ff f90e 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  HAL_PWREx_EnableVddIO2();
341861f8:	f006 fb76 	bl	3418c8e8 <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2, PWR_VDDIO_RANGE_1V8);
341861fc:	2101      	movs	r1, #1
341861fe:	2001      	movs	r0, #1
34186200:	f006 fb20 	bl	3418c844 <HAL_PWREx_ConfigVddIORange>

  /* Enable the XSPI memory interface clock */
  XSPI_RAM_CLK_ENABLE();
34186204:	2020      	movs	r0, #32
34186206:	f7ff f91b 	bl	34185440 <LL_AHB5_GRP1_EnableClock>

  /* Reset the XSPI memory interface */
  XSPI_RAM_FORCE_RESET();
3418620a:	2020      	movs	r0, #32
3418620c:	f7ff f92e 	bl	3418546c <LL_AHB5_GRP1_ForceReset>
  XSPI_RAM_RELEASE_RESET();
34186210:	2020      	movs	r0, #32
34186212:	f7ff f93b 	bl	3418548c <LL_AHB5_GRP1_ReleaseReset>

  /* Enable and reset XSPI I/O Manager */
  __HAL_RCC_XSPIM_CLK_ENABLE();
34186216:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418621a:	f7ff f911 	bl	34185440 <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_XSPIM_FORCE_RESET();
3418621e:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34186222:	f7ff f923 	bl	3418546c <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_XSPIM_RELEASE_RESET();
34186226:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
3418622a:	f7ff f92f 	bl	3418548c <LL_AHB5_GRP1_ReleaseReset>

  /* Enable GPIO clocks */
  XSPI_RAM_CLK_GPIO_CLK_ENABLE();
3418622e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34186232:	f7ff f8ef 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_DQS_GPIO_CLK_ENABLE();
34186236:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3418623a:	f7ff f8eb 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_CS_GPIO_CLK_ENABLE();
3418623e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34186242:	f7ff f8e7 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D0_GPIO_CLK_ENABLE();
34186246:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418624a:	f7ff f8e3 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D1_GPIO_CLK_ENABLE();
3418624e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34186252:	f7ff f8df 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D2_GPIO_CLK_ENABLE();
34186256:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418625a:	f7ff f8db 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D3_GPIO_CLK_ENABLE();
3418625e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34186262:	f7ff f8d7 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D4_GPIO_CLK_ENABLE();
34186266:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418626a:	f7ff f8d3 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D5_GPIO_CLK_ENABLE();
3418626e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34186272:	f7ff f8cf 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D6_GPIO_CLK_ENABLE();
34186276:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
3418627a:	f7ff f8cb 	bl	34185414 <LL_AHB4_GRP1_EnableClock>
  XSPI_RAM_D7_GPIO_CLK_ENABLE();
3418627e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34186282:	f7ff f8c7 	bl	34185414 <LL_AHB4_GRP1_EnableClock>

  /* XSPI CS GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CS_PIN;
34186286:	2301      	movs	r3, #1
34186288:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
3418628a:	2302      	movs	r3, #2
3418628c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
3418628e:	2301      	movs	r3, #1
34186290:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
34186292:	2303      	movs	r3, #3
34186294:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Alternate = XSPI_RAM_CS_PIN_AF;
34186296:	2309      	movs	r3, #9
34186298:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CS_GPIO_PORT, &GPIO_InitStruct);
3418629a:	f107 030c 	add.w	r3, r7, #12
3418629e:	4619      	mov	r1, r3
341862a0:	486a      	ldr	r0, [pc, #424]	@ (3418644c <XSPI_RAM_MspInit+0x264>)
341862a2:	f003 ff4b 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI DQS0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS0_PIN;
341862a6:	2304      	movs	r3, #4
341862a8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS0_PIN_AF;
341862aa:	2309      	movs	r3, #9
341862ac:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341862ae:	2301      	movs	r3, #1
341862b0:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS0_GPIO_PORT, &GPIO_InitStruct);
341862b2:	f107 030c 	add.w	r3, r7, #12
341862b6:	4619      	mov	r1, r3
341862b8:	4864      	ldr	r0, [pc, #400]	@ (3418644c <XSPI_RAM_MspInit+0x264>)
341862ba:	f003 ff3f 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI DQS1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_DQS1_PIN;
341862be:	2308      	movs	r3, #8
341862c0:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_DQS1_PIN_AF;
341862c2:	2309      	movs	r3, #9
341862c4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341862c6:	2301      	movs	r3, #1
341862c8:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_DQS1_GPIO_PORT, &GPIO_InitStruct);
341862ca:	f107 030c 	add.w	r3, r7, #12
341862ce:	4619      	mov	r1, r3
341862d0:	485e      	ldr	r0, [pc, #376]	@ (3418644c <XSPI_RAM_MspInit+0x264>)
341862d2:	f003 ff33 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI CLK GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_CLK_PIN;
341862d6:	2310      	movs	r3, #16
341862d8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341862da:	2301      	movs	r3, #1
341862dc:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = XSPI_RAM_CLK_PIN_AF;
341862de:	2309      	movs	r3, #9
341862e0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_CLK_GPIO_PORT, &GPIO_InitStruct);
341862e2:	f107 030c 	add.w	r3, r7, #12
341862e6:	4619      	mov	r1, r3
341862e8:	4858      	ldr	r0, [pc, #352]	@ (3418644c <XSPI_RAM_MspInit+0x264>)
341862ea:	f003 ff27 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D0 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D0_PIN;
341862ee:	2301      	movs	r3, #1
341862f0:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D0_PIN_AF;
341862f2:	2309      	movs	r3, #9
341862f4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
341862f6:	2301      	movs	r3, #1
341862f8:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(XSPI_RAM_D0_GPIO_PORT, &GPIO_InitStruct);
341862fa:	f107 030c 	add.w	r3, r7, #12
341862fe:	4619      	mov	r1, r3
34186300:	4853      	ldr	r0, [pc, #332]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186302:	f003 ff1b 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D1 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D1_PIN;
34186306:	2302      	movs	r3, #2
34186308:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D1_PIN_AF;
3418630a:	2309      	movs	r3, #9
3418630c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D1_GPIO_PORT, &GPIO_InitStruct);
3418630e:	f107 030c 	add.w	r3, r7, #12
34186312:	4619      	mov	r1, r3
34186314:	484e      	ldr	r0, [pc, #312]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186316:	f003 ff11 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D2 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D2_PIN;
3418631a:	2304      	movs	r3, #4
3418631c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D2_PIN_AF;
3418631e:	2309      	movs	r3, #9
34186320:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D2_GPIO_PORT, &GPIO_InitStruct);
34186322:	f107 030c 	add.w	r3, r7, #12
34186326:	4619      	mov	r1, r3
34186328:	4849      	ldr	r0, [pc, #292]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
3418632a:	f003 ff07 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D3 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D3_PIN;
3418632e:	2308      	movs	r3, #8
34186330:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D3_PIN_AF;
34186332:	2309      	movs	r3, #9
34186334:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D3_GPIO_PORT, &GPIO_InitStruct);
34186336:	f107 030c 	add.w	r3, r7, #12
3418633a:	4619      	mov	r1, r3
3418633c:	4844      	ldr	r0, [pc, #272]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
3418633e:	f003 fefd 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D4 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D4_PIN;
34186342:	2310      	movs	r3, #16
34186344:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D4_PIN_AF;
34186346:	2309      	movs	r3, #9
34186348:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D4_GPIO_PORT, &GPIO_InitStruct);
3418634a:	f107 030c 	add.w	r3, r7, #12
3418634e:	4619      	mov	r1, r3
34186350:	483f      	ldr	r0, [pc, #252]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186352:	f003 fef3 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D5 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D5_PIN;
34186356:	2320      	movs	r3, #32
34186358:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D5_PIN_AF;
3418635a:	2309      	movs	r3, #9
3418635c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D5_GPIO_PORT, &GPIO_InitStruct);
3418635e:	f107 030c 	add.w	r3, r7, #12
34186362:	4619      	mov	r1, r3
34186364:	483a      	ldr	r0, [pc, #232]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186366:	f003 fee9 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D6 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D6_PIN;
3418636a:	2340      	movs	r3, #64	@ 0x40
3418636c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D6_PIN_AF;
3418636e:	2309      	movs	r3, #9
34186370:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D6_GPIO_PORT, &GPIO_InitStruct);
34186372:	f107 030c 	add.w	r3, r7, #12
34186376:	4619      	mov	r1, r3
34186378:	4835      	ldr	r0, [pc, #212]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
3418637a:	f003 fedf 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D7 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D7_PIN;
3418637e:	2380      	movs	r3, #128	@ 0x80
34186380:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D7_PIN_AF;
34186382:	2309      	movs	r3, #9
34186384:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D7_GPIO_PORT, &GPIO_InitStruct);
34186386:	f107 030c 	add.w	r3, r7, #12
3418638a:	4619      	mov	r1, r3
3418638c:	4830      	ldr	r0, [pc, #192]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
3418638e:	f003 fed5 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D8 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D8_PIN;
34186392:	f44f 7380 	mov.w	r3, #256	@ 0x100
34186396:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D8_PIN_AF;
34186398:	2309      	movs	r3, #9
3418639a:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D8_GPIO_PORT, &GPIO_InitStruct);
3418639c:	f107 030c 	add.w	r3, r7, #12
341863a0:	4619      	mov	r1, r3
341863a2:	482b      	ldr	r0, [pc, #172]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
341863a4:	f003 feca 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D9 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D9_PIN;
341863a8:	f44f 7300 	mov.w	r3, #512	@ 0x200
341863ac:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D9_PIN_AF;
341863ae:	2309      	movs	r3, #9
341863b0:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D9_GPIO_PORT, &GPIO_InitStruct);
341863b2:	f107 030c 	add.w	r3, r7, #12
341863b6:	4619      	mov	r1, r3
341863b8:	4825      	ldr	r0, [pc, #148]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
341863ba:	f003 febf 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D10 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D10_PIN;
341863be:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341863c2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D10_PIN_AF;
341863c4:	2309      	movs	r3, #9
341863c6:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D10_GPIO_PORT, &GPIO_InitStruct);
341863c8:	f107 030c 	add.w	r3, r7, #12
341863cc:	4619      	mov	r1, r3
341863ce:	4820      	ldr	r0, [pc, #128]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
341863d0:	f003 feb4 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D11 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D11_PIN;
341863d4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341863d8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D11_PIN_AF;
341863da:	2309      	movs	r3, #9
341863dc:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D11_GPIO_PORT, &GPIO_InitStruct);
341863de:	f107 030c 	add.w	r3, r7, #12
341863e2:	4619      	mov	r1, r3
341863e4:	481a      	ldr	r0, [pc, #104]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
341863e6:	f003 fea9 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D12 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D12_PIN;
341863ea:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
341863ee:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D12_PIN_AF;
341863f0:	2309      	movs	r3, #9
341863f2:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D12_GPIO_PORT, &GPIO_InitStruct);
341863f4:	f107 030c 	add.w	r3, r7, #12
341863f8:	4619      	mov	r1, r3
341863fa:	4815      	ldr	r0, [pc, #84]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
341863fc:	f003 fe9e 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D13 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D13_PIN;
34186400:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34186404:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D13_PIN_AF;
34186406:	2309      	movs	r3, #9
34186408:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D13_GPIO_PORT, &GPIO_InitStruct);
3418640a:	f107 030c 	add.w	r3, r7, #12
3418640e:	4619      	mov	r1, r3
34186410:	480f      	ldr	r0, [pc, #60]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186412:	f003 fe93 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D14 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D14_PIN;
34186416:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3418641a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D14_PIN_AF;
3418641c:	2309      	movs	r3, #9
3418641e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D14_GPIO_PORT, &GPIO_InitStruct);
34186420:	f107 030c 	add.w	r3, r7, #12
34186424:	4619      	mov	r1, r3
34186426:	480a      	ldr	r0, [pc, #40]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
34186428:	f003 fe88 	bl	3418a13c <HAL_GPIO_Init>

  /* XSPI D15 GPIO pin configuration  */
  GPIO_InitStruct.Pin       = XSPI_RAM_D15_PIN;
3418642c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34186430:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Alternate = XSPI_RAM_D15_PIN_AF;
34186432:	2309      	movs	r3, #9
34186434:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(XSPI_RAM_D15_GPIO_PORT, &GPIO_InitStruct);
34186436:	f107 030c 	add.w	r3, r7, #12
3418643a:	4619      	mov	r1, r3
3418643c:	4804      	ldr	r0, [pc, #16]	@ (34186450 <XSPI_RAM_MspInit+0x268>)
3418643e:	f003 fe7d 	bl	3418a13c <HAL_GPIO_Init>
}
34186442:	bf00      	nop
34186444:	3720      	adds	r7, #32
34186446:	46bd      	mov	sp, r7
34186448:	bd80      	pop	{r7, pc}
3418644a:	bf00      	nop
3418644c:	56023800 	.word	0x56023800
34186450:	56023c00 	.word	0x56023c00

34186454 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34186454:	b580      	push	{r7, lr}
34186456:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34186458:	2003      	movs	r0, #3
3418645a:	f000 f9bf 	bl	341867dc <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
3418645e:	f7fd f991 	bl	34183784 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34186462:	200f      	movs	r0, #15
34186464:	f000 f80a 	bl	3418647c <HAL_InitTick>
34186468:	4603      	mov	r3, r0
3418646a:	2b00      	cmp	r3, #0
3418646c:	d001      	beq.n	34186472 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
3418646e:	2301      	movs	r3, #1
34186470:	e002      	b.n	34186478 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34186472:	f7fc fd7b 	bl	34182f6c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34186476:	2300      	movs	r3, #0
}
34186478:	4618      	mov	r0, r3
3418647a:	bd80      	pop	{r7, pc}

3418647c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
3418647c:	b580      	push	{r7, lr}
3418647e:	b082      	sub	sp, #8
34186480:	af00      	add	r7, sp, #0
34186482:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34186484:	4b15      	ldr	r3, [pc, #84]	@ (341864dc <HAL_InitTick+0x60>)
34186486:	781b      	ldrb	r3, [r3, #0]
34186488:	2b00      	cmp	r3, #0
3418648a:	d101      	bne.n	34186490 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
3418648c:	2301      	movs	r3, #1
3418648e:	e021      	b.n	341864d4 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34186490:	4b13      	ldr	r3, [pc, #76]	@ (341864e0 <HAL_InitTick+0x64>)
34186492:	681a      	ldr	r2, [r3, #0]
34186494:	4b11      	ldr	r3, [pc, #68]	@ (341864dc <HAL_InitTick+0x60>)
34186496:	781b      	ldrb	r3, [r3, #0]
34186498:	4619      	mov	r1, r3
3418649a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
3418649e:	fbb3 f3f1 	udiv	r3, r3, r1
341864a2:	fbb2 f3f3 	udiv	r3, r2, r3
341864a6:	4618      	mov	r0, r3
341864a8:	f000 f9ce 	bl	34186848 <HAL_SYSTICK_Config>
341864ac:	4603      	mov	r3, r0
341864ae:	2b00      	cmp	r3, #0
341864b0:	d001      	beq.n	341864b6 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
341864b2:	2301      	movs	r3, #1
341864b4:	e00e      	b.n	341864d4 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
341864b6:	687b      	ldr	r3, [r7, #4]
341864b8:	2b0f      	cmp	r3, #15
341864ba:	d80a      	bhi.n	341864d2 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
341864bc:	2200      	movs	r2, #0
341864be:	6879      	ldr	r1, [r7, #4]
341864c0:	f04f 30ff 	mov.w	r0, #4294967295
341864c4:	f000 f995 	bl	341867f2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
341864c8:	4a06      	ldr	r2, [pc, #24]	@ (341864e4 <HAL_InitTick+0x68>)
341864ca:	687b      	ldr	r3, [r7, #4]
341864cc:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
341864ce:	2300      	movs	r3, #0
341864d0:	e000      	b.n	341864d4 <HAL_InitTick+0x58>
    return HAL_ERROR;
341864d2:	2301      	movs	r3, #1
}
341864d4:	4618      	mov	r0, r3
341864d6:	3708      	adds	r7, #8
341864d8:	46bd      	mov	sp, r7
341864da:	bd80      	pop	{r7, pc}
341864dc:	341c0028 	.word	0x341c0028
341864e0:	341c0020 	.word	0x341c0020
341864e4:	341c0024 	.word	0x341c0024

341864e8 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
341864e8:	b480      	push	{r7}
341864ea:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
341864ec:	4b06      	ldr	r3, [pc, #24]	@ (34186508 <HAL_IncTick+0x20>)
341864ee:	781b      	ldrb	r3, [r3, #0]
341864f0:	461a      	mov	r2, r3
341864f2:	4b06      	ldr	r3, [pc, #24]	@ (3418650c <HAL_IncTick+0x24>)
341864f4:	681b      	ldr	r3, [r3, #0]
341864f6:	4413      	add	r3, r2
341864f8:	4a04      	ldr	r2, [pc, #16]	@ (3418650c <HAL_IncTick+0x24>)
341864fa:	6013      	str	r3, [r2, #0]
}
341864fc:	bf00      	nop
341864fe:	46bd      	mov	sp, r7
34186500:	f85d 7b04 	ldr.w	r7, [sp], #4
34186504:	4770      	bx	lr
34186506:	bf00      	nop
34186508:	341c0028 	.word	0x341c0028
3418650c:	341c12f4 	.word	0x341c12f4

34186510 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34186510:	b480      	push	{r7}
34186512:	af00      	add	r7, sp, #0
  return uwTick;
34186514:	4b03      	ldr	r3, [pc, #12]	@ (34186524 <HAL_GetTick+0x14>)
34186516:	681b      	ldr	r3, [r3, #0]
}
34186518:	4618      	mov	r0, r3
3418651a:	46bd      	mov	sp, r7
3418651c:	f85d 7b04 	ldr.w	r7, [sp], #4
34186520:	4770      	bx	lr
34186522:	bf00      	nop
34186524:	341c12f4 	.word	0x341c12f4

34186528 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
34186528:	b580      	push	{r7, lr}
3418652a:	b084      	sub	sp, #16
3418652c:	af00      	add	r7, sp, #0
3418652e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
34186530:	f7ff ffee 	bl	34186510 <HAL_GetTick>
34186534:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
34186536:	687b      	ldr	r3, [r7, #4]
34186538:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
3418653a:	68fb      	ldr	r3, [r7, #12]
3418653c:	f1b3 3fff 	cmp.w	r3, #4294967295
34186540:	d005      	beq.n	3418654e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
34186542:	4b0a      	ldr	r3, [pc, #40]	@ (3418656c <HAL_Delay+0x44>)
34186544:	781b      	ldrb	r3, [r3, #0]
34186546:	461a      	mov	r2, r3
34186548:	68fb      	ldr	r3, [r7, #12]
3418654a:	4413      	add	r3, r2
3418654c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
3418654e:	bf00      	nop
34186550:	f7ff ffde 	bl	34186510 <HAL_GetTick>
34186554:	4602      	mov	r2, r0
34186556:	68bb      	ldr	r3, [r7, #8]
34186558:	1ad3      	subs	r3, r2, r3
3418655a:	68fa      	ldr	r2, [r7, #12]
3418655c:	429a      	cmp	r2, r3
3418655e:	d8f7      	bhi.n	34186550 <HAL_Delay+0x28>
  {
  }
}
34186560:	bf00      	nop
34186562:	bf00      	nop
34186564:	3710      	adds	r7, #16
34186566:	46bd      	mov	sp, r7
34186568:	bd80      	pop	{r7, pc}
3418656a:	bf00      	nop
3418656c:	341c0028 	.word	0x341c0028

34186570 <HAL_CACHEAXI_Init>:
  * @note   In case HAL_CACHEAXI_Init() returns HAL_BUSY because an invalidation
  *         procedure is ongoing, the application should call again HAL_CACHEAXI_Init()
  *         until it returns HAL_OK to have the CACHEAXI enabled
  */
HAL_StatusTypeDef  HAL_CACHEAXI_Init(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34186570:	b580      	push	{r7, lr}
34186572:	b084      	sub	sp, #16
34186574:	af00      	add	r7, sp, #0
34186576:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the CACHEAXI handle allocation */
  if (hcacheaxi == NULL)
34186578:	687b      	ldr	r3, [r7, #4]
3418657a:	2b00      	cmp	r3, #0
3418657c:	d101      	bne.n	34186582 <HAL_CACHEAXI_Init+0x12>
  {
    return HAL_ERROR;
3418657e:	2301      	movs	r3, #1
34186580:	e013      	b.n	341865aa <HAL_CACHEAXI_Init+0x3a>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34186582:	687b      	ldr	r3, [r7, #4]
34186584:	791b      	ldrb	r3, [r3, #4]
34186586:	b2db      	uxtb	r3, r3
34186588:	2b00      	cmp	r3, #0
3418658a:	d102      	bne.n	34186592 <HAL_CACHEAXI_Init+0x22>

    /* Init the low level hardware */
    hcacheaxi->MspInitCallback(hcacheaxi);
#else
    /* Init the low level hardware */
    HAL_CACHEAXI_MspInit(hcacheaxi);
3418658c:	6878      	ldr	r0, [r7, #4]
3418658e:	f7fb fbe1 	bl	34181d54 <HAL_CACHEAXI_MspInit>
#endif /* USE_HAL_CACHEAXI_REGISTER_CALLBACKS */
  }

  /* Init the error code */
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34186592:	687b      	ldr	r3, [r7, #4]
34186594:	2200      	movs	r2, #0
34186596:	609a      	str	r2, [r3, #8]

  /* Init the CACHEAXI handle state */
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34186598:	687b      	ldr	r3, [r7, #4]
3418659a:	2201      	movs	r2, #1
3418659c:	711a      	strb	r2, [r3, #4]

  /* Enable the selected CACHEAXI peripheral */
  status = HAL_CACHEAXI_Enable(hcacheaxi);
3418659e:	6878      	ldr	r0, [r7, #4]
341865a0:	f000 f807 	bl	341865b2 <HAL_CACHEAXI_Enable>
341865a4:	4603      	mov	r3, r0
341865a6:	73fb      	strb	r3, [r7, #15]

  return status;
341865a8:	7bfb      	ldrb	r3, [r7, #15]
}
341865aa:	4618      	mov	r0, r3
341865ac:	3710      	adds	r7, #16
341865ae:	46bd      	mov	sp, r7
341865b0:	bd80      	pop	{r7, pc}

341865b2 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
341865b2:	b580      	push	{r7, lr}
341865b4:	b084      	sub	sp, #16
341865b6:	af00      	add	r7, sp, #0
341865b8:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
341865ba:	2300      	movs	r3, #0
341865bc:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
341865be:	687b      	ldr	r3, [r7, #4]
341865c0:	2b00      	cmp	r3, #0
341865c2:	d101      	bne.n	341865c8 <HAL_CACHEAXI_Enable+0x16>
  {
    return HAL_ERROR;
341865c4:	2301      	movs	r3, #1
341865c6:	e034      	b.n	34186632 <HAL_CACHEAXI_Enable+0x80>

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
341865c8:	687b      	ldr	r3, [r7, #4]
341865ca:	681b      	ldr	r3, [r3, #0]
341865cc:	685b      	ldr	r3, [r3, #4]
341865ce:	f003 0301 	and.w	r3, r3, #1
341865d2:	2b00      	cmp	r3, #0
341865d4:	d01e      	beq.n	34186614 <HAL_CACHEAXI_Enable+0x62>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
341865d6:	f7ff ff9b 	bl	34186510 <HAL_GetTick>
341865da:	60b8      	str	r0, [r7, #8]

    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
341865dc:	e013      	b.n	34186606 <HAL_CACHEAXI_Enable+0x54>
    {
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
341865de:	f7ff ff97 	bl	34186510 <HAL_GetTick>
341865e2:	4602      	mov	r2, r0
341865e4:	68bb      	ldr	r3, [r7, #8]
341865e6:	1ad3      	subs	r3, r2, r3
341865e8:	2b01      	cmp	r3, #1
341865ea:	d90c      	bls.n	34186606 <HAL_CACHEAXI_Enable+0x54>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
341865ec:	687b      	ldr	r3, [r7, #4]
341865ee:	681b      	ldr	r3, [r3, #0]
341865f0:	685b      	ldr	r3, [r3, #4]
341865f2:	f003 0301 	and.w	r3, r3, #1
341865f6:	2b00      	cmp	r3, #0
341865f8:	d105      	bne.n	34186606 <HAL_CACHEAXI_Enable+0x54>
        {
          /* Update error code */
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
341865fa:	687b      	ldr	r3, [r7, #4]
341865fc:	2210      	movs	r2, #16
341865fe:	609a      	str	r2, [r3, #8]
          /* Return error status */
          status =  HAL_ERROR;
34186600:	2301      	movs	r3, #1
34186602:	73fb      	strb	r3, [r7, #15]
          break;
34186604:	e006      	b.n	34186614 <HAL_CACHEAXI_Enable+0x62>
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34186606:	687b      	ldr	r3, [r7, #4]
34186608:	681b      	ldr	r3, [r3, #0]
3418660a:	685b      	ldr	r3, [r3, #4]
3418660c:	f003 0301 	and.w	r3, r3, #1
34186610:	2b00      	cmp	r3, #0
34186612:	d1e4      	bne.n	341865de <HAL_CACHEAXI_Enable+0x2c>
        }
      }
    }
  }

  if (status == HAL_OK)
34186614:	7bfb      	ldrb	r3, [r7, #15]
34186616:	2b00      	cmp	r3, #0
34186618:	d10a      	bne.n	34186630 <HAL_CACHEAXI_Enable+0x7e>
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
3418661a:	687b      	ldr	r3, [r7, #4]
3418661c:	2200      	movs	r2, #0
3418661e:	609a      	str	r2, [r3, #8]
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34186620:	687b      	ldr	r3, [r7, #4]
34186622:	681b      	ldr	r3, [r3, #0]
34186624:	681a      	ldr	r2, [r3, #0]
34186626:	687b      	ldr	r3, [r7, #4]
34186628:	681b      	ldr	r3, [r3, #0]
3418662a:	f042 0201 	orr.w	r2, r2, #1
3418662e:	601a      	str	r2, [r3, #0]
  }

  return status;
34186630:	7bfb      	ldrb	r3, [r7, #15]
}
34186632:	4618      	mov	r0, r3
34186634:	3710      	adds	r7, #16
34186636:	46bd      	mov	sp, r7
34186638:	bd80      	pop	{r7, pc}
	...

3418663c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3418663c:	b480      	push	{r7}
3418663e:	b085      	sub	sp, #20
34186640:	af00      	add	r7, sp, #0
34186642:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34186644:	687b      	ldr	r3, [r7, #4]
34186646:	f003 0307 	and.w	r3, r3, #7
3418664a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
3418664c:	4b0c      	ldr	r3, [pc, #48]	@ (34186680 <__NVIC_SetPriorityGrouping+0x44>)
3418664e:	68db      	ldr	r3, [r3, #12]
34186650:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34186652:	68ba      	ldr	r2, [r7, #8]
34186654:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34186658:	4013      	ands	r3, r2
3418665a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3418665c:	68fb      	ldr	r3, [r7, #12]
3418665e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34186660:	68bb      	ldr	r3, [r7, #8]
34186662:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34186664:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34186668:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
3418666c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
3418666e:	4a04      	ldr	r2, [pc, #16]	@ (34186680 <__NVIC_SetPriorityGrouping+0x44>)
34186670:	68bb      	ldr	r3, [r7, #8]
34186672:	60d3      	str	r3, [r2, #12]
}
34186674:	bf00      	nop
34186676:	3714      	adds	r7, #20
34186678:	46bd      	mov	sp, r7
3418667a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418667e:	4770      	bx	lr
34186680:	e000ed00 	.word	0xe000ed00

34186684 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34186684:	b480      	push	{r7}
34186686:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34186688:	4b04      	ldr	r3, [pc, #16]	@ (3418669c <__NVIC_GetPriorityGrouping+0x18>)
3418668a:	68db      	ldr	r3, [r3, #12]
3418668c:	0a1b      	lsrs	r3, r3, #8
3418668e:	f003 0307 	and.w	r3, r3, #7
}
34186692:	4618      	mov	r0, r3
34186694:	46bd      	mov	sp, r7
34186696:	f85d 7b04 	ldr.w	r7, [sp], #4
3418669a:	4770      	bx	lr
3418669c:	e000ed00 	.word	0xe000ed00

341866a0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
341866a0:	b480      	push	{r7}
341866a2:	b083      	sub	sp, #12
341866a4:	af00      	add	r7, sp, #0
341866a6:	4603      	mov	r3, r0
341866a8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341866aa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341866ae:	2b00      	cmp	r3, #0
341866b0:	db0b      	blt.n	341866ca <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
341866b2:	88fb      	ldrh	r3, [r7, #6]
341866b4:	f003 021f 	and.w	r2, r3, #31
341866b8:	4907      	ldr	r1, [pc, #28]	@ (341866d8 <__NVIC_EnableIRQ+0x38>)
341866ba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341866be:	095b      	lsrs	r3, r3, #5
341866c0:	2001      	movs	r0, #1
341866c2:	fa00 f202 	lsl.w	r2, r0, r2
341866c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
341866ca:	bf00      	nop
341866cc:	370c      	adds	r7, #12
341866ce:	46bd      	mov	sp, r7
341866d0:	f85d 7b04 	ldr.w	r7, [sp], #4
341866d4:	4770      	bx	lr
341866d6:	bf00      	nop
341866d8:	e000e100 	.word	0xe000e100

341866dc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
341866dc:	b480      	push	{r7}
341866de:	b083      	sub	sp, #12
341866e0:	af00      	add	r7, sp, #0
341866e2:	4603      	mov	r3, r0
341866e4:	6039      	str	r1, [r7, #0]
341866e6:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
341866e8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341866ec:	2b00      	cmp	r3, #0
341866ee:	db0a      	blt.n	34186706 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
341866f0:	683b      	ldr	r3, [r7, #0]
341866f2:	b2da      	uxtb	r2, r3
341866f4:	490c      	ldr	r1, [pc, #48]	@ (34186728 <__NVIC_SetPriority+0x4c>)
341866f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
341866fa:	0112      	lsls	r2, r2, #4
341866fc:	b2d2      	uxtb	r2, r2
341866fe:	440b      	add	r3, r1
34186700:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34186704:	e00a      	b.n	3418671c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34186706:	683b      	ldr	r3, [r7, #0]
34186708:	b2da      	uxtb	r2, r3
3418670a:	4908      	ldr	r1, [pc, #32]	@ (3418672c <__NVIC_SetPriority+0x50>)
3418670c:	88fb      	ldrh	r3, [r7, #6]
3418670e:	f003 030f 	and.w	r3, r3, #15
34186712:	3b04      	subs	r3, #4
34186714:	0112      	lsls	r2, r2, #4
34186716:	b2d2      	uxtb	r2, r2
34186718:	440b      	add	r3, r1
3418671a:	761a      	strb	r2, [r3, #24]
}
3418671c:	bf00      	nop
3418671e:	370c      	adds	r7, #12
34186720:	46bd      	mov	sp, r7
34186722:	f85d 7b04 	ldr.w	r7, [sp], #4
34186726:	4770      	bx	lr
34186728:	e000e100 	.word	0xe000e100
3418672c:	e000ed00 	.word	0xe000ed00

34186730 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34186730:	b480      	push	{r7}
34186732:	b089      	sub	sp, #36	@ 0x24
34186734:	af00      	add	r7, sp, #0
34186736:	60f8      	str	r0, [r7, #12]
34186738:	60b9      	str	r1, [r7, #8]
3418673a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
3418673c:	68fb      	ldr	r3, [r7, #12]
3418673e:	f003 0307 	and.w	r3, r3, #7
34186742:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34186744:	69fb      	ldr	r3, [r7, #28]
34186746:	f1c3 0307 	rsb	r3, r3, #7
3418674a:	2b04      	cmp	r3, #4
3418674c:	bf28      	it	cs
3418674e:	2304      	movcs	r3, #4
34186750:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34186752:	69fb      	ldr	r3, [r7, #28]
34186754:	3304      	adds	r3, #4
34186756:	2b06      	cmp	r3, #6
34186758:	d902      	bls.n	34186760 <NVIC_EncodePriority+0x30>
3418675a:	69fb      	ldr	r3, [r7, #28]
3418675c:	3b03      	subs	r3, #3
3418675e:	e000      	b.n	34186762 <NVIC_EncodePriority+0x32>
34186760:	2300      	movs	r3, #0
34186762:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34186764:	f04f 32ff 	mov.w	r2, #4294967295
34186768:	69bb      	ldr	r3, [r7, #24]
3418676a:	fa02 f303 	lsl.w	r3, r2, r3
3418676e:	43da      	mvns	r2, r3
34186770:	68bb      	ldr	r3, [r7, #8]
34186772:	401a      	ands	r2, r3
34186774:	697b      	ldr	r3, [r7, #20]
34186776:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34186778:	f04f 31ff 	mov.w	r1, #4294967295
3418677c:	697b      	ldr	r3, [r7, #20]
3418677e:	fa01 f303 	lsl.w	r3, r1, r3
34186782:	43d9      	mvns	r1, r3
34186784:	687b      	ldr	r3, [r7, #4]
34186786:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34186788:	4313      	orrs	r3, r2
         );
}
3418678a:	4618      	mov	r0, r3
3418678c:	3724      	adds	r7, #36	@ 0x24
3418678e:	46bd      	mov	sp, r7
34186790:	f85d 7b04 	ldr.w	r7, [sp], #4
34186794:	4770      	bx	lr
	...

34186798 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34186798:	b580      	push	{r7, lr}
3418679a:	b082      	sub	sp, #8
3418679c:	af00      	add	r7, sp, #0
3418679e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
341867a0:	687b      	ldr	r3, [r7, #4]
341867a2:	3b01      	subs	r3, #1
341867a4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341867a8:	d301      	bcc.n	341867ae <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
341867aa:	2301      	movs	r3, #1
341867ac:	e00f      	b.n	341867ce <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
341867ae:	4a0a      	ldr	r2, [pc, #40]	@ (341867d8 <SysTick_Config+0x40>)
341867b0:	687b      	ldr	r3, [r7, #4]
341867b2:	3b01      	subs	r3, #1
341867b4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
341867b6:	210f      	movs	r1, #15
341867b8:	f04f 30ff 	mov.w	r0, #4294967295
341867bc:	f7ff ff8e 	bl	341866dc <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
341867c0:	4b05      	ldr	r3, [pc, #20]	@ (341867d8 <SysTick_Config+0x40>)
341867c2:	2200      	movs	r2, #0
341867c4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
341867c6:	4b04      	ldr	r3, [pc, #16]	@ (341867d8 <SysTick_Config+0x40>)
341867c8:	2207      	movs	r2, #7
341867ca:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
341867cc:	2300      	movs	r3, #0
}
341867ce:	4618      	mov	r0, r3
341867d0:	3708      	adds	r7, #8
341867d2:	46bd      	mov	sp, r7
341867d4:	bd80      	pop	{r7, pc}
341867d6:	bf00      	nop
341867d8:	e000e010 	.word	0xe000e010

341867dc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
341867dc:	b580      	push	{r7, lr}
341867de:	b082      	sub	sp, #8
341867e0:	af00      	add	r7, sp, #0
341867e2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
341867e4:	6878      	ldr	r0, [r7, #4]
341867e6:	f7ff ff29 	bl	3418663c <__NVIC_SetPriorityGrouping>
}
341867ea:	bf00      	nop
341867ec:	3708      	adds	r7, #8
341867ee:	46bd      	mov	sp, r7
341867f0:	bd80      	pop	{r7, pc}

341867f2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
341867f2:	b580      	push	{r7, lr}
341867f4:	b086      	sub	sp, #24
341867f6:	af00      	add	r7, sp, #0
341867f8:	4603      	mov	r3, r0
341867fa:	60b9      	str	r1, [r7, #8]
341867fc:	607a      	str	r2, [r7, #4]
341867fe:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34186800:	f7ff ff40 	bl	34186684 <__NVIC_GetPriorityGrouping>
34186804:	4603      	mov	r3, r0
34186806:	f003 0307 	and.w	r3, r3, #7
3418680a:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
3418680c:	687a      	ldr	r2, [r7, #4]
3418680e:	68b9      	ldr	r1, [r7, #8]
34186810:	6978      	ldr	r0, [r7, #20]
34186812:	f7ff ff8d 	bl	34186730 <NVIC_EncodePriority>
34186816:	4602      	mov	r2, r0
34186818:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3418681c:	4611      	mov	r1, r2
3418681e:	4618      	mov	r0, r3
34186820:	f7ff ff5c 	bl	341866dc <__NVIC_SetPriority>
}
34186824:	bf00      	nop
34186826:	3718      	adds	r7, #24
34186828:	46bd      	mov	sp, r7
3418682a:	bd80      	pop	{r7, pc}

3418682c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
3418682c:	b580      	push	{r7, lr}
3418682e:	b082      	sub	sp, #8
34186830:	af00      	add	r7, sp, #0
34186832:	4603      	mov	r3, r0
34186834:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34186836:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3418683a:	4618      	mov	r0, r3
3418683c:	f7ff ff30 	bl	341866a0 <__NVIC_EnableIRQ>
}
34186840:	bf00      	nop
34186842:	3708      	adds	r7, #8
34186844:	46bd      	mov	sp, r7
34186846:	bd80      	pop	{r7, pc}

34186848 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34186848:	b580      	push	{r7, lr}
3418684a:	b082      	sub	sp, #8
3418684c:	af00      	add	r7, sp, #0
3418684e:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34186850:	6878      	ldr	r0, [r7, #4]
34186852:	f7ff ffa1 	bl	34186798 <SysTick_Config>
34186856:	4603      	mov	r3, r0
}
34186858:	4618      	mov	r0, r3
3418685a:	3708      	adds	r7, #8
3418685c:	46bd      	mov	sp, r7
3418685e:	bd80      	pop	{r7, pc}

34186860 <HAL_DCMIPP_Init>:
  * @brief  Initialize the selected HAL DCMIPP handle and associate a DCMIPP peripheral instance.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_Init(DCMIPP_HandleTypeDef *hdcmipp)
{
34186860:	b580      	push	{r7, lr}
34186862:	b084      	sub	sp, #16
34186864:	af00      	add	r7, sp, #0
34186866:	6078      	str	r0, [r7, #4]
  uint32_t pipe_index;

  /* Check pointer validity */
  if (hdcmipp == NULL)
34186868:	687b      	ldr	r3, [r7, #4]
3418686a:	2b00      	cmp	r3, #0
3418686c:	d101      	bne.n	34186872 <HAL_DCMIPP_Init+0x12>
  {
    return HAL_ERROR;
3418686e:	2301      	movs	r3, #1
34186870:	e020      	b.n	341868b4 <HAL_DCMIPP_Init+0x54>
  }

  /* Check function parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));

  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34186872:	687b      	ldr	r3, [r7, #4]
34186874:	791b      	ldrb	r3, [r3, #4]
34186876:	b2db      	uxtb	r3, r3
34186878:	2b00      	cmp	r3, #0
3418687a:	d102      	bne.n	34186882 <HAL_DCMIPP_Init+0x22>
    }
    /* Initialize the low level hardware (MSP) */
    hdcmipp->MspInitCallback(hdcmipp);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMIPP_MspInit(hdcmipp);
3418687c:	6878      	ldr	r0, [r7, #4]
3418687e:	f7fb fb61 	bl	34181f44 <HAL_DCMIPP_MspInit>
#endif /* (USE_HAL_DCMIPP_REGISTER_CALLBACKS) */
  }

  /* Change the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34186882:	687b      	ldr	r3, [r7, #4]
34186884:	2203      	movs	r2, #3
34186886:	711a      	strb	r2, [r3, #4]

  /* Reset DCMIPP Pipe state */
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
34186888:	2300      	movs	r3, #0
3418688a:	60fb      	str	r3, [r7, #12]
3418688c:	e008      	b.n	341868a0 <HAL_DCMIPP_Init+0x40>
  {
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
3418688e:	687a      	ldr	r2, [r7, #4]
34186890:	68fb      	ldr	r3, [r7, #12]
34186892:	4413      	add	r3, r2
34186894:	3305      	adds	r3, #5
34186896:	2200      	movs	r2, #0
34186898:	701a      	strb	r2, [r3, #0]
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
3418689a:	68fb      	ldr	r3, [r7, #12]
3418689c:	3301      	adds	r3, #1
3418689e:	60fb      	str	r3, [r7, #12]
341868a0:	68fb      	ldr	r3, [r7, #12]
341868a2:	2b02      	cmp	r3, #2
341868a4:	d9f3      	bls.n	3418688e <HAL_DCMIPP_Init+0x2e>
  }

  /* Update error code */
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
341868a6:	687b      	ldr	r3, [r7, #4]
341868a8:	2200      	movs	r2, #0
341868aa:	609a      	str	r2, [r3, #8]

  /* Update the DCMIPP state*/
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
341868ac:	687b      	ldr	r3, [r7, #4]
341868ae:	2201      	movs	r2, #1
341868b0:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
341868b2:	2300      	movs	r3, #0
}
341868b4:	4618      	mov	r0, r3
341868b6:	3710      	adds	r7, #16
341868b8:	46bd      	mov	sp, r7
341868ba:	bd80      	pop	{r7, pc}

341868bc <HAL_DCMIPP_CSI_SetConfig>:
  *                     configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetConfig(const DCMIPP_HandleTypeDef *hdcmipp,
                                           const DCMIPP_CSI_ConfTypeDef *pCSI_Config)
{
341868bc:	b580      	push	{r7, lr}
341868be:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
341868c2:	af00      	add	r7, sp, #0
341868c4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341868c8:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
341868cc:	6018      	str	r0, [r3, #0]
341868ce:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341868d2:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341868d6:	6019      	str	r1, [r3, #0]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
341868d8:	4ba8      	ldr	r3, [pc, #672]	@ (34186b7c <HAL_DCMIPP_CSI_SetConfig+0x2c0>)
341868da:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204

  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
341868de:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341868e2:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
341868e6:	4aa6      	ldr	r2, [pc, #664]	@ (34186b80 <HAL_DCMIPP_CSI_SetConfig+0x2c4>)
341868e8:	4618      	mov	r0, r3
341868ea:	4611      	mov	r1, r2
341868ec:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
341868f0:	461a      	mov	r2, r3
341868f2:	f01e fe78 	bl	341a55e6 <memcpy>
    { 0x48U, 451U },  /* HAL_CSI_BT_2450 */
    { 0x49U, 460U },  /* HAL_CSI_BT_2500 */
  };

  /* Check parameters */
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
341868f6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341868fa:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
341868fe:	681b      	ldr	r3, [r3, #0]
34186900:	2b00      	cmp	r3, #0
34186902:	d006      	beq.n	34186912 <HAL_DCMIPP_CSI_SetConfig+0x56>
34186904:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186908:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418690c:	681b      	ldr	r3, [r3, #0]
3418690e:	2b00      	cmp	r3, #0
34186910:	d101      	bne.n	34186916 <HAL_DCMIPP_CSI_SetConfig+0x5a>
  {
    return HAL_ERROR;
34186912:	2301      	movs	r3, #1
34186914:	e12c      	b.n	34186b70 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));

  /* Ensure the CSI is disabled */
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34186916:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418691a:	681b      	ldr	r3, [r3, #0]
3418691c:	f023 0201 	bic.w	r2, r3, #1
34186920:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186924:	601a      	str	r2, [r3, #0]

  /* Configure the Lane Merger */
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34186926:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418692a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418692e:	681b      	ldr	r3, [r3, #0]
34186930:	685b      	ldr	r3, [r3, #4]
34186932:	2b01      	cmp	r3, #1
34186934:	d10b      	bne.n	3418694e <HAL_DCMIPP_CSI_SetConfig+0x92>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34186936:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3418693a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3418693e:	681b      	ldr	r3, [r3, #0]
34186940:	681b      	ldr	r3, [r3, #0]
34186942:	f443 1204 	orr.w	r2, r3, #2162688	@ 0x210000
34186946:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418694a:	671a      	str	r2, [r3, #112]	@ 0x70
3418694c:	e015      	b.n	3418697a <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
3418694e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186952:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186956:	681b      	ldr	r3, [r3, #0]
34186958:	685b      	ldr	r3, [r3, #4]
3418695a:	2b02      	cmp	r3, #2
3418695c:	d10b      	bne.n	34186976 <HAL_DCMIPP_CSI_SetConfig+0xba>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
3418695e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186962:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186966:	681b      	ldr	r3, [r3, #0]
34186968:	681b      	ldr	r3, [r3, #0]
3418696a:	f443 1290 	orr.w	r2, r3, #1179648	@ 0x120000
3418696e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186972:	671a      	str	r2, [r3, #112]	@ 0x70
34186974:	e001      	b.n	3418697a <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else
  {
    return HAL_ERROR;
34186976:	2301      	movs	r3, #1
34186978:	e0fa      	b.n	34186b70 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  }

  /* Enable the CSI */
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
3418697a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418697e:	681b      	ldr	r3, [r3, #0]
34186980:	f043 0201 	orr.w	r2, r3, #1
34186984:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186988:	601a      	str	r2, [r3, #0]

  /* Enable some interrupts, not related to virtual channels - all error cases */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
3418698a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3418698e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34186992:	f043 43b0 	orr.w	r3, r3, #1476395008	@ 0x58000000
34186996:	f443 1304 	orr.w	r3, r3, #2162688	@ 0x210000
3418699a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3418699e:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
                             DCMIPP_CSI_IT_SPKTERR | DCMIPP_CSI_IT_IDERR | \
                             DCMIPP_CSI_IT_SPKT);

  /* Enable D-PHY Interrupts */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
341869a2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341869a6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341869aa:	681b      	ldr	r3, [r3, #0]
341869ac:	681b      	ldr	r3, [r3, #0]
341869ae:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341869b2:	d11d      	bne.n	341869f0 <HAL_DCMIPP_CSI_SetConfig+0x134>
  {
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
341869b4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
341869b8:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
341869bc:	681b      	ldr	r3, [r3, #0]
341869be:	685b      	ldr	r3, [r3, #4]
341869c0:	2b01      	cmp	r3, #1
341869c2:	d10a      	bne.n	341869da <HAL_DCMIPP_CSI_SetConfig+0x11e>
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
341869c4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341869c8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341869cc:	f043 021f 	orr.w	r2, r3, #31
341869d0:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341869d4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
341869d8:	e016      	b.n	34186a08 <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_EESCDL0 | DCMIPP_CSI_IT_ESYNCESCDL0 |
                                      DCMIPP_CSI_IT_ECTRLDL0);
    }
    else
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
341869da:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341869de:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341869e2:	f443 52f8 	orr.w	r2, r3, #7936	@ 0x1f00
341869e6:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341869ea:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
341869ee:	e00b      	b.n	34186a08 <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_ECTRLDL1);
    }
  }
  else
  {
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
341869f0:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
341869f4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
341869f8:	f443 53f8 	orr.w	r3, r3, #7936	@ 0x1f00
341869fc:	f043 031f 	orr.w	r3, r3, #31
34186a00:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186a04:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                    DCMIPP_CSI_IT_ECTRLDL0);
  }

  /* Start D-PHY Configuration */
  /* Stop the D-PHY */
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34186a08:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186a0c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186a10:	681b      	ldr	r3, [r3, #0]
34186a12:	f023 0302 	bic.w	r3, r3, #2
34186a16:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186a1a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34186a1e:	6013      	str	r3, [r2, #0]

  /* Get the D-PHY enabledb but with all lanes disabled */
  CLEAR_REG(csi_instance-> PCR);
34186a20:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186a24:	2200      	movs	r2, #0
34186a26:	605a      	str	r2, [r3, #4]

  /* Set the testclk (clock enable) on during 15ns */
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34186a28:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186a2c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186a30:	691b      	ldr	r3, [r3, #16]
34186a32:	f043 0301 	orr.w	r3, r3, #1
34186a36:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186a3a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34186a3e:	6113      	str	r3, [r2, #16]

  HAL_Delay(1);
34186a40:	2001      	movs	r0, #1
34186a42:	f7ff fd71 	bl	34186528 <HAL_Delay>

  CLEAR_REG(csi_instance->PTCR0);
34186a46:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186a4a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186a4e:	461a      	mov	r2, r3
34186a50:	2300      	movs	r3, #0
34186a52:	6113      	str	r3, [r2, #16]

  /* Set hsfreqrange */
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34186a54:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186a58:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186a5c:	689b      	ldr	r3, [r3, #8]
34186a5e:	f423 42fe 	bic.w	r2, r3, #32512	@ 0x7f00
34186a62:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186a66:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186a6a:	681b      	ldr	r3, [r3, #0]
34186a6c:	6899      	ldr	r1, [r3, #8]
34186a6e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186a72:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34186a76:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
34186a7a:	021b      	lsls	r3, r3, #8
34186a7c:	4313      	orrs	r3, r2
34186a7e:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34186a82:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186a86:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34186a8a:	6093      	str	r3, [r2, #8]
             (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos));

  /* set reg @08 deskew_polarity_rw 1'b1 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34186a8c:	2338      	movs	r3, #56	@ 0x38
34186a8e:	2208      	movs	r2, #8
34186a90:	2100      	movs	r1, #0
34186a92:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34186a96:	f002 fe00 	bl	3418969a <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
  /* This is because 13<= cfgclkfreqrange[5:0]<=38 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34186a9a:	2311      	movs	r3, #17
34186a9c:	22e4      	movs	r2, #228	@ 0xe4
34186a9e:	2100      	movs	r1, #0
34186aa0:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34186aa4:	f002 fdf9 	bl	3418969a <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xe3 & reg @0xe2 value DLL target oscilation freq */
  /* Based on the table page 77, osc_freq_target */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34186aa8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186aac:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186ab0:	681b      	ldr	r3, [r3, #0]
34186ab2:	689b      	ldr	r3, [r3, #8]
34186ab4:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34186ab8:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34186abc:	00db      	lsls	r3, r3, #3
34186abe:	4413      	add	r3, r2
34186ac0:	685b      	ldr	r3, [r3, #4]
34186ac2:	0a1b      	lsrs	r3, r3, #8
34186ac4:	22e3      	movs	r2, #227	@ 0xe3
34186ac6:	2100      	movs	r1, #0
34186ac8:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34186acc:	f002 fde5 	bl	3418969a <DCMIPP_CSI_WritePHYReg>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34186ad0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186ad4:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186ad8:	681b      	ldr	r3, [r3, #0]
34186ada:	689b      	ldr	r3, [r3, #8]
34186adc:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34186ae0:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34186ae4:	00db      	lsls	r3, r3, #3
34186ae6:	4413      	add	r3, r2
34186ae8:	685b      	ldr	r3, [r3, #4]
34186aea:	b2db      	uxtb	r3, r3
34186aec:	22e3      	movs	r2, #227	@ 0xe3
34186aee:	2100      	movs	r1, #0
34186af0:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34186af4:	f002 fdd1 	bl	3418969a <DCMIPP_CSI_WritePHYReg>

  /* set basedir_0 to RX DLD 0 RX, 1 TX. Synopsys 1 RX 0 TX  + freq range */
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34186af8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186afc:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186b00:	681b      	ldr	r3, [r3, #0]
34186b02:	689a      	ldr	r2, [r3, #8]
34186b04:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186b08:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34186b0c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
34186b10:	021b      	lsls	r3, r3, #8
34186b12:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34186b16:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34186b1a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186b1e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34186b22:	6093      	str	r3, [r2, #8]
            (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos) | CSI_PFCR_DLD);

  /* Enable the D-PHY_RX lane(s) etc */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34186b24:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34186b28:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34186b2c:	681b      	ldr	r3, [r3, #0]
34186b2e:	681b      	ldr	r3, [r3, #0]
34186b30:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34186b34:	d104      	bne.n	34186b40 <HAL_DCMIPP_CSI_SetConfig+0x284>
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34186b36:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186b3a:	2207      	movs	r2, #7
34186b3c:	605a      	str	r2, [r3, #4]
34186b3e:	e003      	b.n	34186b48 <HAL_DCMIPP_CSI_SetConfig+0x28c>
  }
  else
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34186b40:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186b44:	220f      	movs	r2, #15
34186b46:	605a      	str	r2, [r3, #4]
  }


  /* Enable PHY, out of reset */
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34186b48:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186b4c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186b50:	681b      	ldr	r3, [r3, #0]
34186b52:	f043 0302 	orr.w	r3, r3, #2
34186b56:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34186b5a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34186b5e:	6013      	str	r3, [r2, #0]

  /* Remove the force */
  CLEAR_REG(csi_instance->PMCR);
34186b60:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34186b64:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34186b68:	461a      	mov	r2, r3
34186b6a:	2300      	movs	r3, #0
34186b6c:	6053      	str	r3, [r2, #4]

  return HAL_OK;
34186b6e:	2300      	movs	r3, #0

}
34186b70:	4618      	mov	r0, r3
34186b72:	f507 7702 	add.w	r7, r7, #520	@ 0x208
34186b76:	46bd      	mov	sp, r7
34186b78:	bd80      	pop	{r7, pc}
34186b7a:	bf00      	nop
34186b7c:	58006000 	.word	0x58006000
34186b80:	341a71a4 	.word	0x341a71a4

34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
  *                         the CSI Pipe configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CSI_PIPE_ConfTypeDef *pCSI_PipeConfig)
{
34186b84:	b480      	push	{r7}
34186b86:	b087      	sub	sp, #28
34186b88:	af00      	add	r7, sp, #0
34186b8a:	60f8      	str	r0, [r7, #12]
34186b8c:	60b9      	str	r1, [r7, #8]
34186b8e:	607a      	str	r2, [r7, #4]
  uint32_t pxfscr_reg = 0;
34186b90:	2300      	movs	r3, #0
34186b92:	617b      	str	r3, [r7, #20]
  HAL_DCMIPP_StateTypeDef state;

  /* Check the DCMIPP peripheral handle parameter and pCSI_Config parameter */
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34186b94:	68fb      	ldr	r3, [r7, #12]
34186b96:	2b00      	cmp	r3, #0
34186b98:	d002      	beq.n	34186ba0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
34186b9a:	687b      	ldr	r3, [r7, #4]
34186b9c:	2b00      	cmp	r3, #0
34186b9e:	d101      	bne.n	34186ba4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x20>
  {
    return HAL_ERROR;
34186ba0:	2301      	movs	r3, #1
34186ba2:	e087      	b.n	34186cb4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
  /* Check the parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

  if (Pipe != DCMIPP_PIPE2)
34186ba4:	68bb      	ldr	r3, [r7, #8]
34186ba6:	2b02      	cmp	r3, #2
34186ba8:	d003      	beq.n	34186bb2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2e>
  {
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34186baa:	687b      	ldr	r3, [r7, #4]
34186bac:	681b      	ldr	r3, [r3, #0]
34186bae:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
  {
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
  }

  state = hdcmipp->State;
34186bb2:	68fb      	ldr	r3, [r7, #12]
34186bb4:	791b      	ldrb	r3, [r3, #4]
34186bb6:	74fb      	strb	r3, [r7, #19]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
34186bb8:	7cfb      	ldrb	r3, [r7, #19]
34186bba:	2b01      	cmp	r3, #1
34186bbc:	d002      	beq.n	34186bc4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x40>
34186bbe:	7cfb      	ldrb	r3, [r7, #19]
34186bc0:	2b02      	cmp	r3, #2
34186bc2:	d173      	bne.n	34186cac <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
  {
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34186bc4:	687b      	ldr	r3, [r7, #4]
34186bc6:	681b      	ldr	r3, [r3, #0]
34186bc8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34186bcc:	d004      	beq.n	34186bd8 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x54>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34186bce:	687b      	ldr	r3, [r7, #4]
34186bd0:	681b      	ldr	r3, [r3, #0]
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34186bd2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34186bd6:	d104      	bne.n	34186be2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34186bd8:	68bb      	ldr	r3, [r7, #8]
34186bda:	2b00      	cmp	r3, #0
34186bdc:	d001      	beq.n	34186be2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
    {
      return HAL_ERROR;
34186bde:	2301      	movs	r3, #1
34186be0:	e068      	b.n	34186cb4 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
    }

    /* Add Data Type Mode for the selected Pipe except Pipe2 */
    if (Pipe != DCMIPP_PIPE2)
34186be2:	68bb      	ldr	r3, [r7, #8]
34186be4:	2b02      	cmp	r3, #2
34186be6:	d004      	beq.n	34186bf2 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x6e>
    {
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeMode);
34186be8:	687b      	ldr	r3, [r7, #4]
34186bea:	681b      	ldr	r3, [r3, #0]
34186bec:	697a      	ldr	r2, [r7, #20]
34186bee:	4313      	orrs	r3, r2
34186bf0:	617b      	str	r3, [r7, #20]
    }

    if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34186bf2:	687b      	ldr	r3, [r7, #4]
34186bf4:	681b      	ldr	r3, [r3, #0]
34186bf6:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34186bfa:	d004      	beq.n	34186c06 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
    {
      /* Add Data Type IDA for the selected Pipe */
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34186bfc:	687b      	ldr	r3, [r7, #4]
34186bfe:	685b      	ldr	r3, [r3, #4]
34186c00:	697a      	ldr	r2, [r7, #20]
34186c02:	4313      	orrs	r3, r2
34186c04:	617b      	str	r3, [r7, #20]
    }

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34186c06:	687b      	ldr	r3, [r7, #4]
34186c08:	681b      	ldr	r3, [r3, #0]
34186c0a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34186c0e:	d004      	beq.n	34186c1a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34186c10:	687b      	ldr	r3, [r7, #4]
34186c12:	681b      	ldr	r3, [r3, #0]
34186c14:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34186c18:	d108      	bne.n	34186c2c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
    {
      if (Pipe != DCMIPP_PIPE2)
34186c1a:	68bb      	ldr	r3, [r7, #8]
34186c1c:	2b02      	cmp	r3, #2
34186c1e:	d005      	beq.n	34186c2c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
      {
        /* Add Data Type IDB for the selected Pipe except Pipe2 */
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34186c20:	687b      	ldr	r3, [r7, #4]
34186c22:	689b      	ldr	r3, [r3, #8]
34186c24:	021b      	lsls	r3, r3, #8
34186c26:	697a      	ldr	r2, [r7, #20]
34186c28:	4313      	orrs	r3, r2
34186c2a:	617b      	str	r3, [r7, #20]
      }
    }

    if (Pipe == DCMIPP_PIPE0)
34186c2c:	68bb      	ldr	r3, [r7, #8]
34186c2e:	2b00      	cmp	r3, #0
34186c30:	d10c      	bne.n	34186c4c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc8>
    {
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
34186c32:	68fb      	ldr	r3, [r7, #12]
34186c34:	681b      	ldr	r3, [r3, #0]
34186c36:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34186c3a:	4b21      	ldr	r3, [pc, #132]	@ (34186cc0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34186c3c:	4013      	ands	r3, r2
34186c3e:	68fa      	ldr	r2, [r7, #12]
34186c40:	6812      	ldr	r2, [r2, #0]
34186c42:	6979      	ldr	r1, [r7, #20]
34186c44:	430b      	orrs	r3, r1
34186c46:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
34186c4a:	e01b      	b.n	34186c84 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                 DCMIPP_P0FSCR_DTIDB, pxfscr_reg);
    }
    else if (Pipe == DCMIPP_PIPE1)
34186c4c:	68bb      	ldr	r3, [r7, #8]
34186c4e:	2b01      	cmp	r3, #1
34186c50:	d10c      	bne.n	34186c6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe8>
    {
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34186c52:	68fb      	ldr	r3, [r7, #12]
34186c54:	681b      	ldr	r3, [r3, #0]
34186c56:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34186c5a:	4b19      	ldr	r3, [pc, #100]	@ (34186cc0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34186c5c:	4013      	ands	r3, r2
34186c5e:	68fa      	ldr	r2, [r7, #12]
34186c60:	6812      	ldr	r2, [r2, #0]
34186c62:	6979      	ldr	r1, [r7, #20]
34186c64:	430b      	orrs	r3, r1
34186c66:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
34186c6a:	e00b      	b.n	34186c84 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                                             DCMIPP_P1FSCR_DTMODE), pxfscr_reg);
    }
    else
    {
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
34186c6c:	68fb      	ldr	r3, [r7, #12]
34186c6e:	681b      	ldr	r3, [r3, #0]
34186c70:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
34186c74:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
34186c78:	68fb      	ldr	r3, [r7, #12]
34186c7a:	681b      	ldr	r3, [r3, #0]
34186c7c:	697a      	ldr	r2, [r7, #20]
34186c7e:	430a      	orrs	r2, r1
34186c80:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }

    /* Disable Parallel interface */
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34186c84:	68fb      	ldr	r3, [r7, #12]
34186c86:	681b      	ldr	r3, [r3, #0]
34186c88:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34186c8c:	68fb      	ldr	r3, [r7, #12]
34186c8e:	681b      	ldr	r3, [r3, #0]
34186c90:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34186c94:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Set CSI Input Selection  */
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34186c98:	68fb      	ldr	r3, [r7, #12]
34186c9a:	681b      	ldr	r3, [r3, #0]
34186c9c:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
34186ca0:	68fb      	ldr	r3, [r7, #12]
34186ca2:	681b      	ldr	r3, [r3, #0]
34186ca4:	f042 0201 	orr.w	r2, r2, #1
34186ca8:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  }

  /* Update the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34186cac:	68fb      	ldr	r3, [r7, #12]
34186cae:	2202      	movs	r2, #2
34186cb0:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34186cb2:	2300      	movs	r3, #0
}
34186cb4:	4618      	mov	r0, r3
34186cb6:	371c      	adds	r7, #28
34186cb8:	46bd      	mov	sp, r7
34186cba:	f85d 7b04 	ldr.w	r7, [sp], #4
34186cbe:	4770      	bx	lr
34186cc0:	fffcc0c0 	.word	0xfffcc0c0

34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>:
  * @param  DataTypeFormat Specifies the Data Type Format, can be a value from @ref DCMIPP_CSI_DataTypeFormat.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetVCConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel,
                                             uint32_t DataTypeFormat)
{
34186cc4:	b480      	push	{r7}
34186cc6:	b087      	sub	sp, #28
34186cc8:	af00      	add	r7, sp, #0
34186cca:	60f8      	str	r0, [r7, #12]
34186ccc:	60b9      	str	r1, [r7, #8]
34186cce:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34186cd0:	4b1c      	ldr	r3, [pc, #112]	@ (34186d44 <HAL_DCMIPP_CSI_SetVCConfig+0x80>)
34186cd2:	617b      	str	r3, [r7, #20]

  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));

  /* Check pointer and input values validity */
  if (hdcmipp == NULL)
34186cd4:	68fb      	ldr	r3, [r7, #12]
34186cd6:	2b00      	cmp	r3, #0
34186cd8:	d101      	bne.n	34186cde <HAL_DCMIPP_CSI_SetVCConfig+0x1a>
  {
    return HAL_ERROR;
34186cda:	2301      	movs	r3, #1
34186cdc:	e02c      	b.n	34186d38 <HAL_DCMIPP_CSI_SetVCConfig+0x74>
  }

  /* Set the common format for all data type for the selected virtual channel */
  switch (VirtualChannel)
34186cde:	68bb      	ldr	r3, [r7, #8]
34186ce0:	2b03      	cmp	r3, #3
34186ce2:	d827      	bhi.n	34186d34 <HAL_DCMIPP_CSI_SetVCConfig+0x70>
34186ce4:	a201      	add	r2, pc, #4	@ (adr r2, 34186cec <HAL_DCMIPP_CSI_SetVCConfig+0x28>)
34186ce6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34186cea:	bf00      	nop
34186cec:	34186cfd 	.word	0x34186cfd
34186cf0:	34186d0b 	.word	0x34186d0b
34186cf4:	34186d19 	.word	0x34186d19
34186cf8:	34186d27 	.word	0x34186d27
  {
    case DCMIPP_VIRTUAL_CHANNEL0:
    {
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34186cfc:	687b      	ldr	r3, [r7, #4]
34186cfe:	021b      	lsls	r3, r3, #8
34186d00:	f043 0201 	orr.w	r2, r3, #1
34186d04:	697b      	ldr	r3, [r7, #20]
34186d06:	611a      	str	r2, [r3, #16]
      break;
34186d08:	e015      	b.n	34186d36 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL1:
    {
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
34186d0a:	687b      	ldr	r3, [r7, #4]
34186d0c:	021b      	lsls	r3, r3, #8
34186d0e:	f043 0201 	orr.w	r2, r3, #1
34186d12:	697b      	ldr	r3, [r7, #20]
34186d14:	621a      	str	r2, [r3, #32]
      break;
34186d16:	e00e      	b.n	34186d36 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL2:
    {
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
34186d18:	687b      	ldr	r3, [r7, #4]
34186d1a:	021b      	lsls	r3, r3, #8
34186d1c:	f043 0201 	orr.w	r2, r3, #1
34186d20:	697b      	ldr	r3, [r7, #20]
34186d22:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
34186d24:	e007      	b.n	34186d36 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL3:
    {
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
34186d26:	687b      	ldr	r3, [r7, #4]
34186d28:	021b      	lsls	r3, r3, #8
34186d2a:	f043 0201 	orr.w	r2, r3, #1
34186d2e:	697b      	ldr	r3, [r7, #20]
34186d30:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
34186d32:	e000      	b.n	34186d36 <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    default:
      break;
34186d34:	bf00      	nop
  }

  return HAL_OK;
34186d36:	2300      	movs	r3, #0
}
34186d38:	4618      	mov	r0, r3
34186d3a:	371c      	adds	r7, #28
34186d3c:	46bd      	mov	sp, r7
34186d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34186d42:	4770      	bx	lr
34186d44:	58006000 	.word	0x58006000

34186d48 <HAL_DCMIPP_PIPE_SetConfig>:
  * @param  pPipeConfig pointer to pipe configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                            const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
34186d48:	b580      	push	{r7, lr}
34186d4a:	b086      	sub	sp, #24
34186d4c:	af00      	add	r7, sp, #0
34186d4e:	60f8      	str	r0, [r7, #12]
34186d50:	60b9      	str	r1, [r7, #8]
34186d52:	607a      	str	r2, [r7, #4]
  HAL_DCMIPP_PipeStateTypeDef pipe_state;

  /* Check the DCMIPP peripheral handle parameter and pPipeConfig parameter */
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
34186d54:	68fb      	ldr	r3, [r7, #12]
34186d56:	2b00      	cmp	r3, #0
34186d58:	d002      	beq.n	34186d60 <HAL_DCMIPP_PIPE_SetConfig+0x18>
34186d5a:	687b      	ldr	r3, [r7, #4]
34186d5c:	2b00      	cmp	r3, #0
34186d5e:	d101      	bne.n	34186d64 <HAL_DCMIPP_PIPE_SetConfig+0x1c>
  {
    return HAL_ERROR;
34186d60:	2301      	movs	r3, #1
34186d62:	e02f      	b.n	34186dc4 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  {
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
  }

  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
34186d64:	68bb      	ldr	r3, [r7, #8]
34186d66:	2b02      	cmp	r3, #2
34186d68:	d105      	bne.n	34186d76 <HAL_DCMIPP_PIPE_SetConfig+0x2e>
34186d6a:	687b      	ldr	r3, [r7, #4]
34186d6c:	689b      	ldr	r3, [r3, #8]
34186d6e:	2b06      	cmp	r3, #6
34186d70:	d901      	bls.n	34186d76 <HAL_DCMIPP_PIPE_SetConfig+0x2e>
  {
    return HAL_ERROR;
34186d72:	2301      	movs	r3, #1
34186d74:	e026      	b.n	34186dc4 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  }
  /* Get Pipe State */
  pipe_state = hdcmipp->PipeState[Pipe];
34186d76:	68fa      	ldr	r2, [r7, #12]
34186d78:	68bb      	ldr	r3, [r7, #8]
34186d7a:	4413      	add	r3, r2
34186d7c:	3305      	adds	r3, #5
34186d7e:	781b      	ldrb	r3, [r3, #0]
34186d80:	75fb      	strb	r3, [r7, #23]

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34186d82:	68fb      	ldr	r3, [r7, #12]
34186d84:	791b      	ldrb	r3, [r3, #4]
34186d86:	b2db      	uxtb	r3, r3
34186d88:	2b02      	cmp	r3, #2
34186d8a:	d11a      	bne.n	34186dc2 <HAL_DCMIPP_PIPE_SetConfig+0x7a>
  {
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
34186d8c:	7dfb      	ldrb	r3, [r7, #23]
34186d8e:	2b00      	cmp	r3, #0
34186d90:	d002      	beq.n	34186d98 <HAL_DCMIPP_PIPE_SetConfig+0x50>
34186d92:	7dfb      	ldrb	r3, [r7, #23]
34186d94:	2b04      	cmp	r3, #4
34186d96:	d112      	bne.n	34186dbe <HAL_DCMIPP_PIPE_SetConfig+0x76>
    {
      /* Update the DCMIPP PIPE state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34186d98:	68fa      	ldr	r2, [r7, #12]
34186d9a:	68bb      	ldr	r3, [r7, #8]
34186d9c:	4413      	add	r3, r2
34186d9e:	3305      	adds	r3, #5
34186da0:	2202      	movs	r2, #2
34186da2:	701a      	strb	r2, [r3, #0]

      /* Initialize the DCMIPP Pipe registers */
      Pipe_Config(hdcmipp, Pipe, pPipeConfig);
34186da4:	687a      	ldr	r2, [r7, #4]
34186da6:	68b9      	ldr	r1, [r7, #8]
34186da8:	68f8      	ldr	r0, [r7, #12]
34186daa:	f002 fbd7 	bl	3418955c <Pipe_Config>

      /* Update the DCMIPP pipe state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
34186dae:	68fa      	ldr	r2, [r7, #12]
34186db0:	68bb      	ldr	r3, [r7, #8]
34186db2:	4413      	add	r3, r2
34186db4:	3305      	adds	r3, #5
34186db6:	2201      	movs	r2, #1
34186db8:	701a      	strb	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34186dba:	2300      	movs	r3, #0
34186dbc:	e002      	b.n	34186dc4 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
      return HAL_ERROR;
34186dbe:	2301      	movs	r3, #1
34186dc0:	e000      	b.n	34186dc4 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
    return HAL_ERROR;
34186dc2:	2301      	movs	r3, #1
}
34186dc4:	4618      	mov	r0, r3
34186dc6:	3718      	adds	r7, #24
34186dc8:	46bd      	mov	sp, r7
34186dca:	bd80      	pop	{r7, pc}

34186dcc <HAL_DCMIPP_CSI_PIPE_Start>:
  * @param  CaptureMode    DCMIPP capture mode for the pipe can be a value from @ref DCMIPP_Capture_Mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_Start(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel,
                                            uint32_t DstAddress, uint32_t CaptureMode)
{
34186dcc:	b580      	push	{r7, lr}
34186dce:	b086      	sub	sp, #24
34186dd0:	af00      	add	r7, sp, #0
34186dd2:	60f8      	str	r0, [r7, #12]
34186dd4:	60b9      	str	r1, [r7, #8]
34186dd6:	607a      	str	r2, [r7, #4]
34186dd8:	603b      	str	r3, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CAPTURE_MODE(CaptureMode));

  /* Check pointer validity */
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
34186dda:	68fb      	ldr	r3, [r7, #12]
34186ddc:	2b00      	cmp	r3, #0
34186dde:	d004      	beq.n	34186dea <HAL_DCMIPP_CSI_PIPE_Start+0x1e>
34186de0:	683b      	ldr	r3, [r7, #0]
34186de2:	f003 030f 	and.w	r3, r3, #15
34186de6:	2b00      	cmp	r3, #0
34186de8:	d001      	beq.n	34186dee <HAL_DCMIPP_CSI_PIPE_Start+0x22>
  {
    return HAL_ERROR;
34186dea:	2301      	movs	r3, #1
34186dec:	e028      	b.n	34186e40 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34186dee:	68fb      	ldr	r3, [r7, #12]
34186df0:	681b      	ldr	r3, [r3, #0]
34186df2:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
34186df6:	f003 0301 	and.w	r3, r3, #1
34186dfa:	617b      	str	r3, [r7, #20]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
34186dfc:	68fa      	ldr	r2, [r7, #12]
34186dfe:	68bb      	ldr	r3, [r7, #8]
34186e00:	4413      	add	r3, r2
34186e02:	3305      	adds	r3, #5
34186e04:	781b      	ldrb	r3, [r3, #0]
34186e06:	b2db      	uxtb	r3, r3
34186e08:	2b01      	cmp	r3, #1
34186e0a:	d102      	bne.n	34186e12 <HAL_DCMIPP_CSI_PIPE_Start+0x46>
34186e0c:	697b      	ldr	r3, [r7, #20]
34186e0e:	2b01      	cmp	r3, #1
34186e10:	d001      	beq.n	34186e16 <HAL_DCMIPP_CSI_PIPE_Start+0x4a>
  {
    return HAL_ERROR;
34186e12:	2301      	movs	r3, #1
34186e14:	e014      	b.n	34186e40 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  /* Set Virtual Channel for the selected Pipe */
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
34186e16:	687a      	ldr	r2, [r7, #4]
34186e18:	68b9      	ldr	r1, [r7, #8]
34186e1a:	68f8      	ldr	r0, [r7, #12]
34186e1c:	f002 fda4 	bl	34189968 <DCMIPP_CSI_SetVCConfig>
34186e20:	4603      	mov	r3, r0
34186e22:	2b00      	cmp	r3, #0
34186e24:	d001      	beq.n	34186e2a <HAL_DCMIPP_CSI_PIPE_Start+0x5e>
  {
    return HAL_ERROR;
34186e26:	2301      	movs	r3, #1
34186e28:	e00a      	b.n	34186e40 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  /* Set Capture Mode and Destination address for the selected pipe */
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
34186e2a:	6a3b      	ldr	r3, [r7, #32]
34186e2c:	683a      	ldr	r2, [r7, #0]
34186e2e:	68b9      	ldr	r1, [r7, #8]
34186e30:	68f8      	ldr	r0, [r7, #12]
34186e32:	f002 fccc 	bl	341897ce <DCMIPP_SetConfig>

  /* Enable Capture for the selected Pipe */
  DCMIPP_EnableCapture(hdcmipp, Pipe);
34186e36:	68b9      	ldr	r1, [r7, #8]
34186e38:	68f8      	ldr	r0, [r7, #12]
34186e3a:	f002 fd40 	bl	341898be <DCMIPP_EnableCapture>

  return HAL_OK;
34186e3e:	2300      	movs	r3, #0
}
34186e40:	4618      	mov	r0, r3
34186e42:	3718      	adds	r7, #24
34186e44:	46bd      	mov	sp, r7
34186e46:	bd80      	pop	{r7, pc}

34186e48 <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34186e48:	b580      	push	{r7, lr}
34186e4a:	b084      	sub	sp, #16
34186e4c:	af00      	add	r7, sp, #0
34186e4e:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
34186e50:	687b      	ldr	r3, [r7, #4]
34186e52:	681b      	ldr	r3, [r3, #0]
34186e54:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
34186e58:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34186e5a:	687b      	ldr	r3, [r7, #4]
34186e5c:	681b      	ldr	r3, [r3, #0]
34186e5e:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34186e62:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34186e64:	68fb      	ldr	r3, [r7, #12]
34186e66:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34186e6a:	2b00      	cmp	r3, #0
34186e6c:	d01e      	beq.n	34186eac <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
34186e6e:	68bb      	ldr	r3, [r7, #8]
34186e70:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34186e74:	2b00      	cmp	r3, #0
34186e76:	d019      	beq.n	34186eac <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34186e78:	687b      	ldr	r3, [r7, #4]
34186e7a:	681b      	ldr	r3, [r3, #0]
34186e7c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34186e80:	687b      	ldr	r3, [r7, #4]
34186e82:	681b      	ldr	r3, [r3, #0]
34186e84:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34186e88:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34186e8c:	687b      	ldr	r3, [r7, #4]
34186e8e:	689b      	ldr	r3, [r3, #8]
34186e90:	f043 0204 	orr.w	r2, r3, #4
34186e94:	687b      	ldr	r3, [r7, #4]
34186e96:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
34186e98:	687b      	ldr	r3, [r7, #4]
34186e9a:	681b      	ldr	r3, [r3, #0]
34186e9c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34186ea0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34186ea4:	2100      	movs	r1, #0
34186ea6:	6878      	ldr	r0, [r7, #4]
34186ea8:	f000 fe7d 	bl	34187ba6 <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34186eac:	68fb      	ldr	r3, [r7, #12]
34186eae:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34186eb2:	2b00      	cmp	r3, #0
34186eb4:	d00e      	beq.n	34186ed4 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
34186eb6:	68bb      	ldr	r3, [r7, #8]
34186eb8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34186ebc:	2b00      	cmp	r3, #0
34186ebe:	d009      	beq.n	34186ed4 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34186ec0:	687b      	ldr	r3, [r7, #4]
34186ec2:	681b      	ldr	r3, [r3, #0]
34186ec4:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34186ec8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34186ecc:	2100      	movs	r1, #0
34186ece:	6878      	ldr	r0, [r7, #4]
34186ed0:	f000 fe53 	bl	34187b7a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34186ed4:	68fb      	ldr	r3, [r7, #12]
34186ed6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34186eda:	2b00      	cmp	r3, #0
34186edc:	d023      	beq.n	34186f26 <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34186ede:	68bb      	ldr	r3, [r7, #8]
34186ee0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34186ee4:	2b00      	cmp	r3, #0
34186ee6:	d01e      	beq.n	34186f26 <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34186ee8:	687b      	ldr	r3, [r7, #4]
34186eea:	681b      	ldr	r3, [r3, #0]
34186eec:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34186ef0:	f003 0304 	and.w	r3, r3, #4
34186ef4:	2b04      	cmp	r3, #4
34186ef6:	d10c      	bne.n	34186f12 <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34186ef8:	687b      	ldr	r3, [r7, #4]
34186efa:	681b      	ldr	r3, [r3, #0]
34186efc:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34186f00:	687b      	ldr	r3, [r7, #4]
34186f02:	681b      	ldr	r3, [r3, #0]
34186f04:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34186f08:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34186f0c:	687b      	ldr	r3, [r7, #4]
34186f0e:	2201      	movs	r2, #1
34186f10:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34186f12:	687b      	ldr	r3, [r7, #4]
34186f14:	681b      	ldr	r3, [r3, #0]
34186f16:	f44f 7200 	mov.w	r2, #512	@ 0x200
34186f1a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
34186f1e:	2100      	movs	r1, #0
34186f20:	6878      	ldr	r0, [r7, #4]
34186f22:	f000 fe1f 	bl	34187b64 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34186f26:	68fb      	ldr	r3, [r7, #12]
34186f28:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34186f2c:	2b00      	cmp	r3, #0
34186f2e:	d00e      	beq.n	34186f4e <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
34186f30:	68bb      	ldr	r3, [r7, #8]
34186f32:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34186f36:	2b00      	cmp	r3, #0
34186f38:	d009      	beq.n	34186f4e <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34186f3a:	687b      	ldr	r3, [r7, #4]
34186f3c:	681b      	ldr	r3, [r3, #0]
34186f3e:	f44f 7280 	mov.w	r2, #256	@ 0x100
34186f42:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34186f46:	2100      	movs	r1, #0
34186f48:	6878      	ldr	r0, [r7, #4]
34186f4a:	f000 fe21 	bl	34187b90 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
34186f4e:	68fb      	ldr	r3, [r7, #12]
34186f50:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34186f54:	2b00      	cmp	r3, #0
34186f56:	d021      	beq.n	34186f9c <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34186f58:	68bb      	ldr	r3, [r7, #8]
34186f5a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34186f5e:	2b00      	cmp	r3, #0
34186f60:	d01c      	beq.n	34186f9c <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34186f62:	687b      	ldr	r3, [r7, #4]
34186f64:	681b      	ldr	r3, [r3, #0]
34186f66:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34186f6a:	687b      	ldr	r3, [r7, #4]
34186f6c:	681b      	ldr	r3, [r3, #0]
34186f6e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34186f72:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34186f76:	687b      	ldr	r3, [r7, #4]
34186f78:	689b      	ldr	r3, [r3, #8]
34186f7a:	f043 0208 	orr.w	r2, r3, #8
34186f7e:	687b      	ldr	r3, [r7, #4]
34186f80:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34186f82:	687b      	ldr	r3, [r7, #4]
34186f84:	681b      	ldr	r3, [r3, #0]
34186f86:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34186f8a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34186f8e:	687b      	ldr	r3, [r7, #4]
34186f90:	2204      	movs	r2, #4
34186f92:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34186f94:	2100      	movs	r1, #0
34186f96:	6878      	ldr	r0, [r7, #4]
34186f98:	f000 fe10 	bl	34187bbc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34186f9c:	68fb      	ldr	r3, [r7, #12]
34186f9e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34186fa2:	2b00      	cmp	r3, #0
34186fa4:	d00e      	beq.n	34186fc4 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34186fa6:	68bb      	ldr	r3, [r7, #8]
34186fa8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34186fac:	2b00      	cmp	r3, #0
34186fae:	d009      	beq.n	34186fc4 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34186fb0:	687b      	ldr	r3, [r7, #4]
34186fb2:	681b      	ldr	r3, [r3, #0]
34186fb4:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34186fb8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34186fbc:	2101      	movs	r1, #1
34186fbe:	6878      	ldr	r0, [r7, #4]
34186fc0:	f000 fde6 	bl	34187b90 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34186fc4:	68fb      	ldr	r3, [r7, #12]
34186fc6:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34186fca:	2b00      	cmp	r3, #0
34186fcc:	d00e      	beq.n	34186fec <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34186fce:	68bb      	ldr	r3, [r7, #8]
34186fd0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34186fd4:	2b00      	cmp	r3, #0
34186fd6:	d009      	beq.n	34186fec <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
34186fd8:	687b      	ldr	r3, [r7, #4]
34186fda:	681b      	ldr	r3, [r3, #0]
34186fdc:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34186fe0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34186fe4:	2101      	movs	r1, #1
34186fe6:	6878      	ldr	r0, [r7, #4]
34186fe8:	f000 fdc7 	bl	34187b7a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34186fec:	68fb      	ldr	r3, [r7, #12]
34186fee:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34186ff2:	2b00      	cmp	r3, #0
34186ff4:	d023      	beq.n	3418703e <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34186ff6:	68bb      	ldr	r3, [r7, #8]
34186ff8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34186ffc:	2b00      	cmp	r3, #0
34186ffe:	d01e      	beq.n	3418703e <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187000:	687b      	ldr	r3, [r7, #4]
34187002:	681b      	ldr	r3, [r3, #0]
34187004:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34187008:	f003 0304 	and.w	r3, r3, #4
3418700c:	2b04      	cmp	r3, #4
3418700e:	d10c      	bne.n	3418702a <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34187010:	687b      	ldr	r3, [r7, #4]
34187012:	681b      	ldr	r3, [r3, #0]
34187014:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34187018:	687b      	ldr	r3, [r7, #4]
3418701a:	681b      	ldr	r3, [r3, #0]
3418701c:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
34187020:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34187024:	687b      	ldr	r3, [r7, #4]
34187026:	2201      	movs	r2, #1
34187028:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
3418702a:	687b      	ldr	r3, [r7, #4]
3418702c:	681b      	ldr	r3, [r3, #0]
3418702e:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34187032:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34187036:	2101      	movs	r1, #1
34187038:	6878      	ldr	r0, [r7, #4]
3418703a:	f000 fd93 	bl	34187b64 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
3418703e:	68fb      	ldr	r3, [r7, #12]
34187040:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34187044:	2b00      	cmp	r3, #0
34187046:	d021      	beq.n	3418708c <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34187048:	68bb      	ldr	r3, [r7, #8]
3418704a:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3418704e:	2b00      	cmp	r3, #0
34187050:	d01c      	beq.n	3418708c <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34187052:	687b      	ldr	r3, [r7, #4]
34187054:	681b      	ldr	r3, [r3, #0]
34187056:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3418705a:	687b      	ldr	r3, [r7, #4]
3418705c:	681b      	ldr	r3, [r3, #0]
3418705e:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34187062:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34187066:	687b      	ldr	r3, [r7, #4]
34187068:	689b      	ldr	r3, [r3, #8]
3418706a:	f043 0210 	orr.w	r2, r3, #16
3418706e:	687b      	ldr	r3, [r7, #4]
34187070:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34187072:	687b      	ldr	r3, [r7, #4]
34187074:	681b      	ldr	r3, [r3, #0]
34187076:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3418707a:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
3418707e:	687b      	ldr	r3, [r7, #4]
34187080:	2204      	movs	r2, #4
34187082:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34187084:	2101      	movs	r1, #1
34187086:	6878      	ldr	r0, [r7, #4]
34187088:	f000 fd98 	bl	34187bbc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
3418708c:	68fb      	ldr	r3, [r7, #12]
3418708e:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34187092:	2b00      	cmp	r3, #0
34187094:	d00e      	beq.n	341870b4 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34187096:	68bb      	ldr	r3, [r7, #8]
34187098:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418709c:	2b00      	cmp	r3, #0
3418709e:	d009      	beq.n	341870b4 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
341870a0:	687b      	ldr	r3, [r7, #4]
341870a2:	681b      	ldr	r3, [r3, #0]
341870a4:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
341870a8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
341870ac:	2102      	movs	r1, #2
341870ae:	6878      	ldr	r0, [r7, #4]
341870b0:	f000 fd6e 	bl	34187b90 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
341870b4:	68fb      	ldr	r3, [r7, #12]
341870b6:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
341870ba:	2b00      	cmp	r3, #0
341870bc:	d00e      	beq.n	341870dc <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
341870be:	68bb      	ldr	r3, [r7, #8]
341870c0:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
341870c4:	2b00      	cmp	r3, #0
341870c6:	d009      	beq.n	341870dc <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
341870c8:	687b      	ldr	r3, [r7, #4]
341870ca:	681b      	ldr	r3, [r3, #0]
341870cc:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
341870d0:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
341870d4:	2102      	movs	r1, #2
341870d6:	6878      	ldr	r0, [r7, #4]
341870d8:	f000 fd4f 	bl	34187b7a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
341870dc:	68fb      	ldr	r3, [r7, #12]
341870de:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
341870e2:	2b00      	cmp	r3, #0
341870e4:	d023      	beq.n	3418712e <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
341870e6:	68bb      	ldr	r3, [r7, #8]
341870e8:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
341870ec:	2b00      	cmp	r3, #0
341870ee:	d01e      	beq.n	3418712e <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341870f0:	687b      	ldr	r3, [r7, #4]
341870f2:	681b      	ldr	r3, [r3, #0]
341870f4:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
341870f8:	f003 0304 	and.w	r3, r3, #4
341870fc:	2b04      	cmp	r3, #4
341870fe:	d10c      	bne.n	3418711a <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34187100:	687b      	ldr	r3, [r7, #4]
34187102:	681b      	ldr	r3, [r3, #0]
34187104:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34187108:	687b      	ldr	r3, [r7, #4]
3418710a:	681b      	ldr	r3, [r3, #0]
3418710c:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34187110:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34187114:	687b      	ldr	r3, [r7, #4]
34187116:	2201      	movs	r2, #1
34187118:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
3418711a:	687b      	ldr	r3, [r7, #4]
3418711c:	681b      	ldr	r3, [r3, #0]
3418711e:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34187122:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34187126:	2102      	movs	r1, #2
34187128:	6878      	ldr	r0, [r7, #4]
3418712a:	f000 fd1b 	bl	34187b64 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
3418712e:	68fb      	ldr	r3, [r7, #12]
34187130:	2b00      	cmp	r3, #0
34187132:	da1f      	bge.n	34187174 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34187134:	68bb      	ldr	r3, [r7, #8]
34187136:	2b00      	cmp	r3, #0
34187138:	da1c      	bge.n	34187174 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
3418713a:	687b      	ldr	r3, [r7, #4]
3418713c:	681b      	ldr	r3, [r3, #0]
3418713e:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34187142:	687b      	ldr	r3, [r7, #4]
34187144:	681b      	ldr	r3, [r3, #0]
34187146:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
3418714a:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
3418714e:	687b      	ldr	r3, [r7, #4]
34187150:	689b      	ldr	r3, [r3, #8]
34187152:	f043 0220 	orr.w	r2, r3, #32
34187156:	687b      	ldr	r3, [r7, #4]
34187158:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
3418715a:	687b      	ldr	r3, [r7, #4]
3418715c:	681b      	ldr	r3, [r3, #0]
3418715e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34187162:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34187166:	687b      	ldr	r3, [r7, #4]
34187168:	2204      	movs	r2, #4
3418716a:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
3418716c:	2102      	movs	r1, #2
3418716e:	6878      	ldr	r0, [r7, #4]
34187170:	f000 fd24 	bl	34187bbc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34187174:	68fb      	ldr	r3, [r7, #12]
34187176:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418717a:	2b00      	cmp	r3, #0
3418717c:	d01f      	beq.n	341871be <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
3418717e:	68bb      	ldr	r3, [r7, #8]
34187180:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34187184:	2b00      	cmp	r3, #0
34187186:	d01a      	beq.n	341871be <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34187188:	687b      	ldr	r3, [r7, #4]
3418718a:	681b      	ldr	r3, [r3, #0]
3418718c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34187190:	687b      	ldr	r3, [r7, #4]
34187192:	681b      	ldr	r3, [r3, #0]
34187194:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34187198:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
3418719c:	687b      	ldr	r3, [r7, #4]
3418719e:	689b      	ldr	r3, [r3, #8]
341871a0:	f043 0202 	orr.w	r2, r3, #2
341871a4:	687b      	ldr	r3, [r7, #4]
341871a6:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
341871a8:	687b      	ldr	r3, [r7, #4]
341871aa:	681b      	ldr	r3, [r3, #0]
341871ac:	2240      	movs	r2, #64	@ 0x40
341871ae:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
341871b2:	687b      	ldr	r3, [r7, #4]
341871b4:	2204      	movs	r2, #4
341871b6:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
341871b8:	6878      	ldr	r0, [r7, #4]
341871ba:	f000 fd0a 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
341871be:	68fb      	ldr	r3, [r7, #12]
341871c0:	f003 0320 	and.w	r3, r3, #32
341871c4:	2b00      	cmp	r3, #0
341871c6:	d01f      	beq.n	34187208 <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
341871c8:	68bb      	ldr	r3, [r7, #8]
341871ca:	f003 0320 	and.w	r3, r3, #32
341871ce:	2b00      	cmp	r3, #0
341871d0:	d01a      	beq.n	34187208 <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
341871d2:	687b      	ldr	r3, [r7, #4]
341871d4:	681b      	ldr	r3, [r3, #0]
341871d6:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
341871da:	687b      	ldr	r3, [r7, #4]
341871dc:	681b      	ldr	r3, [r3, #0]
341871de:	f022 0220 	bic.w	r2, r2, #32
341871e2:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
341871e6:	687b      	ldr	r3, [r7, #4]
341871e8:	689b      	ldr	r3, [r3, #8]
341871ea:	f043 0201 	orr.w	r2, r3, #1
341871ee:	687b      	ldr	r3, [r7, #4]
341871f0:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
341871f2:	687b      	ldr	r3, [r7, #4]
341871f4:	681b      	ldr	r3, [r3, #0]
341871f6:	2220      	movs	r2, #32
341871f8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
341871fc:	687b      	ldr	r3, [r7, #4]
341871fe:	2204      	movs	r2, #4
34187200:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187202:	6878      	ldr	r0, [r7, #4]
34187204:	f000 fce5 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34187208:	bf00      	nop
3418720a:	3710      	adds	r7, #16
3418720c:	46bd      	mov	sp, r7
3418720e:	bd80      	pop	{r7, pc}

34187210 <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34187210:	b580      	push	{r7, lr}
34187212:	b088      	sub	sp, #32
34187214:	af00      	add	r7, sp, #0
34187216:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34187218:	4bb1      	ldr	r3, [pc, #708]	@ (341874e0 <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
3418721a:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
3418721c:	69fb      	ldr	r3, [r7, #28]
3418721e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34187222:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34187224:	69fb      	ldr	r3, [r7, #28]
34187226:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3418722a:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
3418722c:	69fb      	ldr	r3, [r7, #28]
3418722e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187232:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34187234:	69fb      	ldr	r3, [r7, #28]
34187236:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418723a:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
3418723c:	69bb      	ldr	r3, [r7, #24]
3418723e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34187242:	2b00      	cmp	r3, #0
34187244:	d014      	beq.n	34187270 <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34187246:	693b      	ldr	r3, [r7, #16]
34187248:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3418724c:	2b00      	cmp	r3, #0
3418724e:	d00f      	beq.n	34187270 <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34187250:	69fb      	ldr	r3, [r7, #28]
34187252:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187256:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
3418725a:	69fb      	ldr	r3, [r7, #28]
3418725c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34187260:	69fb      	ldr	r3, [r7, #28]
34187262:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34187266:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
3418726a:	6878      	ldr	r0, [r7, #4]
3418726c:	f000 fcc6 	bl	34187bfc <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34187270:	69bb      	ldr	r3, [r7, #24]
34187272:	f003 0308 	and.w	r3, r3, #8
34187276:	2b00      	cmp	r3, #0
34187278:	d01c      	beq.n	341872b4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
3418727a:	693b      	ldr	r3, [r7, #16]
3418727c:	f003 0308 	and.w	r3, r3, #8
34187280:	2b00      	cmp	r3, #0
34187282:	d017      	beq.n	341872b4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187284:	687b      	ldr	r3, [r7, #4]
34187286:	681b      	ldr	r3, [r3, #0]
34187288:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418728c:	f003 0304 	and.w	r3, r3, #4
34187290:	2b04      	cmp	r3, #4
34187292:	d107      	bne.n	341872a4 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
34187294:	69fb      	ldr	r3, [r7, #28]
34187296:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418729a:	f023 0208 	bic.w	r2, r3, #8
3418729e:	69fb      	ldr	r3, [r7, #28]
341872a0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
341872a4:	69fb      	ldr	r3, [r7, #28]
341872a6:	2208      	movs	r2, #8
341872a8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
341872ac:	2103      	movs	r1, #3
341872ae:	6878      	ldr	r0, [r7, #4]
341872b0:	f000 fcd9 	bl	34187c66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
341872b4:	69bb      	ldr	r3, [r7, #24]
341872b6:	f003 0304 	and.w	r3, r3, #4
341872ba:	2b00      	cmp	r3, #0
341872bc:	d01c      	beq.n	341872f8 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
341872be:	693b      	ldr	r3, [r7, #16]
341872c0:	f003 0304 	and.w	r3, r3, #4
341872c4:	2b00      	cmp	r3, #0
341872c6:	d017      	beq.n	341872f8 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341872c8:	687b      	ldr	r3, [r7, #4]
341872ca:	681b      	ldr	r3, [r3, #0]
341872cc:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341872d0:	f003 0304 	and.w	r3, r3, #4
341872d4:	2b04      	cmp	r3, #4
341872d6:	d107      	bne.n	341872e8 <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
341872d8:	69fb      	ldr	r3, [r7, #28]
341872da:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341872de:	f023 0204 	bic.w	r2, r3, #4
341872e2:	69fb      	ldr	r3, [r7, #28]
341872e4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
341872e8:	69fb      	ldr	r3, [r7, #28]
341872ea:	2204      	movs	r2, #4
341872ec:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
341872f0:	2102      	movs	r1, #2
341872f2:	6878      	ldr	r0, [r7, #4]
341872f4:	f000 fcb7 	bl	34187c66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
341872f8:	69bb      	ldr	r3, [r7, #24]
341872fa:	f003 0302 	and.w	r3, r3, #2
341872fe:	2b00      	cmp	r3, #0
34187300:	d01c      	beq.n	3418733c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34187302:	693b      	ldr	r3, [r7, #16]
34187304:	f003 0302 	and.w	r3, r3, #2
34187308:	2b00      	cmp	r3, #0
3418730a:	d017      	beq.n	3418733c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418730c:	687b      	ldr	r3, [r7, #4]
3418730e:	681b      	ldr	r3, [r3, #0]
34187310:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187314:	f003 0304 	and.w	r3, r3, #4
34187318:	2b04      	cmp	r3, #4
3418731a:	d107      	bne.n	3418732c <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
3418731c:	69fb      	ldr	r3, [r7, #28]
3418731e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187322:	f023 0202 	bic.w	r2, r3, #2
34187326:	69fb      	ldr	r3, [r7, #28]
34187328:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
3418732c:	69fb      	ldr	r3, [r7, #28]
3418732e:	2202      	movs	r2, #2
34187330:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34187334:	2101      	movs	r1, #1
34187336:	6878      	ldr	r0, [r7, #4]
34187338:	f000 fc95 	bl	34187c66 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
3418733c:	69bb      	ldr	r3, [r7, #24]
3418733e:	f003 0301 	and.w	r3, r3, #1
34187342:	2b00      	cmp	r3, #0
34187344:	d01c      	beq.n	34187380 <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34187346:	693b      	ldr	r3, [r7, #16]
34187348:	f003 0301 	and.w	r3, r3, #1
3418734c:	2b00      	cmp	r3, #0
3418734e:	d017      	beq.n	34187380 <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187350:	687b      	ldr	r3, [r7, #4]
34187352:	681b      	ldr	r3, [r3, #0]
34187354:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187358:	f003 0304 	and.w	r3, r3, #4
3418735c:	2b04      	cmp	r3, #4
3418735e:	d107      	bne.n	34187370 <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34187360:	69fb      	ldr	r3, [r7, #28]
34187362:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187366:	f023 0201 	bic.w	r2, r3, #1
3418736a:	69fb      	ldr	r3, [r7, #28]
3418736c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34187370:	69fb      	ldr	r3, [r7, #28]
34187372:	2201      	movs	r2, #1
34187374:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34187378:	2100      	movs	r1, #0
3418737a:	6878      	ldr	r0, [r7, #4]
3418737c:	f000 fc73 	bl	34187c66 <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34187380:	69bb      	ldr	r3, [r7, #24]
34187382:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34187386:	2b00      	cmp	r3, #0
34187388:	d01d      	beq.n	341873c6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
3418738a:	693b      	ldr	r3, [r7, #16]
3418738c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34187390:	2b00      	cmp	r3, #0
34187392:	d018      	beq.n	341873c6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187394:	687b      	ldr	r3, [r7, #4]
34187396:	681b      	ldr	r3, [r3, #0]
34187398:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418739c:	f003 0304 	and.w	r3, r3, #4
341873a0:	2b04      	cmp	r3, #4
341873a2:	d107      	bne.n	341873b4 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
341873a4:	69fb      	ldr	r3, [r7, #28]
341873a6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341873aa:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
341873ae:	69fb      	ldr	r3, [r7, #28]
341873b0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
341873b4:	69fb      	ldr	r3, [r7, #28]
341873b6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341873ba:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
341873be:	2103      	movs	r1, #3
341873c0:	6878      	ldr	r0, [r7, #4]
341873c2:	f000 fc2f 	bl	34187c24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
341873c6:	69bb      	ldr	r3, [r7, #24]
341873c8:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
341873cc:	2b00      	cmp	r3, #0
341873ce:	d01d      	beq.n	3418740c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
341873d0:	693b      	ldr	r3, [r7, #16]
341873d2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
341873d6:	2b00      	cmp	r3, #0
341873d8:	d018      	beq.n	3418740c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341873da:	687b      	ldr	r3, [r7, #4]
341873dc:	681b      	ldr	r3, [r3, #0]
341873de:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341873e2:	f003 0304 	and.w	r3, r3, #4
341873e6:	2b04      	cmp	r3, #4
341873e8:	d107      	bne.n	341873fa <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
341873ea:	69fb      	ldr	r3, [r7, #28]
341873ec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341873f0:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
341873f4:	69fb      	ldr	r3, [r7, #28]
341873f6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
341873fa:	69fb      	ldr	r3, [r7, #28]
341873fc:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34187400:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34187404:	2102      	movs	r1, #2
34187406:	6878      	ldr	r0, [r7, #4]
34187408:	f000 fc0c 	bl	34187c24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
3418740c:	69bb      	ldr	r3, [r7, #24]
3418740e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34187412:	2b00      	cmp	r3, #0
34187414:	d01d      	beq.n	34187452 <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34187416:	693b      	ldr	r3, [r7, #16]
34187418:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418741c:	2b00      	cmp	r3, #0
3418741e:	d018      	beq.n	34187452 <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187420:	687b      	ldr	r3, [r7, #4]
34187422:	681b      	ldr	r3, [r3, #0]
34187424:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187428:	f003 0304 	and.w	r3, r3, #4
3418742c:	2b04      	cmp	r3, #4
3418742e:	d107      	bne.n	34187440 <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
34187430:	69fb      	ldr	r3, [r7, #28]
34187432:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187436:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
3418743a:	69fb      	ldr	r3, [r7, #28]
3418743c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34187440:	69fb      	ldr	r3, [r7, #28]
34187442:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34187446:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
3418744a:	2101      	movs	r1, #1
3418744c:	6878      	ldr	r0, [r7, #4]
3418744e:	f000 fbe9 	bl	34187c24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34187452:	69bb      	ldr	r3, [r7, #24]
34187454:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34187458:	2b00      	cmp	r3, #0
3418745a:	d01d      	beq.n	34187498 <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
3418745c:	693b      	ldr	r3, [r7, #16]
3418745e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34187462:	2b00      	cmp	r3, #0
34187464:	d018      	beq.n	34187498 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187466:	687b      	ldr	r3, [r7, #4]
34187468:	681b      	ldr	r3, [r3, #0]
3418746a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418746e:	f003 0304 	and.w	r3, r3, #4
34187472:	2b04      	cmp	r3, #4
34187474:	d107      	bne.n	34187486 <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34187476:	69fb      	ldr	r3, [r7, #28]
34187478:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418747c:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34187480:	69fb      	ldr	r3, [r7, #28]
34187482:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34187486:	69fb      	ldr	r3, [r7, #28]
34187488:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3418748c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34187490:	2100      	movs	r1, #0
34187492:	6878      	ldr	r0, [r7, #4]
34187494:	f000 fbc6 	bl	34187c24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
34187498:	69bb      	ldr	r3, [r7, #24]
3418749a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418749e:	2b00      	cmp	r3, #0
341874a0:	d020      	beq.n	341874e4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
341874a2:	693b      	ldr	r3, [r7, #16]
341874a4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341874a8:	2b00      	cmp	r3, #0
341874aa:	d01b      	beq.n	341874e4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341874ac:	687b      	ldr	r3, [r7, #4]
341874ae:	681b      	ldr	r3, [r3, #0]
341874b0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341874b4:	f003 0304 	and.w	r3, r3, #4
341874b8:	2b04      	cmp	r3, #4
341874ba:	d107      	bne.n	341874cc <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
341874bc:	69fb      	ldr	r3, [r7, #28]
341874be:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341874c2:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
341874c6:	69fb      	ldr	r3, [r7, #28]
341874c8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
341874cc:	69fb      	ldr	r3, [r7, #28]
341874ce:	f44f 6200 	mov.w	r2, #2048	@ 0x800
341874d2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
341874d6:	2103      	movs	r1, #3
341874d8:	6878      	ldr	r0, [r7, #4]
341874da:	f000 fbae 	bl	34187c3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
341874de:	e001      	b.n	341874e4 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
341874e0:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
341874e4:	69bb      	ldr	r3, [r7, #24]
341874e6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341874ea:	2b00      	cmp	r3, #0
341874ec:	d01d      	beq.n	3418752a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
341874ee:	693b      	ldr	r3, [r7, #16]
341874f0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341874f4:	2b00      	cmp	r3, #0
341874f6:	d018      	beq.n	3418752a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341874f8:	687b      	ldr	r3, [r7, #4]
341874fa:	681b      	ldr	r3, [r3, #0]
341874fc:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187500:	f003 0304 	and.w	r3, r3, #4
34187504:	2b04      	cmp	r3, #4
34187506:	d107      	bne.n	34187518 <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34187508:	69fb      	ldr	r3, [r7, #28]
3418750a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418750e:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34187512:	69fb      	ldr	r3, [r7, #28]
34187514:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34187518:	69fb      	ldr	r3, [r7, #28]
3418751a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3418751e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34187522:	2102      	movs	r1, #2
34187524:	6878      	ldr	r0, [r7, #4]
34187526:	f000 fb88 	bl	34187c3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
3418752a:	69bb      	ldr	r3, [r7, #24]
3418752c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34187530:	2b00      	cmp	r3, #0
34187532:	d01d      	beq.n	34187570 <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34187534:	693b      	ldr	r3, [r7, #16]
34187536:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418753a:	2b00      	cmp	r3, #0
3418753c:	d018      	beq.n	34187570 <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418753e:	687b      	ldr	r3, [r7, #4]
34187540:	681b      	ldr	r3, [r3, #0]
34187542:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187546:	f003 0304 	and.w	r3, r3, #4
3418754a:	2b04      	cmp	r3, #4
3418754c:	d107      	bne.n	3418755e <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
3418754e:	69fb      	ldr	r3, [r7, #28]
34187550:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187554:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34187558:	69fb      	ldr	r3, [r7, #28]
3418755a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
3418755e:	69fb      	ldr	r3, [r7, #28]
34187560:	f44f 7200 	mov.w	r2, #512	@ 0x200
34187564:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34187568:	2101      	movs	r1, #1
3418756a:	6878      	ldr	r0, [r7, #4]
3418756c:	f000 fb65 	bl	34187c3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34187570:	69bb      	ldr	r3, [r7, #24]
34187572:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34187576:	2b00      	cmp	r3, #0
34187578:	d01d      	beq.n	341875b6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
3418757a:	693b      	ldr	r3, [r7, #16]
3418757c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34187580:	2b00      	cmp	r3, #0
34187582:	d018      	beq.n	341875b6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187584:	687b      	ldr	r3, [r7, #4]
34187586:	681b      	ldr	r3, [r3, #0]
34187588:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418758c:	f003 0304 	and.w	r3, r3, #4
34187590:	2b04      	cmp	r3, #4
34187592:	d107      	bne.n	341875a4 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
34187594:	69fb      	ldr	r3, [r7, #28]
34187596:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418759a:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
3418759e:	69fb      	ldr	r3, [r7, #28]
341875a0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
341875a4:	69fb      	ldr	r3, [r7, #28]
341875a6:	f44f 7280 	mov.w	r2, #256	@ 0x100
341875aa:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
341875ae:	2100      	movs	r1, #0
341875b0:	6878      	ldr	r0, [r7, #4]
341875b2:	f000 fb42 	bl	34187c3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
341875b6:	69bb      	ldr	r3, [r7, #24]
341875b8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341875bc:	2b00      	cmp	r3, #0
341875be:	d01c      	beq.n	341875fa <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
341875c0:	693b      	ldr	r3, [r7, #16]
341875c2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341875c6:	2b00      	cmp	r3, #0
341875c8:	d017      	beq.n	341875fa <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
341875ca:	687b      	ldr	r3, [r7, #4]
341875cc:	681b      	ldr	r3, [r3, #0]
341875ce:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
341875d2:	f003 0304 	and.w	r3, r3, #4
341875d6:	2b04      	cmp	r3, #4
341875d8:	d107      	bne.n	341875ea <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
341875da:	69fb      	ldr	r3, [r7, #28]
341875dc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341875e0:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
341875e4:	69fb      	ldr	r3, [r7, #28]
341875e6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
341875ea:	69fb      	ldr	r3, [r7, #28]
341875ec:	2280      	movs	r2, #128	@ 0x80
341875ee:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
341875f2:	2103      	movs	r1, #3
341875f4:	6878      	ldr	r0, [r7, #4]
341875f6:	f000 fb2b 	bl	34187c50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
341875fa:	69bb      	ldr	r3, [r7, #24]
341875fc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34187600:	2b00      	cmp	r3, #0
34187602:	d01c      	beq.n	3418763e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34187604:	693b      	ldr	r3, [r7, #16]
34187606:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418760a:	2b00      	cmp	r3, #0
3418760c:	d017      	beq.n	3418763e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3418760e:	687b      	ldr	r3, [r7, #4]
34187610:	681b      	ldr	r3, [r3, #0]
34187612:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34187616:	f003 0304 	and.w	r3, r3, #4
3418761a:	2b04      	cmp	r3, #4
3418761c:	d107      	bne.n	3418762e <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
3418761e:	69fb      	ldr	r3, [r7, #28]
34187620:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187624:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
34187628:	69fb      	ldr	r3, [r7, #28]
3418762a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
3418762e:	69fb      	ldr	r3, [r7, #28]
34187630:	2240      	movs	r2, #64	@ 0x40
34187632:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34187636:	2102      	movs	r1, #2
34187638:	6878      	ldr	r0, [r7, #4]
3418763a:	f000 fb09 	bl	34187c50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
3418763e:	69bb      	ldr	r3, [r7, #24]
34187640:	f003 0320 	and.w	r3, r3, #32
34187644:	2b00      	cmp	r3, #0
34187646:	d01c      	beq.n	34187682 <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34187648:	693b      	ldr	r3, [r7, #16]
3418764a:	f003 0320 	and.w	r3, r3, #32
3418764e:	2b00      	cmp	r3, #0
34187650:	d017      	beq.n	34187682 <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187652:	687b      	ldr	r3, [r7, #4]
34187654:	681b      	ldr	r3, [r3, #0]
34187656:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418765a:	f003 0304 	and.w	r3, r3, #4
3418765e:	2b04      	cmp	r3, #4
34187660:	d107      	bne.n	34187672 <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34187662:	69fb      	ldr	r3, [r7, #28]
34187664:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187668:	f023 0220 	bic.w	r2, r3, #32
3418766c:	69fb      	ldr	r3, [r7, #28]
3418766e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34187672:	69fb      	ldr	r3, [r7, #28]
34187674:	2220      	movs	r2, #32
34187676:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3418767a:	2101      	movs	r1, #1
3418767c:	6878      	ldr	r0, [r7, #4]
3418767e:	f000 fae7 	bl	34187c50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34187682:	69bb      	ldr	r3, [r7, #24]
34187684:	f003 0310 	and.w	r3, r3, #16
34187688:	2b00      	cmp	r3, #0
3418768a:	d01c      	beq.n	341876c6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
3418768c:	693b      	ldr	r3, [r7, #16]
3418768e:	f003 0310 	and.w	r3, r3, #16
34187692:	2b00      	cmp	r3, #0
34187694:	d017      	beq.n	341876c6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34187696:	687b      	ldr	r3, [r7, #4]
34187698:	681b      	ldr	r3, [r3, #0]
3418769a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3418769e:	f003 0304 	and.w	r3, r3, #4
341876a2:	2b04      	cmp	r3, #4
341876a4:	d107      	bne.n	341876b6 <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
341876a6:	69fb      	ldr	r3, [r7, #28]
341876a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341876ac:	f023 0210 	bic.w	r2, r3, #16
341876b0:	69fb      	ldr	r3, [r7, #28]
341876b2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
341876b6:	69fb      	ldr	r3, [r7, #28]
341876b8:	2210      	movs	r2, #16
341876ba:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
341876be:	2100      	movs	r1, #0
341876c0:	6878      	ldr	r0, [r7, #4]
341876c2:	f000 fac5 	bl	34187c50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
341876c6:	69bb      	ldr	r3, [r7, #24]
341876c8:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
341876cc:	2b00      	cmp	r3, #0
341876ce:	d01a      	beq.n	34187706 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
341876d0:	693b      	ldr	r3, [r7, #16]
341876d2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
341876d6:	2b00      	cmp	r3, #0
341876d8:	d015      	beq.n	34187706 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
341876da:	69fb      	ldr	r3, [r7, #28]
341876dc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341876e0:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
341876e4:	69fb      	ldr	r3, [r7, #28]
341876e6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
341876ea:	69fb      	ldr	r3, [r7, #28]
341876ec:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
341876f0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
341876f4:	687b      	ldr	r3, [r7, #4]
341876f6:	689b      	ldr	r3, [r3, #8]
341876f8:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
341876fc:	687b      	ldr	r3, [r7, #4]
341876fe:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187700:	6878      	ldr	r0, [r7, #4]
34187702:	f000 fa66 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
34187706:	69bb      	ldr	r3, [r7, #24]
34187708:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3418770c:	2b00      	cmp	r3, #0
3418770e:	d01a      	beq.n	34187746 <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
34187710:	693b      	ldr	r3, [r7, #16]
34187712:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34187716:	2b00      	cmp	r3, #0
34187718:	d015      	beq.n	34187746 <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
3418771a:	69fb      	ldr	r3, [r7, #28]
3418771c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187720:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
34187724:	69fb      	ldr	r3, [r7, #28]
34187726:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
3418772a:	69fb      	ldr	r3, [r7, #28]
3418772c:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34187730:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34187734:	687b      	ldr	r3, [r7, #4]
34187736:	689b      	ldr	r3, [r3, #8]
34187738:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
3418773c:	687b      	ldr	r3, [r7, #4]
3418773e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187740:	6878      	ldr	r0, [r7, #4]
34187742:	f000 fa46 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34187746:	69bb      	ldr	r3, [r7, #24]
34187748:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3418774c:	2b00      	cmp	r3, #0
3418774e:	d01a      	beq.n	34187786 <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34187750:	693b      	ldr	r3, [r7, #16]
34187752:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34187756:	2b00      	cmp	r3, #0
34187758:	d015      	beq.n	34187786 <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
3418775a:	69fb      	ldr	r3, [r7, #28]
3418775c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187760:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34187764:	69fb      	ldr	r3, [r7, #28]
34187766:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
3418776a:	69fb      	ldr	r3, [r7, #28]
3418776c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34187770:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34187774:	687b      	ldr	r3, [r7, #4]
34187776:	689b      	ldr	r3, [r3, #8]
34187778:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
3418777c:	687b      	ldr	r3, [r7, #4]
3418777e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187780:	6878      	ldr	r0, [r7, #4]
34187782:	f000 fa26 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34187786:	69bb      	ldr	r3, [r7, #24]
34187788:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418778c:	2b00      	cmp	r3, #0
3418778e:	d01a      	beq.n	341877c6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34187790:	693b      	ldr	r3, [r7, #16]
34187792:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34187796:	2b00      	cmp	r3, #0
34187798:	d015      	beq.n	341877c6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
3418779a:	69fb      	ldr	r3, [r7, #28]
3418779c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341877a0:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
341877a4:	69fb      	ldr	r3, [r7, #28]
341877a6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
341877aa:	69fb      	ldr	r3, [r7, #28]
341877ac:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
341877b0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
341877b4:	687b      	ldr	r3, [r7, #4]
341877b6:	689b      	ldr	r3, [r3, #8]
341877b8:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
341877bc:	687b      	ldr	r3, [r7, #4]
341877be:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
341877c0:	6878      	ldr	r0, [r7, #4]
341877c2:	f000 fa06 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
341877c6:	69bb      	ldr	r3, [r7, #24]
341877c8:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
341877cc:	2b00      	cmp	r3, #0
341877ce:	d01a      	beq.n	34187806 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
341877d0:	693b      	ldr	r3, [r7, #16]
341877d2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
341877d6:	2b00      	cmp	r3, #0
341877d8:	d015      	beq.n	34187806 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
341877da:	69fb      	ldr	r3, [r7, #28]
341877dc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341877e0:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
341877e4:	69fb      	ldr	r3, [r7, #28]
341877e6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
341877ea:	69fb      	ldr	r3, [r7, #28]
341877ec:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
341877f0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
341877f4:	687b      	ldr	r3, [r7, #4]
341877f6:	689b      	ldr	r3, [r3, #8]
341877f8:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
341877fc:	687b      	ldr	r3, [r7, #4]
341877fe:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187800:	6878      	ldr	r0, [r7, #4]
34187802:	f000 f9e6 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34187806:	69bb      	ldr	r3, [r7, #24]
34187808:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3418780c:	2b00      	cmp	r3, #0
3418780e:	d01a      	beq.n	34187846 <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
34187810:	693b      	ldr	r3, [r7, #16]
34187812:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34187816:	2b00      	cmp	r3, #0
34187818:	d015      	beq.n	34187846 <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
3418781a:	69fb      	ldr	r3, [r7, #28]
3418781c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187820:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34187824:	69fb      	ldr	r3, [r7, #28]
34187826:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
3418782a:	69fb      	ldr	r3, [r7, #28]
3418782c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34187830:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34187834:	687b      	ldr	r3, [r7, #4]
34187836:	689b      	ldr	r3, [r3, #8]
34187838:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
3418783c:	687b      	ldr	r3, [r7, #4]
3418783e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187840:	6878      	ldr	r0, [r7, #4]
34187842:	f000 f9c6 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34187846:	69bb      	ldr	r3, [r7, #24]
34187848:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418784c:	2b00      	cmp	r3, #0
3418784e:	d01a      	beq.n	34187886 <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34187850:	693b      	ldr	r3, [r7, #16]
34187852:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34187856:	2b00      	cmp	r3, #0
34187858:	d015      	beq.n	34187886 <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
3418785a:	69fb      	ldr	r3, [r7, #28]
3418785c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187860:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34187864:	69fb      	ldr	r3, [r7, #28]
34187866:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
3418786a:	69fb      	ldr	r3, [r7, #28]
3418786c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34187870:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34187874:	687b      	ldr	r3, [r7, #4]
34187876:	689b      	ldr	r3, [r3, #8]
34187878:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
3418787c:	687b      	ldr	r3, [r7, #4]
3418787e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34187880:	6878      	ldr	r0, [r7, #4]
34187882:	f000 f9a6 	bl	34187bd2 <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34187886:	697b      	ldr	r3, [r7, #20]
34187888:	f003 0301 	and.w	r3, r3, #1
3418788c:	2b00      	cmp	r3, #0
3418788e:	d01d      	beq.n	341878cc <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34187890:	68fb      	ldr	r3, [r7, #12]
34187892:	f003 0301 	and.w	r3, r3, #1
34187896:	2b00      	cmp	r3, #0
34187898:	d018      	beq.n	341878cc <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
3418789a:	69fb      	ldr	r3, [r7, #28]
3418789c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341878a0:	f023 0201 	bic.w	r2, r3, #1
341878a4:	69fb      	ldr	r3, [r7, #28]
341878a6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
341878aa:	69fb      	ldr	r3, [r7, #28]
341878ac:	2201      	movs	r2, #1
341878ae:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
341878b2:	687b      	ldr	r3, [r7, #4]
341878b4:	689b      	ldr	r3, [r3, #8]
341878b6:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
341878ba:	687b      	ldr	r3, [r7, #4]
341878bc:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
341878be:	687b      	ldr	r3, [r7, #4]
341878c0:	2204      	movs	r2, #4
341878c2:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
341878c4:	2101      	movs	r1, #1
341878c6:	6878      	ldr	r0, [r7, #4]
341878c8:	f000 f98d 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
341878cc:	697b      	ldr	r3, [r7, #20]
341878ce:	f003 0302 	and.w	r3, r3, #2
341878d2:	2b00      	cmp	r3, #0
341878d4:	d01d      	beq.n	34187912 <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
341878d6:	68fb      	ldr	r3, [r7, #12]
341878d8:	f003 0302 	and.w	r3, r3, #2
341878dc:	2b00      	cmp	r3, #0
341878de:	d018      	beq.n	34187912 <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
341878e0:	69fb      	ldr	r3, [r7, #28]
341878e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341878e6:	f023 0202 	bic.w	r2, r3, #2
341878ea:	69fb      	ldr	r3, [r7, #28]
341878ec:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
341878f0:	69fb      	ldr	r3, [r7, #28]
341878f2:	2202      	movs	r2, #2
341878f4:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
341878f8:	687b      	ldr	r3, [r7, #4]
341878fa:	689b      	ldr	r3, [r3, #8]
341878fc:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34187900:	687b      	ldr	r3, [r7, #4]
34187902:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34187904:	687b      	ldr	r3, [r7, #4]
34187906:	2204      	movs	r2, #4
34187908:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418790a:	2101      	movs	r1, #1
3418790c:	6878      	ldr	r0, [r7, #4]
3418790e:	f000 f96a 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34187912:	697b      	ldr	r3, [r7, #20]
34187914:	f003 0304 	and.w	r3, r3, #4
34187918:	2b00      	cmp	r3, #0
3418791a:	d01a      	beq.n	34187952 <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
3418791c:	68fb      	ldr	r3, [r7, #12]
3418791e:	f003 0304 	and.w	r3, r3, #4
34187922:	2b00      	cmp	r3, #0
34187924:	d015      	beq.n	34187952 <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34187926:	69fb      	ldr	r3, [r7, #28]
34187928:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418792c:	f023 0204 	bic.w	r2, r3, #4
34187930:	69fb      	ldr	r3, [r7, #28]
34187932:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34187936:	69fb      	ldr	r3, [r7, #28]
34187938:	2204      	movs	r2, #4
3418793a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
3418793e:	687b      	ldr	r3, [r7, #4]
34187940:	689b      	ldr	r3, [r3, #8]
34187942:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34187946:	687b      	ldr	r3, [r7, #4]
34187948:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418794a:	2101      	movs	r1, #1
3418794c:	6878      	ldr	r0, [r7, #4]
3418794e:	f000 f94a 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34187952:	697b      	ldr	r3, [r7, #20]
34187954:	f003 0308 	and.w	r3, r3, #8
34187958:	2b00      	cmp	r3, #0
3418795a:	d01a      	beq.n	34187992 <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
3418795c:	68fb      	ldr	r3, [r7, #12]
3418795e:	f003 0308 	and.w	r3, r3, #8
34187962:	2b00      	cmp	r3, #0
34187964:	d015      	beq.n	34187992 <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34187966:	69fb      	ldr	r3, [r7, #28]
34187968:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418796c:	f023 0208 	bic.w	r2, r3, #8
34187970:	69fb      	ldr	r3, [r7, #28]
34187972:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
34187976:	69fb      	ldr	r3, [r7, #28]
34187978:	2208      	movs	r2, #8
3418797a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
3418797e:	687b      	ldr	r3, [r7, #4]
34187980:	689b      	ldr	r3, [r3, #8]
34187982:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34187986:	687b      	ldr	r3, [r7, #4]
34187988:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3418798a:	2101      	movs	r1, #1
3418798c:	6878      	ldr	r0, [r7, #4]
3418798e:	f000 f92a 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34187992:	697b      	ldr	r3, [r7, #20]
34187994:	f003 0310 	and.w	r3, r3, #16
34187998:	2b00      	cmp	r3, #0
3418799a:	d01a      	beq.n	341879d2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
3418799c:	68fb      	ldr	r3, [r7, #12]
3418799e:	f003 0310 	and.w	r3, r3, #16
341879a2:	2b00      	cmp	r3, #0
341879a4:	d015      	beq.n	341879d2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
341879a6:	69fb      	ldr	r3, [r7, #28]
341879a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341879ac:	f023 0210 	bic.w	r2, r3, #16
341879b0:	69fb      	ldr	r3, [r7, #28]
341879b2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
341879b6:	69fb      	ldr	r3, [r7, #28]
341879b8:	2210      	movs	r2, #16
341879ba:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
341879be:	687b      	ldr	r3, [r7, #4]
341879c0:	689b      	ldr	r3, [r3, #8]
341879c2:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
341879c6:	687b      	ldr	r3, [r7, #4]
341879c8:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
341879ca:	2101      	movs	r1, #1
341879cc:	6878      	ldr	r0, [r7, #4]
341879ce:	f000 f90a 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
341879d2:	697b      	ldr	r3, [r7, #20]
341879d4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341879d8:	2b00      	cmp	r3, #0
341879da:	d01e      	beq.n	34187a1a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
341879dc:	68fb      	ldr	r3, [r7, #12]
341879de:	f403 7380 	and.w	r3, r3, #256	@ 0x100
341879e2:	2b00      	cmp	r3, #0
341879e4:	d019      	beq.n	34187a1a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
341879e6:	69fb      	ldr	r3, [r7, #28]
341879e8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
341879ec:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
341879f0:	69fb      	ldr	r3, [r7, #28]
341879f2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
341879f6:	69fb      	ldr	r3, [r7, #28]
341879f8:	f44f 7280 	mov.w	r2, #256	@ 0x100
341879fc:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34187a00:	687b      	ldr	r3, [r7, #4]
34187a02:	689b      	ldr	r3, [r3, #8]
34187a04:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
34187a08:	687b      	ldr	r3, [r7, #4]
34187a0a:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34187a0c:	687b      	ldr	r3, [r7, #4]
34187a0e:	2204      	movs	r2, #4
34187a10:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34187a12:	2102      	movs	r1, #2
34187a14:	6878      	ldr	r0, [r7, #4]
34187a16:	f000 f8e6 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34187a1a:	697b      	ldr	r3, [r7, #20]
34187a1c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34187a20:	2b00      	cmp	r3, #0
34187a22:	d01e      	beq.n	34187a62 <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34187a24:	68fb      	ldr	r3, [r7, #12]
34187a26:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34187a2a:	2b00      	cmp	r3, #0
34187a2c:	d019      	beq.n	34187a62 <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34187a2e:	69fb      	ldr	r3, [r7, #28]
34187a30:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187a34:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34187a38:	69fb      	ldr	r3, [r7, #28]
34187a3a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
34187a3e:	69fb      	ldr	r3, [r7, #28]
34187a40:	f44f 7200 	mov.w	r2, #512	@ 0x200
34187a44:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34187a48:	687b      	ldr	r3, [r7, #4]
34187a4a:	689b      	ldr	r3, [r3, #8]
34187a4c:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34187a50:	687b      	ldr	r3, [r7, #4]
34187a52:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34187a54:	687b      	ldr	r3, [r7, #4]
34187a56:	2204      	movs	r2, #4
34187a58:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34187a5a:	2102      	movs	r1, #2
34187a5c:	6878      	ldr	r0, [r7, #4]
34187a5e:	f000 f8c2 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34187a62:	697b      	ldr	r3, [r7, #20]
34187a64:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34187a68:	2b00      	cmp	r3, #0
34187a6a:	d01b      	beq.n	34187aa4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34187a6c:	68fb      	ldr	r3, [r7, #12]
34187a6e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34187a72:	2b00      	cmp	r3, #0
34187a74:	d016      	beq.n	34187aa4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34187a76:	69fb      	ldr	r3, [r7, #28]
34187a78:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187a7c:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34187a80:	69fb      	ldr	r3, [r7, #28]
34187a82:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
34187a86:	69fb      	ldr	r3, [r7, #28]
34187a88:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34187a8c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34187a90:	687b      	ldr	r3, [r7, #4]
34187a92:	689b      	ldr	r3, [r3, #8]
34187a94:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34187a98:	687b      	ldr	r3, [r7, #4]
34187a9a:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34187a9c:	2102      	movs	r1, #2
34187a9e:	6878      	ldr	r0, [r7, #4]
34187aa0:	f000 f8a1 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34187aa4:	697b      	ldr	r3, [r7, #20]
34187aa6:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34187aaa:	2b00      	cmp	r3, #0
34187aac:	d01b      	beq.n	34187ae6 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34187aae:	68fb      	ldr	r3, [r7, #12]
34187ab0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34187ab4:	2b00      	cmp	r3, #0
34187ab6:	d016      	beq.n	34187ae6 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34187ab8:	69fb      	ldr	r3, [r7, #28]
34187aba:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187abe:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34187ac2:	69fb      	ldr	r3, [r7, #28]
34187ac4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
34187ac8:	69fb      	ldr	r3, [r7, #28]
34187aca:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34187ace:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34187ad2:	687b      	ldr	r3, [r7, #4]
34187ad4:	689b      	ldr	r3, [r3, #8]
34187ad6:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34187ada:	687b      	ldr	r3, [r7, #4]
34187adc:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34187ade:	2102      	movs	r1, #2
34187ae0:	6878      	ldr	r0, [r7, #4]
34187ae2:	f000 f880 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34187ae6:	697b      	ldr	r3, [r7, #20]
34187ae8:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34187aec:	2b00      	cmp	r3, #0
34187aee:	d01b      	beq.n	34187b28 <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34187af0:	68fb      	ldr	r3, [r7, #12]
34187af2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34187af6:	2b00      	cmp	r3, #0
34187af8:	d016      	beq.n	34187b28 <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34187afa:	69fb      	ldr	r3, [r7, #28]
34187afc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187b00:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34187b04:	69fb      	ldr	r3, [r7, #28]
34187b06:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34187b0a:	69fb      	ldr	r3, [r7, #28]
34187b0c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34187b10:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34187b14:	687b      	ldr	r3, [r7, #4]
34187b16:	689b      	ldr	r3, [r3, #8]
34187b18:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34187b1c:	687b      	ldr	r3, [r7, #4]
34187b1e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34187b20:	2102      	movs	r1, #2
34187b22:	6878      	ldr	r0, [r7, #4]
34187b24:	f000 f85f 	bl	34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34187b28:	69bb      	ldr	r3, [r7, #24]
34187b2a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34187b2e:	2b00      	cmp	r3, #0
34187b30:	d014      	beq.n	34187b5c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
34187b32:	693b      	ldr	r3, [r7, #16]
34187b34:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34187b38:	2b00      	cmp	r3, #0
34187b3a:	d00f      	beq.n	34187b5c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34187b3c:	69fb      	ldr	r3, [r7, #28]
34187b3e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34187b42:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
34187b46:	69fb      	ldr	r3, [r7, #28]
34187b48:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34187b4c:	69fb      	ldr	r3, [r7, #28]
34187b4e:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34187b52:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34187b56:	6878      	ldr	r0, [r7, #4]
34187b58:	f000 f85a 	bl	34187c10 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34187b5c:	bf00      	nop
34187b5e:	3720      	adds	r7, #32
34187b60:	46bd      	mov	sp, r7
34187b62:	bd80      	pop	{r7, pc}

34187b64 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187b64:	b480      	push	{r7}
34187b66:	b083      	sub	sp, #12
34187b68:	af00      	add	r7, sp, #0
34187b6a:	6078      	str	r0, [r7, #4]
34187b6c:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_FrameEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34187b6e:	bf00      	nop
34187b70:	370c      	adds	r7, #12
34187b72:	46bd      	mov	sp, r7
34187b74:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b78:	4770      	bx	lr

34187b7a <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187b7a:	b480      	push	{r7}
34187b7c:	b083      	sub	sp, #12
34187b7e:	af00      	add	r7, sp, #0
34187b80:	6078      	str	r0, [r7, #4]
34187b82:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_VsyncEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34187b84:	bf00      	nop
34187b86:	370c      	adds	r7, #12
34187b88:	46bd      	mov	sp, r7
34187b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34187b8e:	4770      	bx	lr

34187b90 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187b90:	b480      	push	{r7}
34187b92:	b083      	sub	sp, #12
34187b94:	af00      	add	r7, sp, #0
34187b96:	6078      	str	r0, [r7, #4]
34187b98:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34187b9a:	bf00      	nop
34187b9c:	370c      	adds	r7, #12
34187b9e:	46bd      	mov	sp, r7
34187ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
34187ba4:	4770      	bx	lr

34187ba6 <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187ba6:	b480      	push	{r7}
34187ba8:	b083      	sub	sp, #12
34187baa:	af00      	add	r7, sp, #0
34187bac:	6078      	str	r0, [r7, #4]
34187bae:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34187bb0:	bf00      	nop
34187bb2:	370c      	adds	r7, #12
34187bb4:	46bd      	mov	sp, r7
34187bb6:	f85d 7b04 	ldr.w	r7, [sp], #4
34187bba:	4770      	bx	lr

34187bbc <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187bbc:	b480      	push	{r7}
34187bbe:	b083      	sub	sp, #12
34187bc0:	af00      	add	r7, sp, #0
34187bc2:	6078      	str	r0, [r7, #4]
34187bc4:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34187bc6:	bf00      	nop
34187bc8:	370c      	adds	r7, #12
34187bca:	46bd      	mov	sp, r7
34187bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
34187bd0:	4770      	bx	lr

34187bd2 <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34187bd2:	b480      	push	{r7}
34187bd4:	b083      	sub	sp, #12
34187bd6:	af00      	add	r7, sp, #0
34187bd8:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
34187bda:	bf00      	nop
34187bdc:	370c      	adds	r7, #12
34187bde:	46bd      	mov	sp, r7
34187be0:	f85d 7b04 	ldr.w	r7, [sp], #4
34187be4:	4770      	bx	lr

34187be6 <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
34187be6:	b480      	push	{r7}
34187be8:	b083      	sub	sp, #12
34187bea:	af00      	add	r7, sp, #0
34187bec:	6078      	str	r0, [r7, #4]
34187bee:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
34187bf0:	bf00      	nop
34187bf2:	370c      	adds	r7, #12
34187bf4:	46bd      	mov	sp, r7
34187bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
34187bfa:	4770      	bx	lr

34187bfc <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34187bfc:	b480      	push	{r7}
34187bfe:	b083      	sub	sp, #12
34187c00:	af00      	add	r7, sp, #0
34187c02:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34187c04:	bf00      	nop
34187c06:	370c      	adds	r7, #12
34187c08:	46bd      	mov	sp, r7
34187c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c0e:	4770      	bx	lr

34187c10 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34187c10:	b480      	push	{r7}
34187c12:	b083      	sub	sp, #12
34187c14:	af00      	add	r7, sp, #0
34187c16:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34187c18:	bf00      	nop
34187c1a:	370c      	adds	r7, #12
34187c1c:	46bd      	mov	sp, r7
34187c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c22:	4770      	bx	lr

34187c24 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34187c24:	b480      	push	{r7}
34187c26:	b083      	sub	sp, #12
34187c28:	af00      	add	r7, sp, #0
34187c2a:	6078      	str	r0, [r7, #4]
34187c2c:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34187c2e:	bf00      	nop
34187c30:	370c      	adds	r7, #12
34187c32:	46bd      	mov	sp, r7
34187c34:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c38:	4770      	bx	lr

34187c3a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34187c3a:	b480      	push	{r7}
34187c3c:	b083      	sub	sp, #12
34187c3e:	af00      	add	r7, sp, #0
34187c40:	6078      	str	r0, [r7, #4]
34187c42:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34187c44:	bf00      	nop
34187c46:	370c      	adds	r7, #12
34187c48:	46bd      	mov	sp, r7
34187c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c4e:	4770      	bx	lr

34187c50 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
34187c50:	b480      	push	{r7}
34187c52:	b083      	sub	sp, #12
34187c54:	af00      	add	r7, sp, #0
34187c56:	6078      	str	r0, [r7, #4]
34187c58:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
34187c5a:	bf00      	nop
34187c5c:	370c      	adds	r7, #12
34187c5e:	46bd      	mov	sp, r7
34187c60:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c64:	4770      	bx	lr

34187c66 <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
34187c66:	b480      	push	{r7}
34187c68:	b083      	sub	sp, #12
34187c6a:	af00      	add	r7, sp, #0
34187c6c:	6078      	str	r0, [r7, #4]
34187c6e:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
34187c70:	bf00      	nop
34187c72:	370c      	adds	r7, #12
34187c74:	46bd      	mov	sp, r7
34187c76:	f85d 7b04 	ldr.w	r7, [sp], #4
34187c7a:	4770      	bx	lr

34187c7c <HAL_DCMIPP_PIPE_SetCropConfig>:
  *                     the configuration information for Crop.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetCropConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CropConfTypeDef *pCropConfig)
{
34187c7c:	b480      	push	{r7}
34187c7e:	b087      	sub	sp, #28
34187c80:	af00      	add	r7, sp, #0
34187c82:	60f8      	str	r0, [r7, #12]
34187c84:	60b9      	str	r1, [r7, #8]
34187c86:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
34187c88:	68fb      	ldr	r3, [r7, #12]
34187c8a:	2b00      	cmp	r3, #0
34187c8c:	d002      	beq.n	34187c94 <HAL_DCMIPP_PIPE_SetCropConfig+0x18>
34187c8e:	687b      	ldr	r3, [r7, #4]
34187c90:	2b00      	cmp	r3, #0
34187c92:	d101      	bne.n	34187c98 <HAL_DCMIPP_PIPE_SetCropConfig+0x1c>
  {
    return HAL_ERROR;
34187c94:	2301      	movs	r3, #1
34187c96:	e090      	b.n	34187dba <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187c98:	68fb      	ldr	r3, [r7, #12]
34187c9a:	791b      	ldrb	r3, [r3, #4]
34187c9c:	b2db      	uxtb	r3, r3
34187c9e:	2b02      	cmp	r3, #2
34187ca0:	f040 8088 	bne.w	34187db4 <HAL_DCMIPP_PIPE_SetCropConfig+0x138>
  {

    if (Pipe == DCMIPP_PIPE0)
34187ca4:	68bb      	ldr	r3, [r7, #8]
34187ca6:	2b00      	cmp	r3, #0
34187ca8:	d136      	bne.n	34187d18 <HAL_DCMIPP_PIPE_SetCropConfig+0x9c>
    {
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34187caa:	68fb      	ldr	r3, [r7, #12]
34187cac:	681b      	ldr	r3, [r3, #0]
34187cae:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34187cb2:	617b      	str	r3, [r7, #20]

      /* Verify for parallel mode with jpeg format , no Line Crop enable  */
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34187cb4:	697b      	ldr	r3, [r7, #20]
34187cb6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34187cba:	2b00      	cmp	r3, #0
34187cbc:	d006      	beq.n	34187ccc <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
34187cbe:	697b      	ldr	r3, [r7, #20]
34187cc0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34187cc4:	2b00      	cmp	r3, #0
34187cc6:	d101      	bne.n	34187ccc <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
      {
        return HAL_ERROR;
34187cc8:	2301      	movs	r3, #1
34187cca:	e076      	b.n	34187dba <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
      }
      else
      {
        /* Set Cropping horizontal and vertical start for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34187ccc:	68fb      	ldr	r3, [r7, #12]
34187cce:	681b      	ldr	r3, [r3, #0]
34187cd0:	f8d3 3504 	ldr.w	r3, [r3, #1284]	@ 0x504
34187cd4:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34187cd8:	687b      	ldr	r3, [r7, #4]
34187cda:	685a      	ldr	r2, [r3, #4]
34187cdc:	687b      	ldr	r3, [r7, #4]
34187cde:	681b      	ldr	r3, [r3, #0]
34187ce0:	041b      	lsls	r3, r3, #16
34187ce2:	431a      	orrs	r2, r3
34187ce4:	68fb      	ldr	r3, [r7, #12]
34187ce6:	681b      	ldr	r3, [r3, #0]
34187ce8:	430a      	orrs	r2, r1
34187cea:	f8c3 2504 	str.w	r2, [r3, #1284]	@ 0x504
                   (pCropConfig->HStart << DCMIPP_P0SCSTR_HSTART_Pos) |
                   (pCropConfig->VStart << DCMIPP_P0SCSTR_VSTART_Pos));

        /* Set Cropping horizontal and vertical width for Pipe0 */
        /* Set crop Area (Inner or outer) for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34187cee:	68fb      	ldr	r3, [r7, #12]
34187cf0:	681b      	ldr	r3, [r3, #0]
34187cf2:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34187cf6:	4b34      	ldr	r3, [pc, #208]	@ (34187dc8 <HAL_DCMIPP_PIPE_SetCropConfig+0x14c>)
34187cf8:	4013      	ands	r3, r2
34187cfa:	687a      	ldr	r2, [r7, #4]
34187cfc:	68d1      	ldr	r1, [r2, #12]
34187cfe:	687a      	ldr	r2, [r7, #4]
34187d00:	6892      	ldr	r2, [r2, #8]
34187d02:	0412      	lsls	r2, r2, #16
34187d04:	4311      	orrs	r1, r2
34187d06:	687a      	ldr	r2, [r7, #4]
34187d08:	6912      	ldr	r2, [r2, #16]
34187d0a:	4311      	orrs	r1, r2
34187d0c:	68fa      	ldr	r2, [r7, #12]
34187d0e:	6812      	ldr	r2, [r2, #0]
34187d10:	430b      	orrs	r3, r1
34187d12:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
34187d16:	e04f      	b.n	34187db8 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                   (pCropConfig->HSize << DCMIPP_P0SCSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P0SCSZR_VSIZE_Pos) |
                   (pCropConfig->PipeArea));
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34187d18:	68bb      	ldr	r3, [r7, #8]
34187d1a:	2b01      	cmp	r3, #1
34187d1c:	d122      	bne.n	34187d64 <HAL_DCMIPP_PIPE_SetCropConfig+0xe8>
    {
      /* Set Cropping horizontal and vertical start for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34187d1e:	68fb      	ldr	r3, [r7, #12]
34187d20:	681b      	ldr	r3, [r3, #0]
34187d22:	f8d3 3904 	ldr.w	r3, [r3, #2308]	@ 0x904
34187d26:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34187d2a:	687b      	ldr	r3, [r7, #4]
34187d2c:	685a      	ldr	r2, [r3, #4]
34187d2e:	687b      	ldr	r3, [r7, #4]
34187d30:	681b      	ldr	r3, [r3, #0]
34187d32:	041b      	lsls	r3, r3, #16
34187d34:	431a      	orrs	r2, r3
34187d36:	68fb      	ldr	r3, [r7, #12]
34187d38:	681b      	ldr	r3, [r3, #0]
34187d3a:	430a      	orrs	r2, r1
34187d3c:	f8c3 2904 	str.w	r2, [r3, #2308]	@ 0x904
                 (pCropConfig->HStart << DCMIPP_P1CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P1CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34187d40:	68fb      	ldr	r3, [r7, #12]
34187d42:	681b      	ldr	r3, [r3, #0]
34187d44:	f8d3 3908 	ldr.w	r3, [r3, #2312]	@ 0x908
34187d48:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34187d4c:	687b      	ldr	r3, [r7, #4]
34187d4e:	68da      	ldr	r2, [r3, #12]
34187d50:	687b      	ldr	r3, [r7, #4]
34187d52:	689b      	ldr	r3, [r3, #8]
34187d54:	041b      	lsls	r3, r3, #16
34187d56:	431a      	orrs	r2, r3
34187d58:	68fb      	ldr	r3, [r7, #12]
34187d5a:	681b      	ldr	r3, [r3, #0]
34187d5c:	430a      	orrs	r2, r1
34187d5e:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34187d62:	e029      	b.n	34187db8 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P1CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P1CRSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
34187d64:	68bb      	ldr	r3, [r7, #8]
34187d66:	2b02      	cmp	r3, #2
34187d68:	d122      	bne.n	34187db0 <HAL_DCMIPP_PIPE_SetCropConfig+0x134>
    {
      /* Set Cropping horizontal and vertical start for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
34187d6a:	68fb      	ldr	r3, [r7, #12]
34187d6c:	681b      	ldr	r3, [r3, #0]
34187d6e:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
34187d72:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34187d76:	687b      	ldr	r3, [r7, #4]
34187d78:	685a      	ldr	r2, [r3, #4]
34187d7a:	687b      	ldr	r3, [r7, #4]
34187d7c:	681b      	ldr	r3, [r3, #0]
34187d7e:	041b      	lsls	r3, r3, #16
34187d80:	431a      	orrs	r2, r3
34187d82:	68fb      	ldr	r3, [r7, #12]
34187d84:	681b      	ldr	r3, [r3, #0]
34187d86:	430a      	orrs	r2, r1
34187d88:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
                 (pCropConfig->HStart << DCMIPP_P2CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P2CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
34187d8c:	68fb      	ldr	r3, [r7, #12]
34187d8e:	681b      	ldr	r3, [r3, #0]
34187d90:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	@ 0xd08
34187d94:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34187d98:	687b      	ldr	r3, [r7, #4]
34187d9a:	68da      	ldr	r2, [r3, #12]
34187d9c:	687b      	ldr	r3, [r7, #4]
34187d9e:	689b      	ldr	r3, [r3, #8]
34187da0:	041b      	lsls	r3, r3, #16
34187da2:	431a      	orrs	r2, r3
34187da4:	68fb      	ldr	r3, [r7, #12]
34187da6:	681b      	ldr	r3, [r3, #0]
34187da8:	430a      	orrs	r2, r1
34187daa:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34187dae:	e003      	b.n	34187db8 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P2CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P2CRSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
34187db0:	2301      	movs	r3, #1
34187db2:	e002      	b.n	34187dba <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
    }
  }
  else
  {
    return HAL_ERROR;
34187db4:	2301      	movs	r3, #1
34187db6:	e000      	b.n	34187dba <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  }

  return HAL_OK;
34187db8:	2300      	movs	r3, #0
}
34187dba:	4618      	mov	r0, r3
34187dbc:	371c      	adds	r7, #28
34187dbe:	46bd      	mov	sp, r7
34187dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
34187dc4:	4770      	bx	lr
34187dc6:	bf00      	nop
34187dc8:	b000f000 	.word	0xb000f000

34187dcc <HAL_DCMIPP_PIPE_EnableCrop>:
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @note   Cropping cannot be enabled in parallel mode with JPEG Format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187dcc:	b480      	push	{r7}
34187dce:	b085      	sub	sp, #20
34187dd0:	af00      	add	r7, sp, #0
34187dd2:	6078      	str	r0, [r7, #4]
34187dd4:	6039      	str	r1, [r7, #0]
  uint32_t tmp;

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34187dd6:	687b      	ldr	r3, [r7, #4]
34187dd8:	2b00      	cmp	r3, #0
34187dda:	d101      	bne.n	34187de0 <HAL_DCMIPP_PIPE_EnableCrop+0x14>
  {
    return HAL_ERROR;
34187ddc:	2301      	movs	r3, #1
34187dde:	e04d      	b.n	34187e7c <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187de0:	687b      	ldr	r3, [r7, #4]
34187de2:	791b      	ldrb	r3, [r3, #4]
34187de4:	b2db      	uxtb	r3, r3
34187de6:	2b02      	cmp	r3, #2
34187de8:	d145      	bne.n	34187e76 <HAL_DCMIPP_PIPE_EnableCrop+0xaa>
  {
    if (Pipe == DCMIPP_PIPE0)
34187dea:	683b      	ldr	r3, [r7, #0]
34187dec:	2b00      	cmp	r3, #0
34187dee:	d11b      	bne.n	34187e28 <HAL_DCMIPP_PIPE_EnableCrop+0x5c>
    {
      /* This bit must be kept cleared if the input format is JPEG */
      /* Verify for parallel mode with jpeg format , no Line Crop enable  */

      tmp = READ_REG(hdcmipp->Instance->PRCR);
34187df0:	687b      	ldr	r3, [r7, #4]
34187df2:	681b      	ldr	r3, [r3, #0]
34187df4:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34187df8:	60fb      	str	r3, [r7, #12]

      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34187dfa:	68fb      	ldr	r3, [r7, #12]
34187dfc:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34187e00:	2b00      	cmp	r3, #0
34187e02:	d006      	beq.n	34187e12 <HAL_DCMIPP_PIPE_EnableCrop+0x46>
34187e04:	68fb      	ldr	r3, [r7, #12]
34187e06:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34187e0a:	2b00      	cmp	r3, #0
34187e0c:	d101      	bne.n	34187e12 <HAL_DCMIPP_PIPE_EnableCrop+0x46>
      {
        return HAL_ERROR;
34187e0e:	2301      	movs	r3, #1
34187e10:	e034      	b.n	34187e7c <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
      else
      {
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34187e12:	687b      	ldr	r3, [r7, #4]
34187e14:	681b      	ldr	r3, [r3, #0]
34187e16:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34187e1a:	687b      	ldr	r3, [r7, #4]
34187e1c:	681b      	ldr	r3, [r3, #0]
34187e1e:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34187e22:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
34187e26:	e028      	b.n	34187e7a <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34187e28:	683b      	ldr	r3, [r7, #0]
34187e2a:	2b01      	cmp	r3, #1
34187e2c:	d113      	bne.n	34187e56 <HAL_DCMIPP_PIPE_EnableCrop+0x8a>
    {
      /* Verify Crop line is disabled */
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34187e2e:	687b      	ldr	r3, [r7, #4]
34187e30:	681b      	ldr	r3, [r3, #0]
34187e32:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
34187e36:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34187e3a:	d00a      	beq.n	34187e52 <HAL_DCMIPP_PIPE_EnableCrop+0x86>
      {
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34187e3c:	687b      	ldr	r3, [r7, #4]
34187e3e:	681b      	ldr	r3, [r3, #0]
34187e40:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34187e44:	687b      	ldr	r3, [r7, #4]
34187e46:	681b      	ldr	r3, [r3, #0]
34187e48:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34187e4c:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34187e50:	e013      	b.n	34187e7a <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
      else
      {
        return HAL_ERROR;
34187e52:	2301      	movs	r3, #1
34187e54:	e012      	b.n	34187e7c <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
    }
    else if (Pipe == DCMIPP_PIPE2)
34187e56:	683b      	ldr	r3, [r7, #0]
34187e58:	2b02      	cmp	r3, #2
34187e5a:	d10a      	bne.n	34187e72 <HAL_DCMIPP_PIPE_EnableCrop+0xa6>
    {
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34187e5c:	687b      	ldr	r3, [r7, #4]
34187e5e:	681b      	ldr	r3, [r3, #0]
34187e60:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
34187e64:	687b      	ldr	r3, [r7, #4]
34187e66:	681b      	ldr	r3, [r3, #0]
34187e68:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34187e6c:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34187e70:	e003      	b.n	34187e7a <HAL_DCMIPP_PIPE_EnableCrop+0xae>
    }
    else
    {
      return HAL_ERROR;
34187e72:	2301      	movs	r3, #1
34187e74:	e002      	b.n	34187e7c <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
    }
  }
  else
  {
    return HAL_ERROR;
34187e76:	2301      	movs	r3, #1
34187e78:	e000      	b.n	34187e7c <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  return HAL_OK;
34187e7a:	2300      	movs	r3, #0
}
34187e7c:	4618      	mov	r0, r3
34187e7e:	3714      	adds	r7, #20
34187e80:	46bd      	mov	sp, r7
34187e82:	f85d 7b04 	ldr.w	r7, [sp], #4
34187e86:	4770      	bx	lr

34187e88 <HAL_DCMIPP_PIPE_DisableCrop>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187e88:	b480      	push	{r7}
34187e8a:	b083      	sub	sp, #12
34187e8c:	af00      	add	r7, sp, #0
34187e8e:	6078      	str	r0, [r7, #4]
34187e90:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34187e92:	687b      	ldr	r3, [r7, #4]
34187e94:	2b00      	cmp	r3, #0
34187e96:	d101      	bne.n	34187e9c <HAL_DCMIPP_PIPE_DisableCrop+0x14>
  {
    return HAL_ERROR;
34187e98:	2301      	movs	r3, #1
34187e9a:	e02c      	b.n	34187ef6 <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  if (Pipe == DCMIPP_PIPE0)
34187e9c:	683b      	ldr	r3, [r7, #0]
34187e9e:	2b00      	cmp	r3, #0
34187ea0:	d10a      	bne.n	34187eb8 <HAL_DCMIPP_PIPE_DisableCrop+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
34187ea2:	687b      	ldr	r3, [r7, #4]
34187ea4:	681b      	ldr	r3, [r3, #0]
34187ea6:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34187eaa:	687b      	ldr	r3, [r7, #4]
34187eac:	681b      	ldr	r3, [r3, #0]
34187eae:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34187eb2:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
34187eb6:	e01d      	b.n	34187ef4 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE1)
34187eb8:	683b      	ldr	r3, [r7, #0]
34187eba:	2b01      	cmp	r3, #1
34187ebc:	d10a      	bne.n	34187ed4 <HAL_DCMIPP_PIPE_DisableCrop+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34187ebe:	687b      	ldr	r3, [r7, #4]
34187ec0:	681b      	ldr	r3, [r3, #0]
34187ec2:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
34187ec6:	687b      	ldr	r3, [r7, #4]
34187ec8:	681b      	ldr	r3, [r3, #0]
34187eca:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34187ece:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
34187ed2:	e00f      	b.n	34187ef4 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE2)
34187ed4:	683b      	ldr	r3, [r7, #0]
34187ed6:	2b02      	cmp	r3, #2
34187ed8:	d10a      	bne.n	34187ef0 <HAL_DCMIPP_PIPE_DisableCrop+0x68>
  {
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34187eda:	687b      	ldr	r3, [r7, #4]
34187edc:	681b      	ldr	r3, [r3, #0]
34187ede:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
34187ee2:	687b      	ldr	r3, [r7, #4]
34187ee4:	681b      	ldr	r3, [r3, #0]
34187ee6:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34187eea:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34187eee:	e001      	b.n	34187ef4 <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else
  {
    return HAL_ERROR;
34187ef0:	2301      	movs	r3, #1
34187ef2:	e000      	b.n	34187ef6 <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  return HAL_OK;
34187ef4:	2300      	movs	r3, #0
}
34187ef6:	4618      	mov	r0, r3
34187ef8:	370c      	adds	r7, #12
34187efa:	46bd      	mov	sp, r7
34187efc:	f85d 7b04 	ldr.w	r7, [sp], #4
34187f00:	4770      	bx	lr

34187f02 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                         const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
34187f02:	b480      	push	{r7}
34187f04:	b085      	sub	sp, #20
34187f06:	af00      	add	r7, sp, #0
34187f08:	60f8      	str	r0, [r7, #12]
34187f0a:	60b9      	str	r1, [r7, #8]
34187f0c:	607a      	str	r2, [r7, #4]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34187f0e:	68fb      	ldr	r3, [r7, #12]
34187f10:	2b00      	cmp	r3, #0
34187f12:	d002      	beq.n	34187f1a <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x18>
34187f14:	687b      	ldr	r3, [r7, #4]
34187f16:	2b00      	cmp	r3, #0
34187f18:	d101      	bne.n	34187f1e <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x1c>
  {
    return HAL_ERROR;
34187f1a:	2301      	movs	r3, #1
34187f1c:	e01c      	b.n	34187f58 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
  }

  /* Set Decimation Type , Vertical and Horizontal Ratio */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187f1e:	68fb      	ldr	r3, [r7, #12]
34187f20:	791b      	ldrb	r3, [r3, #4]
34187f22:	b2db      	uxtb	r3, r3
34187f24:	2b02      	cmp	r3, #2
34187f26:	d116      	bne.n	34187f56 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x54>
  {
    if (Pipe == DCMIPP_PIPE1)
34187f28:	68bb      	ldr	r3, [r7, #8]
34187f2a:	2b01      	cmp	r3, #1
34187f2c:	d111      	bne.n	34187f52 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x50>
    {
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34187f2e:	68fb      	ldr	r3, [r7, #12]
34187f30:	681b      	ldr	r3, [r3, #0]
34187f32:	f8d3 3830 	ldr.w	r3, [r3, #2096]	@ 0x830
34187f36:	f023 011e 	bic.w	r1, r3, #30
34187f3a:	687b      	ldr	r3, [r7, #4]
34187f3c:	681a      	ldr	r2, [r3, #0]
34187f3e:	687b      	ldr	r3, [r7, #4]
34187f40:	685b      	ldr	r3, [r3, #4]
34187f42:	431a      	orrs	r2, r3
34187f44:	68fb      	ldr	r3, [r7, #12]
34187f46:	681b      	ldr	r3, [r3, #0]
34187f48:	430a      	orrs	r2, r1
34187f4a:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  {
    return HAL_ERROR;
  }


  return HAL_OK;
34187f4e:	2300      	movs	r3, #0
34187f50:	e002      	b.n	34187f58 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
      return HAL_ERROR;
34187f52:	2301      	movs	r3, #1
34187f54:	e000      	b.n	34187f58 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
    return HAL_ERROR;
34187f56:	2301      	movs	r3, #1
}
34187f58:	4618      	mov	r0, r3
34187f5a:	3714      	adds	r7, #20
34187f5c:	46bd      	mov	sp, r7
34187f5e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187f62:	4770      	bx	lr

34187f64 <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34187f64:	b480      	push	{r7}
34187f66:	b083      	sub	sp, #12
34187f68:	af00      	add	r7, sp, #0
34187f6a:	6078      	str	r0, [r7, #4]
34187f6c:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
34187f6e:	687b      	ldr	r3, [r7, #4]
34187f70:	2b00      	cmp	r3, #0
34187f72:	d101      	bne.n	34187f78 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
  {
    return HAL_ERROR;
34187f74:	2301      	movs	r3, #1
34187f76:	e00f      	b.n	34187f98 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
  }

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
34187f78:	683b      	ldr	r3, [r7, #0]
34187f7a:	2b01      	cmp	r3, #1
34187f7c:	d10b      	bne.n	34187f96 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
34187f7e:	687b      	ldr	r3, [r7, #4]
34187f80:	681b      	ldr	r3, [r3, #0]
34187f82:	f8d3 2830 	ldr.w	r2, [r3, #2096]	@ 0x830
34187f86:	687b      	ldr	r3, [r7, #4]
34187f88:	681b      	ldr	r3, [r3, #0]
34187f8a:	f042 0201 	orr.w	r2, r2, #1
34187f8e:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34187f92:	2300      	movs	r3, #0
34187f94:	e000      	b.n	34187f98 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
    return HAL_ERROR;
34187f96:	2301      	movs	r3, #1
}
34187f98:	4618      	mov	r0, r3
34187f9a:	370c      	adds	r7, #12
34187f9c:	46bd      	mov	sp, r7
34187f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34187fa2:	4770      	bx	lr

34187fa4 <HAL_DCMIPP_PIPE_SetDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                      const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
34187fa4:	b480      	push	{r7}
34187fa6:	b085      	sub	sp, #20
34187fa8:	af00      	add	r7, sp, #0
34187faa:	60f8      	str	r0, [r7, #12]
34187fac:	60b9      	str	r1, [r7, #8]
34187fae:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if (hdcmipp == NULL)
34187fb0:	68fb      	ldr	r3, [r7, #12]
34187fb2:	2b00      	cmp	r3, #0
34187fb4:	d101      	bne.n	34187fba <HAL_DCMIPP_PIPE_SetDecimationConfig+0x16>
  {
    return HAL_ERROR;
34187fb6:	2301      	movs	r3, #1
34187fb8:	e031      	b.n	3418801e <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34187fba:	68fb      	ldr	r3, [r7, #12]
34187fbc:	791b      	ldrb	r3, [r3, #4]
34187fbe:	b2db      	uxtb	r3, r3
34187fc0:	2b02      	cmp	r3, #2
34187fc2:	d129      	bne.n	34188018 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
  {
    /* Set Decimation Type , Vertical and Horizontal Ratio */
    if (Pipe == DCMIPP_PIPE1)
34187fc4:	68bb      	ldr	r3, [r7, #8]
34187fc6:	2b01      	cmp	r3, #1
34187fc8:	d110      	bne.n	34187fec <HAL_DCMIPP_PIPE_SetDecimationConfig+0x48>
    {
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
34187fca:	68fb      	ldr	r3, [r7, #12]
34187fcc:	681b      	ldr	r3, [r3, #0]
34187fce:	f8d3 390c 	ldr.w	r3, [r3, #2316]	@ 0x90c
34187fd2:	f023 011e 	bic.w	r1, r3, #30
34187fd6:	687b      	ldr	r3, [r7, #4]
34187fd8:	681a      	ldr	r2, [r3, #0]
34187fda:	687b      	ldr	r3, [r7, #4]
34187fdc:	685b      	ldr	r3, [r3, #4]
34187fde:	431a      	orrs	r2, r3
34187fe0:	68fb      	ldr	r3, [r7, #12]
34187fe2:	681b      	ldr	r3, [r3, #0]
34187fe4:	430a      	orrs	r2, r1
34187fe6:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34187fea:	e017      	b.n	3418801c <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else if (Pipe == DCMIPP_PIPE2)
34187fec:	68bb      	ldr	r3, [r7, #8]
34187fee:	2b02      	cmp	r3, #2
34187ff0:	d110      	bne.n	34188014 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
    {
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
34187ff2:	68fb      	ldr	r3, [r7, #12]
34187ff4:	681b      	ldr	r3, [r3, #0]
34187ff6:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
34187ffa:	f023 011e 	bic.w	r1, r3, #30
34187ffe:	687b      	ldr	r3, [r7, #4]
34188000:	681a      	ldr	r2, [r3, #0]
34188002:	687b      	ldr	r3, [r7, #4]
34188004:	685b      	ldr	r3, [r3, #4]
34188006:	431a      	orrs	r2, r3
34188008:	68fb      	ldr	r3, [r7, #12]
3418800a:	681b      	ldr	r3, [r3, #0]
3418800c:	430a      	orrs	r2, r1
3418800e:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34188012:	e003      	b.n	3418801c <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else
    {
      return HAL_ERROR;
34188014:	2301      	movs	r3, #1
34188016:	e002      	b.n	3418801e <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
    }
  }
  else
  {
    return HAL_ERROR;
34188018:	2301      	movs	r3, #1
3418801a:	e000      	b.n	3418801e <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  }

  return HAL_OK;
3418801c:	2300      	movs	r3, #0
}
3418801e:	4618      	mov	r0, r3
34188020:	3714      	adds	r7, #20
34188022:	46bd      	mov	sp, r7
34188024:	f85d 7b04 	ldr.w	r7, [sp], #4
34188028:	4770      	bx	lr

3418802a <HAL_DCMIPP_PIPE_EnableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418802a:	b480      	push	{r7}
3418802c:	b083      	sub	sp, #12
3418802e:	af00      	add	r7, sp, #0
34188030:	6078      	str	r0, [r7, #4]
34188032:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188034:	687b      	ldr	r3, [r7, #4]
34188036:	2b00      	cmp	r3, #0
34188038:	d101      	bne.n	3418803e <HAL_DCMIPP_PIPE_EnableDecimation+0x14>
  {
    return HAL_ERROR;
3418803a:	2301      	movs	r3, #1
3418803c:	e01e      	b.n	3418807c <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
3418803e:	683b      	ldr	r3, [r7, #0]
34188040:	2b01      	cmp	r3, #1
34188042:	d10a      	bne.n	3418805a <HAL_DCMIPP_PIPE_EnableDecimation+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
34188044:	687b      	ldr	r3, [r7, #4]
34188046:	681b      	ldr	r3, [r3, #0]
34188048:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
3418804c:	687b      	ldr	r3, [r7, #4]
3418804e:	681b      	ldr	r3, [r3, #0]
34188050:	f042 0201 	orr.w	r2, r2, #1
34188054:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34188058:	e00f      	b.n	3418807a <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
3418805a:	683b      	ldr	r3, [r7, #0]
3418805c:	2b02      	cmp	r3, #2
3418805e:	d10a      	bne.n	34188076 <HAL_DCMIPP_PIPE_EnableDecimation+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34188060:	687b      	ldr	r3, [r7, #4]
34188062:	681b      	ldr	r3, [r3, #0]
34188064:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
34188068:	687b      	ldr	r3, [r7, #4]
3418806a:	681b      	ldr	r3, [r3, #0]
3418806c:	f042 0201 	orr.w	r2, r2, #1
34188070:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34188074:	e001      	b.n	3418807a <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
34188076:	2301      	movs	r3, #1
34188078:	e000      	b.n	3418807c <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  return HAL_OK;
3418807a:	2300      	movs	r3, #0
}
3418807c:	4618      	mov	r0, r3
3418807e:	370c      	adds	r7, #12
34188080:	46bd      	mov	sp, r7
34188082:	f85d 7b04 	ldr.w	r7, [sp], #4
34188086:	4770      	bx	lr

34188088 <HAL_DCMIPP_PIPE_DisableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188088:	b480      	push	{r7}
3418808a:	b083      	sub	sp, #12
3418808c:	af00      	add	r7, sp, #0
3418808e:	6078      	str	r0, [r7, #4]
34188090:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188092:	687b      	ldr	r3, [r7, #4]
34188094:	2b00      	cmp	r3, #0
34188096:	d101      	bne.n	3418809c <HAL_DCMIPP_PIPE_DisableDecimation+0x14>
  {
    return HAL_ERROR;
34188098:	2301      	movs	r3, #1
3418809a:	e01e      	b.n	341880da <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
3418809c:	683b      	ldr	r3, [r7, #0]
3418809e:	2b01      	cmp	r3, #1
341880a0:	d10a      	bne.n	341880b8 <HAL_DCMIPP_PIPE_DisableDecimation+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
341880a2:	687b      	ldr	r3, [r7, #4]
341880a4:	681b      	ldr	r3, [r3, #0]
341880a6:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
341880aa:	687b      	ldr	r3, [r7, #4]
341880ac:	681b      	ldr	r3, [r3, #0]
341880ae:	f022 0201 	bic.w	r2, r2, #1
341880b2:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
341880b6:	e00f      	b.n	341880d8 <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
341880b8:	683b      	ldr	r3, [r7, #0]
341880ba:	2b02      	cmp	r3, #2
341880bc:	d10a      	bne.n	341880d4 <HAL_DCMIPP_PIPE_DisableDecimation+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
341880be:	687b      	ldr	r3, [r7, #4]
341880c0:	681b      	ldr	r3, [r3, #0]
341880c2:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
341880c6:	687b      	ldr	r3, [r7, #4]
341880c8:	681b      	ldr	r3, [r3, #0]
341880ca:	f022 0201 	bic.w	r2, r2, #1
341880ce:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
341880d2:	e001      	b.n	341880d8 <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
341880d4:	2301      	movs	r3, #1
341880d6:	e000      	b.n	341880da <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  return HAL_OK;
341880d8:	2300      	movs	r3, #0
}
341880da:	4618      	mov	r0, r3
341880dc:	370c      	adds	r7, #12
341880de:	46bd      	mov	sp, r7
341880e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341880e4:	4770      	bx	lr

341880e6 <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
  * @param  pDownsizeConfig pointer to the DCMIPP_DownsizeTypeDef structure that contains Downsize information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDownsizeConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                    const DCMIPP_DownsizeTypeDef *pDownsizeConfig)
{
341880e6:	b480      	push	{r7}
341880e8:	b085      	sub	sp, #20
341880ea:	af00      	add	r7, sp, #0
341880ec:	60f8      	str	r0, [r7, #12]
341880ee:	60b9      	str	r1, [r7, #8]
341880f0:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
341880f2:	68fb      	ldr	r3, [r7, #12]
341880f4:	2b00      	cmp	r3, #0
341880f6:	d002      	beq.n	341880fe <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x18>
341880f8:	687b      	ldr	r3, [r7, #4]
341880fa:	2b00      	cmp	r3, #0
341880fc:	d101      	bne.n	34188102 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x1c>
  {
    return HAL_ERROR;
341880fe:	2301      	movs	r3, #1
34188100:	e069      	b.n	341881d6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34188102:	68fb      	ldr	r3, [r7, #12]
34188104:	791b      	ldrb	r3, [r3, #4]
34188106:	b2db      	uxtb	r3, r3
34188108:	2b02      	cmp	r3, #2
3418810a:	d161      	bne.n	341881d0 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xea>
  {
    if (Pipe == DCMIPP_PIPE1)
3418810c:	68bb      	ldr	r3, [r7, #8]
3418810e:	2b01      	cmp	r3, #1
34188110:	d12c      	bne.n	3418816c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x86>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
34188112:	68fb      	ldr	r3, [r7, #12]
34188114:	681b      	ldr	r3, [r3, #0]
34188116:	f8d3 3910 	ldr.w	r3, [r3, #2320]	@ 0x910
3418811a:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
3418811e:	687b      	ldr	r3, [r7, #4]
34188120:	695a      	ldr	r2, [r3, #20]
34188122:	687b      	ldr	r3, [r7, #4]
34188124:	691b      	ldr	r3, [r3, #16]
34188126:	041b      	lsls	r3, r3, #16
34188128:	431a      	orrs	r2, r3
3418812a:	68fb      	ldr	r3, [r7, #12]
3418812c:	681b      	ldr	r3, [r3, #0]
3418812e:	430a      	orrs	r2, r1
34188130:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
                 ((pDownsizeConfig->HDivFactor << DCMIPP_P1DSCR_HDIV_Pos) | \
                  (pDownsizeConfig->VDivFactor << DCMIPP_P1DSCR_VDIV_Pos)));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
34188134:	687b      	ldr	r3, [r7, #4]
34188136:	68d9      	ldr	r1, [r3, #12]
34188138:	687b      	ldr	r3, [r7, #4]
3418813a:	689b      	ldr	r3, [r3, #8]
3418813c:	041a      	lsls	r2, r3, #16
3418813e:	68fb      	ldr	r3, [r7, #12]
34188140:	681b      	ldr	r3, [r3, #0]
34188142:	430a      	orrs	r2, r1
34188144:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
                (pDownsizeConfig->VRatio << DCMIPP_P1DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
34188148:	68fb      	ldr	r3, [r7, #12]
3418814a:	681b      	ldr	r3, [r3, #0]
3418814c:	f8d3 3918 	ldr.w	r3, [r3, #2328]	@ 0x918
34188150:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34188154:	687b      	ldr	r3, [r7, #4]
34188156:	685a      	ldr	r2, [r3, #4]
34188158:	687b      	ldr	r3, [r7, #4]
3418815a:	681b      	ldr	r3, [r3, #0]
3418815c:	041b      	lsls	r3, r3, #16
3418815e:	431a      	orrs	r2, r3
34188160:	68fb      	ldr	r3, [r7, #12]
34188162:	681b      	ldr	r3, [r3, #0]
34188164:	430a      	orrs	r2, r1
34188166:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
3418816a:	e033      	b.n	341881d4 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P1DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P1DSSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
3418816c:	68bb      	ldr	r3, [r7, #8]
3418816e:	2b02      	cmp	r3, #2
34188170:	d12c      	bne.n	341881cc <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe6>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
34188172:	68fb      	ldr	r3, [r7, #12]
34188174:	681b      	ldr	r3, [r3, #0]
34188176:	f8d3 3d10 	ldr.w	r3, [r3, #3344]	@ 0xd10
3418817a:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
3418817e:	687b      	ldr	r3, [r7, #4]
34188180:	695a      	ldr	r2, [r3, #20]
34188182:	687b      	ldr	r3, [r7, #4]
34188184:	691b      	ldr	r3, [r3, #16]
34188186:	041b      	lsls	r3, r3, #16
34188188:	431a      	orrs	r2, r3
3418818a:	68fb      	ldr	r3, [r7, #12]
3418818c:	681b      	ldr	r3, [r3, #0]
3418818e:	430a      	orrs	r2, r1
34188190:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
                 (pDownsizeConfig->HDivFactor << DCMIPP_P2DSCR_HDIV_Pos) | \
                 (pDownsizeConfig->VDivFactor << DCMIPP_P2DSCR_VDIV_Pos));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
34188194:	687b      	ldr	r3, [r7, #4]
34188196:	68d9      	ldr	r1, [r3, #12]
34188198:	687b      	ldr	r3, [r7, #4]
3418819a:	689b      	ldr	r3, [r3, #8]
3418819c:	041a      	lsls	r2, r3, #16
3418819e:	68fb      	ldr	r3, [r7, #12]
341881a0:	681b      	ldr	r3, [r3, #0]
341881a2:	430a      	orrs	r2, r1
341881a4:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
                (pDownsizeConfig->VRatio << DCMIPP_P2DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
341881a8:	68fb      	ldr	r3, [r7, #12]
341881aa:	681b      	ldr	r3, [r3, #0]
341881ac:	f8d3 3d18 	ldr.w	r3, [r3, #3352]	@ 0xd18
341881b0:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
341881b4:	687b      	ldr	r3, [r7, #4]
341881b6:	685a      	ldr	r2, [r3, #4]
341881b8:	687b      	ldr	r3, [r7, #4]
341881ba:	681b      	ldr	r3, [r3, #0]
341881bc:	041b      	lsls	r3, r3, #16
341881be:	431a      	orrs	r2, r3
341881c0:	68fb      	ldr	r3, [r7, #12]
341881c2:	681b      	ldr	r3, [r3, #0]
341881c4:	430a      	orrs	r2, r1
341881c6:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
341881ca:	e003      	b.n	341881d4 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P2DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P2DSSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
341881cc:	2301      	movs	r3, #1
341881ce:	e002      	b.n	341881d6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
    }
  }
  else
  {
    return HAL_ERROR;
341881d0:	2301      	movs	r3, #1
341881d2:	e000      	b.n	341881d6 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  }

  return HAL_OK;
341881d4:	2300      	movs	r3, #0
}
341881d6:	4618      	mov	r0, r3
341881d8:	3714      	adds	r7, #20
341881da:	46bd      	mov	sp, r7
341881dc:	f85d 7b04 	ldr.w	r7, [sp], #4
341881e0:	4770      	bx	lr

341881e2 <HAL_DCMIPP_PIPE_EnableDownsize>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDownsize(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341881e2:	b480      	push	{r7}
341881e4:	b083      	sub	sp, #12
341881e6:	af00      	add	r7, sp, #0
341881e8:	6078      	str	r0, [r7, #4]
341881ea:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
341881ec:	687b      	ldr	r3, [r7, #4]
341881ee:	2b00      	cmp	r3, #0
341881f0:	d101      	bne.n	341881f6 <HAL_DCMIPP_PIPE_EnableDownsize+0x14>
  {
    return HAL_ERROR;
341881f2:	2301      	movs	r3, #1
341881f4:	e01e      	b.n	34188234 <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341881f6:	683b      	ldr	r3, [r7, #0]
341881f8:	2b01      	cmp	r3, #1
341881fa:	d10a      	bne.n	34188212 <HAL_DCMIPP_PIPE_EnableDownsize+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
341881fc:	687b      	ldr	r3, [r7, #4]
341881fe:	681b      	ldr	r3, [r3, #0]
34188200:	f8d3 2910 	ldr.w	r2, [r3, #2320]	@ 0x910
34188204:	687b      	ldr	r3, [r7, #4]
34188206:	681b      	ldr	r3, [r3, #0]
34188208:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3418820c:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
34188210:	e00f      	b.n	34188232 <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34188212:	683b      	ldr	r3, [r7, #0]
34188214:	2b02      	cmp	r3, #2
34188216:	d10a      	bne.n	3418822e <HAL_DCMIPP_PIPE_EnableDownsize+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
34188218:	687b      	ldr	r3, [r7, #4]
3418821a:	681b      	ldr	r3, [r3, #0]
3418821c:	f8d3 2d10 	ldr.w	r2, [r3, #3344]	@ 0xd10
34188220:	687b      	ldr	r3, [r7, #4]
34188222:	681b      	ldr	r3, [r3, #0]
34188224:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34188228:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
3418822c:	e001      	b.n	34188232 <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else
  {
    return HAL_ERROR;
3418822e:	2301      	movs	r3, #1
34188230:	e000      	b.n	34188234 <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  return HAL_OK;
34188232:	2300      	movs	r3, #0
}
34188234:	4618      	mov	r0, r3
34188236:	370c      	adds	r7, #12
34188238:	46bd      	mov	sp, r7
3418823a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418823e:	4770      	bx	lr

34188240 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188240:	b480      	push	{r7}
34188242:	b083      	sub	sp, #12
34188244:	af00      	add	r7, sp, #0
34188246:	6078      	str	r0, [r7, #4]
34188248:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
3418824a:	687b      	ldr	r3, [r7, #4]
3418824c:	2b00      	cmp	r3, #0
3418824e:	d101      	bne.n	34188254 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x14>
  {
    return HAL_ERROR;
34188250:	2301      	movs	r3, #1
34188252:	e01e      	b.n	34188292 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188254:	683b      	ldr	r3, [r7, #0]
34188256:	2b01      	cmp	r3, #1
34188258:	d10a      	bne.n	34188270 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
3418825a:	687b      	ldr	r3, [r7, #4]
3418825c:	681b      	ldr	r3, [r3, #0]
3418825e:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
34188262:	687b      	ldr	r3, [r7, #4]
34188264:	681b      	ldr	r3, [r3, #0]
34188266:	f042 0201 	orr.w	r2, r2, #1
3418826a:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
3418826e:	e00f      	b.n	34188290 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34188270:	683b      	ldr	r3, [r7, #0]
34188272:	2b02      	cmp	r3, #2
34188274:	d10a      	bne.n	3418828c <HAL_DCMIPP_PIPE_EnableGammaConversion+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34188276:	687b      	ldr	r3, [r7, #4]
34188278:	681b      	ldr	r3, [r3, #0]
3418827a:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
3418827e:	687b      	ldr	r3, [r7, #4]
34188280:	681b      	ldr	r3, [r3, #0]
34188282:	f042 0201 	orr.w	r2, r2, #1
34188286:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
3418828a:	e001      	b.n	34188290 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
3418828c:	2301      	movs	r3, #1
3418828e:	e000      	b.n	34188292 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  return HAL_OK;
34188290:	2300      	movs	r3, #0
}
34188292:	4618      	mov	r0, r3
34188294:	370c      	adds	r7, #12
34188296:	46bd      	mov	sp, r7
34188298:	f85d 7b04 	ldr.w	r7, [sp], #4
3418829c:	4770      	bx	lr

3418829e <HAL_DCMIPP_PIPE_DisableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418829e:	b480      	push	{r7}
341882a0:	b083      	sub	sp, #12
341882a2:	af00      	add	r7, sp, #0
341882a4:	6078      	str	r0, [r7, #4]
341882a6:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341882a8:	687b      	ldr	r3, [r7, #4]
341882aa:	2b00      	cmp	r3, #0
341882ac:	d101      	bne.n	341882b2 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x14>
  {
    return HAL_ERROR;
341882ae:	2301      	movs	r3, #1
341882b0:	e01e      	b.n	341882f0 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341882b2:	683b      	ldr	r3, [r7, #0]
341882b4:	2b01      	cmp	r3, #1
341882b6:	d10a      	bne.n	341882ce <HAL_DCMIPP_PIPE_DisableGammaConversion+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
341882b8:	687b      	ldr	r3, [r7, #4]
341882ba:	681b      	ldr	r3, [r3, #0]
341882bc:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
341882c0:	687b      	ldr	r3, [r7, #4]
341882c2:	681b      	ldr	r3, [r3, #0]
341882c4:	f022 0201 	bic.w	r2, r2, #1
341882c8:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
341882cc:	e00f      	b.n	341882ee <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
341882ce:	683b      	ldr	r3, [r7, #0]
341882d0:	2b02      	cmp	r3, #2
341882d2:	d10a      	bne.n	341882ea <HAL_DCMIPP_PIPE_DisableGammaConversion+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
341882d4:	687b      	ldr	r3, [r7, #4]
341882d6:	681b      	ldr	r3, [r3, #0]
341882d8:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
341882dc:	687b      	ldr	r3, [r7, #4]
341882de:	681b      	ldr	r3, [r3, #0]
341882e0:	f022 0201 	bic.w	r2, r2, #1
341882e4:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
341882e8:	e001      	b.n	341882ee <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
341882ea:	2301      	movs	r3, #1
341882ec:	e000      	b.n	341882f0 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  return HAL_OK;
341882ee:	2300      	movs	r3, #0
}
341882f0:	4618      	mov	r0, r3
341882f2:	370c      	adds	r7, #12
341882f4:	46bd      	mov	sp, r7
341882f6:	f85d 7b04 	ldr.w	r7, [sp], #4
341882fa:	4770      	bx	lr

341882fc <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledGammaConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341882fc:	b480      	push	{r7}
341882fe:	b083      	sub	sp, #12
34188300:	af00      	add	r7, sp, #0
34188302:	6078      	str	r0, [r7, #4]
34188304:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188306:	683b      	ldr	r3, [r7, #0]
34188308:	2b01      	cmp	r3, #1
3418830a:	d10b      	bne.n	34188324 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
3418830c:	687b      	ldr	r3, [r7, #4]
3418830e:	681b      	ldr	r3, [r3, #0]
34188310:	f8d3 3970 	ldr.w	r3, [r3, #2416]	@ 0x970
34188314:	f003 0301 	and.w	r3, r3, #1
34188318:	2b01      	cmp	r3, #1
3418831a:	d101      	bne.n	34188320 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x24>
3418831c:	2301      	movs	r3, #1
3418831e:	e011      	b.n	34188344 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
34188320:	2300      	movs	r3, #0
34188322:	e00f      	b.n	34188344 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else if (Pipe == DCMIPP_PIPE2)
34188324:	683b      	ldr	r3, [r7, #0]
34188326:	2b02      	cmp	r3, #2
34188328:	d10b      	bne.n	34188342 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x46>
  {
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
3418832a:	687b      	ldr	r3, [r7, #4]
3418832c:	681b      	ldr	r3, [r3, #0]
3418832e:	f8d3 3d70 	ldr.w	r3, [r3, #3440]	@ 0xd70
34188332:	f003 0301 	and.w	r3, r3, #1
34188336:	2b01      	cmp	r3, #1
34188338:	d101      	bne.n	3418833e <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
3418833a:	2301      	movs	r3, #1
3418833c:	e002      	b.n	34188344 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
3418833e:	2300      	movs	r3, #0
34188340:	e000      	b.n	34188344 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else
  {
    /* State Disabled */
    return 0;
34188342:	2300      	movs	r3, #0
  }
}
34188344:	4618      	mov	r0, r3
34188346:	370c      	adds	r7, #12
34188348:	46bd      	mov	sp, r7
3418834a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418834e:	4770      	bx	lr

34188350 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
  *         information.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_RawBayer2RGBConfTypeDef *pRawBayer2RGBConfig)
{
34188350:	b480      	push	{r7}
34188352:	b087      	sub	sp, #28
34188354:	af00      	add	r7, sp, #0
34188356:	60f8      	str	r0, [r7, #12]
34188358:	60b9      	str	r1, [r7, #8]
3418835a:	607a      	str	r2, [r7, #4]
  uint32_t p1dmcr_reg;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
3418835c:	68fb      	ldr	r3, [r7, #12]
3418835e:	2b00      	cmp	r3, #0
34188360:	d002      	beq.n	34188368 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x18>
34188362:	687b      	ldr	r3, [r7, #4]
34188364:	2b00      	cmp	r3, #0
34188366:	d101      	bne.n	3418836c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x1c>
  {
    return HAL_ERROR;
34188368:	2301      	movs	r3, #1
3418836a:	e024      	b.n	341883b6 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));

  if (Pipe == DCMIPP_PIPE1)
3418836c:	68bb      	ldr	r3, [r7, #8]
3418836e:	2b01      	cmp	r3, #1
34188370:	d120      	bne.n	341883b4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x64>
  {

    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34188372:	687b      	ldr	r3, [r7, #4]
34188374:	689a      	ldr	r2, [r3, #8]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34188376:	687b      	ldr	r3, [r7, #4]
34188378:	68db      	ldr	r3, [r3, #12]
3418837a:	041b      	lsls	r3, r3, #16
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
3418837c:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
3418837e:	687b      	ldr	r3, [r7, #4]
34188380:	691b      	ldr	r3, [r3, #16]
34188382:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34188384:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
34188386:	687b      	ldr	r3, [r7, #4]
34188388:	681b      	ldr	r3, [r3, #0]
3418838a:	051b      	lsls	r3, r3, #20
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
3418838c:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
3418838e:	687b      	ldr	r3, [r7, #4]
34188390:	685b      	ldr	r3, [r3, #4]
34188392:	061b      	lsls	r3, r3, #24
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34188394:	4313      	orrs	r3, r2
34188396:	617b      	str	r3, [r7, #20]


    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34188398:	68fb      	ldr	r3, [r7, #12]
3418839a:	681b      	ldr	r3, [r3, #0]
3418839c:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
341883a0:	4b08      	ldr	r3, [pc, #32]	@ (341883c4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x74>)
341883a2:	4013      	ands	r3, r2
341883a4:	68fa      	ldr	r2, [r7, #12]
341883a6:	6812      	ldr	r2, [r2, #0]
341883a8:	6979      	ldr	r1, [r7, #20]
341883aa:	430b      	orrs	r3, r1
341883ac:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341883b0:	2300      	movs	r3, #0
341883b2:	e000      	b.n	341883b6 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
    return HAL_ERROR;
341883b4:	2301      	movs	r3, #1
}
341883b6:	4618      	mov	r0, r3
341883b8:	371c      	adds	r7, #28
341883ba:	46bd      	mov	sp, r7
341883bc:	f85d 7b04 	ldr.w	r7, [sp], #4
341883c0:	4770      	bx	lr
341883c2:	bf00      	nop
341883c4:	8888fff9 	.word	0x8888fff9

341883c8 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341883c8:	b480      	push	{r7}
341883ca:	b083      	sub	sp, #12
341883cc:	af00      	add	r7, sp, #0
341883ce:	6078      	str	r0, [r7, #4]
341883d0:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341883d2:	687b      	ldr	r3, [r7, #4]
341883d4:	2b00      	cmp	r3, #0
341883d6:	d101      	bne.n	341883dc <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
341883d8:	2301      	movs	r3, #1
341883da:	e00f      	b.n	341883fc <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341883dc:	683b      	ldr	r3, [r7, #0]
341883de:	2b01      	cmp	r3, #1
341883e0:	d10b      	bne.n	341883fa <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
341883e2:	687b      	ldr	r3, [r7, #4]
341883e4:	681b      	ldr	r3, [r3, #0]
341883e6:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
341883ea:	687b      	ldr	r3, [r7, #4]
341883ec:	681b      	ldr	r3, [r3, #0]
341883ee:	f042 0201 	orr.w	r2, r2, #1
341883f2:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341883f6:	2300      	movs	r3, #0
341883f8:	e000      	b.n	341883fc <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
341883fa:	2301      	movs	r3, #1
}
341883fc:	4618      	mov	r0, r3
341883fe:	370c      	adds	r7, #12
34188400:	46bd      	mov	sp, r7
34188402:	f85d 7b04 	ldr.w	r7, [sp], #4
34188406:	4770      	bx	lr

34188408 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188408:	b480      	push	{r7}
3418840a:	b083      	sub	sp, #12
3418840c:	af00      	add	r7, sp, #0
3418840e:	6078      	str	r0, [r7, #4]
34188410:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34188412:	687b      	ldr	r3, [r7, #4]
34188414:	2b00      	cmp	r3, #0
34188416:	d101      	bne.n	3418841c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
34188418:	2301      	movs	r3, #1
3418841a:	e00f      	b.n	3418843c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
3418841c:	683b      	ldr	r3, [r7, #0]
3418841e:	2b01      	cmp	r3, #1
34188420:	d10b      	bne.n	3418843a <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34188422:	687b      	ldr	r3, [r7, #4]
34188424:	681b      	ldr	r3, [r3, #0]
34188426:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
3418842a:	687b      	ldr	r3, [r7, #4]
3418842c:	681b      	ldr	r3, [r3, #0]
3418842e:	f022 0201 	bic.w	r2, r2, #1
34188432:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188436:	2300      	movs	r3, #0
34188438:	e000      	b.n	3418843c <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
3418843a:	2301      	movs	r3, #1
}
3418843c:	4618      	mov	r0, r3
3418843e:	370c      	adds	r7, #12
34188440:	46bd      	mov	sp, r7
34188442:	f85d 7b04 	ldr.w	r7, [sp], #4
34188446:	4770      	bx	lr

34188448 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
  * @param  NbLastLines  number of valid image line to keep after the skipped first lines
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t NbFirstLines, uint32_t NbLastLines)
{
34188448:	b480      	push	{r7}
3418844a:	b087      	sub	sp, #28
3418844c:	af00      	add	r7, sp, #0
3418844e:	60f8      	str	r0, [r7, #12]
34188450:	60b9      	str	r1, [r7, #8]
34188452:	607a      	str	r2, [r7, #4]
34188454:	603b      	str	r3, [r7, #0]
  uint32_t p1srcr_reg;

  /* Check handles validity */
  if (hdcmipp == NULL)
34188456:	68fb      	ldr	r3, [r7, #12]
34188458:	2b00      	cmp	r3, #0
3418845a:	d101      	bne.n	34188460 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x18>
  {
    return HAL_ERROR;
3418845c:	2301      	movs	r3, #1
3418845e:	e018      	b.n	34188492 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));

  if (Pipe == DCMIPP_PIPE1)
34188460:	68bb      	ldr	r3, [r7, #8]
34188462:	2b01      	cmp	r3, #1
34188464:	d114      	bne.n	34188490 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x48>
  {
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
34188466:	687b      	ldr	r3, [r7, #4]
34188468:	031b      	lsls	r3, r3, #12
3418846a:	683a      	ldr	r2, [r7, #0]
3418846c:	4313      	orrs	r3, r2
3418846e:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34188470:	68fb      	ldr	r3, [r7, #12]
34188472:	681b      	ldr	r3, [r3, #0]
34188474:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
34188478:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
3418847c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34188480:	68fa      	ldr	r2, [r7, #12]
34188482:	6812      	ldr	r2, [r2, #0]
34188484:	6979      	ldr	r1, [r7, #20]
34188486:	430b      	orrs	r3, r1
34188488:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418848c:	2300      	movs	r3, #0
3418848e:	e000      	b.n	34188492 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
    return HAL_ERROR;
34188490:	2301      	movs	r3, #1
}
34188492:	4618      	mov	r0, r3
34188494:	371c      	adds	r7, #28
34188496:	46bd      	mov	sp, r7
34188498:	f85d 7b04 	ldr.w	r7, [sp], #4
3418849c:	4770      	bx	lr

3418849e <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418849e:	b480      	push	{r7}
341884a0:	b083      	sub	sp, #12
341884a2:	af00      	add	r7, sp, #0
341884a4:	6078      	str	r0, [r7, #4]
341884a6:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341884a8:	687b      	ldr	r3, [r7, #4]
341884aa:	2b00      	cmp	r3, #0
341884ac:	d101      	bne.n	341884b2 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
341884ae:	2301      	movs	r3, #1
341884b0:	e00f      	b.n	341884d2 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
341884b2:	683b      	ldr	r3, [r7, #0]
341884b4:	2b01      	cmp	r3, #1
341884b6:	d10b      	bne.n	341884d0 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
341884b8:	687b      	ldr	r3, [r7, #4]
341884ba:	681b      	ldr	r3, [r3, #0]
341884bc:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
341884c0:	687b      	ldr	r3, [r7, #4]
341884c2:	681b      	ldr	r3, [r3, #0]
341884c4:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
341884c8:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341884cc:	2300      	movs	r3, #0
341884ce:	e000      	b.n	341884d2 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
    return HAL_ERROR;
341884d0:	2301      	movs	r3, #1
}
341884d2:	4618      	mov	r0, r3
341884d4:	370c      	adds	r7, #12
341884d6:	46bd      	mov	sp, r7
341884d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341884dc:	4770      	bx	lr

341884de <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341884de:	b480      	push	{r7}
341884e0:	b083      	sub	sp, #12
341884e2:	af00      	add	r7, sp, #0
341884e4:	6078      	str	r0, [r7, #4]
341884e6:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341884e8:	687b      	ldr	r3, [r7, #4]
341884ea:	2b00      	cmp	r3, #0
341884ec:	d101      	bne.n	341884f2 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
341884ee:	2301      	movs	r3, #1
341884f0:	e00f      	b.n	34188512 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
341884f2:	683b      	ldr	r3, [r7, #0]
341884f4:	2b01      	cmp	r3, #1
341884f6:	d10b      	bne.n	34188510 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
341884f8:	687b      	ldr	r3, [r7, #4]
341884fa:	681b      	ldr	r3, [r3, #0]
341884fc:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34188500:	687b      	ldr	r3, [r7, #4]
34188502:	681b      	ldr	r3, [r3, #0]
34188504:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34188508:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418850c:	2300      	movs	r3, #0
3418850e:	e000      	b.n	34188512 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
    return HAL_ERROR;
34188510:	2301      	movs	r3, #1
}
34188512:	4618      	mov	r0, r3
34188514:	370c      	adds	r7, #12
34188516:	46bd      	mov	sp, r7
34188518:	f85d 7b04 	ldr.w	r7, [sp], #4
3418851c:	4770      	bx	lr

3418851e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
  * @param  Strength Specifies the removal strength, can be a value from @ref DCMIPP_Bad_Pixel_Removal_Strength
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              uint32_t Strength)
{
3418851e:	b480      	push	{r7}
34188520:	b085      	sub	sp, #20
34188522:	af00      	add	r7, sp, #0
34188524:	60f8      	str	r0, [r7, #12]
34188526:	60b9      	str	r1, [r7, #8]
34188528:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if (hdcmipp == NULL)
3418852a:	68fb      	ldr	r3, [r7, #12]
3418852c:	2b00      	cmp	r3, #0
3418852e:	d101      	bne.n	34188534 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x16>
  {
    return HAL_ERROR;
34188530:	2301      	movs	r3, #1
34188532:	e012      	b.n	3418855a <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));

  if (Pipe == DCMIPP_PIPE1)
34188534:	68bb      	ldr	r3, [r7, #8]
34188536:	2b01      	cmp	r3, #1
34188538:	d10e      	bne.n	34188558 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
3418853a:	68fb      	ldr	r3, [r7, #12]
3418853c:	681b      	ldr	r3, [r3, #0]
3418853e:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34188542:	f023 010e 	bic.w	r1, r3, #14
34188546:	687b      	ldr	r3, [r7, #4]
34188548:	005a      	lsls	r2, r3, #1
3418854a:	68fb      	ldr	r3, [r7, #12]
3418854c:	681b      	ldr	r3, [r3, #0]
3418854e:	430a      	orrs	r2, r1
34188550:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188554:	2300      	movs	r3, #0
34188556:	e000      	b.n	3418855a <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>
    return HAL_ERROR;
34188558:	2301      	movs	r3, #1
}
3418855a:	4618      	mov	r0, r3
3418855c:	3714      	adds	r7, #20
3418855e:	46bd      	mov	sp, r7
34188560:	f85d 7b04 	ldr.w	r7, [sp], #4
34188564:	4770      	bx	lr

34188566 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188566:	b480      	push	{r7}
34188568:	b083      	sub	sp, #12
3418856a:	af00      	add	r7, sp, #0
3418856c:	6078      	str	r0, [r7, #4]
3418856e:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34188570:	687b      	ldr	r3, [r7, #4]
34188572:	2b00      	cmp	r3, #0
34188574:	d101      	bne.n	3418857a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
34188576:	2301      	movs	r3, #1
34188578:	e00f      	b.n	3418859a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
3418857a:	683b      	ldr	r3, [r7, #0]
3418857c:	2b01      	cmp	r3, #1
3418857e:	d10b      	bne.n	34188598 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34188580:	687b      	ldr	r3, [r7, #4]
34188582:	681b      	ldr	r3, [r3, #0]
34188584:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
34188588:	687b      	ldr	r3, [r7, #4]
3418858a:	681b      	ldr	r3, [r3, #0]
3418858c:	f042 0201 	orr.w	r2, r2, #1
34188590:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188594:	2300      	movs	r3, #0
34188596:	e000      	b.n	3418859a <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
34188598:	2301      	movs	r3, #1
}
3418859a:	4618      	mov	r0, r3
3418859c:	370c      	adds	r7, #12
3418859e:	46bd      	mov	sp, r7
341885a0:	f85d 7b04 	ldr.w	r7, [sp], #4
341885a4:	4770      	bx	lr

341885a6 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341885a6:	b480      	push	{r7}
341885a8:	b083      	sub	sp, #12
341885aa:	af00      	add	r7, sp, #0
341885ac:	6078      	str	r0, [r7, #4]
341885ae:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
341885b0:	687b      	ldr	r3, [r7, #4]
341885b2:	2b00      	cmp	r3, #0
341885b4:	d101      	bne.n	341885ba <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
341885b6:	2301      	movs	r3, #1
341885b8:	e00f      	b.n	341885da <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341885ba:	683b      	ldr	r3, [r7, #0]
341885bc:	2b01      	cmp	r3, #1
341885be:	d10b      	bne.n	341885d8 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
341885c0:	687b      	ldr	r3, [r7, #4]
341885c2:	681b      	ldr	r3, [r3, #0]
341885c4:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
341885c8:	687b      	ldr	r3, [r7, #4]
341885ca:	681b      	ldr	r3, [r3, #0]
341885cc:	f022 0201 	bic.w	r2, r2, #1
341885d0:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341885d4:	2300      	movs	r3, #0
341885d6:	e000      	b.n	341885da <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
341885d8:	2301      	movs	r3, #1
}
341885da:	4618      	mov	r0, r3
341885dc:	370c      	adds	r7, #12
341885de:	46bd      	mov	sp, r7
341885e0:	f85d 7b04 	ldr.w	r7, [sp], #4
341885e4:	4770      	bx	lr

341885e6 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval  The strength of the bad pixel removal process.
  */
uint32_t HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341885e6:	b480      	push	{r7}
341885e8:	b083      	sub	sp, #12
341885ea:	af00      	add	r7, sp, #0
341885ec:	6078      	str	r0, [r7, #4]
341885ee:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
341885f0:	687b      	ldr	r3, [r7, #4]
341885f2:	681b      	ldr	r3, [r3, #0]
341885f4:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
341885f8:	085b      	lsrs	r3, r3, #1
341885fa:	f003 0307 	and.w	r3, r3, #7
}
341885fe:	4618      	mov	r0, r3
34188600:	370c      	adds	r7, #12
34188602:	46bd      	mov	sp, r7
34188604:	f85d 7b04 	ldr.w	r7, [sp], #4
34188608:	4770      	bx	lr

3418860a <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418860a:	b480      	push	{r7}
3418860c:	b083      	sub	sp, #12
3418860e:	af00      	add	r7, sp, #0
34188610:	6078      	str	r0, [r7, #4]
34188612:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188614:	683b      	ldr	r3, [r7, #0]
34188616:	2b01      	cmp	r3, #1
34188618:	d10b      	bne.n	34188632 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
3418861a:	687b      	ldr	r3, [r7, #4]
3418861c:	681b      	ldr	r3, [r3, #0]
3418861e:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34188622:	f003 0301 	and.w	r3, r3, #1
34188626:	2b01      	cmp	r3, #1
34188628:	d101      	bne.n	3418862e <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x24>
3418862a:	2301      	movs	r3, #1
3418862c:	e002      	b.n	34188634 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
3418862e:	2300      	movs	r3, #0
34188630:	e000      	b.n	34188634 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
34188632:	2300      	movs	r3, #0
  }
}
34188634:	4618      	mov	r0, r3
34188636:	370c      	adds	r7, #12
34188638:	46bd      	mov	sp, r7
3418863a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418863e:	4770      	bx	lr

34188640 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
  * @param  pCounter pointer receiving the number of corrected bad pixels
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t *pCounter)
{
34188640:	b480      	push	{r7}
34188642:	b085      	sub	sp, #20
34188644:	af00      	add	r7, sp, #0
34188646:	60f8      	str	r0, [r7, #12]
34188648:	60b9      	str	r1, [r7, #8]
3418864a:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
3418864c:	68fb      	ldr	r3, [r7, #12]
3418864e:	2b00      	cmp	r3, #0
34188650:	d002      	beq.n	34188658 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x18>
34188652:	687b      	ldr	r3, [r7, #4]
34188654:	2b00      	cmp	r3, #0
34188656:	d101      	bne.n	3418865c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1c>
  {
    return HAL_ERROR;
34188658:	2301      	movs	r3, #1
3418865a:	e00f      	b.n	3418867c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
3418865c:	68fb      	ldr	r3, [r7, #12]
3418865e:	791b      	ldrb	r3, [r3, #4]
34188660:	b2db      	uxtb	r3, r3
34188662:	2b02      	cmp	r3, #2
34188664:	d109      	bne.n	3418867a <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3a>
  {
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34188666:	68fb      	ldr	r3, [r7, #12]
34188668:	681b      	ldr	r3, [r3, #0]
3418866a:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
3418866e:	f3c3 020b 	ubfx	r2, r3, #0, #12
34188672:	687b      	ldr	r3, [r7, #4]
34188674:	601a      	str	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188676:	2300      	movs	r3, #0
34188678:	e000      	b.n	3418867c <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>
    return HAL_ERROR;
3418867a:	2301      	movs	r3, #1
}
3418867c:	4618      	mov	r0, r3
3418867e:	3714      	adds	r7, #20
34188680:	46bd      	mov	sp, r7
34188682:	f85d 7b04 	ldr.w	r7, [sp], #4
34188686:	4770      	bx	lr

34188688 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPColorConversionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              const DCMIPP_ColorConversionConfTypeDef
                                                              *pColorConversionConfig)
{
34188688:	b480      	push	{r7}
3418868a:	b087      	sub	sp, #28
3418868c:	af00      	add	r7, sp, #0
3418868e:	60f8      	str	r0, [r7, #12]
34188690:	60b9      	str	r1, [r7, #8]
34188692:	607a      	str	r2, [r7, #4]
  uint32_t p1cccr_reg;
  uint16_t tmp1;
  uint16_t tmp2;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34188694:	68fb      	ldr	r3, [r7, #12]
34188696:	2b00      	cmp	r3, #0
34188698:	d002      	beq.n	341886a0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x18>
3418869a:	687b      	ldr	r3, [r7, #4]
3418869c:	2b00      	cmp	r3, #0
3418869e:	d101      	bne.n	341886a4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c>
  {
    return HAL_ERROR;
341886a0:	2301      	movs	r3, #1
341886a2:	e14b      	b.n	3418893c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));

  if (Pipe == DCMIPP_PIPE1)
341886a4:	68bb      	ldr	r3, [r7, #8]
341886a6:	2b01      	cmp	r3, #1
341886a8:	f040 8147 	bne.w	3418893a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b2>
  {
    /* Set Clamp and Type */
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
341886ac:	687b      	ldr	r3, [r7, #4]
341886ae:	781b      	ldrb	r3, [r3, #0]
341886b0:	009b      	lsls	r3, r3, #2
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
341886b2:	687a      	ldr	r2, [r7, #4]
341886b4:	7852      	ldrb	r2, [r2, #1]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
341886b6:	4313      	orrs	r3, r2
341886b8:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
341886ba:	68fb      	ldr	r3, [r7, #12]
341886bc:	681b      	ldr	r3, [r3, #0]
341886be:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
341886c2:	f023 0106 	bic.w	r1, r3, #6
341886c6:	68fb      	ldr	r3, [r7, #12]
341886c8:	681b      	ldr	r3, [r3, #0]
341886ca:	697a      	ldr	r2, [r7, #20]
341886cc:	430a      	orrs	r2, r1
341886ce:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
341886d2:	687b      	ldr	r3, [r7, #4]
341886d4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
341886d8:	2b00      	cmp	r3, #0
341886da:	da07      	bge.n	341886ec <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x64>
341886dc:	687b      	ldr	r3, [r7, #4]
341886de:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
341886e2:	b29b      	uxth	r3, r3
341886e4:	f3c3 030a 	ubfx	r3, r3, #0, #11
341886e8:	b29b      	uxth	r3, r3
341886ea:	e003      	b.n	341886f4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6c>
341886ec:	687b      	ldr	r3, [r7, #4]
341886ee:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
341886f2:	b29b      	uxth	r3, r3
341886f4:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
341886f6:	687b      	ldr	r3, [r7, #4]
341886f8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
341886fc:	2b00      	cmp	r3, #0
341886fe:	da07      	bge.n	34188710 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x88>
34188700:	687b      	ldr	r3, [r7, #4]
34188702:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
34188706:	b29b      	uxth	r3, r3
34188708:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418870c:	b29b      	uxth	r3, r3
3418870e:	e003      	b.n	34188718 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x90>
34188710:	687b      	ldr	r3, [r7, #4]
34188712:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
34188716:	b29b      	uxth	r3, r3
34188718:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
3418871a:	68fb      	ldr	r3, [r7, #12]
3418871c:	681b      	ldr	r3, [r3, #0]
3418871e:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
34188722:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
34188726:	8a7a      	ldrh	r2, [r7, #18]
34188728:	8a3b      	ldrh	r3, [r7, #16]
3418872a:	041b      	lsls	r3, r3, #16
3418872c:	431a      	orrs	r2, r3
3418872e:	68fb      	ldr	r3, [r7, #12]
34188730:	681b      	ldr	r3, [r3, #0]
34188732:	430a      	orrs	r2, r1
34188734:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
               (((uint32_t)tmp1) << DCMIPP_P1CCRR1_RR_Pos) | (((uint32_t)tmp2) << DCMIPP_P1CCRR1_RG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34188738:	687b      	ldr	r3, [r7, #4]
3418873a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
3418873e:	2b00      	cmp	r3, #0
34188740:	da07      	bge.n	34188752 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xca>
34188742:	687b      	ldr	r3, [r7, #4]
34188744:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
34188748:	b29b      	uxth	r3, r3
3418874a:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418874e:	b29b      	uxth	r3, r3
34188750:	e003      	b.n	3418875a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xd2>
34188752:	687b      	ldr	r3, [r7, #4]
34188754:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
34188758:	b29b      	uxth	r3, r3
3418875a:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
3418875c:	687b      	ldr	r3, [r7, #4]
3418875e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
34188762:	2b00      	cmp	r3, #0
34188764:	da07      	bge.n	34188776 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xee>
34188766:	687b      	ldr	r3, [r7, #4]
34188768:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
3418876c:	b29b      	uxth	r3, r3
3418876e:	f3c3 0309 	ubfx	r3, r3, #0, #10
34188772:	b29b      	uxth	r3, r3
34188774:	e003      	b.n	3418877e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
34188776:	687b      	ldr	r3, [r7, #4]
34188778:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
3418877c:	b29b      	uxth	r3, r3
3418877e:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
34188780:	68fb      	ldr	r3, [r7, #12]
34188782:	681b      	ldr	r3, [r3, #0]
34188784:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
34188788:	4b6f      	ldr	r3, [pc, #444]	@ (34188948 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
3418878a:	4013      	ands	r3, r2
3418878c:	8a79      	ldrh	r1, [r7, #18]
3418878e:	8a3a      	ldrh	r2, [r7, #16]
34188790:	0412      	lsls	r2, r2, #16
34188792:	4311      	orrs	r1, r2
34188794:	68fa      	ldr	r2, [r7, #12]
34188796:	6812      	ldr	r2, [r2, #0]
34188798:	430b      	orrs	r3, r1
3418879a:	f8c2 3888 	str.w	r3, [r2, #2184]	@ 0x888
               ((uint32_t)tmp1 << DCMIPP_P1CCRR2_RB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCRR2_RA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
3418879e:	687b      	ldr	r3, [r7, #4]
341887a0:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
341887a4:	2b00      	cmp	r3, #0
341887a6:	da07      	bge.n	341887b8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x130>
341887a8:	687b      	ldr	r3, [r7, #4]
341887aa:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
341887ae:	b29b      	uxth	r3, r3
341887b0:	f3c3 030a 	ubfx	r3, r3, #0, #11
341887b4:	b29b      	uxth	r3, r3
341887b6:	e003      	b.n	341887c0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x138>
341887b8:	687b      	ldr	r3, [r7, #4]
341887ba:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
341887be:	b29b      	uxth	r3, r3
341887c0:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
341887c2:	687b      	ldr	r3, [r7, #4]
341887c4:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
341887c8:	2b00      	cmp	r3, #0
341887ca:	da07      	bge.n	341887dc <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x154>
341887cc:	687b      	ldr	r3, [r7, #4]
341887ce:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
341887d2:	b29b      	uxth	r3, r3
341887d4:	f3c3 030a 	ubfx	r3, r3, #0, #11
341887d8:	b29b      	uxth	r3, r3
341887da:	e003      	b.n	341887e4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x15c>
341887dc:	687b      	ldr	r3, [r7, #4]
341887de:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
341887e2:	b29b      	uxth	r3, r3
341887e4:	823b      	strh	r3, [r7, #16]


    /* Set Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
341887e6:	68fb      	ldr	r3, [r7, #12]
341887e8:	681b      	ldr	r3, [r3, #0]
341887ea:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
341887ee:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
341887f2:	8a7b      	ldrh	r3, [r7, #18]
341887f4:	041a      	lsls	r2, r3, #16
341887f6:	8a3b      	ldrh	r3, [r7, #16]
341887f8:	431a      	orrs	r2, r3
341887fa:	68fb      	ldr	r3, [r7, #12]
341887fc:	681b      	ldr	r3, [r3, #0]
341887fe:	430a      	orrs	r2, r1
34188800:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
               ((uint32_t)tmp1 << DCMIPP_P1CCGR1_GG_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR1_GR_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
34188804:	687b      	ldr	r3, [r7, #4]
34188806:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
3418880a:	2b00      	cmp	r3, #0
3418880c:	da07      	bge.n	3418881e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x196>
3418880e:	687b      	ldr	r3, [r7, #4]
34188810:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
34188814:	b29b      	uxth	r3, r3
34188816:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418881a:	b29b      	uxth	r3, r3
3418881c:	e003      	b.n	34188826 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x19e>
3418881e:	687b      	ldr	r3, [r7, #4]
34188820:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
34188824:	b29b      	uxth	r3, r3
34188826:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34188828:	687b      	ldr	r3, [r7, #4]
3418882a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
3418882e:	2b00      	cmp	r3, #0
34188830:	da07      	bge.n	34188842 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1ba>
34188832:	687b      	ldr	r3, [r7, #4]
34188834:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
34188838:	b29b      	uxth	r3, r3
3418883a:	f3c3 0309 	ubfx	r3, r3, #0, #10
3418883e:	b29b      	uxth	r3, r3
34188840:	e003      	b.n	3418884a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c2>
34188842:	687b      	ldr	r3, [r7, #4]
34188844:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
34188848:	b29b      	uxth	r3, r3
3418884a:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
3418884c:	68fb      	ldr	r3, [r7, #12]
3418884e:	681b      	ldr	r3, [r3, #0]
34188850:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
34188854:	4b3c      	ldr	r3, [pc, #240]	@ (34188948 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
34188856:	4013      	ands	r3, r2
34188858:	8a79      	ldrh	r1, [r7, #18]
3418885a:	8a3a      	ldrh	r2, [r7, #16]
3418885c:	0412      	lsls	r2, r2, #16
3418885e:	4311      	orrs	r1, r2
34188860:	68fa      	ldr	r2, [r7, #12]
34188862:	6812      	ldr	r2, [r2, #0]
34188864:	430b      	orrs	r3, r1
34188866:	f8c2 3890 	str.w	r3, [r2, #2192]	@ 0x890
               ((uint32_t)tmp1 << DCMIPP_P1CCGR2_GB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR2_GA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
3418886a:	687b      	ldr	r3, [r7, #4]
3418886c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
34188870:	2b00      	cmp	r3, #0
34188872:	da07      	bge.n	34188884 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1fc>
34188874:	687b      	ldr	r3, [r7, #4]
34188876:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
3418887a:	b29b      	uxth	r3, r3
3418887c:	f3c3 030a 	ubfx	r3, r3, #0, #11
34188880:	b29b      	uxth	r3, r3
34188882:	e003      	b.n	3418888c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x204>
34188884:	687b      	ldr	r3, [r7, #4]
34188886:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
3418888a:	b29b      	uxth	r3, r3
3418888c:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
3418888e:	687b      	ldr	r3, [r7, #4]
34188890:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
34188894:	2b00      	cmp	r3, #0
34188896:	da07      	bge.n	341888a8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x220>
34188898:	687b      	ldr	r3, [r7, #4]
3418889a:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
3418889e:	b29b      	uxth	r3, r3
341888a0:	f3c3 030a 	ubfx	r3, r3, #0, #11
341888a4:	b29b      	uxth	r3, r3
341888a6:	e003      	b.n	341888b0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x228>
341888a8:	687b      	ldr	r3, [r7, #4]
341888aa:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
341888ae:	b29b      	uxth	r3, r3
341888b0:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
341888b2:	68fb      	ldr	r3, [r7, #12]
341888b4:	681b      	ldr	r3, [r3, #0]
341888b6:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
341888ba:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
341888be:	8a7a      	ldrh	r2, [r7, #18]
341888c0:	8a3b      	ldrh	r3, [r7, #16]
341888c2:	041b      	lsls	r3, r3, #16
341888c4:	431a      	orrs	r2, r3
341888c6:	68fb      	ldr	r3, [r7, #12]
341888c8:	681b      	ldr	r3, [r3, #0]
341888ca:	430a      	orrs	r2, r1
341888cc:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
               ((uint32_t)tmp1 << DCMIPP_P1CCBR1_BR_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCBR1_BG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
341888d0:	687b      	ldr	r3, [r7, #4]
341888d2:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
341888d6:	2b00      	cmp	r3, #0
341888d8:	da07      	bge.n	341888ea <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x262>
341888da:	687b      	ldr	r3, [r7, #4]
341888dc:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
341888e0:	b29b      	uxth	r3, r3
341888e2:	f3c3 030a 	ubfx	r3, r3, #0, #11
341888e6:	b29b      	uxth	r3, r3
341888e8:	e003      	b.n	341888f2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x26a>
341888ea:	687b      	ldr	r3, [r7, #4]
341888ec:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
341888f0:	b29b      	uxth	r3, r3
341888f2:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
341888f4:	687b      	ldr	r3, [r7, #4]
341888f6:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
341888fa:	2b00      	cmp	r3, #0
341888fc:	da07      	bge.n	3418890e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x286>
341888fe:	687b      	ldr	r3, [r7, #4]
34188900:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
34188904:	b29b      	uxth	r3, r3
34188906:	f3c3 0309 	ubfx	r3, r3, #0, #10
3418890a:	b29b      	uxth	r3, r3
3418890c:	e003      	b.n	34188916 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x28e>
3418890e:	687b      	ldr	r3, [r7, #4]
34188910:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
34188914:	b29b      	uxth	r3, r3
34188916:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34188918:	68fb      	ldr	r3, [r7, #12]
3418891a:	681b      	ldr	r3, [r3, #0]
3418891c:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
34188920:	4b09      	ldr	r3, [pc, #36]	@ (34188948 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
34188922:	4013      	ands	r3, r2
34188924:	8a79      	ldrh	r1, [r7, #18]
34188926:	8a3a      	ldrh	r2, [r7, #16]
34188928:	0412      	lsls	r2, r2, #16
3418892a:	4311      	orrs	r1, r2
3418892c:	68fa      	ldr	r2, [r7, #12]
3418892e:	6812      	ldr	r2, [r2, #0]
34188930:	430b      	orrs	r3, r1
34188932:	f8c2 3898 	str.w	r3, [r2, #2200]	@ 0x898
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188936:	2300      	movs	r3, #0
34188938:	e000      	b.n	3418893c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
    return HAL_ERROR;
3418893a:	2301      	movs	r3, #1
}
3418893c:	4618      	mov	r0, r3
3418893e:	371c      	adds	r7, #28
34188940:	46bd      	mov	sp, r7
34188942:	f85d 7b04 	ldr.w	r7, [sp], #4
34188946:	4770      	bx	lr
34188948:	fc00f800 	.word	0xfc00f800

3418894c <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418894c:	b480      	push	{r7}
3418894e:	b083      	sub	sp, #12
34188950:	af00      	add	r7, sp, #0
34188952:	6078      	str	r0, [r7, #4]
34188954:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188956:	687b      	ldr	r3, [r7, #4]
34188958:	2b00      	cmp	r3, #0
3418895a:	d101      	bne.n	34188960 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
  {
    return HAL_ERROR;
3418895c:	2301      	movs	r3, #1
3418895e:	e00f      	b.n	34188980 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188960:	683b      	ldr	r3, [r7, #0]
34188962:	2b01      	cmp	r3, #1
34188964:	d10b      	bne.n	3418897e <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
34188966:	687b      	ldr	r3, [r7, #4]
34188968:	681b      	ldr	r3, [r3, #0]
3418896a:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
3418896e:	687b      	ldr	r3, [r7, #4]
34188970:	681b      	ldr	r3, [r3, #0]
34188972:	f042 0201 	orr.w	r2, r2, #1
34188976:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3418897a:	2300      	movs	r3, #0
3418897c:	e000      	b.n	34188980 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
    return HAL_ERROR;
3418897e:	2301      	movs	r3, #1
}
34188980:	4618      	mov	r0, r3
34188982:	370c      	adds	r7, #12
34188984:	46bd      	mov	sp, r7
34188986:	f85d 7b04 	ldr.w	r7, [sp], #4
3418898a:	4770      	bx	lr

3418898c <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418898c:	b480      	push	{r7}
3418898e:	b083      	sub	sp, #12
34188990:	af00      	add	r7, sp, #0
34188992:	6078      	str	r0, [r7, #4]
34188994:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188996:	687b      	ldr	r3, [r7, #4]
34188998:	2b00      	cmp	r3, #0
3418899a:	d101      	bne.n	341889a0 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
  {
    return HAL_ERROR;
3418899c:	2301      	movs	r3, #1
3418899e:	e00f      	b.n	341889c0 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341889a0:	683b      	ldr	r3, [r7, #0]
341889a2:	2b01      	cmp	r3, #1
341889a4:	d10b      	bne.n	341889be <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
341889a6:	687b      	ldr	r3, [r7, #4]
341889a8:	681b      	ldr	r3, [r3, #0]
341889aa:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
341889ae:	687b      	ldr	r3, [r7, #4]
341889b0:	681b      	ldr	r3, [r3, #0]
341889b2:	f022 0201 	bic.w	r2, r2, #1
341889b6:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
341889ba:	2300      	movs	r3, #0
341889bc:	e000      	b.n	341889c0 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
    return HAL_ERROR;
341889be:	2301      	movs	r3, #1
}
341889c0:	4618      	mov	r0, r3
341889c2:	370c      	adds	r7, #12
341889c4:	46bd      	mov	sp, r7
341889c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341889ca:	4770      	bx	lr

341889cc <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                    const DCMIPP_BlackLevelConfTypeDef
                                                                    *pBlackLevelConfig)
{
341889cc:	b480      	push	{r7}
341889ce:	b085      	sub	sp, #20
341889d0:	af00      	add	r7, sp, #0
341889d2:	60f8      	str	r0, [r7, #12]
341889d4:	60b9      	str	r1, [r7, #8]
341889d6:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
341889d8:	68fb      	ldr	r3, [r7, #12]
341889da:	2b00      	cmp	r3, #0
341889dc:	d002      	beq.n	341889e4 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x18>
341889de:	687b      	ldr	r3, [r7, #4]
341889e0:	2b00      	cmp	r3, #0
341889e2:	d101      	bne.n	341889e8 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1c>
  {
    return HAL_ERROR;
341889e4:	2301      	movs	r3, #1
341889e6:	e01a      	b.n	34188a1e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341889e8:	68bb      	ldr	r3, [r7, #8]
341889ea:	2b01      	cmp	r3, #1
341889ec:	d116      	bne.n	34188a1c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x50>
  {
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
341889ee:	68fb      	ldr	r3, [r7, #12]
341889f0:	681b      	ldr	r3, [r3, #0]
341889f2:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
341889f6:	b2d9      	uxtb	r1, r3
341889f8:	687b      	ldr	r3, [r7, #4]
341889fa:	781b      	ldrb	r3, [r3, #0]
341889fc:	061a      	lsls	r2, r3, #24
341889fe:	687b      	ldr	r3, [r7, #4]
34188a00:	785b      	ldrb	r3, [r3, #1]
34188a02:	041b      	lsls	r3, r3, #16
34188a04:	431a      	orrs	r2, r3
34188a06:	687b      	ldr	r3, [r7, #4]
34188a08:	789b      	ldrb	r3, [r3, #2]
34188a0a:	021b      	lsls	r3, r3, #8
34188a0c:	431a      	orrs	r2, r3
34188a0e:	68fb      	ldr	r3, [r7, #12]
34188a10:	681b      	ldr	r3, [r3, #0]
34188a12:	430a      	orrs	r2, r1
34188a14:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188a18:	2300      	movs	r3, #0
34188a1a:	e000      	b.n	34188a1e <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
    return HAL_ERROR;
34188a1c:	2301      	movs	r3, #1
}
34188a1e:	4618      	mov	r0, r3
34188a20:	3714      	adds	r7, #20
34188a22:	46bd      	mov	sp, r7
34188a24:	f85d 7b04 	ldr.w	r7, [sp], #4
34188a28:	4770      	bx	lr

34188a2a <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188a2a:	b480      	push	{r7}
34188a2c:	b083      	sub	sp, #12
34188a2e:	af00      	add	r7, sp, #0
34188a30:	6078      	str	r0, [r7, #4]
34188a32:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188a34:	687b      	ldr	r3, [r7, #4]
34188a36:	2b00      	cmp	r3, #0
34188a38:	d101      	bne.n	34188a3e <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
34188a3a:	2301      	movs	r3, #1
34188a3c:	e00f      	b.n	34188a5e <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188a3e:	683b      	ldr	r3, [r7, #0]
34188a40:	2b01      	cmp	r3, #1
34188a42:	d10b      	bne.n	34188a5c <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34188a44:	687b      	ldr	r3, [r7, #4]
34188a46:	681b      	ldr	r3, [r3, #0]
34188a48:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
34188a4c:	687b      	ldr	r3, [r7, #4]
34188a4e:	681b      	ldr	r3, [r3, #0]
34188a50:	f042 0201 	orr.w	r2, r2, #1
34188a54:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188a58:	2300      	movs	r3, #0
34188a5a:	e000      	b.n	34188a5e <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
34188a5c:	2301      	movs	r3, #1
}
34188a5e:	4618      	mov	r0, r3
34188a60:	370c      	adds	r7, #12
34188a62:	46bd      	mov	sp, r7
34188a64:	f85d 7b04 	ldr.w	r7, [sp], #4
34188a68:	4770      	bx	lr

34188a6a <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188a6a:	b480      	push	{r7}
34188a6c:	b083      	sub	sp, #12
34188a6e:	af00      	add	r7, sp, #0
34188a70:	6078      	str	r0, [r7, #4]
34188a72:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188a74:	687b      	ldr	r3, [r7, #4]
34188a76:	2b00      	cmp	r3, #0
34188a78:	d101      	bne.n	34188a7e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
34188a7a:	2301      	movs	r3, #1
34188a7c:	e00f      	b.n	34188a9e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188a7e:	683b      	ldr	r3, [r7, #0]
34188a80:	2b01      	cmp	r3, #1
34188a82:	d10b      	bne.n	34188a9c <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
34188a84:	687b      	ldr	r3, [r7, #4]
34188a86:	681b      	ldr	r3, [r3, #0]
34188a88:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
34188a8c:	687b      	ldr	r3, [r7, #4]
34188a8e:	681b      	ldr	r3, [r3, #0]
34188a90:	f022 0201 	bic.w	r2, r2, #1
34188a94:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188a98:	2300      	movs	r3, #0
34188a9a:	e000      	b.n	34188a9e <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
34188a9c:	2301      	movs	r3, #1
}
34188a9e:	4618      	mov	r0, r3
34188aa0:	370c      	adds	r7, #12
34188aa2:	46bd      	mov	sp, r7
34188aa4:	f85d 7b04 	ldr.w	r7, [sp], #4
34188aa8:	4770      	bx	lr

34188aaa <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>:
  *                            filled with the black level calibration configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       DCMIPP_BlackLevelConfTypeDef *pBlackLevelConfig)
{
34188aaa:	b480      	push	{r7}
34188aac:	b087      	sub	sp, #28
34188aae:	af00      	add	r7, sp, #0
34188ab0:	60f8      	str	r0, [r7, #12]
34188ab2:	60b9      	str	r1, [r7, #8]
34188ab4:	607a      	str	r2, [r7, #4]
  uint32_t p1blccr_reg;
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188ab6:	68bb      	ldr	r3, [r7, #8]
34188ab8:	2b01      	cmp	r3, #1
34188aba:	d113      	bne.n	34188ae4 <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig+0x3a>
  {
    p1blccr_reg = READ_REG(hdcmipp->Instance->P1BLCCR);
34188abc:	68fb      	ldr	r3, [r7, #12]
34188abe:	681b      	ldr	r3, [r3, #0]
34188ac0:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
34188ac4:	617b      	str	r3, [r7, #20]
    pBlackLevelConfig->BlueCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCB) >> DCMIPP_P1BLCCR_BLCB_Pos);
34188ac6:	697b      	ldr	r3, [r7, #20]
34188ac8:	0a1b      	lsrs	r3, r3, #8
34188aca:	b2da      	uxtb	r2, r3
34188acc:	687b      	ldr	r3, [r7, #4]
34188ace:	709a      	strb	r2, [r3, #2]
    pBlackLevelConfig->GreenCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCG) >> DCMIPP_P1BLCCR_BLCG_Pos);
34188ad0:	697b      	ldr	r3, [r7, #20]
34188ad2:	0c1b      	lsrs	r3, r3, #16
34188ad4:	b2da      	uxtb	r2, r3
34188ad6:	687b      	ldr	r3, [r7, #4]
34188ad8:	705a      	strb	r2, [r3, #1]
    pBlackLevelConfig->RedCompBlackLevel = (uint8_t)((p1blccr_reg & DCMIPP_P1BLCCR_BLCR) >> DCMIPP_P1BLCCR_BLCR_Pos);
34188ada:	697b      	ldr	r3, [r7, #20]
34188adc:	0e1b      	lsrs	r3, r3, #24
34188ade:	b2da      	uxtb	r2, r3
34188ae0:	687b      	ldr	r3, [r7, #4]
34188ae2:	701a      	strb	r2, [r3, #0]
  }
}
34188ae4:	bf00      	nop
34188ae6:	371c      	adds	r7, #28
34188ae8:	46bd      	mov	sp, r7
34188aea:	f85d 7b04 	ldr.w	r7, [sp], #4
34188aee:	4770      	bx	lr

34188af0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188af0:	b480      	push	{r7}
34188af2:	b083      	sub	sp, #12
34188af4:	af00      	add	r7, sp, #0
34188af6:	6078      	str	r0, [r7, #4]
34188af8:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188afa:	683b      	ldr	r3, [r7, #0]
34188afc:	2b01      	cmp	r3, #1
34188afe:	d10b      	bne.n	34188b18 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE) == DCMIPP_P1BLCCR_ENABLE) ? 1U : 0U);
34188b00:	687b      	ldr	r3, [r7, #4]
34188b02:	681b      	ldr	r3, [r3, #0]
34188b04:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
34188b08:	f003 0301 	and.w	r3, r3, #1
34188b0c:	2b01      	cmp	r3, #1
34188b0e:	d101      	bne.n	34188b14 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x24>
34188b10:	2301      	movs	r3, #1
34188b12:	e002      	b.n	34188b1a <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x2a>
34188b14:	2300      	movs	r3, #0
34188b16:	e000      	b.n	34188b1a <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
34188b18:	2300      	movs	r3, #0
  }
}
34188b1a:	4618      	mov	r0, r3
34188b1c:	370c      	adds	r7, #12
34188b1e:	46bd      	mov	sp, r7
34188b20:	f85d 7b04 	ldr.w	r7, [sp], #4
34188b24:	4770      	bx	lr

34188b26 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                  uint8_t ModuleID, const
                                                                  DCMIPP_StatisticExtractionConfTypeDef
                                                                  *pStatisticExtractionConfig)
{
34188b26:	b480      	push	{r7}
34188b28:	b087      	sub	sp, #28
34188b2a:	af00      	add	r7, sp, #0
34188b2c:	60f8      	str	r0, [r7, #12]
34188b2e:	60b9      	str	r1, [r7, #8]
34188b30:	603b      	str	r3, [r7, #0]
34188b32:	4613      	mov	r3, r2
34188b34:	71fb      	strb	r3, [r7, #7]
  uint32_t p1stxcr_reg;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
34188b36:	68fb      	ldr	r3, [r7, #12]
34188b38:	2b00      	cmp	r3, #0
34188b3a:	d002      	beq.n	34188b42 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x1c>
34188b3c:	683b      	ldr	r3, [r7, #0]
34188b3e:	2b00      	cmp	r3, #0
34188b40:	d101      	bne.n	34188b46 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x20>
  {
    return HAL_ERROR;
34188b42:	2301      	movs	r3, #1
34188b44:	e03b      	b.n	34188bbe <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));

  if (Pipe == DCMIPP_PIPE1)
34188b46:	68bb      	ldr	r3, [r7, #8]
34188b48:	2b01      	cmp	r3, #1
34188b4a:	d135      	bne.n	34188bb8 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x92>
  {
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34188b4c:	683b      	ldr	r3, [r7, #0]
34188b4e:	681a      	ldr	r2, [r3, #0]
34188b50:	683b      	ldr	r3, [r7, #0]
34188b52:	685b      	ldr	r3, [r3, #4]
34188b54:	431a      	orrs	r2, r3
                  (pStatisticExtractionConfig->Bins);
34188b56:	683b      	ldr	r3, [r7, #0]
34188b58:	689b      	ldr	r3, [r3, #8]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34188b5a:	4313      	orrs	r3, r2
34188b5c:	617b      	str	r3, [r7, #20]

    switch (ModuleID)
34188b5e:	79fb      	ldrb	r3, [r7, #7]
34188b60:	2b01      	cmp	r3, #1
34188b62:	d002      	beq.n	34188b6a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x44>
34188b64:	2b02      	cmp	r3, #2
34188b66:	d00d      	beq.n	34188b84 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x5e>
34188b68:	e019      	b.n	34188b9e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x78>
    {
      case DCMIPP_STATEXT_MODULE1:
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34188b6a:	68fb      	ldr	r3, [r7, #12]
34188b6c:	681b      	ldr	r3, [r3, #0]
34188b6e:	f8d3 3850 	ldr.w	r3, [r3, #2128]	@ 0x850
34188b72:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34188b76:	68fb      	ldr	r3, [r7, #12]
34188b78:	681b      	ldr	r3, [r3, #0]
34188b7a:	697a      	ldr	r2, [r7, #20]
34188b7c:	430a      	orrs	r2, r1
34188b7e:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
                   DCMIPP_P1ST1CR_MODE, p1stxcr_reg);
        break;
34188b82:	e01b      	b.n	34188bbc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      case DCMIPP_STATEXT_MODULE2:
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34188b84:	68fb      	ldr	r3, [r7, #12]
34188b86:	681b      	ldr	r3, [r3, #0]
34188b88:	f8d3 3854 	ldr.w	r3, [r3, #2132]	@ 0x854
34188b8c:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34188b90:	68fb      	ldr	r3, [r7, #12]
34188b92:	681b      	ldr	r3, [r3, #0]
34188b94:	697a      	ldr	r2, [r7, #20]
34188b96:	430a      	orrs	r2, r1
34188b98:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
                   DCMIPP_P1ST2CR_MODE, p1stxcr_reg);
        break;
34188b9c:	e00e      	b.n	34188bbc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
34188b9e:	68fb      	ldr	r3, [r7, #12]
34188ba0:	681b      	ldr	r3, [r3, #0]
34188ba2:	f8d3 3858 	ldr.w	r3, [r3, #2136]	@ 0x858
34188ba6:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34188baa:	68fb      	ldr	r3, [r7, #12]
34188bac:	681b      	ldr	r3, [r3, #0]
34188bae:	697a      	ldr	r2, [r7, #20]
34188bb0:	430a      	orrs	r2, r1
34188bb2:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
                   DCMIPP_P1ST3CR_MODE, p1stxcr_reg);
        break;
34188bb6:	e001      	b.n	34188bbc <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
    }
  }
  else
  {
    return HAL_ERROR;
34188bb8:	2301      	movs	r3, #1
34188bba:	e000      	b.n	34188bbe <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  }

  return HAL_OK;
34188bbc:	2300      	movs	r3, #0
}
34188bbe:	4618      	mov	r0, r3
34188bc0:	371c      	adds	r7, #28
34188bc2:	46bd      	mov	sp, r7
34188bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
34188bc8:	4770      	bx	lr

34188bca <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                      const DCMIPP_StatisticExtractionAreaConfTypeDef
                                                                      *pStatisticExtractionAreaConfig)
{
34188bca:	b480      	push	{r7}
34188bcc:	b085      	sub	sp, #20
34188bce:	af00      	add	r7, sp, #0
34188bd0:	60f8      	str	r0, [r7, #12]
34188bd2:	60b9      	str	r1, [r7, #8]
34188bd4:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
34188bd6:	68fb      	ldr	r3, [r7, #12]
34188bd8:	2b00      	cmp	r3, #0
34188bda:	d002      	beq.n	34188be2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x18>
34188bdc:	687b      	ldr	r3, [r7, #4]
34188bde:	2b00      	cmp	r3, #0
34188be0:	d101      	bne.n	34188be6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x1c>
  {
    return HAL_ERROR;
34188be2:	2301      	movs	r3, #1
34188be4:	e027      	b.n	34188c36 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));

  if (Pipe == DCMIPP_PIPE1)
34188be6:	68bb      	ldr	r3, [r7, #8]
34188be8:	2b01      	cmp	r3, #1
34188bea:	d123      	bne.n	34188c34 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6a>
  {
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
34188bec:	68fb      	ldr	r3, [r7, #12]
34188bee:	681b      	ldr	r3, [r3, #0]
34188bf0:	f8d3 385c 	ldr.w	r3, [r3, #2140]	@ 0x85c
34188bf4:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34188bf8:	687b      	ldr	r3, [r7, #4]
34188bfa:	685a      	ldr	r2, [r3, #4]
34188bfc:	687b      	ldr	r3, [r7, #4]
34188bfe:	681b      	ldr	r3, [r3, #0]
34188c00:	041b      	lsls	r3, r3, #16
34188c02:	431a      	orrs	r2, r3
34188c04:	68fb      	ldr	r3, [r7, #12]
34188c06:	681b      	ldr	r3, [r3, #0]
34188c08:	430a      	orrs	r2, r1
34188c0a:	f8c3 285c 	str.w	r2, [r3, #2140]	@ 0x85c
               (pStatisticExtractionAreaConfig->HStart << DCMIPP_P1STSTR_HSTART_Pos) | \
               (pStatisticExtractionAreaConfig->VStart << DCMIPP_P1STSTR_VSTART_Pos));

    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
34188c0e:	68fb      	ldr	r3, [r7, #12]
34188c10:	681b      	ldr	r3, [r3, #0]
34188c12:	f8d3 3860 	ldr.w	r3, [r3, #2144]	@ 0x860
34188c16:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34188c1a:	687b      	ldr	r3, [r7, #4]
34188c1c:	68da      	ldr	r2, [r3, #12]
34188c1e:	687b      	ldr	r3, [r7, #4]
34188c20:	689b      	ldr	r3, [r3, #8]
34188c22:	041b      	lsls	r3, r3, #16
34188c24:	431a      	orrs	r2, r3
34188c26:	68fb      	ldr	r3, [r7, #12]
34188c28:	681b      	ldr	r3, [r3, #0]
34188c2a:	430a      	orrs	r2, r1
34188c2c:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188c30:	2300      	movs	r3, #0
34188c32:	e000      	b.n	34188c36 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
    return HAL_ERROR;
34188c34:	2301      	movs	r3, #1
}
34188c36:	4618      	mov	r0, r3
34188c38:	3714      	adds	r7, #20
34188c3a:	46bd      	mov	sp, r7
34188c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34188c40:	4770      	bx	lr

34188c42 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
  * @param  ModuleID  Specifies the Module ID, can be a value from @ref DCMIPP_Statistics_Extraction_Module_ID.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint8_t ModuleID)
{
34188c42:	b480      	push	{r7}
34188c44:	b085      	sub	sp, #20
34188c46:	af00      	add	r7, sp, #0
34188c48:	60f8      	str	r0, [r7, #12]
34188c4a:	60b9      	str	r1, [r7, #8]
34188c4c:	4613      	mov	r3, r2
34188c4e:	71fb      	strb	r3, [r7, #7]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188c50:	68fb      	ldr	r3, [r7, #12]
34188c52:	2b00      	cmp	r3, #0
34188c54:	d101      	bne.n	34188c5a <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x18>
  {
    return HAL_ERROR;
34188c56:	2301      	movs	r3, #1
34188c58:	e02c      	b.n	34188cb4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34188c5a:	68bb      	ldr	r3, [r7, #8]
34188c5c:	2b01      	cmp	r3, #1
34188c5e:	d126      	bne.n	34188cae <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>
  {
    switch (ModuleID)
34188c60:	79fb      	ldrb	r3, [r7, #7]
34188c62:	2b01      	cmp	r3, #1
34188c64:	d002      	beq.n	34188c6c <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2a>
34188c66:	2b02      	cmp	r3, #2
34188c68:	d00b      	beq.n	34188c82 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34188c6a:	e015      	b.n	34188c98 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x56>
    {
      case DCMIPP_STATEXT_MODULE1:
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34188c6c:	68fb      	ldr	r3, [r7, #12]
34188c6e:	681b      	ldr	r3, [r3, #0]
34188c70:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34188c74:	68fb      	ldr	r3, [r7, #12]
34188c76:	681b      	ldr	r3, [r3, #0]
34188c78:	f042 0201 	orr.w	r2, r2, #1
34188c7c:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
        break;
34188c80:	e017      	b.n	34188cb2 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      case DCMIPP_STATEXT_MODULE2:
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
34188c82:	68fb      	ldr	r3, [r7, #12]
34188c84:	681b      	ldr	r3, [r3, #0]
34188c86:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34188c8a:	68fb      	ldr	r3, [r7, #12]
34188c8c:	681b      	ldr	r3, [r3, #0]
34188c8e:	f042 0201 	orr.w	r2, r2, #1
34188c92:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
34188c96:	e00c      	b.n	34188cb2 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34188c98:	68fb      	ldr	r3, [r7, #12]
34188c9a:	681b      	ldr	r3, [r3, #0]
34188c9c:	f8d3 2858 	ldr.w	r2, [r3, #2136]	@ 0x858
34188ca0:	68fb      	ldr	r3, [r7, #12]
34188ca2:	681b      	ldr	r3, [r3, #0]
34188ca4:	f042 0201 	orr.w	r2, r2, #1
34188ca8:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
        break;
34188cac:	e001      	b.n	34188cb2 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
    }
  }
  else
  {
    return HAL_ERROR;
34188cae:	2301      	movs	r3, #1
34188cb0:	e000      	b.n	34188cb4 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>
  }

  return HAL_OK;
34188cb2:	2300      	movs	r3, #0
}
34188cb4:	4618      	mov	r0, r3
34188cb6:	3714      	adds	r7, #20
34188cb8:	46bd      	mov	sp, r7
34188cba:	f85d 7b04 	ldr.w	r7, [sp], #4
34188cbe:	4770      	bx	lr

34188cc0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188cc0:	b480      	push	{r7}
34188cc2:	b083      	sub	sp, #12
34188cc4:	af00      	add	r7, sp, #0
34188cc6:	6078      	str	r0, [r7, #4]
34188cc8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188cca:	687b      	ldr	r3, [r7, #4]
34188ccc:	2b00      	cmp	r3, #0
34188cce:	d101      	bne.n	34188cd4 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
  {
    return HAL_ERROR;
34188cd0:	2301      	movs	r3, #1
34188cd2:	e00f      	b.n	34188cf4 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188cd4:	683b      	ldr	r3, [r7, #0]
34188cd6:	2b01      	cmp	r3, #1
34188cd8:	d10b      	bne.n	34188cf2 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x32>
  {
    /* Crop line enable */
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
34188cda:	687b      	ldr	r3, [r7, #4]
34188cdc:	681b      	ldr	r3, [r3, #0]
34188cde:	f8d3 2860 	ldr.w	r2, [r3, #2144]	@ 0x860
34188ce2:	687b      	ldr	r3, [r7, #4]
34188ce4:	681b      	ldr	r3, [r3, #0]
34188ce6:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34188cea:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188cee:	2300      	movs	r3, #0
34188cf0:	e000      	b.n	34188cf4 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
    return HAL_ERROR;
34188cf2:	2301      	movs	r3, #1
}
34188cf4:	4618      	mov	r0, r3
34188cf6:	370c      	adds	r7, #12
34188cf8:	46bd      	mov	sp, r7
34188cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
34188cfe:	4770      	bx	lr

34188d00 <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
  * @param  pExposureConfig pointer to the DCMIPP_ExposureConfTypeDef structure that contains the exposure information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPExposureConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       const DCMIPP_ExposureConfTypeDef *pExposureConfig)
{
34188d00:	b480      	push	{r7}
34188d02:	b085      	sub	sp, #20
34188d04:	af00      	add	r7, sp, #0
34188d06:	60f8      	str	r0, [r7, #12]
34188d08:	60b9      	str	r1, [r7, #8]
34188d0a:	607a      	str	r2, [r7, #4]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
34188d0c:	68fb      	ldr	r3, [r7, #12]
34188d0e:	2b00      	cmp	r3, #0
34188d10:	d002      	beq.n	34188d18 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x18>
34188d12:	687b      	ldr	r3, [r7, #4]
34188d14:	2b00      	cmp	r3, #0
34188d16:	d101      	bne.n	34188d1c <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x1c>
  {
    return HAL_ERROR;
34188d18:	2301      	movs	r3, #1
34188d1a:	e02d      	b.n	34188d78 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));

  if (Pipe == DCMIPP_PIPE1)
34188d1c:	68bb      	ldr	r3, [r7, #8]
34188d1e:	2b01      	cmp	r3, #1
34188d20:	d129      	bne.n	34188d76 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x76>
  {
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
34188d22:	68fb      	ldr	r3, [r7, #12]
34188d24:	681b      	ldr	r3, [r3, #0]
34188d26:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
34188d2a:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
34188d2e:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
34188d32:	687a      	ldr	r2, [r7, #4]
34188d34:	7812      	ldrb	r2, [r2, #0]
34188d36:	0711      	lsls	r1, r2, #28
34188d38:	687a      	ldr	r2, [r7, #4]
34188d3a:	7852      	ldrb	r2, [r2, #1]
34188d3c:	0512      	lsls	r2, r2, #20
34188d3e:	4311      	orrs	r1, r2
34188d40:	68fa      	ldr	r2, [r7, #12]
34188d42:	6812      	ldr	r2, [r2, #0]
34188d44:	430b      	orrs	r3, r1
34188d46:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
               (((uint32_t)pExposureConfig->ShiftRed << DCMIPP_P1EXCR1_SHFR_Pos) | \
                ((uint32_t)pExposureConfig->MultiplierRed << DCMIPP_P1EXCR1_MULTR_Pos)));

    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34188d4a:	687b      	ldr	r3, [r7, #4]
34188d4c:	789b      	ldrb	r3, [r3, #2]
34188d4e:	071a      	lsls	r2, r3, #28
34188d50:	687b      	ldr	r3, [r7, #4]
34188d52:	78db      	ldrb	r3, [r3, #3]
34188d54:	051b      	lsls	r3, r3, #20
34188d56:	431a      	orrs	r2, r3
34188d58:	687b      	ldr	r3, [r7, #4]
34188d5a:	791b      	ldrb	r3, [r3, #4]
34188d5c:	031b      	lsls	r3, r3, #12
34188d5e:	ea42 0103 	orr.w	r1, r2, r3
34188d62:	687b      	ldr	r3, [r7, #4]
34188d64:	795b      	ldrb	r3, [r3, #5]
34188d66:	011a      	lsls	r2, r3, #4
34188d68:	68fb      	ldr	r3, [r7, #12]
34188d6a:	681b      	ldr	r3, [r3, #0]
34188d6c:	430a      	orrs	r2, r1
34188d6e:	f8c3 2848 	str.w	r2, [r3, #2120]	@ 0x848
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188d72:	2300      	movs	r3, #0
34188d74:	e000      	b.n	34188d78 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
    return HAL_ERROR;
34188d76:	2301      	movs	r3, #1
}
34188d78:	4618      	mov	r0, r3
34188d7a:	3714      	adds	r7, #20
34188d7c:	46bd      	mov	sp, r7
34188d7e:	f85d 7b04 	ldr.w	r7, [sp], #4
34188d82:	4770      	bx	lr

34188d84 <HAL_DCMIPP_PIPE_EnableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188d84:	b480      	push	{r7}
34188d86:	b083      	sub	sp, #12
34188d88:	af00      	add	r7, sp, #0
34188d8a:	6078      	str	r0, [r7, #4]
34188d8c:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188d8e:	687b      	ldr	r3, [r7, #4]
34188d90:	2b00      	cmp	r3, #0
34188d92:	d101      	bne.n	34188d98 <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
  {
    return HAL_ERROR;
34188d94:	2301      	movs	r3, #1
34188d96:	e00f      	b.n	34188db8 <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188d98:	683b      	ldr	r3, [r7, #0]
34188d9a:	2b01      	cmp	r3, #1
34188d9c:	d10b      	bne.n	34188db6 <HAL_DCMIPP_PIPE_EnableISPExposure+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34188d9e:	687b      	ldr	r3, [r7, #4]
34188da0:	681b      	ldr	r3, [r3, #0]
34188da2:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
34188da6:	687b      	ldr	r3, [r7, #4]
34188da8:	681b      	ldr	r3, [r3, #0]
34188daa:	f042 0201 	orr.w	r2, r2, #1
34188dae:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188db2:	2300      	movs	r3, #0
34188db4:	e000      	b.n	34188db8 <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
    return HAL_ERROR;
34188db6:	2301      	movs	r3, #1
}
34188db8:	4618      	mov	r0, r3
34188dba:	370c      	adds	r7, #12
34188dbc:	46bd      	mov	sp, r7
34188dbe:	f85d 7b04 	ldr.w	r7, [sp], #4
34188dc2:	4770      	bx	lr

34188dc4 <HAL_DCMIPP_PIPE_DisableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188dc4:	b480      	push	{r7}
34188dc6:	b083      	sub	sp, #12
34188dc8:	af00      	add	r7, sp, #0
34188dca:	6078      	str	r0, [r7, #4]
34188dcc:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188dce:	687b      	ldr	r3, [r7, #4]
34188dd0:	2b00      	cmp	r3, #0
34188dd2:	d101      	bne.n	34188dd8 <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
  {
    return HAL_ERROR;
34188dd4:	2301      	movs	r3, #1
34188dd6:	e00f      	b.n	34188df8 <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188dd8:	683b      	ldr	r3, [r7, #0]
34188dda:	2b01      	cmp	r3, #1
34188ddc:	d10b      	bne.n	34188df6 <HAL_DCMIPP_PIPE_DisableISPExposure+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
34188dde:	687b      	ldr	r3, [r7, #4]
34188de0:	681b      	ldr	r3, [r3, #0]
34188de2:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
34188de6:	687b      	ldr	r3, [r7, #4]
34188de8:	681b      	ldr	r3, [r3, #0]
34188dea:	f022 0201 	bic.w	r2, r2, #1
34188dee:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188df2:	2300      	movs	r3, #0
34188df4:	e000      	b.n	34188df8 <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
    return HAL_ERROR;
34188df6:	2301      	movs	r3, #1
}
34188df8:	4618      	mov	r0, r3
34188dfa:	370c      	adds	r7, #12
34188dfc:	46bd      	mov	sp, r7
34188dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
34188e02:	4770      	bx	lr

34188e04 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
  * @param  pContrastConfig pointer to the DCMIPP_ContrastConfTypeDef structure that contains contrast information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_ContrastConfTypeDef *pContrastConfig)
{
34188e04:	b480      	push	{r7}
34188e06:	b085      	sub	sp, #20
34188e08:	af00      	add	r7, sp, #0
34188e0a:	60f8      	str	r0, [r7, #12]
34188e0c:	60b9      	str	r1, [r7, #8]
34188e0e:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
34188e10:	68fb      	ldr	r3, [r7, #12]
34188e12:	2b00      	cmp	r3, #0
34188e14:	d002      	beq.n	34188e1c <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x18>
34188e16:	687b      	ldr	r3, [r7, #4]
34188e18:	2b00      	cmp	r3, #0
34188e1a:	d101      	bne.n	34188e20 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x1c>
  {
    return HAL_ERROR;
34188e1c:	2301      	movs	r3, #1
34188e1e:	e03b      	b.n	34188e98 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));

  if (Pipe == DCMIPP_PIPE1)
34188e20:	68bb      	ldr	r3, [r7, #8]
34188e22:	2b01      	cmp	r3, #1
34188e24:	d137      	bne.n	34188e96 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x92>
  {

    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34188e26:	68fb      	ldr	r3, [r7, #12]
34188e28:	681b      	ldr	r3, [r3, #0]
34188e2a:	f8d3 38a0 	ldr.w	r3, [r3, #2208]	@ 0x8a0
34188e2e:	f423 41fc 	bic.w	r1, r3, #32256	@ 0x7e00
34188e32:	687b      	ldr	r3, [r7, #4]
34188e34:	781b      	ldrb	r3, [r3, #0]
34188e36:	025a      	lsls	r2, r3, #9
34188e38:	68fb      	ldr	r3, [r7, #12]
34188e3a:	681b      	ldr	r3, [r3, #0]
34188e3c:	430a      	orrs	r2, r1
34188e3e:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
               (uint32_t)pContrastConfig->LUM_0 << DCMIPP_P1CTCR1_LUM0_Pos);

    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
34188e42:	687b      	ldr	r3, [r7, #4]
34188e44:	785b      	ldrb	r3, [r3, #1]
34188e46:	065a      	lsls	r2, r3, #25
34188e48:	687b      	ldr	r3, [r7, #4]
34188e4a:	789b      	ldrb	r3, [r3, #2]
34188e4c:	045b      	lsls	r3, r3, #17
34188e4e:	431a      	orrs	r2, r3
34188e50:	687b      	ldr	r3, [r7, #4]
34188e52:	78db      	ldrb	r3, [r3, #3]
34188e54:	025b      	lsls	r3, r3, #9
34188e56:	ea42 0103 	orr.w	r1, r2, r3
34188e5a:	687b      	ldr	r3, [r7, #4]
34188e5c:	791b      	ldrb	r3, [r3, #4]
34188e5e:	005a      	lsls	r2, r3, #1
34188e60:	68fb      	ldr	r3, [r7, #12]
34188e62:	681b      	ldr	r3, [r3, #0]
34188e64:	430a      	orrs	r2, r1
34188e66:	f8c3 28a4 	str.w	r2, [r3, #2212]	@ 0x8a4
                                           ((uint32_t)pContrastConfig->LUM_64 << DCMIPP_P1CTCR2_LUM2_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_96 << DCMIPP_P1CTCR2_LUM3_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_128 << DCMIPP_P1CTCR2_LUM4_Pos)));

    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34188e6a:	687b      	ldr	r3, [r7, #4]
34188e6c:	795b      	ldrb	r3, [r3, #5]
34188e6e:	065a      	lsls	r2, r3, #25
34188e70:	687b      	ldr	r3, [r7, #4]
34188e72:	799b      	ldrb	r3, [r3, #6]
34188e74:	045b      	lsls	r3, r3, #17
34188e76:	431a      	orrs	r2, r3
34188e78:	687b      	ldr	r3, [r7, #4]
34188e7a:	79db      	ldrb	r3, [r3, #7]
34188e7c:	025b      	lsls	r3, r3, #9
34188e7e:	ea42 0103 	orr.w	r1, r2, r3
34188e82:	687b      	ldr	r3, [r7, #4]
34188e84:	7a1b      	ldrb	r3, [r3, #8]
34188e86:	005a      	lsls	r2, r3, #1
34188e88:	68fb      	ldr	r3, [r7, #12]
34188e8a:	681b      	ldr	r3, [r3, #0]
34188e8c:	430a      	orrs	r2, r1
34188e8e:	f8c3 28a8 	str.w	r2, [r3, #2216]	@ 0x8a8
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188e92:	2300      	movs	r3, #0
34188e94:	e000      	b.n	34188e98 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
    return HAL_ERROR;
34188e96:	2301      	movs	r3, #1
}
34188e98:	4618      	mov	r0, r3
34188e9a:	3714      	adds	r7, #20
34188e9c:	46bd      	mov	sp, r7
34188e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34188ea2:	4770      	bx	lr

34188ea4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188ea4:	b480      	push	{r7}
34188ea6:	b083      	sub	sp, #12
34188ea8:	af00      	add	r7, sp, #0
34188eaa:	6078      	str	r0, [r7, #4]
34188eac:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188eae:	687b      	ldr	r3, [r7, #4]
34188eb0:	2b00      	cmp	r3, #0
34188eb2:	d101      	bne.n	34188eb8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
34188eb4:	2301      	movs	r3, #1
34188eb6:	e00f      	b.n	34188ed8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188eb8:	683b      	ldr	r3, [r7, #0]
34188eba:	2b01      	cmp	r3, #1
34188ebc:	d10b      	bne.n	34188ed6 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34188ebe:	687b      	ldr	r3, [r7, #4]
34188ec0:	681b      	ldr	r3, [r3, #0]
34188ec2:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
34188ec6:	687b      	ldr	r3, [r7, #4]
34188ec8:	681b      	ldr	r3, [r3, #0]
34188eca:	f042 0201 	orr.w	r2, r2, #1
34188ece:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188ed2:	2300      	movs	r3, #0
34188ed4:	e000      	b.n	34188ed8 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
    return HAL_ERROR;
34188ed6:	2301      	movs	r3, #1
}
34188ed8:	4618      	mov	r0, r3
34188eda:	370c      	adds	r7, #12
34188edc:	46bd      	mov	sp, r7
34188ede:	f85d 7b04 	ldr.w	r7, [sp], #4
34188ee2:	4770      	bx	lr

34188ee4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188ee4:	b480      	push	{r7}
34188ee6:	b083      	sub	sp, #12
34188ee8:	af00      	add	r7, sp, #0
34188eea:	6078      	str	r0, [r7, #4]
34188eec:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34188eee:	687b      	ldr	r3, [r7, #4]
34188ef0:	2b00      	cmp	r3, #0
34188ef2:	d101      	bne.n	34188ef8 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
34188ef4:	2301      	movs	r3, #1
34188ef6:	e00f      	b.n	34188f18 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34188ef8:	683b      	ldr	r3, [r7, #0]
34188efa:	2b01      	cmp	r3, #1
34188efc:	d10b      	bne.n	34188f16 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
34188efe:	687b      	ldr	r3, [r7, #4]
34188f00:	681b      	ldr	r3, [r3, #0]
34188f02:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
34188f06:	687b      	ldr	r3, [r7, #4]
34188f08:	681b      	ldr	r3, [r3, #0]
34188f0a:	f022 0201 	bic.w	r2, r2, #1
34188f0e:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34188f12:	2300      	movs	r3, #0
34188f14:	e000      	b.n	34188f18 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
    return HAL_ERROR;
34188f16:	2301      	movs	r3, #1
}
34188f18:	4618      	mov	r0, r3
34188f1a:	370c      	adds	r7, #12
34188f1c:	46bd      	mov	sp, r7
34188f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34188f22:	4770      	bx	lr

34188f24 <HAL_DCMIPP_PIPE_SetPitch>:
  * @param  Pipe       Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  LinePitch  the new Pitch value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPitch(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t LinePitch)
{
34188f24:	b480      	push	{r7}
34188f26:	b085      	sub	sp, #20
34188f28:	af00      	add	r7, sp, #0
34188f2a:	60f8      	str	r0, [r7, #12]
34188f2c:	60b9      	str	r1, [r7, #8]
34188f2e:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
34188f30:	68fb      	ldr	r3, [r7, #12]
34188f32:	2b00      	cmp	r3, #0
34188f34:	d101      	bne.n	34188f3a <HAL_DCMIPP_PIPE_SetPitch+0x16>
  {
    return HAL_ERROR;
34188f36:	2301      	movs	r3, #1
34188f38:	e026      	b.n	34188f88 <HAL_DCMIPP_PIPE_SetPitch+0x64>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34188f3a:	68bb      	ldr	r3, [r7, #8]
34188f3c:	2b01      	cmp	r3, #1
34188f3e:	d10e      	bne.n	34188f5e <HAL_DCMIPP_PIPE_SetPitch+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
34188f40:	68fb      	ldr	r3, [r7, #12]
34188f42:	681b      	ldr	r3, [r3, #0]
34188f44:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
34188f48:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34188f4c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34188f50:	68fa      	ldr	r2, [r7, #12]
34188f52:	6812      	ldr	r2, [r2, #0]
34188f54:	6879      	ldr	r1, [r7, #4]
34188f56:	430b      	orrs	r3, r1
34188f58:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
34188f5c:	e013      	b.n	34188f86 <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else if (Pipe == DCMIPP_PIPE2)
34188f5e:	68bb      	ldr	r3, [r7, #8]
34188f60:	2b02      	cmp	r3, #2
34188f62:	d10e      	bne.n	34188f82 <HAL_DCMIPP_PIPE_SetPitch+0x5e>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34188f64:	68fb      	ldr	r3, [r7, #12]
34188f66:	681b      	ldr	r3, [r3, #0]
34188f68:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
34188f6c:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34188f70:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34188f74:	68fa      	ldr	r2, [r7, #12]
34188f76:	6812      	ldr	r2, [r2, #0]
34188f78:	6879      	ldr	r1, [r7, #4]
34188f7a:	430b      	orrs	r3, r1
34188f7c:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
34188f80:	e001      	b.n	34188f86 <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else
  {
    return HAL_ERROR;
34188f82:	2301      	movs	r3, #1
34188f84:	e000      	b.n	34188f88 <HAL_DCMIPP_PIPE_SetPitch+0x64>
  }

  return HAL_OK;
34188f86:	2300      	movs	r3, #0
}
34188f88:	4618      	mov	r0, r3
34188f8a:	3714      	adds	r7, #20
34188f8c:	46bd      	mov	sp, r7
34188f8e:	f85d 7b04 	ldr.w	r7, [sp], #4
34188f92:	4770      	bx	lr

34188f94 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
  * @param  PixelPackerFormat the new Pixel Packer Format value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPixelPackerFormat(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       uint32_t PixelPackerFormat)
{
34188f94:	b480      	push	{r7}
34188f96:	b085      	sub	sp, #20
34188f98:	af00      	add	r7, sp, #0
34188f9a:	60f8      	str	r0, [r7, #12]
34188f9c:	60b9      	str	r1, [r7, #8]
34188f9e:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
34188fa0:	68fb      	ldr	r3, [r7, #12]
34188fa2:	2b00      	cmp	r3, #0
34188fa4:	d101      	bne.n	34188faa <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x16>
  {
    return HAL_ERROR;
34188fa6:	2301      	movs	r3, #1
34188fa8:	e022      	b.n	34188ff0 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34188faa:	68bb      	ldr	r3, [r7, #8]
34188fac:	2b01      	cmp	r3, #1
34188fae:	d10c      	bne.n	34188fca <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x36>
  {
    /* Configure the pixel packer */
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
34188fb0:	68fb      	ldr	r3, [r7, #12]
34188fb2:	681b      	ldr	r3, [r3, #0]
34188fb4:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34188fb8:	f023 010f 	bic.w	r1, r3, #15
34188fbc:	68fb      	ldr	r3, [r7, #12]
34188fbe:	681b      	ldr	r3, [r3, #0]
34188fc0:	687a      	ldr	r2, [r7, #4]
34188fc2:	430a      	orrs	r2, r1
34188fc4:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34188fc8:	e011      	b.n	34188fee <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else if (Pipe == DCMIPP_PIPE2)
34188fca:	68bb      	ldr	r3, [r7, #8]
34188fcc:	2b02      	cmp	r3, #2
34188fce:	d10c      	bne.n	34188fea <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x56>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
34188fd0:	68fb      	ldr	r3, [r7, #12]
34188fd2:	681b      	ldr	r3, [r3, #0]
34188fd4:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
34188fd8:	f023 010f 	bic.w	r1, r3, #15
34188fdc:	68fb      	ldr	r3, [r7, #12]
34188fde:	681b      	ldr	r3, [r3, #0]
34188fe0:	687a      	ldr	r2, [r7, #4]
34188fe2:	430a      	orrs	r2, r1
34188fe4:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34188fe8:	e001      	b.n	34188fee <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else
  {
    return HAL_ERROR;
34188fea:	2301      	movs	r3, #1
34188fec:	e000      	b.n	34188ff0 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  }

  return HAL_OK;
34188fee:	2300      	movs	r3, #0
}
34188ff0:	4618      	mov	r0, r3
34188ff2:	3714      	adds	r7, #20
34188ff4:	46bd      	mov	sp, r7
34188ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
34188ffa:	4770      	bx	lr

34188ffc <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34188ffc:	b480      	push	{r7}
34188ffe:	b083      	sub	sp, #12
34189000:	af00      	add	r7, sp, #0
34189002:	6078      	str	r0, [r7, #4]
34189004:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
34189006:	687b      	ldr	r3, [r7, #4]
34189008:	2b00      	cmp	r3, #0
3418900a:	d101      	bne.n	34189010 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
3418900c:	2301      	movs	r3, #1
3418900e:	e023      	b.n	34189058 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34189010:	687b      	ldr	r3, [r7, #4]
34189012:	791b      	ldrb	r3, [r3, #4]
34189014:	b2db      	uxtb	r3, r3
34189016:	2b02      	cmp	r3, #2
34189018:	d11d      	bne.n	34189056 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
3418901a:	683b      	ldr	r3, [r7, #0]
3418901c:	2b01      	cmp	r3, #1
3418901e:	d10a      	bne.n	34189036 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x3a>
    {
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34189020:	687b      	ldr	r3, [r7, #4]
34189022:	681b      	ldr	r3, [r3, #0]
34189024:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34189028:	687b      	ldr	r3, [r7, #4]
3418902a:	681b      	ldr	r3, [r3, #0]
3418902c:	f042 0210 	orr.w	r2, r2, #16
34189030:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34189034:	e00f      	b.n	34189056 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
34189036:	683b      	ldr	r3, [r7, #0]
34189038:	2b02      	cmp	r3, #2
3418903a:	d10a      	bne.n	34189052 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x56>
    {
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
3418903c:	687b      	ldr	r3, [r7, #4]
3418903e:	681b      	ldr	r3, [r3, #0]
34189040:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
34189044:	687b      	ldr	r3, [r7, #4]
34189046:	681b      	ldr	r3, [r3, #0]
34189048:	f042 0210 	orr.w	r2, r2, #16
3418904c:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34189050:	e001      	b.n	34189056 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
34189052:	2301      	movs	r3, #1
34189054:	e000      	b.n	34189058 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
34189056:	2300      	movs	r3, #0
}
34189058:	4618      	mov	r0, r3
3418905a:	370c      	adds	r7, #12
3418905c:	46bd      	mov	sp, r7
3418905e:	f85d 7b04 	ldr.w	r7, [sp], #4
34189062:	4770      	bx	lr

34189064 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34189064:	b480      	push	{r7}
34189066:	b083      	sub	sp, #12
34189068:	af00      	add	r7, sp, #0
3418906a:	6078      	str	r0, [r7, #4]
3418906c:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
3418906e:	687b      	ldr	r3, [r7, #4]
34189070:	2b00      	cmp	r3, #0
34189072:	d101      	bne.n	34189078 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
34189074:	2301      	movs	r3, #1
34189076:	e023      	b.n	341890c0 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34189078:	687b      	ldr	r3, [r7, #4]
3418907a:	791b      	ldrb	r3, [r3, #4]
3418907c:	b2db      	uxtb	r3, r3
3418907e:	2b02      	cmp	r3, #2
34189080:	d11d      	bne.n	341890be <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
34189082:	683b      	ldr	r3, [r7, #0]
34189084:	2b01      	cmp	r3, #1
34189086:	d10a      	bne.n	3418909e <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x3a>
    {
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34189088:	687b      	ldr	r3, [r7, #4]
3418908a:	681b      	ldr	r3, [r3, #0]
3418908c:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34189090:	687b      	ldr	r3, [r7, #4]
34189092:	681b      	ldr	r3, [r3, #0]
34189094:	f022 0210 	bic.w	r2, r2, #16
34189098:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
3418909c:	e00f      	b.n	341890be <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
3418909e:	683b      	ldr	r3, [r7, #0]
341890a0:	2b02      	cmp	r3, #2
341890a2:	d10a      	bne.n	341890ba <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x56>
    {
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
341890a4:	687b      	ldr	r3, [r7, #4]
341890a6:	681b      	ldr	r3, [r3, #0]
341890a8:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
341890ac:	687b      	ldr	r3, [r7, #4]
341890ae:	681b      	ldr	r3, [r3, #0]
341890b0:	f022 0210 	bic.w	r2, r2, #16
341890b4:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
341890b8:	e001      	b.n	341890be <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
341890ba:	2301      	movs	r3, #1
341890bc:	e000      	b.n	341890c0 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
341890be:	2300      	movs	r3, #0
}
341890c0:	4618      	mov	r0, r3
341890c2:	370c      	adds	r7, #12
341890c4:	46bd      	mov	sp, r7
341890c6:	f85d 7b04 	ldr.w	r7, [sp], #4
341890ca:	4770      	bx	lr

341890cc <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_CSI_EnableShare(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341890cc:	b480      	push	{r7}
341890ce:	b085      	sub	sp, #20
341890d0:	af00      	add	r7, sp, #0
341890d2:	6078      	str	r0, [r7, #4]
341890d4:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  uint32_t tmp1;
  uint32_t tmp2;

  if (Pipe == DCMIPP_PIPE2)
341890d6:	683b      	ldr	r3, [r7, #0]
341890d8:	2b02      	cmp	r3, #2
341890da:	d11d      	bne.n	34189118 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4c>
  {
    /* check that Pipe1 and pipe2 are disabled */
    tmp1 = hdcmipp->Instance->P2FSCR;
341890dc:	687b      	ldr	r3, [r7, #4]
341890de:	681b      	ldr	r3, [r3, #0]
341890e0:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
341890e4:	60fb      	str	r3, [r7, #12]
    tmp2 = hdcmipp->Instance->P1FSCR;
341890e6:	687b      	ldr	r3, [r7, #4]
341890e8:	681b      	ldr	r3, [r3, #0]
341890ea:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
341890ee:	60bb      	str	r3, [r7, #8]
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
341890f0:	68fb      	ldr	r3, [r7, #12]
341890f2:	2b00      	cmp	r3, #0
341890f4:	db02      	blt.n	341890fc <HAL_DCMIPP_PIPE_CSI_EnableShare+0x30>
341890f6:	68bb      	ldr	r3, [r7, #8]
341890f8:	2b00      	cmp	r3, #0
341890fa:	da01      	bge.n	34189100 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>
    {
      return HAL_ERROR;
341890fc:	2301      	movs	r3, #1
341890fe:	e00c      	b.n	3418911a <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    }
    else
    {
      /* Pipe2 receives the same data as Pipe1 */
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34189100:	687b      	ldr	r3, [r7, #4]
34189102:	681b      	ldr	r3, [r3, #0]
34189104:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34189108:	687b      	ldr	r3, [r7, #4]
3418910a:	681b      	ldr	r3, [r3, #0]
3418910c:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34189110:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34189114:	2300      	movs	r3, #0
34189116:	e000      	b.n	3418911a <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    return HAL_ERROR;
34189118:	2301      	movs	r3, #1
}
3418911a:	4618      	mov	r0, r3
3418911c:	3714      	adds	r7, #20
3418911e:	46bd      	mov	sp, r7
34189120:	f85d 7b04 	ldr.w	r7, [sp], #4
34189124:	4770      	bx	lr

34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
  * @param  pCounter pointer to receive the accumulated value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                     uint8_t ModuleID, uint32_t *pCounter)
{
34189126:	b480      	push	{r7}
34189128:	b085      	sub	sp, #20
3418912a:	af00      	add	r7, sp, #0
3418912c:	60f8      	str	r0, [r7, #12]
3418912e:	60b9      	str	r1, [r7, #8]
34189130:	603b      	str	r3, [r7, #0]
34189132:	4613      	mov	r3, r2
34189134:	71fb      	strb	r3, [r7, #7]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
34189136:	68fb      	ldr	r3, [r7, #12]
34189138:	2b00      	cmp	r3, #0
3418913a:	d002      	beq.n	34189142 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x1c>
3418913c:	683b      	ldr	r3, [r7, #0]
3418913e:	2b00      	cmp	r3, #0
34189140:	d101      	bne.n	34189146 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x20>
  {
    return HAL_ERROR;
34189142:	2301      	movs	r3, #1
34189144:	e02b      	b.n	3418919e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34189146:	68bb      	ldr	r3, [r7, #8]
34189148:	2b01      	cmp	r3, #1
3418914a:	d124      	bne.n	34189196 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x70>
  {
    switch (ModuleID)
3418914c:	79fb      	ldrb	r3, [r7, #7]
3418914e:	2b03      	cmp	r3, #3
34189150:	d018      	beq.n	34189184 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5e>
34189152:	2b03      	cmp	r3, #3
34189154:	dc21      	bgt.n	3418919a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
34189156:	2b01      	cmp	r3, #1
34189158:	d002      	beq.n	34189160 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
3418915a:	2b02      	cmp	r3, #2
3418915c:	d009      	beq.n	34189172 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        break;
      case DCMIPP_STATEXT_MODULE3:
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
        break;
      default:
        break;
3418915e:	e01c      	b.n	3418919a <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34189160:	68fb      	ldr	r3, [r7, #12]
34189162:	681b      	ldr	r3, [r3, #0]
34189164:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
34189168:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
3418916c:	683b      	ldr	r3, [r7, #0]
3418916e:	601a      	str	r2, [r3, #0]
        break;
34189170:	e014      	b.n	3418919c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34189172:	68fb      	ldr	r3, [r7, #12]
34189174:	681b      	ldr	r3, [r3, #0]
34189176:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
3418917a:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
3418917e:	683b      	ldr	r3, [r7, #0]
34189180:	601a      	str	r2, [r3, #0]
        break;
34189182:	e00b      	b.n	3418919c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34189184:	68fb      	ldr	r3, [r7, #12]
34189186:	681b      	ldr	r3, [r3, #0]
34189188:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
3418918c:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34189190:	683b      	ldr	r3, [r7, #0]
34189192:	601a      	str	r2, [r3, #0]
        break;
34189194:	e002      	b.n	3418919c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
    }
  }
  else
  {
    return HAL_ERROR;
34189196:	2301      	movs	r3, #1
34189198:	e001      	b.n	3418919e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>
        break;
3418919a:	bf00      	nop
  }

  return HAL_OK;
3418919c:	2300      	movs	r3, #0
}
3418919e:	4618      	mov	r0, r3
341891a0:	3714      	adds	r7, #20
341891a2:	46bd      	mov	sp, r7
341891a4:	f85d 7b04 	ldr.w	r7, [sp], #4
341891a8:	4770      	bx	lr

341891aa <HAL_DCMIPP_PIPE_GetISPExposureConfig>:
  *                         filled with the exposure configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPExposureConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                          DCMIPP_ExposureConfTypeDef *pExposureConfig)
{
341891aa:	b480      	push	{r7}
341891ac:	b087      	sub	sp, #28
341891ae:	af00      	add	r7, sp, #0
341891b0:	60f8      	str	r0, [r7, #12]
341891b2:	60b9      	str	r1, [r7, #8]
341891b4:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341891b6:	68bb      	ldr	r3, [r7, #8]
341891b8:	2b01      	cmp	r3, #1
341891ba:	d130      	bne.n	3418921e <HAL_DCMIPP_PIPE_GetISPExposureConfig+0x74>
  {
    tmp = READ_REG(hdcmipp->Instance->P1EXCR2);
341891bc:	68fb      	ldr	r3, [r7, #12]
341891be:	681b      	ldr	r3, [r3, #0]
341891c0:	f8d3 3848 	ldr.w	r3, [r3, #2120]	@ 0x848
341891c4:	617b      	str	r3, [r7, #20]

    pExposureConfig->MultiplierBlue  = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTB) >> DCMIPP_P1EXCR2_MULTB_Pos);
341891c6:	697b      	ldr	r3, [r7, #20]
341891c8:	091b      	lsrs	r3, r3, #4
341891ca:	b2da      	uxtb	r2, r3
341891cc:	687b      	ldr	r3, [r7, #4]
341891ce:	715a      	strb	r2, [r3, #5]
    pExposureConfig->ShiftBlue       = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFB) >> DCMIPP_P1EXCR2_SHFB_Pos);
341891d0:	697b      	ldr	r3, [r7, #20]
341891d2:	0b1b      	lsrs	r3, r3, #12
341891d4:	b2db      	uxtb	r3, r3
341891d6:	f003 0307 	and.w	r3, r3, #7
341891da:	b2da      	uxtb	r2, r3
341891dc:	687b      	ldr	r3, [r7, #4]
341891de:	711a      	strb	r2, [r3, #4]
    pExposureConfig->ShiftGreen      = (uint8_t)((tmp & DCMIPP_P1EXCR2_SHFG) >> DCMIPP_P1EXCR2_SHFG_Pos);
341891e0:	697b      	ldr	r3, [r7, #20]
341891e2:	0f1b      	lsrs	r3, r3, #28
341891e4:	b2db      	uxtb	r3, r3
341891e6:	f003 0307 	and.w	r3, r3, #7
341891ea:	b2da      	uxtb	r2, r3
341891ec:	687b      	ldr	r3, [r7, #4]
341891ee:	709a      	strb	r2, [r3, #2]
    pExposureConfig->MultiplierGreen = (uint8_t)((tmp & DCMIPP_P1EXCR2_MULTG) >> DCMIPP_P1EXCR2_MULTG_Pos);
341891f0:	697b      	ldr	r3, [r7, #20]
341891f2:	0d1b      	lsrs	r3, r3, #20
341891f4:	b2da      	uxtb	r2, r3
341891f6:	687b      	ldr	r3, [r7, #4]
341891f8:	70da      	strb	r2, [r3, #3]

    tmp = READ_REG(hdcmipp->Instance->P1EXCR1);
341891fa:	68fb      	ldr	r3, [r7, #12]
341891fc:	681b      	ldr	r3, [r3, #0]
341891fe:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
34189202:	617b      	str	r3, [r7, #20]

    pExposureConfig->MultiplierRed   = (uint8_t)((tmp & DCMIPP_P1EXCR1_MULTR) >> DCMIPP_P1EXCR1_MULTR_Pos);
34189204:	697b      	ldr	r3, [r7, #20]
34189206:	0d1b      	lsrs	r3, r3, #20
34189208:	b2da      	uxtb	r2, r3
3418920a:	687b      	ldr	r3, [r7, #4]
3418920c:	705a      	strb	r2, [r3, #1]
    pExposureConfig->ShiftRed        = (uint8_t)((tmp & DCMIPP_P1EXCR1_SHFR) >> DCMIPP_P1EXCR1_SHFR_Pos);
3418920e:	697b      	ldr	r3, [r7, #20]
34189210:	0f1b      	lsrs	r3, r3, #28
34189212:	b2db      	uxtb	r3, r3
34189214:	f003 0307 	and.w	r3, r3, #7
34189218:	b2da      	uxtb	r2, r3
3418921a:	687b      	ldr	r3, [r7, #4]
3418921c:	701a      	strb	r2, [r3, #0]
  }
}
3418921e:	bf00      	nop
34189220:	371c      	adds	r7, #28
34189222:	46bd      	mov	sp, r7
34189224:	f85d 7b04 	ldr.w	r7, [sp], #4
34189228:	4770      	bx	lr

3418922a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  *                                 filled with the color conversion configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPColorConversionConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                 DCMIPP_ColorConversionConfTypeDef *pColorConversionConfig)
{
3418922a:	b480      	push	{r7}
3418922c:	b087      	sub	sp, #28
3418922e:	af00      	add	r7, sp, #0
34189230:	60f8      	str	r0, [r7, #12]
34189232:	60b9      	str	r1, [r7, #8]
34189234:	607a      	str	r2, [r7, #4]
  uint16_t tmp;

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34189236:	68bb      	ldr	r3, [r7, #8]
34189238:	2b01      	cmp	r3, #1
3418923a:	f040 8146 	bne.w	341894ca <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x2a0>
  {
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
3418923e:	68fb      	ldr	r3, [r7, #12]
34189240:	681b      	ldr	r3, [r3, #0]
34189242:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
34189246:	82fb      	strh	r3, [r7, #22]

    UNUSED(tmp);

    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
                                                 ? ENABLE : DISABLE;
34189248:	8afb      	ldrh	r3, [r7, #22]
3418924a:	089b      	lsrs	r3, r3, #2
3418924c:	b2db      	uxtb	r3, r3
3418924e:	f003 0301 	and.w	r3, r3, #1
34189252:	b2da      	uxtb	r2, r3
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34189254:	687b      	ldr	r3, [r7, #4]
34189256:	701a      	strb	r2, [r3, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34189258:	8afb      	ldrh	r3, [r7, #22]
3418925a:	b2db      	uxtb	r3, r3
3418925c:	f003 0302 	and.w	r3, r3, #2
34189260:	b2da      	uxtb	r2, r3
34189262:	687b      	ldr	r3, [r7, #4]
34189264:	705a      	strb	r2, [r3, #1]

    /* Get Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34189266:	68fb      	ldr	r3, [r7, #12]
34189268:	681b      	ldr	r3, [r3, #0]
3418926a:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
3418926e:	0c1b      	lsrs	r3, r3, #16
34189270:	b29b      	uxth	r3, r3
34189272:	f3c3 030a 	ubfx	r3, r3, #0, #11
34189276:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34189278:	8afb      	ldrh	r3, [r7, #22]
3418927a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418927e:	2b00      	cmp	r3, #0
34189280:	d007      	beq.n	34189292 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x68>
34189282:	8afb      	ldrh	r3, [r7, #22]
34189284:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189288:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418928c:	b29b      	uxth	r3, r3
3418928e:	b21b      	sxth	r3, r3
34189290:	e001      	b.n	34189296 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x6c>
34189292:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34189296:	687a      	ldr	r2, [r7, #4]
34189298:	8093      	strh	r3, [r2, #4]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
3418929a:	68fb      	ldr	r3, [r7, #12]
3418929c:	681b      	ldr	r3, [r3, #0]
3418929e:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
341892a2:	b29b      	uxth	r3, r3
341892a4:	f3c3 030a 	ubfx	r3, r3, #0, #11
341892a8:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
341892aa:	8afb      	ldrh	r3, [r7, #22]
341892ac:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341892b0:	2b00      	cmp	r3, #0
341892b2:	d007      	beq.n	341892c4 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9a>
341892b4:	8afb      	ldrh	r3, [r7, #22]
341892b6:	ea6f 5343 	mvn.w	r3, r3, lsl #21
341892ba:	ea6f 5353 	mvn.w	r3, r3, lsr #21
341892be:	b29b      	uxth	r3, r3
341892c0:	b21b      	sxth	r3, r3
341892c2:	e001      	b.n	341892c8 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9e>
341892c4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341892c8:	687a      	ldr	r2, [r7, #4]
341892ca:	8053      	strh	r3, [r2, #2]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
341892cc:	68fb      	ldr	r3, [r7, #12]
341892ce:	681b      	ldr	r3, [r3, #0]
341892d0:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
341892d4:	0c1b      	lsrs	r3, r3, #16
341892d6:	b29b      	uxth	r3, r3
341892d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
341892dc:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
341892de:	8afb      	ldrh	r3, [r7, #22]
341892e0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341892e4:	2b00      	cmp	r3, #0
341892e6:	d007      	beq.n	341892f8 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xce>
341892e8:	8afb      	ldrh	r3, [r7, #22]
341892ea:	ea6f 5383 	mvn.w	r3, r3, lsl #22
341892ee:	ea6f 5393 	mvn.w	r3, r3, lsr #22
341892f2:	b29b      	uxth	r3, r3
341892f4:	b21b      	sxth	r3, r3
341892f6:	e001      	b.n	341892fc <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xd2>
341892f8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341892fc:	687a      	ldr	r2, [r7, #4]
341892fe:	8113      	strh	r3, [r2, #8]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34189300:	68fb      	ldr	r3, [r7, #12]
34189302:	681b      	ldr	r3, [r3, #0]
34189304:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
34189308:	b29b      	uxth	r3, r3
3418930a:	f3c3 030a 	ubfx	r3, r3, #0, #11
3418930e:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34189310:	8afb      	ldrh	r3, [r7, #22]
34189312:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34189316:	2b00      	cmp	r3, #0
34189318:	d007      	beq.n	3418932a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x100>
3418931a:	8afb      	ldrh	r3, [r7, #22]
3418931c:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189320:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34189324:	b29b      	uxth	r3, r3
34189326:	b21b      	sxth	r3, r3
34189328:	e001      	b.n	3418932e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x104>
3418932a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418932e:	687a      	ldr	r2, [r7, #4]
34189330:	80d3      	strh	r3, [r2, #6]

    /* Get Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34189332:	68fb      	ldr	r3, [r7, #12]
34189334:	681b      	ldr	r3, [r3, #0]
34189336:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
3418933a:	0c1b      	lsrs	r3, r3, #16
3418933c:	b29b      	uxth	r3, r3
3418933e:	f3c3 030a 	ubfx	r3, r3, #0, #11
34189342:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34189344:	8afb      	ldrh	r3, [r7, #22]
34189346:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418934a:	2b00      	cmp	r3, #0
3418934c:	d007      	beq.n	3418935e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x134>
3418934e:	8afb      	ldrh	r3, [r7, #22]
34189350:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189354:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34189358:	b29b      	uxth	r3, r3
3418935a:	b21b      	sxth	r3, r3
3418935c:	e001      	b.n	34189362 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>
3418935e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34189362:	687a      	ldr	r2, [r7, #4]
34189364:	8193      	strh	r3, [r2, #12]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34189366:	68fb      	ldr	r3, [r7, #12]
34189368:	681b      	ldr	r3, [r3, #0]
3418936a:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
3418936e:	b29b      	uxth	r3, r3
34189370:	f3c3 030a 	ubfx	r3, r3, #0, #11
34189374:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34189376:	8afb      	ldrh	r3, [r7, #22]
34189378:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418937c:	2b00      	cmp	r3, #0
3418937e:	d007      	beq.n	34189390 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x166>
34189380:	8afb      	ldrh	r3, [r7, #22]
34189382:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189386:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418938a:	b29b      	uxth	r3, r3
3418938c:	b21b      	sxth	r3, r3
3418938e:	e001      	b.n	34189394 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x16a>
34189390:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34189394:	687a      	ldr	r2, [r7, #4]
34189396:	8153      	strh	r3, [r2, #10]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34189398:	68fb      	ldr	r3, [r7, #12]
3418939a:	681b      	ldr	r3, [r3, #0]
3418939c:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
341893a0:	0c1b      	lsrs	r3, r3, #16
341893a2:	b29b      	uxth	r3, r3
341893a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
341893a8:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
341893aa:	8afb      	ldrh	r3, [r7, #22]
341893ac:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341893b0:	2b00      	cmp	r3, #0
341893b2:	d007      	beq.n	341893c4 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19a>
341893b4:	8afb      	ldrh	r3, [r7, #22]
341893b6:	ea6f 5383 	mvn.w	r3, r3, lsl #22
341893ba:	ea6f 5393 	mvn.w	r3, r3, lsr #22
341893be:	b29b      	uxth	r3, r3
341893c0:	b21b      	sxth	r3, r3
341893c2:	e001      	b.n	341893c8 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19e>
341893c4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341893c8:	687a      	ldr	r2, [r7, #4]
341893ca:	8213      	strh	r3, [r2, #16]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
341893cc:	68fb      	ldr	r3, [r7, #12]
341893ce:	681b      	ldr	r3, [r3, #0]
341893d0:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
341893d4:	b29b      	uxth	r3, r3
341893d6:	f3c3 030a 	ubfx	r3, r3, #0, #11
341893da:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
341893dc:	8afb      	ldrh	r3, [r7, #22]
341893de:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341893e2:	2b00      	cmp	r3, #0
341893e4:	d007      	beq.n	341893f6 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1cc>
341893e6:	8afb      	ldrh	r3, [r7, #22]
341893e8:	ea6f 5343 	mvn.w	r3, r3, lsl #21
341893ec:	ea6f 5353 	mvn.w	r3, r3, lsr #21
341893f0:	b29b      	uxth	r3, r3
341893f2:	b21b      	sxth	r3, r3
341893f4:	e001      	b.n	341893fa <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1d0>
341893f6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341893fa:	687a      	ldr	r2, [r7, #4]
341893fc:	81d3      	strh	r3, [r2, #14]

    /* Get Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
341893fe:	68fb      	ldr	r3, [r7, #12]
34189400:	681b      	ldr	r3, [r3, #0]
34189402:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
34189406:	0c1b      	lsrs	r3, r3, #16
34189408:	b29b      	uxth	r3, r3
3418940a:	f3c3 0309 	ubfx	r3, r3, #0, #10
3418940e:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
34189410:	8afb      	ldrh	r3, [r7, #22]
34189412:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34189416:	2b00      	cmp	r3, #0
34189418:	d007      	beq.n	3418942a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x200>
3418941a:	8afb      	ldrh	r3, [r7, #22]
3418941c:	ea6f 5383 	mvn.w	r3, r3, lsl #22
34189420:	ea6f 5393 	mvn.w	r3, r3, lsr #22
34189424:	b29b      	uxth	r3, r3
34189426:	b21b      	sxth	r3, r3
34189428:	e001      	b.n	3418942e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x204>
3418942a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3418942e:	687a      	ldr	r2, [r7, #4]
34189430:	8313      	strh	r3, [r2, #24]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
34189432:	68fb      	ldr	r3, [r7, #12]
34189434:	681b      	ldr	r3, [r3, #0]
34189436:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
3418943a:	b29b      	uxth	r3, r3
3418943c:	f3c3 030a 	ubfx	r3, r3, #0, #11
34189440:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34189442:	8afb      	ldrh	r3, [r7, #22]
34189444:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34189448:	2b00      	cmp	r3, #0
3418944a:	d007      	beq.n	3418945c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x232>
3418944c:	8afb      	ldrh	r3, [r7, #22]
3418944e:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189452:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34189456:	b29b      	uxth	r3, r3
34189458:	b21b      	sxth	r3, r3
3418945a:	e001      	b.n	34189460 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x236>
3418945c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34189460:	687a      	ldr	r2, [r7, #4]
34189462:	82d3      	strh	r3, [r2, #22]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34189464:	68fb      	ldr	r3, [r7, #12]
34189466:	681b      	ldr	r3, [r3, #0]
34189468:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
3418946c:	0c1b      	lsrs	r3, r3, #16
3418946e:	b29b      	uxth	r3, r3
34189470:	f3c3 030a 	ubfx	r3, r3, #0, #11
34189474:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
34189476:	8afb      	ldrh	r3, [r7, #22]
34189478:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418947c:	2b00      	cmp	r3, #0
3418947e:	d007      	beq.n	34189490 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x266>
34189480:	8afb      	ldrh	r3, [r7, #22]
34189482:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34189486:	ea6f 5353 	mvn.w	r3, r3, lsr #21
3418948a:	b29b      	uxth	r3, r3
3418948c:	b21b      	sxth	r3, r3
3418948e:	e001      	b.n	34189494 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x26a>
34189490:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34189494:	687a      	ldr	r2, [r7, #4]
34189496:	8293      	strh	r3, [r2, #20]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
34189498:	68fb      	ldr	r3, [r7, #12]
3418949a:	681b      	ldr	r3, [r3, #0]
3418949c:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
341894a0:	b29b      	uxth	r3, r3
341894a2:	f3c3 030a 	ubfx	r3, r3, #0, #11
341894a6:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
341894a8:	8afb      	ldrh	r3, [r7, #22]
341894aa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341894ae:	2b00      	cmp	r3, #0
341894b0:	d007      	beq.n	341894c2 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x298>
341894b2:	8afb      	ldrh	r3, [r7, #22]
341894b4:	ea6f 5343 	mvn.w	r3, r3, lsl #21
341894b8:	ea6f 5353 	mvn.w	r3, r3, lsr #21
341894bc:	b29b      	uxth	r3, r3
341894be:	b21b      	sxth	r3, r3
341894c0:	e001      	b.n	341894c6 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x29c>
341894c2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
341894c6:	687a      	ldr	r2, [r7, #4]
341894c8:	8253      	strh	r3, [r2, #18]
  }
}
341894ca:	bf00      	nop
341894cc:	371c      	adds	r7, #28
341894ce:	46bd      	mov	sp, r7
341894d0:	f85d 7b04 	ldr.w	r7, [sp], #4
341894d4:	4770      	bx	lr

341894d6 <HAL_DCMIPP_PIPE_IsEnabledISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPExposure(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341894d6:	b480      	push	{r7}
341894d8:	b083      	sub	sp, #12
341894da:	af00      	add	r7, sp, #0
341894dc:	6078      	str	r0, [r7, #4]
341894de:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
341894e0:	683b      	ldr	r3, [r7, #0]
341894e2:	2b01      	cmp	r3, #1
341894e4:	d10b      	bne.n	341894fe <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE) == DCMIPP_P1EXCR1_ENABLE) ? 1U : 0U);
341894e6:	687b      	ldr	r3, [r7, #4]
341894e8:	681b      	ldr	r3, [r3, #0]
341894ea:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
341894ee:	f003 0301 	and.w	r3, r3, #1
341894f2:	2b01      	cmp	r3, #1
341894f4:	d101      	bne.n	341894fa <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x24>
341894f6:	2301      	movs	r3, #1
341894f8:	e002      	b.n	34189500 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x2a>
341894fa:	2300      	movs	r3, #0
341894fc:	e000      	b.n	34189500 <HAL_DCMIPP_PIPE_IsEnabledISPExposure+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
341894fe:	2300      	movs	r3, #0
  }
}
34189500:	4618      	mov	r0, r3
34189502:	370c      	adds	r7, #12
34189504:	46bd      	mov	sp, r7
34189506:	f85d 7b04 	ldr.w	r7, [sp], #4
3418950a:	4770      	bx	lr

3418950c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Pipe to be checked
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3418950c:	b480      	push	{r7}
3418950e:	b083      	sub	sp, #12
34189510:	af00      	add	r7, sp, #0
34189512:	6078      	str	r0, [r7, #4]
34189514:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34189516:	683b      	ldr	r3, [r7, #0]
34189518:	2b01      	cmp	r3, #1
3418951a:	d10b      	bne.n	34189534 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
3418951c:	687b      	ldr	r3, [r7, #4]
3418951e:	681b      	ldr	r3, [r3, #0]
34189520:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
34189524:	f003 0301 	and.w	r3, r3, #1
34189528:	2b01      	cmp	r3, #1
3418952a:	d101      	bne.n	34189530 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x24>
3418952c:	2301      	movs	r3, #1
3418952e:	e002      	b.n	34189536 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
34189530:	2300      	movs	r3, #0
34189532:	e000      	b.n	34189536 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
34189534:	2300      	movs	r3, #0
  }
}
34189536:	4618      	mov	r0, r3
34189538:	370c      	adds	r7, #12
3418953a:	46bd      	mov	sp, r7
3418953c:	f85d 7b04 	ldr.w	r7, [sp], #4
34189540:	4770      	bx	lr

34189542 <HAL_DCMIPP_GetState>:
  * @brief  Return the DCMIPP state
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL state
  */
HAL_DCMIPP_StateTypeDef HAL_DCMIPP_GetState(const DCMIPP_HandleTypeDef *hdcmipp)
{
34189542:	b480      	push	{r7}
34189544:	b083      	sub	sp, #12
34189546:	af00      	add	r7, sp, #0
34189548:	6078      	str	r0, [r7, #4]
  return hdcmipp->State;
3418954a:	687b      	ldr	r3, [r7, #4]
3418954c:	791b      	ldrb	r3, [r3, #4]
3418954e:	b2db      	uxtb	r3, r3
}
34189550:	4618      	mov	r0, r3
34189552:	370c      	adds	r7, #12
34189554:	46bd      	mov	sp, r7
34189556:	f85d 7b04 	ldr.w	r7, [sp], #4
3418955a:	4770      	bx	lr

3418955c <Pipe_Config>:
  * @param  pPipeConfig pointer to the DCMIPP_PipeConfTypeDef structure that contains
  *                     the configuration information for the pipe.
  * @retval None
  */
static void Pipe_Config(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
3418955c:	b480      	push	{r7}
3418955e:	b085      	sub	sp, #20
34189560:	af00      	add	r7, sp, #0
34189562:	60f8      	str	r0, [r7, #12]
34189564:	60b9      	str	r1, [r7, #8]
34189566:	607a      	str	r2, [r7, #4]
  if (Pipe == DCMIPP_PIPE0)
34189568:	68bb      	ldr	r3, [r7, #8]
3418956a:	2b00      	cmp	r3, #0
3418956c:	d10d      	bne.n	3418958a <Pipe_Config+0x2e>
  {
    /* Configure Pipe0 */
    /* Configure Frame Rate */
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
3418956e:	68fb      	ldr	r3, [r7, #12]
34189570:	681b      	ldr	r3, [r3, #0]
34189572:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34189576:	f023 0103 	bic.w	r1, r3, #3
3418957a:	687b      	ldr	r3, [r7, #4]
3418957c:	681a      	ldr	r2, [r3, #0]
3418957e:	68fb      	ldr	r3, [r7, #12]
34189580:	681b      	ldr	r3, [r3, #0]
34189582:	430a      	orrs	r2, r1
34189584:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Configure Pixel Pipe Pitch */
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
               pPipeConfig->PixelPipePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
  }
}
34189588:	e081      	b.n	3418968e <Pipe_Config+0x132>
  else if (Pipe == DCMIPP_PIPE1)
3418958a:	68bb      	ldr	r3, [r7, #8]
3418958c:	2b01      	cmp	r3, #1
3418958e:	d155      	bne.n	3418963c <Pipe_Config+0xe0>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34189590:	68fb      	ldr	r3, [r7, #12]
34189592:	681b      	ldr	r3, [r3, #0]
34189594:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34189598:	f023 0103 	bic.w	r1, r3, #3
3418959c:	687b      	ldr	r3, [r7, #4]
3418959e:	681a      	ldr	r2, [r3, #0]
341895a0:	68fb      	ldr	r3, [r7, #12]
341895a2:	681b      	ldr	r3, [r3, #0]
341895a4:	430a      	orrs	r2, r1
341895a6:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
341895aa:	68fb      	ldr	r3, [r7, #12]
341895ac:	681b      	ldr	r3, [r3, #0]
341895ae:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
341895b2:	f023 010f 	bic.w	r1, r3, #15
341895b6:	687b      	ldr	r3, [r7, #4]
341895b8:	689a      	ldr	r2, [r3, #8]
341895ba:	68fb      	ldr	r3, [r7, #12]
341895bc:	681b      	ldr	r3, [r3, #0]
341895be:	430a      	orrs	r2, r1
341895c0:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
341895c4:	68fb      	ldr	r3, [r7, #12]
341895c6:	681b      	ldr	r3, [r3, #0]
341895c8:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
341895cc:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
341895d0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341895d4:	687a      	ldr	r2, [r7, #4]
341895d6:	6851      	ldr	r1, [r2, #4]
341895d8:	68fa      	ldr	r2, [r7, #12]
341895da:	6812      	ldr	r2, [r2, #0]
341895dc:	430b      	orrs	r3, r1
341895de:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
341895e2:	687b      	ldr	r3, [r7, #4]
341895e4:	689b      	ldr	r3, [r3, #8]
341895e6:	2b07      	cmp	r3, #7
341895e8:	d003      	beq.n	341895f2 <Pipe_Config+0x96>
        (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_2))
341895ea:	687b      	ldr	r3, [r7, #4]
341895ec:	689b      	ldr	r3, [r3, #8]
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
341895ee:	2b08      	cmp	r3, #8
341895f0:	d10f      	bne.n	34189612 <Pipe_Config+0xb6>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
341895f2:	68fb      	ldr	r3, [r7, #12]
341895f4:	681b      	ldr	r3, [r3, #0]
341895f6:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
341895fa:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
341895fe:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34189602:	687a      	ldr	r2, [r7, #4]
34189604:	6851      	ldr	r1, [r2, #4]
34189606:	68fa      	ldr	r2, [r7, #12]
34189608:	6812      	ldr	r2, [r2, #0]
3418960a:	430b      	orrs	r3, r1
3418960c:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
34189610:	e03d      	b.n	3418968e <Pipe_Config+0x132>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
34189612:	687b      	ldr	r3, [r7, #4]
34189614:	689b      	ldr	r3, [r3, #8]
34189616:	2b09      	cmp	r3, #9
34189618:	d139      	bne.n	3418968e <Pipe_Config+0x132>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3418961a:	68fb      	ldr	r3, [r7, #12]
3418961c:	681b      	ldr	r3, [r3, #0]
3418961e:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
34189622:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34189626:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
3418962a:	687a      	ldr	r2, [r7, #4]
3418962c:	6852      	ldr	r2, [r2, #4]
3418962e:	0851      	lsrs	r1, r2, #1
34189630:	68fa      	ldr	r2, [r7, #12]
34189632:	6812      	ldr	r2, [r2, #0]
34189634:	430b      	orrs	r3, r1
34189636:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
3418963a:	e028      	b.n	3418968e <Pipe_Config+0x132>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
3418963c:	68fb      	ldr	r3, [r7, #12]
3418963e:	681b      	ldr	r3, [r3, #0]
34189640:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34189644:	f023 0103 	bic.w	r1, r3, #3
34189648:	687b      	ldr	r3, [r7, #4]
3418964a:	681a      	ldr	r2, [r3, #0]
3418964c:	68fb      	ldr	r3, [r7, #12]
3418964e:	681b      	ldr	r3, [r3, #0]
34189650:	430a      	orrs	r2, r1
34189652:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34189656:	68fb      	ldr	r3, [r7, #12]
34189658:	681b      	ldr	r3, [r3, #0]
3418965a:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
3418965e:	f023 010f 	bic.w	r1, r3, #15
34189662:	687b      	ldr	r3, [r7, #4]
34189664:	689a      	ldr	r2, [r3, #8]
34189666:	68fb      	ldr	r3, [r7, #12]
34189668:	681b      	ldr	r3, [r3, #0]
3418966a:	430a      	orrs	r2, r1
3418966c:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34189670:	68fb      	ldr	r3, [r7, #12]
34189672:	681b      	ldr	r3, [r3, #0]
34189674:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
34189678:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
3418967c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34189680:	687a      	ldr	r2, [r7, #4]
34189682:	6851      	ldr	r1, [r2, #4]
34189684:	68fa      	ldr	r2, [r7, #12]
34189686:	6812      	ldr	r2, [r2, #0]
34189688:	430b      	orrs	r3, r1
3418968a:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
}
3418968e:	bf00      	nop
34189690:	3714      	adds	r7, #20
34189692:	46bd      	mov	sp, r7
34189694:	f85d 7b04 	ldr.w	r7, [sp], #4
34189698:	4770      	bx	lr

3418969a <DCMIPP_CSI_WritePHYReg>:
  * @param  reg_lsb specifies the testcode LSB in testdin
  * @param  val     specifies the page offset in testdin
  * @retval None
  */
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
{
3418969a:	b480      	push	{r7}
3418969c:	b085      	sub	sp, #20
3418969e:	af00      	add	r7, sp, #0
341896a0:	60f8      	str	r0, [r7, #12]
341896a2:	60b9      	str	r1, [r7, #8]
341896a4:	607a      	str	r2, [r7, #4]
341896a6:	603b      	str	r3, [r7, #0]
  /* Based on sequence described at section 5.2.3.2 of DesignWave document */
  /* For writing the 4-bit testcode MSBs */
  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
341896a8:	68fb      	ldr	r3, [r7, #12]
341896aa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341896ae:	695b      	ldr	r3, [r3, #20]
341896b0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341896b4:	68fa      	ldr	r2, [r7, #12]
341896b6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341896ba:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
341896bc:	68fb      	ldr	r3, [r7, #12]
341896be:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341896c2:	691b      	ldr	r3, [r3, #16]
341896c4:	f043 0301 	orr.w	r3, r3, #1
341896c8:	68fa      	ldr	r2, [r7, #12]
341896ca:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341896ce:	6113      	str	r3, [r2, #16]

  /* Place 0x00 in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
341896d0:	68fb      	ldr	r3, [r7, #12]
341896d2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341896d6:	695b      	ldr	r3, [r3, #20]
341896d8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
341896dc:	68fa      	ldr	r2, [r7, #12]
341896de:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341896e2:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
341896e4:	68fb      	ldr	r3, [r7, #12]
341896e6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341896ea:	461a      	mov	r2, r3
341896ec:	2300      	movs	r3, #0
341896ee:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
341896f0:	68fb      	ldr	r3, [r7, #12]
341896f2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341896f6:	461a      	mov	r2, r3
341896f8:	2300      	movs	r3, #0
341896fa:	6153      	str	r3, [r2, #20]

  /* Place the 8-bit word corresponding to the testcode MSBs in testdin */
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
341896fc:	68fb      	ldr	r3, [r7, #12]
341896fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189702:	695a      	ldr	r2, [r3, #20]
34189704:	68bb      	ldr	r3, [r7, #8]
34189706:	b2db      	uxtb	r3, r3
34189708:	4313      	orrs	r3, r2
3418970a:	68fa      	ldr	r2, [r7, #12]
3418970c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34189710:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34189712:	68fb      	ldr	r3, [r7, #12]
34189714:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189718:	691b      	ldr	r3, [r3, #16]
3418971a:	f043 0301 	orr.w	r3, r3, #1
3418971e:	68fa      	ldr	r2, [r7, #12]
34189720:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34189724:	6113      	str	r3, [r2, #16]

  /* For writing the 8-bit testcode LSBs */
  /* Set testclk to low */
  CLEAR_REG(hcsi->PTCR0);
34189726:	68fb      	ldr	r3, [r7, #12]
34189728:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418972c:	461a      	mov	r2, r3
3418972e:	2300      	movs	r3, #0
34189730:	6113      	str	r3, [r2, #16]

  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34189732:	68fb      	ldr	r3, [r7, #12]
34189734:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189738:	695b      	ldr	r3, [r3, #20]
3418973a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418973e:	68fa      	ldr	r2, [r7, #12]
34189740:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34189744:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34189746:	68fb      	ldr	r3, [r7, #12]
34189748:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418974c:	691b      	ldr	r3, [r3, #16]
3418974e:	f043 0301 	orr.w	r3, r3, #1
34189752:	68fa      	ldr	r2, [r7, #12]
34189754:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34189758:	6113      	str	r3, [r2, #16]

  /* Place the 8-bit word test data in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
3418975a:	68fb      	ldr	r3, [r7, #12]
3418975c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189760:	695a      	ldr	r2, [r3, #20]
34189762:	687b      	ldr	r3, [r7, #4]
34189764:	b2db      	uxtb	r3, r3
34189766:	4313      	orrs	r3, r2
34189768:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418976c:	68fa      	ldr	r2, [r7, #12]
3418976e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34189772:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
34189774:	68fb      	ldr	r3, [r7, #12]
34189776:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418977a:	461a      	mov	r2, r3
3418977c:	2300      	movs	r3, #0
3418977e:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
34189780:	68fb      	ldr	r3, [r7, #12]
34189782:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189786:	461a      	mov	r2, r3
34189788:	2300      	movs	r3, #0
3418978a:	6153      	str	r3, [r2, #20]

  /* For writing the data */
  /* Place the 8-bit word corresponding to the page offset in testdin */
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
3418978c:	68fb      	ldr	r3, [r7, #12]
3418978e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34189792:	695a      	ldr	r2, [r3, #20]
34189794:	683b      	ldr	r3, [r7, #0]
34189796:	b2db      	uxtb	r3, r3
34189798:	4313      	orrs	r3, r2
3418979a:	68fa      	ldr	r2, [r7, #12]
3418979c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341897a0:	6153      	str	r3, [r2, #20]

  /* Set testclk to high (test data is programmed internally */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
341897a2:	68fb      	ldr	r3, [r7, #12]
341897a4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341897a8:	691b      	ldr	r3, [r3, #16]
341897aa:	f043 0301 	orr.w	r3, r3, #1
341897ae:	68fa      	ldr	r2, [r7, #12]
341897b0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
341897b4:	6113      	str	r3, [r2, #16]

  /* Finish by setting testclk to low */
  CLEAR_REG(hcsi->PTCR0);
341897b6:	68fb      	ldr	r3, [r7, #12]
341897b8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
341897bc:	461a      	mov	r2, r3
341897be:	2300      	movs	r3, #0
341897c0:	6113      	str	r3, [r2, #16]
}
341897c2:	bf00      	nop
341897c4:	3714      	adds	r7, #20
341897c6:	46bd      	mov	sp, r7
341897c8:	f85d 7b04 	ldr.w	r7, [sp], #4
341897cc:	4770      	bx	lr

341897ce <DCMIPP_SetConfig>:
  * @param  DstAddress  Specifies the destination memory address for the captured data.
  * @param  CaptureMode Specifies the capture mode to be set for the pipe.
  * @retval None
  */
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
{
341897ce:	b480      	push	{r7}
341897d0:	b085      	sub	sp, #20
341897d2:	af00      	add	r7, sp, #0
341897d4:	60f8      	str	r0, [r7, #12]
341897d6:	60b9      	str	r1, [r7, #8]
341897d8:	607a      	str	r2, [r7, #4]
341897da:	603b      	str	r3, [r7, #0]
  if (Pipe == DCMIPP_PIPE0)
341897dc:	68bb      	ldr	r3, [r7, #8]
341897de:	2b00      	cmp	r3, #0
341897e0:	d121      	bne.n	34189826 <DCMIPP_SetConfig+0x58>
  {
    /* Update the DCMIPP pipe State */
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
341897e2:	68fa      	ldr	r2, [r7, #12]
341897e4:	68bb      	ldr	r3, [r7, #8]
341897e6:	4413      	add	r3, r2
341897e8:	3305      	adds	r3, #5
341897ea:	2202      	movs	r2, #2
341897ec:	701a      	strb	r2, [r3, #0]

    /* Set the capture mode */
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
341897ee:	68fb      	ldr	r3, [r7, #12]
341897f0:	681b      	ldr	r3, [r3, #0]
341897f2:	f8d3 1500 	ldr.w	r1, [r3, #1280]	@ 0x500
341897f6:	68fb      	ldr	r3, [r7, #12]
341897f8:	681b      	ldr	r3, [r3, #0]
341897fa:	683a      	ldr	r2, [r7, #0]
341897fc:	430a      	orrs	r2, r1
341897fe:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Set the destination address */
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
34189802:	68fb      	ldr	r3, [r7, #12]
34189804:	681b      	ldr	r3, [r3, #0]
34189806:	687a      	ldr	r2, [r7, #4]
34189808:	f8c3 25c4 	str.w	r2, [r3, #1476]	@ 0x5c4

    /* Enable all required interrupts lines for the PIPE0 */
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
3418980c:	68fb      	ldr	r3, [r7, #12]
3418980e:	681b      	ldr	r3, [r3, #0]
34189810:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34189814:	68fa      	ldr	r2, [r7, #12]
34189816:	6812      	ldr	r2, [r2, #0]
34189818:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
3418981c:	f043 0320 	orr.w	r3, r3, #32
34189820:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0

    /* Enable all required interrupts lines for the PIPE2 */
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
                           DCMIPP_IT_AXI_TRANSFER_ERROR);
  }
}
34189824:	e045      	b.n	341898b2 <DCMIPP_SetConfig+0xe4>
  else if (Pipe == DCMIPP_PIPE1)
34189826:	68bb      	ldr	r3, [r7, #8]
34189828:	2b01      	cmp	r3, #1
3418982a:	d121      	bne.n	34189870 <DCMIPP_SetConfig+0xa2>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3418982c:	68fa      	ldr	r2, [r7, #12]
3418982e:	68bb      	ldr	r3, [r7, #8]
34189830:	4413      	add	r3, r2
34189832:	3305      	adds	r3, #5
34189834:	2202      	movs	r2, #2
34189836:	701a      	strb	r2, [r3, #0]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
34189838:	68fb      	ldr	r3, [r7, #12]
3418983a:	681b      	ldr	r3, [r3, #0]
3418983c:	f8d3 1900 	ldr.w	r1, [r3, #2304]	@ 0x900
34189840:	68fb      	ldr	r3, [r7, #12]
34189842:	681b      	ldr	r3, [r3, #0]
34189844:	683a      	ldr	r2, [r7, #0]
34189846:	430a      	orrs	r2, r1
34189848:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
3418984c:	68fb      	ldr	r3, [r7, #12]
3418984e:	681b      	ldr	r3, [r3, #0]
34189850:	687a      	ldr	r2, [r7, #4]
34189852:	f8c3 29c4 	str.w	r2, [r3, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
34189856:	68fb      	ldr	r3, [r7, #12]
34189858:	681b      	ldr	r3, [r3, #0]
3418985a:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
3418985e:	68fa      	ldr	r2, [r7, #12]
34189860:	6812      	ldr	r2, [r2, #0]
34189862:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
34189866:	f043 0320 	orr.w	r3, r3, #32
3418986a:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0
}
3418986e:	e020      	b.n	341898b2 <DCMIPP_SetConfig+0xe4>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34189870:	68fa      	ldr	r2, [r7, #12]
34189872:	68bb      	ldr	r3, [r7, #8]
34189874:	4413      	add	r3, r2
34189876:	3305      	adds	r3, #5
34189878:	2202      	movs	r2, #2
3418987a:	701a      	strb	r2, [r3, #0]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
3418987c:	68fb      	ldr	r3, [r7, #12]
3418987e:	681b      	ldr	r3, [r3, #0]
34189880:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	@ 0xd00
34189884:	68fb      	ldr	r3, [r7, #12]
34189886:	681b      	ldr	r3, [r3, #0]
34189888:	683a      	ldr	r2, [r7, #0]
3418988a:	430a      	orrs	r2, r1
3418988c:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
34189890:	68fb      	ldr	r3, [r7, #12]
34189892:	681b      	ldr	r3, [r3, #0]
34189894:	687a      	ldr	r2, [r7, #4]
34189896:	f8c3 2dc4 	str.w	r2, [r3, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
3418989a:	68fb      	ldr	r3, [r7, #12]
3418989c:	681b      	ldr	r3, [r3, #0]
3418989e:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
341898a2:	68fa      	ldr	r2, [r7, #12]
341898a4:	6812      	ldr	r2, [r2, #0]
341898a6:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
341898aa:	f043 0320 	orr.w	r3, r3, #32
341898ae:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0
}
341898b2:	bf00      	nop
341898b4:	3714      	adds	r7, #20
341898b6:	46bd      	mov	sp, r7
341898b8:	f85d 7b04 	ldr.w	r7, [sp], #4
341898bc:	4770      	bx	lr

341898be <DCMIPP_EnableCapture>:
  * @param  hdcmipp     Pointer to DCMIPP handle
  * @param  Pipe        Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
static void DCMIPP_EnableCapture(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
341898be:	b480      	push	{r7}
341898c0:	b083      	sub	sp, #12
341898c2:	af00      	add	r7, sp, #0
341898c4:	6078      	str	r0, [r7, #4]
341898c6:	6039      	str	r1, [r7, #0]
  if (Pipe == DCMIPP_PIPE0)
341898c8:	683b      	ldr	r3, [r7, #0]
341898ca:	2b00      	cmp	r3, #0
341898cc:	d114      	bne.n	341898f8 <DCMIPP_EnableCapture+0x3a>
  {
    /* Activate the Pipe */
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
341898ce:	687b      	ldr	r3, [r7, #4]
341898d0:	681b      	ldr	r3, [r3, #0]
341898d2:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
341898d6:	687b      	ldr	r3, [r7, #4]
341898d8:	681b      	ldr	r3, [r3, #0]
341898da:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
341898de:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404

    /* Start the capture */
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
341898e2:	687b      	ldr	r3, [r7, #4]
341898e4:	681b      	ldr	r3, [r3, #0]
341898e6:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
341898ea:	687b      	ldr	r3, [r7, #4]
341898ec:	681b      	ldr	r3, [r3, #0]
341898ee:	f042 0208 	orr.w	r2, r2, #8
341898f2:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);

    /* Start the capture */
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
  }
}
341898f6:	e031      	b.n	3418995c <DCMIPP_EnableCapture+0x9e>
  else if (Pipe == DCMIPP_PIPE1)
341898f8:	683b      	ldr	r3, [r7, #0]
341898fa:	2b01      	cmp	r3, #1
341898fc:	d11a      	bne.n	34189934 <DCMIPP_EnableCapture+0x76>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
341898fe:	687a      	ldr	r2, [r7, #4]
34189900:	683b      	ldr	r3, [r7, #0]
34189902:	4413      	add	r3, r2
34189904:	3305      	adds	r3, #5
34189906:	2202      	movs	r2, #2
34189908:	701a      	strb	r2, [r3, #0]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
3418990a:	687b      	ldr	r3, [r7, #4]
3418990c:	681b      	ldr	r3, [r3, #0]
3418990e:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34189912:	687b      	ldr	r3, [r7, #4]
34189914:	681b      	ldr	r3, [r3, #0]
34189916:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3418991a:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
3418991e:	687b      	ldr	r3, [r7, #4]
34189920:	681b      	ldr	r3, [r3, #0]
34189922:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
34189926:	687b      	ldr	r3, [r7, #4]
34189928:	681b      	ldr	r3, [r3, #0]
3418992a:	f042 0208 	orr.w	r2, r2, #8
3418992e:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
34189932:	e013      	b.n	3418995c <DCMIPP_EnableCapture+0x9e>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
34189934:	687b      	ldr	r3, [r7, #4]
34189936:	681b      	ldr	r3, [r3, #0]
34189938:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
3418993c:	687b      	ldr	r3, [r7, #4]
3418993e:	681b      	ldr	r3, [r3, #0]
34189940:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34189944:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
34189948:	687b      	ldr	r3, [r7, #4]
3418994a:	681b      	ldr	r3, [r3, #0]
3418994c:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
34189950:	687b      	ldr	r3, [r7, #4]
34189952:	681b      	ldr	r3, [r3, #0]
34189954:	f042 0208 	orr.w	r2, r2, #8
34189958:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
3418995c:	bf00      	nop
3418995e:	370c      	adds	r7, #12
34189960:	46bd      	mov	sp, r7
34189962:	f85d 7b04 	ldr.w	r7, [sp], #4
34189966:	4770      	bx	lr

34189968 <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
34189968:	b580      	push	{r7, lr}
3418996a:	b086      	sub	sp, #24
3418996c:	af00      	add	r7, sp, #0
3418996e:	60f8      	str	r0, [r7, #12]
34189970:	60b9      	str	r1, [r7, #8]
34189972:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34189974:	4b48      	ldr	r3, [pc, #288]	@ (34189a98 <DCMIPP_CSI_SetVCConfig+0x130>)
34189976:	617b      	str	r3, [r7, #20]
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
34189978:	68bb      	ldr	r3, [r7, #8]
3418997a:	2b00      	cmp	r3, #0
3418997c:	d10d      	bne.n	3418999a <DCMIPP_CSI_SetVCConfig+0x32>
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
3418997e:	68fb      	ldr	r3, [r7, #12]
34189980:	681b      	ldr	r3, [r3, #0]
34189982:	f8d3 3404 	ldr.w	r3, [r3, #1028]	@ 0x404
34189986:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
3418998a:	687b      	ldr	r3, [r7, #4]
3418998c:	04da      	lsls	r2, r3, #19
3418998e:	68fb      	ldr	r3, [r7, #12]
34189990:	681b      	ldr	r3, [r3, #0]
34189992:	430a      	orrs	r2, r1
34189994:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
34189998:	e026      	b.n	341899e8 <DCMIPP_CSI_SetVCConfig+0x80>
  }
  else if (Pipe == DCMIPP_PIPE1)
3418999a:	68bb      	ldr	r3, [r7, #8]
3418999c:	2b01      	cmp	r3, #1
3418999e:	d10d      	bne.n	341899bc <DCMIPP_CSI_SetVCConfig+0x54>
  {
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
341899a0:	68fb      	ldr	r3, [r7, #12]
341899a2:	681b      	ldr	r3, [r3, #0]
341899a4:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
341899a8:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
341899ac:	687b      	ldr	r3, [r7, #4]
341899ae:	04da      	lsls	r2, r3, #19
341899b0:	68fb      	ldr	r3, [r7, #12]
341899b2:	681b      	ldr	r3, [r3, #0]
341899b4:	430a      	orrs	r2, r1
341899b6:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
341899ba:	e015      	b.n	341899e8 <DCMIPP_CSI_SetVCConfig+0x80>
  }
  else
  {
    /* Those bit fields are meaningful when PIPEDIFF = 1: Pipe1, Pipe2 is fully independent */
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
341899bc:	68fb      	ldr	r3, [r7, #12]
341899be:	681b      	ldr	r3, [r3, #0]
341899c0:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
341899c4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
341899c8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
341899cc:	d10c      	bne.n	341899e8 <DCMIPP_CSI_SetVCConfig+0x80>
    {
      /* Set Virtual Channel ID and DTIDA for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
341899ce:	68fb      	ldr	r3, [r7, #12]
341899d0:	681b      	ldr	r3, [r3, #0]
341899d2:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
341899d6:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
341899da:	687b      	ldr	r3, [r7, #4]
341899dc:	04da      	lsls	r2, r3, #19
341899de:	68fb      	ldr	r3, [r7, #12]
341899e0:	681b      	ldr	r3, [r3, #0]
341899e2:	430a      	orrs	r2, r1
341899e4:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
341899e8:	687b      	ldr	r3, [r7, #4]
341899ea:	2b03      	cmp	r3, #3
341899ec:	d017      	beq.n	34189a1e <DCMIPP_CSI_SetVCConfig+0xb6>
341899ee:	687b      	ldr	r3, [r7, #4]
341899f0:	2b03      	cmp	r3, #3
341899f2:	d81b      	bhi.n	34189a2c <DCMIPP_CSI_SetVCConfig+0xc4>
341899f4:	687b      	ldr	r3, [r7, #4]
341899f6:	2b01      	cmp	r3, #1
341899f8:	d003      	beq.n	34189a02 <DCMIPP_CSI_SetVCConfig+0x9a>
341899fa:	687b      	ldr	r3, [r7, #4]
341899fc:	2b02      	cmp	r3, #2
341899fe:	d007      	beq.n	34189a10 <DCMIPP_CSI_SetVCConfig+0xa8>
34189a00:	e014      	b.n	34189a2c <DCMIPP_CSI_SetVCConfig+0xc4>
  {
    case DCMIPP_VIRTUAL_CHANNEL1:
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
34189a02:	697b      	ldr	r3, [r7, #20]
34189a04:	681b      	ldr	r3, [r3, #0]
34189a06:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
34189a0a:	697b      	ldr	r3, [r7, #20]
34189a0c:	601a      	str	r2, [r3, #0]
      break;
34189a0e:	e014      	b.n	34189a3a <DCMIPP_CSI_SetVCConfig+0xd2>
    case DCMIPP_VIRTUAL_CHANNEL2:
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
34189a10:	697b      	ldr	r3, [r7, #20]
34189a12:	681b      	ldr	r3, [r3, #0]
34189a14:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34189a18:	697b      	ldr	r3, [r7, #20]
34189a1a:	601a      	str	r2, [r3, #0]
      break;
34189a1c:	e00d      	b.n	34189a3a <DCMIPP_CSI_SetVCConfig+0xd2>
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
34189a1e:	697b      	ldr	r3, [r7, #20]
34189a20:	681b      	ldr	r3, [r3, #0]
34189a22:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
34189a26:	697b      	ldr	r3, [r7, #20]
34189a28:	601a      	str	r2, [r3, #0]
      break;
34189a2a:	e006      	b.n	34189a3a <DCMIPP_CSI_SetVCConfig+0xd2>
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
34189a2c:	697b      	ldr	r3, [r7, #20]
34189a2e:	681b      	ldr	r3, [r3, #0]
34189a30:	f043 0204 	orr.w	r2, r3, #4
34189a34:	697b      	ldr	r3, [r7, #20]
34189a36:	601a      	str	r2, [r3, #0]
      break;
34189a38:	bf00      	nop
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
34189a3a:	f7fc fd69 	bl	34186510 <HAL_GetTick>
34189a3e:	6138      	str	r0, [r7, #16]
  do
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
34189a40:	f7fc fd66 	bl	34186510 <HAL_GetTick>
34189a44:	4602      	mov	r2, r0
34189a46:	693b      	ldr	r3, [r7, #16]
34189a48:	1ad3      	subs	r3, r2, r3
34189a4a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34189a4e:	d901      	bls.n	34189a54 <DCMIPP_CSI_SetVCConfig+0xec>
    {
      return HAL_ERROR;
34189a50:	2301      	movs	r3, #1
34189a52:	e01c      	b.n	34189a8e <DCMIPP_CSI_SetVCConfig+0x126>
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
34189a54:	697b      	ldr	r3, [r7, #20]
34189a56:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34189a5a:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
34189a5e:	687b      	ldr	r3, [r7, #4]
34189a60:	fa01 f303 	lsl.w	r3, r1, r3
34189a64:	401a      	ands	r2, r3
34189a66:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
34189a6a:	687b      	ldr	r3, [r7, #4]
34189a6c:	fa01 f303 	lsl.w	r3, r1, r3
34189a70:	429a      	cmp	r2, r3
34189a72:	d1e5      	bne.n	34189a40 <DCMIPP_CSI_SetVCConfig+0xd8>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
34189a74:	697b      	ldr	r3, [r7, #20]
34189a76:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34189a7a:	f44f 5188 	mov.w	r1, #4352	@ 0x1100
34189a7e:	687b      	ldr	r3, [r7, #4]
34189a80:	fa01 f303 	lsl.w	r3, r1, r3
34189a84:	431a      	orrs	r2, r3
34189a86:	697b      	ldr	r3, [r7, #20]
34189a88:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
34189a8c:	2300      	movs	r3, #0
}
34189a8e:	4618      	mov	r0, r3
34189a90:	3718      	adds	r7, #24
34189a92:	46bd      	mov	sp, r7
34189a94:	bd80      	pop	{r7, pc}
34189a96:	bf00      	nop
34189a98:	58006000 	.word	0x58006000

34189a9c <HAL_DMA_Abort>:
  *         is suspended while a data transfer is on-going, the current data will be transferred and the channel will be
  *         effectively suspended only after the transfer of any on-going data is finished.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *const hdma)
{
34189a9c:	b580      	push	{r7, lr}
34189a9e:	b084      	sub	sp, #16
34189aa0:	af00      	add	r7, sp, #0
34189aa2:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart =  HAL_GetTick();
34189aa4:	f7fc fd34 	bl	34186510 <HAL_GetTick>
34189aa8:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
34189aaa:	687b      	ldr	r3, [r7, #4]
34189aac:	2b00      	cmp	r3, #0
34189aae:	d101      	bne.n	34189ab4 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
34189ab0:	2301      	movs	r3, #1
34189ab2:	e06b      	b.n	34189b8c <HAL_DMA_Abort+0xf0>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
34189ab4:	687b      	ldr	r3, [r7, #4]
34189ab6:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34189aba:	b2db      	uxtb	r3, r3
34189abc:	2b02      	cmp	r3, #2
34189abe:	d008      	beq.n	34189ad2 <HAL_DMA_Abort+0x36>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
34189ac0:	687b      	ldr	r3, [r7, #4]
34189ac2:	2220      	movs	r2, #32
34189ac4:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
34189ac6:	687b      	ldr	r3, [r7, #4]
34189ac8:	2200      	movs	r2, #0
34189aca:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    return HAL_ERROR;
34189ace:	2301      	movs	r3, #1
34189ad0:	e05c      	b.n	34189b8c <HAL_DMA_Abort+0xf0>
  }
  else
  {
    /* Suspend the channel */
    hdma->Instance->CCR |= DMA_CCR_SUSP;
34189ad2:	687b      	ldr	r3, [r7, #4]
34189ad4:	681b      	ldr	r3, [r3, #0]
34189ad6:	695a      	ldr	r2, [r3, #20]
34189ad8:	687b      	ldr	r3, [r7, #4]
34189ada:	681b      	ldr	r3, [r3, #0]
34189adc:	f042 0204 	orr.w	r2, r2, #4
34189ae0:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_SUSPEND;
34189ae2:	687b      	ldr	r3, [r7, #4]
34189ae4:	2205      	movs	r2, #5
34189ae6:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check if the DMA Channel is suspended */
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
34189aea:	e020      	b.n	34189b2e <HAL_DMA_Abort+0x92>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
34189aec:	f7fc fd10 	bl	34186510 <HAL_GetTick>
34189af0:	4602      	mov	r2, r0
34189af2:	68fb      	ldr	r3, [r7, #12]
34189af4:	1ad3      	subs	r3, r2, r3
34189af6:	2b05      	cmp	r3, #5
34189af8:	d919      	bls.n	34189b2e <HAL_DMA_Abort+0x92>
      {
        /* Update the DMA channel error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
34189afa:	687b      	ldr	r3, [r7, #4]
34189afc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34189afe:	f043 0210 	orr.w	r2, r3, #16
34189b02:	687b      	ldr	r3, [r7, #4]
34189b04:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_ERROR;
34189b06:	687b      	ldr	r3, [r7, #4]
34189b08:	2203      	movs	r2, #3
34189b0a:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
34189b0e:	687b      	ldr	r3, [r7, #4]
34189b10:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34189b12:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34189b16:	2b00      	cmp	r3, #0
34189b18:	d003      	beq.n	34189b22 <HAL_DMA_Abort+0x86>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34189b1a:	687b      	ldr	r3, [r7, #4]
34189b1c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34189b1e:	2201      	movs	r2, #1
34189b20:	731a      	strb	r2, [r3, #12]
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
34189b22:	687b      	ldr	r3, [r7, #4]
34189b24:	2200      	movs	r2, #0
34189b26:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        return HAL_ERROR;
34189b2a:	2301      	movs	r3, #1
34189b2c:	e02e      	b.n	34189b8c <HAL_DMA_Abort+0xf0>
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
34189b2e:	687b      	ldr	r3, [r7, #4]
34189b30:	681b      	ldr	r3, [r3, #0]
34189b32:	691b      	ldr	r3, [r3, #16]
34189b34:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34189b38:	2b00      	cmp	r3, #0
34189b3a:	d0d7      	beq.n	34189aec <HAL_DMA_Abort+0x50>
      }
    }

    /* Reset the channel */
    hdma->Instance->CCR |= DMA_CCR_RESET;
34189b3c:	687b      	ldr	r3, [r7, #4]
34189b3e:	681b      	ldr	r3, [r3, #0]
34189b40:	695a      	ldr	r2, [r3, #20]
34189b42:	687b      	ldr	r3, [r7, #4]
34189b44:	681b      	ldr	r3, [r3, #0]
34189b46:	f042 0202 	orr.w	r2, r2, #2
34189b4a:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
34189b4c:	687b      	ldr	r3, [r7, #4]
34189b4e:	2204      	movs	r2, #4
34189b50:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Clear all status flags */
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
34189b54:	687b      	ldr	r3, [r7, #4]
34189b56:	681b      	ldr	r3, [r3, #0]
34189b58:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
34189b5c:	60da      	str	r2, [r3, #12]
                                DMA_FLAG_TO));

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
34189b5e:	687b      	ldr	r3, [r7, #4]
34189b60:	2201      	movs	r2, #1
34189b62:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
34189b66:	687b      	ldr	r3, [r7, #4]
34189b68:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34189b6a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34189b6e:	2b00      	cmp	r3, #0
34189b70:	d007      	beq.n	34189b82 <HAL_DMA_Abort+0xe6>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
34189b72:	687b      	ldr	r3, [r7, #4]
34189b74:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34189b76:	2201      	movs	r2, #1
34189b78:	731a      	strb	r2, [r3, #12]

      /* Clear remaining data size to ensure loading linked-list from memory next start */
      hdma->Instance->CBR1 = 0U;
34189b7a:	687b      	ldr	r3, [r7, #4]
34189b7c:	681b      	ldr	r3, [r3, #0]
34189b7e:	2200      	movs	r2, #0
34189b80:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
34189b82:	687b      	ldr	r3, [r7, #4]
34189b84:	2200      	movs	r2, #0
34189b86:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
  }

  return HAL_OK;
34189b8a:	2300      	movs	r3, #0
}
34189b8c:	4618      	mov	r0, r3
34189b8e:	3710      	adds	r7, #16
34189b90:	46bd      	mov	sp, r7
34189b92:	bd80      	pop	{r7, pc}

34189b94 <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
34189b94:	b580      	push	{r7, lr}
34189b96:	b082      	sub	sp, #8
34189b98:	af00      	add	r7, sp, #0
34189b9a:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
34189b9c:	687b      	ldr	r3, [r7, #4]
34189b9e:	2b00      	cmp	r3, #0
34189ba0:	d101      	bne.n	34189ba6 <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
34189ba2:	2301      	movs	r3, #1
34189ba4:	e053      	b.n	34189c4e <HAL_DMA2D_Init+0xba>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
34189ba6:	687b      	ldr	r3, [r7, #4]
34189ba8:	f893 3061 	ldrb.w	r3, [r3, #97]	@ 0x61
34189bac:	b2db      	uxtb	r3, r3
34189bae:	2b00      	cmp	r3, #0
34189bb0:	d106      	bne.n	34189bc0 <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
34189bb2:	687b      	ldr	r3, [r7, #4]
34189bb4:	2200      	movs	r2, #0
34189bb6:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
34189bba:	6878      	ldr	r0, [r7, #4]
34189bbc:	f000 f84b 	bl	34189c56 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34189bc0:	687b      	ldr	r3, [r7, #4]
34189bc2:	2202      	movs	r2, #2
34189bc4:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34189bc8:	687b      	ldr	r3, [r7, #4]
34189bca:	681b      	ldr	r3, [r3, #0]
34189bcc:	681b      	ldr	r3, [r3, #0]
34189bce:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
34189bd2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34189bd6:	687a      	ldr	r2, [r7, #4]
34189bd8:	6851      	ldr	r1, [r2, #4]
34189bda:	687a      	ldr	r2, [r7, #4]
34189bdc:	69d2      	ldr	r2, [r2, #28]
34189bde:	4311      	orrs	r1, r2
34189be0:	687a      	ldr	r2, [r7, #4]
34189be2:	6812      	ldr	r2, [r2, #0]
34189be4:	430b      	orrs	r3, r1
34189be6:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34189be8:	687b      	ldr	r3, [r7, #4]
34189bea:	681b      	ldr	r3, [r3, #0]
34189bec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34189bee:	f423 7383 	bic.w	r3, r3, #262	@ 0x106
34189bf2:	f023 0301 	bic.w	r3, r3, #1
34189bf6:	687a      	ldr	r2, [r7, #4]
34189bf8:	6891      	ldr	r1, [r2, #8]
34189bfa:	687a      	ldr	r2, [r7, #4]
34189bfc:	6992      	ldr	r2, [r2, #24]
34189bfe:	4311      	orrs	r1, r2
34189c00:	687a      	ldr	r2, [r7, #4]
34189c02:	6812      	ldr	r2, [r2, #0]
34189c04:	430b      	orrs	r3, r1
34189c06:	6353      	str	r3, [r2, #52]	@ 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34189c08:	687b      	ldr	r3, [r7, #4]
34189c0a:	681b      	ldr	r3, [r3, #0]
34189c0c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34189c0e:	0c1b      	lsrs	r3, r3, #16
34189c10:	041b      	lsls	r3, r3, #16
34189c12:	687a      	ldr	r2, [r7, #4]
34189c14:	68d1      	ldr	r1, [r2, #12]
34189c16:	687a      	ldr	r2, [r7, #4]
34189c18:	6812      	ldr	r2, [r2, #0]
34189c1a:	430b      	orrs	r3, r1
34189c1c:	6413      	str	r3, [r2, #64]	@ 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
34189c1e:	687b      	ldr	r3, [r7, #4]
34189c20:	681b      	ldr	r3, [r3, #0]
34189c22:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34189c24:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
34189c28:	687b      	ldr	r3, [r7, #4]
34189c2a:	691b      	ldr	r3, [r3, #16]
34189c2c:	051a      	lsls	r2, r3, #20
34189c2e:	687b      	ldr	r3, [r7, #4]
34189c30:	695b      	ldr	r3, [r3, #20]
34189c32:	055b      	lsls	r3, r3, #21
34189c34:	431a      	orrs	r2, r3
34189c36:	687b      	ldr	r3, [r7, #4]
34189c38:	681b      	ldr	r3, [r3, #0]
34189c3a:	430a      	orrs	r2, r1
34189c3c:	635a      	str	r2, [r3, #52]	@ 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34189c3e:	687b      	ldr	r3, [r7, #4]
34189c40:	2200      	movs	r2, #0
34189c42:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
34189c44:	687b      	ldr	r3, [r7, #4]
34189c46:	2201      	movs	r2, #1
34189c48:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  return HAL_OK;
34189c4c:	2300      	movs	r3, #0
}
34189c4e:	4618      	mov	r0, r3
34189c50:	3708      	adds	r7, #8
34189c52:	46bd      	mov	sp, r7
34189c54:	bd80      	pop	{r7, pc}

34189c56 <HAL_DMA2D_MspInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
34189c56:	b480      	push	{r7}
34189c58:	b083      	sub	sp, #12
34189c5a:	af00      	add	r7, sp, #0
34189c5c:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   */
}
34189c5e:	bf00      	nop
34189c60:	370c      	adds	r7, #12
34189c62:	46bd      	mov	sp, r7
34189c64:	f85d 7b04 	ldr.w	r7, [sp], #4
34189c68:	4770      	bx	lr

34189c6a <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
34189c6a:	b580      	push	{r7, lr}
34189c6c:	b086      	sub	sp, #24
34189c6e:	af02      	add	r7, sp, #8
34189c70:	60f8      	str	r0, [r7, #12]
34189c72:	60b9      	str	r1, [r7, #8]
34189c74:	607a      	str	r2, [r7, #4]
34189c76:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
34189c78:	68fb      	ldr	r3, [r7, #12]
34189c7a:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
34189c7e:	2b01      	cmp	r3, #1
34189c80:	d101      	bne.n	34189c86 <HAL_DMA2D_Start+0x1c>
34189c82:	2302      	movs	r3, #2
34189c84:	e018      	b.n	34189cb8 <HAL_DMA2D_Start+0x4e>
34189c86:	68fb      	ldr	r3, [r7, #12]
34189c88:	2201      	movs	r2, #1
34189c8a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34189c8e:	68fb      	ldr	r3, [r7, #12]
34189c90:	2202      	movs	r2, #2
34189c92:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
34189c96:	69bb      	ldr	r3, [r7, #24]
34189c98:	9300      	str	r3, [sp, #0]
34189c9a:	683b      	ldr	r3, [r7, #0]
34189c9c:	687a      	ldr	r2, [r7, #4]
34189c9e:	68b9      	ldr	r1, [r7, #8]
34189ca0:	68f8      	ldr	r0, [r7, #12]
34189ca2:	f000 f9a5 	bl	34189ff0 <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
34189ca6:	68fb      	ldr	r3, [r7, #12]
34189ca8:	681b      	ldr	r3, [r3, #0]
34189caa:	681a      	ldr	r2, [r3, #0]
34189cac:	68fb      	ldr	r3, [r7, #12]
34189cae:	681b      	ldr	r3, [r3, #0]
34189cb0:	f042 0201 	orr.w	r2, r2, #1
34189cb4:	601a      	str	r2, [r3, #0]

  return HAL_OK;
34189cb6:	2300      	movs	r3, #0
}
34189cb8:	4618      	mov	r0, r3
34189cba:	3710      	adds	r7, #16
34189cbc:	46bd      	mov	sp, r7
34189cbe:	bd80      	pop	{r7, pc}

34189cc0 <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
34189cc0:	b580      	push	{r7, lr}
34189cc2:	b086      	sub	sp, #24
34189cc4:	af00      	add	r7, sp, #0
34189cc6:	6078      	str	r0, [r7, #4]
34189cc8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
34189cca:	2300      	movs	r3, #0
34189ccc:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34189cce:	687b      	ldr	r3, [r7, #4]
34189cd0:	681b      	ldr	r3, [r3, #0]
34189cd2:	681b      	ldr	r3, [r3, #0]
34189cd4:	f003 0301 	and.w	r3, r3, #1
34189cd8:	2b00      	cmp	r3, #0
34189cda:	d056      	beq.n	34189d8a <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34189cdc:	f7fc fc18 	bl	34186510 <HAL_GetTick>
34189ce0:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34189ce2:	e04b      	b.n	34189d7c <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34189ce4:	687b      	ldr	r3, [r7, #4]
34189ce6:	681b      	ldr	r3, [r3, #0]
34189ce8:	685b      	ldr	r3, [r3, #4]
34189cea:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34189cec:	68fb      	ldr	r3, [r7, #12]
34189cee:	f003 0321 	and.w	r3, r3, #33	@ 0x21
34189cf2:	2b00      	cmp	r3, #0
34189cf4:	d023      	beq.n	34189d3e <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34189cf6:	68fb      	ldr	r3, [r7, #12]
34189cf8:	f003 0320 	and.w	r3, r3, #32
34189cfc:	2b00      	cmp	r3, #0
34189cfe:	d005      	beq.n	34189d0c <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34189d00:	687b      	ldr	r3, [r7, #4]
34189d02:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189d04:	f043 0202 	orr.w	r2, r3, #2
34189d08:	687b      	ldr	r3, [r7, #4]
34189d0a:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34189d0c:	68fb      	ldr	r3, [r7, #12]
34189d0e:	f003 0301 	and.w	r3, r3, #1
34189d12:	2b00      	cmp	r3, #0
34189d14:	d005      	beq.n	34189d22 <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34189d16:	687b      	ldr	r3, [r7, #4]
34189d18:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189d1a:	f043 0201 	orr.w	r2, r3, #1
34189d1e:	687b      	ldr	r3, [r7, #4]
34189d20:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34189d22:	687b      	ldr	r3, [r7, #4]
34189d24:	681b      	ldr	r3, [r3, #0]
34189d26:	2221      	movs	r2, #33	@ 0x21
34189d28:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34189d2a:	687b      	ldr	r3, [r7, #4]
34189d2c:	2204      	movs	r2, #4
34189d2e:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34189d32:	687b      	ldr	r3, [r7, #4]
34189d34:	2200      	movs	r2, #0
34189d36:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34189d3a:	2301      	movs	r3, #1
34189d3c:	e0a5      	b.n	34189e8a <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34189d3e:	683b      	ldr	r3, [r7, #0]
34189d40:	f1b3 3fff 	cmp.w	r3, #4294967295
34189d44:	d01a      	beq.n	34189d7c <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34189d46:	f7fc fbe3 	bl	34186510 <HAL_GetTick>
34189d4a:	4602      	mov	r2, r0
34189d4c:	697b      	ldr	r3, [r7, #20]
34189d4e:	1ad3      	subs	r3, r2, r3
34189d50:	683a      	ldr	r2, [r7, #0]
34189d52:	429a      	cmp	r2, r3
34189d54:	d302      	bcc.n	34189d5c <HAL_DMA2D_PollForTransfer+0x9c>
34189d56:	683b      	ldr	r3, [r7, #0]
34189d58:	2b00      	cmp	r3, #0
34189d5a:	d10f      	bne.n	34189d7c <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34189d5c:	687b      	ldr	r3, [r7, #4]
34189d5e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189d60:	f043 0220 	orr.w	r2, r3, #32
34189d64:	687b      	ldr	r3, [r7, #4]
34189d66:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34189d68:	687b      	ldr	r3, [r7, #4]
34189d6a:	2203      	movs	r2, #3
34189d6c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
34189d70:	687b      	ldr	r3, [r7, #4]
34189d72:	2200      	movs	r2, #0
34189d74:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
34189d78:	2303      	movs	r3, #3
34189d7a:	e086      	b.n	34189e8a <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
34189d7c:	687b      	ldr	r3, [r7, #4]
34189d7e:	681b      	ldr	r3, [r3, #0]
34189d80:	685b      	ldr	r3, [r3, #4]
34189d82:	f003 0302 	and.w	r3, r3, #2
34189d86:	2b00      	cmp	r3, #0
34189d88:	d0ac      	beq.n	34189ce4 <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
34189d8a:	687b      	ldr	r3, [r7, #4]
34189d8c:	681b      	ldr	r3, [r3, #0]
34189d8e:	69db      	ldr	r3, [r3, #28]
34189d90:	f003 0320 	and.w	r3, r3, #32
34189d94:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
34189d96:	687b      	ldr	r3, [r7, #4]
34189d98:	681b      	ldr	r3, [r3, #0]
34189d9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34189d9c:	f003 0320 	and.w	r3, r3, #32
34189da0:	693a      	ldr	r2, [r7, #16]
34189da2:	4313      	orrs	r3, r2
34189da4:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
34189da6:	693b      	ldr	r3, [r7, #16]
34189da8:	2b00      	cmp	r3, #0
34189daa:	d061      	beq.n	34189e70 <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34189dac:	f7fc fbb0 	bl	34186510 <HAL_GetTick>
34189db0:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34189db2:	e056      	b.n	34189e62 <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
34189db4:	687b      	ldr	r3, [r7, #4]
34189db6:	681b      	ldr	r3, [r3, #0]
34189db8:	685b      	ldr	r3, [r3, #4]
34189dba:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34189dbc:	68fb      	ldr	r3, [r7, #12]
34189dbe:	f003 0329 	and.w	r3, r3, #41	@ 0x29
34189dc2:	2b00      	cmp	r3, #0
34189dc4:	d02e      	beq.n	34189e24 <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34189dc6:	68fb      	ldr	r3, [r7, #12]
34189dc8:	f003 0308 	and.w	r3, r3, #8
34189dcc:	2b00      	cmp	r3, #0
34189dce:	d005      	beq.n	34189ddc <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34189dd0:	687b      	ldr	r3, [r7, #4]
34189dd2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189dd4:	f043 0204 	orr.w	r2, r3, #4
34189dd8:	687b      	ldr	r3, [r7, #4]
34189dda:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34189ddc:	68fb      	ldr	r3, [r7, #12]
34189dde:	f003 0320 	and.w	r3, r3, #32
34189de2:	2b00      	cmp	r3, #0
34189de4:	d005      	beq.n	34189df2 <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34189de6:	687b      	ldr	r3, [r7, #4]
34189de8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189dea:	f043 0202 	orr.w	r2, r3, #2
34189dee:	687b      	ldr	r3, [r7, #4]
34189df0:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34189df2:	68fb      	ldr	r3, [r7, #12]
34189df4:	f003 0301 	and.w	r3, r3, #1
34189df8:	2b00      	cmp	r3, #0
34189dfa:	d005      	beq.n	34189e08 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34189dfc:	687b      	ldr	r3, [r7, #4]
34189dfe:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189e00:	f043 0201 	orr.w	r2, r3, #1
34189e04:	687b      	ldr	r3, [r7, #4]
34189e06:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34189e08:	687b      	ldr	r3, [r7, #4]
34189e0a:	681b      	ldr	r3, [r3, #0]
34189e0c:	2229      	movs	r2, #41	@ 0x29
34189e0e:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34189e10:	687b      	ldr	r3, [r7, #4]
34189e12:	2204      	movs	r2, #4
34189e14:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34189e18:	687b      	ldr	r3, [r7, #4]
34189e1a:	2200      	movs	r2, #0
34189e1c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34189e20:	2301      	movs	r3, #1
34189e22:	e032      	b.n	34189e8a <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34189e24:	683b      	ldr	r3, [r7, #0]
34189e26:	f1b3 3fff 	cmp.w	r3, #4294967295
34189e2a:	d01a      	beq.n	34189e62 <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34189e2c:	f7fc fb70 	bl	34186510 <HAL_GetTick>
34189e30:	4602      	mov	r2, r0
34189e32:	697b      	ldr	r3, [r7, #20]
34189e34:	1ad3      	subs	r3, r2, r3
34189e36:	683a      	ldr	r2, [r7, #0]
34189e38:	429a      	cmp	r2, r3
34189e3a:	d302      	bcc.n	34189e42 <HAL_DMA2D_PollForTransfer+0x182>
34189e3c:	683b      	ldr	r3, [r7, #0]
34189e3e:	2b00      	cmp	r3, #0
34189e40:	d10f      	bne.n	34189e62 <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34189e42:	687b      	ldr	r3, [r7, #4]
34189e44:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34189e46:	f043 0220 	orr.w	r2, r3, #32
34189e4a:	687b      	ldr	r3, [r7, #4]
34189e4c:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34189e4e:	687b      	ldr	r3, [r7, #4]
34189e50:	2203      	movs	r2, #3
34189e52:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
34189e56:	687b      	ldr	r3, [r7, #4]
34189e58:	2200      	movs	r2, #0
34189e5a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
34189e5e:	2303      	movs	r3, #3
34189e60:	e013      	b.n	34189e8a <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34189e62:	687b      	ldr	r3, [r7, #4]
34189e64:	681b      	ldr	r3, [r3, #0]
34189e66:	685b      	ldr	r3, [r3, #4]
34189e68:	f003 0310 	and.w	r3, r3, #16
34189e6c:	2b00      	cmp	r3, #0
34189e6e:	d0a1      	beq.n	34189db4 <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34189e70:	687b      	ldr	r3, [r7, #4]
34189e72:	681b      	ldr	r3, [r3, #0]
34189e74:	2212      	movs	r2, #18
34189e76:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
34189e78:	687b      	ldr	r3, [r7, #4]
34189e7a:	2201      	movs	r2, #1
34189e7c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
34189e80:	687b      	ldr	r3, [r7, #4]
34189e82:	2200      	movs	r2, #0
34189e84:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34189e88:	2300      	movs	r3, #0
}
34189e8a:	4618      	mov	r0, r3
34189e8c:	3718      	adds	r7, #24
34189e8e:	46bd      	mov	sp, r7
34189e90:	bd80      	pop	{r7, pc}
	...

34189e94 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
34189e94:	b480      	push	{r7}
34189e96:	b087      	sub	sp, #28
34189e98:	af00      	add	r7, sp, #0
34189e9a:	6078      	str	r0, [r7, #4]
34189e9c:	6039      	str	r1, [r7, #0]
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if (hdma2d->Init.Mode != DMA2D_R2M)
34189e9e:	687b      	ldr	r3, [r7, #4]
34189ea0:	685b      	ldr	r3, [r3, #4]
34189ea2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
    }
  }
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));

  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
34189ea6:	683b      	ldr	r3, [r7, #0]
34189ea8:	2b01      	cmp	r3, #1
  {
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
34189eaa:	687b      	ldr	r3, [r7, #4]
34189eac:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
34189eb0:	2b01      	cmp	r3, #1
34189eb2:	d101      	bne.n	34189eb8 <HAL_DMA2D_ConfigLayer+0x24>
34189eb4:	2302      	movs	r3, #2
34189eb6:	e092      	b.n	34189fde <HAL_DMA2D_ConfigLayer+0x14a>
34189eb8:	687b      	ldr	r3, [r7, #4]
34189eba:	2201      	movs	r2, #1
34189ebc:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
34189ec0:	687b      	ldr	r3, [r7, #4]
34189ec2:	2202      	movs	r2, #2
34189ec4:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
34189ec8:	683a      	ldr	r2, [r7, #0]
34189eca:	4613      	mov	r3, r2
34189ecc:	00db      	lsls	r3, r3, #3
34189ece:	1a9b      	subs	r3, r3, r2
34189ed0:	009b      	lsls	r3, r3, #2
34189ed2:	3328      	adds	r3, #40	@ 0x28
34189ed4:	687a      	ldr	r2, [r7, #4]
34189ed6:	4413      	add	r3, r2
34189ed8:	60fb      	str	r3, [r7, #12]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34189eda:	68fb      	ldr	r3, [r7, #12]
34189edc:	685a      	ldr	r2, [r3, #4]
34189ede:	68fb      	ldr	r3, [r7, #12]
34189ee0:	689b      	ldr	r3, [r3, #8]
34189ee2:	041b      	lsls	r3, r3, #16
34189ee4:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34189ee6:	68fb      	ldr	r3, [r7, #12]
34189ee8:	691b      	ldr	r3, [r3, #16]
34189eea:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34189eec:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
34189eee:	68fb      	ldr	r3, [r7, #12]
34189ef0:	695b      	ldr	r3, [r3, #20]
34189ef2:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
34189ef4:	4313      	orrs	r3, r2
34189ef6:	613b      	str	r3, [r7, #16]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
34189ef8:	4b3c      	ldr	r3, [pc, #240]	@ (34189fec <HAL_DMA2D_ConfigLayer+0x158>)
34189efa:	617b      	str	r3, [r7, #20]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34189efc:	68fb      	ldr	r3, [r7, #12]
34189efe:	685b      	ldr	r3, [r3, #4]
34189f00:	2b0a      	cmp	r3, #10
34189f02:	d003      	beq.n	34189f0c <HAL_DMA2D_ConfigLayer+0x78>
34189f04:	68fb      	ldr	r3, [r7, #12]
34189f06:	685b      	ldr	r3, [r3, #4]
34189f08:	2b09      	cmp	r3, #9
34189f0a:	d107      	bne.n	34189f1c <HAL_DMA2D_ConfigLayer+0x88>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
34189f0c:	68fb      	ldr	r3, [r7, #12]
34189f0e:	68db      	ldr	r3, [r3, #12]
34189f10:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
34189f14:	693a      	ldr	r2, [r7, #16]
34189f16:	4313      	orrs	r3, r2
34189f18:	613b      	str	r3, [r7, #16]
34189f1a:	e005      	b.n	34189f28 <HAL_DMA2D_ConfigLayer+0x94>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
34189f1c:	68fb      	ldr	r3, [r7, #12]
34189f1e:	68db      	ldr	r3, [r3, #12]
34189f20:	061b      	lsls	r3, r3, #24
34189f22:	693a      	ldr	r2, [r7, #16]
34189f24:	4313      	orrs	r3, r2
34189f26:	613b      	str	r3, [r7, #16]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
34189f28:	683b      	ldr	r3, [r7, #0]
34189f2a:	2b00      	cmp	r3, #0
34189f2c:	d120      	bne.n	34189f70 <HAL_DMA2D_ConfigLayer+0xdc>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
34189f2e:	687b      	ldr	r3, [r7, #4]
34189f30:	681b      	ldr	r3, [r3, #0]
34189f32:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34189f34:	697b      	ldr	r3, [r7, #20]
34189f36:	43db      	mvns	r3, r3
34189f38:	ea02 0103 	and.w	r1, r2, r3
34189f3c:	687b      	ldr	r3, [r7, #4]
34189f3e:	681b      	ldr	r3, [r3, #0]
34189f40:	693a      	ldr	r2, [r7, #16]
34189f42:	430a      	orrs	r2, r1
34189f44:	625a      	str	r2, [r3, #36]	@ 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
34189f46:	687b      	ldr	r3, [r7, #4]
34189f48:	681b      	ldr	r3, [r3, #0]
34189f4a:	68fa      	ldr	r2, [r7, #12]
34189f4c:	6812      	ldr	r2, [r2, #0]
34189f4e:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34189f50:	68fb      	ldr	r3, [r7, #12]
34189f52:	685b      	ldr	r3, [r3, #4]
34189f54:	2b0a      	cmp	r3, #10
34189f56:	d003      	beq.n	34189f60 <HAL_DMA2D_ConfigLayer+0xcc>
34189f58:	68fb      	ldr	r3, [r7, #12]
34189f5a:	685b      	ldr	r3, [r3, #4]
34189f5c:	2b09      	cmp	r3, #9
34189f5e:	d135      	bne.n	34189fcc <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
34189f60:	68fb      	ldr	r3, [r7, #12]
34189f62:	68da      	ldr	r2, [r3, #12]
34189f64:	687b      	ldr	r3, [r7, #4]
34189f66:	681b      	ldr	r3, [r3, #0]
34189f68:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34189f6c:	629a      	str	r2, [r3, #40]	@ 0x28
34189f6e:	e02d      	b.n	34189fcc <HAL_DMA2D_ConfigLayer+0x138>
  }
  /* Configure the foreground DMA2D layer */
  else
  {

    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
34189f70:	68fb      	ldr	r3, [r7, #12]
34189f72:	685b      	ldr	r3, [r3, #4]
34189f74:	2b0b      	cmp	r3, #11
34189f76:	d109      	bne.n	34189f8c <HAL_DMA2D_ConfigLayer+0xf8>
    {
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
34189f78:	68fb      	ldr	r3, [r7, #12]
34189f7a:	699b      	ldr	r3, [r3, #24]
34189f7c:	049b      	lsls	r3, r3, #18
34189f7e:	693a      	ldr	r2, [r7, #16]
34189f80:	4313      	orrs	r3, r2
34189f82:	613b      	str	r3, [r7, #16]
      regMask  |= DMA2D_FGPFCCR_CSS;
34189f84:	697b      	ldr	r3, [r7, #20]
34189f86:	f443 2340 	orr.w	r3, r3, #786432	@ 0xc0000
34189f8a:	617b      	str	r3, [r7, #20]
    }

    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
34189f8c:	687b      	ldr	r3, [r7, #4]
34189f8e:	681b      	ldr	r3, [r3, #0]
34189f90:	69da      	ldr	r2, [r3, #28]
34189f92:	697b      	ldr	r3, [r7, #20]
34189f94:	43db      	mvns	r3, r3
34189f96:	ea02 0103 	and.w	r1, r2, r3
34189f9a:	687b      	ldr	r3, [r7, #4]
34189f9c:	681b      	ldr	r3, [r3, #0]
34189f9e:	693a      	ldr	r2, [r7, #16]
34189fa0:	430a      	orrs	r2, r1
34189fa2:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
34189fa4:	687b      	ldr	r3, [r7, #4]
34189fa6:	681b      	ldr	r3, [r3, #0]
34189fa8:	68fa      	ldr	r2, [r7, #12]
34189faa:	6812      	ldr	r2, [r2, #0]
34189fac:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
34189fae:	68fb      	ldr	r3, [r7, #12]
34189fb0:	685b      	ldr	r3, [r3, #4]
34189fb2:	2b0a      	cmp	r3, #10
34189fb4:	d003      	beq.n	34189fbe <HAL_DMA2D_ConfigLayer+0x12a>
34189fb6:	68fb      	ldr	r3, [r7, #12]
34189fb8:	685b      	ldr	r3, [r3, #4]
34189fba:	2b09      	cmp	r3, #9
34189fbc:	d106      	bne.n	34189fcc <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
34189fbe:	68fb      	ldr	r3, [r7, #12]
34189fc0:	68da      	ldr	r2, [r3, #12]
34189fc2:	687b      	ldr	r3, [r7, #4]
34189fc4:	681b      	ldr	r3, [r3, #0]
34189fc6:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
34189fca:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
34189fcc:	687b      	ldr	r3, [r7, #4]
34189fce:	2201      	movs	r2, #1
34189fd0:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
34189fd4:	687b      	ldr	r3, [r7, #4]
34189fd6:	2200      	movs	r2, #0
34189fd8:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34189fdc:	2300      	movs	r3, #0
}
34189fde:	4618      	mov	r0, r3
34189fe0:	371c      	adds	r7, #28
34189fe2:	46bd      	mov	sp, r7
34189fe4:	f85d 7b04 	ldr.w	r7, [sp], #4
34189fe8:	4770      	bx	lr
34189fea:	bf00      	nop
34189fec:	ff33000f 	.word	0xff33000f

34189ff0 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
34189ff0:	b480      	push	{r7}
34189ff2:	b08b      	sub	sp, #44	@ 0x2c
34189ff4:	af00      	add	r7, sp, #0
34189ff6:	60f8      	str	r0, [r7, #12]
34189ff8:	60b9      	str	r1, [r7, #8]
34189ffa:	607a      	str	r2, [r7, #4]
34189ffc:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34189ffe:	68fb      	ldr	r3, [r7, #12]
3418a000:	681b      	ldr	r3, [r3, #0]
3418a002:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418a004:	f003 4140 	and.w	r1, r3, #3221225472	@ 0xc0000000
3418a008:	683b      	ldr	r3, [r7, #0]
3418a00a:	041a      	lsls	r2, r3, #16
3418a00c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418a00e:	431a      	orrs	r2, r3
3418a010:	68fb      	ldr	r3, [r7, #12]
3418a012:	681b      	ldr	r3, [r3, #0]
3418a014:	430a      	orrs	r2, r1
3418a016:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
3418a018:	68fb      	ldr	r3, [r7, #12]
3418a01a:	681b      	ldr	r3, [r3, #0]
3418a01c:	687a      	ldr	r2, [r7, #4]
3418a01e:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
3418a020:	68fb      	ldr	r3, [r7, #12]
3418a022:	685b      	ldr	r3, [r3, #4]
3418a024:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418a028:	d174      	bne.n	3418a114 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
3418a02a:	68bb      	ldr	r3, [r7, #8]
3418a02c:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
3418a030:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
3418a032:	68bb      	ldr	r3, [r7, #8]
3418a034:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3418a038:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
3418a03a:	68bb      	ldr	r3, [r7, #8]
3418a03c:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
3418a040:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
3418a042:	68bb      	ldr	r3, [r7, #8]
3418a044:	b2db      	uxtb	r3, r3
3418a046:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
3418a048:	68fb      	ldr	r3, [r7, #12]
3418a04a:	689b      	ldr	r3, [r3, #8]
3418a04c:	2b00      	cmp	r3, #0
3418a04e:	d108      	bne.n	3418a062 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
3418a050:	69ba      	ldr	r2, [r7, #24]
3418a052:	69fb      	ldr	r3, [r7, #28]
3418a054:	431a      	orrs	r2, r3
3418a056:	6a3b      	ldr	r3, [r7, #32]
3418a058:	4313      	orrs	r3, r2
3418a05a:	697a      	ldr	r2, [r7, #20]
3418a05c:	4313      	orrs	r3, r2
3418a05e:	627b      	str	r3, [r7, #36]	@ 0x24
3418a060:	e053      	b.n	3418a10a <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
3418a062:	68fb      	ldr	r3, [r7, #12]
3418a064:	689b      	ldr	r3, [r3, #8]
3418a066:	2b01      	cmp	r3, #1
3418a068:	d106      	bne.n	3418a078 <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
3418a06a:	69ba      	ldr	r2, [r7, #24]
3418a06c:	69fb      	ldr	r3, [r7, #28]
3418a06e:	4313      	orrs	r3, r2
3418a070:	697a      	ldr	r2, [r7, #20]
3418a072:	4313      	orrs	r3, r2
3418a074:	627b      	str	r3, [r7, #36]	@ 0x24
3418a076:	e048      	b.n	3418a10a <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
3418a078:	68fb      	ldr	r3, [r7, #12]
3418a07a:	689b      	ldr	r3, [r3, #8]
3418a07c:	2b02      	cmp	r3, #2
3418a07e:	d111      	bne.n	3418a0a4 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
3418a080:	69fb      	ldr	r3, [r7, #28]
3418a082:	0cdb      	lsrs	r3, r3, #19
3418a084:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
3418a086:	69bb      	ldr	r3, [r7, #24]
3418a088:	0a9b      	lsrs	r3, r3, #10
3418a08a:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
3418a08c:	697b      	ldr	r3, [r7, #20]
3418a08e:	08db      	lsrs	r3, r3, #3
3418a090:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
3418a092:	69bb      	ldr	r3, [r7, #24]
3418a094:	015a      	lsls	r2, r3, #5
3418a096:	69fb      	ldr	r3, [r7, #28]
3418a098:	02db      	lsls	r3, r3, #11
3418a09a:	4313      	orrs	r3, r2
3418a09c:	697a      	ldr	r2, [r7, #20]
3418a09e:	4313      	orrs	r3, r2
3418a0a0:	627b      	str	r3, [r7, #36]	@ 0x24
3418a0a2:	e032      	b.n	3418a10a <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
3418a0a4:	68fb      	ldr	r3, [r7, #12]
3418a0a6:	689b      	ldr	r3, [r3, #8]
3418a0a8:	2b03      	cmp	r3, #3
3418a0aa:	d117      	bne.n	3418a0dc <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
3418a0ac:	6a3b      	ldr	r3, [r7, #32]
3418a0ae:	0fdb      	lsrs	r3, r3, #31
3418a0b0:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
3418a0b2:	69fb      	ldr	r3, [r7, #28]
3418a0b4:	0cdb      	lsrs	r3, r3, #19
3418a0b6:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
3418a0b8:	69bb      	ldr	r3, [r7, #24]
3418a0ba:	0adb      	lsrs	r3, r3, #11
3418a0bc:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
3418a0be:	697b      	ldr	r3, [r7, #20]
3418a0c0:	08db      	lsrs	r3, r3, #3
3418a0c2:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3418a0c4:	69bb      	ldr	r3, [r7, #24]
3418a0c6:	015a      	lsls	r2, r3, #5
3418a0c8:	69fb      	ldr	r3, [r7, #28]
3418a0ca:	029b      	lsls	r3, r3, #10
3418a0cc:	431a      	orrs	r2, r3
3418a0ce:	6a3b      	ldr	r3, [r7, #32]
3418a0d0:	03db      	lsls	r3, r3, #15
3418a0d2:	4313      	orrs	r3, r2
3418a0d4:	697a      	ldr	r2, [r7, #20]
3418a0d6:	4313      	orrs	r3, r2
3418a0d8:	627b      	str	r3, [r7, #36]	@ 0x24
3418a0da:	e016      	b.n	3418a10a <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
3418a0dc:	6a3b      	ldr	r3, [r7, #32]
3418a0de:	0f1b      	lsrs	r3, r3, #28
3418a0e0:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
3418a0e2:	69fb      	ldr	r3, [r7, #28]
3418a0e4:	0d1b      	lsrs	r3, r3, #20
3418a0e6:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
3418a0e8:	69bb      	ldr	r3, [r7, #24]
3418a0ea:	0b1b      	lsrs	r3, r3, #12
3418a0ec:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
3418a0ee:	697b      	ldr	r3, [r7, #20]
3418a0f0:	091b      	lsrs	r3, r3, #4
3418a0f2:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
3418a0f4:	69bb      	ldr	r3, [r7, #24]
3418a0f6:	011a      	lsls	r2, r3, #4
3418a0f8:	69fb      	ldr	r3, [r7, #28]
3418a0fa:	021b      	lsls	r3, r3, #8
3418a0fc:	431a      	orrs	r2, r3
3418a0fe:	6a3b      	ldr	r3, [r7, #32]
3418a100:	031b      	lsls	r3, r3, #12
3418a102:	4313      	orrs	r3, r2
3418a104:	697a      	ldr	r2, [r7, #20]
3418a106:	4313      	orrs	r3, r2
3418a108:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
3418a10a:	68fb      	ldr	r3, [r7, #12]
3418a10c:	681b      	ldr	r3, [r3, #0]
3418a10e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3418a110:	639a      	str	r2, [r3, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
3418a112:	e00d      	b.n	3418a130 <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
3418a114:	68fb      	ldr	r3, [r7, #12]
3418a116:	685b      	ldr	r3, [r3, #4]
3418a118:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3418a11c:	d104      	bne.n	3418a128 <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
3418a11e:	68fb      	ldr	r3, [r7, #12]
3418a120:	681b      	ldr	r3, [r3, #0]
3418a122:	68ba      	ldr	r2, [r7, #8]
3418a124:	615a      	str	r2, [r3, #20]
}
3418a126:	e003      	b.n	3418a130 <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
3418a128:	68fb      	ldr	r3, [r7, #12]
3418a12a:	681b      	ldr	r3, [r3, #0]
3418a12c:	68ba      	ldr	r2, [r7, #8]
3418a12e:	60da      	str	r2, [r3, #12]
}
3418a130:	bf00      	nop
3418a132:	372c      	adds	r7, #44	@ 0x2c
3418a134:	46bd      	mov	sp, r7
3418a136:	f85d 7b04 	ldr.w	r7, [sp], #4
3418a13a:	4770      	bx	lr

3418a13c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
3418a13c:	b480      	push	{r7}
3418a13e:	b087      	sub	sp, #28
3418a140:	af00      	add	r7, sp, #0
3418a142:	6078      	str	r0, [r7, #4]
3418a144:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
3418a146:	2300      	movs	r3, #0
3418a148:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3418a14a:	e180      	b.n	3418a44e <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
3418a14c:	683b      	ldr	r3, [r7, #0]
3418a14e:	681a      	ldr	r2, [r3, #0]
3418a150:	2101      	movs	r1, #1
3418a152:	697b      	ldr	r3, [r7, #20]
3418a154:	fa01 f303 	lsl.w	r3, r1, r3
3418a158:	4013      	ands	r3, r2
3418a15a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
3418a15c:	68fb      	ldr	r3, [r7, #12]
3418a15e:	2b00      	cmp	r3, #0
3418a160:	f000 8172 	beq.w	3418a448 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
3418a164:	683b      	ldr	r3, [r7, #0]
3418a166:	685b      	ldr	r3, [r3, #4]
3418a168:	f003 0303 	and.w	r3, r3, #3
3418a16c:	2b01      	cmp	r3, #1
3418a16e:	d005      	beq.n	3418a17c <HAL_GPIO_Init+0x40>
3418a170:	683b      	ldr	r3, [r7, #0]
3418a172:	685b      	ldr	r3, [r3, #4]
3418a174:	f003 0303 	and.w	r3, r3, #3
3418a178:	2b02      	cmp	r3, #2
3418a17a:	d130      	bne.n	3418a1de <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
3418a17c:	687b      	ldr	r3, [r7, #4]
3418a17e:	689b      	ldr	r3, [r3, #8]
3418a180:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3418a182:	697b      	ldr	r3, [r7, #20]
3418a184:	005b      	lsls	r3, r3, #1
3418a186:	2203      	movs	r2, #3
3418a188:	fa02 f303 	lsl.w	r3, r2, r3
3418a18c:	43db      	mvns	r3, r3
3418a18e:	693a      	ldr	r2, [r7, #16]
3418a190:	4013      	ands	r3, r2
3418a192:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3418a194:	683b      	ldr	r3, [r7, #0]
3418a196:	68da      	ldr	r2, [r3, #12]
3418a198:	697b      	ldr	r3, [r7, #20]
3418a19a:	005b      	lsls	r3, r3, #1
3418a19c:	fa02 f303 	lsl.w	r3, r2, r3
3418a1a0:	693a      	ldr	r2, [r7, #16]
3418a1a2:	4313      	orrs	r3, r2
3418a1a4:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
3418a1a6:	687b      	ldr	r3, [r7, #4]
3418a1a8:	693a      	ldr	r2, [r7, #16]
3418a1aa:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
3418a1ac:	687b      	ldr	r3, [r7, #4]
3418a1ae:	685b      	ldr	r3, [r3, #4]
3418a1b0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
3418a1b2:	2201      	movs	r2, #1
3418a1b4:	697b      	ldr	r3, [r7, #20]
3418a1b6:	fa02 f303 	lsl.w	r3, r2, r3
3418a1ba:	43db      	mvns	r3, r3
3418a1bc:	693a      	ldr	r2, [r7, #16]
3418a1be:	4013      	ands	r3, r2
3418a1c0:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
3418a1c2:	683b      	ldr	r3, [r7, #0]
3418a1c4:	685b      	ldr	r3, [r3, #4]
3418a1c6:	091b      	lsrs	r3, r3, #4
3418a1c8:	f003 0201 	and.w	r2, r3, #1
3418a1cc:	697b      	ldr	r3, [r7, #20]
3418a1ce:	fa02 f303 	lsl.w	r3, r2, r3
3418a1d2:	693a      	ldr	r2, [r7, #16]
3418a1d4:	4313      	orrs	r3, r2
3418a1d6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
3418a1d8:	687b      	ldr	r3, [r7, #4]
3418a1da:	693a      	ldr	r2, [r7, #16]
3418a1dc:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3418a1de:	683b      	ldr	r3, [r7, #0]
3418a1e0:	685b      	ldr	r3, [r3, #4]
3418a1e2:	f003 0303 	and.w	r3, r3, #3
3418a1e6:	2b03      	cmp	r3, #3
3418a1e8:	d109      	bne.n	3418a1fe <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3418a1ea:	683b      	ldr	r3, [r7, #0]
3418a1ec:	685b      	ldr	r3, [r3, #4]
3418a1ee:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3418a1f2:	2b03      	cmp	r3, #3
3418a1f4:	d11b      	bne.n	3418a22e <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3418a1f6:	683b      	ldr	r3, [r7, #0]
3418a1f8:	689b      	ldr	r3, [r3, #8]
3418a1fa:	2b01      	cmp	r3, #1
3418a1fc:	d017      	beq.n	3418a22e <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
3418a1fe:	687b      	ldr	r3, [r7, #4]
3418a200:	68db      	ldr	r3, [r3, #12]
3418a202:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
3418a204:	697b      	ldr	r3, [r7, #20]
3418a206:	005b      	lsls	r3, r3, #1
3418a208:	2203      	movs	r2, #3
3418a20a:	fa02 f303 	lsl.w	r3, r2, r3
3418a20e:	43db      	mvns	r3, r3
3418a210:	693a      	ldr	r2, [r7, #16]
3418a212:	4013      	ands	r3, r2
3418a214:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
3418a216:	683b      	ldr	r3, [r7, #0]
3418a218:	689a      	ldr	r2, [r3, #8]
3418a21a:	697b      	ldr	r3, [r7, #20]
3418a21c:	005b      	lsls	r3, r3, #1
3418a21e:	fa02 f303 	lsl.w	r3, r2, r3
3418a222:	693a      	ldr	r2, [r7, #16]
3418a224:	4313      	orrs	r3, r2
3418a226:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
3418a228:	687b      	ldr	r3, [r7, #4]
3418a22a:	693a      	ldr	r2, [r7, #16]
3418a22c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
3418a22e:	683b      	ldr	r3, [r7, #0]
3418a230:	685b      	ldr	r3, [r3, #4]
3418a232:	f003 0303 	and.w	r3, r3, #3
3418a236:	2b02      	cmp	r3, #2
3418a238:	d123      	bne.n	3418a282 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
3418a23a:	697b      	ldr	r3, [r7, #20]
3418a23c:	08da      	lsrs	r2, r3, #3
3418a23e:	687b      	ldr	r3, [r7, #4]
3418a240:	3208      	adds	r2, #8
3418a242:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3418a246:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3418a248:	697b      	ldr	r3, [r7, #20]
3418a24a:	f003 0307 	and.w	r3, r3, #7
3418a24e:	009b      	lsls	r3, r3, #2
3418a250:	220f      	movs	r2, #15
3418a252:	fa02 f303 	lsl.w	r3, r2, r3
3418a256:	43db      	mvns	r3, r3
3418a258:	693a      	ldr	r2, [r7, #16]
3418a25a:	4013      	ands	r3, r2
3418a25c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3418a25e:	683b      	ldr	r3, [r7, #0]
3418a260:	691a      	ldr	r2, [r3, #16]
3418a262:	697b      	ldr	r3, [r7, #20]
3418a264:	f003 0307 	and.w	r3, r3, #7
3418a268:	009b      	lsls	r3, r3, #2
3418a26a:	fa02 f303 	lsl.w	r3, r2, r3
3418a26e:	693a      	ldr	r2, [r7, #16]
3418a270:	4313      	orrs	r3, r2
3418a272:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
3418a274:	697b      	ldr	r3, [r7, #20]
3418a276:	08da      	lsrs	r2, r3, #3
3418a278:	687b      	ldr	r3, [r7, #4]
3418a27a:	3208      	adds	r2, #8
3418a27c:	6939      	ldr	r1, [r7, #16]
3418a27e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
3418a282:	687b      	ldr	r3, [r7, #4]
3418a284:	681b      	ldr	r3, [r3, #0]
3418a286:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
3418a288:	697b      	ldr	r3, [r7, #20]
3418a28a:	005b      	lsls	r3, r3, #1
3418a28c:	2203      	movs	r2, #3
3418a28e:	fa02 f303 	lsl.w	r3, r2, r3
3418a292:	43db      	mvns	r3, r3
3418a294:	693a      	ldr	r2, [r7, #16]
3418a296:	4013      	ands	r3, r2
3418a298:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
3418a29a:	683b      	ldr	r3, [r7, #0]
3418a29c:	685b      	ldr	r3, [r3, #4]
3418a29e:	f003 0203 	and.w	r2, r3, #3
3418a2a2:	697b      	ldr	r3, [r7, #20]
3418a2a4:	005b      	lsls	r3, r3, #1
3418a2a6:	fa02 f303 	lsl.w	r3, r2, r3
3418a2aa:	693a      	ldr	r2, [r7, #16]
3418a2ac:	4313      	orrs	r3, r2
3418a2ae:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
3418a2b0:	687b      	ldr	r3, [r7, #4]
3418a2b2:	693a      	ldr	r2, [r7, #16]
3418a2b4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
3418a2b6:	683b      	ldr	r3, [r7, #0]
3418a2b8:	685b      	ldr	r3, [r3, #4]
3418a2ba:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
3418a2be:	2b00      	cmp	r3, #0
3418a2c0:	f000 80c2 	beq.w	3418a448 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
3418a2c4:	4a69      	ldr	r2, [pc, #420]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a2c6:	697b      	ldr	r3, [r7, #20]
3418a2c8:	089b      	lsrs	r3, r3, #2
3418a2ca:	3318      	adds	r3, #24
3418a2cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418a2d0:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3418a2d2:	697b      	ldr	r3, [r7, #20]
3418a2d4:	f003 0303 	and.w	r3, r3, #3
3418a2d8:	00db      	lsls	r3, r3, #3
3418a2da:	220f      	movs	r2, #15
3418a2dc:	fa02 f303 	lsl.w	r3, r2, r3
3418a2e0:	43db      	mvns	r3, r3
3418a2e2:	693a      	ldr	r2, [r7, #16]
3418a2e4:	4013      	ands	r3, r2
3418a2e6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3418a2e8:	687b      	ldr	r3, [r7, #4]
3418a2ea:	4a61      	ldr	r2, [pc, #388]	@ (3418a470 <HAL_GPIO_Init+0x334>)
3418a2ec:	4293      	cmp	r3, r2
3418a2ee:	d043      	beq.n	3418a378 <HAL_GPIO_Init+0x23c>
3418a2f0:	687b      	ldr	r3, [r7, #4]
3418a2f2:	4a60      	ldr	r2, [pc, #384]	@ (3418a474 <HAL_GPIO_Init+0x338>)
3418a2f4:	4293      	cmp	r3, r2
3418a2f6:	d03d      	beq.n	3418a374 <HAL_GPIO_Init+0x238>
3418a2f8:	687b      	ldr	r3, [r7, #4]
3418a2fa:	4a5f      	ldr	r2, [pc, #380]	@ (3418a478 <HAL_GPIO_Init+0x33c>)
3418a2fc:	4293      	cmp	r3, r2
3418a2fe:	d037      	beq.n	3418a370 <HAL_GPIO_Init+0x234>
3418a300:	687b      	ldr	r3, [r7, #4]
3418a302:	4a5e      	ldr	r2, [pc, #376]	@ (3418a47c <HAL_GPIO_Init+0x340>)
3418a304:	4293      	cmp	r3, r2
3418a306:	d031      	beq.n	3418a36c <HAL_GPIO_Init+0x230>
3418a308:	687b      	ldr	r3, [r7, #4]
3418a30a:	4a5d      	ldr	r2, [pc, #372]	@ (3418a480 <HAL_GPIO_Init+0x344>)
3418a30c:	4293      	cmp	r3, r2
3418a30e:	d02b      	beq.n	3418a368 <HAL_GPIO_Init+0x22c>
3418a310:	687b      	ldr	r3, [r7, #4]
3418a312:	4a5c      	ldr	r2, [pc, #368]	@ (3418a484 <HAL_GPIO_Init+0x348>)
3418a314:	4293      	cmp	r3, r2
3418a316:	d025      	beq.n	3418a364 <HAL_GPIO_Init+0x228>
3418a318:	687b      	ldr	r3, [r7, #4]
3418a31a:	4a5b      	ldr	r2, [pc, #364]	@ (3418a488 <HAL_GPIO_Init+0x34c>)
3418a31c:	4293      	cmp	r3, r2
3418a31e:	d01f      	beq.n	3418a360 <HAL_GPIO_Init+0x224>
3418a320:	687b      	ldr	r3, [r7, #4]
3418a322:	4a5a      	ldr	r2, [pc, #360]	@ (3418a48c <HAL_GPIO_Init+0x350>)
3418a324:	4293      	cmp	r3, r2
3418a326:	d019      	beq.n	3418a35c <HAL_GPIO_Init+0x220>
3418a328:	687b      	ldr	r3, [r7, #4]
3418a32a:	4a59      	ldr	r2, [pc, #356]	@ (3418a490 <HAL_GPIO_Init+0x354>)
3418a32c:	4293      	cmp	r3, r2
3418a32e:	d013      	beq.n	3418a358 <HAL_GPIO_Init+0x21c>
3418a330:	687b      	ldr	r3, [r7, #4]
3418a332:	4a58      	ldr	r2, [pc, #352]	@ (3418a494 <HAL_GPIO_Init+0x358>)
3418a334:	4293      	cmp	r3, r2
3418a336:	d00d      	beq.n	3418a354 <HAL_GPIO_Init+0x218>
3418a338:	687b      	ldr	r3, [r7, #4]
3418a33a:	4a57      	ldr	r2, [pc, #348]	@ (3418a498 <HAL_GPIO_Init+0x35c>)
3418a33c:	4293      	cmp	r3, r2
3418a33e:	d007      	beq.n	3418a350 <HAL_GPIO_Init+0x214>
3418a340:	687b      	ldr	r3, [r7, #4]
3418a342:	4a56      	ldr	r2, [pc, #344]	@ (3418a49c <HAL_GPIO_Init+0x360>)
3418a344:	4293      	cmp	r3, r2
3418a346:	d101      	bne.n	3418a34c <HAL_GPIO_Init+0x210>
3418a348:	230b      	movs	r3, #11
3418a34a:	e016      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a34c:	2310      	movs	r3, #16
3418a34e:	e014      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a350:	230a      	movs	r3, #10
3418a352:	e012      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a354:	2309      	movs	r3, #9
3418a356:	e010      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a358:	2308      	movs	r3, #8
3418a35a:	e00e      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a35c:	2307      	movs	r3, #7
3418a35e:	e00c      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a360:	2306      	movs	r3, #6
3418a362:	e00a      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a364:	2305      	movs	r3, #5
3418a366:	e008      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a368:	2304      	movs	r3, #4
3418a36a:	e006      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a36c:	2303      	movs	r3, #3
3418a36e:	e004      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a370:	2302      	movs	r3, #2
3418a372:	e002      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a374:	2301      	movs	r3, #1
3418a376:	e000      	b.n	3418a37a <HAL_GPIO_Init+0x23e>
3418a378:	2300      	movs	r3, #0
3418a37a:	697a      	ldr	r2, [r7, #20]
3418a37c:	f002 0203 	and.w	r2, r2, #3
3418a380:	00d2      	lsls	r2, r2, #3
3418a382:	4093      	lsls	r3, r2
3418a384:	693a      	ldr	r2, [r7, #16]
3418a386:	4313      	orrs	r3, r2
3418a388:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
3418a38a:	4938      	ldr	r1, [pc, #224]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a38c:	697b      	ldr	r3, [r7, #20]
3418a38e:	089b      	lsrs	r3, r3, #2
3418a390:	3318      	adds	r3, #24
3418a392:	693a      	ldr	r2, [r7, #16]
3418a394:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
3418a398:	4b34      	ldr	r3, [pc, #208]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a39a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418a39e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418a3a0:	68fb      	ldr	r3, [r7, #12]
3418a3a2:	43db      	mvns	r3, r3
3418a3a4:	693a      	ldr	r2, [r7, #16]
3418a3a6:	4013      	ands	r3, r2
3418a3a8:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
3418a3aa:	683b      	ldr	r3, [r7, #0]
3418a3ac:	685b      	ldr	r3, [r3, #4]
3418a3ae:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418a3b2:	2b00      	cmp	r3, #0
3418a3b4:	d003      	beq.n	3418a3be <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
3418a3b6:	693a      	ldr	r2, [r7, #16]
3418a3b8:	68fb      	ldr	r3, [r7, #12]
3418a3ba:	4313      	orrs	r3, r2
3418a3bc:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
3418a3be:	4a2b      	ldr	r2, [pc, #172]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a3c0:	693b      	ldr	r3, [r7, #16]
3418a3c2:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
3418a3c6:	4b29      	ldr	r3, [pc, #164]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a3c8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418a3cc:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418a3ce:	68fb      	ldr	r3, [r7, #12]
3418a3d0:	43db      	mvns	r3, r3
3418a3d2:	693a      	ldr	r2, [r7, #16]
3418a3d4:	4013      	ands	r3, r2
3418a3d6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
3418a3d8:	683b      	ldr	r3, [r7, #0]
3418a3da:	685b      	ldr	r3, [r3, #4]
3418a3dc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418a3e0:	2b00      	cmp	r3, #0
3418a3e2:	d003      	beq.n	3418a3ec <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
3418a3e4:	693a      	ldr	r2, [r7, #16]
3418a3e6:	68fb      	ldr	r3, [r7, #12]
3418a3e8:	4313      	orrs	r3, r2
3418a3ea:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
3418a3ec:	4a1f      	ldr	r2, [pc, #124]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a3ee:	693b      	ldr	r3, [r7, #16]
3418a3f0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
3418a3f4:	4b1d      	ldr	r3, [pc, #116]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a3f6:	681b      	ldr	r3, [r3, #0]
3418a3f8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418a3fa:	68fb      	ldr	r3, [r7, #12]
3418a3fc:	43db      	mvns	r3, r3
3418a3fe:	693a      	ldr	r2, [r7, #16]
3418a400:	4013      	ands	r3, r2
3418a402:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
3418a404:	683b      	ldr	r3, [r7, #0]
3418a406:	685b      	ldr	r3, [r3, #4]
3418a408:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3418a40c:	2b00      	cmp	r3, #0
3418a40e:	d003      	beq.n	3418a418 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
3418a410:	693a      	ldr	r2, [r7, #16]
3418a412:	68fb      	ldr	r3, [r7, #12]
3418a414:	4313      	orrs	r3, r2
3418a416:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
3418a418:	4a14      	ldr	r2, [pc, #80]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a41a:	693b      	ldr	r3, [r7, #16]
3418a41c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
3418a41e:	4b13      	ldr	r3, [pc, #76]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a420:	685b      	ldr	r3, [r3, #4]
3418a422:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3418a424:	68fb      	ldr	r3, [r7, #12]
3418a426:	43db      	mvns	r3, r3
3418a428:	693a      	ldr	r2, [r7, #16]
3418a42a:	4013      	ands	r3, r2
3418a42c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
3418a42e:	683b      	ldr	r3, [r7, #0]
3418a430:	685b      	ldr	r3, [r3, #4]
3418a432:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3418a436:	2b00      	cmp	r3, #0
3418a438:	d003      	beq.n	3418a442 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
3418a43a:	693a      	ldr	r2, [r7, #16]
3418a43c:	68fb      	ldr	r3, [r7, #12]
3418a43e:	4313      	orrs	r3, r2
3418a440:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
3418a442:	4a0a      	ldr	r2, [pc, #40]	@ (3418a46c <HAL_GPIO_Init+0x330>)
3418a444:	693b      	ldr	r3, [r7, #16]
3418a446:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
3418a448:	697b      	ldr	r3, [r7, #20]
3418a44a:	3301      	adds	r3, #1
3418a44c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3418a44e:	683b      	ldr	r3, [r7, #0]
3418a450:	681a      	ldr	r2, [r3, #0]
3418a452:	697b      	ldr	r3, [r7, #20]
3418a454:	fa22 f303 	lsr.w	r3, r2, r3
3418a458:	2b00      	cmp	r3, #0
3418a45a:	f47f ae77 	bne.w	3418a14c <HAL_GPIO_Init+0x10>
  }
}
3418a45e:	bf00      	nop
3418a460:	bf00      	nop
3418a462:	371c      	adds	r7, #28
3418a464:	46bd      	mov	sp, r7
3418a466:	f85d 7b04 	ldr.w	r7, [sp], #4
3418a46a:	4770      	bx	lr
3418a46c:	56025000 	.word	0x56025000
3418a470:	56020000 	.word	0x56020000
3418a474:	56020400 	.word	0x56020400
3418a478:	56020800 	.word	0x56020800
3418a47c:	56020c00 	.word	0x56020c00
3418a480:	56021000 	.word	0x56021000
3418a484:	56021400 	.word	0x56021400
3418a488:	56021800 	.word	0x56021800
3418a48c:	56021c00 	.word	0x56021c00
3418a490:	56023400 	.word	0x56023400
3418a494:	56023800 	.word	0x56023800
3418a498:	56023c00 	.word	0x56023c00
3418a49c:	56024000 	.word	0x56024000

3418a4a0 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
3418a4a0:	b480      	push	{r7}
3418a4a2:	b087      	sub	sp, #28
3418a4a4:	af00      	add	r7, sp, #0
3418a4a6:	6078      	str	r0, [r7, #4]
3418a4a8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
3418a4aa:	2300      	movs	r3, #0
3418a4ac:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
3418a4ae:	e10f      	b.n	3418a6d0 <HAL_GPIO_DeInit+0x230>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
3418a4b0:	2201      	movs	r2, #1
3418a4b2:	697b      	ldr	r3, [r7, #20]
3418a4b4:	fa02 f303 	lsl.w	r3, r2, r3
3418a4b8:	683a      	ldr	r2, [r7, #0]
3418a4ba:	4013      	ands	r3, r2
3418a4bc:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
3418a4be:	693b      	ldr	r3, [r7, #16]
3418a4c0:	2b00      	cmp	r3, #0
3418a4c2:	f000 8102 	beq.w	3418a6ca <HAL_GPIO_DeInit+0x22a>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
3418a4c6:	4a89      	ldr	r2, [pc, #548]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a4c8:	697b      	ldr	r3, [r7, #20]
3418a4ca:	089b      	lsrs	r3, r3, #2
3418a4cc:	3318      	adds	r3, #24
3418a4ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3418a4d2:	60fb      	str	r3, [r7, #12]
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3418a4d4:	697b      	ldr	r3, [r7, #20]
3418a4d6:	f003 0303 	and.w	r3, r3, #3
3418a4da:	00db      	lsls	r3, r3, #3
3418a4dc:	220f      	movs	r2, #15
3418a4de:	fa02 f303 	lsl.w	r3, r2, r3
3418a4e2:	68fa      	ldr	r2, [r7, #12]
3418a4e4:	4013      	ands	r3, r2
3418a4e6:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
3418a4e8:	687b      	ldr	r3, [r7, #4]
3418a4ea:	4a81      	ldr	r2, [pc, #516]	@ (3418a6f0 <HAL_GPIO_DeInit+0x250>)
3418a4ec:	4293      	cmp	r3, r2
3418a4ee:	d043      	beq.n	3418a578 <HAL_GPIO_DeInit+0xd8>
3418a4f0:	687b      	ldr	r3, [r7, #4]
3418a4f2:	4a80      	ldr	r2, [pc, #512]	@ (3418a6f4 <HAL_GPIO_DeInit+0x254>)
3418a4f4:	4293      	cmp	r3, r2
3418a4f6:	d03d      	beq.n	3418a574 <HAL_GPIO_DeInit+0xd4>
3418a4f8:	687b      	ldr	r3, [r7, #4]
3418a4fa:	4a7f      	ldr	r2, [pc, #508]	@ (3418a6f8 <HAL_GPIO_DeInit+0x258>)
3418a4fc:	4293      	cmp	r3, r2
3418a4fe:	d037      	beq.n	3418a570 <HAL_GPIO_DeInit+0xd0>
3418a500:	687b      	ldr	r3, [r7, #4]
3418a502:	4a7e      	ldr	r2, [pc, #504]	@ (3418a6fc <HAL_GPIO_DeInit+0x25c>)
3418a504:	4293      	cmp	r3, r2
3418a506:	d031      	beq.n	3418a56c <HAL_GPIO_DeInit+0xcc>
3418a508:	687b      	ldr	r3, [r7, #4]
3418a50a:	4a7d      	ldr	r2, [pc, #500]	@ (3418a700 <HAL_GPIO_DeInit+0x260>)
3418a50c:	4293      	cmp	r3, r2
3418a50e:	d02b      	beq.n	3418a568 <HAL_GPIO_DeInit+0xc8>
3418a510:	687b      	ldr	r3, [r7, #4]
3418a512:	4a7c      	ldr	r2, [pc, #496]	@ (3418a704 <HAL_GPIO_DeInit+0x264>)
3418a514:	4293      	cmp	r3, r2
3418a516:	d025      	beq.n	3418a564 <HAL_GPIO_DeInit+0xc4>
3418a518:	687b      	ldr	r3, [r7, #4]
3418a51a:	4a7b      	ldr	r2, [pc, #492]	@ (3418a708 <HAL_GPIO_DeInit+0x268>)
3418a51c:	4293      	cmp	r3, r2
3418a51e:	d01f      	beq.n	3418a560 <HAL_GPIO_DeInit+0xc0>
3418a520:	687b      	ldr	r3, [r7, #4]
3418a522:	4a7a      	ldr	r2, [pc, #488]	@ (3418a70c <HAL_GPIO_DeInit+0x26c>)
3418a524:	4293      	cmp	r3, r2
3418a526:	d019      	beq.n	3418a55c <HAL_GPIO_DeInit+0xbc>
3418a528:	687b      	ldr	r3, [r7, #4]
3418a52a:	4a79      	ldr	r2, [pc, #484]	@ (3418a710 <HAL_GPIO_DeInit+0x270>)
3418a52c:	4293      	cmp	r3, r2
3418a52e:	d013      	beq.n	3418a558 <HAL_GPIO_DeInit+0xb8>
3418a530:	687b      	ldr	r3, [r7, #4]
3418a532:	4a78      	ldr	r2, [pc, #480]	@ (3418a714 <HAL_GPIO_DeInit+0x274>)
3418a534:	4293      	cmp	r3, r2
3418a536:	d00d      	beq.n	3418a554 <HAL_GPIO_DeInit+0xb4>
3418a538:	687b      	ldr	r3, [r7, #4]
3418a53a:	4a77      	ldr	r2, [pc, #476]	@ (3418a718 <HAL_GPIO_DeInit+0x278>)
3418a53c:	4293      	cmp	r3, r2
3418a53e:	d007      	beq.n	3418a550 <HAL_GPIO_DeInit+0xb0>
3418a540:	687b      	ldr	r3, [r7, #4]
3418a542:	4a76      	ldr	r2, [pc, #472]	@ (3418a71c <HAL_GPIO_DeInit+0x27c>)
3418a544:	4293      	cmp	r3, r2
3418a546:	d101      	bne.n	3418a54c <HAL_GPIO_DeInit+0xac>
3418a548:	230b      	movs	r3, #11
3418a54a:	e016      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a54c:	2310      	movs	r3, #16
3418a54e:	e014      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a550:	230a      	movs	r3, #10
3418a552:	e012      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a554:	2309      	movs	r3, #9
3418a556:	e010      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a558:	2308      	movs	r3, #8
3418a55a:	e00e      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a55c:	2307      	movs	r3, #7
3418a55e:	e00c      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a560:	2306      	movs	r3, #6
3418a562:	e00a      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a564:	2305      	movs	r3, #5
3418a566:	e008      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a568:	2304      	movs	r3, #4
3418a56a:	e006      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a56c:	2303      	movs	r3, #3
3418a56e:	e004      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a570:	2302      	movs	r3, #2
3418a572:	e002      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a574:	2301      	movs	r3, #1
3418a576:	e000      	b.n	3418a57a <HAL_GPIO_DeInit+0xda>
3418a578:	2300      	movs	r3, #0
3418a57a:	697a      	ldr	r2, [r7, #20]
3418a57c:	f002 0203 	and.w	r2, r2, #3
3418a580:	00d2      	lsls	r2, r2, #3
3418a582:	4093      	lsls	r3, r2
3418a584:	68fa      	ldr	r2, [r7, #12]
3418a586:	429a      	cmp	r2, r3
3418a588:	d136      	bne.n	3418a5f8 <HAL_GPIO_DeInit+0x158>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
3418a58a:	4b58      	ldr	r3, [pc, #352]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a58c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3418a590:	693b      	ldr	r3, [r7, #16]
3418a592:	43db      	mvns	r3, r3
3418a594:	4955      	ldr	r1, [pc, #340]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a596:	4013      	ands	r3, r2
3418a598:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
3418a59c:	4b53      	ldr	r3, [pc, #332]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a59e:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
3418a5a2:	693b      	ldr	r3, [r7, #16]
3418a5a4:	43db      	mvns	r3, r3
3418a5a6:	4951      	ldr	r1, [pc, #324]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5a8:	4013      	ands	r3, r2
3418a5aa:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
3418a5ae:	4b4f      	ldr	r3, [pc, #316]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5b0:	681a      	ldr	r2, [r3, #0]
3418a5b2:	693b      	ldr	r3, [r7, #16]
3418a5b4:	43db      	mvns	r3, r3
3418a5b6:	494d      	ldr	r1, [pc, #308]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5b8:	4013      	ands	r3, r2
3418a5ba:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
3418a5bc:	4b4b      	ldr	r3, [pc, #300]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5be:	685a      	ldr	r2, [r3, #4]
3418a5c0:	693b      	ldr	r3, [r7, #16]
3418a5c2:	43db      	mvns	r3, r3
3418a5c4:	4949      	ldr	r1, [pc, #292]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5c6:	4013      	ands	r3, r2
3418a5c8:	604b      	str	r3, [r1, #4]

        tmp = 0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos);
3418a5ca:	697b      	ldr	r3, [r7, #20]
3418a5cc:	f003 0303 	and.w	r3, r3, #3
3418a5d0:	00db      	lsls	r3, r3, #3
3418a5d2:	220f      	movs	r2, #15
3418a5d4:	fa02 f303 	lsl.w	r3, r2, r3
3418a5d8:	60fb      	str	r3, [r7, #12]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
3418a5da:	4a44      	ldr	r2, [pc, #272]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5dc:	697b      	ldr	r3, [r7, #20]
3418a5de:	089b      	lsrs	r3, r3, #2
3418a5e0:	3318      	adds	r3, #24
3418a5e2:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
3418a5e6:	68fb      	ldr	r3, [r7, #12]
3418a5e8:	43da      	mvns	r2, r3
3418a5ea:	4840      	ldr	r0, [pc, #256]	@ (3418a6ec <HAL_GPIO_DeInit+0x24c>)
3418a5ec:	697b      	ldr	r3, [r7, #20]
3418a5ee:	089b      	lsrs	r3, r3, #2
3418a5f0:	400a      	ands	r2, r1
3418a5f2:	3318      	adds	r3, #24
3418a5f4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
3418a5f8:	687b      	ldr	r3, [r7, #4]
3418a5fa:	681a      	ldr	r2, [r3, #0]
3418a5fc:	697b      	ldr	r3, [r7, #20]
3418a5fe:	005b      	lsls	r3, r3, #1
3418a600:	2103      	movs	r1, #3
3418a602:	fa01 f303 	lsl.w	r3, r1, r3
3418a606:	431a      	orrs	r2, r3
3418a608:	687b      	ldr	r3, [r7, #4]
3418a60a:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
3418a60c:	697b      	ldr	r3, [r7, #20]
3418a60e:	08da      	lsrs	r2, r3, #3
3418a610:	687b      	ldr	r3, [r7, #4]
3418a612:	3208      	adds	r2, #8
3418a614:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3418a618:	697b      	ldr	r3, [r7, #20]
3418a61a:	f003 0307 	and.w	r3, r3, #7
3418a61e:	009b      	lsls	r3, r3, #2
3418a620:	220f      	movs	r2, #15
3418a622:	fa02 f303 	lsl.w	r3, r2, r3
3418a626:	43db      	mvns	r3, r3
3418a628:	697a      	ldr	r2, [r7, #20]
3418a62a:	08d2      	lsrs	r2, r2, #3
3418a62c:	4019      	ands	r1, r3
3418a62e:	687b      	ldr	r3, [r7, #4]
3418a630:	3208      	adds	r2, #8
3418a632:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3418a636:	687b      	ldr	r3, [r7, #4]
3418a638:	689a      	ldr	r2, [r3, #8]
3418a63a:	697b      	ldr	r3, [r7, #20]
3418a63c:	005b      	lsls	r3, r3, #1
3418a63e:	2103      	movs	r1, #3
3418a640:	fa01 f303 	lsl.w	r3, r1, r3
3418a644:	43db      	mvns	r3, r3
3418a646:	401a      	ands	r2, r3
3418a648:	687b      	ldr	r3, [r7, #4]
3418a64a:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
3418a64c:	687b      	ldr	r3, [r7, #4]
3418a64e:	685a      	ldr	r2, [r3, #4]
3418a650:	2101      	movs	r1, #1
3418a652:	697b      	ldr	r3, [r7, #20]
3418a654:	fa01 f303 	lsl.w	r3, r1, r3
3418a658:	43db      	mvns	r3, r3
3418a65a:	401a      	ands	r2, r3
3418a65c:	687b      	ldr	r3, [r7, #4]
3418a65e:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
3418a660:	687b      	ldr	r3, [r7, #4]
3418a662:	68da      	ldr	r2, [r3, #12]
3418a664:	697b      	ldr	r3, [r7, #20]
3418a666:	005b      	lsls	r3, r3, #1
3418a668:	2103      	movs	r1, #3
3418a66a:	fa01 f303 	lsl.w	r3, r1, r3
3418a66e:	43db      	mvns	r3, r3
3418a670:	401a      	ands	r2, r3
3418a672:	687b      	ldr	r3, [r7, #4]
3418a674:	60da      	str	r2, [r3, #12]

      /* Reset delay settings for the current IO */
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
3418a676:	697b      	ldr	r3, [r7, #20]
3418a678:	08da      	lsrs	r2, r3, #3
3418a67a:	687b      	ldr	r3, [r7, #4]
3418a67c:	3210      	adds	r2, #16
3418a67e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3418a682:	697b      	ldr	r3, [r7, #20]
3418a684:	f003 0307 	and.w	r3, r3, #7
3418a688:	009b      	lsls	r3, r3, #2
3418a68a:	220f      	movs	r2, #15
3418a68c:	fa02 f303 	lsl.w	r3, r2, r3
3418a690:	43db      	mvns	r3, r3
3418a692:	697a      	ldr	r2, [r7, #20]
3418a694:	08d2      	lsrs	r2, r2, #3
3418a696:	4019      	ands	r1, r3
3418a698:	687b      	ldr	r3, [r7, #4]
3418a69a:	3210      	adds	r2, #16
3418a69c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Reset control settings for the current IO */
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
3418a6a0:	697b      	ldr	r3, [r7, #20]
3418a6a2:	08da      	lsrs	r2, r3, #3
3418a6a4:	687b      	ldr	r3, [r7, #4]
3418a6a6:	3212      	adds	r2, #18
3418a6a8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3418a6ac:	697b      	ldr	r3, [r7, #20]
3418a6ae:	f003 0307 	and.w	r3, r3, #7
3418a6b2:	009b      	lsls	r3, r3, #2
3418a6b4:	220f      	movs	r2, #15
3418a6b6:	fa02 f303 	lsl.w	r3, r2, r3
3418a6ba:	43db      	mvns	r3, r3
3418a6bc:	697a      	ldr	r2, [r7, #20]
3418a6be:	08d2      	lsrs	r2, r2, #3
3418a6c0:	4019      	ands	r1, r3
3418a6c2:	687b      	ldr	r3, [r7, #4]
3418a6c4:	3212      	adds	r2, #18
3418a6c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    position++;
3418a6ca:	697b      	ldr	r3, [r7, #20]
3418a6cc:	3301      	adds	r3, #1
3418a6ce:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00u)
3418a6d0:	683a      	ldr	r2, [r7, #0]
3418a6d2:	697b      	ldr	r3, [r7, #20]
3418a6d4:	fa22 f303 	lsr.w	r3, r2, r3
3418a6d8:	2b00      	cmp	r3, #0
3418a6da:	f47f aee9 	bne.w	3418a4b0 <HAL_GPIO_DeInit+0x10>
  }
}
3418a6de:	bf00      	nop
3418a6e0:	bf00      	nop
3418a6e2:	371c      	adds	r7, #28
3418a6e4:	46bd      	mov	sp, r7
3418a6e6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418a6ea:	4770      	bx	lr
3418a6ec:	56025000 	.word	0x56025000
3418a6f0:	56020000 	.word	0x56020000
3418a6f4:	56020400 	.word	0x56020400
3418a6f8:	56020800 	.word	0x56020800
3418a6fc:	56020c00 	.word	0x56020c00
3418a700:	56021000 	.word	0x56021000
3418a704:	56021400 	.word	0x56021400
3418a708:	56021800 	.word	0x56021800
3418a70c:	56021c00 	.word	0x56021c00
3418a710:	56023400 	.word	0x56023400
3418a714:	56023800 	.word	0x56023800
3418a718:	56023c00 	.word	0x56023c00
3418a71c:	56024000 	.word	0x56024000

3418a720 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
3418a720:	b480      	push	{r7}
3418a722:	b083      	sub	sp, #12
3418a724:	af00      	add	r7, sp, #0
3418a726:	6078      	str	r0, [r7, #4]
3418a728:	460b      	mov	r3, r1
3418a72a:	807b      	strh	r3, [r7, #2]
3418a72c:	4613      	mov	r3, r2
3418a72e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
3418a730:	787b      	ldrb	r3, [r7, #1]
3418a732:	2b00      	cmp	r3, #0
3418a734:	d003      	beq.n	3418a73e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
3418a736:	887a      	ldrh	r2, [r7, #2]
3418a738:	687b      	ldr	r3, [r7, #4]
3418a73a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
3418a73c:	e002      	b.n	3418a744 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
3418a73e:	887a      	ldrh	r2, [r7, #2]
3418a740:	687b      	ldr	r3, [r7, #4]
3418a742:	629a      	str	r2, [r3, #40]	@ 0x28
}
3418a744:	bf00      	nop
3418a746:	370c      	adds	r7, #12
3418a748:	46bd      	mov	sp, r7
3418a74a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418a74e:	4770      	bx	lr

3418a750 <HAL_GPIO_ConfigPinAttributes>:
  *            @arg @ref GPIO_PIN_SEC          Secure-only access
  *            @arg @ref GPIO_PIN_NSEC         Secure/Non-secure access
  * @retval None.
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
3418a750:	b480      	push	{r7}
3418a752:	b087      	sub	sp, #28
3418a754:	af00      	add	r7, sp, #0
3418a756:	60f8      	str	r0, [r7, #12]
3418a758:	460b      	mov	r3, r1
3418a75a:	607a      	str	r2, [r7, #4]
3418a75c:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

#if defined CPU_IN_SECURE_STATE
  /* Configure the port pins */
  sec = GPIOx->SECCFGR;
3418a75e:	68fb      	ldr	r3, [r7, #12]
3418a760:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3418a762:	617b      	str	r3, [r7, #20]
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
3418a764:	687a      	ldr	r2, [r7, #4]
3418a766:	f240 1301 	movw	r3, #257	@ 0x101
3418a76a:	4013      	ands	r3, r2
3418a76c:	f240 1201 	movw	r2, #257	@ 0x101
3418a770:	4293      	cmp	r3, r2
3418a772:	d104      	bne.n	3418a77e <HAL_GPIO_ConfigPinAttributes+0x2e>
  {
    sec |= (uint32_t)GPIO_Pin;
3418a774:	897b      	ldrh	r3, [r7, #10]
3418a776:	697a      	ldr	r2, [r7, #20]
3418a778:	4313      	orrs	r3, r2
3418a77a:	617b      	str	r3, [r7, #20]
3418a77c:	e009      	b.n	3418a792 <HAL_GPIO_ConfigPinAttributes+0x42>
  }
  else if ((PinAttributes & GPIO_PIN_NSEC) == GPIO_PIN_NSEC)
3418a77e:	687b      	ldr	r3, [r7, #4]
3418a780:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418a784:	2b00      	cmp	r3, #0
3418a786:	d004      	beq.n	3418a792 <HAL_GPIO_ConfigPinAttributes+0x42>
  {
    sec &= ~((uint32_t)GPIO_Pin);
3418a788:	897b      	ldrh	r3, [r7, #10]
3418a78a:	43db      	mvns	r3, r3
3418a78c:	697a      	ldr	r2, [r7, #20]
3418a78e:	4013      	ands	r3, r2
3418a790:	617b      	str	r3, [r7, #20]
  }
  else
  {
    /* do nothing */
  }
  GPIOx->SECCFGR = sec;
3418a792:	68fb      	ldr	r3, [r7, #12]
3418a794:	697a      	ldr	r2, [r7, #20]
3418a796:	631a      	str	r2, [r3, #48]	@ 0x30
#endif /* CPU_IN_SECURE_STATE */

  priv = GPIOx->PRIVCFGR;
3418a798:	68fb      	ldr	r3, [r7, #12]
3418a79a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418a79c:	613b      	str	r3, [r7, #16]
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
3418a79e:	687a      	ldr	r2, [r7, #4]
3418a7a0:	f240 2302 	movw	r3, #514	@ 0x202
3418a7a4:	4013      	ands	r3, r2
3418a7a6:	f240 2202 	movw	r2, #514	@ 0x202
3418a7aa:	4293      	cmp	r3, r2
3418a7ac:	d104      	bne.n	3418a7b8 <HAL_GPIO_ConfigPinAttributes+0x68>
  {
    priv |= (uint32_t)GPIO_Pin;
3418a7ae:	897b      	ldrh	r3, [r7, #10]
3418a7b0:	693a      	ldr	r2, [r7, #16]
3418a7b2:	4313      	orrs	r3, r2
3418a7b4:	613b      	str	r3, [r7, #16]
3418a7b6:	e009      	b.n	3418a7cc <HAL_GPIO_ConfigPinAttributes+0x7c>
  }
  else if ((PinAttributes & GPIO_PIN_NPRIV) == GPIO_PIN_NPRIV)
3418a7b8:	687b      	ldr	r3, [r7, #4]
3418a7ba:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418a7be:	2b00      	cmp	r3, #0
3418a7c0:	d004      	beq.n	3418a7cc <HAL_GPIO_ConfigPinAttributes+0x7c>
  {
    priv &= ~((uint32_t)GPIO_Pin);
3418a7c2:	897b      	ldrh	r3, [r7, #10]
3418a7c4:	43db      	mvns	r3, r3
3418a7c6:	693a      	ldr	r2, [r7, #16]
3418a7c8:	4013      	ands	r3, r2
3418a7ca:	613b      	str	r3, [r7, #16]
  else
  {
    /* do nothing */
  }

  GPIOx->PRIVCFGR = priv;
3418a7cc:	68fb      	ldr	r3, [r7, #12]
3418a7ce:	693a      	ldr	r2, [r7, #16]
3418a7d0:	635a      	str	r2, [r3, #52]	@ 0x34
}
3418a7d2:	bf00      	nop
3418a7d4:	371c      	adds	r7, #28
3418a7d6:	46bd      	mov	sp, r7
3418a7d8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418a7dc:	4770      	bx	lr

3418a7de <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
3418a7de:	b580      	push	{r7, lr}
3418a7e0:	b082      	sub	sp, #8
3418a7e2:	af00      	add	r7, sp, #0
3418a7e4:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
3418a7e6:	687b      	ldr	r3, [r7, #4]
3418a7e8:	2b00      	cmp	r3, #0
3418a7ea:	d101      	bne.n	3418a7f0 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
3418a7ec:	2301      	movs	r3, #1
3418a7ee:	e08d      	b.n	3418a90c <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
3418a7f0:	687b      	ldr	r3, [r7, #4]
3418a7f2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418a7f6:	b2db      	uxtb	r3, r3
3418a7f8:	2b00      	cmp	r3, #0
3418a7fa:	d106      	bne.n	3418a80a <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
3418a7fc:	687b      	ldr	r3, [r7, #4]
3418a7fe:	2200      	movs	r2, #0
3418a800:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
3418a804:	6878      	ldr	r0, [r7, #4]
3418a806:	f7f7 fd91 	bl	3418232c <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
3418a80a:	687b      	ldr	r3, [r7, #4]
3418a80c:	2224      	movs	r2, #36	@ 0x24
3418a80e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
3418a812:	687b      	ldr	r3, [r7, #4]
3418a814:	681b      	ldr	r3, [r3, #0]
3418a816:	681a      	ldr	r2, [r3, #0]
3418a818:	687b      	ldr	r3, [r7, #4]
3418a81a:	681b      	ldr	r3, [r3, #0]
3418a81c:	f022 0201 	bic.w	r2, r2, #1
3418a820:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
3418a822:	687b      	ldr	r3, [r7, #4]
3418a824:	685a      	ldr	r2, [r3, #4]
3418a826:	687b      	ldr	r3, [r7, #4]
3418a828:	681b      	ldr	r3, [r3, #0]
3418a82a:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
3418a82e:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
3418a830:	687b      	ldr	r3, [r7, #4]
3418a832:	681b      	ldr	r3, [r3, #0]
3418a834:	689a      	ldr	r2, [r3, #8]
3418a836:	687b      	ldr	r3, [r7, #4]
3418a838:	681b      	ldr	r3, [r3, #0]
3418a83a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3418a83e:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
3418a840:	687b      	ldr	r3, [r7, #4]
3418a842:	68db      	ldr	r3, [r3, #12]
3418a844:	2b01      	cmp	r3, #1
3418a846:	d107      	bne.n	3418a858 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3418a848:	687b      	ldr	r3, [r7, #4]
3418a84a:	689a      	ldr	r2, [r3, #8]
3418a84c:	687b      	ldr	r3, [r7, #4]
3418a84e:	681b      	ldr	r3, [r3, #0]
3418a850:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3418a854:	609a      	str	r2, [r3, #8]
3418a856:	e006      	b.n	3418a866 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3418a858:	687b      	ldr	r3, [r7, #4]
3418a85a:	689a      	ldr	r2, [r3, #8]
3418a85c:	687b      	ldr	r3, [r7, #4]
3418a85e:	681b      	ldr	r3, [r3, #0]
3418a860:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
3418a864:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3418a866:	687b      	ldr	r3, [r7, #4]
3418a868:	68db      	ldr	r3, [r3, #12]
3418a86a:	2b02      	cmp	r3, #2
3418a86c:	d108      	bne.n	3418a880 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3418a86e:	687b      	ldr	r3, [r7, #4]
3418a870:	681b      	ldr	r3, [r3, #0]
3418a872:	685a      	ldr	r2, [r3, #4]
3418a874:	687b      	ldr	r3, [r7, #4]
3418a876:	681b      	ldr	r3, [r3, #0]
3418a878:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
3418a87c:	605a      	str	r2, [r3, #4]
3418a87e:	e007      	b.n	3418a890 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3418a880:	687b      	ldr	r3, [r7, #4]
3418a882:	681b      	ldr	r3, [r3, #0]
3418a884:	685a      	ldr	r2, [r3, #4]
3418a886:	687b      	ldr	r3, [r7, #4]
3418a888:	681b      	ldr	r3, [r3, #0]
3418a88a:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
3418a88e:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
3418a890:	687b      	ldr	r3, [r7, #4]
3418a892:	681b      	ldr	r3, [r3, #0]
3418a894:	685b      	ldr	r3, [r3, #4]
3418a896:	687a      	ldr	r2, [r7, #4]
3418a898:	6812      	ldr	r2, [r2, #0]
3418a89a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
3418a89e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418a8a2:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
3418a8a4:	687b      	ldr	r3, [r7, #4]
3418a8a6:	681b      	ldr	r3, [r3, #0]
3418a8a8:	68da      	ldr	r2, [r3, #12]
3418a8aa:	687b      	ldr	r3, [r7, #4]
3418a8ac:	681b      	ldr	r3, [r3, #0]
3418a8ae:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3418a8b2:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3418a8b4:	687b      	ldr	r3, [r7, #4]
3418a8b6:	691a      	ldr	r2, [r3, #16]
3418a8b8:	687b      	ldr	r3, [r7, #4]
3418a8ba:	695b      	ldr	r3, [r3, #20]
3418a8bc:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
3418a8c0:	687b      	ldr	r3, [r7, #4]
3418a8c2:	699b      	ldr	r3, [r3, #24]
3418a8c4:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3418a8c6:	687b      	ldr	r3, [r7, #4]
3418a8c8:	681b      	ldr	r3, [r3, #0]
3418a8ca:	430a      	orrs	r2, r1
3418a8cc:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
3418a8ce:	687b      	ldr	r3, [r7, #4]
3418a8d0:	69d9      	ldr	r1, [r3, #28]
3418a8d2:	687b      	ldr	r3, [r7, #4]
3418a8d4:	6a1a      	ldr	r2, [r3, #32]
3418a8d6:	687b      	ldr	r3, [r7, #4]
3418a8d8:	681b      	ldr	r3, [r3, #0]
3418a8da:	430a      	orrs	r2, r1
3418a8dc:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
3418a8de:	687b      	ldr	r3, [r7, #4]
3418a8e0:	681b      	ldr	r3, [r3, #0]
3418a8e2:	681a      	ldr	r2, [r3, #0]
3418a8e4:	687b      	ldr	r3, [r7, #4]
3418a8e6:	681b      	ldr	r3, [r3, #0]
3418a8e8:	f042 0201 	orr.w	r2, r2, #1
3418a8ec:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3418a8ee:	687b      	ldr	r3, [r7, #4]
3418a8f0:	2200      	movs	r2, #0
3418a8f2:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
3418a8f4:	687b      	ldr	r3, [r7, #4]
3418a8f6:	2220      	movs	r2, #32
3418a8f8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3418a8fc:	687b      	ldr	r3, [r7, #4]
3418a8fe:	2200      	movs	r2, #0
3418a900:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3418a902:	687b      	ldr	r3, [r7, #4]
3418a904:	2200      	movs	r2, #0
3418a906:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
3418a90a:	2300      	movs	r3, #0
}
3418a90c:	4618      	mov	r0, r3
3418a90e:	3708      	adds	r7, #8
3418a910:	46bd      	mov	sp, r7
3418a912:	bd80      	pop	{r7, pc}

3418a914 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
3418a914:	b580      	push	{r7, lr}
3418a916:	b082      	sub	sp, #8
3418a918:	af00      	add	r7, sp, #0
3418a91a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
3418a91c:	687b      	ldr	r3, [r7, #4]
3418a91e:	2b00      	cmp	r3, #0
3418a920:	d101      	bne.n	3418a926 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
3418a922:	2301      	movs	r3, #1
3418a924:	e021      	b.n	3418a96a <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
3418a926:	687b      	ldr	r3, [r7, #4]
3418a928:	2224      	movs	r2, #36	@ 0x24
3418a92a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
3418a92e:	687b      	ldr	r3, [r7, #4]
3418a930:	681b      	ldr	r3, [r3, #0]
3418a932:	681a      	ldr	r2, [r3, #0]
3418a934:	687b      	ldr	r3, [r7, #4]
3418a936:	681b      	ldr	r3, [r3, #0]
3418a938:	f022 0201 	bic.w	r2, r2, #1
3418a93c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
3418a93e:	6878      	ldr	r0, [r7, #4]
3418a940:	f7f7 fd76 	bl	34182430 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3418a944:	687b      	ldr	r3, [r7, #4]
3418a946:	2200      	movs	r2, #0
3418a948:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
3418a94a:	687b      	ldr	r3, [r7, #4]
3418a94c:	2200      	movs	r2, #0
3418a94e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3418a952:	687b      	ldr	r3, [r7, #4]
3418a954:	2200      	movs	r2, #0
3418a956:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3418a958:	687b      	ldr	r3, [r7, #4]
3418a95a:	2200      	movs	r2, #0
3418a95c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
3418a960:	687b      	ldr	r3, [r7, #4]
3418a962:	2200      	movs	r2, #0
3418a964:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
3418a968:	2300      	movs	r3, #0
}
3418a96a:	4618      	mov	r0, r3
3418a96c:	3708      	adds	r7, #8
3418a96e:	46bd      	mov	sp, r7
3418a970:	bd80      	pop	{r7, pc}
	...

3418a974 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3418a974:	b580      	push	{r7, lr}
3418a976:	b088      	sub	sp, #32
3418a978:	af02      	add	r7, sp, #8
3418a97a:	60f8      	str	r0, [r7, #12]
3418a97c:	4608      	mov	r0, r1
3418a97e:	4611      	mov	r1, r2
3418a980:	461a      	mov	r2, r3
3418a982:	4603      	mov	r3, r0
3418a984:	817b      	strh	r3, [r7, #10]
3418a986:	460b      	mov	r3, r1
3418a988:	813b      	strh	r3, [r7, #8]
3418a98a:	4613      	mov	r3, r2
3418a98c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
3418a98e:	68fb      	ldr	r3, [r7, #12]
3418a990:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418a994:	b2db      	uxtb	r3, r3
3418a996:	2b20      	cmp	r3, #32
3418a998:	f040 80f9 	bne.w	3418ab8e <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
3418a99c:	6a3b      	ldr	r3, [r7, #32]
3418a99e:	2b00      	cmp	r3, #0
3418a9a0:	d002      	beq.n	3418a9a8 <HAL_I2C_Mem_Write+0x34>
3418a9a2:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
3418a9a4:	2b00      	cmp	r3, #0
3418a9a6:	d105      	bne.n	3418a9b4 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
3418a9a8:	68fb      	ldr	r3, [r7, #12]
3418a9aa:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418a9ae:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
3418a9b0:	2301      	movs	r3, #1
3418a9b2:	e0ed      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
3418a9b4:	68fb      	ldr	r3, [r7, #12]
3418a9b6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418a9ba:	2b01      	cmp	r3, #1
3418a9bc:	d101      	bne.n	3418a9c2 <HAL_I2C_Mem_Write+0x4e>
3418a9be:	2302      	movs	r3, #2
3418a9c0:	e0e6      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
3418a9c2:	68fb      	ldr	r3, [r7, #12]
3418a9c4:	2201      	movs	r2, #1
3418a9c6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
3418a9ca:	f7fb fda1 	bl	34186510 <HAL_GetTick>
3418a9ce:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3418a9d0:	697b      	ldr	r3, [r7, #20]
3418a9d2:	9300      	str	r3, [sp, #0]
3418a9d4:	2319      	movs	r3, #25
3418a9d6:	2201      	movs	r2, #1
3418a9d8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3418a9dc:	68f8      	ldr	r0, [r7, #12]
3418a9de:	f000 fadd 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418a9e2:	4603      	mov	r3, r0
3418a9e4:	2b00      	cmp	r3, #0
3418a9e6:	d001      	beq.n	3418a9ec <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
3418a9e8:	2301      	movs	r3, #1
3418a9ea:	e0d1      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
3418a9ec:	68fb      	ldr	r3, [r7, #12]
3418a9ee:	2221      	movs	r2, #33	@ 0x21
3418a9f0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3418a9f4:	68fb      	ldr	r3, [r7, #12]
3418a9f6:	2240      	movs	r2, #64	@ 0x40
3418a9f8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3418a9fc:	68fb      	ldr	r3, [r7, #12]
3418a9fe:	2200      	movs	r2, #0
3418aa00:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3418aa02:	68fb      	ldr	r3, [r7, #12]
3418aa04:	6a3a      	ldr	r2, [r7, #32]
3418aa06:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
3418aa08:	68fb      	ldr	r3, [r7, #12]
3418aa0a:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
3418aa0c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
3418aa0e:	68fb      	ldr	r3, [r7, #12]
3418aa10:	2200      	movs	r2, #0
3418aa12:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3418aa14:	88f8      	ldrh	r0, [r7, #6]
3418aa16:	893a      	ldrh	r2, [r7, #8]
3418aa18:	8979      	ldrh	r1, [r7, #10]
3418aa1a:	697b      	ldr	r3, [r7, #20]
3418aa1c:	9301      	str	r3, [sp, #4]
3418aa1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aa20:	9300      	str	r3, [sp, #0]
3418aa22:	4603      	mov	r3, r0
3418aa24:	68f8      	ldr	r0, [r7, #12]
3418aa26:	f000 f9ed 	bl	3418ae04 <I2C_RequestMemoryWrite>
3418aa2a:	4603      	mov	r3, r0
3418aa2c:	2b00      	cmp	r3, #0
3418aa2e:	d005      	beq.n	3418aa3c <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
3418aa30:	68fb      	ldr	r3, [r7, #12]
3418aa32:	2200      	movs	r2, #0
3418aa34:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
3418aa38:	2301      	movs	r3, #1
3418aa3a:	e0a9      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3418aa3c:	68fb      	ldr	r3, [r7, #12]
3418aa3e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418aa40:	b29b      	uxth	r3, r3
3418aa42:	2bff      	cmp	r3, #255	@ 0xff
3418aa44:	d90e      	bls.n	3418aa64 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3418aa46:	68fb      	ldr	r3, [r7, #12]
3418aa48:	22ff      	movs	r2, #255	@ 0xff
3418aa4a:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
3418aa4c:	68fb      	ldr	r3, [r7, #12]
3418aa4e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418aa50:	b2da      	uxtb	r2, r3
3418aa52:	8979      	ldrh	r1, [r7, #10]
3418aa54:	2300      	movs	r3, #0
3418aa56:	9300      	str	r3, [sp, #0]
3418aa58:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418aa5c:	68f8      	ldr	r0, [r7, #12]
3418aa5e:	f000 fc61 	bl	3418b324 <I2C_TransferConfig>
3418aa62:	e00f      	b.n	3418aa84 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
3418aa64:	68fb      	ldr	r3, [r7, #12]
3418aa66:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418aa68:	b29a      	uxth	r2, r3
3418aa6a:	68fb      	ldr	r3, [r7, #12]
3418aa6c:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
3418aa6e:	68fb      	ldr	r3, [r7, #12]
3418aa70:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418aa72:	b2da      	uxtb	r2, r3
3418aa74:	8979      	ldrh	r1, [r7, #10]
3418aa76:	2300      	movs	r3, #0
3418aa78:	9300      	str	r3, [sp, #0]
3418aa7a:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3418aa7e:	68f8      	ldr	r0, [r7, #12]
3418aa80:	f000 fc50 	bl	3418b324 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3418aa84:	697a      	ldr	r2, [r7, #20]
3418aa86:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418aa88:	68f8      	ldr	r0, [r7, #12]
3418aa8a:	f000 fae0 	bl	3418b04e <I2C_WaitOnTXISFlagUntilTimeout>
3418aa8e:	4603      	mov	r3, r0
3418aa90:	2b00      	cmp	r3, #0
3418aa92:	d001      	beq.n	3418aa98 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
3418aa94:	2301      	movs	r3, #1
3418aa96:	e07b      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
3418aa98:	68fb      	ldr	r3, [r7, #12]
3418aa9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418aa9c:	781a      	ldrb	r2, [r3, #0]
3418aa9e:	68fb      	ldr	r3, [r7, #12]
3418aaa0:	681b      	ldr	r3, [r3, #0]
3418aaa2:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3418aaa4:	68fb      	ldr	r3, [r7, #12]
3418aaa6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418aaa8:	1c5a      	adds	r2, r3, #1
3418aaaa:	68fb      	ldr	r3, [r7, #12]
3418aaac:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
3418aaae:	68fb      	ldr	r3, [r7, #12]
3418aab0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418aab2:	b29b      	uxth	r3, r3
3418aab4:	3b01      	subs	r3, #1
3418aab6:	b29a      	uxth	r2, r3
3418aab8:	68fb      	ldr	r3, [r7, #12]
3418aaba:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
3418aabc:	68fb      	ldr	r3, [r7, #12]
3418aabe:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418aac0:	3b01      	subs	r3, #1
3418aac2:	b29a      	uxth	r2, r3
3418aac4:	68fb      	ldr	r3, [r7, #12]
3418aac6:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3418aac8:	68fb      	ldr	r3, [r7, #12]
3418aaca:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418aacc:	b29b      	uxth	r3, r3
3418aace:	2b00      	cmp	r3, #0
3418aad0:	d034      	beq.n	3418ab3c <HAL_I2C_Mem_Write+0x1c8>
3418aad2:	68fb      	ldr	r3, [r7, #12]
3418aad4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418aad6:	2b00      	cmp	r3, #0
3418aad8:	d130      	bne.n	3418ab3c <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3418aada:	697b      	ldr	r3, [r7, #20]
3418aadc:	9300      	str	r3, [sp, #0]
3418aade:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418aae0:	2200      	movs	r2, #0
3418aae2:	2180      	movs	r1, #128	@ 0x80
3418aae4:	68f8      	ldr	r0, [r7, #12]
3418aae6:	f000 fa59 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418aaea:	4603      	mov	r3, r0
3418aaec:	2b00      	cmp	r3, #0
3418aaee:	d001      	beq.n	3418aaf4 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
3418aaf0:	2301      	movs	r3, #1
3418aaf2:	e04d      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3418aaf4:	68fb      	ldr	r3, [r7, #12]
3418aaf6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418aaf8:	b29b      	uxth	r3, r3
3418aafa:	2bff      	cmp	r3, #255	@ 0xff
3418aafc:	d90e      	bls.n	3418ab1c <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3418aafe:	68fb      	ldr	r3, [r7, #12]
3418ab00:	22ff      	movs	r2, #255	@ 0xff
3418ab02:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3418ab04:	68fb      	ldr	r3, [r7, #12]
3418ab06:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ab08:	b2da      	uxtb	r2, r3
3418ab0a:	8979      	ldrh	r1, [r7, #10]
3418ab0c:	2300      	movs	r3, #0
3418ab0e:	9300      	str	r3, [sp, #0]
3418ab10:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418ab14:	68f8      	ldr	r0, [r7, #12]
3418ab16:	f000 fc05 	bl	3418b324 <I2C_TransferConfig>
3418ab1a:	e00f      	b.n	3418ab3c <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3418ab1c:	68fb      	ldr	r3, [r7, #12]
3418ab1e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ab20:	b29a      	uxth	r2, r3
3418ab22:	68fb      	ldr	r3, [r7, #12]
3418ab24:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3418ab26:	68fb      	ldr	r3, [r7, #12]
3418ab28:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ab2a:	b2da      	uxtb	r2, r3
3418ab2c:	8979      	ldrh	r1, [r7, #10]
3418ab2e:	2300      	movs	r3, #0
3418ab30:	9300      	str	r3, [sp, #0]
3418ab32:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3418ab36:	68f8      	ldr	r0, [r7, #12]
3418ab38:	f000 fbf4 	bl	3418b324 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
3418ab3c:	68fb      	ldr	r3, [r7, #12]
3418ab3e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ab40:	b29b      	uxth	r3, r3
3418ab42:	2b00      	cmp	r3, #0
3418ab44:	d19e      	bne.n	3418aa84 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3418ab46:	697a      	ldr	r2, [r7, #20]
3418ab48:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ab4a:	68f8      	ldr	r0, [r7, #12]
3418ab4c:	f000 fac6 	bl	3418b0dc <I2C_WaitOnSTOPFlagUntilTimeout>
3418ab50:	4603      	mov	r3, r0
3418ab52:	2b00      	cmp	r3, #0
3418ab54:	d001      	beq.n	3418ab5a <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
3418ab56:	2301      	movs	r3, #1
3418ab58:	e01a      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3418ab5a:	68fb      	ldr	r3, [r7, #12]
3418ab5c:	681b      	ldr	r3, [r3, #0]
3418ab5e:	2220      	movs	r2, #32
3418ab60:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3418ab62:	68fb      	ldr	r3, [r7, #12]
3418ab64:	681b      	ldr	r3, [r3, #0]
3418ab66:	6859      	ldr	r1, [r3, #4]
3418ab68:	68fb      	ldr	r3, [r7, #12]
3418ab6a:	681a      	ldr	r2, [r3, #0]
3418ab6c:	4b0a      	ldr	r3, [pc, #40]	@ (3418ab98 <HAL_I2C_Mem_Write+0x224>)
3418ab6e:	400b      	ands	r3, r1
3418ab70:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
3418ab72:	68fb      	ldr	r3, [r7, #12]
3418ab74:	2220      	movs	r2, #32
3418ab76:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3418ab7a:	68fb      	ldr	r3, [r7, #12]
3418ab7c:	2200      	movs	r2, #0
3418ab7e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418ab82:	68fb      	ldr	r3, [r7, #12]
3418ab84:	2200      	movs	r2, #0
3418ab86:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418ab8a:	2300      	movs	r3, #0
3418ab8c:	e000      	b.n	3418ab90 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
3418ab8e:	2302      	movs	r3, #2
  }
}
3418ab90:	4618      	mov	r0, r3
3418ab92:	3718      	adds	r7, #24
3418ab94:	46bd      	mov	sp, r7
3418ab96:	bd80      	pop	{r7, pc}
3418ab98:	fe00e800 	.word	0xfe00e800

3418ab9c <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3418ab9c:	b580      	push	{r7, lr}
3418ab9e:	b088      	sub	sp, #32
3418aba0:	af02      	add	r7, sp, #8
3418aba2:	60f8      	str	r0, [r7, #12]
3418aba4:	4608      	mov	r0, r1
3418aba6:	4611      	mov	r1, r2
3418aba8:	461a      	mov	r2, r3
3418abaa:	4603      	mov	r3, r0
3418abac:	817b      	strh	r3, [r7, #10]
3418abae:	460b      	mov	r3, r1
3418abb0:	813b      	strh	r3, [r7, #8]
3418abb2:	4613      	mov	r3, r2
3418abb4:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
3418abb6:	68fb      	ldr	r3, [r7, #12]
3418abb8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418abbc:	b2db      	uxtb	r3, r3
3418abbe:	2b20      	cmp	r3, #32
3418abc0:	f040 80fd 	bne.w	3418adbe <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
3418abc4:	6a3b      	ldr	r3, [r7, #32]
3418abc6:	2b00      	cmp	r3, #0
3418abc8:	d002      	beq.n	3418abd0 <HAL_I2C_Mem_Read+0x34>
3418abca:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
3418abcc:	2b00      	cmp	r3, #0
3418abce:	d105      	bne.n	3418abdc <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
3418abd0:	68fb      	ldr	r3, [r7, #12]
3418abd2:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418abd6:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
3418abd8:	2301      	movs	r3, #1
3418abda:	e0f1      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
3418abdc:	68fb      	ldr	r3, [r7, #12]
3418abde:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418abe2:	2b01      	cmp	r3, #1
3418abe4:	d101      	bne.n	3418abea <HAL_I2C_Mem_Read+0x4e>
3418abe6:	2302      	movs	r3, #2
3418abe8:	e0ea      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
3418abea:	68fb      	ldr	r3, [r7, #12]
3418abec:	2201      	movs	r2, #1
3418abee:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
3418abf2:	f7fb fc8d 	bl	34186510 <HAL_GetTick>
3418abf6:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3418abf8:	697b      	ldr	r3, [r7, #20]
3418abfa:	9300      	str	r3, [sp, #0]
3418abfc:	2319      	movs	r3, #25
3418abfe:	2201      	movs	r2, #1
3418ac00:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3418ac04:	68f8      	ldr	r0, [r7, #12]
3418ac06:	f000 f9c9 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418ac0a:	4603      	mov	r3, r0
3418ac0c:	2b00      	cmp	r3, #0
3418ac0e:	d001      	beq.n	3418ac14 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
3418ac10:	2301      	movs	r3, #1
3418ac12:	e0d5      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
3418ac14:	68fb      	ldr	r3, [r7, #12]
3418ac16:	2222      	movs	r2, #34	@ 0x22
3418ac18:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3418ac1c:	68fb      	ldr	r3, [r7, #12]
3418ac1e:	2240      	movs	r2, #64	@ 0x40
3418ac20:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3418ac24:	68fb      	ldr	r3, [r7, #12]
3418ac26:	2200      	movs	r2, #0
3418ac28:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3418ac2a:	68fb      	ldr	r3, [r7, #12]
3418ac2c:	6a3a      	ldr	r2, [r7, #32]
3418ac2e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
3418ac30:	68fb      	ldr	r3, [r7, #12]
3418ac32:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
3418ac34:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
3418ac36:	68fb      	ldr	r3, [r7, #12]
3418ac38:	2200      	movs	r2, #0
3418ac3a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3418ac3c:	88f8      	ldrh	r0, [r7, #6]
3418ac3e:	893a      	ldrh	r2, [r7, #8]
3418ac40:	8979      	ldrh	r1, [r7, #10]
3418ac42:	697b      	ldr	r3, [r7, #20]
3418ac44:	9301      	str	r3, [sp, #4]
3418ac46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ac48:	9300      	str	r3, [sp, #0]
3418ac4a:	4603      	mov	r3, r0
3418ac4c:	68f8      	ldr	r0, [r7, #12]
3418ac4e:	f000 f92d 	bl	3418aeac <I2C_RequestMemoryRead>
3418ac52:	4603      	mov	r3, r0
3418ac54:	2b00      	cmp	r3, #0
3418ac56:	d005      	beq.n	3418ac64 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
3418ac58:	68fb      	ldr	r3, [r7, #12]
3418ac5a:	2200      	movs	r2, #0
3418ac5c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
3418ac60:	2301      	movs	r3, #1
3418ac62:	e0ad      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3418ac64:	68fb      	ldr	r3, [r7, #12]
3418ac66:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ac68:	b29b      	uxth	r3, r3
3418ac6a:	2bff      	cmp	r3, #255	@ 0xff
3418ac6c:	d90e      	bls.n	3418ac8c <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3418ac6e:	68fb      	ldr	r3, [r7, #12]
3418ac70:	22ff      	movs	r2, #255	@ 0xff
3418ac72:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3418ac74:	68fb      	ldr	r3, [r7, #12]
3418ac76:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ac78:	b2da      	uxtb	r2, r3
3418ac7a:	8979      	ldrh	r1, [r7, #10]
3418ac7c:	4b52      	ldr	r3, [pc, #328]	@ (3418adc8 <HAL_I2C_Mem_Read+0x22c>)
3418ac7e:	9300      	str	r3, [sp, #0]
3418ac80:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418ac84:	68f8      	ldr	r0, [r7, #12]
3418ac86:	f000 fb4d 	bl	3418b324 <I2C_TransferConfig>
3418ac8a:	e00f      	b.n	3418acac <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
3418ac8c:	68fb      	ldr	r3, [r7, #12]
3418ac8e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ac90:	b29a      	uxth	r2, r3
3418ac92:	68fb      	ldr	r3, [r7, #12]
3418ac94:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3418ac96:	68fb      	ldr	r3, [r7, #12]
3418ac98:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ac9a:	b2da      	uxtb	r2, r3
3418ac9c:	8979      	ldrh	r1, [r7, #10]
3418ac9e:	4b4a      	ldr	r3, [pc, #296]	@ (3418adc8 <HAL_I2C_Mem_Read+0x22c>)
3418aca0:	9300      	str	r3, [sp, #0]
3418aca2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3418aca6:	68f8      	ldr	r0, [r7, #12]
3418aca8:	f000 fb3c 	bl	3418b324 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
3418acac:	697b      	ldr	r3, [r7, #20]
3418acae:	9300      	str	r3, [sp, #0]
3418acb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418acb2:	2200      	movs	r2, #0
3418acb4:	2104      	movs	r1, #4
3418acb6:	68f8      	ldr	r0, [r7, #12]
3418acb8:	f000 f970 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418acbc:	4603      	mov	r3, r0
3418acbe:	2b00      	cmp	r3, #0
3418acc0:	d001      	beq.n	3418acc6 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
3418acc2:	2301      	movs	r3, #1
3418acc4:	e07c      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
3418acc6:	68fb      	ldr	r3, [r7, #12]
3418acc8:	681b      	ldr	r3, [r3, #0]
3418acca:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3418accc:	68fb      	ldr	r3, [r7, #12]
3418acce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418acd0:	b2d2      	uxtb	r2, r2
3418acd2:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3418acd4:	68fb      	ldr	r3, [r7, #12]
3418acd6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418acd8:	1c5a      	adds	r2, r3, #1
3418acda:	68fb      	ldr	r3, [r7, #12]
3418acdc:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
3418acde:	68fb      	ldr	r3, [r7, #12]
3418ace0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ace2:	3b01      	subs	r3, #1
3418ace4:	b29a      	uxth	r2, r3
3418ace6:	68fb      	ldr	r3, [r7, #12]
3418ace8:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
3418acea:	68fb      	ldr	r3, [r7, #12]
3418acec:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418acee:	b29b      	uxth	r3, r3
3418acf0:	3b01      	subs	r3, #1
3418acf2:	b29a      	uxth	r2, r3
3418acf4:	68fb      	ldr	r3, [r7, #12]
3418acf6:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3418acf8:	68fb      	ldr	r3, [r7, #12]
3418acfa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418acfc:	b29b      	uxth	r3, r3
3418acfe:	2b00      	cmp	r3, #0
3418ad00:	d034      	beq.n	3418ad6c <HAL_I2C_Mem_Read+0x1d0>
3418ad02:	68fb      	ldr	r3, [r7, #12]
3418ad04:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ad06:	2b00      	cmp	r3, #0
3418ad08:	d130      	bne.n	3418ad6c <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3418ad0a:	697b      	ldr	r3, [r7, #20]
3418ad0c:	9300      	str	r3, [sp, #0]
3418ad0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ad10:	2200      	movs	r2, #0
3418ad12:	2180      	movs	r1, #128	@ 0x80
3418ad14:	68f8      	ldr	r0, [r7, #12]
3418ad16:	f000 f941 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418ad1a:	4603      	mov	r3, r0
3418ad1c:	2b00      	cmp	r3, #0
3418ad1e:	d001      	beq.n	3418ad24 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
3418ad20:	2301      	movs	r3, #1
3418ad22:	e04d      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3418ad24:	68fb      	ldr	r3, [r7, #12]
3418ad26:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ad28:	b29b      	uxth	r3, r3
3418ad2a:	2bff      	cmp	r3, #255	@ 0xff
3418ad2c:	d90e      	bls.n	3418ad4c <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3418ad2e:	68fb      	ldr	r3, [r7, #12]
3418ad30:	22ff      	movs	r2, #255	@ 0xff
3418ad32:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
3418ad34:	68fb      	ldr	r3, [r7, #12]
3418ad36:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ad38:	b2da      	uxtb	r2, r3
3418ad3a:	8979      	ldrh	r1, [r7, #10]
3418ad3c:	2300      	movs	r3, #0
3418ad3e:	9300      	str	r3, [sp, #0]
3418ad40:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418ad44:	68f8      	ldr	r0, [r7, #12]
3418ad46:	f000 faed 	bl	3418b324 <I2C_TransferConfig>
3418ad4a:	e00f      	b.n	3418ad6c <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3418ad4c:	68fb      	ldr	r3, [r7, #12]
3418ad4e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ad50:	b29a      	uxth	r2, r3
3418ad52:	68fb      	ldr	r3, [r7, #12]
3418ad54:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3418ad56:	68fb      	ldr	r3, [r7, #12]
3418ad58:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3418ad5a:	b2da      	uxtb	r2, r3
3418ad5c:	8979      	ldrh	r1, [r7, #10]
3418ad5e:	2300      	movs	r3, #0
3418ad60:	9300      	str	r3, [sp, #0]
3418ad62:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3418ad66:	68f8      	ldr	r0, [r7, #12]
3418ad68:	f000 fadc 	bl	3418b324 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
3418ad6c:	68fb      	ldr	r3, [r7, #12]
3418ad6e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3418ad70:	b29b      	uxth	r3, r3
3418ad72:	2b00      	cmp	r3, #0
3418ad74:	d19a      	bne.n	3418acac <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3418ad76:	697a      	ldr	r2, [r7, #20]
3418ad78:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ad7a:	68f8      	ldr	r0, [r7, #12]
3418ad7c:	f000 f9ae 	bl	3418b0dc <I2C_WaitOnSTOPFlagUntilTimeout>
3418ad80:	4603      	mov	r3, r0
3418ad82:	2b00      	cmp	r3, #0
3418ad84:	d001      	beq.n	3418ad8a <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
3418ad86:	2301      	movs	r3, #1
3418ad88:	e01a      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3418ad8a:	68fb      	ldr	r3, [r7, #12]
3418ad8c:	681b      	ldr	r3, [r3, #0]
3418ad8e:	2220      	movs	r2, #32
3418ad90:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3418ad92:	68fb      	ldr	r3, [r7, #12]
3418ad94:	681b      	ldr	r3, [r3, #0]
3418ad96:	6859      	ldr	r1, [r3, #4]
3418ad98:	68fb      	ldr	r3, [r7, #12]
3418ad9a:	681a      	ldr	r2, [r3, #0]
3418ad9c:	4b0b      	ldr	r3, [pc, #44]	@ (3418adcc <HAL_I2C_Mem_Read+0x230>)
3418ad9e:	400b      	ands	r3, r1
3418ada0:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
3418ada2:	68fb      	ldr	r3, [r7, #12]
3418ada4:	2220      	movs	r2, #32
3418ada6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3418adaa:	68fb      	ldr	r3, [r7, #12]
3418adac:	2200      	movs	r2, #0
3418adae:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418adb2:	68fb      	ldr	r3, [r7, #12]
3418adb4:	2200      	movs	r2, #0
3418adb6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418adba:	2300      	movs	r3, #0
3418adbc:	e000      	b.n	3418adc0 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
3418adbe:	2302      	movs	r3, #2
  }
}
3418adc0:	4618      	mov	r0, r3
3418adc2:	3718      	adds	r7, #24
3418adc4:	46bd      	mov	sp, r7
3418adc6:	bd80      	pop	{r7, pc}
3418adc8:	80002400 	.word	0x80002400
3418adcc:	fe00e800 	.word	0xfe00e800

3418add0 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(const I2C_HandleTypeDef *hi2c)
{
3418add0:	b480      	push	{r7}
3418add2:	b083      	sub	sp, #12
3418add4:	af00      	add	r7, sp, #0
3418add6:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
3418add8:	687b      	ldr	r3, [r7, #4]
3418adda:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418adde:	b2db      	uxtb	r3, r3
}
3418ade0:	4618      	mov	r0, r3
3418ade2:	370c      	adds	r7, #12
3418ade4:	46bd      	mov	sp, r7
3418ade6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418adea:	4770      	bx	lr

3418adec <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(const I2C_HandleTypeDef *hi2c)
{
3418adec:	b480      	push	{r7}
3418adee:	b083      	sub	sp, #12
3418adf0:	af00      	add	r7, sp, #0
3418adf2:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
3418adf4:	687b      	ldr	r3, [r7, #4]
3418adf6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
}
3418adf8:	4618      	mov	r0, r3
3418adfa:	370c      	adds	r7, #12
3418adfc:	46bd      	mov	sp, r7
3418adfe:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ae02:	4770      	bx	lr

3418ae04 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
3418ae04:	b580      	push	{r7, lr}
3418ae06:	b086      	sub	sp, #24
3418ae08:	af02      	add	r7, sp, #8
3418ae0a:	60f8      	str	r0, [r7, #12]
3418ae0c:	4608      	mov	r0, r1
3418ae0e:	4611      	mov	r1, r2
3418ae10:	461a      	mov	r2, r3
3418ae12:	4603      	mov	r3, r0
3418ae14:	817b      	strh	r3, [r7, #10]
3418ae16:	460b      	mov	r3, r1
3418ae18:	813b      	strh	r3, [r7, #8]
3418ae1a:	4613      	mov	r3, r2
3418ae1c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3418ae1e:	88fb      	ldrh	r3, [r7, #6]
3418ae20:	b2da      	uxtb	r2, r3
3418ae22:	8979      	ldrh	r1, [r7, #10]
3418ae24:	4b20      	ldr	r3, [pc, #128]	@ (3418aea8 <I2C_RequestMemoryWrite+0xa4>)
3418ae26:	9300      	str	r3, [sp, #0]
3418ae28:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3418ae2c:	68f8      	ldr	r0, [r7, #12]
3418ae2e:	f000 fa79 	bl	3418b324 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3418ae32:	69fa      	ldr	r2, [r7, #28]
3418ae34:	69b9      	ldr	r1, [r7, #24]
3418ae36:	68f8      	ldr	r0, [r7, #12]
3418ae38:	f000 f909 	bl	3418b04e <I2C_WaitOnTXISFlagUntilTimeout>
3418ae3c:	4603      	mov	r3, r0
3418ae3e:	2b00      	cmp	r3, #0
3418ae40:	d001      	beq.n	3418ae46 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
3418ae42:	2301      	movs	r3, #1
3418ae44:	e02c      	b.n	3418aea0 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3418ae46:	88fb      	ldrh	r3, [r7, #6]
3418ae48:	2b01      	cmp	r3, #1
3418ae4a:	d105      	bne.n	3418ae58 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3418ae4c:	893b      	ldrh	r3, [r7, #8]
3418ae4e:	b2da      	uxtb	r2, r3
3418ae50:	68fb      	ldr	r3, [r7, #12]
3418ae52:	681b      	ldr	r3, [r3, #0]
3418ae54:	629a      	str	r2, [r3, #40]	@ 0x28
3418ae56:	e015      	b.n	3418ae84 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3418ae58:	893b      	ldrh	r3, [r7, #8]
3418ae5a:	0a1b      	lsrs	r3, r3, #8
3418ae5c:	b29b      	uxth	r3, r3
3418ae5e:	b2da      	uxtb	r2, r3
3418ae60:	68fb      	ldr	r3, [r7, #12]
3418ae62:	681b      	ldr	r3, [r3, #0]
3418ae64:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3418ae66:	69fa      	ldr	r2, [r7, #28]
3418ae68:	69b9      	ldr	r1, [r7, #24]
3418ae6a:	68f8      	ldr	r0, [r7, #12]
3418ae6c:	f000 f8ef 	bl	3418b04e <I2C_WaitOnTXISFlagUntilTimeout>
3418ae70:	4603      	mov	r3, r0
3418ae72:	2b00      	cmp	r3, #0
3418ae74:	d001      	beq.n	3418ae7a <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
3418ae76:	2301      	movs	r3, #1
3418ae78:	e012      	b.n	3418aea0 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3418ae7a:	893b      	ldrh	r3, [r7, #8]
3418ae7c:	b2da      	uxtb	r2, r3
3418ae7e:	68fb      	ldr	r3, [r7, #12]
3418ae80:	681b      	ldr	r3, [r3, #0]
3418ae82:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
3418ae84:	69fb      	ldr	r3, [r7, #28]
3418ae86:	9300      	str	r3, [sp, #0]
3418ae88:	69bb      	ldr	r3, [r7, #24]
3418ae8a:	2200      	movs	r2, #0
3418ae8c:	2180      	movs	r1, #128	@ 0x80
3418ae8e:	68f8      	ldr	r0, [r7, #12]
3418ae90:	f000 f884 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418ae94:	4603      	mov	r3, r0
3418ae96:	2b00      	cmp	r3, #0
3418ae98:	d001      	beq.n	3418ae9e <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
3418ae9a:	2301      	movs	r3, #1
3418ae9c:	e000      	b.n	3418aea0 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
3418ae9e:	2300      	movs	r3, #0
}
3418aea0:	4618      	mov	r0, r3
3418aea2:	3710      	adds	r7, #16
3418aea4:	46bd      	mov	sp, r7
3418aea6:	bd80      	pop	{r7, pc}
3418aea8:	80002000 	.word	0x80002000

3418aeac <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
3418aeac:	b580      	push	{r7, lr}
3418aeae:	b086      	sub	sp, #24
3418aeb0:	af02      	add	r7, sp, #8
3418aeb2:	60f8      	str	r0, [r7, #12]
3418aeb4:	4608      	mov	r0, r1
3418aeb6:	4611      	mov	r1, r2
3418aeb8:	461a      	mov	r2, r3
3418aeba:	4603      	mov	r3, r0
3418aebc:	817b      	strh	r3, [r7, #10]
3418aebe:	460b      	mov	r3, r1
3418aec0:	813b      	strh	r3, [r7, #8]
3418aec2:	4613      	mov	r3, r2
3418aec4:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
3418aec6:	88fb      	ldrh	r3, [r7, #6]
3418aec8:	b2da      	uxtb	r2, r3
3418aeca:	8979      	ldrh	r1, [r7, #10]
3418aecc:	4b20      	ldr	r3, [pc, #128]	@ (3418af50 <I2C_RequestMemoryRead+0xa4>)
3418aece:	9300      	str	r3, [sp, #0]
3418aed0:	2300      	movs	r3, #0
3418aed2:	68f8      	ldr	r0, [r7, #12]
3418aed4:	f000 fa26 	bl	3418b324 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3418aed8:	69fa      	ldr	r2, [r7, #28]
3418aeda:	69b9      	ldr	r1, [r7, #24]
3418aedc:	68f8      	ldr	r0, [r7, #12]
3418aede:	f000 f8b6 	bl	3418b04e <I2C_WaitOnTXISFlagUntilTimeout>
3418aee2:	4603      	mov	r3, r0
3418aee4:	2b00      	cmp	r3, #0
3418aee6:	d001      	beq.n	3418aeec <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
3418aee8:	2301      	movs	r3, #1
3418aeea:	e02c      	b.n	3418af46 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3418aeec:	88fb      	ldrh	r3, [r7, #6]
3418aeee:	2b01      	cmp	r3, #1
3418aef0:	d105      	bne.n	3418aefe <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3418aef2:	893b      	ldrh	r3, [r7, #8]
3418aef4:	b2da      	uxtb	r2, r3
3418aef6:	68fb      	ldr	r3, [r7, #12]
3418aef8:	681b      	ldr	r3, [r3, #0]
3418aefa:	629a      	str	r2, [r3, #40]	@ 0x28
3418aefc:	e015      	b.n	3418af2a <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3418aefe:	893b      	ldrh	r3, [r7, #8]
3418af00:	0a1b      	lsrs	r3, r3, #8
3418af02:	b29b      	uxth	r3, r3
3418af04:	b2da      	uxtb	r2, r3
3418af06:	68fb      	ldr	r3, [r7, #12]
3418af08:	681b      	ldr	r3, [r3, #0]
3418af0a:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3418af0c:	69fa      	ldr	r2, [r7, #28]
3418af0e:	69b9      	ldr	r1, [r7, #24]
3418af10:	68f8      	ldr	r0, [r7, #12]
3418af12:	f000 f89c 	bl	3418b04e <I2C_WaitOnTXISFlagUntilTimeout>
3418af16:	4603      	mov	r3, r0
3418af18:	2b00      	cmp	r3, #0
3418af1a:	d001      	beq.n	3418af20 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
3418af1c:	2301      	movs	r3, #1
3418af1e:	e012      	b.n	3418af46 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3418af20:	893b      	ldrh	r3, [r7, #8]
3418af22:	b2da      	uxtb	r2, r3
3418af24:	68fb      	ldr	r3, [r7, #12]
3418af26:	681b      	ldr	r3, [r3, #0]
3418af28:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
3418af2a:	69fb      	ldr	r3, [r7, #28]
3418af2c:	9300      	str	r3, [sp, #0]
3418af2e:	69bb      	ldr	r3, [r7, #24]
3418af30:	2200      	movs	r2, #0
3418af32:	2140      	movs	r1, #64	@ 0x40
3418af34:	68f8      	ldr	r0, [r7, #12]
3418af36:	f000 f831 	bl	3418af9c <I2C_WaitOnFlagUntilTimeout>
3418af3a:	4603      	mov	r3, r0
3418af3c:	2b00      	cmp	r3, #0
3418af3e:	d001      	beq.n	3418af44 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
3418af40:	2301      	movs	r3, #1
3418af42:	e000      	b.n	3418af46 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
3418af44:	2300      	movs	r3, #0
}
3418af46:	4618      	mov	r0, r3
3418af48:	3710      	adds	r7, #16
3418af4a:	46bd      	mov	sp, r7
3418af4c:	bd80      	pop	{r7, pc}
3418af4e:	bf00      	nop
3418af50:	80002000 	.word	0x80002000

3418af54 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
3418af54:	b480      	push	{r7}
3418af56:	b083      	sub	sp, #12
3418af58:	af00      	add	r7, sp, #0
3418af5a:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
3418af5c:	687b      	ldr	r3, [r7, #4]
3418af5e:	681b      	ldr	r3, [r3, #0]
3418af60:	699b      	ldr	r3, [r3, #24]
3418af62:	f003 0302 	and.w	r3, r3, #2
3418af66:	2b02      	cmp	r3, #2
3418af68:	d103      	bne.n	3418af72 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
3418af6a:	687b      	ldr	r3, [r7, #4]
3418af6c:	681b      	ldr	r3, [r3, #0]
3418af6e:	2200      	movs	r2, #0
3418af70:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
3418af72:	687b      	ldr	r3, [r7, #4]
3418af74:	681b      	ldr	r3, [r3, #0]
3418af76:	699b      	ldr	r3, [r3, #24]
3418af78:	f003 0301 	and.w	r3, r3, #1
3418af7c:	2b01      	cmp	r3, #1
3418af7e:	d007      	beq.n	3418af90 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
3418af80:	687b      	ldr	r3, [r7, #4]
3418af82:	681b      	ldr	r3, [r3, #0]
3418af84:	699a      	ldr	r2, [r3, #24]
3418af86:	687b      	ldr	r3, [r7, #4]
3418af88:	681b      	ldr	r3, [r3, #0]
3418af8a:	f042 0201 	orr.w	r2, r2, #1
3418af8e:	619a      	str	r2, [r3, #24]
  }
}
3418af90:	bf00      	nop
3418af92:	370c      	adds	r7, #12
3418af94:	46bd      	mov	sp, r7
3418af96:	f85d 7b04 	ldr.w	r7, [sp], #4
3418af9a:	4770      	bx	lr

3418af9c <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
3418af9c:	b580      	push	{r7, lr}
3418af9e:	b084      	sub	sp, #16
3418afa0:	af00      	add	r7, sp, #0
3418afa2:	60f8      	str	r0, [r7, #12]
3418afa4:	60b9      	str	r1, [r7, #8]
3418afa6:	603b      	str	r3, [r7, #0]
3418afa8:	4613      	mov	r3, r2
3418afaa:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3418afac:	e03b      	b.n	3418b026 <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3418afae:	69ba      	ldr	r2, [r7, #24]
3418afb0:	6839      	ldr	r1, [r7, #0]
3418afb2:	68f8      	ldr	r0, [r7, #12]
3418afb4:	f000 f8d6 	bl	3418b164 <I2C_IsErrorOccurred>
3418afb8:	4603      	mov	r3, r0
3418afba:	2b00      	cmp	r3, #0
3418afbc:	d001      	beq.n	3418afc2 <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
3418afbe:	2301      	movs	r3, #1
3418afc0:	e041      	b.n	3418b046 <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3418afc2:	683b      	ldr	r3, [r7, #0]
3418afc4:	f1b3 3fff 	cmp.w	r3, #4294967295
3418afc8:	d02d      	beq.n	3418b026 <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3418afca:	f7fb faa1 	bl	34186510 <HAL_GetTick>
3418afce:	4602      	mov	r2, r0
3418afd0:	69bb      	ldr	r3, [r7, #24]
3418afd2:	1ad3      	subs	r3, r2, r3
3418afd4:	683a      	ldr	r2, [r7, #0]
3418afd6:	429a      	cmp	r2, r3
3418afd8:	d302      	bcc.n	3418afe0 <I2C_WaitOnFlagUntilTimeout+0x44>
3418afda:	683b      	ldr	r3, [r7, #0]
3418afdc:	2b00      	cmp	r3, #0
3418afde:	d122      	bne.n	3418b026 <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3418afe0:	68fb      	ldr	r3, [r7, #12]
3418afe2:	681b      	ldr	r3, [r3, #0]
3418afe4:	699a      	ldr	r2, [r3, #24]
3418afe6:	68bb      	ldr	r3, [r7, #8]
3418afe8:	4013      	ands	r3, r2
3418afea:	68ba      	ldr	r2, [r7, #8]
3418afec:	429a      	cmp	r2, r3
3418afee:	bf0c      	ite	eq
3418aff0:	2301      	moveq	r3, #1
3418aff2:	2300      	movne	r3, #0
3418aff4:	b2db      	uxtb	r3, r3
3418aff6:	461a      	mov	r2, r3
3418aff8:	79fb      	ldrb	r3, [r7, #7]
3418affa:	429a      	cmp	r2, r3
3418affc:	d113      	bne.n	3418b026 <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3418affe:	68fb      	ldr	r3, [r7, #12]
3418b000:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b002:	f043 0220 	orr.w	r2, r3, #32
3418b006:	68fb      	ldr	r3, [r7, #12]
3418b008:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3418b00a:	68fb      	ldr	r3, [r7, #12]
3418b00c:	2220      	movs	r2, #32
3418b00e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
3418b012:	68fb      	ldr	r3, [r7, #12]
3418b014:	2200      	movs	r2, #0
3418b016:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3418b01a:	68fb      	ldr	r3, [r7, #12]
3418b01c:	2200      	movs	r2, #0
3418b01e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
3418b022:	2301      	movs	r3, #1
3418b024:	e00f      	b.n	3418b046 <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3418b026:	68fb      	ldr	r3, [r7, #12]
3418b028:	681b      	ldr	r3, [r3, #0]
3418b02a:	699a      	ldr	r2, [r3, #24]
3418b02c:	68bb      	ldr	r3, [r7, #8]
3418b02e:	4013      	ands	r3, r2
3418b030:	68ba      	ldr	r2, [r7, #8]
3418b032:	429a      	cmp	r2, r3
3418b034:	bf0c      	ite	eq
3418b036:	2301      	moveq	r3, #1
3418b038:	2300      	movne	r3, #0
3418b03a:	b2db      	uxtb	r3, r3
3418b03c:	461a      	mov	r2, r3
3418b03e:	79fb      	ldrb	r3, [r7, #7]
3418b040:	429a      	cmp	r2, r3
3418b042:	d0b4      	beq.n	3418afae <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
3418b044:	2300      	movs	r3, #0
}
3418b046:	4618      	mov	r0, r3
3418b048:	3710      	adds	r7, #16
3418b04a:	46bd      	mov	sp, r7
3418b04c:	bd80      	pop	{r7, pc}

3418b04e <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3418b04e:	b580      	push	{r7, lr}
3418b050:	b084      	sub	sp, #16
3418b052:	af00      	add	r7, sp, #0
3418b054:	60f8      	str	r0, [r7, #12]
3418b056:	60b9      	str	r1, [r7, #8]
3418b058:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3418b05a:	e033      	b.n	3418b0c4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3418b05c:	687a      	ldr	r2, [r7, #4]
3418b05e:	68b9      	ldr	r1, [r7, #8]
3418b060:	68f8      	ldr	r0, [r7, #12]
3418b062:	f000 f87f 	bl	3418b164 <I2C_IsErrorOccurred>
3418b066:	4603      	mov	r3, r0
3418b068:	2b00      	cmp	r3, #0
3418b06a:	d001      	beq.n	3418b070 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
3418b06c:	2301      	movs	r3, #1
3418b06e:	e031      	b.n	3418b0d4 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3418b070:	68bb      	ldr	r3, [r7, #8]
3418b072:	f1b3 3fff 	cmp.w	r3, #4294967295
3418b076:	d025      	beq.n	3418b0c4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3418b078:	f7fb fa4a 	bl	34186510 <HAL_GetTick>
3418b07c:	4602      	mov	r2, r0
3418b07e:	687b      	ldr	r3, [r7, #4]
3418b080:	1ad3      	subs	r3, r2, r3
3418b082:	68ba      	ldr	r2, [r7, #8]
3418b084:	429a      	cmp	r2, r3
3418b086:	d302      	bcc.n	3418b08e <I2C_WaitOnTXISFlagUntilTimeout+0x40>
3418b088:	68bb      	ldr	r3, [r7, #8]
3418b08a:	2b00      	cmp	r3, #0
3418b08c:	d11a      	bne.n	3418b0c4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3418b08e:	68fb      	ldr	r3, [r7, #12]
3418b090:	681b      	ldr	r3, [r3, #0]
3418b092:	699b      	ldr	r3, [r3, #24]
3418b094:	f003 0302 	and.w	r3, r3, #2
3418b098:	2b02      	cmp	r3, #2
3418b09a:	d013      	beq.n	3418b0c4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3418b09c:	68fb      	ldr	r3, [r7, #12]
3418b09e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b0a0:	f043 0220 	orr.w	r2, r3, #32
3418b0a4:	68fb      	ldr	r3, [r7, #12]
3418b0a6:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3418b0a8:	68fb      	ldr	r3, [r7, #12]
3418b0aa:	2220      	movs	r2, #32
3418b0ac:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
3418b0b0:	68fb      	ldr	r3, [r7, #12]
3418b0b2:	2200      	movs	r2, #0
3418b0b4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3418b0b8:	68fb      	ldr	r3, [r7, #12]
3418b0ba:	2200      	movs	r2, #0
3418b0bc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
3418b0c0:	2301      	movs	r3, #1
3418b0c2:	e007      	b.n	3418b0d4 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3418b0c4:	68fb      	ldr	r3, [r7, #12]
3418b0c6:	681b      	ldr	r3, [r3, #0]
3418b0c8:	699b      	ldr	r3, [r3, #24]
3418b0ca:	f003 0302 	and.w	r3, r3, #2
3418b0ce:	2b02      	cmp	r3, #2
3418b0d0:	d1c4      	bne.n	3418b05c <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
3418b0d2:	2300      	movs	r3, #0
}
3418b0d4:	4618      	mov	r0, r3
3418b0d6:	3710      	adds	r7, #16
3418b0d8:	46bd      	mov	sp, r7
3418b0da:	bd80      	pop	{r7, pc}

3418b0dc <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3418b0dc:	b580      	push	{r7, lr}
3418b0de:	b084      	sub	sp, #16
3418b0e0:	af00      	add	r7, sp, #0
3418b0e2:	60f8      	str	r0, [r7, #12]
3418b0e4:	60b9      	str	r1, [r7, #8]
3418b0e6:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418b0e8:	e02f      	b.n	3418b14a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3418b0ea:	687a      	ldr	r2, [r7, #4]
3418b0ec:	68b9      	ldr	r1, [r7, #8]
3418b0ee:	68f8      	ldr	r0, [r7, #12]
3418b0f0:	f000 f838 	bl	3418b164 <I2C_IsErrorOccurred>
3418b0f4:	4603      	mov	r3, r0
3418b0f6:	2b00      	cmp	r3, #0
3418b0f8:	d001      	beq.n	3418b0fe <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
3418b0fa:	2301      	movs	r3, #1
3418b0fc:	e02d      	b.n	3418b15a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3418b0fe:	f7fb fa07 	bl	34186510 <HAL_GetTick>
3418b102:	4602      	mov	r2, r0
3418b104:	687b      	ldr	r3, [r7, #4]
3418b106:	1ad3      	subs	r3, r2, r3
3418b108:	68ba      	ldr	r2, [r7, #8]
3418b10a:	429a      	cmp	r2, r3
3418b10c:	d302      	bcc.n	3418b114 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
3418b10e:	68bb      	ldr	r3, [r7, #8]
3418b110:	2b00      	cmp	r3, #0
3418b112:	d11a      	bne.n	3418b14a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418b114:	68fb      	ldr	r3, [r7, #12]
3418b116:	681b      	ldr	r3, [r3, #0]
3418b118:	699b      	ldr	r3, [r3, #24]
3418b11a:	f003 0320 	and.w	r3, r3, #32
3418b11e:	2b20      	cmp	r3, #32
3418b120:	d013      	beq.n	3418b14a <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3418b122:	68fb      	ldr	r3, [r7, #12]
3418b124:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418b126:	f043 0220 	orr.w	r2, r3, #32
3418b12a:	68fb      	ldr	r3, [r7, #12]
3418b12c:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
3418b12e:	68fb      	ldr	r3, [r7, #12]
3418b130:	2220      	movs	r2, #32
3418b132:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
3418b136:	68fb      	ldr	r3, [r7, #12]
3418b138:	2200      	movs	r2, #0
3418b13a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
3418b13e:	68fb      	ldr	r3, [r7, #12]
3418b140:	2200      	movs	r2, #0
3418b142:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
3418b146:	2301      	movs	r3, #1
3418b148:	e007      	b.n	3418b15a <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418b14a:	68fb      	ldr	r3, [r7, #12]
3418b14c:	681b      	ldr	r3, [r3, #0]
3418b14e:	699b      	ldr	r3, [r3, #24]
3418b150:	f003 0320 	and.w	r3, r3, #32
3418b154:	2b20      	cmp	r3, #32
3418b156:	d1c8      	bne.n	3418b0ea <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
3418b158:	2300      	movs	r3, #0
}
3418b15a:	4618      	mov	r0, r3
3418b15c:	3710      	adds	r7, #16
3418b15e:	46bd      	mov	sp, r7
3418b160:	bd80      	pop	{r7, pc}
	...

3418b164 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
3418b164:	b580      	push	{r7, lr}
3418b166:	b08a      	sub	sp, #40	@ 0x28
3418b168:	af00      	add	r7, sp, #0
3418b16a:	60f8      	str	r0, [r7, #12]
3418b16c:	60b9      	str	r1, [r7, #8]
3418b16e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3418b170:	2300      	movs	r3, #0
3418b172:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
3418b176:	68fb      	ldr	r3, [r7, #12]
3418b178:	681b      	ldr	r3, [r3, #0]
3418b17a:	699b      	ldr	r3, [r3, #24]
3418b17c:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
3418b17e:	2300      	movs	r3, #0
3418b180:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
3418b182:	687b      	ldr	r3, [r7, #4]
3418b184:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
3418b186:	69bb      	ldr	r3, [r7, #24]
3418b188:	f003 0310 	and.w	r3, r3, #16
3418b18c:	2b00      	cmp	r3, #0
3418b18e:	d068      	beq.n	3418b262 <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3418b190:	68fb      	ldr	r3, [r7, #12]
3418b192:	681b      	ldr	r3, [r3, #0]
3418b194:	2210      	movs	r2, #16
3418b196:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
3418b198:	e049      	b.n	3418b22e <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
3418b19a:	68bb      	ldr	r3, [r7, #8]
3418b19c:	f1b3 3fff 	cmp.w	r3, #4294967295
3418b1a0:	d045      	beq.n	3418b22e <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3418b1a2:	f7fb f9b5 	bl	34186510 <HAL_GetTick>
3418b1a6:	4602      	mov	r2, r0
3418b1a8:	69fb      	ldr	r3, [r7, #28]
3418b1aa:	1ad3      	subs	r3, r2, r3
3418b1ac:	68ba      	ldr	r2, [r7, #8]
3418b1ae:	429a      	cmp	r2, r3
3418b1b0:	d302      	bcc.n	3418b1b8 <I2C_IsErrorOccurred+0x54>
3418b1b2:	68bb      	ldr	r3, [r7, #8]
3418b1b4:	2b00      	cmp	r3, #0
3418b1b6:	d13a      	bne.n	3418b22e <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
3418b1b8:	68fb      	ldr	r3, [r7, #12]
3418b1ba:	681b      	ldr	r3, [r3, #0]
3418b1bc:	685b      	ldr	r3, [r3, #4]
3418b1be:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418b1c2:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
3418b1c4:	68fb      	ldr	r3, [r7, #12]
3418b1c6:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
3418b1ca:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
3418b1cc:	68fb      	ldr	r3, [r7, #12]
3418b1ce:	681b      	ldr	r3, [r3, #0]
3418b1d0:	699b      	ldr	r3, [r3, #24]
3418b1d2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3418b1d6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3418b1da:	d121      	bne.n	3418b220 <I2C_IsErrorOccurred+0xbc>
3418b1dc:	697b      	ldr	r3, [r7, #20]
3418b1de:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3418b1e2:	d01d      	beq.n	3418b220 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
3418b1e4:	7cfb      	ldrb	r3, [r7, #19]
3418b1e6:	2b20      	cmp	r3, #32
3418b1e8:	d01a      	beq.n	3418b220 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
3418b1ea:	68fb      	ldr	r3, [r7, #12]
3418b1ec:	681b      	ldr	r3, [r3, #0]
3418b1ee:	685a      	ldr	r2, [r3, #4]
3418b1f0:	68fb      	ldr	r3, [r7, #12]
3418b1f2:	681b      	ldr	r3, [r3, #0]
3418b1f4:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
3418b1f8:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
3418b1fa:	f7fb f989 	bl	34186510 <HAL_GetTick>
3418b1fe:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418b200:	e00e      	b.n	3418b220 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
3418b202:	f7fb f985 	bl	34186510 <HAL_GetTick>
3418b206:	4602      	mov	r2, r0
3418b208:	69fb      	ldr	r3, [r7, #28]
3418b20a:	1ad3      	subs	r3, r2, r3
3418b20c:	2b19      	cmp	r3, #25
3418b20e:	d907      	bls.n	3418b220 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
3418b210:	6a3b      	ldr	r3, [r7, #32]
3418b212:	f043 0320 	orr.w	r3, r3, #32
3418b216:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
3418b218:	2301      	movs	r3, #1
3418b21a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
3418b21e:	e006      	b.n	3418b22e <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3418b220:	68fb      	ldr	r3, [r7, #12]
3418b222:	681b      	ldr	r3, [r3, #0]
3418b224:	699b      	ldr	r3, [r3, #24]
3418b226:	f003 0320 	and.w	r3, r3, #32
3418b22a:	2b20      	cmp	r3, #32
3418b22c:	d1e9      	bne.n	3418b202 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
3418b22e:	68fb      	ldr	r3, [r7, #12]
3418b230:	681b      	ldr	r3, [r3, #0]
3418b232:	699b      	ldr	r3, [r3, #24]
3418b234:	f003 0320 	and.w	r3, r3, #32
3418b238:	2b20      	cmp	r3, #32
3418b23a:	d003      	beq.n	3418b244 <I2C_IsErrorOccurred+0xe0>
3418b23c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3418b240:	2b00      	cmp	r3, #0
3418b242:	d0aa      	beq.n	3418b19a <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
3418b244:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3418b248:	2b00      	cmp	r3, #0
3418b24a:	d103      	bne.n	3418b254 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3418b24c:	68fb      	ldr	r3, [r7, #12]
3418b24e:	681b      	ldr	r3, [r3, #0]
3418b250:	2220      	movs	r2, #32
3418b252:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
3418b254:	6a3b      	ldr	r3, [r7, #32]
3418b256:	f043 0304 	orr.w	r3, r3, #4
3418b25a:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
3418b25c:	2301      	movs	r3, #1
3418b25e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
3418b262:	68fb      	ldr	r3, [r7, #12]
3418b264:	681b      	ldr	r3, [r3, #0]
3418b266:	699b      	ldr	r3, [r3, #24]
3418b268:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
3418b26a:	69bb      	ldr	r3, [r7, #24]
3418b26c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418b270:	2b00      	cmp	r3, #0
3418b272:	d00b      	beq.n	3418b28c <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
3418b274:	6a3b      	ldr	r3, [r7, #32]
3418b276:	f043 0301 	orr.w	r3, r3, #1
3418b27a:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
3418b27c:	68fb      	ldr	r3, [r7, #12]
3418b27e:	681b      	ldr	r3, [r3, #0]
3418b280:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418b284:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3418b286:	2301      	movs	r3, #1
3418b288:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
3418b28c:	69bb      	ldr	r3, [r7, #24]
3418b28e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418b292:	2b00      	cmp	r3, #0
3418b294:	d00b      	beq.n	3418b2ae <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
3418b296:	6a3b      	ldr	r3, [r7, #32]
3418b298:	f043 0308 	orr.w	r3, r3, #8
3418b29c:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
3418b29e:	68fb      	ldr	r3, [r7, #12]
3418b2a0:	681b      	ldr	r3, [r3, #0]
3418b2a2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3418b2a6:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3418b2a8:	2301      	movs	r3, #1
3418b2aa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
3418b2ae:	69bb      	ldr	r3, [r7, #24]
3418b2b0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418b2b4:	2b00      	cmp	r3, #0
3418b2b6:	d00b      	beq.n	3418b2d0 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
3418b2b8:	6a3b      	ldr	r3, [r7, #32]
3418b2ba:	f043 0302 	orr.w	r3, r3, #2
3418b2be:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
3418b2c0:	68fb      	ldr	r3, [r7, #12]
3418b2c2:	681b      	ldr	r3, [r3, #0]
3418b2c4:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418b2c8:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3418b2ca:	2301      	movs	r3, #1
3418b2cc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
3418b2d0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3418b2d4:	2b00      	cmp	r3, #0
3418b2d6:	d01c      	beq.n	3418b312 <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
3418b2d8:	68f8      	ldr	r0, [r7, #12]
3418b2da:	f7ff fe3b 	bl	3418af54 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3418b2de:	68fb      	ldr	r3, [r7, #12]
3418b2e0:	681b      	ldr	r3, [r3, #0]
3418b2e2:	6859      	ldr	r1, [r3, #4]
3418b2e4:	68fb      	ldr	r3, [r7, #12]
3418b2e6:	681a      	ldr	r2, [r3, #0]
3418b2e8:	4b0d      	ldr	r3, [pc, #52]	@ (3418b320 <I2C_IsErrorOccurred+0x1bc>)
3418b2ea:	400b      	ands	r3, r1
3418b2ec:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
3418b2ee:	68fb      	ldr	r3, [r7, #12]
3418b2f0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3418b2f2:	6a3b      	ldr	r3, [r7, #32]
3418b2f4:	431a      	orrs	r2, r3
3418b2f6:	68fb      	ldr	r3, [r7, #12]
3418b2f8:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
3418b2fa:	68fb      	ldr	r3, [r7, #12]
3418b2fc:	2220      	movs	r2, #32
3418b2fe:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
3418b302:	68fb      	ldr	r3, [r7, #12]
3418b304:	2200      	movs	r2, #0
3418b306:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418b30a:	68fb      	ldr	r3, [r7, #12]
3418b30c:	2200      	movs	r2, #0
3418b30e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
3418b312:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3418b316:	4618      	mov	r0, r3
3418b318:	3728      	adds	r7, #40	@ 0x28
3418b31a:	46bd      	mov	sp, r7
3418b31c:	bd80      	pop	{r7, pc}
3418b31e:	bf00      	nop
3418b320:	fe00e800 	.word	0xfe00e800

3418b324 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
3418b324:	b480      	push	{r7}
3418b326:	b087      	sub	sp, #28
3418b328:	af00      	add	r7, sp, #0
3418b32a:	60f8      	str	r0, [r7, #12]
3418b32c:	607b      	str	r3, [r7, #4]
3418b32e:	460b      	mov	r3, r1
3418b330:	817b      	strh	r3, [r7, #10]
3418b332:	4613      	mov	r3, r2
3418b334:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418b336:	897b      	ldrh	r3, [r7, #10]
3418b338:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3418b33c:	7a7b      	ldrb	r3, [r7, #9]
3418b33e:	041b      	lsls	r3, r3, #16
3418b340:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418b344:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3418b346:	687b      	ldr	r3, [r7, #4]
3418b348:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3418b34a:	6a3b      	ldr	r3, [r7, #32]
3418b34c:	4313      	orrs	r3, r2
3418b34e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3418b352:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
3418b354:	68fb      	ldr	r3, [r7, #12]
3418b356:	681b      	ldr	r3, [r3, #0]
3418b358:	685a      	ldr	r2, [r3, #4]
3418b35a:	6a3b      	ldr	r3, [r7, #32]
3418b35c:	0d5b      	lsrs	r3, r3, #21
3418b35e:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
3418b362:	4b08      	ldr	r3, [pc, #32]	@ (3418b384 <I2C_TransferConfig+0x60>)
3418b364:	430b      	orrs	r3, r1
3418b366:	43db      	mvns	r3, r3
3418b368:	ea02 0103 	and.w	r1, r2, r3
3418b36c:	68fb      	ldr	r3, [r7, #12]
3418b36e:	681b      	ldr	r3, [r3, #0]
3418b370:	697a      	ldr	r2, [r7, #20]
3418b372:	430a      	orrs	r2, r1
3418b374:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
3418b376:	bf00      	nop
3418b378:	371c      	adds	r7, #28
3418b37a:	46bd      	mov	sp, r7
3418b37c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b380:	4770      	bx	lr
3418b382:	bf00      	nop
3418b384:	03ff63ff 	.word	0x03ff63ff

3418b388 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
3418b388:	b480      	push	{r7}
3418b38a:	b083      	sub	sp, #12
3418b38c:	af00      	add	r7, sp, #0
3418b38e:	6078      	str	r0, [r7, #4]
3418b390:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
3418b392:	687b      	ldr	r3, [r7, #4]
3418b394:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418b398:	b2db      	uxtb	r3, r3
3418b39a:	2b20      	cmp	r3, #32
3418b39c:	d138      	bne.n	3418b410 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3418b39e:	687b      	ldr	r3, [r7, #4]
3418b3a0:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418b3a4:	2b01      	cmp	r3, #1
3418b3a6:	d101      	bne.n	3418b3ac <HAL_I2CEx_ConfigAnalogFilter+0x24>
3418b3a8:	2302      	movs	r3, #2
3418b3aa:	e032      	b.n	3418b412 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
3418b3ac:	687b      	ldr	r3, [r7, #4]
3418b3ae:	2201      	movs	r2, #1
3418b3b0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
3418b3b4:	687b      	ldr	r3, [r7, #4]
3418b3b6:	2224      	movs	r2, #36	@ 0x24
3418b3b8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3418b3bc:	687b      	ldr	r3, [r7, #4]
3418b3be:	681b      	ldr	r3, [r3, #0]
3418b3c0:	681a      	ldr	r2, [r3, #0]
3418b3c2:	687b      	ldr	r3, [r7, #4]
3418b3c4:	681b      	ldr	r3, [r3, #0]
3418b3c6:	f022 0201 	bic.w	r2, r2, #1
3418b3ca:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
3418b3cc:	687b      	ldr	r3, [r7, #4]
3418b3ce:	681b      	ldr	r3, [r3, #0]
3418b3d0:	681a      	ldr	r2, [r3, #0]
3418b3d2:	687b      	ldr	r3, [r7, #4]
3418b3d4:	681b      	ldr	r3, [r3, #0]
3418b3d6:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
3418b3da:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
3418b3dc:	687b      	ldr	r3, [r7, #4]
3418b3de:	681b      	ldr	r3, [r3, #0]
3418b3e0:	6819      	ldr	r1, [r3, #0]
3418b3e2:	687b      	ldr	r3, [r7, #4]
3418b3e4:	681b      	ldr	r3, [r3, #0]
3418b3e6:	683a      	ldr	r2, [r7, #0]
3418b3e8:	430a      	orrs	r2, r1
3418b3ea:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
3418b3ec:	687b      	ldr	r3, [r7, #4]
3418b3ee:	681b      	ldr	r3, [r3, #0]
3418b3f0:	681a      	ldr	r2, [r3, #0]
3418b3f2:	687b      	ldr	r3, [r7, #4]
3418b3f4:	681b      	ldr	r3, [r3, #0]
3418b3f6:	f042 0201 	orr.w	r2, r2, #1
3418b3fa:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
3418b3fc:	687b      	ldr	r3, [r7, #4]
3418b3fe:	2220      	movs	r2, #32
3418b400:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418b404:	687b      	ldr	r3, [r7, #4]
3418b406:	2200      	movs	r2, #0
3418b408:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418b40c:	2300      	movs	r3, #0
3418b40e:	e000      	b.n	3418b412 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
3418b410:	2302      	movs	r3, #2
  }
}
3418b412:	4618      	mov	r0, r3
3418b414:	370c      	adds	r7, #12
3418b416:	46bd      	mov	sp, r7
3418b418:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b41c:	4770      	bx	lr

3418b41e <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
3418b41e:	b480      	push	{r7}
3418b420:	b085      	sub	sp, #20
3418b422:	af00      	add	r7, sp, #0
3418b424:	6078      	str	r0, [r7, #4]
3418b426:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
3418b428:	687b      	ldr	r3, [r7, #4]
3418b42a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3418b42e:	b2db      	uxtb	r3, r3
3418b430:	2b20      	cmp	r3, #32
3418b432:	d139      	bne.n	3418b4a8 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3418b434:	687b      	ldr	r3, [r7, #4]
3418b436:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3418b43a:	2b01      	cmp	r3, #1
3418b43c:	d101      	bne.n	3418b442 <HAL_I2CEx_ConfigDigitalFilter+0x24>
3418b43e:	2302      	movs	r3, #2
3418b440:	e033      	b.n	3418b4aa <HAL_I2CEx_ConfigDigitalFilter+0x8c>
3418b442:	687b      	ldr	r3, [r7, #4]
3418b444:	2201      	movs	r2, #1
3418b446:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
3418b44a:	687b      	ldr	r3, [r7, #4]
3418b44c:	2224      	movs	r2, #36	@ 0x24
3418b44e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3418b452:	687b      	ldr	r3, [r7, #4]
3418b454:	681b      	ldr	r3, [r3, #0]
3418b456:	681a      	ldr	r2, [r3, #0]
3418b458:	687b      	ldr	r3, [r7, #4]
3418b45a:	681b      	ldr	r3, [r3, #0]
3418b45c:	f022 0201 	bic.w	r2, r2, #1
3418b460:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
3418b462:	687b      	ldr	r3, [r7, #4]
3418b464:	681b      	ldr	r3, [r3, #0]
3418b466:	681b      	ldr	r3, [r3, #0]
3418b468:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
3418b46a:	68fb      	ldr	r3, [r7, #12]
3418b46c:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
3418b470:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
3418b472:	683b      	ldr	r3, [r7, #0]
3418b474:	021b      	lsls	r3, r3, #8
3418b476:	68fa      	ldr	r2, [r7, #12]
3418b478:	4313      	orrs	r3, r2
3418b47a:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
3418b47c:	687b      	ldr	r3, [r7, #4]
3418b47e:	681b      	ldr	r3, [r3, #0]
3418b480:	68fa      	ldr	r2, [r7, #12]
3418b482:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
3418b484:	687b      	ldr	r3, [r7, #4]
3418b486:	681b      	ldr	r3, [r3, #0]
3418b488:	681a      	ldr	r2, [r3, #0]
3418b48a:	687b      	ldr	r3, [r7, #4]
3418b48c:	681b      	ldr	r3, [r3, #0]
3418b48e:	f042 0201 	orr.w	r2, r2, #1
3418b492:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
3418b494:	687b      	ldr	r3, [r7, #4]
3418b496:	2220      	movs	r2, #32
3418b498:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3418b49c:	687b      	ldr	r3, [r7, #4]
3418b49e:	2200      	movs	r2, #0
3418b4a0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3418b4a4:	2300      	movs	r3, #0
3418b4a6:	e000      	b.n	3418b4aa <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
3418b4a8:	2302      	movs	r3, #2
  }
}
3418b4aa:	4618      	mov	r0, r3
3418b4ac:	3714      	adds	r7, #20
3418b4ae:	46bd      	mov	sp, r7
3418b4b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418b4b4:	4770      	bx	lr

3418b4b6 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
3418b4b6:	b580      	push	{r7, lr}
3418b4b8:	b084      	sub	sp, #16
3418b4ba:	af00      	add	r7, sp, #0
3418b4bc:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
3418b4be:	687b      	ldr	r3, [r7, #4]
3418b4c0:	2b00      	cmp	r3, #0
3418b4c2:	d101      	bne.n	3418b4c8 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
3418b4c4:	2301      	movs	r3, #1
3418b4c6:	e09d      	b.n	3418b604 <HAL_LTDC_Init+0x14e>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
3418b4c8:	687b      	ldr	r3, [r7, #4]
3418b4ca:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
3418b4ce:	b2db      	uxtb	r3, r3
3418b4d0:	2b00      	cmp	r3, #0
3418b4d2:	d106      	bne.n	3418b4e2 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
3418b4d4:	687b      	ldr	r3, [r7, #4]
3418b4d6:	2200      	movs	r2, #0
3418b4d8:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
3418b4dc:	6878      	ldr	r0, [r7, #4]
3418b4de:	f7f7 f8c9 	bl	34182674 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3418b4e2:	687b      	ldr	r3, [r7, #4]
3418b4e4:	2202      	movs	r2, #2
3418b4e6:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
3418b4ea:	687b      	ldr	r3, [r7, #4]
3418b4ec:	681b      	ldr	r3, [r3, #0]
3418b4ee:	699a      	ldr	r2, [r3, #24]
3418b4f0:	687b      	ldr	r3, [r7, #4]
3418b4f2:	681b      	ldr	r3, [r3, #0]
3418b4f4:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
3418b4f8:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3418b4fa:	687b      	ldr	r3, [r7, #4]
3418b4fc:	681b      	ldr	r3, [r3, #0]
3418b4fe:	6999      	ldr	r1, [r3, #24]
3418b500:	687b      	ldr	r3, [r7, #4]
3418b502:	685a      	ldr	r2, [r3, #4]
3418b504:	687b      	ldr	r3, [r7, #4]
3418b506:	689b      	ldr	r3, [r3, #8]
3418b508:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
3418b50a:	687b      	ldr	r3, [r7, #4]
3418b50c:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3418b50e:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
3418b510:	687b      	ldr	r3, [r7, #4]
3418b512:	691b      	ldr	r3, [r3, #16]
3418b514:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3418b516:	687b      	ldr	r3, [r7, #4]
3418b518:	681b      	ldr	r3, [r3, #0]
3418b51a:	430a      	orrs	r2, r1
3418b51c:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
3418b51e:	687b      	ldr	r3, [r7, #4]
3418b520:	695b      	ldr	r3, [r3, #20]
3418b522:	041b      	lsls	r3, r3, #16
3418b524:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
3418b526:	687b      	ldr	r3, [r7, #4]
3418b528:	6999      	ldr	r1, [r3, #24]
3418b52a:	687b      	ldr	r3, [r7, #4]
3418b52c:	681b      	ldr	r3, [r3, #0]
3418b52e:	68fa      	ldr	r2, [r7, #12]
3418b530:	430a      	orrs	r2, r1
3418b532:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
3418b534:	687b      	ldr	r3, [r7, #4]
3418b536:	69db      	ldr	r3, [r3, #28]
3418b538:	041b      	lsls	r3, r3, #16
3418b53a:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
3418b53c:	687b      	ldr	r3, [r7, #4]
3418b53e:	6a19      	ldr	r1, [r3, #32]
3418b540:	687b      	ldr	r3, [r7, #4]
3418b542:	681b      	ldr	r3, [r3, #0]
3418b544:	68fa      	ldr	r2, [r7, #12]
3418b546:	430a      	orrs	r2, r1
3418b548:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
3418b54a:	687b      	ldr	r3, [r7, #4]
3418b54c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418b54e:	041b      	lsls	r3, r3, #16
3418b550:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
3418b552:	687b      	ldr	r3, [r7, #4]
3418b554:	6a99      	ldr	r1, [r3, #40]	@ 0x28
3418b556:	687b      	ldr	r3, [r7, #4]
3418b558:	681b      	ldr	r3, [r3, #0]
3418b55a:	68fa      	ldr	r2, [r7, #12]
3418b55c:	430a      	orrs	r2, r1
3418b55e:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
3418b560:	687b      	ldr	r3, [r7, #4]
3418b562:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418b564:	041b      	lsls	r3, r3, #16
3418b566:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
3418b568:	687b      	ldr	r3, [r7, #4]
3418b56a:	6b19      	ldr	r1, [r3, #48]	@ 0x30
3418b56c:	687b      	ldr	r3, [r7, #4]
3418b56e:	681b      	ldr	r3, [r3, #0]
3418b570:	68fa      	ldr	r2, [r7, #12]
3418b572:	430a      	orrs	r2, r1
3418b574:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
3418b576:	687b      	ldr	r3, [r7, #4]
3418b578:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
3418b57c:	021b      	lsls	r3, r3, #8
3418b57e:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
3418b580:	687b      	ldr	r3, [r7, #4]
3418b582:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3418b586:	041b      	lsls	r3, r3, #16
3418b588:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
3418b58a:	687b      	ldr	r3, [r7, #4]
3418b58c:	681b      	ldr	r3, [r3, #0]
3418b58e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3418b590:	687b      	ldr	r3, [r7, #4]
3418b592:	681b      	ldr	r3, [r3, #0]
3418b594:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
3418b598:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
3418b59a:	687b      	ldr	r3, [r7, #4]
3418b59c:	681b      	ldr	r3, [r3, #0]
3418b59e:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
3418b5a0:	68ba      	ldr	r2, [r7, #8]
3418b5a2:	68fb      	ldr	r3, [r7, #12]
3418b5a4:	4313      	orrs	r3, r2
3418b5a6:	687a      	ldr	r2, [r7, #4]
3418b5a8:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
3418b5ac:	431a      	orrs	r2, r3
3418b5ae:	687b      	ldr	r3, [r7, #4]
3418b5b0:	681b      	ldr	r3, [r3, #0]
3418b5b2:	430a      	orrs	r2, r1
3418b5b4:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
3418b5b6:	687b      	ldr	r3, [r7, #4]
3418b5b8:	681b      	ldr	r3, [r3, #0]
3418b5ba:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b5be:	461a      	mov	r2, r3
3418b5c0:	2304      	movs	r3, #4
3418b5c2:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
3418b5c4:	687b      	ldr	r3, [r7, #4]
3418b5c6:	681b      	ldr	r3, [r3, #0]
3418b5c8:	f503 7300 	add.w	r3, r3, #512	@ 0x200
3418b5cc:	461a      	mov	r2, r3
3418b5ce:	2304      	movs	r3, #4
3418b5d0:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
3418b5d2:	687b      	ldr	r3, [r7, #4]
3418b5d4:	681b      	ldr	r3, [r3, #0]
3418b5d6:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
3418b5d8:	687b      	ldr	r3, [r7, #4]
3418b5da:	681b      	ldr	r3, [r3, #0]
3418b5dc:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
3418b5e0:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
3418b5e2:	687b      	ldr	r3, [r7, #4]
3418b5e4:	681b      	ldr	r3, [r3, #0]
3418b5e6:	699a      	ldr	r2, [r3, #24]
3418b5e8:	687b      	ldr	r3, [r7, #4]
3418b5ea:	681b      	ldr	r3, [r3, #0]
3418b5ec:	f042 0201 	orr.w	r2, r2, #1
3418b5f0:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
3418b5f2:	687b      	ldr	r3, [r7, #4]
3418b5f4:	2200      	movs	r2, #0
3418b5f6:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
3418b5fa:	687b      	ldr	r3, [r7, #4]
3418b5fc:	2201      	movs	r2, #1
3418b5fe:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
3418b602:	2300      	movs	r3, #0
}
3418b604:	4618      	mov	r0, r3
3418b606:	3710      	adds	r7, #16
3418b608:	46bd      	mov	sp, r7
3418b60a:	bd80      	pop	{r7, pc}

3418b60c <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
3418b60c:	b5b0      	push	{r4, r5, r7, lr}
3418b60e:	b086      	sub	sp, #24
3418b610:	af02      	add	r7, sp, #8
3418b612:	60f8      	str	r0, [r7, #12]
3418b614:	60b9      	str	r1, [r7, #8]
3418b616:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
3418b618:	68fb      	ldr	r3, [r7, #12]
3418b61a:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
3418b61e:	2b01      	cmp	r3, #1
3418b620:	d101      	bne.n	3418b626 <HAL_LTDC_ConfigLayer+0x1a>
3418b622:	2302      	movs	r3, #2
3418b624:	e052      	b.n	3418b6cc <HAL_LTDC_ConfigLayer+0xc0>
3418b626:	68fb      	ldr	r3, [r7, #12]
3418b628:	2201      	movs	r2, #1
3418b62a:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3418b62e:	68fb      	ldr	r3, [r7, #12]
3418b630:	2202      	movs	r2, #2
3418b632:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
3418b636:	68fa      	ldr	r2, [r7, #12]
3418b638:	687b      	ldr	r3, [r7, #4]
3418b63a:	2134      	movs	r1, #52	@ 0x34
3418b63c:	fb01 f303 	mul.w	r3, r1, r3
3418b640:	4413      	add	r3, r2
3418b642:	f103 0238 	add.w	r2, r3, #56	@ 0x38
3418b646:	68bb      	ldr	r3, [r7, #8]
3418b648:	4614      	mov	r4, r2
3418b64a:	461d      	mov	r5, r3
3418b64c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3418b64e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3418b650:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3418b652:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3418b654:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3418b656:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3418b658:	682b      	ldr	r3, [r5, #0]
3418b65a:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
3418b65c:	6879      	ldr	r1, [r7, #4]
3418b65e:	68f8      	ldr	r0, [r7, #12]
3418b660:	f000 ff6e 	bl	3418c540 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
3418b664:	6879      	ldr	r1, [r7, #4]
3418b666:	68f8      	ldr	r0, [r7, #12]
3418b668:	f000 fec0 	bl	3418c3ec <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
3418b66c:	68fb      	ldr	r3, [r7, #12]
3418b66e:	681b      	ldr	r3, [r3, #0]
3418b670:	461a      	mov	r2, r3
3418b672:	687b      	ldr	r3, [r7, #4]
3418b674:	021b      	lsls	r3, r3, #8
3418b676:	4413      	add	r3, r2
3418b678:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b67c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3418b67e:	68fa      	ldr	r2, [r7, #12]
3418b680:	6812      	ldr	r2, [r2, #0]
3418b682:	4611      	mov	r1, r2
3418b684:	687a      	ldr	r2, [r7, #4]
3418b686:	0212      	lsls	r2, r2, #8
3418b688:	440a      	add	r2, r1
3418b68a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418b68e:	f023 0308 	bic.w	r3, r3, #8
3418b692:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
3418b694:	687b      	ldr	r3, [r7, #4]
3418b696:	9300      	str	r3, [sp, #0]
3418b698:	2303      	movs	r3, #3
3418b69a:	2200      	movs	r2, #0
3418b69c:	2100      	movs	r1, #0
3418b69e:	68f8      	ldr	r0, [r7, #12]
3418b6a0:	f000 f818 	bl	3418b6d4 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
3418b6a4:	68fb      	ldr	r3, [r7, #12]
3418b6a6:	681b      	ldr	r3, [r3, #0]
3418b6a8:	461a      	mov	r2, r3
3418b6aa:	687b      	ldr	r3, [r7, #4]
3418b6ac:	021b      	lsls	r3, r3, #8
3418b6ae:	4413      	add	r3, r2
3418b6b0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b6b4:	461a      	mov	r2, r3
3418b6b6:	2305      	movs	r3, #5
3418b6b8:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
3418b6ba:	68fb      	ldr	r3, [r7, #12]
3418b6bc:	2201      	movs	r2, #1
3418b6be:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
3418b6c2:	68fb      	ldr	r3, [r7, #12]
3418b6c4:	2200      	movs	r2, #0
3418b6c6:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
3418b6ca:	2300      	movs	r3, #0
}
3418b6cc:	4618      	mov	r0, r3
3418b6ce:	3710      	adds	r7, #16
3418b6d0:	46bd      	mov	sp, r7
3418b6d2:	bdb0      	pop	{r4, r5, r7, pc}

3418b6d4 <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
3418b6d4:	b4b0      	push	{r4, r5, r7}
3418b6d6:	b087      	sub	sp, #28
3418b6d8:	af00      	add	r7, sp, #0
3418b6da:	60f8      	str	r0, [r7, #12]
3418b6dc:	60b9      	str	r1, [r7, #8]
3418b6de:	607a      	str	r2, [r7, #4]
3418b6e0:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3418b6e2:	68fb      	ldr	r3, [r7, #12]
3418b6e4:	681b      	ldr	r3, [r3, #0]
3418b6e6:	461a      	mov	r2, r3
3418b6e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b6ea:	021b      	lsls	r3, r3, #8
3418b6ec:	4413      	add	r3, r2
3418b6ee:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b6f2:	4618      	mov	r0, r3
3418b6f4:	68fa      	ldr	r2, [r7, #12]
3418b6f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b6f8:	2134      	movs	r1, #52	@ 0x34
3418b6fa:	fb01 f303 	mul.w	r3, r1, r3
3418b6fe:	4413      	add	r3, r2
3418b700:	3364      	adds	r3, #100	@ 0x64
3418b702:	681b      	ldr	r3, [r3, #0]
3418b704:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418b706:	68fa      	ldr	r2, [r7, #12]
3418b708:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b70a:	2134      	movs	r1, #52	@ 0x34
3418b70c:	fb01 f303 	mul.w	r3, r1, r3
3418b710:	4413      	add	r3, r2
3418b712:	3348      	adds	r3, #72	@ 0x48
3418b714:	681b      	ldr	r3, [r3, #0]
3418b716:	2b03      	cmp	r3, #3
3418b718:	d821      	bhi.n	3418b75e <LTDC_SetConfig+0x8a>
3418b71a:	e025      	b.n	3418b768 <LTDC_SetConfig+0x94>
3418b71c:	3b04      	subs	r3, #4
3418b71e:	2201      	movs	r2, #1
3418b720:	fa02 f303 	lsl.w	r3, r2, r3
3418b724:	f240 229b 	movw	r2, #667	@ 0x29b
3418b728:	401a      	ands	r2, r3
3418b72a:	2a00      	cmp	r2, #0
3418b72c:	bf14      	ite	ne
3418b72e:	2201      	movne	r2, #1
3418b730:	2200      	moveq	r2, #0
3418b732:	b2d2      	uxtb	r2, r2
3418b734:	2a00      	cmp	r2, #0
3418b736:	d11d      	bne.n	3418b774 <LTDC_SetConfig+0xa0>
3418b738:	f403 7280 	and.w	r2, r3, #256	@ 0x100
3418b73c:	2a00      	cmp	r2, #0
3418b73e:	bf14      	ite	ne
3418b740:	2201      	movne	r2, #1
3418b742:	2200      	moveq	r2, #0
3418b744:	b2d2      	uxtb	r2, r2
3418b746:	2a00      	cmp	r2, #0
3418b748:	d117      	bne.n	3418b77a <LTDC_SetConfig+0xa6>
3418b74a:	f003 0304 	and.w	r3, r3, #4
3418b74e:	2b00      	cmp	r3, #0
3418b750:	bf14      	ite	ne
3418b752:	2301      	movne	r3, #1
3418b754:	2300      	moveq	r3, #0
3418b756:	b2db      	uxtb	r3, r3
3418b758:	2b00      	cmp	r3, #0
3418b75a:	d108      	bne.n	3418b76e <LTDC_SetConfig+0x9a>
3418b75c:	e01b      	b.n	3418b796 <LTDC_SetConfig+0xc2>
3418b75e:	2b0d      	cmp	r3, #13
3418b760:	d819      	bhi.n	3418b796 <LTDC_SetConfig+0xc2>
3418b762:	2b04      	cmp	r3, #4
3418b764:	d2da      	bcs.n	3418b71c <LTDC_SetConfig+0x48>
3418b766:	e016      	b.n	3418b796 <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3418b768:	2304      	movs	r3, #4
3418b76a:	617b      	str	r3, [r7, #20]
      break;
3418b76c:	e016      	b.n	3418b79c <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
3418b76e:	2303      	movs	r3, #3
3418b770:	617b      	str	r3, [r7, #20]
      break;
3418b772:	e013      	b.n	3418b79c <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3418b774:	2302      	movs	r3, #2
3418b776:	617b      	str	r3, [r7, #20]
      break;
3418b778:	e010      	b.n	3418b79c <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
3418b77a:	68fb      	ldr	r3, [r7, #12]
3418b77c:	681b      	ldr	r3, [r3, #0]
3418b77e:	461a      	mov	r2, r3
3418b780:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b782:	021b      	lsls	r3, r3, #8
3418b784:	4413      	add	r3, r2
3418b786:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b78a:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3418b78c:	0c9b      	lsrs	r3, r3, #18
3418b78e:	f003 0307 	and.w	r3, r3, #7
3418b792:	617b      	str	r3, [r7, #20]
      break;
3418b794:	e002      	b.n	3418b79c <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3418b796:	2301      	movs	r3, #1
3418b798:	617b      	str	r3, [r7, #20]
      break;
3418b79a:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3418b79c:	68fa      	ldr	r2, [r7, #12]
3418b79e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b7a0:	2134      	movs	r1, #52	@ 0x34
3418b7a2:	fb01 f303 	mul.w	r3, r1, r3
3418b7a6:	4413      	add	r3, r2
3418b7a8:	333c      	adds	r3, #60	@ 0x3c
3418b7aa:	681a      	ldr	r2, [r3, #0]
3418b7ac:	68fb      	ldr	r3, [r7, #12]
3418b7ae:	681b      	ldr	r3, [r3, #0]
3418b7b0:	68db      	ldr	r3, [r3, #12]
3418b7b2:	0c1b      	lsrs	r3, r3, #16
3418b7b4:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418b7b8:	4413      	add	r3, r2
3418b7ba:	041b      	lsls	r3, r3, #16
3418b7bc:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418b7be:	68fa      	ldr	r2, [r7, #12]
3418b7c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b7c2:	2134      	movs	r1, #52	@ 0x34
3418b7c4:	fb01 f303 	mul.w	r3, r1, r3
3418b7c8:	4413      	add	r3, r2
3418b7ca:	3338      	adds	r3, #56	@ 0x38
3418b7cc:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418b7ce:	68fb      	ldr	r3, [r7, #12]
3418b7d0:	681b      	ldr	r3, [r3, #0]
3418b7d2:	68db      	ldr	r3, [r3, #12]
3418b7d4:	0c1b      	lsrs	r3, r3, #16
3418b7d6:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418b7da:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418b7dc:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418b7de:	68fb      	ldr	r3, [r7, #12]
3418b7e0:	681b      	ldr	r3, [r3, #0]
3418b7e2:	4619      	mov	r1, r3
3418b7e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b7e6:	021b      	lsls	r3, r3, #8
3418b7e8:	440b      	add	r3, r1
3418b7ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b7ee:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3418b7f0:	693b      	ldr	r3, [r7, #16]
3418b7f2:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3418b7f4:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3418b7f6:	68fa      	ldr	r2, [r7, #12]
3418b7f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b7fa:	2134      	movs	r1, #52	@ 0x34
3418b7fc:	fb01 f303 	mul.w	r3, r1, r3
3418b800:	4413      	add	r3, r2
3418b802:	3344      	adds	r3, #68	@ 0x44
3418b804:	681a      	ldr	r2, [r3, #0]
3418b806:	68fb      	ldr	r3, [r7, #12]
3418b808:	681b      	ldr	r3, [r3, #0]
3418b80a:	68db      	ldr	r3, [r3, #12]
3418b80c:	f3c3 030b 	ubfx	r3, r3, #0, #12
3418b810:	4413      	add	r3, r2
3418b812:	041b      	lsls	r3, r3, #16
3418b814:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418b816:	68fa      	ldr	r2, [r7, #12]
3418b818:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b81a:	2134      	movs	r1, #52	@ 0x34
3418b81c:	fb01 f303 	mul.w	r3, r1, r3
3418b820:	4413      	add	r3, r2
3418b822:	3340      	adds	r3, #64	@ 0x40
3418b824:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418b826:	68fb      	ldr	r3, [r7, #12]
3418b828:	681b      	ldr	r3, [r3, #0]
3418b82a:	68db      	ldr	r3, [r3, #12]
3418b82c:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418b830:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418b832:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418b834:	68fb      	ldr	r3, [r7, #12]
3418b836:	681b      	ldr	r3, [r3, #0]
3418b838:	4619      	mov	r1, r3
3418b83a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b83c:	021b      	lsls	r3, r3, #8
3418b83e:	440b      	add	r3, r1
3418b840:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b844:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3418b846:	693b      	ldr	r3, [r7, #16]
3418b848:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3418b84a:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
3418b84c:	683b      	ldr	r3, [r7, #0]
3418b84e:	2b03      	cmp	r3, #3
3418b850:	f040 80fb 	bne.w	3418ba4a <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3418b854:	68fb      	ldr	r3, [r7, #12]
3418b856:	681b      	ldr	r3, [r3, #0]
3418b858:	461a      	mov	r2, r3
3418b85a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b85c:	021b      	lsls	r3, r3, #8
3418b85e:	4413      	add	r3, r2
3418b860:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b864:	4618      	mov	r0, r3
3418b866:	68fa      	ldr	r2, [r7, #12]
3418b868:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b86a:	2134      	movs	r1, #52	@ 0x34
3418b86c:	fb01 f303 	mul.w	r3, r1, r3
3418b870:	4413      	add	r3, r2
3418b872:	335c      	adds	r3, #92	@ 0x5c
3418b874:	681b      	ldr	r3, [r3, #0]
3418b876:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418b878:	68fa      	ldr	r2, [r7, #12]
3418b87a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b87c:	2134      	movs	r1, #52	@ 0x34
3418b87e:	fb01 f303 	mul.w	r3, r1, r3
3418b882:	4413      	add	r3, r2
3418b884:	3348      	adds	r3, #72	@ 0x48
3418b886:	681b      	ldr	r3, [r3, #0]
3418b888:	f240 120d 	movw	r2, #269	@ 0x10d
3418b88c:	4293      	cmp	r3, r2
3418b88e:	d004      	beq.n	3418b89a <LTDC_SetConfig+0x1c6>
3418b890:	f240 220d 	movw	r2, #525	@ 0x20d
3418b894:	4293      	cmp	r3, r2
3418b896:	d043      	beq.n	3418b920 <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
3418b898:	e092      	b.n	3418b9c0 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3418b89a:	68fb      	ldr	r3, [r7, #12]
3418b89c:	681b      	ldr	r3, [r3, #0]
3418b89e:	461a      	mov	r2, r3
3418b8a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b8a2:	021b      	lsls	r3, r3, #8
3418b8a4:	4413      	add	r3, r2
3418b8a6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b8aa:	461a      	mov	r2, r3
3418b8ac:	68bb      	ldr	r3, [r7, #8]
3418b8ae:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418b8b0:	68fa      	ldr	r2, [r7, #12]
3418b8b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b8b4:	2134      	movs	r1, #52	@ 0x34
3418b8b6:	fb01 f303 	mul.w	r3, r1, r3
3418b8ba:	4413      	add	r3, r2
3418b8bc:	3360      	adds	r3, #96	@ 0x60
3418b8be:	681b      	ldr	r3, [r3, #0]
3418b8c0:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418b8c2:	68f9      	ldr	r1, [r7, #12]
3418b8c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b8c6:	2034      	movs	r0, #52	@ 0x34
3418b8c8:	fb00 f303 	mul.w	r3, r0, r3
3418b8cc:	440b      	add	r3, r1
3418b8ce:	333c      	adds	r3, #60	@ 0x3c
3418b8d0:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418b8d2:	68f8      	ldr	r0, [r7, #12]
3418b8d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b8d6:	2434      	movs	r4, #52	@ 0x34
3418b8d8:	fb04 f303 	mul.w	r3, r4, r3
3418b8dc:	4403      	add	r3, r0
3418b8de:	3338      	adds	r3, #56	@ 0x38
3418b8e0:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418b8e2:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3418b8e4:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418b8e6:	68f9      	ldr	r1, [r7, #12]
3418b8e8:	6809      	ldr	r1, [r1, #0]
3418b8ea:	4608      	mov	r0, r1
3418b8ec:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418b8ee:	0209      	lsls	r1, r1, #8
3418b8f0:	4401      	add	r1, r0
3418b8f2:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418b8f6:	4313      	orrs	r3, r2
3418b8f8:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3418b8fa:	68fa      	ldr	r2, [r7, #12]
3418b8fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b8fe:	2134      	movs	r1, #52	@ 0x34
3418b900:	fb01 f303 	mul.w	r3, r1, r3
3418b904:	4413      	add	r3, r2
3418b906:	3364      	adds	r3, #100	@ 0x64
3418b908:	681b      	ldr	r3, [r3, #0]
3418b90a:	68fa      	ldr	r2, [r7, #12]
3418b90c:	6812      	ldr	r2, [r2, #0]
3418b90e:	4611      	mov	r1, r2
3418b910:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418b912:	0212      	lsls	r2, r2, #8
3418b914:	440a      	add	r2, r1
3418b916:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418b91a:	085b      	lsrs	r3, r3, #1
3418b91c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418b91e:	e04f      	b.n	3418b9c0 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3418b920:	68fb      	ldr	r3, [r7, #12]
3418b922:	681b      	ldr	r3, [r3, #0]
3418b924:	461a      	mov	r2, r3
3418b926:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b928:	021b      	lsls	r3, r3, #8
3418b92a:	4413      	add	r3, r2
3418b92c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b930:	461a      	mov	r2, r3
3418b932:	68bb      	ldr	r3, [r7, #8]
3418b934:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
3418b936:	68fb      	ldr	r3, [r7, #12]
3418b938:	681b      	ldr	r3, [r3, #0]
3418b93a:	461a      	mov	r2, r3
3418b93c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b93e:	021b      	lsls	r3, r3, #8
3418b940:	4413      	add	r3, r2
3418b942:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418b946:	461a      	mov	r2, r3
3418b948:	687b      	ldr	r3, [r7, #4]
3418b94a:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418b94c:	68fa      	ldr	r2, [r7, #12]
3418b94e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b950:	2134      	movs	r1, #52	@ 0x34
3418b952:	fb01 f303 	mul.w	r3, r1, r3
3418b956:	4413      	add	r3, r2
3418b958:	3360      	adds	r3, #96	@ 0x60
3418b95a:	681b      	ldr	r3, [r3, #0]
3418b95c:	085b      	lsrs	r3, r3, #1
3418b95e:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418b960:	68f9      	ldr	r1, [r7, #12]
3418b962:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b964:	2034      	movs	r0, #52	@ 0x34
3418b966:	fb00 f303 	mul.w	r3, r0, r3
3418b96a:	440b      	add	r3, r1
3418b96c:	333c      	adds	r3, #60	@ 0x3c
3418b96e:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418b970:	68f8      	ldr	r0, [r7, #12]
3418b972:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b974:	2434      	movs	r4, #52	@ 0x34
3418b976:	fb04 f303 	mul.w	r3, r4, r3
3418b97a:	4403      	add	r3, r0
3418b97c:	3338      	adds	r3, #56	@ 0x38
3418b97e:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418b980:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418b982:	085b      	lsrs	r3, r3, #1
3418b984:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418b986:	68f9      	ldr	r1, [r7, #12]
3418b988:	6809      	ldr	r1, [r1, #0]
3418b98a:	4608      	mov	r0, r1
3418b98c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418b98e:	0209      	lsls	r1, r1, #8
3418b990:	4401      	add	r1, r0
3418b992:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418b996:	4313      	orrs	r3, r2
3418b998:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3418b99a:	68fa      	ldr	r2, [r7, #12]
3418b99c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b99e:	2134      	movs	r1, #52	@ 0x34
3418b9a0:	fb01 f303 	mul.w	r3, r1, r3
3418b9a4:	4413      	add	r3, r2
3418b9a6:	3364      	adds	r3, #100	@ 0x64
3418b9a8:	681b      	ldr	r3, [r3, #0]
3418b9aa:	68fa      	ldr	r2, [r7, #12]
3418b9ac:	6812      	ldr	r2, [r2, #0]
3418b9ae:	4611      	mov	r1, r2
3418b9b0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418b9b2:	0212      	lsls	r2, r2, #8
3418b9b4:	440a      	add	r2, r1
3418b9b6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418b9ba:	085b      	lsrs	r3, r3, #1
3418b9bc:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418b9be:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418b9c0:	68fa      	ldr	r2, [r7, #12]
3418b9c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b9c4:	2134      	movs	r1, #52	@ 0x34
3418b9c6:	fb01 f303 	mul.w	r3, r1, r3
3418b9ca:	4413      	add	r3, r2
3418b9cc:	3360      	adds	r3, #96	@ 0x60
3418b9ce:	681b      	ldr	r3, [r3, #0]
3418b9d0:	697a      	ldr	r2, [r7, #20]
3418b9d2:	fb02 f303 	mul.w	r3, r2, r3
3418b9d6:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
3418b9d8:	68f9      	ldr	r1, [r7, #12]
3418b9da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b9dc:	2034      	movs	r0, #52	@ 0x34
3418b9de:	fb00 f303 	mul.w	r3, r0, r3
3418b9e2:	440b      	add	r3, r1
3418b9e4:	333c      	adds	r3, #60	@ 0x3c
3418b9e6:	6819      	ldr	r1, [r3, #0]
3418b9e8:	68f8      	ldr	r0, [r7, #12]
3418b9ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418b9ec:	2434      	movs	r4, #52	@ 0x34
3418b9ee:	fb04 f303 	mul.w	r3, r4, r3
3418b9f2:	4403      	add	r3, r0
3418b9f4:	3338      	adds	r3, #56	@ 0x38
3418b9f6:	681b      	ldr	r3, [r3, #0]
3418b9f8:	1acb      	subs	r3, r1, r3
3418b9fa:	6979      	ldr	r1, [r7, #20]
3418b9fc:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
3418ba00:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418ba02:	68f9      	ldr	r1, [r7, #12]
3418ba04:	6809      	ldr	r1, [r1, #0]
3418ba06:	4608      	mov	r0, r1
3418ba08:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418ba0a:	0209      	lsls	r1, r1, #8
3418ba0c:	4401      	add	r1, r0
3418ba0e:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418ba12:	4313      	orrs	r3, r2
3418ba14:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3418ba16:	68fb      	ldr	r3, [r7, #12]
3418ba18:	681b      	ldr	r3, [r3, #0]
3418ba1a:	461a      	mov	r2, r3
3418ba1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ba1e:	021b      	lsls	r3, r3, #8
3418ba20:	4413      	add	r3, r2
3418ba22:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418ba26:	68db      	ldr	r3, [r3, #12]
3418ba28:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3418ba2c:	f023 0301 	bic.w	r3, r3, #1
3418ba30:	68fa      	ldr	r2, [r7, #12]
3418ba32:	6812      	ldr	r2, [r2, #0]
3418ba34:	4611      	mov	r1, r2
3418ba36:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ba38:	0212      	lsls	r2, r2, #8
3418ba3a:	440a      	add	r2, r1
3418ba3c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418ba40:	f043 0301 	orr.w	r3, r3, #1
3418ba44:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
3418ba46:	f000 bccc 	b.w	3418c3e2 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
3418ba4a:	683b      	ldr	r3, [r7, #0]
3418ba4c:	2b00      	cmp	r3, #0
3418ba4e:	f040 814e 	bne.w	3418bcee <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418ba52:	68fa      	ldr	r2, [r7, #12]
3418ba54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ba56:	2134      	movs	r1, #52	@ 0x34
3418ba58:	fb01 f303 	mul.w	r3, r1, r3
3418ba5c:	4413      	add	r3, r2
3418ba5e:	335c      	adds	r3, #92	@ 0x5c
3418ba60:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ba62:	68f9      	ldr	r1, [r7, #12]
3418ba64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ba66:	2034      	movs	r0, #52	@ 0x34
3418ba68:	fb00 f303 	mul.w	r3, r0, r3
3418ba6c:	440b      	add	r3, r1
3418ba6e:	333c      	adds	r3, #60	@ 0x3c
3418ba70:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418ba72:	68f8      	ldr	r0, [r7, #12]
3418ba74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418ba76:	2434      	movs	r4, #52	@ 0x34
3418ba78:	fb04 f303 	mul.w	r3, r4, r3
3418ba7c:	4403      	add	r3, r0
3418ba7e:	3338      	adds	r3, #56	@ 0x38
3418ba80:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418ba82:	1acb      	subs	r3, r1, r3
3418ba84:	6979      	ldr	r1, [r7, #20]
3418ba86:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418ba8a:	4413      	add	r3, r2
3418ba8c:	68fa      	ldr	r2, [r7, #12]
3418ba8e:	6812      	ldr	r2, [r2, #0]
3418ba90:	4611      	mov	r1, r2
3418ba92:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418ba94:	0212      	lsls	r2, r2, #8
3418ba96:	440a      	add	r2, r1
3418ba98:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418ba9c:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418ba9e:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418baa0:	68fa      	ldr	r2, [r7, #12]
3418baa2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418baa4:	2134      	movs	r1, #52	@ 0x34
3418baa6:	fb01 f303 	mul.w	r3, r1, r3
3418baaa:	4413      	add	r3, r2
3418baac:	3348      	adds	r3, #72	@ 0x48
3418baae:	681b      	ldr	r3, [r3, #0]
3418bab0:	f240 120d 	movw	r2, #269	@ 0x10d
3418bab4:	4293      	cmp	r3, r2
3418bab6:	d004      	beq.n	3418bac2 <LTDC_SetConfig+0x3ee>
3418bab8:	f240 220d 	movw	r2, #525	@ 0x20d
3418babc:	4293      	cmp	r3, r2
3418babe:	d058      	beq.n	3418bb72 <LTDC_SetConfig+0x49e>
        break;
3418bac0:	e0d3      	b.n	3418bc6a <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bac2:	68fa      	ldr	r2, [r7, #12]
3418bac4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bac6:	2134      	movs	r1, #52	@ 0x34
3418bac8:	fb01 f303 	mul.w	r3, r1, r3
3418bacc:	4413      	add	r3, r2
3418bace:	333c      	adds	r3, #60	@ 0x3c
3418bad0:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418bad2:	68f9      	ldr	r1, [r7, #12]
3418bad4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bad6:	2034      	movs	r0, #52	@ 0x34
3418bad8:	fb00 f303 	mul.w	r3, r0, r3
3418badc:	440b      	add	r3, r1
3418bade:	3338      	adds	r3, #56	@ 0x38
3418bae0:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bae2:	1ad3      	subs	r3, r2, r3
3418bae4:	697a      	ldr	r2, [r7, #20]
3418bae6:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418baea:	68bb      	ldr	r3, [r7, #8]
3418baec:	4413      	add	r3, r2
3418baee:	68fa      	ldr	r2, [r7, #12]
3418baf0:	6812      	ldr	r2, [r2, #0]
3418baf2:	4611      	mov	r1, r2
3418baf4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418baf6:	0212      	lsls	r2, r2, #8
3418baf8:	440a      	add	r2, r1
3418bafa:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3418bafe:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418bb00:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418bb02:	68fa      	ldr	r2, [r7, #12]
3418bb04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb06:	2134      	movs	r1, #52	@ 0x34
3418bb08:	fb01 f303 	mul.w	r3, r1, r3
3418bb0c:	4413      	add	r3, r2
3418bb0e:	3360      	adds	r3, #96	@ 0x60
3418bb10:	681b      	ldr	r3, [r3, #0]
3418bb12:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
3418bb14:	68f9      	ldr	r1, [r7, #12]
3418bb16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb18:	2034      	movs	r0, #52	@ 0x34
3418bb1a:	fb00 f303 	mul.w	r3, r0, r3
3418bb1e:	440b      	add	r3, r1
3418bb20:	333c      	adds	r3, #60	@ 0x3c
3418bb22:	6819      	ldr	r1, [r3, #0]
3418bb24:	68f8      	ldr	r0, [r7, #12]
3418bb26:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb28:	2434      	movs	r4, #52	@ 0x34
3418bb2a:	fb04 f303 	mul.w	r3, r4, r3
3418bb2e:	4403      	add	r3, r0
3418bb30:	3338      	adds	r3, #56	@ 0x38
3418bb32:	681b      	ldr	r3, [r3, #0]
3418bb34:	1acb      	subs	r3, r1, r3
3418bb36:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3418bb38:	68f9      	ldr	r1, [r7, #12]
3418bb3a:	6809      	ldr	r1, [r1, #0]
3418bb3c:	4608      	mov	r0, r1
3418bb3e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bb40:	0209      	lsls	r1, r1, #8
3418bb42:	4401      	add	r1, r0
3418bb44:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418bb48:	4313      	orrs	r3, r2
3418bb4a:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
3418bb4c:	68fa      	ldr	r2, [r7, #12]
3418bb4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb50:	2134      	movs	r1, #52	@ 0x34
3418bb52:	fb01 f303 	mul.w	r3, r1, r3
3418bb56:	4413      	add	r3, r2
3418bb58:	3364      	adds	r3, #100	@ 0x64
3418bb5a:	681b      	ldr	r3, [r3, #0]
3418bb5c:	68fa      	ldr	r2, [r7, #12]
3418bb5e:	6812      	ldr	r2, [r2, #0]
3418bb60:	4611      	mov	r1, r2
3418bb62:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bb64:	0212      	lsls	r2, r2, #8
3418bb66:	440a      	add	r2, r1
3418bb68:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418bb6c:	085b      	lsrs	r3, r3, #1
3418bb6e:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418bb70:	e07b      	b.n	3418bc6a <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bb72:	68fa      	ldr	r2, [r7, #12]
3418bb74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb76:	2134      	movs	r1, #52	@ 0x34
3418bb78:	fb01 f303 	mul.w	r3, r1, r3
3418bb7c:	4413      	add	r3, r2
3418bb7e:	333c      	adds	r3, #60	@ 0x3c
3418bb80:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bb82:	68f9      	ldr	r1, [r7, #12]
3418bb84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bb86:	2034      	movs	r0, #52	@ 0x34
3418bb88:	fb00 f303 	mul.w	r3, r0, r3
3418bb8c:	440b      	add	r3, r1
3418bb8e:	3338      	adds	r3, #56	@ 0x38
3418bb90:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bb92:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bb94:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bb96:	697a      	ldr	r2, [r7, #20]
3418bb98:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418bb9c:	68bb      	ldr	r3, [r7, #8]
3418bb9e:	4413      	add	r3, r2
3418bba0:	68fa      	ldr	r2, [r7, #12]
3418bba2:	6812      	ldr	r2, [r2, #0]
3418bba4:	4611      	mov	r1, r2
3418bba6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bba8:	0212      	lsls	r2, r2, #8
3418bbaa:	440a      	add	r2, r1
3418bbac:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bbb0:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418bbb2:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bbb4:	68fa      	ldr	r2, [r7, #12]
3418bbb6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bbb8:	2134      	movs	r1, #52	@ 0x34
3418bbba:	fb01 f303 	mul.w	r3, r1, r3
3418bbbe:	4413      	add	r3, r2
3418bbc0:	333c      	adds	r3, #60	@ 0x3c
3418bbc2:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bbc4:	68f9      	ldr	r1, [r7, #12]
3418bbc6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bbc8:	2034      	movs	r0, #52	@ 0x34
3418bbca:	fb00 f303 	mul.w	r3, r0, r3
3418bbce:	440b      	add	r3, r1
3418bbd0:	3338      	adds	r3, #56	@ 0x38
3418bbd2:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bbd4:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bbd6:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bbd8:	697a      	ldr	r2, [r7, #20]
3418bbda:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418bbde:	687b      	ldr	r3, [r7, #4]
3418bbe0:	4413      	add	r3, r2
3418bbe2:	68fa      	ldr	r2, [r7, #12]
3418bbe4:	6812      	ldr	r2, [r2, #0]
3418bbe6:	4611      	mov	r1, r2
3418bbe8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bbea:	0212      	lsls	r2, r2, #8
3418bbec:	440a      	add	r2, r1
3418bbee:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3418bbf2:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418bbf4:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418bbf6:	68fa      	ldr	r2, [r7, #12]
3418bbf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bbfa:	2134      	movs	r1, #52	@ 0x34
3418bbfc:	fb01 f303 	mul.w	r3, r1, r3
3418bc00:	4413      	add	r3, r2
3418bc02:	3360      	adds	r3, #96	@ 0x60
3418bc04:	681b      	ldr	r3, [r3, #0]
3418bc06:	085b      	lsrs	r3, r3, #1
3418bc08:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bc0a:	68f9      	ldr	r1, [r7, #12]
3418bc0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc0e:	2034      	movs	r0, #52	@ 0x34
3418bc10:	fb00 f303 	mul.w	r3, r0, r3
3418bc14:	440b      	add	r3, r1
3418bc16:	333c      	adds	r3, #60	@ 0x3c
3418bc18:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418bc1a:	68f8      	ldr	r0, [r7, #12]
3418bc1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc1e:	2434      	movs	r4, #52	@ 0x34
3418bc20:	fb04 f303 	mul.w	r3, r4, r3
3418bc24:	4403      	add	r3, r0
3418bc26:	3338      	adds	r3, #56	@ 0x38
3418bc28:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bc2a:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3418bc2c:	085b      	lsrs	r3, r3, #1
3418bc2e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3418bc30:	68f9      	ldr	r1, [r7, #12]
3418bc32:	6809      	ldr	r1, [r1, #0]
3418bc34:	4608      	mov	r0, r1
3418bc36:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bc38:	0209      	lsls	r1, r1, #8
3418bc3a:	4401      	add	r1, r0
3418bc3c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418bc40:	4313      	orrs	r3, r2
3418bc42:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418bc44:	68fa      	ldr	r2, [r7, #12]
3418bc46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc48:	2134      	movs	r1, #52	@ 0x34
3418bc4a:	fb01 f303 	mul.w	r3, r1, r3
3418bc4e:	4413      	add	r3, r2
3418bc50:	3364      	adds	r3, #100	@ 0x64
3418bc52:	681b      	ldr	r3, [r3, #0]
3418bc54:	68fa      	ldr	r2, [r7, #12]
3418bc56:	6812      	ldr	r2, [r2, #0]
3418bc58:	4611      	mov	r1, r2
3418bc5a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bc5c:	0212      	lsls	r2, r2, #8
3418bc5e:	440a      	add	r2, r1
3418bc60:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418bc64:	085b      	lsrs	r3, r3, #1
3418bc66:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418bc68:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418bc6a:	68fa      	ldr	r2, [r7, #12]
3418bc6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc6e:	2134      	movs	r1, #52	@ 0x34
3418bc70:	fb01 f303 	mul.w	r3, r1, r3
3418bc74:	4413      	add	r3, r2
3418bc76:	3360      	adds	r3, #96	@ 0x60
3418bc78:	681b      	ldr	r3, [r3, #0]
3418bc7a:	697a      	ldr	r2, [r7, #20]
3418bc7c:	fb02 f303 	mul.w	r3, r2, r3
3418bc80:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bc82:	68f9      	ldr	r1, [r7, #12]
3418bc84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc86:	2034      	movs	r0, #52	@ 0x34
3418bc88:	fb00 f303 	mul.w	r3, r0, r3
3418bc8c:	440b      	add	r3, r1
3418bc8e:	333c      	adds	r3, #60	@ 0x3c
3418bc90:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418bc92:	68f8      	ldr	r0, [r7, #12]
3418bc94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bc96:	2434      	movs	r4, #52	@ 0x34
3418bc98:	fb04 f303 	mul.w	r3, r4, r3
3418bc9c:	4403      	add	r3, r0
3418bc9e:	3338      	adds	r3, #56	@ 0x38
3418bca0:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bca2:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3418bca4:	6979      	ldr	r1, [r7, #20]
3418bca6:	fb01 f303 	mul.w	r3, r1, r3
3418bcaa:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3418bcac:	68f9      	ldr	r1, [r7, #12]
3418bcae:	6809      	ldr	r1, [r1, #0]
3418bcb0:	4608      	mov	r0, r1
3418bcb2:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bcb4:	0209      	lsls	r1, r1, #8
3418bcb6:	4401      	add	r1, r0
3418bcb8:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418bcbc:	4313      	orrs	r3, r2
3418bcbe:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3418bcc0:	68fb      	ldr	r3, [r7, #12]
3418bcc2:	681b      	ldr	r3, [r3, #0]
3418bcc4:	461a      	mov	r2, r3
3418bcc6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bcc8:	021b      	lsls	r3, r3, #8
3418bcca:	4413      	add	r3, r2
3418bccc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418bcd0:	68db      	ldr	r3, [r3, #12]
3418bcd2:	68fa      	ldr	r2, [r7, #12]
3418bcd4:	6812      	ldr	r2, [r2, #0]
3418bcd6:	4611      	mov	r1, r2
3418bcd8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bcda:	0212      	lsls	r2, r2, #8
3418bcdc:	440a      	add	r2, r1
3418bcde:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418bce2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418bce6:	f043 0301 	orr.w	r3, r3, #1
3418bcea:	60d3      	str	r3, [r2, #12]
}
3418bcec:	e379      	b.n	3418c3e2 <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3418bcee:	683b      	ldr	r3, [r7, #0]
3418bcf0:	2b01      	cmp	r3, #1
3418bcf2:	f040 81b4 	bne.w	3418c05e <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418bcf6:	68fa      	ldr	r2, [r7, #12]
3418bcf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bcfa:	2134      	movs	r1, #52	@ 0x34
3418bcfc:	fb01 f303 	mul.w	r3, r1, r3
3418bd00:	4413      	add	r3, r2
3418bd02:	335c      	adds	r3, #92	@ 0x5c
3418bd04:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bd06:	68f9      	ldr	r1, [r7, #12]
3418bd08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bd0a:	2034      	movs	r0, #52	@ 0x34
3418bd0c:	fb00 f303 	mul.w	r3, r0, r3
3418bd10:	440b      	add	r3, r1
3418bd12:	333c      	adds	r3, #60	@ 0x3c
3418bd14:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418bd16:	68f8      	ldr	r0, [r7, #12]
3418bd18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bd1a:	2434      	movs	r4, #52	@ 0x34
3418bd1c:	fb04 f303 	mul.w	r3, r4, r3
3418bd20:	4403      	add	r3, r0
3418bd22:	3338      	adds	r3, #56	@ 0x38
3418bd24:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bd26:	1acb      	subs	r3, r1, r3
3418bd28:	6979      	ldr	r1, [r7, #20]
3418bd2a:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bd2e:	68f8      	ldr	r0, [r7, #12]
3418bd30:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bd32:	2434      	movs	r4, #52	@ 0x34
3418bd34:	fb04 f101 	mul.w	r1, r4, r1
3418bd38:	4401      	add	r1, r0
3418bd3a:	3144      	adds	r1, #68	@ 0x44
3418bd3c:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3418bd3e:	68fc      	ldr	r4, [r7, #12]
3418bd40:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bd42:	2534      	movs	r5, #52	@ 0x34
3418bd44:	fb05 f101 	mul.w	r1, r5, r1
3418bd48:	4421      	add	r1, r4
3418bd4a:	3140      	adds	r1, #64	@ 0x40
3418bd4c:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bd4e:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3418bd50:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418bd52:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418bd56:	68f9      	ldr	r1, [r7, #12]
3418bd58:	6809      	ldr	r1, [r1, #0]
3418bd5a:	4608      	mov	r0, r1
3418bd5c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bd5e:	0209      	lsls	r1, r1, #8
3418bd60:	4401      	add	r1, r0
3418bd62:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418bd66:	4413      	add	r3, r2
3418bd68:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418bd6a:	68fa      	ldr	r2, [r7, #12]
3418bd6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bd6e:	2134      	movs	r1, #52	@ 0x34
3418bd70:	fb01 f303 	mul.w	r3, r1, r3
3418bd74:	4413      	add	r3, r2
3418bd76:	3348      	adds	r3, #72	@ 0x48
3418bd78:	681b      	ldr	r3, [r3, #0]
3418bd7a:	f240 120d 	movw	r2, #269	@ 0x10d
3418bd7e:	4293      	cmp	r3, r2
3418bd80:	d004      	beq.n	3418bd8c <LTDC_SetConfig+0x6b8>
3418bd82:	f240 220d 	movw	r2, #525	@ 0x20d
3418bd86:	4293      	cmp	r3, r2
3418bd88:	d075      	beq.n	3418be76 <LTDC_SetConfig+0x7a2>
        break;
3418bd8a:	e122      	b.n	3418bfd2 <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bd8c:	68fa      	ldr	r2, [r7, #12]
3418bd8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bd90:	2134      	movs	r1, #52	@ 0x34
3418bd92:	fb01 f303 	mul.w	r3, r1, r3
3418bd96:	4413      	add	r3, r2
3418bd98:	333c      	adds	r3, #60	@ 0x3c
3418bd9a:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418bd9c:	68f9      	ldr	r1, [r7, #12]
3418bd9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bda0:	2034      	movs	r0, #52	@ 0x34
3418bda2:	fb00 f303 	mul.w	r3, r0, r3
3418bda6:	440b      	add	r3, r1
3418bda8:	3338      	adds	r3, #56	@ 0x38
3418bdaa:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bdac:	1ad3      	subs	r3, r2, r3
3418bdae:	697a      	ldr	r2, [r7, #20]
3418bdb0:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bdb4:	68f9      	ldr	r1, [r7, #12]
3418bdb6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bdb8:	2034      	movs	r0, #52	@ 0x34
3418bdba:	fb00 f202 	mul.w	r2, r0, r2
3418bdbe:	440a      	add	r2, r1
3418bdc0:	3244      	adds	r2, #68	@ 0x44
3418bdc2:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418bdc4:	68f8      	ldr	r0, [r7, #12]
3418bdc6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bdc8:	2434      	movs	r4, #52	@ 0x34
3418bdca:	fb04 f202 	mul.w	r2, r4, r2
3418bdce:	4402      	add	r2, r0
3418bdd0:	3240      	adds	r2, #64	@ 0x40
3418bdd2:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bdd4:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418bdd6:	0852      	lsrs	r2, r2, #1
3418bdd8:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418bdda:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418bdde:	68fb      	ldr	r3, [r7, #12]
3418bde0:	681b      	ldr	r3, [r3, #0]
3418bde2:	4619      	mov	r1, r3
3418bde4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bde6:	021b      	lsls	r3, r3, #8
3418bde8:	440b      	add	r3, r1
3418bdea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418bdee:	4619      	mov	r1, r3
3418bdf0:	68bb      	ldr	r3, [r7, #8]
3418bdf2:	4413      	add	r3, r2
3418bdf4:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418bdf6:	68fa      	ldr	r2, [r7, #12]
3418bdf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bdfa:	2134      	movs	r1, #52	@ 0x34
3418bdfc:	fb01 f303 	mul.w	r3, r1, r3
3418be00:	4413      	add	r3, r2
3418be02:	3360      	adds	r3, #96	@ 0x60
3418be04:	681b      	ldr	r3, [r3, #0]
3418be06:	697a      	ldr	r2, [r7, #20]
3418be08:	fb02 f303 	mul.w	r3, r2, r3
3418be0c:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418be10:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418be12:	68f9      	ldr	r1, [r7, #12]
3418be14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418be16:	2034      	movs	r0, #52	@ 0x34
3418be18:	fb00 f303 	mul.w	r3, r0, r3
3418be1c:	440b      	add	r3, r1
3418be1e:	333c      	adds	r3, #60	@ 0x3c
3418be20:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3418be22:	68f8      	ldr	r0, [r7, #12]
3418be24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418be26:	2434      	movs	r4, #52	@ 0x34
3418be28:	fb04 f303 	mul.w	r3, r4, r3
3418be2c:	4403      	add	r3, r0
3418be2e:	3338      	adds	r3, #56	@ 0x38
3418be30:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418be32:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3418be34:	6979      	ldr	r1, [r7, #20]
3418be36:	fb01 f303 	mul.w	r3, r1, r3
3418be3a:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418be3c:	68f9      	ldr	r1, [r7, #12]
3418be3e:	6809      	ldr	r1, [r1, #0]
3418be40:	4608      	mov	r0, r1
3418be42:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418be44:	0209      	lsls	r1, r1, #8
3418be46:	4401      	add	r1, r0
3418be48:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418be4c:	4313      	orrs	r3, r2
3418be4e:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418be50:	68fa      	ldr	r2, [r7, #12]
3418be52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418be54:	2134      	movs	r1, #52	@ 0x34
3418be56:	fb01 f303 	mul.w	r3, r1, r3
3418be5a:	4413      	add	r3, r2
3418be5c:	3364      	adds	r3, #100	@ 0x64
3418be5e:	681b      	ldr	r3, [r3, #0]
3418be60:	68fa      	ldr	r2, [r7, #12]
3418be62:	6812      	ldr	r2, [r2, #0]
3418be64:	4611      	mov	r1, r2
3418be66:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418be68:	0212      	lsls	r2, r2, #8
3418be6a:	440a      	add	r2, r1
3418be6c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418be70:	085b      	lsrs	r3, r3, #1
3418be72:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418be74:	e0ad      	b.n	3418bfd2 <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418be76:	68fa      	ldr	r2, [r7, #12]
3418be78:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418be7a:	2134      	movs	r1, #52	@ 0x34
3418be7c:	fb01 f303 	mul.w	r3, r1, r3
3418be80:	4413      	add	r3, r2
3418be82:	333c      	adds	r3, #60	@ 0x3c
3418be84:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418be86:	68f9      	ldr	r1, [r7, #12]
3418be88:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418be8a:	2034      	movs	r0, #52	@ 0x34
3418be8c:	fb00 f303 	mul.w	r3, r0, r3
3418be90:	440b      	add	r3, r1
3418be92:	3338      	adds	r3, #56	@ 0x38
3418be94:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418be96:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418be98:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418be9a:	697a      	ldr	r2, [r7, #20]
3418be9c:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bea0:	68f9      	ldr	r1, [r7, #12]
3418bea2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bea4:	2034      	movs	r0, #52	@ 0x34
3418bea6:	fb00 f202 	mul.w	r2, r0, r2
3418beaa:	440a      	add	r2, r1
3418beac:	3244      	adds	r2, #68	@ 0x44
3418beae:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418beb0:	68f8      	ldr	r0, [r7, #12]
3418beb2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418beb4:	2434      	movs	r4, #52	@ 0x34
3418beb6:	fb04 f202 	mul.w	r2, r4, r2
3418beba:	4402      	add	r2, r0
3418bebc:	3240      	adds	r2, #64	@ 0x40
3418bebe:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bec0:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418bec2:	0852      	lsrs	r2, r2, #1
3418bec4:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418bec6:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418beca:	68fb      	ldr	r3, [r7, #12]
3418becc:	681b      	ldr	r3, [r3, #0]
3418bece:	4619      	mov	r1, r3
3418bed0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bed2:	021b      	lsls	r3, r3, #8
3418bed4:	440b      	add	r3, r1
3418bed6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418beda:	4619      	mov	r1, r3
3418bedc:	68bb      	ldr	r3, [r7, #8]
3418bede:	4413      	add	r3, r2
3418bee0:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bee2:	68fa      	ldr	r2, [r7, #12]
3418bee4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bee6:	2134      	movs	r1, #52	@ 0x34
3418bee8:	fb01 f303 	mul.w	r3, r1, r3
3418beec:	4413      	add	r3, r2
3418beee:	333c      	adds	r3, #60	@ 0x3c
3418bef0:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418bef2:	68f9      	ldr	r1, [r7, #12]
3418bef4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bef6:	2034      	movs	r0, #52	@ 0x34
3418bef8:	fb00 f303 	mul.w	r3, r0, r3
3418befc:	440b      	add	r3, r1
3418befe:	3338      	adds	r3, #56	@ 0x38
3418bf00:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bf02:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418bf04:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bf06:	697a      	ldr	r2, [r7, #20]
3418bf08:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bf0c:	68f9      	ldr	r1, [r7, #12]
3418bf0e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bf10:	2034      	movs	r0, #52	@ 0x34
3418bf12:	fb00 f202 	mul.w	r2, r0, r2
3418bf16:	440a      	add	r2, r1
3418bf18:	3244      	adds	r2, #68	@ 0x44
3418bf1a:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418bf1c:	68f8      	ldr	r0, [r7, #12]
3418bf1e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bf20:	2434      	movs	r4, #52	@ 0x34
3418bf22:	fb04 f202 	mul.w	r2, r4, r2
3418bf26:	4402      	add	r2, r0
3418bf28:	3240      	adds	r2, #64	@ 0x40
3418bf2a:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418bf2c:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3418bf2e:	0852      	lsrs	r2, r2, #1
3418bf30:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418bf32:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418bf36:	68fb      	ldr	r3, [r7, #12]
3418bf38:	681b      	ldr	r3, [r3, #0]
3418bf3a:	4619      	mov	r1, r3
3418bf3c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bf3e:	021b      	lsls	r3, r3, #8
3418bf40:	440b      	add	r3, r1
3418bf42:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418bf46:	4619      	mov	r1, r3
3418bf48:	687b      	ldr	r3, [r7, #4]
3418bf4a:	4413      	add	r3, r2
3418bf4c:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418bf4e:	68fa      	ldr	r2, [r7, #12]
3418bf50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bf52:	2134      	movs	r1, #52	@ 0x34
3418bf54:	fb01 f303 	mul.w	r3, r1, r3
3418bf58:	4413      	add	r3, r2
3418bf5a:	3360      	adds	r3, #96	@ 0x60
3418bf5c:	681b      	ldr	r3, [r3, #0]
3418bf5e:	085b      	lsrs	r3, r3, #1
3418bf60:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418bf64:	697a      	ldr	r2, [r7, #20]
3418bf66:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
3418bf6a:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bf6c:	68f9      	ldr	r1, [r7, #12]
3418bf6e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bf70:	2034      	movs	r0, #52	@ 0x34
3418bf72:	fb00 f303 	mul.w	r3, r0, r3
3418bf76:	440b      	add	r3, r1
3418bf78:	333c      	adds	r3, #60	@ 0x3c
3418bf7a:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418bf7c:	68f8      	ldr	r0, [r7, #12]
3418bf7e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bf80:	2434      	movs	r4, #52	@ 0x34
3418bf82:	fb04 f303 	mul.w	r3, r4, r3
3418bf86:	4403      	add	r3, r0
3418bf88:	3338      	adds	r3, #56	@ 0x38
3418bf8a:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bf8c:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418bf8e:	085b      	lsrs	r3, r3, #1
3418bf90:	6979      	ldr	r1, [r7, #20]
3418bf92:	fb01 f303 	mul.w	r3, r1, r3
3418bf96:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418bf98:	68f9      	ldr	r1, [r7, #12]
3418bf9a:	6809      	ldr	r1, [r1, #0]
3418bf9c:	4608      	mov	r0, r1
3418bf9e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418bfa0:	0209      	lsls	r1, r1, #8
3418bfa2:	4401      	add	r1, r0
3418bfa4:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
3418bfa8:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3418bfaa:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418bfac:	68fa      	ldr	r2, [r7, #12]
3418bfae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bfb0:	2134      	movs	r1, #52	@ 0x34
3418bfb2:	fb01 f303 	mul.w	r3, r1, r3
3418bfb6:	4413      	add	r3, r2
3418bfb8:	3364      	adds	r3, #100	@ 0x64
3418bfba:	681b      	ldr	r3, [r3, #0]
3418bfbc:	68fa      	ldr	r2, [r7, #12]
3418bfbe:	6812      	ldr	r2, [r2, #0]
3418bfc0:	4611      	mov	r1, r2
3418bfc2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418bfc4:	0212      	lsls	r2, r2, #8
3418bfc6:	440a      	add	r2, r1
3418bfc8:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418bfcc:	085b      	lsrs	r3, r3, #1
3418bfce:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418bfd0:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418bfd2:	68fa      	ldr	r2, [r7, #12]
3418bfd4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bfd6:	2134      	movs	r1, #52	@ 0x34
3418bfd8:	fb01 f303 	mul.w	r3, r1, r3
3418bfdc:	4413      	add	r3, r2
3418bfde:	3360      	adds	r3, #96	@ 0x60
3418bfe0:	681b      	ldr	r3, [r3, #0]
3418bfe2:	697a      	ldr	r2, [r7, #20]
3418bfe4:	fb02 f303 	mul.w	r3, r2, r3
3418bfe8:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418bfec:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418bfee:	68f9      	ldr	r1, [r7, #12]
3418bff0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418bff2:	2034      	movs	r0, #52	@ 0x34
3418bff4:	fb00 f303 	mul.w	r3, r0, r3
3418bff8:	440b      	add	r3, r1
3418bffa:	333c      	adds	r3, #60	@ 0x3c
3418bffc:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418bffe:	68f8      	ldr	r0, [r7, #12]
3418c000:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c002:	2434      	movs	r4, #52	@ 0x34
3418c004:	fb04 f303 	mul.w	r3, r4, r3
3418c008:	4403      	add	r3, r0
3418c00a:	3338      	adds	r3, #56	@ 0x38
3418c00c:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c00e:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418c010:	6979      	ldr	r1, [r7, #20]
3418c012:	fb01 f303 	mul.w	r3, r1, r3
3418c016:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418c018:	68f9      	ldr	r1, [r7, #12]
3418c01a:	6809      	ldr	r1, [r1, #0]
3418c01c:	4608      	mov	r0, r1
3418c01e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c020:	0209      	lsls	r1, r1, #8
3418c022:	4401      	add	r1, r0
3418c024:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418c028:	4313      	orrs	r3, r2
3418c02a:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3418c02c:	68fb      	ldr	r3, [r7, #12]
3418c02e:	681b      	ldr	r3, [r3, #0]
3418c030:	461a      	mov	r2, r3
3418c032:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c034:	021b      	lsls	r3, r3, #8
3418c036:	4413      	add	r3, r2
3418c038:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c03c:	68db      	ldr	r3, [r3, #12]
3418c03e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3418c042:	f023 0301 	bic.w	r3, r3, #1
3418c046:	68fa      	ldr	r2, [r7, #12]
3418c048:	6812      	ldr	r2, [r2, #0]
3418c04a:	4611      	mov	r1, r2
3418c04c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c04e:	0212      	lsls	r2, r2, #8
3418c050:	440a      	add	r2, r1
3418c052:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c056:	f043 0301 	orr.w	r3, r3, #1
3418c05a:	60d3      	str	r3, [r2, #12]
}
3418c05c:	e1c1      	b.n	3418c3e2 <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418c05e:	68fa      	ldr	r2, [r7, #12]
3418c060:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c062:	2134      	movs	r1, #52	@ 0x34
3418c064:	fb01 f303 	mul.w	r3, r1, r3
3418c068:	4413      	add	r3, r2
3418c06a:	335c      	adds	r3, #92	@ 0x5c
3418c06c:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c06e:	68f9      	ldr	r1, [r7, #12]
3418c070:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c072:	2034      	movs	r0, #52	@ 0x34
3418c074:	fb00 f303 	mul.w	r3, r0, r3
3418c078:	440b      	add	r3, r1
3418c07a:	333c      	adds	r3, #60	@ 0x3c
3418c07c:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418c07e:	68f8      	ldr	r0, [r7, #12]
3418c080:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c082:	2434      	movs	r4, #52	@ 0x34
3418c084:	fb04 f303 	mul.w	r3, r4, r3
3418c088:	4403      	add	r3, r0
3418c08a:	3338      	adds	r3, #56	@ 0x38
3418c08c:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c08e:	1acb      	subs	r3, r1, r3
3418c090:	6979      	ldr	r1, [r7, #20]
3418c092:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418c096:	68f8      	ldr	r0, [r7, #12]
3418c098:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c09a:	2434      	movs	r4, #52	@ 0x34
3418c09c:	fb04 f101 	mul.w	r1, r4, r1
3418c0a0:	4401      	add	r1, r0
3418c0a2:	3144      	adds	r1, #68	@ 0x44
3418c0a4:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3418c0a6:	68fc      	ldr	r4, [r7, #12]
3418c0a8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c0aa:	2534      	movs	r5, #52	@ 0x34
3418c0ac:	fb05 f101 	mul.w	r1, r5, r1
3418c0b0:	4421      	add	r1, r4
3418c0b2:	3140      	adds	r1, #64	@ 0x40
3418c0b4:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3418c0b6:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3418c0b8:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418c0bc:	4413      	add	r3, r2
3418c0be:	68fa      	ldr	r2, [r7, #12]
3418c0c0:	6812      	ldr	r2, [r2, #0]
3418c0c2:	4611      	mov	r1, r2
3418c0c4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c0c6:	0212      	lsls	r2, r2, #8
3418c0c8:	440a      	add	r2, r1
3418c0ca:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3418c0ce:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3418c0d0:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418c0d2:	68fa      	ldr	r2, [r7, #12]
3418c0d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c0d6:	2134      	movs	r1, #52	@ 0x34
3418c0d8:	fb01 f303 	mul.w	r3, r1, r3
3418c0dc:	4413      	add	r3, r2
3418c0de:	3348      	adds	r3, #72	@ 0x48
3418c0e0:	681b      	ldr	r3, [r3, #0]
3418c0e2:	f240 120d 	movw	r2, #269	@ 0x10d
3418c0e6:	4293      	cmp	r3, r2
3418c0e8:	d004      	beq.n	3418c0f4 <LTDC_SetConfig+0xa20>
3418c0ea:	f240 220d 	movw	r2, #525	@ 0x20d
3418c0ee:	4293      	cmp	r3, r2
3418c0f0:	d074      	beq.n	3418c1dc <LTDC_SetConfig+0xb08>
        break;
3418c0f2:	e133      	b.n	3418c35c <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c0f4:	68fa      	ldr	r2, [r7, #12]
3418c0f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c0f8:	2134      	movs	r1, #52	@ 0x34
3418c0fa:	fb01 f303 	mul.w	r3, r1, r3
3418c0fe:	4413      	add	r3, r2
3418c100:	333c      	adds	r3, #60	@ 0x3c
3418c102:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418c104:	68f9      	ldr	r1, [r7, #12]
3418c106:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c108:	2034      	movs	r0, #52	@ 0x34
3418c10a:	fb00 f303 	mul.w	r3, r0, r3
3418c10e:	440b      	add	r3, r1
3418c110:	3338      	adds	r3, #56	@ 0x38
3418c112:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c114:	1ad3      	subs	r3, r2, r3
3418c116:	697a      	ldr	r2, [r7, #20]
3418c118:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c11c:	68f9      	ldr	r1, [r7, #12]
3418c11e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c120:	2034      	movs	r0, #52	@ 0x34
3418c122:	fb00 f202 	mul.w	r2, r0, r2
3418c126:	440a      	add	r2, r1
3418c128:	3244      	adds	r2, #68	@ 0x44
3418c12a:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c12c:	68f8      	ldr	r0, [r7, #12]
3418c12e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c130:	2434      	movs	r4, #52	@ 0x34
3418c132:	fb04 f202 	mul.w	r2, r4, r2
3418c136:	4402      	add	r2, r0
3418c138:	3240      	adds	r2, #64	@ 0x40
3418c13a:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c13c:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c13e:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3418c140:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418c144:	68bb      	ldr	r3, [r7, #8]
3418c146:	4413      	add	r3, r2
3418c148:	68fa      	ldr	r2, [r7, #12]
3418c14a:	6812      	ldr	r2, [r2, #0]
3418c14c:	4611      	mov	r1, r2
3418c14e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c150:	0212      	lsls	r2, r2, #8
3418c152:	440a      	add	r2, r1
3418c154:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c158:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418c15a:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418c15c:	68fa      	ldr	r2, [r7, #12]
3418c15e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c160:	2134      	movs	r1, #52	@ 0x34
3418c162:	fb01 f303 	mul.w	r3, r1, r3
3418c166:	4413      	add	r3, r2
3418c168:	3360      	adds	r3, #96	@ 0x60
3418c16a:	681b      	ldr	r3, [r3, #0]
3418c16c:	697a      	ldr	r2, [r7, #20]
3418c16e:	fb02 f303 	mul.w	r3, r2, r3
3418c172:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418c176:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c178:	68f9      	ldr	r1, [r7, #12]
3418c17a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c17c:	2034      	movs	r0, #52	@ 0x34
3418c17e:	fb00 f303 	mul.w	r3, r0, r3
3418c182:	440b      	add	r3, r1
3418c184:	333c      	adds	r3, #60	@ 0x3c
3418c186:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3418c188:	68f8      	ldr	r0, [r7, #12]
3418c18a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c18c:	2434      	movs	r4, #52	@ 0x34
3418c18e:	fb04 f303 	mul.w	r3, r4, r3
3418c192:	4403      	add	r3, r0
3418c194:	3338      	adds	r3, #56	@ 0x38
3418c196:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c198:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3418c19a:	6979      	ldr	r1, [r7, #20]
3418c19c:	fb01 f303 	mul.w	r3, r1, r3
3418c1a0:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3418c1a2:	68f9      	ldr	r1, [r7, #12]
3418c1a4:	6809      	ldr	r1, [r1, #0]
3418c1a6:	4608      	mov	r0, r1
3418c1a8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c1aa:	0209      	lsls	r1, r1, #8
3418c1ac:	4401      	add	r1, r0
3418c1ae:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418c1b2:	4313      	orrs	r3, r2
3418c1b4:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418c1b6:	68fa      	ldr	r2, [r7, #12]
3418c1b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c1ba:	2134      	movs	r1, #52	@ 0x34
3418c1bc:	fb01 f303 	mul.w	r3, r1, r3
3418c1c0:	4413      	add	r3, r2
3418c1c2:	3364      	adds	r3, #100	@ 0x64
3418c1c4:	681b      	ldr	r3, [r3, #0]
3418c1c6:	68fa      	ldr	r2, [r7, #12]
3418c1c8:	6812      	ldr	r2, [r2, #0]
3418c1ca:	4611      	mov	r1, r2
3418c1cc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c1ce:	0212      	lsls	r2, r2, #8
3418c1d0:	440a      	add	r2, r1
3418c1d2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c1d6:	085b      	lsrs	r3, r3, #1
3418c1d8:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418c1da:	e0bf      	b.n	3418c35c <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c1dc:	68fa      	ldr	r2, [r7, #12]
3418c1de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c1e0:	2134      	movs	r1, #52	@ 0x34
3418c1e2:	fb01 f303 	mul.w	r3, r1, r3
3418c1e6:	4413      	add	r3, r2
3418c1e8:	333c      	adds	r3, #60	@ 0x3c
3418c1ea:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c1ec:	68f9      	ldr	r1, [r7, #12]
3418c1ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c1f0:	2034      	movs	r0, #52	@ 0x34
3418c1f2:	fb00 f303 	mul.w	r3, r0, r3
3418c1f6:	440b      	add	r3, r1
3418c1f8:	3338      	adds	r3, #56	@ 0x38
3418c1fa:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c1fc:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c1fe:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c200:	697a      	ldr	r2, [r7, #20]
3418c202:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c206:	68f9      	ldr	r1, [r7, #12]
3418c208:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c20a:	2034      	movs	r0, #52	@ 0x34
3418c20c:	fb00 f202 	mul.w	r2, r0, r2
3418c210:	440a      	add	r2, r1
3418c212:	3244      	adds	r2, #68	@ 0x44
3418c214:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c216:	68f8      	ldr	r0, [r7, #12]
3418c218:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c21a:	2434      	movs	r4, #52	@ 0x34
3418c21c:	fb04 f202 	mul.w	r2, r4, r2
3418c220:	4402      	add	r2, r0
3418c222:	3240      	adds	r2, #64	@ 0x40
3418c224:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c226:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c228:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c22a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418c22e:	68bb      	ldr	r3, [r7, #8]
3418c230:	4413      	add	r3, r2
3418c232:	68fa      	ldr	r2, [r7, #12]
3418c234:	6812      	ldr	r2, [r2, #0]
3418c236:	4611      	mov	r1, r2
3418c238:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c23a:	0212      	lsls	r2, r2, #8
3418c23c:	440a      	add	r2, r1
3418c23e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c242:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3418c244:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c246:	68fa      	ldr	r2, [r7, #12]
3418c248:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c24a:	2134      	movs	r1, #52	@ 0x34
3418c24c:	fb01 f303 	mul.w	r3, r1, r3
3418c250:	4413      	add	r3, r2
3418c252:	333c      	adds	r3, #60	@ 0x3c
3418c254:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c256:	68f9      	ldr	r1, [r7, #12]
3418c258:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c25a:	2034      	movs	r0, #52	@ 0x34
3418c25c:	fb00 f303 	mul.w	r3, r0, r3
3418c260:	440b      	add	r3, r1
3418c262:	3338      	adds	r3, #56	@ 0x38
3418c264:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c266:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c268:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c26a:	697a      	ldr	r2, [r7, #20]
3418c26c:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c270:	68f9      	ldr	r1, [r7, #12]
3418c272:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c274:	2034      	movs	r0, #52	@ 0x34
3418c276:	fb00 f202 	mul.w	r2, r0, r2
3418c27a:	440a      	add	r2, r1
3418c27c:	3244      	adds	r2, #68	@ 0x44
3418c27e:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c280:	68f8      	ldr	r0, [r7, #12]
3418c282:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c284:	2434      	movs	r4, #52	@ 0x34
3418c286:	fb04 f202 	mul.w	r2, r4, r2
3418c28a:	4402      	add	r2, r0
3418c28c:	3240      	adds	r2, #64	@ 0x40
3418c28e:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3418c290:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c292:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3418c294:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418c298:	687b      	ldr	r3, [r7, #4]
3418c29a:	4413      	add	r3, r2
3418c29c:	68fa      	ldr	r2, [r7, #12]
3418c29e:	6812      	ldr	r2, [r2, #0]
3418c2a0:	4611      	mov	r1, r2
3418c2a2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c2a4:	0212      	lsls	r2, r2, #8
3418c2a6:	440a      	add	r2, r1
3418c2a8:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3418c2ac:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3418c2ae:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418c2b0:	68fa      	ldr	r2, [r7, #12]
3418c2b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c2b4:	2134      	movs	r1, #52	@ 0x34
3418c2b6:	fb01 f303 	mul.w	r3, r1, r3
3418c2ba:	4413      	add	r3, r2
3418c2bc:	3360      	adds	r3, #96	@ 0x60
3418c2be:	681b      	ldr	r3, [r3, #0]
3418c2c0:	085b      	lsrs	r3, r3, #1
3418c2c2:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418c2c6:	697a      	ldr	r2, [r7, #20]
3418c2c8:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
3418c2cc:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c2ce:	68f9      	ldr	r1, [r7, #12]
3418c2d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c2d2:	2034      	movs	r0, #52	@ 0x34
3418c2d4:	fb00 f303 	mul.w	r3, r0, r3
3418c2d8:	440b      	add	r3, r1
3418c2da:	333c      	adds	r3, #60	@ 0x3c
3418c2dc:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418c2de:	68f8      	ldr	r0, [r7, #12]
3418c2e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c2e2:	2434      	movs	r4, #52	@ 0x34
3418c2e4:	fb04 f303 	mul.w	r3, r4, r3
3418c2e8:	4403      	add	r3, r0
3418c2ea:	3338      	adds	r3, #56	@ 0x38
3418c2ec:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c2ee:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3418c2f0:	085b      	lsrs	r3, r3, #1
3418c2f2:	6979      	ldr	r1, [r7, #20]
3418c2f4:	fb01 f303 	mul.w	r3, r1, r3
3418c2f8:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418c2fa:	68f9      	ldr	r1, [r7, #12]
3418c2fc:	6809      	ldr	r1, [r1, #0]
3418c2fe:	4608      	mov	r0, r1
3418c300:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c302:	0209      	lsls	r1, r1, #8
3418c304:	4401      	add	r1, r0
3418c306:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
3418c30a:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3418c30c:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
3418c30e:	68fb      	ldr	r3, [r7, #12]
3418c310:	681b      	ldr	r3, [r3, #0]
3418c312:	461a      	mov	r2, r3
3418c314:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c316:	021b      	lsls	r3, r3, #8
3418c318:	4413      	add	r3, r2
3418c31a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c31e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3418c320:	68fa      	ldr	r2, [r7, #12]
3418c322:	6812      	ldr	r2, [r2, #0]
3418c324:	4611      	mov	r1, r2
3418c326:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c328:	0212      	lsls	r2, r2, #8
3418c32a:	440a      	add	r2, r1
3418c32c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c330:	0c1b      	lsrs	r3, r3, #16
3418c332:	041b      	lsls	r3, r3, #16
3418c334:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3418c336:	68fa      	ldr	r2, [r7, #12]
3418c338:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c33a:	2134      	movs	r1, #52	@ 0x34
3418c33c:	fb01 f303 	mul.w	r3, r1, r3
3418c340:	4413      	add	r3, r2
3418c342:	3364      	adds	r3, #100	@ 0x64
3418c344:	681b      	ldr	r3, [r3, #0]
3418c346:	68fa      	ldr	r2, [r7, #12]
3418c348:	6812      	ldr	r2, [r2, #0]
3418c34a:	4611      	mov	r1, r2
3418c34c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c34e:	0212      	lsls	r2, r2, #8
3418c350:	440a      	add	r2, r1
3418c352:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c356:	085b      	lsrs	r3, r3, #1
3418c358:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3418c35a:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418c35c:	68fa      	ldr	r2, [r7, #12]
3418c35e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c360:	2134      	movs	r1, #52	@ 0x34
3418c362:	fb01 f303 	mul.w	r3, r1, r3
3418c366:	4413      	add	r3, r2
3418c368:	3360      	adds	r3, #96	@ 0x60
3418c36a:	681b      	ldr	r3, [r3, #0]
3418c36c:	697a      	ldr	r2, [r7, #20]
3418c36e:	fb02 f303 	mul.w	r3, r2, r3
3418c372:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3418c376:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c378:	68f9      	ldr	r1, [r7, #12]
3418c37a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c37c:	2034      	movs	r0, #52	@ 0x34
3418c37e:	fb00 f303 	mul.w	r3, r0, r3
3418c382:	440b      	add	r3, r1
3418c384:	333c      	adds	r3, #60	@ 0x3c
3418c386:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418c388:	68f8      	ldr	r0, [r7, #12]
3418c38a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c38c:	2434      	movs	r4, #52	@ 0x34
3418c38e:	fb04 f303 	mul.w	r3, r4, r3
3418c392:	4403      	add	r3, r0
3418c394:	3338      	adds	r3, #56	@ 0x38
3418c396:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3418c398:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3418c39a:	6979      	ldr	r1, [r7, #20]
3418c39c:	fb01 f303 	mul.w	r3, r1, r3
3418c3a0:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3418c3a2:	68f9      	ldr	r1, [r7, #12]
3418c3a4:	6809      	ldr	r1, [r1, #0]
3418c3a6:	4608      	mov	r0, r1
3418c3a8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3418c3aa:	0209      	lsls	r1, r1, #8
3418c3ac:	4401      	add	r1, r0
3418c3ae:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3418c3b2:	4313      	orrs	r3, r2
3418c3b4:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3418c3b6:	68fb      	ldr	r3, [r7, #12]
3418c3b8:	681b      	ldr	r3, [r3, #0]
3418c3ba:	461a      	mov	r2, r3
3418c3bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c3be:	021b      	lsls	r3, r3, #8
3418c3c0:	4413      	add	r3, r2
3418c3c2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c3c6:	68db      	ldr	r3, [r3, #12]
3418c3c8:	68fa      	ldr	r2, [r7, #12]
3418c3ca:	6812      	ldr	r2, [r2, #0]
3418c3cc:	4611      	mov	r1, r2
3418c3ce:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3418c3d0:	0212      	lsls	r2, r2, #8
3418c3d2:	440a      	add	r2, r1
3418c3d4:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c3d8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418c3dc:	f043 0301 	orr.w	r3, r3, #1
3418c3e0:	60d3      	str	r3, [r2, #12]
}
3418c3e2:	bf00      	nop
3418c3e4:	371c      	adds	r7, #28
3418c3e6:	46bd      	mov	sp, r7
3418c3e8:	bcb0      	pop	{r4, r5, r7}
3418c3ea:	4770      	bx	lr

3418c3ec <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3418c3ec:	b480      	push	{r7}
3418c3ee:	b087      	sub	sp, #28
3418c3f0:	af00      	add	r7, sp, #0
3418c3f2:	6078      	str	r0, [r7, #4]
3418c3f4:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
3418c3f6:	687a      	ldr	r2, [r7, #4]
3418c3f8:	683b      	ldr	r3, [r7, #0]
3418c3fa:	2134      	movs	r1, #52	@ 0x34
3418c3fc:	fb01 f303 	mul.w	r3, r1, r3
3418c400:	4413      	add	r3, r2
3418c402:	3369      	adds	r3, #105	@ 0x69
3418c404:	781b      	ldrb	r3, [r3, #0]
3418c406:	021b      	lsls	r3, r3, #8
3418c408:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
3418c40a:	687a      	ldr	r2, [r7, #4]
3418c40c:	683b      	ldr	r3, [r7, #0]
3418c40e:	2134      	movs	r1, #52	@ 0x34
3418c410:	fb01 f303 	mul.w	r3, r1, r3
3418c414:	4413      	add	r3, r2
3418c416:	336a      	adds	r3, #106	@ 0x6a
3418c418:	781b      	ldrb	r3, [r3, #0]
3418c41a:	041b      	lsls	r3, r3, #16
3418c41c:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
3418c41e:	687a      	ldr	r2, [r7, #4]
3418c420:	683b      	ldr	r3, [r7, #0]
3418c422:	2134      	movs	r1, #52	@ 0x34
3418c424:	fb01 f303 	mul.w	r3, r1, r3
3418c428:	4413      	add	r3, r2
3418c42a:	3350      	adds	r3, #80	@ 0x50
3418c42c:	681b      	ldr	r3, [r3, #0]
3418c42e:	061b      	lsls	r3, r3, #24
3418c430:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3418c432:	687a      	ldr	r2, [r7, #4]
3418c434:	683b      	ldr	r3, [r7, #0]
3418c436:	2134      	movs	r1, #52	@ 0x34
3418c438:	fb01 f303 	mul.w	r3, r1, r3
3418c43c:	4413      	add	r3, r2
3418c43e:	3368      	adds	r3, #104	@ 0x68
3418c440:	781b      	ldrb	r3, [r3, #0]
3418c442:	461a      	mov	r2, r3
3418c444:	697b      	ldr	r3, [r7, #20]
3418c446:	431a      	orrs	r2, r3
3418c448:	693b      	ldr	r3, [r7, #16]
3418c44a:	431a      	orrs	r2, r3
3418c44c:	687b      	ldr	r3, [r7, #4]
3418c44e:	681b      	ldr	r3, [r3, #0]
3418c450:	4619      	mov	r1, r3
3418c452:	683b      	ldr	r3, [r7, #0]
3418c454:	021b      	lsls	r3, r3, #8
3418c456:	440b      	add	r3, r1
3418c458:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c45c:	4619      	mov	r1, r3
3418c45e:	68fb      	ldr	r3, [r7, #12]
3418c460:	4313      	orrs	r3, r2
3418c462:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3418c464:	687b      	ldr	r3, [r7, #4]
3418c466:	681b      	ldr	r3, [r3, #0]
3418c468:	461a      	mov	r2, r3
3418c46a:	683b      	ldr	r3, [r7, #0]
3418c46c:	021b      	lsls	r3, r3, #8
3418c46e:	4413      	add	r3, r2
3418c470:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c474:	6a1b      	ldr	r3, [r3, #32]
3418c476:	687a      	ldr	r2, [r7, #4]
3418c478:	6812      	ldr	r2, [r2, #0]
3418c47a:	4611      	mov	r1, r2
3418c47c:	683a      	ldr	r2, [r7, #0]
3418c47e:	0212      	lsls	r2, r2, #8
3418c480:	440a      	add	r2, r1
3418c482:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3418c486:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3418c48a:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
3418c48c:	687b      	ldr	r3, [r7, #4]
3418c48e:	681b      	ldr	r3, [r3, #0]
3418c490:	461a      	mov	r2, r3
3418c492:	683b      	ldr	r3, [r7, #0]
3418c494:	021b      	lsls	r3, r3, #8
3418c496:	4413      	add	r3, r2
3418c498:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c49c:	4618      	mov	r0, r3
3418c49e:	687a      	ldr	r2, [r7, #4]
3418c4a0:	683b      	ldr	r3, [r7, #0]
3418c4a2:	2134      	movs	r1, #52	@ 0x34
3418c4a4:	fb01 f303 	mul.w	r3, r1, r3
3418c4a8:	4413      	add	r3, r2
3418c4aa:	334c      	adds	r3, #76	@ 0x4c
3418c4ac:	681b      	ldr	r3, [r3, #0]
3418c4ae:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
3418c4b0:	687b      	ldr	r3, [r7, #4]
3418c4b2:	681b      	ldr	r3, [r3, #0]
3418c4b4:	461a      	mov	r2, r3
3418c4b6:	683b      	ldr	r3, [r7, #0]
3418c4b8:	021b      	lsls	r3, r3, #8
3418c4ba:	4413      	add	r3, r2
3418c4bc:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c4c0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418c4c2:	687b      	ldr	r3, [r7, #4]
3418c4c4:	681b      	ldr	r3, [r3, #0]
3418c4c6:	4619      	mov	r1, r3
3418c4c8:	683b      	ldr	r3, [r7, #0]
3418c4ca:	021b      	lsls	r3, r3, #8
3418c4cc:	440b      	add	r3, r1
3418c4ce:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c4d2:	4619      	mov	r1, r3
3418c4d4:	4b19      	ldr	r3, [pc, #100]	@ (3418c53c <LTDC_SetCompositionConfig+0x150>)
3418c4d6:	4013      	ands	r3, r2
3418c4d8:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3418c4da:	687b      	ldr	r3, [r7, #4]
3418c4dc:	681b      	ldr	r3, [r3, #0]
3418c4de:	461a      	mov	r2, r3
3418c4e0:	683b      	ldr	r3, [r7, #0]
3418c4e2:	021b      	lsls	r3, r3, #8
3418c4e4:	4413      	add	r3, r2
3418c4e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c4ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418c4ec:	0c1b      	lsrs	r3, r3, #16
3418c4ee:	041b      	lsls	r3, r3, #16
3418c4f0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418c4f4:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418c4f6:	687a      	ldr	r2, [r7, #4]
3418c4f8:	683b      	ldr	r3, [r7, #0]
3418c4fa:	2134      	movs	r1, #52	@ 0x34
3418c4fc:	fb01 f303 	mul.w	r3, r1, r3
3418c500:	4413      	add	r3, r2
3418c502:	3354      	adds	r3, #84	@ 0x54
3418c504:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3418c506:	6879      	ldr	r1, [r7, #4]
3418c508:	683b      	ldr	r3, [r7, #0]
3418c50a:	2034      	movs	r0, #52	@ 0x34
3418c50c:	fb00 f303 	mul.w	r3, r0, r3
3418c510:	440b      	add	r3, r1
3418c512:	3358      	adds	r3, #88	@ 0x58
3418c514:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418c516:	431a      	orrs	r2, r3
3418c518:	687b      	ldr	r3, [r7, #4]
3418c51a:	681b      	ldr	r3, [r3, #0]
3418c51c:	4619      	mov	r1, r3
3418c51e:	683b      	ldr	r3, [r7, #0]
3418c520:	021b      	lsls	r3, r3, #8
3418c522:	440b      	add	r3, r1
3418c524:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c528:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3418c52a:	697b      	ldr	r3, [r7, #20]
3418c52c:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3418c52e:	628b      	str	r3, [r1, #40]	@ 0x28
}
3418c530:	bf00      	nop
3418c532:	371c      	adds	r7, #28
3418c534:	46bd      	mov	sp, r7
3418c536:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c53a:	4770      	bx	lr
3418c53c:	fffef8f8 	.word	0xfffef8f8

3418c540 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3418c540:	b480      	push	{r7}
3418c542:	b08d      	sub	sp, #52	@ 0x34
3418c544:	af00      	add	r7, sp, #0
3418c546:	6078      	str	r0, [r7, #4]
3418c548:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
3418c54a:	2300      	movs	r3, #0
3418c54c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
3418c54e:	2300      	movs	r3, #0
3418c550:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
3418c552:	2300      	movs	r3, #0
3418c554:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
3418c556:	2300      	movs	r3, #0
3418c558:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
3418c55a:	2300      	movs	r3, #0
3418c55c:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
3418c55e:	2300      	movs	r3, #0
3418c560:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
3418c562:	2300      	movs	r3, #0
3418c564:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
3418c566:	2300      	movs	r3, #0
3418c568:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
3418c56a:	2300      	movs	r3, #0
3418c56c:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418c56e:	687a      	ldr	r2, [r7, #4]
3418c570:	683b      	ldr	r3, [r7, #0]
3418c572:	2134      	movs	r1, #52	@ 0x34
3418c574:	fb01 f303 	mul.w	r3, r1, r3
3418c578:	4413      	add	r3, r2
3418c57a:	3348      	adds	r3, #72	@ 0x48
3418c57c:	681b      	ldr	r3, [r3, #0]
3418c57e:	3b07      	subs	r3, #7
3418c580:	2b04      	cmp	r3, #4
3418c582:	d86c      	bhi.n	3418c65e <LTDC_SetPredefFormat+0x11e>
3418c584:	a201      	add	r2, pc, #4	@ (adr r2, 3418c58c <LTDC_SetPredefFormat+0x4c>)
3418c586:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3418c58a:	bf00      	nop
3418c58c:	3418c5a1 	.word	0x3418c5a1
3418c590:	3418c5c7 	.word	0x3418c5c7
3418c594:	3418c5ed 	.word	0x3418c5ed
3418c598:	3418c613 	.word	0x3418c613
3418c59c:	3418c639 	.word	0x3418c639
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
3418c5a0:	2302      	movs	r3, #2
3418c5a2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
3418c5a4:	2301      	movs	r3, #1
3418c5a6:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
3418c5a8:	230f      	movs	r3, #15
3418c5aa:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
3418c5ac:	2305      	movs	r3, #5
3418c5ae:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
3418c5b0:	230a      	movs	r3, #10
3418c5b2:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
3418c5b4:	2305      	movs	r3, #5
3418c5b6:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
3418c5b8:	2305      	movs	r3, #5
3418c5ba:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
3418c5bc:	2305      	movs	r3, #5
3418c5be:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418c5c0:	2300      	movs	r3, #0
3418c5c2:	617b      	str	r3, [r7, #20]
      break;
3418c5c4:	e04c      	b.n	3418c660 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
3418c5c6:	2302      	movs	r3, #2
3418c5c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3418c5ca:	2304      	movs	r3, #4
3418c5cc:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
3418c5ce:	230c      	movs	r3, #12
3418c5d0:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3418c5d2:	2304      	movs	r3, #4
3418c5d4:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
3418c5d6:	2308      	movs	r3, #8
3418c5d8:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3418c5da:	2304      	movs	r3, #4
3418c5dc:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
3418c5de:	2304      	movs	r3, #4
3418c5e0:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3418c5e2:	2304      	movs	r3, #4
3418c5e4:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418c5e6:	2300      	movs	r3, #0
3418c5e8:	617b      	str	r3, [r7, #20]
      break;
3418c5ea:	e039      	b.n	3418c660 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
3418c5ec:	2301      	movs	r3, #1
3418c5ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
3418c5f0:	2300      	movs	r3, #0
3418c5f2:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
3418c5f4:	2300      	movs	r3, #0
3418c5f6:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3418c5f8:	2308      	movs	r3, #8
3418c5fa:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418c5fc:	2300      	movs	r3, #0
3418c5fe:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3418c600:	2308      	movs	r3, #8
3418c602:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418c604:	2300      	movs	r3, #0
3418c606:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3418c608:	2308      	movs	r3, #8
3418c60a:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418c60c:	2300      	movs	r3, #0
3418c60e:	617b      	str	r3, [r7, #20]
      break;
3418c610:	e026      	b.n	3418c660 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
3418c612:	2301      	movs	r3, #1
3418c614:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3418c616:	2304      	movs	r3, #4
3418c618:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
3418c61a:	2304      	movs	r3, #4
3418c61c:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3418c61e:	2304      	movs	r3, #4
3418c620:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418c622:	2300      	movs	r3, #0
3418c624:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3418c626:	2304      	movs	r3, #4
3418c628:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418c62a:	2300      	movs	r3, #0
3418c62c:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3418c62e:	2304      	movs	r3, #4
3418c630:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418c632:	2300      	movs	r3, #0
3418c634:	617b      	str	r3, [r7, #20]
      break;
3418c636:	e013      	b.n	3418c660 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
3418c638:	2302      	movs	r3, #2
3418c63a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
3418c63c:	2308      	movs	r3, #8
3418c63e:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
3418c640:	2308      	movs	r3, #8
3418c642:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3418c644:	2308      	movs	r3, #8
3418c646:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3418c648:	2300      	movs	r3, #0
3418c64a:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3418c64c:	2308      	movs	r3, #8
3418c64e:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3418c650:	2300      	movs	r3, #0
3418c652:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3418c654:	2308      	movs	r3, #8
3418c656:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3418c658:	2300      	movs	r3, #0
3418c65a:	617b      	str	r3, [r7, #20]
      break;
3418c65c:	e000      	b.n	3418c660 <LTDC_SetPredefFormat+0x120>
    default:
      break;
3418c65e:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3418c660:	687a      	ldr	r2, [r7, #4]
3418c662:	683b      	ldr	r3, [r7, #0]
3418c664:	2134      	movs	r1, #52	@ 0x34
3418c666:	fb01 f303 	mul.w	r3, r1, r3
3418c66a:	4413      	add	r3, r2
3418c66c:	3348      	adds	r3, #72	@ 0x48
3418c66e:	681b      	ldr	r3, [r3, #0]
3418c670:	2b06      	cmp	r3, #6
3418c672:	d903      	bls.n	3418c67c <LTDC_SetPredefFormat+0x13c>
3418c674:	3b07      	subs	r3, #7
3418c676:	2b04      	cmp	r3, #4
3418c678:	d860      	bhi.n	3418c73c <LTDC_SetPredefFormat+0x1fc>
3418c67a:	e028      	b.n	3418c6ce <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3418c67c:	687b      	ldr	r3, [r7, #4]
3418c67e:	681b      	ldr	r3, [r3, #0]
3418c680:	461a      	mov	r2, r3
3418c682:	683b      	ldr	r3, [r7, #0]
3418c684:	021b      	lsls	r3, r3, #8
3418c686:	4413      	add	r3, r2
3418c688:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c68c:	4618      	mov	r0, r3
3418c68e:	687a      	ldr	r2, [r7, #4]
3418c690:	683b      	ldr	r3, [r7, #0]
3418c692:	2134      	movs	r1, #52	@ 0x34
3418c694:	fb01 f303 	mul.w	r3, r1, r3
3418c698:	4413      	add	r3, r2
3418c69a:	3348      	adds	r3, #72	@ 0x48
3418c69c:	681b      	ldr	r3, [r3, #0]
3418c69e:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
3418c6a0:	687b      	ldr	r3, [r7, #4]
3418c6a2:	681b      	ldr	r3, [r3, #0]
3418c6a4:	461a      	mov	r2, r3
3418c6a6:	683b      	ldr	r3, [r7, #0]
3418c6a8:	021b      	lsls	r3, r3, #8
3418c6aa:	4413      	add	r3, r2
3418c6ac:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c6b0:	461a      	mov	r2, r3
3418c6b2:	2300      	movs	r3, #0
3418c6b4:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
3418c6b6:	687b      	ldr	r3, [r7, #4]
3418c6b8:	681b      	ldr	r3, [r3, #0]
3418c6ba:	461a      	mov	r2, r3
3418c6bc:	683b      	ldr	r3, [r7, #0]
3418c6be:	021b      	lsls	r3, r3, #8
3418c6c0:	4413      	add	r3, r2
3418c6c2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c6c6:	461a      	mov	r2, r3
3418c6c8:	2300      	movs	r3, #0
3418c6ca:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
3418c6cc:	e037      	b.n	3418c73e <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
3418c6ce:	687b      	ldr	r3, [r7, #4]
3418c6d0:	681b      	ldr	r3, [r3, #0]
3418c6d2:	461a      	mov	r2, r3
3418c6d4:	683b      	ldr	r3, [r7, #0]
3418c6d6:	021b      	lsls	r3, r3, #8
3418c6d8:	4413      	add	r3, r2
3418c6da:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c6de:	461a      	mov	r2, r3
3418c6e0:	2307      	movs	r3, #7
3418c6e2:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418c6e4:	6a3b      	ldr	r3, [r7, #32]
3418c6e6:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3418c6e8:	69fb      	ldr	r3, [r7, #28]
3418c6ea:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418c6ec:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3418c6ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418c6f0:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3418c6f2:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418c6f4:	687b      	ldr	r3, [r7, #4]
3418c6f6:	681b      	ldr	r3, [r3, #0]
3418c6f8:	4619      	mov	r1, r3
3418c6fa:	683b      	ldr	r3, [r7, #0]
3418c6fc:	021b      	lsls	r3, r3, #8
3418c6fe:	440b      	add	r3, r1
3418c700:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c704:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3418c706:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418c708:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3418c70a:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418c70c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418c70e:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3418c710:	69bb      	ldr	r3, [r7, #24]
3418c712:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418c714:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3418c716:	697b      	ldr	r3, [r7, #20]
3418c718:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3418c71a:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3418c71c:	693b      	ldr	r3, [r7, #16]
3418c71e:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3418c720:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418c722:	687b      	ldr	r3, [r7, #4]
3418c724:	681b      	ldr	r3, [r3, #0]
3418c726:	4619      	mov	r1, r3
3418c728:	683b      	ldr	r3, [r7, #0]
3418c72a:	021b      	lsls	r3, r3, #8
3418c72c:	440b      	add	r3, r1
3418c72e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3418c732:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3418c734:	68fb      	ldr	r3, [r7, #12]
3418c736:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3418c738:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
3418c73a:	e000      	b.n	3418c73e <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
3418c73c:	bf00      	nop
  }
}
3418c73e:	bf00      	nop
3418c740:	3734      	adds	r7, #52	@ 0x34
3418c742:	46bd      	mov	sp, r7
3418c744:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c748:	4770      	bx	lr
3418c74a:	bf00      	nop

3418c74c <HAL_PWR_ConfigAttributes>:
  * @param  Attributes : Specifies the available attribute(s).
  *                      This parameter can be one of PWR_ATTRIBUTES.
  * @retval None.
  */
void HAL_PWR_ConfigAttributes(uint32_t Item, uint32_t Attributes)
{
3418c74c:	b480      	push	{r7}
3418c74e:	b083      	sub	sp, #12
3418c750:	af00      	add	r7, sp, #0
3418c752:	6078      	str	r0, [r7, #4]
3418c754:	6039      	str	r1, [r7, #0]
  assert_param(IS_PWR_ITEMS_ATTRIBUTES(Item));
  assert_param(IS_PWR_ATTRIBUTES(Attributes));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Secure item management (TZEN = 1) */
  if ((Attributes & PWR_ITEM_ATTR_SEC_PRIV_MASK) == PWR_ITEM_ATTR_SEC_PRIV_MASK)
3418c756:	683b      	ldr	r3, [r7, #0]
3418c758:	f003 0320 	and.w	r3, r3, #32
3418c75c:	2b00      	cmp	r3, #0
3418c75e:	d01f      	beq.n	3418c7a0 <HAL_PWR_ConfigAttributes+0x54>
  {
    /* Privilege item management */
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
3418c760:	683b      	ldr	r3, [r7, #0]
3418c762:	f003 0322 	and.w	r3, r3, #34	@ 0x22
3418c766:	2b22      	cmp	r3, #34	@ 0x22
3418c768:	d10c      	bne.n	3418c784 <HAL_PWR_ConfigAttributes+0x38>
    {
      SET_BIT(PWR_S->SECCFGR, Item);
3418c76a:	4b21      	ldr	r3, [pc, #132]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c76c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418c76e:	4920      	ldr	r1, [pc, #128]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c770:	687b      	ldr	r3, [r7, #4]
3418c772:	4313      	orrs	r3, r2
3418c774:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3418c776:	4b1e      	ldr	r3, [pc, #120]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c778:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418c77a:	491d      	ldr	r1, [pc, #116]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c77c:	687b      	ldr	r3, [r7, #4]
3418c77e:	4313      	orrs	r3, r2
3418c780:	674b      	str	r3, [r1, #116]	@ 0x74
    {
      CLEAR_BIT(PWR->PRIVCFGR, Item);
    }
  }
#endif /* __ARM_FEATURE_CMSE */
}
3418c782:	e02e      	b.n	3418c7e2 <HAL_PWR_ConfigAttributes+0x96>
      SET_BIT(PWR_S->SECCFGR, Item);
3418c784:	4b1a      	ldr	r3, [pc, #104]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c786:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418c788:	4919      	ldr	r1, [pc, #100]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c78a:	687b      	ldr	r3, [r7, #4]
3418c78c:	4313      	orrs	r3, r2
3418c78e:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3418c790:	4b17      	ldr	r3, [pc, #92]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c792:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418c794:	687b      	ldr	r3, [r7, #4]
3418c796:	43db      	mvns	r3, r3
3418c798:	4915      	ldr	r1, [pc, #84]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c79a:	4013      	ands	r3, r2
3418c79c:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418c79e:	e020      	b.n	3418c7e2 <HAL_PWR_ConfigAttributes+0x96>
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
3418c7a0:	683b      	ldr	r3, [r7, #0]
3418c7a2:	f003 0311 	and.w	r3, r3, #17
3418c7a6:	2b11      	cmp	r3, #17
3418c7a8:	d10d      	bne.n	3418c7c6 <HAL_PWR_ConfigAttributes+0x7a>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3418c7aa:	4b11      	ldr	r3, [pc, #68]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7ac:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418c7ae:	687b      	ldr	r3, [r7, #4]
3418c7b0:	43db      	mvns	r3, r3
3418c7b2:	490f      	ldr	r1, [pc, #60]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7b4:	4013      	ands	r3, r2
3418c7b6:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3418c7b8:	4b0d      	ldr	r3, [pc, #52]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7ba:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418c7bc:	490c      	ldr	r1, [pc, #48]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7be:	687b      	ldr	r3, [r7, #4]
3418c7c0:	4313      	orrs	r3, r2
3418c7c2:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418c7c4:	e00d      	b.n	3418c7e2 <HAL_PWR_ConfigAttributes+0x96>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3418c7c6:	4b0a      	ldr	r3, [pc, #40]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7c8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3418c7ca:	687b      	ldr	r3, [r7, #4]
3418c7cc:	43db      	mvns	r3, r3
3418c7ce:	4908      	ldr	r1, [pc, #32]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7d0:	4013      	ands	r3, r2
3418c7d2:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3418c7d4:	4b06      	ldr	r3, [pc, #24]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7d6:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3418c7d8:	687b      	ldr	r3, [r7, #4]
3418c7da:	43db      	mvns	r3, r3
3418c7dc:	4904      	ldr	r1, [pc, #16]	@ (3418c7f0 <HAL_PWR_ConfigAttributes+0xa4>)
3418c7de:	4013      	ands	r3, r2
3418c7e0:	674b      	str	r3, [r1, #116]	@ 0x74
}
3418c7e2:	bf00      	nop
3418c7e4:	370c      	adds	r7, #12
3418c7e6:	46bd      	mov	sp, r7
3418c7e8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c7ec:	4770      	bx	lr
3418c7ee:	bf00      	nop
3418c7f0:	56024800 	.word	0x56024800

3418c7f4 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
3418c7f4:	b580      	push	{r7, lr}
3418c7f6:	b084      	sub	sp, #16
3418c7f8:	af00      	add	r7, sp, #0
3418c7fa:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
3418c7fc:	4b10      	ldr	r3, [pc, #64]	@ (3418c840 <HAL_PWREx_ConfigSupply+0x4c>)
3418c7fe:	681b      	ldr	r3, [r3, #0]
3418c800:	f023 0204 	bic.w	r2, r3, #4
3418c804:	490e      	ldr	r1, [pc, #56]	@ (3418c840 <HAL_PWREx_ConfigSupply+0x4c>)
3418c806:	687b      	ldr	r3, [r7, #4]
3418c808:	4313      	orrs	r3, r2
3418c80a:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
3418c80c:	f7f9 fe80 	bl	34186510 <HAL_GetTick>
3418c810:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3418c812:	e009      	b.n	3418c828 <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
3418c814:	f7f9 fe7c 	bl	34186510 <HAL_GetTick>
3418c818:	4602      	mov	r2, r0
3418c81a:	68fb      	ldr	r3, [r7, #12]
3418c81c:	1ad3      	subs	r3, r2, r3
3418c81e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
3418c822:	d901      	bls.n	3418c828 <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
3418c824:	2301      	movs	r3, #1
3418c826:	e006      	b.n	3418c836 <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3418c828:	4b05      	ldr	r3, [pc, #20]	@ (3418c840 <HAL_PWREx_ConfigSupply+0x4c>)
3418c82a:	6a1b      	ldr	r3, [r3, #32]
3418c82c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418c830:	2b00      	cmp	r3, #0
3418c832:	d0ef      	beq.n	3418c814 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
3418c834:	2300      	movs	r3, #0
}
3418c836:	4618      	mov	r0, r3
3418c838:	3710      	adds	r7, #16
3418c83a:	46bd      	mov	sp, r7
3418c83c:	bd80      	pop	{r7, pc}
3418c83e:	bf00      	nop
3418c840:	56024800 	.word	0x56024800

3418c844 <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
3418c844:	b480      	push	{r7}
3418c846:	b083      	sub	sp, #12
3418c848:	af00      	add	r7, sp, #0
3418c84a:	6078      	str	r0, [r7, #4]
3418c84c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));

  switch (VddIOPort)
3418c84e:	687b      	ldr	r3, [r7, #4]
3418c850:	2b04      	cmp	r3, #4
3418c852:	d83f      	bhi.n	3418c8d4 <HAL_PWREx_ConfigVddIORange+0x90>
3418c854:	a201      	add	r2, pc, #4	@ (adr r2, 3418c85c <HAL_PWREx_ConfigVddIORange+0x18>)
3418c856:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3418c85a:	bf00      	nop
3418c85c:	3418c871 	.word	0x3418c871
3418c860:	3418c885 	.word	0x3418c885
3418c864:	3418c899 	.word	0x3418c899
3418c868:	3418c8ad 	.word	0x3418c8ad
3418c86c:	3418c8c1 	.word	0x3418c8c1
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
3418c870:	4b1c      	ldr	r3, [pc, #112]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c872:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c874:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418c878:	683b      	ldr	r3, [r7, #0]
3418c87a:	061b      	lsls	r3, r3, #24
3418c87c:	4919      	ldr	r1, [pc, #100]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c87e:	4313      	orrs	r3, r2
3418c880:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418c882:	e028      	b.n	3418c8d6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
3418c884:	4b17      	ldr	r3, [pc, #92]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c886:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c888:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
3418c88c:	683b      	ldr	r3, [r7, #0]
3418c88e:	065b      	lsls	r3, r3, #25
3418c890:	4914      	ldr	r1, [pc, #80]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c892:	4313      	orrs	r3, r2
3418c894:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418c896:	e01e      	b.n	3418c8d6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3418c898:	4b12      	ldr	r3, [pc, #72]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c89a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c89c:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3418c8a0:	683b      	ldr	r3, [r7, #0]
3418c8a2:	069b      	lsls	r3, r3, #26
3418c8a4:	490f      	ldr	r1, [pc, #60]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c8a6:	4313      	orrs	r3, r2
3418c8a8:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3418c8aa:	e014      	b.n	3418c8d6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
3418c8ac:	4b0d      	ldr	r3, [pc, #52]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c8ae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418c8b0:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418c8b4:	683b      	ldr	r3, [r7, #0]
3418c8b6:	061b      	lsls	r3, r3, #24
3418c8b8:	490a      	ldr	r1, [pc, #40]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c8ba:	4313      	orrs	r3, r2
3418c8bc:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
3418c8be:	e00a      	b.n	3418c8d6 <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3418c8c0:	4b08      	ldr	r3, [pc, #32]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c8c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418c8c4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418c8c8:	683b      	ldr	r3, [r7, #0]
3418c8ca:	061b      	lsls	r3, r3, #24
3418c8cc:	4905      	ldr	r1, [pc, #20]	@ (3418c8e4 <HAL_PWREx_ConfigVddIORange+0xa0>)
3418c8ce:	4313      	orrs	r3, r2
3418c8d0:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
3418c8d2:	e000      	b.n	3418c8d6 <HAL_PWREx_ConfigVddIORange+0x92>

    default:
      break;
3418c8d4:	bf00      	nop
  }
}
3418c8d6:	bf00      	nop
3418c8d8:	370c      	adds	r7, #12
3418c8da:	46bd      	mov	sp, r7
3418c8dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c8e0:	4770      	bx	lr
3418c8e2:	bf00      	nop
3418c8e4:	56024800 	.word	0x56024800

3418c8e8 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
3418c8e8:	b480      	push	{r7}
3418c8ea:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
3418c8ec:	4b05      	ldr	r3, [pc, #20]	@ (3418c904 <HAL_PWREx_EnableVddIO2+0x1c>)
3418c8ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c8f0:	4a04      	ldr	r2, [pc, #16]	@ (3418c904 <HAL_PWREx_EnableVddIO2+0x1c>)
3418c8f2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418c8f6:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3418c8f8:	bf00      	nop
3418c8fa:	46bd      	mov	sp, r7
3418c8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c900:	4770      	bx	lr
3418c902:	bf00      	nop
3418c904:	56024800 	.word	0x56024800

3418c908 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
3418c908:	b480      	push	{r7}
3418c90a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
3418c90c:	4b05      	ldr	r3, [pc, #20]	@ (3418c924 <HAL_PWREx_EnableVddIO3+0x1c>)
3418c90e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418c910:	4a04      	ldr	r2, [pc, #16]	@ (3418c924 <HAL_PWREx_EnableVddIO3+0x1c>)
3418c912:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3418c916:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3418c918:	bf00      	nop
3418c91a:	46bd      	mov	sp, r7
3418c91c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c920:	4770      	bx	lr
3418c922:	bf00      	nop
3418c924:	56024800 	.word	0x56024800

3418c928 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
3418c928:	b480      	push	{r7}
3418c92a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
3418c92c:	4b05      	ldr	r3, [pc, #20]	@ (3418c944 <HAL_PWREx_EnableVddIO4+0x1c>)
3418c92e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418c930:	4a04      	ldr	r2, [pc, #16]	@ (3418c944 <HAL_PWREx_EnableVddIO4+0x1c>)
3418c932:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418c936:	6353      	str	r3, [r2, #52]	@ 0x34
}
3418c938:	bf00      	nop
3418c93a:	46bd      	mov	sp, r7
3418c93c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c940:	4770      	bx	lr
3418c942:	bf00      	nop
3418c944:	56024800 	.word	0x56024800

3418c948 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
3418c948:	b480      	push	{r7}
3418c94a:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
3418c94c:	4b05      	ldr	r3, [pc, #20]	@ (3418c964 <HAL_PWREx_EnableVddIO5+0x1c>)
3418c94e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418c950:	4a04      	ldr	r2, [pc, #16]	@ (3418c964 <HAL_PWREx_EnableVddIO5+0x1c>)
3418c952:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3418c956:	6393      	str	r3, [r2, #56]	@ 0x38
}
3418c958:	bf00      	nop
3418c95a:	46bd      	mov	sp, r7
3418c95c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c960:	4770      	bx	lr
3418c962:	bf00      	nop
3418c964:	56024800 	.word	0x56024800

3418c968 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
3418c968:	b480      	push	{r7}
3418c96a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3418c96c:	4b06      	ldr	r3, [pc, #24]	@ (3418c988 <LL_RCC_HSE_IsReady+0x20>)
3418c96e:	685b      	ldr	r3, [r3, #4]
3418c970:	f003 0310 	and.w	r3, r3, #16
3418c974:	2b00      	cmp	r3, #0
3418c976:	d001      	beq.n	3418c97c <LL_RCC_HSE_IsReady+0x14>
3418c978:	2301      	movs	r3, #1
3418c97a:	e000      	b.n	3418c97e <LL_RCC_HSE_IsReady+0x16>
3418c97c:	2300      	movs	r3, #0
}
3418c97e:	4618      	mov	r0, r3
3418c980:	46bd      	mov	sp, r7
3418c982:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c986:	4770      	bx	lr
3418c988:	56028000 	.word	0x56028000

3418c98c <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
3418c98c:	b480      	push	{r7}
3418c98e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3418c990:	4b04      	ldr	r3, [pc, #16]	@ (3418c9a4 <LL_RCC_HSI_Enable+0x18>)
3418c992:	2208      	movs	r2, #8
3418c994:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418c998:	bf00      	nop
3418c99a:	46bd      	mov	sp, r7
3418c99c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c9a0:	4770      	bx	lr
3418c9a2:	bf00      	nop
3418c9a4:	56028000 	.word	0x56028000

3418c9a8 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
3418c9a8:	b480      	push	{r7}
3418c9aa:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
3418c9ac:	4b05      	ldr	r3, [pc, #20]	@ (3418c9c4 <LL_RCC_HSI_Disable+0x1c>)
3418c9ae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418c9b2:	461a      	mov	r2, r3
3418c9b4:	2308      	movs	r3, #8
3418c9b6:	6013      	str	r3, [r2, #0]
}
3418c9b8:	bf00      	nop
3418c9ba:	46bd      	mov	sp, r7
3418c9bc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c9c0:	4770      	bx	lr
3418c9c2:	bf00      	nop
3418c9c4:	56028000 	.word	0x56028000

3418c9c8 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
3418c9c8:	b480      	push	{r7}
3418c9ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418c9cc:	4b06      	ldr	r3, [pc, #24]	@ (3418c9e8 <LL_RCC_HSI_IsReady+0x20>)
3418c9ce:	685b      	ldr	r3, [r3, #4]
3418c9d0:	f003 0308 	and.w	r3, r3, #8
3418c9d4:	2b00      	cmp	r3, #0
3418c9d6:	d001      	beq.n	3418c9dc <LL_RCC_HSI_IsReady+0x14>
3418c9d8:	2301      	movs	r3, #1
3418c9da:	e000      	b.n	3418c9de <LL_RCC_HSI_IsReady+0x16>
3418c9dc:	2300      	movs	r3, #0
}
3418c9de:	4618      	mov	r0, r3
3418c9e0:	46bd      	mov	sp, r7
3418c9e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418c9e6:	4770      	bx	lr
3418c9e8:	56028000 	.word	0x56028000

3418c9ec <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
3418c9ec:	b480      	push	{r7}
3418c9ee:	b083      	sub	sp, #12
3418c9f0:	af00      	add	r7, sp, #0
3418c9f2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
3418c9f4:	4b06      	ldr	r3, [pc, #24]	@ (3418ca10 <LL_RCC_HSI_SetDivider+0x24>)
3418c9f6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418c9f8:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
3418c9fc:	4904      	ldr	r1, [pc, #16]	@ (3418ca10 <LL_RCC_HSI_SetDivider+0x24>)
3418c9fe:	687b      	ldr	r3, [r7, #4]
3418ca00:	4313      	orrs	r3, r2
3418ca02:	648b      	str	r3, [r1, #72]	@ 0x48
}
3418ca04:	bf00      	nop
3418ca06:	370c      	adds	r7, #12
3418ca08:	46bd      	mov	sp, r7
3418ca0a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ca0e:	4770      	bx	lr
3418ca10:	56028000 	.word	0x56028000

3418ca14 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
3418ca14:	b480      	push	{r7}
3418ca16:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418ca18:	4b04      	ldr	r3, [pc, #16]	@ (3418ca2c <LL_RCC_HSI_GetDivider+0x18>)
3418ca1a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418ca1c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418ca20:	4618      	mov	r0, r3
3418ca22:	46bd      	mov	sp, r7
3418ca24:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ca28:	4770      	bx	lr
3418ca2a:	bf00      	nop
3418ca2c:	56028000 	.word	0x56028000

3418ca30 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
3418ca30:	b480      	push	{r7}
3418ca32:	b083      	sub	sp, #12
3418ca34:	af00      	add	r7, sp, #0
3418ca36:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
3418ca38:	4b07      	ldr	r3, [pc, #28]	@ (3418ca58 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3418ca3a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418ca3c:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
3418ca40:	687b      	ldr	r3, [r7, #4]
3418ca42:	041b      	lsls	r3, r3, #16
3418ca44:	4904      	ldr	r1, [pc, #16]	@ (3418ca58 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3418ca46:	4313      	orrs	r3, r2
3418ca48:	648b      	str	r3, [r1, #72]	@ 0x48
}
3418ca4a:	bf00      	nop
3418ca4c:	370c      	adds	r7, #12
3418ca4e:	46bd      	mov	sp, r7
3418ca50:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ca54:	4770      	bx	lr
3418ca56:	bf00      	nop
3418ca58:	56028000 	.word	0x56028000

3418ca5c <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
3418ca5c:	b480      	push	{r7}
3418ca5e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3418ca60:	4b04      	ldr	r3, [pc, #16]	@ (3418ca74 <LL_RCC_MSI_Enable+0x18>)
3418ca62:	2204      	movs	r2, #4
3418ca64:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418ca68:	bf00      	nop
3418ca6a:	46bd      	mov	sp, r7
3418ca6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ca70:	4770      	bx	lr
3418ca72:	bf00      	nop
3418ca74:	56028000 	.word	0x56028000

3418ca78 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
3418ca78:	b480      	push	{r7}
3418ca7a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
3418ca7c:	4b05      	ldr	r3, [pc, #20]	@ (3418ca94 <LL_RCC_MSI_Disable+0x1c>)
3418ca7e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418ca82:	461a      	mov	r2, r3
3418ca84:	2304      	movs	r3, #4
3418ca86:	6013      	str	r3, [r2, #0]
}
3418ca88:	bf00      	nop
3418ca8a:	46bd      	mov	sp, r7
3418ca8c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ca90:	4770      	bx	lr
3418ca92:	bf00      	nop
3418ca94:	56028000 	.word	0x56028000

3418ca98 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
3418ca98:	b480      	push	{r7}
3418ca9a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3418ca9c:	4b06      	ldr	r3, [pc, #24]	@ (3418cab8 <LL_RCC_MSI_IsReady+0x20>)
3418ca9e:	685b      	ldr	r3, [r3, #4]
3418caa0:	f003 0304 	and.w	r3, r3, #4
3418caa4:	2b00      	cmp	r3, #0
3418caa6:	d001      	beq.n	3418caac <LL_RCC_MSI_IsReady+0x14>
3418caa8:	2301      	movs	r3, #1
3418caaa:	e000      	b.n	3418caae <LL_RCC_MSI_IsReady+0x16>
3418caac:	2300      	movs	r3, #0
}
3418caae:	4618      	mov	r0, r3
3418cab0:	46bd      	mov	sp, r7
3418cab2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cab6:	4770      	bx	lr
3418cab8:	56028000 	.word	0x56028000

3418cabc <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
3418cabc:	b480      	push	{r7}
3418cabe:	b083      	sub	sp, #12
3418cac0:	af00      	add	r7, sp, #0
3418cac2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3418cac4:	4b06      	ldr	r3, [pc, #24]	@ (3418cae0 <LL_RCC_MSI_SetFrequency+0x24>)
3418cac6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418cac8:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3418cacc:	4904      	ldr	r1, [pc, #16]	@ (3418cae0 <LL_RCC_MSI_SetFrequency+0x24>)
3418cace:	687b      	ldr	r3, [r7, #4]
3418cad0:	4313      	orrs	r3, r2
3418cad2:	644b      	str	r3, [r1, #68]	@ 0x44
}
3418cad4:	bf00      	nop
3418cad6:	370c      	adds	r7, #12
3418cad8:	46bd      	mov	sp, r7
3418cada:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cade:	4770      	bx	lr
3418cae0:	56028000 	.word	0x56028000

3418cae4 <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
3418cae4:	b480      	push	{r7}
3418cae6:	b083      	sub	sp, #12
3418cae8:	af00      	add	r7, sp, #0
3418caea:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
3418caec:	4b07      	ldr	r3, [pc, #28]	@ (3418cb0c <LL_RCC_MSI_SetCalibTrimming+0x28>)
3418caee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418caf0:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
3418caf4:	687b      	ldr	r3, [r7, #4]
3418caf6:	041b      	lsls	r3, r3, #16
3418caf8:	4904      	ldr	r1, [pc, #16]	@ (3418cb0c <LL_RCC_MSI_SetCalibTrimming+0x28>)
3418cafa:	4313      	orrs	r3, r2
3418cafc:	644b      	str	r3, [r1, #68]	@ 0x44
}
3418cafe:	bf00      	nop
3418cb00:	370c      	adds	r7, #12
3418cb02:	46bd      	mov	sp, r7
3418cb04:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cb08:	4770      	bx	lr
3418cb0a:	bf00      	nop
3418cb0c:	56028000 	.word	0x56028000

3418cb10 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
3418cb10:	b480      	push	{r7}
3418cb12:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418cb14:	4b06      	ldr	r3, [pc, #24]	@ (3418cb30 <LL_RCC_LSE_IsReady+0x20>)
3418cb16:	685b      	ldr	r3, [r3, #4]
3418cb18:	f003 0302 	and.w	r3, r3, #2
3418cb1c:	2b00      	cmp	r3, #0
3418cb1e:	d001      	beq.n	3418cb24 <LL_RCC_LSE_IsReady+0x14>
3418cb20:	2301      	movs	r3, #1
3418cb22:	e000      	b.n	3418cb26 <LL_RCC_LSE_IsReady+0x16>
3418cb24:	2300      	movs	r3, #0
}
3418cb26:	4618      	mov	r0, r3
3418cb28:	46bd      	mov	sp, r7
3418cb2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cb2e:	4770      	bx	lr
3418cb30:	56028000 	.word	0x56028000

3418cb34 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
3418cb34:	b480      	push	{r7}
3418cb36:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
3418cb38:	4b04      	ldr	r3, [pc, #16]	@ (3418cb4c <LL_RCC_LSI_Enable+0x18>)
3418cb3a:	2201      	movs	r2, #1
3418cb3c:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3418cb40:	bf00      	nop
3418cb42:	46bd      	mov	sp, r7
3418cb44:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cb48:	4770      	bx	lr
3418cb4a:	bf00      	nop
3418cb4c:	56028000 	.word	0x56028000

3418cb50 <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
3418cb50:	b480      	push	{r7}
3418cb52:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3418cb54:	4b05      	ldr	r3, [pc, #20]	@ (3418cb6c <LL_RCC_LSI_Disable+0x1c>)
3418cb56:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418cb5a:	461a      	mov	r2, r3
3418cb5c:	2301      	movs	r3, #1
3418cb5e:	6013      	str	r3, [r2, #0]
}
3418cb60:	bf00      	nop
3418cb62:	46bd      	mov	sp, r7
3418cb64:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cb68:	4770      	bx	lr
3418cb6a:	bf00      	nop
3418cb6c:	56028000 	.word	0x56028000

3418cb70 <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
3418cb70:	b480      	push	{r7}
3418cb72:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418cb74:	4b04      	ldr	r3, [pc, #16]	@ (3418cb88 <LL_RCC_LSI_IsReady+0x18>)
3418cb76:	685b      	ldr	r3, [r3, #4]
3418cb78:	f003 0301 	and.w	r3, r3, #1
}
3418cb7c:	4618      	mov	r0, r3
3418cb7e:	46bd      	mov	sp, r7
3418cb80:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cb84:	4770      	bx	lr
3418cb86:	bf00      	nop
3418cb88:	56028000 	.word	0x56028000

3418cb8c <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
3418cb8c:	b480      	push	{r7}
3418cb8e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3418cb90:	4b04      	ldr	r3, [pc, #16]	@ (3418cba4 <LL_RCC_GetCpuClkSource+0x18>)
3418cb92:	6a1b      	ldr	r3, [r3, #32]
3418cb94:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3418cb98:	4618      	mov	r0, r3
3418cb9a:	46bd      	mov	sp, r7
3418cb9c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cba0:	4770      	bx	lr
3418cba2:	bf00      	nop
3418cba4:	56028000 	.word	0x56028000

3418cba8 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
3418cba8:	b480      	push	{r7}
3418cbaa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3418cbac:	4b04      	ldr	r3, [pc, #16]	@ (3418cbc0 <LL_RCC_GetSysClkSource+0x18>)
3418cbae:	6a1b      	ldr	r3, [r3, #32]
3418cbb0:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418cbb4:	4618      	mov	r0, r3
3418cbb6:	46bd      	mov	sp, r7
3418cbb8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cbbc:	4770      	bx	lr
3418cbbe:	bf00      	nop
3418cbc0:	56028000 	.word	0x56028000

3418cbc4 <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_AHB_DIV_32
  *         @arg @ref LL_RCC_AHB_DIV_64
  *         @arg @ref LL_RCC_AHB_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
3418cbc4:	b480      	push	{r7}
3418cbc6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3418cbc8:	4b04      	ldr	r3, [pc, #16]	@ (3418cbdc <LL_RCC_GetAHBPrescaler+0x18>)
3418cbca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418cbcc:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3418cbd0:	4618      	mov	r0, r3
3418cbd2:	46bd      	mov	sp, r7
3418cbd4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cbd8:	4770      	bx	lr
3418cbda:	bf00      	nop
3418cbdc:	56028000 	.word	0x56028000

3418cbe0 <LL_RCC_GetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_32
  *         @arg @ref LL_RCC_APB1_DIV_64
  *         @arg @ref LL_RCC_APB1_DIV_128
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
3418cbe0:	b480      	push	{r7}
3418cbe2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418cbe4:	4b04      	ldr	r3, [pc, #16]	@ (3418cbf8 <LL_RCC_GetAPB1Prescaler+0x18>)
3418cbe6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418cbe8:	f003 0307 	and.w	r3, r3, #7
}
3418cbec:	4618      	mov	r0, r3
3418cbee:	46bd      	mov	sp, r7
3418cbf0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cbf4:	4770      	bx	lr
3418cbf6:	bf00      	nop
3418cbf8:	56028000 	.word	0x56028000

3418cbfc <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
3418cbfc:	b480      	push	{r7}
3418cbfe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3418cc00:	4b04      	ldr	r3, [pc, #16]	@ (3418cc14 <LL_RCC_PLL1_GetSource+0x18>)
3418cc02:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418cc06:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418cc0a:	4618      	mov	r0, r3
3418cc0c:	46bd      	mov	sp, r7
3418cc0e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cc12:	4770      	bx	lr
3418cc14:	56028000 	.word	0x56028000

3418cc18 <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
3418cc18:	b480      	push	{r7}
3418cc1a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3418cc1c:	4b07      	ldr	r3, [pc, #28]	@ (3418cc3c <LL_RCC_PLL1_IsReady+0x24>)
3418cc1e:	685b      	ldr	r3, [r3, #4]
3418cc20:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418cc24:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418cc28:	d101      	bne.n	3418cc2e <LL_RCC_PLL1_IsReady+0x16>
3418cc2a:	2301      	movs	r3, #1
3418cc2c:	e000      	b.n	3418cc30 <LL_RCC_PLL1_IsReady+0x18>
3418cc2e:	2300      	movs	r3, #0
}
3418cc30:	4618      	mov	r0, r3
3418cc32:	46bd      	mov	sp, r7
3418cc34:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cc38:	4770      	bx	lr
3418cc3a:	bf00      	nop
3418cc3c:	56028000 	.word	0x56028000

3418cc40 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
3418cc40:	b480      	push	{r7}
3418cc42:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3418cc44:	4b07      	ldr	r3, [pc, #28]	@ (3418cc64 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3418cc46:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418cc4a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418cc4e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418cc52:	d101      	bne.n	3418cc58 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3418cc54:	2301      	movs	r3, #1
3418cc56:	e000      	b.n	3418cc5a <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3418cc58:	2300      	movs	r3, #0
}
3418cc5a:	4618      	mov	r0, r3
3418cc5c:	46bd      	mov	sp, r7
3418cc5e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cc62:	4770      	bx	lr
3418cc64:	56028000 	.word	0x56028000

3418cc68 <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
3418cc68:	b480      	push	{r7}
3418cc6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418cc6c:	4b04      	ldr	r3, [pc, #16]	@ (3418cc80 <LL_RCC_PLL2_GetSource+0x18>)
3418cc6e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418cc72:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418cc76:	4618      	mov	r0, r3
3418cc78:	46bd      	mov	sp, r7
3418cc7a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cc7e:	4770      	bx	lr
3418cc80:	56028000 	.word	0x56028000

3418cc84 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
3418cc84:	b480      	push	{r7}
3418cc86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3418cc88:	4b07      	ldr	r3, [pc, #28]	@ (3418cca8 <LL_RCC_PLL2_IsReady+0x24>)
3418cc8a:	685b      	ldr	r3, [r3, #4]
3418cc8c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418cc90:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418cc94:	d101      	bne.n	3418cc9a <LL_RCC_PLL2_IsReady+0x16>
3418cc96:	2301      	movs	r3, #1
3418cc98:	e000      	b.n	3418cc9c <LL_RCC_PLL2_IsReady+0x18>
3418cc9a:	2300      	movs	r3, #0
}
3418cc9c:	4618      	mov	r0, r3
3418cc9e:	46bd      	mov	sp, r7
3418cca0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cca4:	4770      	bx	lr
3418cca6:	bf00      	nop
3418cca8:	56028000 	.word	0x56028000

3418ccac <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
3418ccac:	b480      	push	{r7}
3418ccae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3418ccb0:	4b07      	ldr	r3, [pc, #28]	@ (3418ccd0 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418ccb2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418ccb6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418ccba:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418ccbe:	d101      	bne.n	3418ccc4 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3418ccc0:	2301      	movs	r3, #1
3418ccc2:	e000      	b.n	3418ccc6 <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418ccc4:	2300      	movs	r3, #0
}
3418ccc6:	4618      	mov	r0, r3
3418ccc8:	46bd      	mov	sp, r7
3418ccca:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ccce:	4770      	bx	lr
3418ccd0:	56028000 	.word	0x56028000

3418ccd4 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3418ccd4:	b480      	push	{r7}
3418ccd6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3418ccd8:	4b04      	ldr	r3, [pc, #16]	@ (3418ccec <LL_RCC_PLL3_GetSource+0x18>)
3418ccda:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418ccde:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418cce2:	4618      	mov	r0, r3
3418cce4:	46bd      	mov	sp, r7
3418cce6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ccea:	4770      	bx	lr
3418ccec:	56028000 	.word	0x56028000

3418ccf0 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
3418ccf0:	b480      	push	{r7}
3418ccf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418ccf4:	4b07      	ldr	r3, [pc, #28]	@ (3418cd14 <LL_RCC_PLL3_IsReady+0x24>)
3418ccf6:	685b      	ldr	r3, [r3, #4]
3418ccf8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418ccfc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3418cd00:	d101      	bne.n	3418cd06 <LL_RCC_PLL3_IsReady+0x16>
3418cd02:	2301      	movs	r3, #1
3418cd04:	e000      	b.n	3418cd08 <LL_RCC_PLL3_IsReady+0x18>
3418cd06:	2300      	movs	r3, #0
}
3418cd08:	4618      	mov	r0, r3
3418cd0a:	46bd      	mov	sp, r7
3418cd0c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cd10:	4770      	bx	lr
3418cd12:	bf00      	nop
3418cd14:	56028000 	.word	0x56028000

3418cd18 <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
3418cd18:	b480      	push	{r7}
3418cd1a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3418cd1c:	4b07      	ldr	r3, [pc, #28]	@ (3418cd3c <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3418cd1e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418cd22:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418cd26:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418cd2a:	d101      	bne.n	3418cd30 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3418cd2c:	2301      	movs	r3, #1
3418cd2e:	e000      	b.n	3418cd32 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3418cd30:	2300      	movs	r3, #0
}
3418cd32:	4618      	mov	r0, r3
3418cd34:	46bd      	mov	sp, r7
3418cd36:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cd3a:	4770      	bx	lr
3418cd3c:	56028000 	.word	0x56028000

3418cd40 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
3418cd40:	b480      	push	{r7}
3418cd42:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3418cd44:	4b04      	ldr	r3, [pc, #16]	@ (3418cd58 <LL_RCC_PLL4_GetSource+0x18>)
3418cd46:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418cd4a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418cd4e:	4618      	mov	r0, r3
3418cd50:	46bd      	mov	sp, r7
3418cd52:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cd56:	4770      	bx	lr
3418cd58:	56028000 	.word	0x56028000

3418cd5c <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
3418cd5c:	b480      	push	{r7}
3418cd5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418cd60:	4b07      	ldr	r3, [pc, #28]	@ (3418cd80 <LL_RCC_PLL4_IsReady+0x24>)
3418cd62:	685b      	ldr	r3, [r3, #4]
3418cd64:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418cd68:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418cd6c:	d101      	bne.n	3418cd72 <LL_RCC_PLL4_IsReady+0x16>
3418cd6e:	2301      	movs	r3, #1
3418cd70:	e000      	b.n	3418cd74 <LL_RCC_PLL4_IsReady+0x18>
3418cd72:	2300      	movs	r3, #0
}
3418cd74:	4618      	mov	r0, r3
3418cd76:	46bd      	mov	sp, r7
3418cd78:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cd7c:	4770      	bx	lr
3418cd7e:	bf00      	nop
3418cd80:	56028000 	.word	0x56028000

3418cd84 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
3418cd84:	b480      	push	{r7}
3418cd86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3418cd88:	4b07      	ldr	r3, [pc, #28]	@ (3418cda8 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3418cd8a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418cd8e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418cd92:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418cd96:	d101      	bne.n	3418cd9c <LL_RCC_PLL4_IsEnabledBypass+0x18>
3418cd98:	2301      	movs	r3, #1
3418cd9a:	e000      	b.n	3418cd9e <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3418cd9c:	2300      	movs	r3, #0
}
3418cd9e:	4618      	mov	r0, r3
3418cda0:	46bd      	mov	sp, r7
3418cda2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cda6:	4770      	bx	lr
3418cda8:	56028000 	.word	0x56028000

3418cdac <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
3418cdac:	b480      	push	{r7}
3418cdae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
3418cdb0:	4b04      	ldr	r3, [pc, #16]	@ (3418cdc4 <LL_RCC_IC1_Enable+0x18>)
3418cdb2:	2201      	movs	r2, #1
3418cdb4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418cdb8:	bf00      	nop
3418cdba:	46bd      	mov	sp, r7
3418cdbc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cdc0:	4770      	bx	lr
3418cdc2:	bf00      	nop
3418cdc4:	56028000 	.word	0x56028000

3418cdc8 <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
3418cdc8:	b480      	push	{r7}
3418cdca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3418cdcc:	4b04      	ldr	r3, [pc, #16]	@ (3418cde0 <LL_RCC_IC1_GetSource+0x18>)
3418cdce:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418cdd2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418cdd6:	4618      	mov	r0, r3
3418cdd8:	46bd      	mov	sp, r7
3418cdda:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cdde:	4770      	bx	lr
3418cde0:	56028000 	.word	0x56028000

3418cde4 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3418cde4:	b480      	push	{r7}
3418cde6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3418cde8:	4b05      	ldr	r3, [pc, #20]	@ (3418ce00 <LL_RCC_IC1_GetDivider+0x1c>)
3418cdea:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418cdee:	0c1b      	lsrs	r3, r3, #16
3418cdf0:	b2db      	uxtb	r3, r3
3418cdf2:	3301      	adds	r3, #1
}
3418cdf4:	4618      	mov	r0, r3
3418cdf6:	46bd      	mov	sp, r7
3418cdf8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418cdfc:	4770      	bx	lr
3418cdfe:	bf00      	nop
3418ce00:	56028000 	.word	0x56028000

3418ce04 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3418ce04:	b480      	push	{r7}
3418ce06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3418ce08:	4b04      	ldr	r3, [pc, #16]	@ (3418ce1c <LL_RCC_IC2_GetSource+0x18>)
3418ce0a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ce0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ce12:	4618      	mov	r0, r3
3418ce14:	46bd      	mov	sp, r7
3418ce16:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ce1a:	4770      	bx	lr
3418ce1c:	56028000 	.word	0x56028000

3418ce20 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
3418ce20:	b480      	push	{r7}
3418ce22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3418ce24:	4b05      	ldr	r3, [pc, #20]	@ (3418ce3c <LL_RCC_IC2_GetDivider+0x1c>)
3418ce26:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418ce2a:	0c1b      	lsrs	r3, r3, #16
3418ce2c:	b2db      	uxtb	r3, r3
3418ce2e:	3301      	adds	r3, #1
}
3418ce30:	4618      	mov	r0, r3
3418ce32:	46bd      	mov	sp, r7
3418ce34:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ce38:	4770      	bx	lr
3418ce3a:	bf00      	nop
3418ce3c:	56028000 	.word	0x56028000

3418ce40 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
3418ce40:	b480      	push	{r7}
3418ce42:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3418ce44:	4b04      	ldr	r3, [pc, #16]	@ (3418ce58 <LL_RCC_IC6_GetSource+0x18>)
3418ce46:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418ce4a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ce4e:	4618      	mov	r0, r3
3418ce50:	46bd      	mov	sp, r7
3418ce52:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ce56:	4770      	bx	lr
3418ce58:	56028000 	.word	0x56028000

3418ce5c <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
3418ce5c:	b480      	push	{r7}
3418ce5e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3418ce60:	4b04      	ldr	r3, [pc, #16]	@ (3418ce74 <LL_RCC_IC11_GetSource+0x18>)
3418ce62:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418ce66:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418ce6a:	4618      	mov	r0, r3
3418ce6c:	46bd      	mov	sp, r7
3418ce6e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ce72:	4770      	bx	lr
3418ce74:	56028000 	.word	0x56028000

3418ce78 <HAL_RCC_OscConfig>:
  * @note   This function activates HSE but does not wait for the startup time defined in the datasheet.
  *         This must be ensured by the application when the HSE is selected as PLL source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
3418ce78:	b580      	push	{r7, lr}
3418ce7a:	b0a2      	sub	sp, #136	@ 0x88
3418ce7c:	af00      	add	r7, sp, #0
3418ce7e:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
3418ce80:	687b      	ldr	r3, [r7, #4]
3418ce82:	2b00      	cmp	r3, #0
3418ce84:	d101      	bne.n	3418ce8a <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
3418ce86:	2301      	movs	r3, #1
3418ce88:	e3d1      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
3418ce8a:	f7ff fe7f 	bl	3418cb8c <LL_RCC_GetCpuClkSource>
3418ce8e:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
3418ce92:	f7ff fe89 	bl	3418cba8 <LL_RCC_GetSysClkSource>
3418ce96:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
3418ce9a:	f7ff feaf 	bl	3418cbfc <LL_RCC_PLL1_GetSource>
3418ce9e:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
3418cea0:	f7ff fee2 	bl	3418cc68 <LL_RCC_PLL2_GetSource>
3418cea4:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
3418cea6:	f7ff ff15 	bl	3418ccd4 <LL_RCC_PLL3_GetSource>
3418ceaa:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
3418ceac:	f7ff ff48 	bl	3418cd40 <LL_RCC_PLL4_GetSource>
3418ceb0:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3418ceb2:	4b91      	ldr	r3, [pc, #580]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418ceb4:	685b      	ldr	r3, [r3, #4]
3418ceb6:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
3418ceb8:	687b      	ldr	r3, [r7, #4]
3418ceba:	681b      	ldr	r3, [r3, #0]
3418cebc:	f003 0301 	and.w	r3, r3, #1
3418cec0:	2b00      	cmp	r3, #0
3418cec2:	f000 80a8 	beq.w	3418d016 <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3418cec6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418ceca:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418cece:	d028      	beq.n	3418cf22 <HAL_RCC_OscConfig+0xaa>
3418ced0:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418ced4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418ced8:	d023      	beq.n	3418cf22 <HAL_RCC_OscConfig+0xaa>
3418ceda:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418cedc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cee0:	d104      	bne.n	3418ceec <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418cee2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418cee4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418cee8:	2b00      	cmp	r3, #0
3418ceea:	d11a      	bne.n	3418cf22 <HAL_RCC_OscConfig+0xaa>
3418ceec:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418ceee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cef2:	d104      	bne.n	3418cefe <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418cef4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418cef6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418cefa:	2b00      	cmp	r3, #0
3418cefc:	d111      	bne.n	3418cf22 <HAL_RCC_OscConfig+0xaa>
3418cefe:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418cf00:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cf04:	d104      	bne.n	3418cf10 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418cf06:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418cf08:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418cf0c:	2b00      	cmp	r3, #0
3418cf0e:	d108      	bne.n	3418cf22 <HAL_RCC_OscConfig+0xaa>
3418cf10:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418cf12:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418cf16:	d10a      	bne.n	3418cf2e <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418cf18:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418cf1a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418cf1e:	2b00      	cmp	r3, #0
3418cf20:	d005      	beq.n	3418cf2e <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3418cf22:	687b      	ldr	r3, [r7, #4]
3418cf24:	685b      	ldr	r3, [r3, #4]
3418cf26:	2b00      	cmp	r3, #0
3418cf28:	d175      	bne.n	3418d016 <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
3418cf2a:	2301      	movs	r3, #1
3418cf2c:	e37f      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3418cf2e:	687b      	ldr	r3, [r7, #4]
3418cf30:	685b      	ldr	r3, [r3, #4]
3418cf32:	2b10      	cmp	r3, #16
3418cf34:	d104      	bne.n	3418cf40 <HAL_RCC_OscConfig+0xc8>
3418cf36:	4b70      	ldr	r3, [pc, #448]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf38:	2210      	movs	r2, #16
3418cf3a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418cf3e:	e043      	b.n	3418cfc8 <HAL_RCC_OscConfig+0x150>
3418cf40:	687b      	ldr	r3, [r7, #4]
3418cf42:	685b      	ldr	r3, [r3, #4]
3418cf44:	2b00      	cmp	r3, #0
3418cf46:	d10c      	bne.n	3418cf62 <HAL_RCC_OscConfig+0xea>
3418cf48:	4b6b      	ldr	r3, [pc, #428]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf4a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418cf4e:	461a      	mov	r2, r3
3418cf50:	2310      	movs	r3, #16
3418cf52:	6013      	str	r3, [r2, #0]
3418cf54:	4b68      	ldr	r3, [pc, #416]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf56:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf58:	4a67      	ldr	r2, [pc, #412]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf5a:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418cf5e:	6553      	str	r3, [r2, #84]	@ 0x54
3418cf60:	e032      	b.n	3418cfc8 <HAL_RCC_OscConfig+0x150>
3418cf62:	687b      	ldr	r3, [r7, #4]
3418cf64:	685b      	ldr	r3, [r3, #4]
3418cf66:	f248 0210 	movw	r2, #32784	@ 0x8010
3418cf6a:	4293      	cmp	r3, r2
3418cf6c:	d110      	bne.n	3418cf90 <HAL_RCC_OscConfig+0x118>
3418cf6e:	4b62      	ldr	r3, [pc, #392]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf70:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf72:	4a61      	ldr	r2, [pc, #388]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf74:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418cf78:	6553      	str	r3, [r2, #84]	@ 0x54
3418cf7a:	4b5f      	ldr	r3, [pc, #380]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf7c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf7e:	4a5e      	ldr	r2, [pc, #376]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf80:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418cf84:	6553      	str	r3, [r2, #84]	@ 0x54
3418cf86:	4b5c      	ldr	r3, [pc, #368]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf88:	2210      	movs	r2, #16
3418cf8a:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418cf8e:	e01b      	b.n	3418cfc8 <HAL_RCC_OscConfig+0x150>
3418cf90:	687b      	ldr	r3, [r7, #4]
3418cf92:	685b      	ldr	r3, [r3, #4]
3418cf94:	4a59      	ldr	r2, [pc, #356]	@ (3418d0fc <HAL_RCC_OscConfig+0x284>)
3418cf96:	4293      	cmp	r3, r2
3418cf98:	d10a      	bne.n	3418cfb0 <HAL_RCC_OscConfig+0x138>
3418cf9a:	4b57      	ldr	r3, [pc, #348]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cf9c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cf9e:	4a56      	ldr	r2, [pc, #344]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfa0:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
3418cfa4:	6553      	str	r3, [r2, #84]	@ 0x54
3418cfa6:	4b54      	ldr	r3, [pc, #336]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfa8:	2210      	movs	r2, #16
3418cfaa:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418cfae:	e00b      	b.n	3418cfc8 <HAL_RCC_OscConfig+0x150>
3418cfb0:	4b51      	ldr	r3, [pc, #324]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfb2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418cfb6:	461a      	mov	r2, r3
3418cfb8:	2310      	movs	r3, #16
3418cfba:	6013      	str	r3, [r2, #0]
3418cfbc:	4b4e      	ldr	r3, [pc, #312]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfbe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418cfc0:	4a4d      	ldr	r2, [pc, #308]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfc2:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3418cfc6:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418cfc8:	f7f9 faa2 	bl	34186510 <HAL_GetTick>
3418cfcc:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3418cfce:	687b      	ldr	r3, [r7, #4]
3418cfd0:	685b      	ldr	r3, [r3, #4]
3418cfd2:	2b00      	cmp	r3, #0
3418cfd4:	d019      	beq.n	3418d00a <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418cfd6:	e008      	b.n	3418cfea <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3418cfd8:	f7f9 fa9a 	bl	34186510 <HAL_GetTick>
3418cfdc:	4602      	mov	r2, r0
3418cfde:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418cfe0:	1ad3      	subs	r3, r2, r3
3418cfe2:	2b64      	cmp	r3, #100	@ 0x64
3418cfe4:	d901      	bls.n	3418cfea <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
3418cfe6:	2303      	movs	r3, #3
3418cfe8:	e321      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3418cfea:	4b43      	ldr	r3, [pc, #268]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418cfec:	685b      	ldr	r3, [r3, #4]
3418cfee:	f003 0310 	and.w	r3, r3, #16
3418cff2:	2b00      	cmp	r3, #0
3418cff4:	d0f0      	beq.n	3418cfd8 <HAL_RCC_OscConfig+0x160>
3418cff6:	e00e      	b.n	3418d016 <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3418cff8:	f7f9 fa8a 	bl	34186510 <HAL_GetTick>
3418cffc:	4602      	mov	r2, r0
3418cffe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d000:	1ad3      	subs	r3, r2, r3
3418d002:	2b64      	cmp	r3, #100	@ 0x64
3418d004:	d901      	bls.n	3418d00a <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
3418d006:	2303      	movs	r3, #3
3418d008:	e311      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
3418d00a:	4b3b      	ldr	r3, [pc, #236]	@ (3418d0f8 <HAL_RCC_OscConfig+0x280>)
3418d00c:	685b      	ldr	r3, [r3, #4]
3418d00e:	f003 0310 	and.w	r3, r3, #16
3418d012:	2b00      	cmp	r3, #0
3418d014:	d1f0      	bne.n	3418cff8 <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3418d016:	687b      	ldr	r3, [r7, #4]
3418d018:	681b      	ldr	r3, [r3, #0]
3418d01a:	f003 0302 	and.w	r3, r3, #2
3418d01e:	2b00      	cmp	r3, #0
3418d020:	d073      	beq.n	3418d10a <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3418d022:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d026:	2b00      	cmp	r3, #0
3418d028:	d023      	beq.n	3418d072 <HAL_RCC_OscConfig+0x1fa>
3418d02a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d02e:	2b00      	cmp	r3, #0
3418d030:	d01f      	beq.n	3418d072 <HAL_RCC_OscConfig+0x1fa>
3418d032:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418d034:	2b00      	cmp	r3, #0
3418d036:	d104      	bne.n	3418d042 <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418d038:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d03a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418d03e:	2b00      	cmp	r3, #0
3418d040:	d117      	bne.n	3418d072 <HAL_RCC_OscConfig+0x1fa>
3418d042:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418d044:	2b00      	cmp	r3, #0
3418d046:	d104      	bne.n	3418d052 <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418d048:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d04a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418d04e:	2b00      	cmp	r3, #0
3418d050:	d10f      	bne.n	3418d072 <HAL_RCC_OscConfig+0x1fa>
3418d052:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418d054:	2b00      	cmp	r3, #0
3418d056:	d104      	bne.n	3418d062 <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418d058:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d05a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418d05e:	2b00      	cmp	r3, #0
3418d060:	d107      	bne.n	3418d072 <HAL_RCC_OscConfig+0x1fa>
3418d062:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418d064:	2b00      	cmp	r3, #0
3418d066:	d115      	bne.n	3418d094 <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418d068:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d06a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418d06e:	2b00      	cmp	r3, #0
3418d070:	d010      	beq.n	3418d094 <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418d072:	687b      	ldr	r3, [r7, #4]
3418d074:	68db      	ldr	r3, [r3, #12]
3418d076:	2b00      	cmp	r3, #0
3418d078:	d101      	bne.n	3418d07e <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
3418d07a:	2301      	movs	r3, #1
3418d07c:	e2d7      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418d07e:	687b      	ldr	r3, [r7, #4]
3418d080:	691b      	ldr	r3, [r3, #16]
3418d082:	4618      	mov	r0, r3
3418d084:	f7ff fcb2 	bl	3418c9ec <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418d088:	687b      	ldr	r3, [r7, #4]
3418d08a:	695b      	ldr	r3, [r3, #20]
3418d08c:	4618      	mov	r0, r3
3418d08e:	f7ff fccf 	bl	3418ca30 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3418d092:	e03a      	b.n	3418d10a <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
3418d094:	687b      	ldr	r3, [r7, #4]
3418d096:	68db      	ldr	r3, [r3, #12]
3418d098:	2b00      	cmp	r3, #0
3418d09a:	d01e      	beq.n	3418d0da <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3418d09c:	f7ff fc76 	bl	3418c98c <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418d0a0:	f7f9 fa36 	bl	34186510 <HAL_GetTick>
3418d0a4:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3418d0a6:	e008      	b.n	3418d0ba <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418d0a8:	f7f9 fa32 	bl	34186510 <HAL_GetTick>
3418d0ac:	4602      	mov	r2, r0
3418d0ae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d0b0:	1ad3      	subs	r3, r2, r3
3418d0b2:	2b01      	cmp	r3, #1
3418d0b4:	d901      	bls.n	3418d0ba <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3418d0b6:	2303      	movs	r3, #3
3418d0b8:	e2b9      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
3418d0ba:	f7ff fc85 	bl	3418c9c8 <LL_RCC_HSI_IsReady>
3418d0be:	4603      	mov	r3, r0
3418d0c0:	2b00      	cmp	r3, #0
3418d0c2:	d0f1      	beq.n	3418d0a8 <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3418d0c4:	687b      	ldr	r3, [r7, #4]
3418d0c6:	691b      	ldr	r3, [r3, #16]
3418d0c8:	4618      	mov	r0, r3
3418d0ca:	f7ff fc8f 	bl	3418c9ec <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3418d0ce:	687b      	ldr	r3, [r7, #4]
3418d0d0:	695b      	ldr	r3, [r3, #20]
3418d0d2:	4618      	mov	r0, r3
3418d0d4:	f7ff fcac 	bl	3418ca30 <LL_RCC_HSI_SetCalibTrimming>
3418d0d8:	e017      	b.n	3418d10a <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3418d0da:	f7ff fc65 	bl	3418c9a8 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418d0de:	f7f9 fa17 	bl	34186510 <HAL_GetTick>
3418d0e2:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3418d0e4:	e00c      	b.n	3418d100 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3418d0e6:	f7f9 fa13 	bl	34186510 <HAL_GetTick>
3418d0ea:	4602      	mov	r2, r0
3418d0ec:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d0ee:	1ad3      	subs	r3, r2, r3
3418d0f0:	2b01      	cmp	r3, #1
3418d0f2:	d905      	bls.n	3418d100 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3418d0f4:	2303      	movs	r3, #3
3418d0f6:	e29a      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
3418d0f8:	56028000 	.word	0x56028000
3418d0fc:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
3418d100:	f7ff fc62 	bl	3418c9c8 <LL_RCC_HSI_IsReady>
3418d104:	4603      	mov	r3, r0
3418d106:	2b00      	cmp	r3, #0
3418d108:	d1ed      	bne.n	3418d0e6 <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
3418d10a:	687b      	ldr	r3, [r7, #4]
3418d10c:	681b      	ldr	r3, [r3, #0]
3418d10e:	f003 0310 	and.w	r3, r3, #16
3418d112:	2b00      	cmp	r3, #0
3418d114:	d070      	beq.n	3418d1f8 <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3418d116:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d11a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418d11e:	d028      	beq.n	3418d172 <HAL_RCC_OscConfig+0x2fa>
3418d120:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d124:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d128:	d023      	beq.n	3418d172 <HAL_RCC_OscConfig+0x2fa>
3418d12a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3418d12c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d130:	d104      	bne.n	3418d13c <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3418d132:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d134:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418d138:	2b00      	cmp	r3, #0
3418d13a:	d11a      	bne.n	3418d172 <HAL_RCC_OscConfig+0x2fa>
3418d13c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3418d13e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d142:	d104      	bne.n	3418d14e <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3418d144:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d146:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418d14a:	2b00      	cmp	r3, #0
3418d14c:	d111      	bne.n	3418d172 <HAL_RCC_OscConfig+0x2fa>
3418d14e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3418d150:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d154:	d104      	bne.n	3418d160 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3418d156:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d158:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418d15c:	2b00      	cmp	r3, #0
3418d15e:	d108      	bne.n	3418d172 <HAL_RCC_OscConfig+0x2fa>
3418d160:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3418d162:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d166:	d110      	bne.n	3418d18a <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3418d168:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3418d16a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418d16e:	2b00      	cmp	r3, #0
3418d170:	d00b      	beq.n	3418d18a <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418d172:	687b      	ldr	r3, [r7, #4]
3418d174:	69db      	ldr	r3, [r3, #28]
3418d176:	2b00      	cmp	r3, #0
3418d178:	d101      	bne.n	3418d17e <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
3418d17a:	2301      	movs	r3, #1
3418d17c:	e257      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418d17e:	687b      	ldr	r3, [r7, #4]
3418d180:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d182:	4618      	mov	r0, r3
3418d184:	f7ff fcae 	bl	3418cae4 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3418d188:	e036      	b.n	3418d1f8 <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3418d18a:	687b      	ldr	r3, [r7, #4]
3418d18c:	69db      	ldr	r3, [r3, #28]
3418d18e:	2b00      	cmp	r3, #0
3418d190:	d01e      	beq.n	3418d1d0 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
3418d192:	687b      	ldr	r3, [r7, #4]
3418d194:	6a1b      	ldr	r3, [r3, #32]
3418d196:	4618      	mov	r0, r3
3418d198:	f7ff fc90 	bl	3418cabc <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3418d19c:	f7ff fc5e 	bl	3418ca5c <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418d1a0:	f7f9 f9b6 	bl	34186510 <HAL_GetTick>
3418d1a4:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3418d1a6:	e008      	b.n	3418d1ba <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418d1a8:	f7f9 f9b2 	bl	34186510 <HAL_GetTick>
3418d1ac:	4602      	mov	r2, r0
3418d1ae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d1b0:	1ad3      	subs	r3, r2, r3
3418d1b2:	2b01      	cmp	r3, #1
3418d1b4:	d901      	bls.n	3418d1ba <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
3418d1b6:	2303      	movs	r3, #3
3418d1b8:	e239      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
3418d1ba:	f7ff fc6d 	bl	3418ca98 <LL_RCC_MSI_IsReady>
3418d1be:	4603      	mov	r3, r0
3418d1c0:	2b00      	cmp	r3, #0
3418d1c2:	d0f1      	beq.n	3418d1a8 <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3418d1c4:	687b      	ldr	r3, [r7, #4]
3418d1c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d1c8:	4618      	mov	r0, r3
3418d1ca:	f7ff fc8b 	bl	3418cae4 <LL_RCC_MSI_SetCalibTrimming>
3418d1ce:	e013      	b.n	3418d1f8 <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3418d1d0:	f7ff fc52 	bl	3418ca78 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418d1d4:	f7f9 f99c 	bl	34186510 <HAL_GetTick>
3418d1d8:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3418d1da:	e008      	b.n	3418d1ee <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3418d1dc:	f7f9 f998 	bl	34186510 <HAL_GetTick>
3418d1e0:	4602      	mov	r2, r0
3418d1e2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d1e4:	1ad3      	subs	r3, r2, r3
3418d1e6:	2b01      	cmp	r3, #1
3418d1e8:	d901      	bls.n	3418d1ee <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
3418d1ea:	2303      	movs	r3, #3
3418d1ec:	e21f      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
3418d1ee:	f7ff fc53 	bl	3418ca98 <LL_RCC_MSI_IsReady>
3418d1f2:	4603      	mov	r3, r0
3418d1f4:	2b00      	cmp	r3, #0
3418d1f6:	d1f1      	bne.n	3418d1dc <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
3418d1f8:	687b      	ldr	r3, [r7, #4]
3418d1fa:	681b      	ldr	r3, [r3, #0]
3418d1fc:	f003 0308 	and.w	r3, r3, #8
3418d200:	2b00      	cmp	r3, #0
3418d202:	d02c      	beq.n	3418d25e <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3418d204:	687b      	ldr	r3, [r7, #4]
3418d206:	699b      	ldr	r3, [r3, #24]
3418d208:	2b00      	cmp	r3, #0
3418d20a:	d014      	beq.n	3418d236 <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
3418d20c:	f7ff fc92 	bl	3418cb34 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418d210:	f7f9 f97e 	bl	34186510 <HAL_GetTick>
3418d214:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3418d216:	e008      	b.n	3418d22a <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418d218:	f7f9 f97a 	bl	34186510 <HAL_GetTick>
3418d21c:	4602      	mov	r2, r0
3418d21e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d220:	1ad3      	subs	r3, r2, r3
3418d222:	2b01      	cmp	r3, #1
3418d224:	d901      	bls.n	3418d22a <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
3418d226:	2303      	movs	r3, #3
3418d228:	e201      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
3418d22a:	f7ff fca1 	bl	3418cb70 <LL_RCC_LSI_IsReady>
3418d22e:	4603      	mov	r3, r0
3418d230:	2b00      	cmp	r3, #0
3418d232:	d0f1      	beq.n	3418d218 <HAL_RCC_OscConfig+0x3a0>
3418d234:	e013      	b.n	3418d25e <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3418d236:	f7ff fc8b 	bl	3418cb50 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418d23a:	f7f9 f969 	bl	34186510 <HAL_GetTick>
3418d23e:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
3418d240:	e008      	b.n	3418d254 <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3418d242:	f7f9 f965 	bl	34186510 <HAL_GetTick>
3418d246:	4602      	mov	r2, r0
3418d248:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d24a:	1ad3      	subs	r3, r2, r3
3418d24c:	2b01      	cmp	r3, #1
3418d24e:	d901      	bls.n	3418d254 <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
3418d250:	2303      	movs	r3, #3
3418d252:	e1ec      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
3418d254:	f7ff fc8c 	bl	3418cb70 <LL_RCC_LSI_IsReady>
3418d258:	4603      	mov	r3, r0
3418d25a:	2b00      	cmp	r3, #0
3418d25c:	d1f1      	bne.n	3418d242 <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3418d25e:	687b      	ldr	r3, [r7, #4]
3418d260:	681b      	ldr	r3, [r3, #0]
3418d262:	f003 0304 	and.w	r3, r3, #4
3418d266:	2b00      	cmp	r3, #0
3418d268:	f000 808c 	beq.w	3418d384 <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3418d26c:	687b      	ldr	r3, [r7, #4]
3418d26e:	689b      	ldr	r3, [r3, #8]
3418d270:	2b02      	cmp	r3, #2
3418d272:	d104      	bne.n	3418d27e <HAL_RCC_OscConfig+0x406>
3418d274:	4b96      	ldr	r3, [pc, #600]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d276:	2202      	movs	r2, #2
3418d278:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418d27c:	e055      	b.n	3418d32a <HAL_RCC_OscConfig+0x4b2>
3418d27e:	687b      	ldr	r3, [r7, #4]
3418d280:	689b      	ldr	r3, [r3, #8]
3418d282:	2b00      	cmp	r3, #0
3418d284:	d112      	bne.n	3418d2ac <HAL_RCC_OscConfig+0x434>
3418d286:	4b92      	ldr	r3, [pc, #584]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d288:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418d28c:	461a      	mov	r2, r3
3418d28e:	2302      	movs	r3, #2
3418d290:	6013      	str	r3, [r2, #0]
3418d292:	4b8f      	ldr	r3, [pc, #572]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d294:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d296:	4a8e      	ldr	r2, [pc, #568]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d298:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418d29c:	6413      	str	r3, [r2, #64]	@ 0x40
3418d29e:	4b8c      	ldr	r3, [pc, #560]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2a0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d2a2:	4a8b      	ldr	r2, [pc, #556]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2a4:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418d2a8:	6413      	str	r3, [r2, #64]	@ 0x40
3418d2aa:	e03e      	b.n	3418d32a <HAL_RCC_OscConfig+0x4b2>
3418d2ac:	687b      	ldr	r3, [r7, #4]
3418d2ae:	689b      	ldr	r3, [r3, #8]
3418d2b0:	f248 0202 	movw	r2, #32770	@ 0x8002
3418d2b4:	4293      	cmp	r3, r2
3418d2b6:	d110      	bne.n	3418d2da <HAL_RCC_OscConfig+0x462>
3418d2b8:	4b85      	ldr	r3, [pc, #532]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d2bc:	4a84      	ldr	r2, [pc, #528]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2be:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418d2c2:	6413      	str	r3, [r2, #64]	@ 0x40
3418d2c4:	4b82      	ldr	r3, [pc, #520]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2c6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d2c8:	4a81      	ldr	r2, [pc, #516]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2ca:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418d2ce:	6413      	str	r3, [r2, #64]	@ 0x40
3418d2d0:	4b7f      	ldr	r3, [pc, #508]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2d2:	2202      	movs	r2, #2
3418d2d4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418d2d8:	e027      	b.n	3418d32a <HAL_RCC_OscConfig+0x4b2>
3418d2da:	687b      	ldr	r3, [r7, #4]
3418d2dc:	689b      	ldr	r3, [r3, #8]
3418d2de:	4a7d      	ldr	r2, [pc, #500]	@ (3418d4d4 <HAL_RCC_OscConfig+0x65c>)
3418d2e0:	4293      	cmp	r3, r2
3418d2e2:	d110      	bne.n	3418d306 <HAL_RCC_OscConfig+0x48e>
3418d2e4:	4b7a      	ldr	r3, [pc, #488]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2e6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d2e8:	4a79      	ldr	r2, [pc, #484]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2ea:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3418d2ee:	6413      	str	r3, [r2, #64]	@ 0x40
3418d2f0:	4b77      	ldr	r3, [pc, #476]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2f2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d2f4:	4a76      	ldr	r2, [pc, #472]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2f6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3418d2fa:	6413      	str	r3, [r2, #64]	@ 0x40
3418d2fc:	4b74      	ldr	r3, [pc, #464]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d2fe:	2202      	movs	r2, #2
3418d300:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3418d304:	e011      	b.n	3418d32a <HAL_RCC_OscConfig+0x4b2>
3418d306:	4b72      	ldr	r3, [pc, #456]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d308:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3418d30c:	461a      	mov	r2, r3
3418d30e:	2302      	movs	r3, #2
3418d310:	6013      	str	r3, [r2, #0]
3418d312:	4b6f      	ldr	r3, [pc, #444]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d314:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d316:	4a6e      	ldr	r2, [pc, #440]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d318:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3418d31c:	6413      	str	r3, [r2, #64]	@ 0x40
3418d31e:	4b6c      	ldr	r3, [pc, #432]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d320:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3418d322:	4a6b      	ldr	r2, [pc, #428]	@ (3418d4d0 <HAL_RCC_OscConfig+0x658>)
3418d324:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3418d328:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3418d32a:	687b      	ldr	r3, [r7, #4]
3418d32c:	689b      	ldr	r3, [r3, #8]
3418d32e:	2b00      	cmp	r3, #0
3418d330:	d014      	beq.n	3418d35c <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418d332:	f7f9 f8ed 	bl	34186510 <HAL_GetTick>
3418d336:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
3418d338:	e00a      	b.n	3418d350 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418d33a:	f7f9 f8e9 	bl	34186510 <HAL_GetTick>
3418d33e:	4602      	mov	r2, r0
3418d340:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d342:	1ad3      	subs	r3, r2, r3
3418d344:	f241 3288 	movw	r2, #5000	@ 0x1388
3418d348:	4293      	cmp	r3, r2
3418d34a:	d901      	bls.n	3418d350 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
3418d34c:	2303      	movs	r3, #3
3418d34e:	e16e      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
3418d350:	f7ff fbde 	bl	3418cb10 <LL_RCC_LSE_IsReady>
3418d354:	4603      	mov	r3, r0
3418d356:	2b00      	cmp	r3, #0
3418d358:	d0ef      	beq.n	3418d33a <HAL_RCC_OscConfig+0x4c2>
3418d35a:	e013      	b.n	3418d384 <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418d35c:	f7f9 f8d8 	bl	34186510 <HAL_GetTick>
3418d360:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
3418d362:	e00a      	b.n	3418d37a <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418d364:	f7f9 f8d4 	bl	34186510 <HAL_GetTick>
3418d368:	4602      	mov	r2, r0
3418d36a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3418d36c:	1ad3      	subs	r3, r2, r3
3418d36e:	f241 3288 	movw	r2, #5000	@ 0x1388
3418d372:	4293      	cmp	r3, r2
3418d374:	d901      	bls.n	3418d37a <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
3418d376:	2303      	movs	r3, #3
3418d378:	e159      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
3418d37a:	f7ff fbc9 	bl	3418cb10 <LL_RCC_LSE_IsReady>
3418d37e:	4603      	mov	r3, r0
3418d380:	2b00      	cmp	r3, #0
3418d382:	d1ef      	bne.n	3418d364 <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3418d384:	687b      	ldr	r3, [r7, #4]
3418d386:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418d388:	2b00      	cmp	r3, #0
3418d38a:	d04c      	beq.n	3418d426 <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3418d38c:	687b      	ldr	r3, [r7, #4]
3418d38e:	3328      	adds	r3, #40	@ 0x28
3418d390:	4619      	mov	r1, r3
3418d392:	2000      	movs	r0, #0
3418d394:	f000 fe4c 	bl	3418e030 <RCC_PLL_IsNewConfig>
3418d398:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3418d39a:	f7ff fc3d 	bl	3418cc18 <LL_RCC_PLL1_IsReady>
3418d39e:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
3418d3a0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3418d3a2:	2b01      	cmp	r3, #1
3418d3a4:	d130      	bne.n	3418d408 <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418d3a6:	f7ff fd0f 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418d3aa:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418d3ac:	f7ff fd2a 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418d3b0:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418d3b2:	f7ff fd45 	bl	3418ce40 <LL_RCC_IC6_GetSource>
3418d3b6:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418d3b8:	f7ff fd50 	bl	3418ce5c <LL_RCC_IC11_GetSource>
3418d3bc:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3418d3be:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d3c2:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418d3c6:	d104      	bne.n	3418d3d2 <HAL_RCC_OscConfig+0x55a>
3418d3c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3418d3ca:	2b00      	cmp	r3, #0
3418d3cc:	d101      	bne.n	3418d3d2 <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
3418d3ce:	2301      	movs	r3, #1
3418d3d0:	e12d      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418d3d2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d3d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d3da:	d10a      	bne.n	3418d3f2 <HAL_RCC_OscConfig+0x57a>
3418d3dc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3418d3de:	2b00      	cmp	r3, #0
3418d3e0:	d005      	beq.n	3418d3ee <HAL_RCC_OscConfig+0x576>
3418d3e2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3418d3e4:	2b00      	cmp	r3, #0
3418d3e6:	d002      	beq.n	3418d3ee <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3418d3e8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3418d3ea:	2b00      	cmp	r3, #0
3418d3ec:	d101      	bne.n	3418d3f2 <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
3418d3ee:	2301      	movs	r3, #1
3418d3f0:	e11d      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3418d3f2:	687b      	ldr	r3, [r7, #4]
3418d3f4:	3328      	adds	r3, #40	@ 0x28
3418d3f6:	4619      	mov	r1, r3
3418d3f8:	2000      	movs	r0, #0
3418d3fa:	f000 fcbd 	bl	3418dd78 <RCC_PLL_Config>
3418d3fe:	4603      	mov	r3, r0
3418d400:	2b00      	cmp	r3, #0
3418d402:	d010      	beq.n	3418d426 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418d404:	2301      	movs	r3, #1
3418d406:	e112      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3418d408:	687b      	ldr	r3, [r7, #4]
3418d40a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418d40c:	2b02      	cmp	r3, #2
3418d40e:	d10a      	bne.n	3418d426 <HAL_RCC_OscConfig+0x5ae>
3418d410:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3418d412:	2b00      	cmp	r3, #0
3418d414:	d107      	bne.n	3418d426 <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3418d416:	2000      	movs	r0, #0
3418d418:	f000 fdde 	bl	3418dfd8 <RCC_PLL_Enable>
3418d41c:	4603      	mov	r3, r0
3418d41e:	2b00      	cmp	r3, #0
3418d420:	d001      	beq.n	3418d426 <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3418d422:	2301      	movs	r3, #1
3418d424:	e103      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3418d426:	687b      	ldr	r3, [r7, #4]
3418d428:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418d42a:	2b00      	cmp	r3, #0
3418d42c:	d054      	beq.n	3418d4d8 <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3418d42e:	687b      	ldr	r3, [r7, #4]
3418d430:	3344      	adds	r3, #68	@ 0x44
3418d432:	4619      	mov	r1, r3
3418d434:	2001      	movs	r0, #1
3418d436:	f000 fdfb 	bl	3418e030 <RCC_PLL_IsNewConfig>
3418d43a:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3418d43c:	f7ff fc22 	bl	3418cc84 <LL_RCC_PLL2_IsReady>
3418d440:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
3418d442:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3418d444:	2b01      	cmp	r3, #1
3418d446:	d134      	bne.n	3418d4b2 <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418d448:	f7ff fcbe 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418d44c:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418d44e:	f7ff fcd9 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418d452:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418d454:	f7ff fcf4 	bl	3418ce40 <LL_RCC_IC6_GetSource>
3418d458:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418d45a:	f7ff fcff 	bl	3418ce5c <LL_RCC_IC11_GetSource>
3418d45e:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3418d460:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d464:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418d468:	d105      	bne.n	3418d476 <HAL_RCC_OscConfig+0x5fe>
3418d46a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3418d46c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d470:	d101      	bne.n	3418d476 <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
3418d472:	2301      	movs	r3, #1
3418d474:	e0db      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418d476:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d47a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d47e:	d10d      	bne.n	3418d49c <HAL_RCC_OscConfig+0x624>
3418d480:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3418d482:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d486:	d007      	beq.n	3418d498 <HAL_RCC_OscConfig+0x620>
3418d488:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3418d48a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d48e:	d003      	beq.n	3418d498 <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3418d490:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3418d492:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418d496:	d101      	bne.n	3418d49c <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
3418d498:	2301      	movs	r3, #1
3418d49a:	e0c8      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3418d49c:	687b      	ldr	r3, [r7, #4]
3418d49e:	3344      	adds	r3, #68	@ 0x44
3418d4a0:	4619      	mov	r1, r3
3418d4a2:	2001      	movs	r0, #1
3418d4a4:	f000 fc68 	bl	3418dd78 <RCC_PLL_Config>
3418d4a8:	4603      	mov	r3, r0
3418d4aa:	2b00      	cmp	r3, #0
3418d4ac:	d014      	beq.n	3418d4d8 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418d4ae:	2301      	movs	r3, #1
3418d4b0:	e0bd      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3418d4b2:	687b      	ldr	r3, [r7, #4]
3418d4b4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418d4b6:	2b02      	cmp	r3, #2
3418d4b8:	d10e      	bne.n	3418d4d8 <HAL_RCC_OscConfig+0x660>
3418d4ba:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3418d4bc:	2b00      	cmp	r3, #0
3418d4be:	d10b      	bne.n	3418d4d8 <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3418d4c0:	2001      	movs	r0, #1
3418d4c2:	f000 fd89 	bl	3418dfd8 <RCC_PLL_Enable>
3418d4c6:	4603      	mov	r3, r0
3418d4c8:	2b00      	cmp	r3, #0
3418d4ca:	d005      	beq.n	3418d4d8 <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3418d4cc:	2301      	movs	r3, #1
3418d4ce:	e0ae      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
3418d4d0:	56028000 	.word	0x56028000
3418d4d4:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
3418d4d8:	687b      	ldr	r3, [r7, #4]
3418d4da:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418d4dc:	2b00      	cmp	r3, #0
3418d4de:	d050      	beq.n	3418d582 <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3418d4e0:	687b      	ldr	r3, [r7, #4]
3418d4e2:	3360      	adds	r3, #96	@ 0x60
3418d4e4:	4619      	mov	r1, r3
3418d4e6:	2002      	movs	r0, #2
3418d4e8:	f000 fda2 	bl	3418e030 <RCC_PLL_IsNewConfig>
3418d4ec:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3418d4ee:	f7ff fb93 	bl	3418cc18 <LL_RCC_PLL1_IsReady>
3418d4f2:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3418d4f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3418d4f6:	2b01      	cmp	r3, #1
3418d4f8:	d134      	bne.n	3418d564 <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418d4fa:	f7ff fc65 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418d4fe:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418d500:	f7ff fc80 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418d504:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418d506:	f7ff fc9b 	bl	3418ce40 <LL_RCC_IC6_GetSource>
3418d50a:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418d50c:	f7ff fca6 	bl	3418ce5c <LL_RCC_IC11_GetSource>
3418d510:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3418d512:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d516:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418d51a:	d105      	bne.n	3418d528 <HAL_RCC_OscConfig+0x6b0>
3418d51c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3418d51e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d522:	d101      	bne.n	3418d528 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
3418d524:	2301      	movs	r3, #1
3418d526:	e082      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418d528:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d52c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d530:	d10d      	bne.n	3418d54e <HAL_RCC_OscConfig+0x6d6>
3418d532:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3418d534:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d538:	d007      	beq.n	3418d54a <HAL_RCC_OscConfig+0x6d2>
3418d53a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3418d53c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d540:	d003      	beq.n	3418d54a <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3418d542:	6a3b      	ldr	r3, [r7, #32]
3418d544:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418d548:	d101      	bne.n	3418d54e <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3418d54a:	2301      	movs	r3, #1
3418d54c:	e06f      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3418d54e:	687b      	ldr	r3, [r7, #4]
3418d550:	3360      	adds	r3, #96	@ 0x60
3418d552:	4619      	mov	r1, r3
3418d554:	2002      	movs	r0, #2
3418d556:	f000 fc0f 	bl	3418dd78 <RCC_PLL_Config>
3418d55a:	4603      	mov	r3, r0
3418d55c:	2b00      	cmp	r3, #0
3418d55e:	d010      	beq.n	3418d582 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418d560:	2301      	movs	r3, #1
3418d562:	e064      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3418d564:	687b      	ldr	r3, [r7, #4]
3418d566:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3418d568:	2b02      	cmp	r3, #2
3418d56a:	d10a      	bne.n	3418d582 <HAL_RCC_OscConfig+0x70a>
3418d56c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3418d56e:	2b00      	cmp	r3, #0
3418d570:	d107      	bne.n	3418d582 <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3418d572:	2002      	movs	r0, #2
3418d574:	f000 fd30 	bl	3418dfd8 <RCC_PLL_Enable>
3418d578:	4603      	mov	r3, r0
3418d57a:	2b00      	cmp	r3, #0
3418d57c:	d001      	beq.n	3418d582 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3418d57e:	2301      	movs	r3, #1
3418d580:	e055      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
3418d582:	687b      	ldr	r3, [r7, #4]
3418d584:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418d586:	2b00      	cmp	r3, #0
3418d588:	d050      	beq.n	3418d62c <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3418d58a:	687b      	ldr	r3, [r7, #4]
3418d58c:	337c      	adds	r3, #124	@ 0x7c
3418d58e:	4619      	mov	r1, r3
3418d590:	2003      	movs	r0, #3
3418d592:	f000 fd4d 	bl	3418e030 <RCC_PLL_IsNewConfig>
3418d596:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
3418d598:	f7ff fbe0 	bl	3418cd5c <LL_RCC_PLL4_IsReady>
3418d59c:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
3418d59e:	69fb      	ldr	r3, [r7, #28]
3418d5a0:	2b01      	cmp	r3, #1
3418d5a2:	d134      	bne.n	3418d60e <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3418d5a4:	f7ff fc10 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418d5a8:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3418d5aa:	f7ff fc2b 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418d5ae:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3418d5b0:	f7ff fc46 	bl	3418ce40 <LL_RCC_IC6_GetSource>
3418d5b4:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3418d5b6:	f7ff fc51 	bl	3418ce5c <LL_RCC_IC11_GetSource>
3418d5ba:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3418d5bc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3418d5c0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418d5c4:	d105      	bne.n	3418d5d2 <HAL_RCC_OscConfig+0x75a>
3418d5c6:	697b      	ldr	r3, [r7, #20]
3418d5c8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d5cc:	d101      	bne.n	3418d5d2 <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
3418d5ce:	2301      	movs	r3, #1
3418d5d0:	e02d      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418d5d2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3418d5d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d5da:	d10d      	bne.n	3418d5f8 <HAL_RCC_OscConfig+0x780>
3418d5dc:	693b      	ldr	r3, [r7, #16]
3418d5de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d5e2:	d007      	beq.n	3418d5f4 <HAL_RCC_OscConfig+0x77c>
3418d5e4:	68fb      	ldr	r3, [r7, #12]
3418d5e6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d5ea:	d003      	beq.n	3418d5f4 <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3418d5ec:	68bb      	ldr	r3, [r7, #8]
3418d5ee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418d5f2:	d101      	bne.n	3418d5f8 <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3418d5f4:	2301      	movs	r3, #1
3418d5f6:	e01a      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3418d5f8:	687b      	ldr	r3, [r7, #4]
3418d5fa:	337c      	adds	r3, #124	@ 0x7c
3418d5fc:	4619      	mov	r1, r3
3418d5fe:	2003      	movs	r0, #3
3418d600:	f000 fbba 	bl	3418dd78 <RCC_PLL_Config>
3418d604:	4603      	mov	r3, r0
3418d606:	2b00      	cmp	r3, #0
3418d608:	d010      	beq.n	3418d62c <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418d60a:	2301      	movs	r3, #1
3418d60c:	e00f      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3418d60e:	687b      	ldr	r3, [r7, #4]
3418d610:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418d612:	2b02      	cmp	r3, #2
3418d614:	d10a      	bne.n	3418d62c <HAL_RCC_OscConfig+0x7b4>
3418d616:	69bb      	ldr	r3, [r7, #24]
3418d618:	2b00      	cmp	r3, #0
3418d61a:	d107      	bne.n	3418d62c <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3418d61c:	2003      	movs	r0, #3
3418d61e:	f000 fcdb 	bl	3418dfd8 <RCC_PLL_Enable>
3418d622:	4603      	mov	r3, r0
3418d624:	2b00      	cmp	r3, #0
3418d626:	d001      	beq.n	3418d62c <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3418d628:	2301      	movs	r3, #1
3418d62a:	e000      	b.n	3418d62e <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
3418d62c:	2300      	movs	r3, #0
}
3418d62e:	4618      	mov	r0, r3
3418d630:	3788      	adds	r7, #136	@ 0x88
3418d632:	46bd      	mov	sp, r7
3418d634:	bd80      	pop	{r7, pc}
3418d636:	bf00      	nop

3418d638 <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418d638:	b580      	push	{r7, lr}
3418d63a:	b084      	sub	sp, #16
3418d63c:	af00      	add	r7, sp, #0
3418d63e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3418d640:	687b      	ldr	r3, [r7, #4]
3418d642:	2b00      	cmp	r3, #0
3418d644:	d101      	bne.n	3418d64a <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
3418d646:	2301      	movs	r3, #1
3418d648:	e1f2      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418d64a:	687b      	ldr	r3, [r7, #4]
3418d64c:	681b      	ldr	r3, [r3, #0]
3418d64e:	f003 0308 	and.w	r3, r3, #8
3418d652:	2b00      	cmp	r3, #0
3418d654:	d010      	beq.n	3418d678 <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418d656:	687b      	ldr	r3, [r7, #4]
3418d658:	691a      	ldr	r2, [r3, #16]
3418d65a:	4ba3      	ldr	r3, [pc, #652]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d65c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d65e:	f003 0307 	and.w	r3, r3, #7
3418d662:	429a      	cmp	r2, r3
3418d664:	d908      	bls.n	3418d678 <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418d666:	4ba0      	ldr	r3, [pc, #640]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d668:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d66a:	f023 0207 	bic.w	r2, r3, #7
3418d66e:	687b      	ldr	r3, [r7, #4]
3418d670:	691b      	ldr	r3, [r3, #16]
3418d672:	499d      	ldr	r1, [pc, #628]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d674:	4313      	orrs	r3, r2
3418d676:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418d678:	687b      	ldr	r3, [r7, #4]
3418d67a:	681b      	ldr	r3, [r3, #0]
3418d67c:	f003 0310 	and.w	r3, r3, #16
3418d680:	2b00      	cmp	r3, #0
3418d682:	d010      	beq.n	3418d6a6 <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418d684:	687b      	ldr	r3, [r7, #4]
3418d686:	695a      	ldr	r2, [r3, #20]
3418d688:	4b97      	ldr	r3, [pc, #604]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d68a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d68c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418d690:	429a      	cmp	r2, r3
3418d692:	d908      	bls.n	3418d6a6 <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418d694:	4b94      	ldr	r3, [pc, #592]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d696:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d698:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418d69c:	687b      	ldr	r3, [r7, #4]
3418d69e:	695b      	ldr	r3, [r3, #20]
3418d6a0:	4991      	ldr	r1, [pc, #580]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6a2:	4313      	orrs	r3, r2
3418d6a4:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418d6a6:	687b      	ldr	r3, [r7, #4]
3418d6a8:	681b      	ldr	r3, [r3, #0]
3418d6aa:	f003 0320 	and.w	r3, r3, #32
3418d6ae:	2b00      	cmp	r3, #0
3418d6b0:	d010      	beq.n	3418d6d4 <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418d6b2:	687b      	ldr	r3, [r7, #4]
3418d6b4:	699a      	ldr	r2, [r3, #24]
3418d6b6:	4b8c      	ldr	r3, [pc, #560]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d6ba:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418d6be:	429a      	cmp	r2, r3
3418d6c0:	d908      	bls.n	3418d6d4 <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418d6c2:	4b89      	ldr	r3, [pc, #548]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d6c6:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418d6ca:	687b      	ldr	r3, [r7, #4]
3418d6cc:	699b      	ldr	r3, [r3, #24]
3418d6ce:	4986      	ldr	r1, [pc, #536]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6d0:	4313      	orrs	r3, r2
3418d6d2:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418d6d4:	687b      	ldr	r3, [r7, #4]
3418d6d6:	681b      	ldr	r3, [r3, #0]
3418d6d8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418d6dc:	2b00      	cmp	r3, #0
3418d6de:	d010      	beq.n	3418d702 <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418d6e0:	687b      	ldr	r3, [r7, #4]
3418d6e2:	69da      	ldr	r2, [r3, #28]
3418d6e4:	4b80      	ldr	r3, [pc, #512]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d6e8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418d6ec:	429a      	cmp	r2, r3
3418d6ee:	d908      	bls.n	3418d702 <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418d6f0:	4b7d      	ldr	r3, [pc, #500]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d6f4:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418d6f8:	687b      	ldr	r3, [r7, #4]
3418d6fa:	69db      	ldr	r3, [r3, #28]
3418d6fc:	497a      	ldr	r1, [pc, #488]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d6fe:	4313      	orrs	r3, r2
3418d700:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418d702:	687b      	ldr	r3, [r7, #4]
3418d704:	681b      	ldr	r3, [r3, #0]
3418d706:	f003 0304 	and.w	r3, r3, #4
3418d70a:	2b00      	cmp	r3, #0
3418d70c:	d010      	beq.n	3418d730 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418d70e:	687b      	ldr	r3, [r7, #4]
3418d710:	68da      	ldr	r2, [r3, #12]
3418d712:	4b75      	ldr	r3, [pc, #468]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d714:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d716:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418d71a:	429a      	cmp	r2, r3
3418d71c:	d908      	bls.n	3418d730 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418d71e:	4b72      	ldr	r3, [pc, #456]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d720:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d722:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418d726:	687b      	ldr	r3, [r7, #4]
3418d728:	68db      	ldr	r3, [r3, #12]
3418d72a:	496f      	ldr	r1, [pc, #444]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d72c:	4313      	orrs	r3, r2
3418d72e:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3418d730:	687b      	ldr	r3, [r7, #4]
3418d732:	681b      	ldr	r3, [r3, #0]
3418d734:	f003 0301 	and.w	r3, r3, #1
3418d738:	2b00      	cmp	r3, #0
3418d73a:	d063      	beq.n	3418d804 <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3418d73c:	687b      	ldr	r3, [r7, #4]
3418d73e:	685b      	ldr	r3, [r3, #4]
3418d740:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418d744:	d106      	bne.n	3418d754 <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418d746:	f7ff f90f 	bl	3418c968 <LL_RCC_HSE_IsReady>
3418d74a:	4603      	mov	r3, r0
3418d74c:	2b00      	cmp	r3, #0
3418d74e:	d134      	bne.n	3418d7ba <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418d750:	2301      	movs	r3, #1
3418d752:	e16d      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3418d754:	687b      	ldr	r3, [r7, #4]
3418d756:	685b      	ldr	r3, [r3, #4]
3418d758:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3418d75c:	d11a      	bne.n	3418d794 <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3418d75e:	f7ff fb33 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418d762:	4602      	mov	r2, r0
3418d764:	687b      	ldr	r3, [r7, #4]
3418d766:	6a1b      	ldr	r3, [r3, #32]
3418d768:	4619      	mov	r1, r3
3418d76a:	4610      	mov	r0, r2
3418d76c:	f000 fd14 	bl	3418e198 <RCC_IC_CheckPLLSources>
3418d770:	4603      	mov	r3, r0
3418d772:	2b01      	cmp	r3, #1
3418d774:	d001      	beq.n	3418d77a <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
3418d776:	2301      	movs	r3, #1
3418d778:	e15a      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3418d77a:	687b      	ldr	r3, [r7, #4]
3418d77c:	6a1a      	ldr	r2, [r3, #32]
3418d77e:	687b      	ldr	r3, [r7, #4]
3418d780:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d782:	3b01      	subs	r3, #1
3418d784:	041b      	lsls	r3, r3, #16
3418d786:	4958      	ldr	r1, [pc, #352]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d788:	4313      	orrs	r3, r2
3418d78a:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
3418d78e:	f7ff fb0d 	bl	3418cdac <LL_RCC_IC1_Enable>
3418d792:	e012      	b.n	3418d7ba <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3418d794:	687b      	ldr	r3, [r7, #4]
3418d796:	685b      	ldr	r3, [r3, #4]
3418d798:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418d79c:	d106      	bne.n	3418d7ac <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418d79e:	f7ff f97b 	bl	3418ca98 <LL_RCC_MSI_IsReady>
3418d7a2:	4603      	mov	r3, r0
3418d7a4:	2b00      	cmp	r3, #0
3418d7a6:	d108      	bne.n	3418d7ba <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418d7a8:	2301      	movs	r3, #1
3418d7aa:	e141      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418d7ac:	f7ff f90c 	bl	3418c9c8 <LL_RCC_HSI_IsReady>
3418d7b0:	4603      	mov	r3, r0
3418d7b2:	2b00      	cmp	r3, #0
3418d7b4:	d101      	bne.n	3418d7ba <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3418d7b6:	2301      	movs	r3, #1
3418d7b8:	e13a      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3418d7ba:	4b4b      	ldr	r3, [pc, #300]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d7bc:	6a1b      	ldr	r3, [r3, #32]
3418d7be:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3418d7c2:	687b      	ldr	r3, [r7, #4]
3418d7c4:	685b      	ldr	r3, [r3, #4]
3418d7c6:	4948      	ldr	r1, [pc, #288]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d7c8:	4313      	orrs	r3, r2
3418d7ca:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418d7cc:	f7f8 fea0 	bl	34186510 <HAL_GetTick>
3418d7d0:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418d7d2:	e00a      	b.n	3418d7ea <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418d7d4:	f7f8 fe9c 	bl	34186510 <HAL_GetTick>
3418d7d8:	4602      	mov	r2, r0
3418d7da:	68fb      	ldr	r3, [r7, #12]
3418d7dc:	1ad3      	subs	r3, r2, r3
3418d7de:	f241 3288 	movw	r2, #5000	@ 0x1388
3418d7e2:	4293      	cmp	r3, r2
3418d7e4:	d901      	bls.n	3418d7ea <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
3418d7e6:	2303      	movs	r3, #3
3418d7e8:	e122      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3418d7ea:	f7ff f9cf 	bl	3418cb8c <LL_RCC_GetCpuClkSource>
3418d7ee:	4602      	mov	r2, r0
3418d7f0:	687b      	ldr	r3, [r7, #4]
3418d7f2:	685b      	ldr	r3, [r3, #4]
3418d7f4:	011b      	lsls	r3, r3, #4
3418d7f6:	429a      	cmp	r2, r3
3418d7f8:	d1ec      	bne.n	3418d7d4 <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3418d7fa:	f000 f921 	bl	3418da40 <HAL_RCC_GetCpuClockFreq>
3418d7fe:	4603      	mov	r3, r0
3418d800:	4a3a      	ldr	r2, [pc, #232]	@ (3418d8ec <HAL_RCC_ClockConfig+0x2b4>)
3418d802:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3418d804:	687b      	ldr	r3, [r7, #4]
3418d806:	681b      	ldr	r3, [r3, #0]
3418d808:	f003 0302 	and.w	r3, r3, #2
3418d80c:	2b00      	cmp	r3, #0
3418d80e:	f000 8096 	beq.w	3418d93e <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3418d812:	687b      	ldr	r3, [r7, #4]
3418d814:	689b      	ldr	r3, [r3, #8]
3418d816:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3418d81a:	d106      	bne.n	3418d82a <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3418d81c:	f7ff f8a4 	bl	3418c968 <LL_RCC_HSE_IsReady>
3418d820:	4603      	mov	r3, r0
3418d822:	2b00      	cmp	r3, #0
3418d824:	d16b      	bne.n	3418d8fe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418d826:	2301      	movs	r3, #1
3418d828:	e102      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3418d82a:	687b      	ldr	r3, [r7, #4]
3418d82c:	689b      	ldr	r3, [r3, #8]
3418d82e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3418d832:	d14d      	bne.n	3418d8d0 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3418d834:	f7ff fae6 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418d838:	4602      	mov	r2, r0
3418d83a:	687b      	ldr	r3, [r7, #4]
3418d83c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3418d83e:	4619      	mov	r1, r3
3418d840:	4610      	mov	r0, r2
3418d842:	f000 fca9 	bl	3418e198 <RCC_IC_CheckPLLSources>
3418d846:	4603      	mov	r3, r0
3418d848:	2b01      	cmp	r3, #1
3418d84a:	d001      	beq.n	3418d850 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
3418d84c:	2301      	movs	r3, #1
3418d84e:	e0ef      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3418d850:	f7ff faf6 	bl	3418ce40 <LL_RCC_IC6_GetSource>
3418d854:	4602      	mov	r2, r0
3418d856:	687b      	ldr	r3, [r7, #4]
3418d858:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3418d85a:	4619      	mov	r1, r3
3418d85c:	4610      	mov	r0, r2
3418d85e:	f000 fc9b 	bl	3418e198 <RCC_IC_CheckPLLSources>
3418d862:	4603      	mov	r3, r0
3418d864:	2b01      	cmp	r3, #1
3418d866:	d001      	beq.n	3418d86c <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
3418d868:	2301      	movs	r3, #1
3418d86a:	e0e1      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3418d86c:	f7ff faf6 	bl	3418ce5c <LL_RCC_IC11_GetSource>
3418d870:	4602      	mov	r2, r0
3418d872:	687b      	ldr	r3, [r7, #4]
3418d874:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3418d876:	4619      	mov	r1, r3
3418d878:	4610      	mov	r0, r2
3418d87a:	f000 fc8d 	bl	3418e198 <RCC_IC_CheckPLLSources>
3418d87e:	4603      	mov	r3, r0
3418d880:	2b01      	cmp	r3, #1
3418d882:	d001      	beq.n	3418d888 <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
3418d884:	2301      	movs	r3, #1
3418d886:	e0d3      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3418d888:	687b      	ldr	r3, [r7, #4]
3418d88a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418d88c:	687b      	ldr	r3, [r7, #4]
3418d88e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418d890:	3b01      	subs	r3, #1
3418d892:	041b      	lsls	r3, r3, #16
3418d894:	4914      	ldr	r1, [pc, #80]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d896:	4313      	orrs	r3, r2
3418d898:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3418d89c:	687b      	ldr	r3, [r7, #4]
3418d89e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3418d8a0:	687b      	ldr	r3, [r7, #4]
3418d8a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3418d8a4:	3b01      	subs	r3, #1
3418d8a6:	041b      	lsls	r3, r3, #16
3418d8a8:	490f      	ldr	r1, [pc, #60]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d8aa:	4313      	orrs	r3, r2
3418d8ac:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3418d8b0:	687b      	ldr	r3, [r7, #4]
3418d8b2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3418d8b4:	687b      	ldr	r3, [r7, #4]
3418d8b6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3418d8b8:	3b01      	subs	r3, #1
3418d8ba:	041b      	lsls	r3, r3, #16
3418d8bc:	490a      	ldr	r1, [pc, #40]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d8be:	4313      	orrs	r3, r2
3418d8c0:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3418d8c4:	4b08      	ldr	r3, [pc, #32]	@ (3418d8e8 <HAL_RCC_ClockConfig+0x2b0>)
3418d8c6:	f240 4222 	movw	r2, #1058	@ 0x422
3418d8ca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
3418d8ce:	e016      	b.n	3418d8fe <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3418d8d0:	687b      	ldr	r3, [r7, #4]
3418d8d2:	689b      	ldr	r3, [r3, #8]
3418d8d4:	2b00      	cmp	r3, #0
3418d8d6:	d10b      	bne.n	3418d8f0 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3418d8d8:	f7ff f876 	bl	3418c9c8 <LL_RCC_HSI_IsReady>
3418d8dc:	4603      	mov	r3, r0
3418d8de:	2b00      	cmp	r3, #0
3418d8e0:	d10d      	bne.n	3418d8fe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418d8e2:	2301      	movs	r3, #1
3418d8e4:	e0a4      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
3418d8e6:	bf00      	nop
3418d8e8:	56028000 	.word	0x56028000
3418d8ec:	341c0020 	.word	0x341c0020
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3418d8f0:	f7ff f8d2 	bl	3418ca98 <LL_RCC_MSI_IsReady>
3418d8f4:	4603      	mov	r3, r0
3418d8f6:	2b00      	cmp	r3, #0
3418d8f8:	d101      	bne.n	3418d8fe <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3418d8fa:	2301      	movs	r3, #1
3418d8fc:	e098      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3418d8fe:	4b4e      	ldr	r3, [pc, #312]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d900:	6a1b      	ldr	r3, [r3, #32]
3418d902:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418d906:	687b      	ldr	r3, [r7, #4]
3418d908:	689b      	ldr	r3, [r3, #8]
3418d90a:	494b      	ldr	r1, [pc, #300]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d90c:	4313      	orrs	r3, r2
3418d90e:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418d910:	f7f8 fdfe 	bl	34186510 <HAL_GetTick>
3418d914:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418d916:	e00a      	b.n	3418d92e <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3418d918:	f7f8 fdfa 	bl	34186510 <HAL_GetTick>
3418d91c:	4602      	mov	r2, r0
3418d91e:	68fb      	ldr	r3, [r7, #12]
3418d920:	1ad3      	subs	r3, r2, r3
3418d922:	f241 3288 	movw	r2, #5000	@ 0x1388
3418d926:	4293      	cmp	r3, r2
3418d928:	d901      	bls.n	3418d92e <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
3418d92a:	2303      	movs	r3, #3
3418d92c:	e080      	b.n	3418da30 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3418d92e:	f7ff f93b 	bl	3418cba8 <LL_RCC_GetSysClkSource>
3418d932:	4602      	mov	r2, r0
3418d934:	687b      	ldr	r3, [r7, #4]
3418d936:	689b      	ldr	r3, [r3, #8]
3418d938:	011b      	lsls	r3, r3, #4
3418d93a:	429a      	cmp	r2, r3
3418d93c:	d1ec      	bne.n	3418d918 <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3418d93e:	687b      	ldr	r3, [r7, #4]
3418d940:	681b      	ldr	r3, [r3, #0]
3418d942:	f003 0304 	and.w	r3, r3, #4
3418d946:	2b00      	cmp	r3, #0
3418d948:	d010      	beq.n	3418d96c <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3418d94a:	687b      	ldr	r3, [r7, #4]
3418d94c:	68da      	ldr	r2, [r3, #12]
3418d94e:	4b3a      	ldr	r3, [pc, #232]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d950:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d952:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3418d956:	429a      	cmp	r2, r3
3418d958:	d208      	bcs.n	3418d96c <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3418d95a:	4b37      	ldr	r3, [pc, #220]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d95c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d95e:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3418d962:	687b      	ldr	r3, [r7, #4]
3418d964:	68db      	ldr	r3, [r3, #12]
3418d966:	4934      	ldr	r1, [pc, #208]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d968:	4313      	orrs	r3, r2
3418d96a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3418d96c:	687b      	ldr	r3, [r7, #4]
3418d96e:	681b      	ldr	r3, [r3, #0]
3418d970:	f003 0308 	and.w	r3, r3, #8
3418d974:	2b00      	cmp	r3, #0
3418d976:	d010      	beq.n	3418d99a <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3418d978:	687b      	ldr	r3, [r7, #4]
3418d97a:	691a      	ldr	r2, [r3, #16]
3418d97c:	4b2e      	ldr	r3, [pc, #184]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d97e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d980:	f003 0307 	and.w	r3, r3, #7
3418d984:	429a      	cmp	r2, r3
3418d986:	d208      	bcs.n	3418d99a <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3418d988:	4b2b      	ldr	r3, [pc, #172]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d98a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d98c:	f023 0207 	bic.w	r2, r3, #7
3418d990:	687b      	ldr	r3, [r7, #4]
3418d992:	691b      	ldr	r3, [r3, #16]
3418d994:	4928      	ldr	r1, [pc, #160]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d996:	4313      	orrs	r3, r2
3418d998:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3418d99a:	687b      	ldr	r3, [r7, #4]
3418d99c:	681b      	ldr	r3, [r3, #0]
3418d99e:	f003 0310 	and.w	r3, r3, #16
3418d9a2:	2b00      	cmp	r3, #0
3418d9a4:	d010      	beq.n	3418d9c8 <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3418d9a6:	687b      	ldr	r3, [r7, #4]
3418d9a8:	695a      	ldr	r2, [r3, #20]
3418d9aa:	4b23      	ldr	r3, [pc, #140]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d9ae:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3418d9b2:	429a      	cmp	r2, r3
3418d9b4:	d208      	bcs.n	3418d9c8 <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3418d9b6:	4b20      	ldr	r3, [pc, #128]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d9ba:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3418d9be:	687b      	ldr	r3, [r7, #4]
3418d9c0:	695b      	ldr	r3, [r3, #20]
3418d9c2:	491d      	ldr	r1, [pc, #116]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9c4:	4313      	orrs	r3, r2
3418d9c6:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3418d9c8:	687b      	ldr	r3, [r7, #4]
3418d9ca:	681b      	ldr	r3, [r3, #0]
3418d9cc:	f003 0320 	and.w	r3, r3, #32
3418d9d0:	2b00      	cmp	r3, #0
3418d9d2:	d010      	beq.n	3418d9f6 <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3418d9d4:	687b      	ldr	r3, [r7, #4]
3418d9d6:	699a      	ldr	r2, [r3, #24]
3418d9d8:	4b17      	ldr	r3, [pc, #92]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9da:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d9dc:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3418d9e0:	429a      	cmp	r2, r3
3418d9e2:	d208      	bcs.n	3418d9f6 <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3418d9e4:	4b14      	ldr	r3, [pc, #80]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418d9e8:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3418d9ec:	687b      	ldr	r3, [r7, #4]
3418d9ee:	699b      	ldr	r3, [r3, #24]
3418d9f0:	4911      	ldr	r1, [pc, #68]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418d9f2:	4313      	orrs	r3, r2
3418d9f4:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3418d9f6:	687b      	ldr	r3, [r7, #4]
3418d9f8:	681b      	ldr	r3, [r3, #0]
3418d9fa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418d9fe:	2b00      	cmp	r3, #0
3418da00:	d010      	beq.n	3418da24 <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3418da02:	687b      	ldr	r3, [r7, #4]
3418da04:	69da      	ldr	r2, [r3, #28]
3418da06:	4b0c      	ldr	r3, [pc, #48]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418da08:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418da0a:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3418da0e:	429a      	cmp	r2, r3
3418da10:	d208      	bcs.n	3418da24 <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3418da12:	4b09      	ldr	r3, [pc, #36]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418da14:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418da16:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418da1a:	687b      	ldr	r3, [r7, #4]
3418da1c:	69db      	ldr	r3, [r3, #28]
3418da1e:	4906      	ldr	r1, [pc, #24]	@ (3418da38 <HAL_RCC_ClockConfig+0x400>)
3418da20:	4313      	orrs	r3, r2
3418da22:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3418da24:	4b05      	ldr	r3, [pc, #20]	@ (3418da3c <HAL_RCC_ClockConfig+0x404>)
3418da26:	681b      	ldr	r3, [r3, #0]
3418da28:	4618      	mov	r0, r3
3418da2a:	f7f8 fd27 	bl	3418647c <HAL_InitTick>
3418da2e:	4603      	mov	r3, r0
}
3418da30:	4618      	mov	r0, r3
3418da32:	3710      	adds	r7, #16
3418da34:	46bd      	mov	sp, r7
3418da36:	bd80      	pop	{r7, pc}
3418da38:	56028000 	.word	0x56028000
3418da3c:	341c0024 	.word	0x341c0024

3418da40 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
3418da40:	b580      	push	{r7, lr}
3418da42:	b082      	sub	sp, #8
3418da44:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3418da46:	2300      	movs	r3, #0
3418da48:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3418da4a:	f7ff f89f 	bl	3418cb8c <LL_RCC_GetCpuClkSource>
3418da4e:	4603      	mov	r3, r0
3418da50:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418da54:	d026      	beq.n	3418daa4 <HAL_RCC_GetCpuClockFreq+0x64>
3418da56:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3418da5a:	d861      	bhi.n	3418db20 <HAL_RCC_GetCpuClockFreq+0xe0>
3418da5c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418da60:	d01d      	beq.n	3418da9e <HAL_RCC_GetCpuClockFreq+0x5e>
3418da62:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3418da66:	d85b      	bhi.n	3418db20 <HAL_RCC_GetCpuClockFreq+0xe0>
3418da68:	2b00      	cmp	r3, #0
3418da6a:	d003      	beq.n	3418da74 <HAL_RCC_GetCpuClockFreq+0x34>
3418da6c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3418da70:	d009      	beq.n	3418da86 <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418da72:	e055      	b.n	3418db20 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418da74:	f7fe ffce 	bl	3418ca14 <LL_RCC_HSI_GetDivider>
3418da78:	4603      	mov	r3, r0
3418da7a:	09db      	lsrs	r3, r3, #7
3418da7c:	4a2b      	ldr	r2, [pc, #172]	@ (3418db2c <HAL_RCC_GetCpuClockFreq+0xec>)
3418da7e:	fa22 f303 	lsr.w	r3, r2, r3
3418da82:	607b      	str	r3, [r7, #4]
      break;
3418da84:	e04d      	b.n	3418db22 <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = RCC_GET_MSI_FREQUENCY();
3418da86:	4b2a      	ldr	r3, [pc, #168]	@ (3418db30 <HAL_RCC_GetCpuClockFreq+0xf0>)
3418da88:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418da8a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418da8e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418da92:	d101      	bne.n	3418da98 <HAL_RCC_GetCpuClockFreq+0x58>
3418da94:	4b27      	ldr	r3, [pc, #156]	@ (3418db34 <HAL_RCC_GetCpuClockFreq+0xf4>)
3418da96:	e000      	b.n	3418da9a <HAL_RCC_GetCpuClockFreq+0x5a>
3418da98:	4b27      	ldr	r3, [pc, #156]	@ (3418db38 <HAL_RCC_GetCpuClockFreq+0xf8>)
3418da9a:	607b      	str	r3, [r7, #4]
      break;
3418da9c:	e041      	b.n	3418db22 <HAL_RCC_GetCpuClockFreq+0xe2>
      frequency = HSE_VALUE;
3418da9e:	4b27      	ldr	r3, [pc, #156]	@ (3418db3c <HAL_RCC_GetCpuClockFreq+0xfc>)
3418daa0:	607b      	str	r3, [r7, #4]
      break;
3418daa2:	e03e      	b.n	3418db22 <HAL_RCC_GetCpuClockFreq+0xe2>
      ic_divider = LL_RCC_IC1_GetDivider();
3418daa4:	f7ff f99e 	bl	3418cde4 <LL_RCC_IC1_GetDivider>
3418daa8:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
3418daaa:	f7ff f98d 	bl	3418cdc8 <LL_RCC_IC1_GetSource>
3418daae:	4603      	mov	r3, r0
3418dab0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dab4:	d029      	beq.n	3418db0a <HAL_RCC_GetCpuClockFreq+0xca>
3418dab6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418daba:	d82f      	bhi.n	3418db1c <HAL_RCC_GetCpuClockFreq+0xdc>
3418dabc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dac0:	d01a      	beq.n	3418daf8 <HAL_RCC_GetCpuClockFreq+0xb8>
3418dac2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dac6:	d829      	bhi.n	3418db1c <HAL_RCC_GetCpuClockFreq+0xdc>
3418dac8:	2b00      	cmp	r3, #0
3418daca:	d003      	beq.n	3418dad4 <HAL_RCC_GetCpuClockFreq+0x94>
3418dacc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418dad0:	d009      	beq.n	3418dae6 <HAL_RCC_GetCpuClockFreq+0xa6>
          break;
3418dad2:	e023      	b.n	3418db1c <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418dad4:	f004 fed4 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
3418dad8:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418dada:	687a      	ldr	r2, [r7, #4]
3418dadc:	683b      	ldr	r3, [r7, #0]
3418dade:	fbb2 f3f3 	udiv	r3, r2, r3
3418dae2:	607b      	str	r3, [r7, #4]
          break;
3418dae4:	e01b      	b.n	3418db1e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418dae6:	f004 ff11 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3418daea:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418daec:	687a      	ldr	r2, [r7, #4]
3418daee:	683b      	ldr	r3, [r7, #0]
3418daf0:	fbb2 f3f3 	udiv	r3, r2, r3
3418daf4:	607b      	str	r3, [r7, #4]
          break;
3418daf6:	e012      	b.n	3418db1e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418daf8:	f004 ff4e 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3418dafc:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418dafe:	687a      	ldr	r2, [r7, #4]
3418db00:	683b      	ldr	r3, [r7, #0]
3418db02:	fbb2 f3f3 	udiv	r3, r2, r3
3418db06:	607b      	str	r3, [r7, #4]
          break;
3418db08:	e009      	b.n	3418db1e <HAL_RCC_GetCpuClockFreq+0xde>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418db0a:	f004 ff8b 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3418db0e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3418db10:	687a      	ldr	r2, [r7, #4]
3418db12:	683b      	ldr	r3, [r7, #0]
3418db14:	fbb2 f3f3 	udiv	r3, r2, r3
3418db18:	607b      	str	r3, [r7, #4]
          break;
3418db1a:	e000      	b.n	3418db1e <HAL_RCC_GetCpuClockFreq+0xde>
          break;
3418db1c:	bf00      	nop
      break;
3418db1e:	e000      	b.n	3418db22 <HAL_RCC_GetCpuClockFreq+0xe2>
      break;
3418db20:	bf00      	nop
  }

  return frequency;
3418db22:	687b      	ldr	r3, [r7, #4]
}
3418db24:	4618      	mov	r0, r3
3418db26:	3708      	adds	r7, #8
3418db28:	46bd      	mov	sp, r7
3418db2a:	bd80      	pop	{r7, pc}
3418db2c:	03d09000 	.word	0x03d09000
3418db30:	56028000 	.word	0x56028000
3418db34:	00f42400 	.word	0x00f42400
3418db38:	003d0900 	.word	0x003d0900
3418db3c:	02dc6c00 	.word	0x02dc6c00

3418db40 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
3418db40:	b598      	push	{r3, r4, r7, lr}
3418db42:	af00      	add	r7, sp, #0
  return RCC_GetSysClockFreq(LL_RCC_IC2_GetSource(), LL_RCC_IC2_GetDivider());
3418db44:	f7ff f95e 	bl	3418ce04 <LL_RCC_IC2_GetSource>
3418db48:	4604      	mov	r4, r0
3418db4a:	f7ff f969 	bl	3418ce20 <LL_RCC_IC2_GetDivider>
3418db4e:	4603      	mov	r3, r0
3418db50:	4619      	mov	r1, r3
3418db52:	4620      	mov	r0, r4
3418db54:	f000 f88e 	bl	3418dc74 <RCC_GetSysClockFreq>
3418db58:	4603      	mov	r3, r0
}
3418db5a:	4618      	mov	r0, r3
3418db5c:	bd98      	pop	{r3, r4, r7, pc}

3418db5e <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
3418db5e:	b598      	push	{r3, r4, r7, lr}
3418db60:	af00      	add	r7, sp, #0
  return LL_RCC_CALC_PCLK1_FREQ(LL_RCC_CALC_HCLK_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()),
3418db62:	f7ff ffed 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
3418db66:	4604      	mov	r4, r0
3418db68:	f7ff f82c 	bl	3418cbc4 <LL_RCC_GetAHBPrescaler>
3418db6c:	4603      	mov	r3, r0
3418db6e:	0d1b      	lsrs	r3, r3, #20
3418db70:	f003 0307 	and.w	r3, r3, #7
3418db74:	40dc      	lsrs	r4, r3
3418db76:	f7ff f833 	bl	3418cbe0 <LL_RCC_GetAPB1Prescaler>
3418db7a:	4603      	mov	r3, r0
3418db7c:	f003 0307 	and.w	r3, r3, #7
3418db80:	fa24 f303 	lsr.w	r3, r4, r3
                                LL_RCC_GetAPB1Prescaler());
}
3418db84:	4618      	mov	r0, r3
3418db86:	bd98      	pop	{r3, r4, r7, pc}

3418db88 <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3418db88:	b480      	push	{r7}
3418db8a:	b085      	sub	sp, #20
3418db8c:	af00      	add	r7, sp, #0
3418db8e:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
3418db90:	687b      	ldr	r3, [r7, #4]
3418db92:	227f      	movs	r2, #127	@ 0x7f
3418db94:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
3418db96:	4b36      	ldr	r3, [pc, #216]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418db98:	6a1b      	ldr	r3, [r3, #32]
3418db9a:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
3418db9c:	68fb      	ldr	r3, [r7, #12]
3418db9e:	091b      	lsrs	r3, r3, #4
3418dba0:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
3418dba4:	687b      	ldr	r3, [r7, #4]
3418dba6:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
3418dba8:	68fb      	ldr	r3, [r7, #12]
3418dbaa:	091b      	lsrs	r3, r3, #4
3418dbac:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
3418dbb0:	687b      	ldr	r3, [r7, #4]
3418dbb2:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
3418dbb4:	4b2e      	ldr	r3, [pc, #184]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418dbb6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418dbb8:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
3418dbba:	68fb      	ldr	r3, [r7, #12]
3418dbbc:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
3418dbc0:	687b      	ldr	r3, [r7, #4]
3418dbc2:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
3418dbc4:	68fb      	ldr	r3, [r7, #12]
3418dbc6:	f003 0207 	and.w	r2, r3, #7
3418dbca:	687b      	ldr	r3, [r7, #4]
3418dbcc:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
3418dbce:	68fb      	ldr	r3, [r7, #12]
3418dbd0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
3418dbd4:	687b      	ldr	r3, [r7, #4]
3418dbd6:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
3418dbd8:	68fb      	ldr	r3, [r7, #12]
3418dbda:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
3418dbde:	687b      	ldr	r3, [r7, #4]
3418dbe0:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
3418dbe2:	68fb      	ldr	r3, [r7, #12]
3418dbe4:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
3418dbe8:	687b      	ldr	r3, [r7, #4]
3418dbea:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
3418dbec:	4b20      	ldr	r3, [pc, #128]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418dbee:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3418dbf2:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
3418dbf4:	68fb      	ldr	r3, [r7, #12]
3418dbf6:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418dbfa:	687b      	ldr	r3, [r7, #4]
3418dbfc:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
3418dbfe:	68fb      	ldr	r3, [r7, #12]
3418dc00:	0c1b      	lsrs	r3, r3, #16
3418dc02:	b2db      	uxtb	r3, r3
3418dc04:	1c5a      	adds	r2, r3, #1
3418dc06:	687b      	ldr	r3, [r7, #4]
3418dc08:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
3418dc0a:	4b19      	ldr	r3, [pc, #100]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418dc0c:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3418dc10:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
3418dc12:	68fb      	ldr	r3, [r7, #12]
3418dc14:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418dc18:	687b      	ldr	r3, [r7, #4]
3418dc1a:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
3418dc1c:	68fb      	ldr	r3, [r7, #12]
3418dc1e:	0c1b      	lsrs	r3, r3, #16
3418dc20:	b2db      	uxtb	r3, r3
3418dc22:	1c5a      	adds	r2, r3, #1
3418dc24:	687b      	ldr	r3, [r7, #4]
3418dc26:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
3418dc28:	4b11      	ldr	r3, [pc, #68]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418dc2a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3418dc2e:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
3418dc30:	68fb      	ldr	r3, [r7, #12]
3418dc32:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418dc36:	687b      	ldr	r3, [r7, #4]
3418dc38:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
3418dc3a:	68fb      	ldr	r3, [r7, #12]
3418dc3c:	0c1b      	lsrs	r3, r3, #16
3418dc3e:	b2db      	uxtb	r3, r3
3418dc40:	1c5a      	adds	r2, r3, #1
3418dc42:	687b      	ldr	r3, [r7, #4]
3418dc44:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
3418dc46:	4b0a      	ldr	r3, [pc, #40]	@ (3418dc70 <HAL_RCC_GetClockConfig+0xe8>)
3418dc48:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3418dc4c:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
3418dc4e:	68fb      	ldr	r3, [r7, #12]
3418dc50:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3418dc54:	687b      	ldr	r3, [r7, #4]
3418dc56:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
3418dc58:	68fb      	ldr	r3, [r7, #12]
3418dc5a:	0c1b      	lsrs	r3, r3, #16
3418dc5c:	b2db      	uxtb	r3, r3
3418dc5e:	1c5a      	adds	r2, r3, #1
3418dc60:	687b      	ldr	r3, [r7, #4]
3418dc62:	63da      	str	r2, [r3, #60]	@ 0x3c
}
3418dc64:	bf00      	nop
3418dc66:	3714      	adds	r7, #20
3418dc68:	46bd      	mov	sp, r7
3418dc6a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418dc6e:	4770      	bx	lr
3418dc70:	56028000 	.word	0x56028000

3418dc74 <RCC_GetSysClockFreq>:
  * @param  icx_divider The intermediate clock divider
  *
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreq(uint32_t icx_source, uint32_t icx_divider)
{
3418dc74:	b580      	push	{r7, lr}
3418dc76:	b084      	sub	sp, #16
3418dc78:	af00      	add	r7, sp, #0
3418dc7a:	6078      	str	r0, [r7, #4]
3418dc7c:	6039      	str	r1, [r7, #0]
  uint32_t frequency = 0U;
3418dc7e:	2300      	movs	r3, #0
3418dc80:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3418dc82:	f7fe ff91 	bl	3418cba8 <LL_RCC_GetSysClkSource>
3418dc86:	4603      	mov	r3, r0
3418dc88:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dc8c:	d026      	beq.n	3418dcdc <RCC_GetSysClockFreq+0x68>
3418dc8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dc92:	d861      	bhi.n	3418dd58 <RCC_GetSysClockFreq+0xe4>
3418dc94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dc98:	d01d      	beq.n	3418dcd6 <RCC_GetSysClockFreq+0x62>
3418dc9a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dc9e:	d85b      	bhi.n	3418dd58 <RCC_GetSysClockFreq+0xe4>
3418dca0:	2b00      	cmp	r3, #0
3418dca2:	d003      	beq.n	3418dcac <RCC_GetSysClockFreq+0x38>
3418dca4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418dca8:	d009      	beq.n	3418dcbe <RCC_GetSysClockFreq+0x4a>
      }
      break;

    default:
      /* Unexpected case */
      break;
3418dcaa:	e055      	b.n	3418dd58 <RCC_GetSysClockFreq+0xe4>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3418dcac:	f7fe feb2 	bl	3418ca14 <LL_RCC_HSI_GetDivider>
3418dcb0:	4603      	mov	r3, r0
3418dcb2:	09db      	lsrs	r3, r3, #7
3418dcb4:	4a2b      	ldr	r2, [pc, #172]	@ (3418dd64 <RCC_GetSysClockFreq+0xf0>)
3418dcb6:	fa22 f303 	lsr.w	r3, r2, r3
3418dcba:	60fb      	str	r3, [r7, #12]
      break;
3418dcbc:	e04d      	b.n	3418dd5a <RCC_GetSysClockFreq+0xe6>
      frequency = RCC_GET_MSI_FREQUENCY();
3418dcbe:	4b2a      	ldr	r3, [pc, #168]	@ (3418dd68 <RCC_GetSysClockFreq+0xf4>)
3418dcc0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418dcc2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418dcc6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418dcca:	d101      	bne.n	3418dcd0 <RCC_GetSysClockFreq+0x5c>
3418dccc:	4b27      	ldr	r3, [pc, #156]	@ (3418dd6c <RCC_GetSysClockFreq+0xf8>)
3418dcce:	e000      	b.n	3418dcd2 <RCC_GetSysClockFreq+0x5e>
3418dcd0:	4b27      	ldr	r3, [pc, #156]	@ (3418dd70 <RCC_GetSysClockFreq+0xfc>)
3418dcd2:	60fb      	str	r3, [r7, #12]
      break;
3418dcd4:	e041      	b.n	3418dd5a <RCC_GetSysClockFreq+0xe6>
      frequency = HSE_VALUE;
3418dcd6:	4b27      	ldr	r3, [pc, #156]	@ (3418dd74 <RCC_GetSysClockFreq+0x100>)
3418dcd8:	60fb      	str	r3, [r7, #12]
      break;
3418dcda:	e03e      	b.n	3418dd5a <RCC_GetSysClockFreq+0xe6>
      switch (icx_source)
3418dcdc:	687b      	ldr	r3, [r7, #4]
3418dcde:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dce2:	d02e      	beq.n	3418dd42 <RCC_GetSysClockFreq+0xce>
3418dce4:	687b      	ldr	r3, [r7, #4]
3418dce6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418dcea:	d833      	bhi.n	3418dd54 <RCC_GetSysClockFreq+0xe0>
3418dcec:	687b      	ldr	r3, [r7, #4]
3418dcee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dcf2:	d01d      	beq.n	3418dd30 <RCC_GetSysClockFreq+0xbc>
3418dcf4:	687b      	ldr	r3, [r7, #4]
3418dcf6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418dcfa:	d82b      	bhi.n	3418dd54 <RCC_GetSysClockFreq+0xe0>
3418dcfc:	687b      	ldr	r3, [r7, #4]
3418dcfe:	2b00      	cmp	r3, #0
3418dd00:	d004      	beq.n	3418dd0c <RCC_GetSysClockFreq+0x98>
3418dd02:	687b      	ldr	r3, [r7, #4]
3418dd04:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418dd08:	d009      	beq.n	3418dd1e <RCC_GetSysClockFreq+0xaa>
          break;
3418dd0a:	e023      	b.n	3418dd54 <RCC_GetSysClockFreq+0xe0>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3418dd0c:	f004 fdb8 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
3418dd10:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418dd12:	68fa      	ldr	r2, [r7, #12]
3418dd14:	683b      	ldr	r3, [r7, #0]
3418dd16:	fbb2 f3f3 	udiv	r3, r2, r3
3418dd1a:	60fb      	str	r3, [r7, #12]
          break;
3418dd1c:	e01b      	b.n	3418dd56 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3418dd1e:	f004 fdf5 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3418dd22:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418dd24:	68fa      	ldr	r2, [r7, #12]
3418dd26:	683b      	ldr	r3, [r7, #0]
3418dd28:	fbb2 f3f3 	udiv	r3, r2, r3
3418dd2c:	60fb      	str	r3, [r7, #12]
          break;
3418dd2e:	e012      	b.n	3418dd56 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3418dd30:	f004 fe32 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3418dd34:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418dd36:	68fa      	ldr	r2, [r7, #12]
3418dd38:	683b      	ldr	r3, [r7, #0]
3418dd3a:	fbb2 f3f3 	udiv	r3, r2, r3
3418dd3e:	60fb      	str	r3, [r7, #12]
          break;
3418dd40:	e009      	b.n	3418dd56 <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3418dd42:	f004 fe6f 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3418dd46:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3418dd48:	68fa      	ldr	r2, [r7, #12]
3418dd4a:	683b      	ldr	r3, [r7, #0]
3418dd4c:	fbb2 f3f3 	udiv	r3, r2, r3
3418dd50:	60fb      	str	r3, [r7, #12]
          break;
3418dd52:	e000      	b.n	3418dd56 <RCC_GetSysClockFreq+0xe2>
          break;
3418dd54:	bf00      	nop
      break;
3418dd56:	e000      	b.n	3418dd5a <RCC_GetSysClockFreq+0xe6>
      break;
3418dd58:	bf00      	nop
  }

  return frequency;
3418dd5a:	68fb      	ldr	r3, [r7, #12]
}
3418dd5c:	4618      	mov	r0, r3
3418dd5e:	3710      	adds	r7, #16
3418dd60:	46bd      	mov	sp, r7
3418dd62:	bd80      	pop	{r7, pc}
3418dd64:	03d09000 	.word	0x03d09000
3418dd68:	56028000 	.word	0x56028000
3418dd6c:	00f42400 	.word	0x00f42400
3418dd70:	003d0900 	.word	0x003d0900
3418dd74:	02dc6c00 	.word	0x02dc6c00

3418dd78 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418dd78:	b580      	push	{r7, lr}
3418dd7a:	b088      	sub	sp, #32
3418dd7c:	af00      	add	r7, sp, #0
3418dd7e:	6078      	str	r0, [r7, #4]
3418dd80:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3418dd82:	2300      	movs	r3, #0
3418dd84:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418dd86:	687b      	ldr	r3, [r7, #4]
3418dd88:	011a      	lsls	r2, r3, #4
3418dd8a:	4b8e      	ldr	r3, [pc, #568]	@ (3418dfc4 <RCC_PLL_Config+0x24c>)
3418dd8c:	4413      	add	r3, r2
3418dd8e:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418dd90:	687b      	ldr	r3, [r7, #4]
3418dd92:	011a      	lsls	r2, r3, #4
3418dd94:	4b8c      	ldr	r3, [pc, #560]	@ (3418dfc8 <RCC_PLL_Config+0x250>)
3418dd96:	4413      	add	r3, r2
3418dd98:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418dd9a:	687b      	ldr	r3, [r7, #4]
3418dd9c:	011a      	lsls	r2, r3, #4
3418dd9e:	4b8b      	ldr	r3, [pc, #556]	@ (3418dfcc <RCC_PLL_Config+0x254>)
3418dda0:	4413      	add	r3, r2
3418dda2:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3418dda4:	683b      	ldr	r3, [r7, #0]
3418dda6:	681b      	ldr	r3, [r3, #0]
3418dda8:	2b02      	cmp	r3, #2
3418ddaa:	f040 8091 	bne.w	3418ded0 <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418ddae:	4a88      	ldr	r2, [pc, #544]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418ddb0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ddb4:	687b      	ldr	r3, [r7, #4]
3418ddb6:	fa01 f303 	lsl.w	r3, r1, r3
3418ddba:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418ddbe:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418ddc0:	f7f8 fba6 	bl	34186510 <HAL_GetTick>
3418ddc4:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ddc6:	e008      	b.n	3418ddda <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418ddc8:	f7f8 fba2 	bl	34186510 <HAL_GetTick>
3418ddcc:	4602      	mov	r2, r0
3418ddce:	68fb      	ldr	r3, [r7, #12]
3418ddd0:	1ad3      	subs	r3, r2, r3
3418ddd2:	2b01      	cmp	r3, #1
3418ddd4:	d901      	bls.n	3418ddda <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
3418ddd6:	2303      	movs	r3, #3
3418ddd8:	e0f0      	b.n	3418dfbc <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418ddda:	4b7d      	ldr	r3, [pc, #500]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418dddc:	685a      	ldr	r2, [r3, #4]
3418ddde:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418dde2:	687b      	ldr	r3, [r7, #4]
3418dde4:	fa01 f303 	lsl.w	r3, r1, r3
3418dde8:	401a      	ands	r2, r3
3418ddea:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418ddee:	687b      	ldr	r3, [r7, #4]
3418ddf0:	fa01 f303 	lsl.w	r3, r1, r3
3418ddf4:	429a      	cmp	r2, r3
3418ddf6:	d0e7      	beq.n	3418ddc8 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3418ddf8:	693b      	ldr	r3, [r7, #16]
3418ddfa:	681b      	ldr	r3, [r3, #0]
3418ddfc:	f043 0204 	orr.w	r2, r3, #4
3418de00:	693b      	ldr	r3, [r7, #16]
3418de02:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418de04:	69bb      	ldr	r3, [r7, #24]
3418de06:	681b      	ldr	r3, [r3, #0]
3418de08:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418de0c:	69bb      	ldr	r3, [r7, #24]
3418de0e:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3418de10:	69bb      	ldr	r3, [r7, #24]
3418de12:	681a      	ldr	r2, [r3, #0]
3418de14:	4b6f      	ldr	r3, [pc, #444]	@ (3418dfd4 <RCC_PLL_Config+0x25c>)
3418de16:	4013      	ands	r3, r2
3418de18:	683a      	ldr	r2, [r7, #0]
3418de1a:	6851      	ldr	r1, [r2, #4]
3418de1c:	683a      	ldr	r2, [r7, #0]
3418de1e:	6892      	ldr	r2, [r2, #8]
3418de20:	0512      	lsls	r2, r2, #20
3418de22:	4311      	orrs	r1, r2
3418de24:	683a      	ldr	r2, [r7, #0]
3418de26:	6912      	ldr	r2, [r2, #16]
3418de28:	0212      	lsls	r2, r2, #8
3418de2a:	430a      	orrs	r2, r1
3418de2c:	431a      	orrs	r2, r3
3418de2e:	69bb      	ldr	r3, [r7, #24]
3418de30:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3418de32:	693b      	ldr	r3, [r7, #16]
3418de34:	681b      	ldr	r3, [r3, #0]
3418de36:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3418de3a:	683b      	ldr	r3, [r7, #0]
3418de3c:	695b      	ldr	r3, [r3, #20]
3418de3e:	06d9      	lsls	r1, r3, #27
3418de40:	683b      	ldr	r3, [r7, #0]
3418de42:	699b      	ldr	r3, [r3, #24]
3418de44:	061b      	lsls	r3, r3, #24
3418de46:	430b      	orrs	r3, r1
3418de48:	431a      	orrs	r2, r3
3418de4a:	693b      	ldr	r3, [r7, #16]
3418de4c:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3418de4e:	697b      	ldr	r3, [r7, #20]
3418de50:	681b      	ldr	r3, [r3, #0]
3418de52:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3418de56:	683b      	ldr	r3, [r7, #0]
3418de58:	68db      	ldr	r3, [r3, #12]
3418de5a:	431a      	orrs	r2, r3
3418de5c:	697b      	ldr	r3, [r7, #20]
3418de5e:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3418de60:	693b      	ldr	r3, [r7, #16]
3418de62:	681b      	ldr	r3, [r3, #0]
3418de64:	f023 0208 	bic.w	r2, r3, #8
3418de68:	693b      	ldr	r3, [r7, #16]
3418de6a:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
3418de6c:	683b      	ldr	r3, [r7, #0]
3418de6e:	68db      	ldr	r3, [r3, #12]
3418de70:	2b00      	cmp	r3, #0
3418de72:	d005      	beq.n	3418de80 <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3418de74:	693b      	ldr	r3, [r7, #16]
3418de76:	681b      	ldr	r3, [r3, #0]
3418de78:	f043 020a 	orr.w	r2, r3, #10
3418de7c:	693b      	ldr	r3, [r7, #16]
3418de7e:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3418de80:	693b      	ldr	r3, [r7, #16]
3418de82:	681b      	ldr	r3, [r3, #0]
3418de84:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3418de88:	f043 0301 	orr.w	r3, r3, #1
3418de8c:	693a      	ldr	r2, [r7, #16]
3418de8e:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418de90:	4a4f      	ldr	r2, [pc, #316]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418de92:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418de96:	687b      	ldr	r3, [r7, #4]
3418de98:	fa01 f303 	lsl.w	r3, r1, r3
3418de9c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418dea0:	f7f8 fb36 	bl	34186510 <HAL_GetTick>
3418dea4:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418dea6:	e008      	b.n	3418deba <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418dea8:	f7f8 fb32 	bl	34186510 <HAL_GetTick>
3418deac:	4602      	mov	r2, r0
3418deae:	68fb      	ldr	r3, [r7, #12]
3418deb0:	1ad3      	subs	r3, r2, r3
3418deb2:	2b01      	cmp	r3, #1
3418deb4:	d901      	bls.n	3418deba <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
3418deb6:	2303      	movs	r3, #3
3418deb8:	e080      	b.n	3418dfbc <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418deba:	4b45      	ldr	r3, [pc, #276]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418debc:	685a      	ldr	r2, [r3, #4]
3418debe:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418dec2:	687b      	ldr	r3, [r7, #4]
3418dec4:	fa01 f303 	lsl.w	r3, r1, r3
3418dec8:	4013      	ands	r3, r2
3418deca:	2b00      	cmp	r3, #0
3418decc:	d0ec      	beq.n	3418dea8 <RCC_PLL_Config+0x130>
3418dece:	e074      	b.n	3418dfba <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3418ded0:	683b      	ldr	r3, [r7, #0]
3418ded2:	681b      	ldr	r3, [r3, #0]
3418ded4:	2b03      	cmp	r3, #3
3418ded6:	d13b      	bne.n	3418df50 <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3418ded8:	683b      	ldr	r3, [r7, #0]
3418deda:	685b      	ldr	r3, [r3, #4]
3418dedc:	4618      	mov	r0, r3
3418dede:	f000 f921 	bl	3418e124 <RCC_PLL_Source_IsReady>
3418dee2:	4603      	mov	r3, r0
3418dee4:	2b01      	cmp	r3, #1
3418dee6:	d130      	bne.n	3418df4a <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418dee8:	4a39      	ldr	r2, [pc, #228]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418deea:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418deee:	687b      	ldr	r3, [r7, #4]
3418def0:	fa01 f303 	lsl.w	r3, r1, r3
3418def4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418def8:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3418defa:	f7f8 fb09 	bl	34186510 <HAL_GetTick>
3418defe:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418df00:	e008      	b.n	3418df14 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418df02:	f7f8 fb05 	bl	34186510 <HAL_GetTick>
3418df06:	4602      	mov	r2, r0
3418df08:	68fb      	ldr	r3, [r7, #12]
3418df0a:	1ad3      	subs	r3, r2, r3
3418df0c:	2b01      	cmp	r3, #1
3418df0e:	d901      	bls.n	3418df14 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
3418df10:	2303      	movs	r3, #3
3418df12:	e053      	b.n	3418dfbc <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418df14:	4b2e      	ldr	r3, [pc, #184]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418df16:	685a      	ldr	r2, [r3, #4]
3418df18:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418df1c:	687b      	ldr	r3, [r7, #4]
3418df1e:	fa01 f303 	lsl.w	r3, r1, r3
3418df22:	401a      	ands	r2, r3
3418df24:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418df28:	687b      	ldr	r3, [r7, #4]
3418df2a:	fa01 f303 	lsl.w	r3, r1, r3
3418df2e:	429a      	cmp	r2, r3
3418df30:	d0e7      	beq.n	3418df02 <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3418df32:	69bb      	ldr	r3, [r7, #24]
3418df34:	681b      	ldr	r3, [r3, #0]
3418df36:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3418df3a:	683b      	ldr	r3, [r7, #0]
3418df3c:	685b      	ldr	r3, [r3, #4]
3418df3e:	4313      	orrs	r3, r2
3418df40:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3418df44:	69bb      	ldr	r3, [r7, #24]
3418df46:	601a      	str	r2, [r3, #0]
3418df48:	e037      	b.n	3418dfba <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3418df4a:	2301      	movs	r3, #1
3418df4c:	77fb      	strb	r3, [r7, #31]
3418df4e:	e034      	b.n	3418dfba <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3418df50:	683b      	ldr	r3, [r7, #0]
3418df52:	681b      	ldr	r3, [r3, #0]
3418df54:	2b01      	cmp	r3, #1
3418df56:	d130      	bne.n	3418dfba <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3418df58:	693b      	ldr	r3, [r7, #16]
3418df5a:	681b      	ldr	r3, [r3, #0]
3418df5c:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3418df60:	693b      	ldr	r3, [r7, #16]
3418df62:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3418df64:	4a1a      	ldr	r2, [pc, #104]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418df66:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418df6a:	687b      	ldr	r3, [r7, #4]
3418df6c:	fa01 f303 	lsl.w	r3, r1, r3
3418df70:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3418df74:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3418df76:	f7f8 facb 	bl	34186510 <HAL_GetTick>
3418df7a:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418df7c:	e008      	b.n	3418df90 <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418df7e:	f7f8 fac7 	bl	34186510 <HAL_GetTick>
3418df82:	4602      	mov	r2, r0
3418df84:	68fb      	ldr	r3, [r7, #12]
3418df86:	1ad3      	subs	r3, r2, r3
3418df88:	2b01      	cmp	r3, #1
3418df8a:	d901      	bls.n	3418df90 <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
3418df8c:	2303      	movs	r3, #3
3418df8e:	e015      	b.n	3418dfbc <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418df90:	4b0f      	ldr	r3, [pc, #60]	@ (3418dfd0 <RCC_PLL_Config+0x258>)
3418df92:	685a      	ldr	r2, [r3, #4]
3418df94:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418df98:	687b      	ldr	r3, [r7, #4]
3418df9a:	fa01 f303 	lsl.w	r3, r1, r3
3418df9e:	401a      	ands	r2, r3
3418dfa0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418dfa4:	687b      	ldr	r3, [r7, #4]
3418dfa6:	fa01 f303 	lsl.w	r3, r1, r3
3418dfaa:	429a      	cmp	r2, r3
3418dfac:	d0e7      	beq.n	3418df7e <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3418dfae:	69bb      	ldr	r3, [r7, #24]
3418dfb0:	681b      	ldr	r3, [r3, #0]
3418dfb2:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3418dfb6:	69bb      	ldr	r3, [r7, #24]
3418dfb8:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3418dfba:	7ffb      	ldrb	r3, [r7, #31]
}
3418dfbc:	4618      	mov	r0, r3
3418dfbe:	3720      	adds	r7, #32
3418dfc0:	46bd      	mov	sp, r7
3418dfc2:	bd80      	pop	{r7, pc}
3418dfc4:	56028080 	.word	0x56028080
3418dfc8:	56028084 	.word	0x56028084
3418dfcc:	56028088 	.word	0x56028088
3418dfd0:	56028000 	.word	0x56028000
3418dfd4:	8c0000ff 	.word	0x8c0000ff

3418dfd8 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
3418dfd8:	b580      	push	{r7, lr}
3418dfda:	b084      	sub	sp, #16
3418dfdc:	af00      	add	r7, sp, #0
3418dfde:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
3418dfe0:	2300      	movs	r3, #0
3418dfe2:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3418dfe4:	4a11      	ldr	r2, [pc, #68]	@ (3418e02c <RCC_PLL_Enable+0x54>)
3418dfe6:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418dfea:	687b      	ldr	r3, [r7, #4]
3418dfec:	fa01 f303 	lsl.w	r3, r1, r3
3418dff0:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
3418dff4:	f7f8 fa8c 	bl	34186510 <HAL_GetTick>
3418dff8:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418dffa:	e008      	b.n	3418e00e <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3418dffc:	f7f8 fa88 	bl	34186510 <HAL_GetTick>
3418e000:	4602      	mov	r2, r0
3418e002:	68bb      	ldr	r3, [r7, #8]
3418e004:	1ad3      	subs	r3, r2, r3
3418e006:	2b01      	cmp	r3, #1
3418e008:	d901      	bls.n	3418e00e <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3418e00a:	2303      	movs	r3, #3
3418e00c:	e00a      	b.n	3418e024 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3418e00e:	4b07      	ldr	r3, [pc, #28]	@ (3418e02c <RCC_PLL_Enable+0x54>)
3418e010:	685a      	ldr	r2, [r3, #4]
3418e012:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418e016:	687b      	ldr	r3, [r7, #4]
3418e018:	fa01 f303 	lsl.w	r3, r1, r3
3418e01c:	4013      	ands	r3, r2
3418e01e:	2b00      	cmp	r3, #0
3418e020:	d0ec      	beq.n	3418dffc <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3418e022:	7bfb      	ldrb	r3, [r7, #15]
}
3418e024:	4618      	mov	r0, r3
3418e026:	3710      	adds	r7, #16
3418e028:	46bd      	mov	sp, r7
3418e02a:	bd80      	pop	{r7, pc}
3418e02c:	56028000 	.word	0x56028000

3418e030 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3418e030:	b480      	push	{r7}
3418e032:	b089      	sub	sp, #36	@ 0x24
3418e034:	af00      	add	r7, sp, #0
3418e036:	6078      	str	r0, [r7, #4]
3418e038:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3418e03a:	2300      	movs	r3, #0
3418e03c:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3418e03e:	687b      	ldr	r3, [r7, #4]
3418e040:	011a      	lsls	r2, r3, #4
3418e042:	4b34      	ldr	r3, [pc, #208]	@ (3418e114 <RCC_PLL_IsNewConfig+0xe4>)
3418e044:	4413      	add	r3, r2
3418e046:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3418e048:	687b      	ldr	r3, [r7, #4]
3418e04a:	011a      	lsls	r2, r3, #4
3418e04c:	4b32      	ldr	r3, [pc, #200]	@ (3418e118 <RCC_PLL_IsNewConfig+0xe8>)
3418e04e:	4413      	add	r3, r2
3418e050:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3418e052:	687b      	ldr	r3, [r7, #4]
3418e054:	011a      	lsls	r2, r3, #4
3418e056:	4b31      	ldr	r3, [pc, #196]	@ (3418e11c <RCC_PLL_IsNewConfig+0xec>)
3418e058:	4413      	add	r3, r2
3418e05a:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418e05c:	697b      	ldr	r3, [r7, #20]
3418e05e:	681b      	ldr	r3, [r3, #0]
3418e060:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3418e064:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
3418e068:	683a      	ldr	r2, [r7, #0]
3418e06a:	6851      	ldr	r1, [r2, #4]
3418e06c:	683a      	ldr	r2, [r7, #0]
3418e06e:	6892      	ldr	r2, [r2, #8]
3418e070:	0512      	lsls	r2, r2, #20
3418e072:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3418e074:	683a      	ldr	r2, [r7, #0]
3418e076:	6912      	ldr	r2, [r2, #16]
3418e078:	0212      	lsls	r2, r2, #8
3418e07a:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3418e07c:	4293      	cmp	r3, r2
3418e07e:	d002      	beq.n	3418e086 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3418e080:	2301      	movs	r3, #1
3418e082:	61fb      	str	r3, [r7, #28]
3418e084:	e03e      	b.n	3418e104 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418e086:	693b      	ldr	r3, [r7, #16]
3418e088:	681b      	ldr	r3, [r3, #0]
3418e08a:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3418e08e:	683b      	ldr	r3, [r7, #0]
3418e090:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3418e092:	429a      	cmp	r2, r3
3418e094:	d002      	beq.n	3418e09c <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3418e096:	2301      	movs	r3, #1
3418e098:	61fb      	str	r3, [r7, #28]
3418e09a:	e033      	b.n	3418e104 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418e09c:	68fb      	ldr	r3, [r7, #12]
3418e09e:	681b      	ldr	r3, [r3, #0]
3418e0a0:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3418e0a4:	683b      	ldr	r3, [r7, #0]
3418e0a6:	695b      	ldr	r3, [r3, #20]
3418e0a8:	06d9      	lsls	r1, r3, #27
3418e0aa:	683b      	ldr	r3, [r7, #0]
3418e0ac:	699b      	ldr	r3, [r3, #24]
3418e0ae:	061b      	lsls	r3, r3, #24
3418e0b0:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3418e0b2:	429a      	cmp	r2, r3
3418e0b4:	d002      	beq.n	3418e0bc <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
3418e0b6:	2301      	movs	r3, #1
3418e0b8:	61fb      	str	r3, [r7, #28]
3418e0ba:	e023      	b.n	3418e104 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3418e0bc:	4b18      	ldr	r3, [pc, #96]	@ (3418e120 <RCC_PLL_IsNewConfig+0xf0>)
3418e0be:	685a      	ldr	r2, [r3, #4]
3418e0c0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418e0c4:	687b      	ldr	r3, [r7, #4]
3418e0c6:	fa01 f303 	lsl.w	r3, r1, r3
3418e0ca:	401a      	ands	r2, r3
3418e0cc:	f44f 7180 	mov.w	r1, #256	@ 0x100
3418e0d0:	687b      	ldr	r3, [r7, #4]
3418e0d2:	fa01 f303 	lsl.w	r3, r1, r3
3418e0d6:	429a      	cmp	r2, r3
3418e0d8:	d102      	bne.n	3418e0e0 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3418e0da:	2302      	movs	r3, #2
3418e0dc:	61bb      	str	r3, [r7, #24]
3418e0de:	e00a      	b.n	3418e0f6 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
3418e0e0:	697b      	ldr	r3, [r7, #20]
3418e0e2:	681b      	ldr	r3, [r3, #0]
3418e0e4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418e0e8:	2b00      	cmp	r3, #0
3418e0ea:	d002      	beq.n	3418e0f2 <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3418e0ec:	2303      	movs	r3, #3
3418e0ee:	61bb      	str	r3, [r7, #24]
3418e0f0:	e001      	b.n	3418e0f6 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3418e0f2:	2301      	movs	r3, #1
3418e0f4:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3418e0f6:	683b      	ldr	r3, [r7, #0]
3418e0f8:	681b      	ldr	r3, [r3, #0]
3418e0fa:	69ba      	ldr	r2, [r7, #24]
3418e0fc:	429a      	cmp	r2, r3
3418e0fe:	d001      	beq.n	3418e104 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3418e100:	2301      	movs	r3, #1
3418e102:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3418e104:	69fb      	ldr	r3, [r7, #28]
}
3418e106:	4618      	mov	r0, r3
3418e108:	3724      	adds	r7, #36	@ 0x24
3418e10a:	46bd      	mov	sp, r7
3418e10c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e110:	4770      	bx	lr
3418e112:	bf00      	nop
3418e114:	56028080 	.word	0x56028080
3418e118:	56028084 	.word	0x56028084
3418e11c:	56028088 	.word	0x56028088
3418e120:	56028000 	.word	0x56028000

3418e124 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3418e124:	b580      	push	{r7, lr}
3418e126:	b084      	sub	sp, #16
3418e128:	af00      	add	r7, sp, #0
3418e12a:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3418e12c:	2301      	movs	r3, #1
3418e12e:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3418e130:	687b      	ldr	r3, [r7, #4]
3418e132:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e136:	d01b      	beq.n	3418e170 <RCC_PLL_Source_IsReady+0x4c>
3418e138:	687b      	ldr	r3, [r7, #4]
3418e13a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e13e:	d81f      	bhi.n	3418e180 <RCC_PLL_Source_IsReady+0x5c>
3418e140:	687b      	ldr	r3, [r7, #4]
3418e142:	2b00      	cmp	r3, #0
3418e144:	d004      	beq.n	3418e150 <RCC_PLL_Source_IsReady+0x2c>
3418e146:	687b      	ldr	r3, [r7, #4]
3418e148:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418e14c:	d008      	beq.n	3418e160 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3418e14e:	e017      	b.n	3418e180 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3418e150:	f7fe fc3a 	bl	3418c9c8 <LL_RCC_HSI_IsReady>
3418e154:	4603      	mov	r3, r0
3418e156:	2b00      	cmp	r3, #0
3418e158:	d114      	bne.n	3418e184 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3418e15a:	2300      	movs	r3, #0
3418e15c:	60fb      	str	r3, [r7, #12]
      break;
3418e15e:	e011      	b.n	3418e184 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3418e160:	f7fe fc9a 	bl	3418ca98 <LL_RCC_MSI_IsReady>
3418e164:	4603      	mov	r3, r0
3418e166:	2b00      	cmp	r3, #0
3418e168:	d10e      	bne.n	3418e188 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3418e16a:	2300      	movs	r3, #0
3418e16c:	60fb      	str	r3, [r7, #12]
      break;
3418e16e:	e00b      	b.n	3418e188 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3418e170:	f7fe fbfa 	bl	3418c968 <LL_RCC_HSE_IsReady>
3418e174:	4603      	mov	r3, r0
3418e176:	2b00      	cmp	r3, #0
3418e178:	d108      	bne.n	3418e18c <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3418e17a:	2300      	movs	r3, #0
3418e17c:	60fb      	str	r3, [r7, #12]
      break;
3418e17e:	e005      	b.n	3418e18c <RCC_PLL_Source_IsReady+0x68>
      break;
3418e180:	bf00      	nop
3418e182:	e004      	b.n	3418e18e <RCC_PLL_Source_IsReady+0x6a>
      break;
3418e184:	bf00      	nop
3418e186:	e002      	b.n	3418e18e <RCC_PLL_Source_IsReady+0x6a>
      break;
3418e188:	bf00      	nop
3418e18a:	e000      	b.n	3418e18e <RCC_PLL_Source_IsReady+0x6a>
      break;
3418e18c:	bf00      	nop
  }

  return ret;
3418e18e:	68fb      	ldr	r3, [r7, #12]
}
3418e190:	4618      	mov	r0, r3
3418e192:	3710      	adds	r7, #16
3418e194:	46bd      	mov	sp, r7
3418e196:	bd80      	pop	{r7, pc}

3418e198 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
3418e198:	b580      	push	{r7, lr}
3418e19a:	b084      	sub	sp, #16
3418e19c:	af00      	add	r7, sp, #0
3418e19e:	6078      	str	r0, [r7, #4]
3418e1a0:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
3418e1a2:	2301      	movs	r3, #1
3418e1a4:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
3418e1a6:	687b      	ldr	r3, [r7, #4]
3418e1a8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e1ac:	d03a      	beq.n	3418e224 <RCC_IC_CheckPLLSources+0x8c>
3418e1ae:	687b      	ldr	r3, [r7, #4]
3418e1b0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e1b4:	d843      	bhi.n	3418e23e <RCC_IC_CheckPLLSources+0xa6>
3418e1b6:	687b      	ldr	r3, [r7, #4]
3418e1b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e1bc:	d025      	beq.n	3418e20a <RCC_IC_CheckPLLSources+0x72>
3418e1be:	687b      	ldr	r3, [r7, #4]
3418e1c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e1c4:	d83b      	bhi.n	3418e23e <RCC_IC_CheckPLLSources+0xa6>
3418e1c6:	687b      	ldr	r3, [r7, #4]
3418e1c8:	2b00      	cmp	r3, #0
3418e1ca:	d004      	beq.n	3418e1d6 <RCC_IC_CheckPLLSources+0x3e>
3418e1cc:	687b      	ldr	r3, [r7, #4]
3418e1ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418e1d2:	d00d      	beq.n	3418e1f0 <RCC_IC_CheckPLLSources+0x58>
3418e1d4:	e033      	b.n	3418e23e <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418e1d6:	f7fe fd1f 	bl	3418cc18 <LL_RCC_PLL1_IsReady>
3418e1da:	4603      	mov	r3, r0
3418e1dc:	2b00      	cmp	r3, #0
3418e1de:	d131      	bne.n	3418e244 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418e1e0:	f7fe fd2e 	bl	3418cc40 <LL_RCC_PLL1_IsEnabledBypass>
3418e1e4:	4603      	mov	r3, r0
3418e1e6:	2b00      	cmp	r3, #0
3418e1e8:	d12c      	bne.n	3418e244 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3418e1ea:	2300      	movs	r3, #0
3418e1ec:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e1ee:	e029      	b.n	3418e244 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418e1f0:	f7fe fd48 	bl	3418cc84 <LL_RCC_PLL2_IsReady>
3418e1f4:	4603      	mov	r3, r0
3418e1f6:	2b00      	cmp	r3, #0
3418e1f8:	d126      	bne.n	3418e248 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418e1fa:	f7fe fd57 	bl	3418ccac <LL_RCC_PLL2_IsEnabledBypass>
3418e1fe:	4603      	mov	r3, r0
3418e200:	2b00      	cmp	r3, #0
3418e202:	d121      	bne.n	3418e248 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3418e204:	2300      	movs	r3, #0
3418e206:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e208:	e01e      	b.n	3418e248 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418e20a:	f7fe fd71 	bl	3418ccf0 <LL_RCC_PLL3_IsReady>
3418e20e:	4603      	mov	r3, r0
3418e210:	2b00      	cmp	r3, #0
3418e212:	d11b      	bne.n	3418e24c <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418e214:	f7fe fd80 	bl	3418cd18 <LL_RCC_PLL3_IsEnabledBypass>
3418e218:	4603      	mov	r3, r0
3418e21a:	2b00      	cmp	r3, #0
3418e21c:	d116      	bne.n	3418e24c <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3418e21e:	2300      	movs	r3, #0
3418e220:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e222:	e013      	b.n	3418e24c <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418e224:	f7fe fd9a 	bl	3418cd5c <LL_RCC_PLL4_IsReady>
3418e228:	4603      	mov	r3, r0
3418e22a:	2b00      	cmp	r3, #0
3418e22c:	d110      	bne.n	3418e250 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418e22e:	f7fe fda9 	bl	3418cd84 <LL_RCC_PLL4_IsEnabledBypass>
3418e232:	4603      	mov	r3, r0
3418e234:	2b00      	cmp	r3, #0
3418e236:	d10b      	bne.n	3418e250 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
3418e238:	2300      	movs	r3, #0
3418e23a:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e23c:	e008      	b.n	3418e250 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3418e23e:	2300      	movs	r3, #0
3418e240:	60fb      	str	r3, [r7, #12]
      break;
3418e242:	e006      	b.n	3418e252 <RCC_IC_CheckPLLSources+0xba>
      break;
3418e244:	bf00      	nop
3418e246:	e004      	b.n	3418e252 <RCC_IC_CheckPLLSources+0xba>
      break;
3418e248:	bf00      	nop
3418e24a:	e002      	b.n	3418e252 <RCC_IC_CheckPLLSources+0xba>
      break;
3418e24c:	bf00      	nop
3418e24e:	e000      	b.n	3418e252 <RCC_IC_CheckPLLSources+0xba>
      break;
3418e250:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3418e252:	683b      	ldr	r3, [r7, #0]
3418e254:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e258:	d03a      	beq.n	3418e2d0 <RCC_IC_CheckPLLSources+0x138>
3418e25a:	683b      	ldr	r3, [r7, #0]
3418e25c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3418e260:	d843      	bhi.n	3418e2ea <RCC_IC_CheckPLLSources+0x152>
3418e262:	683b      	ldr	r3, [r7, #0]
3418e264:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e268:	d025      	beq.n	3418e2b6 <RCC_IC_CheckPLLSources+0x11e>
3418e26a:	683b      	ldr	r3, [r7, #0]
3418e26c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3418e270:	d83b      	bhi.n	3418e2ea <RCC_IC_CheckPLLSources+0x152>
3418e272:	683b      	ldr	r3, [r7, #0]
3418e274:	2b00      	cmp	r3, #0
3418e276:	d004      	beq.n	3418e282 <RCC_IC_CheckPLLSources+0xea>
3418e278:	683b      	ldr	r3, [r7, #0]
3418e27a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3418e27e:	d00d      	beq.n	3418e29c <RCC_IC_CheckPLLSources+0x104>
3418e280:	e033      	b.n	3418e2ea <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3418e282:	f7fe fcc9 	bl	3418cc18 <LL_RCC_PLL1_IsReady>
3418e286:	4603      	mov	r3, r0
3418e288:	2b00      	cmp	r3, #0
3418e28a:	d131      	bne.n	3418e2f0 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3418e28c:	f7fe fcd8 	bl	3418cc40 <LL_RCC_PLL1_IsEnabledBypass>
3418e290:	4603      	mov	r3, r0
3418e292:	2b00      	cmp	r3, #0
3418e294:	d12c      	bne.n	3418e2f0 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3418e296:	2300      	movs	r3, #0
3418e298:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e29a:	e029      	b.n	3418e2f0 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3418e29c:	f7fe fcf2 	bl	3418cc84 <LL_RCC_PLL2_IsReady>
3418e2a0:	4603      	mov	r3, r0
3418e2a2:	2b00      	cmp	r3, #0
3418e2a4:	d126      	bne.n	3418e2f4 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3418e2a6:	f7fe fd01 	bl	3418ccac <LL_RCC_PLL2_IsEnabledBypass>
3418e2aa:	4603      	mov	r3, r0
3418e2ac:	2b00      	cmp	r3, #0
3418e2ae:	d121      	bne.n	3418e2f4 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
3418e2b0:	2300      	movs	r3, #0
3418e2b2:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e2b4:	e01e      	b.n	3418e2f4 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3418e2b6:	f7fe fd1b 	bl	3418ccf0 <LL_RCC_PLL3_IsReady>
3418e2ba:	4603      	mov	r3, r0
3418e2bc:	2b00      	cmp	r3, #0
3418e2be:	d11b      	bne.n	3418e2f8 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3418e2c0:	f7fe fd2a 	bl	3418cd18 <LL_RCC_PLL3_IsEnabledBypass>
3418e2c4:	4603      	mov	r3, r0
3418e2c6:	2b00      	cmp	r3, #0
3418e2c8:	d116      	bne.n	3418e2f8 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3418e2ca:	2300      	movs	r3, #0
3418e2cc:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e2ce:	e013      	b.n	3418e2f8 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3418e2d0:	f7fe fd44 	bl	3418cd5c <LL_RCC_PLL4_IsReady>
3418e2d4:	4603      	mov	r3, r0
3418e2d6:	2b00      	cmp	r3, #0
3418e2d8:	d110      	bne.n	3418e2fc <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3418e2da:	f7fe fd53 	bl	3418cd84 <LL_RCC_PLL4_IsEnabledBypass>
3418e2de:	4603      	mov	r3, r0
3418e2e0:	2b00      	cmp	r3, #0
3418e2e2:	d10b      	bne.n	3418e2fc <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
3418e2e4:	2300      	movs	r3, #0
3418e2e6:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3418e2e8:	e008      	b.n	3418e2fc <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3418e2ea:	2300      	movs	r3, #0
3418e2ec:	60fb      	str	r3, [r7, #12]
      break;
3418e2ee:	e006      	b.n	3418e2fe <RCC_IC_CheckPLLSources+0x166>
      break;
3418e2f0:	bf00      	nop
3418e2f2:	e004      	b.n	3418e2fe <RCC_IC_CheckPLLSources+0x166>
      break;
3418e2f4:	bf00      	nop
3418e2f6:	e002      	b.n	3418e2fe <RCC_IC_CheckPLLSources+0x166>
      break;
3418e2f8:	bf00      	nop
3418e2fa:	e000      	b.n	3418e2fe <RCC_IC_CheckPLLSources+0x166>
      break;
3418e2fc:	bf00      	nop
  }

  return ret;
3418e2fe:	68fb      	ldr	r3, [r7, #12]
}
3418e300:	4618      	mov	r0, r3
3418e302:	3710      	adds	r7, #16
3418e304:	46bd      	mov	sp, r7
3418e306:	bd80      	pop	{r7, pc}

3418e308 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
3418e308:	b480      	push	{r7}
3418e30a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418e30c:	4b05      	ldr	r3, [pc, #20]	@ (3418e324 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418e30e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418e310:	4a04      	ldr	r2, [pc, #16]	@ (3418e324 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3418e312:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3418e316:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418e318:	bf00      	nop
3418e31a:	46bd      	mov	sp, r7
3418e31c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e320:	4770      	bx	lr
3418e322:	bf00      	nop
3418e324:	56028000 	.word	0x56028000

3418e328 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
3418e328:	b480      	push	{r7}
3418e32a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3418e32c:	4b05      	ldr	r3, [pc, #20]	@ (3418e344 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418e32e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418e330:	4a04      	ldr	r2, [pc, #16]	@ (3418e344 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3418e332:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3418e336:	6553      	str	r3, [r2, #84]	@ 0x54
}
3418e338:	bf00      	nop
3418e33a:	46bd      	mov	sp, r7
3418e33c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e340:	4770      	bx	lr
3418e342:	bf00      	nop
3418e344:	56028000 	.word	0x56028000

3418e348 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
3418e348:	b480      	push	{r7}
3418e34a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3418e34c:	4b06      	ldr	r3, [pc, #24]	@ (3418e368 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
3418e34e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418e350:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418e354:	2b40      	cmp	r3, #64	@ 0x40
3418e356:	d101      	bne.n	3418e35c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
3418e358:	2301      	movs	r3, #1
3418e35a:	e000      	b.n	3418e35e <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
3418e35c:	2300      	movs	r3, #0
}
3418e35e:	4618      	mov	r0, r3
3418e360:	46bd      	mov	sp, r7
3418e362:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e366:	4770      	bx	lr
3418e368:	56028000 	.word	0x56028000

3418e36c <LL_RCC_HSE_IsReady>:
{
3418e36c:	b480      	push	{r7}
3418e36e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3418e370:	4b06      	ldr	r3, [pc, #24]	@ (3418e38c <LL_RCC_HSE_IsReady+0x20>)
3418e372:	685b      	ldr	r3, [r3, #4]
3418e374:	f003 0310 	and.w	r3, r3, #16
3418e378:	2b00      	cmp	r3, #0
3418e37a:	d001      	beq.n	3418e380 <LL_RCC_HSE_IsReady+0x14>
3418e37c:	2301      	movs	r3, #1
3418e37e:	e000      	b.n	3418e382 <LL_RCC_HSE_IsReady+0x16>
3418e380:	2300      	movs	r3, #0
}
3418e382:	4618      	mov	r0, r3
3418e384:	46bd      	mov	sp, r7
3418e386:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e38a:	4770      	bx	lr
3418e38c:	56028000 	.word	0x56028000

3418e390 <LL_RCC_HSI_IsReady>:
{
3418e390:	b480      	push	{r7}
3418e392:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3418e394:	4b06      	ldr	r3, [pc, #24]	@ (3418e3b0 <LL_RCC_HSI_IsReady+0x20>)
3418e396:	685b      	ldr	r3, [r3, #4]
3418e398:	f003 0308 	and.w	r3, r3, #8
3418e39c:	2b00      	cmp	r3, #0
3418e39e:	d001      	beq.n	3418e3a4 <LL_RCC_HSI_IsReady+0x14>
3418e3a0:	2301      	movs	r3, #1
3418e3a2:	e000      	b.n	3418e3a6 <LL_RCC_HSI_IsReady+0x16>
3418e3a4:	2300      	movs	r3, #0
}
3418e3a6:	4618      	mov	r0, r3
3418e3a8:	46bd      	mov	sp, r7
3418e3aa:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3ae:	4770      	bx	lr
3418e3b0:	56028000 	.word	0x56028000

3418e3b4 <LL_RCC_HSI_GetDivider>:
{
3418e3b4:	b480      	push	{r7}
3418e3b6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3418e3b8:	4b04      	ldr	r3, [pc, #16]	@ (3418e3cc <LL_RCC_HSI_GetDivider+0x18>)
3418e3ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3418e3bc:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3418e3c0:	4618      	mov	r0, r3
3418e3c2:	46bd      	mov	sp, r7
3418e3c4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3c8:	4770      	bx	lr
3418e3ca:	bf00      	nop
3418e3cc:	56028000 	.word	0x56028000

3418e3d0 <LL_RCC_MSI_IsReady>:
{
3418e3d0:	b480      	push	{r7}
3418e3d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3418e3d4:	4b06      	ldr	r3, [pc, #24]	@ (3418e3f0 <LL_RCC_MSI_IsReady+0x20>)
3418e3d6:	685b      	ldr	r3, [r3, #4]
3418e3d8:	f003 0304 	and.w	r3, r3, #4
3418e3dc:	2b00      	cmp	r3, #0
3418e3de:	d001      	beq.n	3418e3e4 <LL_RCC_MSI_IsReady+0x14>
3418e3e0:	2301      	movs	r3, #1
3418e3e2:	e000      	b.n	3418e3e6 <LL_RCC_MSI_IsReady+0x16>
3418e3e4:	2300      	movs	r3, #0
}
3418e3e6:	4618      	mov	r0, r3
3418e3e8:	46bd      	mov	sp, r7
3418e3ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e3ee:	4770      	bx	lr
3418e3f0:	56028000 	.word	0x56028000

3418e3f4 <LL_RCC_MSI_GetFrequency>:
{
3418e3f4:	b480      	push	{r7}
3418e3f6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3418e3f8:	4b04      	ldr	r3, [pc, #16]	@ (3418e40c <LL_RCC_MSI_GetFrequency+0x18>)
3418e3fa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3418e3fc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3418e400:	4618      	mov	r0, r3
3418e402:	46bd      	mov	sp, r7
3418e404:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e408:	4770      	bx	lr
3418e40a:	bf00      	nop
3418e40c:	56028000 	.word	0x56028000

3418e410 <LL_RCC_LSE_IsReady>:
{
3418e410:	b480      	push	{r7}
3418e412:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3418e414:	4b06      	ldr	r3, [pc, #24]	@ (3418e430 <LL_RCC_LSE_IsReady+0x20>)
3418e416:	685b      	ldr	r3, [r3, #4]
3418e418:	f003 0302 	and.w	r3, r3, #2
3418e41c:	2b00      	cmp	r3, #0
3418e41e:	d001      	beq.n	3418e424 <LL_RCC_LSE_IsReady+0x14>
3418e420:	2301      	movs	r3, #1
3418e422:	e000      	b.n	3418e426 <LL_RCC_LSE_IsReady+0x16>
3418e424:	2300      	movs	r3, #0
}
3418e426:	4618      	mov	r0, r3
3418e428:	46bd      	mov	sp, r7
3418e42a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e42e:	4770      	bx	lr
3418e430:	56028000 	.word	0x56028000

3418e434 <LL_RCC_LSI_IsReady>:
{
3418e434:	b480      	push	{r7}
3418e436:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3418e438:	4b04      	ldr	r3, [pc, #16]	@ (3418e44c <LL_RCC_LSI_IsReady+0x18>)
3418e43a:	685b      	ldr	r3, [r3, #4]
3418e43c:	f003 0301 	and.w	r3, r3, #1
}
3418e440:	4618      	mov	r0, r3
3418e442:	46bd      	mov	sp, r7
3418e444:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e448:	4770      	bx	lr
3418e44a:	bf00      	nop
3418e44c:	56028000 	.word	0x56028000

3418e450 <LL_RCC_GetAHBPrescaler>:
{
3418e450:	b480      	push	{r7}
3418e452:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3418e454:	4b04      	ldr	r3, [pc, #16]	@ (3418e468 <LL_RCC_GetAHBPrescaler+0x18>)
3418e456:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e458:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3418e45c:	4618      	mov	r0, r3
3418e45e:	46bd      	mov	sp, r7
3418e460:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e464:	4770      	bx	lr
3418e466:	bf00      	nop
3418e468:	56028000 	.word	0x56028000

3418e46c <LL_RCC_GetAPB1Prescaler>:
{
3418e46c:	b480      	push	{r7}
3418e46e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3418e470:	4b04      	ldr	r3, [pc, #16]	@ (3418e484 <LL_RCC_GetAPB1Prescaler+0x18>)
3418e472:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e474:	f003 0307 	and.w	r3, r3, #7
}
3418e478:	4618      	mov	r0, r3
3418e47a:	46bd      	mov	sp, r7
3418e47c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e480:	4770      	bx	lr
3418e482:	bf00      	nop
3418e484:	56028000 	.word	0x56028000

3418e488 <LL_RCC_GetAPB2Prescaler>:
{
3418e488:	b480      	push	{r7}
3418e48a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3418e48c:	4b04      	ldr	r3, [pc, #16]	@ (3418e4a0 <LL_RCC_GetAPB2Prescaler+0x18>)
3418e48e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e490:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3418e494:	4618      	mov	r0, r3
3418e496:	46bd      	mov	sp, r7
3418e498:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e49c:	4770      	bx	lr
3418e49e:	bf00      	nop
3418e4a0:	56028000 	.word	0x56028000

3418e4a4 <LL_RCC_GetAPB4Prescaler>:
{
3418e4a4:	b480      	push	{r7}
3418e4a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3418e4a8:	4b04      	ldr	r3, [pc, #16]	@ (3418e4bc <LL_RCC_GetAPB4Prescaler+0x18>)
3418e4aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e4ac:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
3418e4b0:	4618      	mov	r0, r3
3418e4b2:	46bd      	mov	sp, r7
3418e4b4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e4b8:	4770      	bx	lr
3418e4ba:	bf00      	nop
3418e4bc:	56028000 	.word	0x56028000

3418e4c0 <LL_RCC_GetAPB5Prescaler>:
{
3418e4c0:	b480      	push	{r7}
3418e4c2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3418e4c4:	4b04      	ldr	r3, [pc, #16]	@ (3418e4d8 <LL_RCC_GetAPB5Prescaler+0x18>)
3418e4c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418e4c8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3418e4cc:	4618      	mov	r0, r3
3418e4ce:	46bd      	mov	sp, r7
3418e4d0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e4d4:	4770      	bx	lr
3418e4d6:	bf00      	nop
3418e4d8:	56028000 	.word	0x56028000

3418e4dc <LL_RCC_SetClockSource>:
{
3418e4dc:	b480      	push	{r7}
3418e4de:	b085      	sub	sp, #20
3418e4e0:	af00      	add	r7, sp, #0
3418e4e2:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3418e4e4:	687b      	ldr	r3, [r7, #4]
3418e4e6:	b2da      	uxtb	r2, r3
3418e4e8:	4b10      	ldr	r3, [pc, #64]	@ (3418e52c <LL_RCC_SetClockSource+0x50>)
3418e4ea:	4413      	add	r3, r2
3418e4ec:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3418e4ee:	68fb      	ldr	r3, [r7, #12]
3418e4f0:	681a      	ldr	r2, [r3, #0]
3418e4f2:	687b      	ldr	r3, [r7, #4]
3418e4f4:	0e19      	lsrs	r1, r3, #24
3418e4f6:	687b      	ldr	r3, [r7, #4]
3418e4f8:	0a1b      	lsrs	r3, r3, #8
3418e4fa:	f003 031f 	and.w	r3, r3, #31
3418e4fe:	fa01 f303 	lsl.w	r3, r1, r3
3418e502:	43db      	mvns	r3, r3
3418e504:	401a      	ands	r2, r3
3418e506:	687b      	ldr	r3, [r7, #4]
3418e508:	0c1b      	lsrs	r3, r3, #16
3418e50a:	b2d9      	uxtb	r1, r3
3418e50c:	687b      	ldr	r3, [r7, #4]
3418e50e:	0a1b      	lsrs	r3, r3, #8
3418e510:	f003 031f 	and.w	r3, r3, #31
3418e514:	fa01 f303 	lsl.w	r3, r1, r3
3418e518:	431a      	orrs	r2, r3
3418e51a:	68fb      	ldr	r3, [r7, #12]
3418e51c:	601a      	str	r2, [r3, #0]
}
3418e51e:	bf00      	nop
3418e520:	3714      	adds	r7, #20
3418e522:	46bd      	mov	sp, r7
3418e524:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e528:	4770      	bx	lr
3418e52a:	bf00      	nop
3418e52c:	56028144 	.word	0x56028144

3418e530 <LL_RCC_GetADCPrescaler>:
{
3418e530:	b480      	push	{r7}
3418e532:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3418e534:	4b04      	ldr	r3, [pc, #16]	@ (3418e548 <LL_RCC_GetADCPrescaler+0x18>)
3418e536:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e53a:	0a1b      	lsrs	r3, r3, #8
3418e53c:	b2db      	uxtb	r3, r3
}
3418e53e:	4618      	mov	r0, r3
3418e540:	46bd      	mov	sp, r7
3418e542:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e546:	4770      	bx	lr
3418e548:	56028000 	.word	0x56028000

3418e54c <LL_RCC_SetADFClockSource>:
{
3418e54c:	b480      	push	{r7}
3418e54e:	b083      	sub	sp, #12
3418e550:	af00      	add	r7, sp, #0
3418e552:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3418e554:	4b07      	ldr	r3, [pc, #28]	@ (3418e574 <LL_RCC_SetADFClockSource+0x28>)
3418e556:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e55a:	f023 0207 	bic.w	r2, r3, #7
3418e55e:	4905      	ldr	r1, [pc, #20]	@ (3418e574 <LL_RCC_SetADFClockSource+0x28>)
3418e560:	687b      	ldr	r3, [r7, #4]
3418e562:	4313      	orrs	r3, r2
3418e564:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3418e568:	bf00      	nop
3418e56a:	370c      	adds	r7, #12
3418e56c:	46bd      	mov	sp, r7
3418e56e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e572:	4770      	bx	lr
3418e574:	56028000 	.word	0x56028000

3418e578 <LL_RCC_SetCLKPClockSource>:
{
3418e578:	b480      	push	{r7}
3418e57a:	b083      	sub	sp, #12
3418e57c:	af00      	add	r7, sp, #0
3418e57e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3418e580:	4b07      	ldr	r3, [pc, #28]	@ (3418e5a0 <LL_RCC_SetCLKPClockSource+0x28>)
3418e582:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418e586:	f023 0207 	bic.w	r2, r3, #7
3418e58a:	4905      	ldr	r1, [pc, #20]	@ (3418e5a0 <LL_RCC_SetCLKPClockSource+0x28>)
3418e58c:	687b      	ldr	r3, [r7, #4]
3418e58e:	4313      	orrs	r3, r2
3418e590:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418e594:	bf00      	nop
3418e596:	370c      	adds	r7, #12
3418e598:	46bd      	mov	sp, r7
3418e59a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e59e:	4770      	bx	lr
3418e5a0:	56028000 	.word	0x56028000

3418e5a4 <LL_RCC_SetDCMIPPClockSource>:
{
3418e5a4:	b480      	push	{r7}
3418e5a6:	b083      	sub	sp, #12
3418e5a8:	af00      	add	r7, sp, #0
3418e5aa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3418e5ac:	4b07      	ldr	r3, [pc, #28]	@ (3418e5cc <LL_RCC_SetDCMIPPClockSource+0x28>)
3418e5ae:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e5b2:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
3418e5b6:	4905      	ldr	r1, [pc, #20]	@ (3418e5cc <LL_RCC_SetDCMIPPClockSource+0x28>)
3418e5b8:	687b      	ldr	r3, [r7, #4]
3418e5ba:	4313      	orrs	r3, r2
3418e5bc:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3418e5c0:	bf00      	nop
3418e5c2:	370c      	adds	r7, #12
3418e5c4:	46bd      	mov	sp, r7
3418e5c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e5ca:	4770      	bx	lr
3418e5cc:	56028000 	.word	0x56028000

3418e5d0 <LL_RCC_SetETHClockSource>:
{
3418e5d0:	b480      	push	{r7}
3418e5d2:	b083      	sub	sp, #12
3418e5d4:	af00      	add	r7, sp, #0
3418e5d6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3418e5d8:	4b07      	ldr	r3, [pc, #28]	@ (3418e5f8 <LL_RCC_SetETHClockSource+0x28>)
3418e5da:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e5de:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3418e5e2:	4905      	ldr	r1, [pc, #20]	@ (3418e5f8 <LL_RCC_SetETHClockSource+0x28>)
3418e5e4:	687b      	ldr	r3, [r7, #4]
3418e5e6:	4313      	orrs	r3, r2
3418e5e8:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418e5ec:	bf00      	nop
3418e5ee:	370c      	adds	r7, #12
3418e5f0:	46bd      	mov	sp, r7
3418e5f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e5f6:	4770      	bx	lr
3418e5f8:	56028000 	.word	0x56028000

3418e5fc <LL_RCC_SetETHPHYInterface>:
{
3418e5fc:	b480      	push	{r7}
3418e5fe:	b083      	sub	sp, #12
3418e600:	af00      	add	r7, sp, #0
3418e602:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3418e604:	4b07      	ldr	r3, [pc, #28]	@ (3418e624 <LL_RCC_SetETHPHYInterface+0x28>)
3418e606:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e60a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418e60e:	4905      	ldr	r1, [pc, #20]	@ (3418e624 <LL_RCC_SetETHPHYInterface+0x28>)
3418e610:	687b      	ldr	r3, [r7, #4]
3418e612:	4313      	orrs	r3, r2
3418e614:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418e618:	bf00      	nop
3418e61a:	370c      	adds	r7, #12
3418e61c:	46bd      	mov	sp, r7
3418e61e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e622:	4770      	bx	lr
3418e624:	56028000 	.word	0x56028000

3418e628 <LL_RCC_GetETH1PTPDivider>:
{
3418e628:	b480      	push	{r7}
3418e62a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3418e62c:	4b04      	ldr	r3, [pc, #16]	@ (3418e640 <LL_RCC_GetETH1PTPDivider+0x18>)
3418e62e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e632:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
3418e636:	4618      	mov	r0, r3
3418e638:	46bd      	mov	sp, r7
3418e63a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e63e:	4770      	bx	lr
3418e640:	56028000 	.word	0x56028000

3418e644 <LL_RCC_SetETHREFRXClockSource>:
{
3418e644:	b480      	push	{r7}
3418e646:	b083      	sub	sp, #12
3418e648:	af00      	add	r7, sp, #0
3418e64a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3418e64c:	4b07      	ldr	r3, [pc, #28]	@ (3418e66c <LL_RCC_SetETHREFRXClockSource+0x28>)
3418e64e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e652:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
3418e656:	4905      	ldr	r1, [pc, #20]	@ (3418e66c <LL_RCC_SetETHREFRXClockSource+0x28>)
3418e658:	687b      	ldr	r3, [r7, #4]
3418e65a:	4313      	orrs	r3, r2
3418e65c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418e660:	bf00      	nop
3418e662:	370c      	adds	r7, #12
3418e664:	46bd      	mov	sp, r7
3418e666:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e66a:	4770      	bx	lr
3418e66c:	56028000 	.word	0x56028000

3418e670 <LL_RCC_SetETHREFTXClockSource>:
{
3418e670:	b480      	push	{r7}
3418e672:	b083      	sub	sp, #12
3418e674:	af00      	add	r7, sp, #0
3418e676:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3418e678:	4b07      	ldr	r3, [pc, #28]	@ (3418e698 <LL_RCC_SetETHREFTXClockSource+0x28>)
3418e67a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e67e:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3418e682:	4905      	ldr	r1, [pc, #20]	@ (3418e698 <LL_RCC_SetETHREFTXClockSource+0x28>)
3418e684:	687b      	ldr	r3, [r7, #4]
3418e686:	4313      	orrs	r3, r2
3418e688:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3418e68c:	bf00      	nop
3418e68e:	370c      	adds	r7, #12
3418e690:	46bd      	mov	sp, r7
3418e692:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e696:	4770      	bx	lr
3418e698:	56028000 	.word	0x56028000

3418e69c <LL_RCC_SetFDCANClockSource>:
{
3418e69c:	b480      	push	{r7}
3418e69e:	b083      	sub	sp, #12
3418e6a0:	af00      	add	r7, sp, #0
3418e6a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3418e6a4:	4b07      	ldr	r3, [pc, #28]	@ (3418e6c4 <LL_RCC_SetFDCANClockSource+0x28>)
3418e6a6:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418e6aa:	f023 0203 	bic.w	r2, r3, #3
3418e6ae:	4905      	ldr	r1, [pc, #20]	@ (3418e6c4 <LL_RCC_SetFDCANClockSource+0x28>)
3418e6b0:	687b      	ldr	r3, [r7, #4]
3418e6b2:	4313      	orrs	r3, r2
3418e6b4:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3418e6b8:	bf00      	nop
3418e6ba:	370c      	adds	r7, #12
3418e6bc:	46bd      	mov	sp, r7
3418e6be:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e6c2:	4770      	bx	lr
3418e6c4:	56028000 	.word	0x56028000

3418e6c8 <LL_RCC_SetFMCClockSource>:
{
3418e6c8:	b480      	push	{r7}
3418e6ca:	b083      	sub	sp, #12
3418e6cc:	af00      	add	r7, sp, #0
3418e6ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3418e6d0:	4b07      	ldr	r3, [pc, #28]	@ (3418e6f0 <LL_RCC_SetFMCClockSource+0x28>)
3418e6d2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418e6d6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3418e6da:	4905      	ldr	r1, [pc, #20]	@ (3418e6f0 <LL_RCC_SetFMCClockSource+0x28>)
3418e6dc:	687b      	ldr	r3, [r7, #4]
3418e6de:	4313      	orrs	r3, r2
3418e6e0:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3418e6e4:	bf00      	nop
3418e6e6:	370c      	adds	r7, #12
3418e6e8:	46bd      	mov	sp, r7
3418e6ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e6ee:	4770      	bx	lr
3418e6f0:	56028000 	.word	0x56028000

3418e6f4 <LL_RCC_SetI2CClockSource>:
{
3418e6f4:	b580      	push	{r7, lr}
3418e6f6:	b082      	sub	sp, #8
3418e6f8:	af00      	add	r7, sp, #0
3418e6fa:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e6fc:	6878      	ldr	r0, [r7, #4]
3418e6fe:	f7ff feed 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e702:	bf00      	nop
3418e704:	3708      	adds	r7, #8
3418e706:	46bd      	mov	sp, r7
3418e708:	bd80      	pop	{r7, pc}

3418e70a <LL_RCC_SetI3CClockSource>:
{
3418e70a:	b580      	push	{r7, lr}
3418e70c:	b082      	sub	sp, #8
3418e70e:	af00      	add	r7, sp, #0
3418e710:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e712:	6878      	ldr	r0, [r7, #4]
3418e714:	f7ff fee2 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e718:	bf00      	nop
3418e71a:	3708      	adds	r7, #8
3418e71c:	46bd      	mov	sp, r7
3418e71e:	bd80      	pop	{r7, pc}

3418e720 <LL_RCC_SetLPTIMClockSource>:
{
3418e720:	b580      	push	{r7, lr}
3418e722:	b082      	sub	sp, #8
3418e724:	af00      	add	r7, sp, #0
3418e726:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e728:	6878      	ldr	r0, [r7, #4]
3418e72a:	f7ff fed7 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e72e:	bf00      	nop
3418e730:	3708      	adds	r7, #8
3418e732:	46bd      	mov	sp, r7
3418e734:	bd80      	pop	{r7, pc}
	...

3418e738 <LL_RCC_SetLPUARTClockSource>:
{
3418e738:	b480      	push	{r7}
3418e73a:	b083      	sub	sp, #12
3418e73c:	af00      	add	r7, sp, #0
3418e73e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3418e740:	4b07      	ldr	r3, [pc, #28]	@ (3418e760 <LL_RCC_SetLPUARTClockSource+0x28>)
3418e742:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3418e746:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3418e74a:	4905      	ldr	r1, [pc, #20]	@ (3418e760 <LL_RCC_SetLPUARTClockSource+0x28>)
3418e74c:	687b      	ldr	r3, [r7, #4]
3418e74e:	4313      	orrs	r3, r2
3418e750:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
3418e754:	bf00      	nop
3418e756:	370c      	adds	r7, #12
3418e758:	46bd      	mov	sp, r7
3418e75a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e75e:	4770      	bx	lr
3418e760:	56028000 	.word	0x56028000

3418e764 <LL_RCC_SetLTDCClockSource>:
{
3418e764:	b480      	push	{r7}
3418e766:	b083      	sub	sp, #12
3418e768:	af00      	add	r7, sp, #0
3418e76a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3418e76c:	4b07      	ldr	r3, [pc, #28]	@ (3418e78c <LL_RCC_SetLTDCClockSource+0x28>)
3418e76e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3418e772:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418e776:	4905      	ldr	r1, [pc, #20]	@ (3418e78c <LL_RCC_SetLTDCClockSource+0x28>)
3418e778:	687b      	ldr	r3, [r7, #4]
3418e77a:	4313      	orrs	r3, r2
3418e77c:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
3418e780:	bf00      	nop
3418e782:	370c      	adds	r7, #12
3418e784:	46bd      	mov	sp, r7
3418e786:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e78a:	4770      	bx	lr
3418e78c:	56028000 	.word	0x56028000

3418e790 <LL_RCC_SetMDFClockSource>:
{
3418e790:	b480      	push	{r7}
3418e792:	b083      	sub	sp, #12
3418e794:	af00      	add	r7, sp, #0
3418e796:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3418e798:	4b07      	ldr	r3, [pc, #28]	@ (3418e7b8 <LL_RCC_SetMDFClockSource+0x28>)
3418e79a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3418e79e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3418e7a2:	4905      	ldr	r1, [pc, #20]	@ (3418e7b8 <LL_RCC_SetMDFClockSource+0x28>)
3418e7a4:	687b      	ldr	r3, [r7, #4]
3418e7a6:	4313      	orrs	r3, r2
3418e7a8:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
3418e7ac:	bf00      	nop
3418e7ae:	370c      	adds	r7, #12
3418e7b0:	46bd      	mov	sp, r7
3418e7b2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e7b6:	4770      	bx	lr
3418e7b8:	56028000 	.word	0x56028000

3418e7bc <LL_RCC_SetOTGPHYClockSource>:
{
3418e7bc:	b580      	push	{r7, lr}
3418e7be:	b082      	sub	sp, #8
3418e7c0:	af00      	add	r7, sp, #0
3418e7c2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e7c4:	6878      	ldr	r0, [r7, #4]
3418e7c6:	f7ff fe89 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e7ca:	bf00      	nop
3418e7cc:	3708      	adds	r7, #8
3418e7ce:	46bd      	mov	sp, r7
3418e7d0:	bd80      	pop	{r7, pc}

3418e7d2 <LL_RCC_SetOTGPHYCKREFClockSource>:
{
3418e7d2:	b580      	push	{r7, lr}
3418e7d4:	b082      	sub	sp, #8
3418e7d6:	af00      	add	r7, sp, #0
3418e7d8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e7da:	6878      	ldr	r0, [r7, #4]
3418e7dc:	f7ff fe7e 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e7e0:	bf00      	nop
3418e7e2:	3708      	adds	r7, #8
3418e7e4:	46bd      	mov	sp, r7
3418e7e6:	bd80      	pop	{r7, pc}

3418e7e8 <LL_RCC_SetPSSIClockSource>:
{
3418e7e8:	b480      	push	{r7}
3418e7ea:	b083      	sub	sp, #12
3418e7ec:	af00      	add	r7, sp, #0
3418e7ee:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3418e7f0:	4b07      	ldr	r3, [pc, #28]	@ (3418e810 <LL_RCC_SetPSSIClockSource+0x28>)
3418e7f2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418e7f6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3418e7fa:	4905      	ldr	r1, [pc, #20]	@ (3418e810 <LL_RCC_SetPSSIClockSource+0x28>)
3418e7fc:	687b      	ldr	r3, [r7, #4]
3418e7fe:	4313      	orrs	r3, r2
3418e800:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418e804:	bf00      	nop
3418e806:	370c      	adds	r7, #12
3418e808:	46bd      	mov	sp, r7
3418e80a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e80e:	4770      	bx	lr
3418e810:	56028000 	.word	0x56028000

3418e814 <LL_RCC_SetSAIClockSource>:
{
3418e814:	b580      	push	{r7, lr}
3418e816:	b082      	sub	sp, #8
3418e818:	af00      	add	r7, sp, #0
3418e81a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e81c:	6878      	ldr	r0, [r7, #4]
3418e81e:	f7ff fe5d 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e822:	bf00      	nop
3418e824:	3708      	adds	r7, #8
3418e826:	46bd      	mov	sp, r7
3418e828:	bd80      	pop	{r7, pc}

3418e82a <LL_RCC_SetSDMMCClockSource>:
{
3418e82a:	b580      	push	{r7, lr}
3418e82c:	b082      	sub	sp, #8
3418e82e:	af00      	add	r7, sp, #0
3418e830:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e832:	6878      	ldr	r0, [r7, #4]
3418e834:	f7ff fe52 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e838:	bf00      	nop
3418e83a:	3708      	adds	r7, #8
3418e83c:	46bd      	mov	sp, r7
3418e83e:	bd80      	pop	{r7, pc}

3418e840 <LL_RCC_SetSPDIFRXClockSource>:
{
3418e840:	b480      	push	{r7}
3418e842:	b083      	sub	sp, #12
3418e844:	af00      	add	r7, sp, #0
3418e846:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3418e848:	4b07      	ldr	r3, [pc, #28]	@ (3418e868 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3418e84a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3418e84e:	f023 0207 	bic.w	r2, r3, #7
3418e852:	4905      	ldr	r1, [pc, #20]	@ (3418e868 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3418e854:	687b      	ldr	r3, [r7, #4]
3418e856:	4313      	orrs	r3, r2
3418e858:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
3418e85c:	bf00      	nop
3418e85e:	370c      	adds	r7, #12
3418e860:	46bd      	mov	sp, r7
3418e862:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e866:	4770      	bx	lr
3418e868:	56028000 	.word	0x56028000

3418e86c <LL_RCC_SetSPIClockSource>:
{
3418e86c:	b580      	push	{r7, lr}
3418e86e:	b082      	sub	sp, #8
3418e870:	af00      	add	r7, sp, #0
3418e872:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e874:	6878      	ldr	r0, [r7, #4]
3418e876:	f7ff fe31 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e87a:	bf00      	nop
3418e87c:	3708      	adds	r7, #8
3418e87e:	46bd      	mov	sp, r7
3418e880:	bd80      	pop	{r7, pc}

3418e882 <LL_RCC_SetUSARTClockSource>:
{
3418e882:	b580      	push	{r7, lr}
3418e884:	b082      	sub	sp, #8
3418e886:	af00      	add	r7, sp, #0
3418e888:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e88a:	6878      	ldr	r0, [r7, #4]
3418e88c:	f7ff fe26 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e890:	bf00      	nop
3418e892:	3708      	adds	r7, #8
3418e894:	46bd      	mov	sp, r7
3418e896:	bd80      	pop	{r7, pc}

3418e898 <LL_RCC_SetXSPIClockSource>:
{
3418e898:	b580      	push	{r7, lr}
3418e89a:	b082      	sub	sp, #8
3418e89c:	af00      	add	r7, sp, #0
3418e89e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3418e8a0:	6878      	ldr	r0, [r7, #4]
3418e8a2:	f7ff fe1b 	bl	3418e4dc <LL_RCC_SetClockSource>
}
3418e8a6:	bf00      	nop
3418e8a8:	3708      	adds	r7, #8
3418e8aa:	46bd      	mov	sp, r7
3418e8ac:	bd80      	pop	{r7, pc}
	...

3418e8b0 <LL_RCC_GetClockSource>:
{
3418e8b0:	b480      	push	{r7}
3418e8b2:	b085      	sub	sp, #20
3418e8b4:	af00      	add	r7, sp, #0
3418e8b6:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3418e8b8:	687b      	ldr	r3, [r7, #4]
3418e8ba:	b2da      	uxtb	r2, r3
3418e8bc:	4b0e      	ldr	r3, [pc, #56]	@ (3418e8f8 <LL_RCC_GetClockSource+0x48>)
3418e8be:	4413      	add	r3, r2
3418e8c0:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3418e8c2:	68fb      	ldr	r3, [r7, #12]
3418e8c4:	681a      	ldr	r2, [r3, #0]
3418e8c6:	687b      	ldr	r3, [r7, #4]
3418e8c8:	0e19      	lsrs	r1, r3, #24
3418e8ca:	687b      	ldr	r3, [r7, #4]
3418e8cc:	0a1b      	lsrs	r3, r3, #8
3418e8ce:	f003 031f 	and.w	r3, r3, #31
3418e8d2:	fa01 f303 	lsl.w	r3, r1, r3
3418e8d6:	401a      	ands	r2, r3
3418e8d8:	687b      	ldr	r3, [r7, #4]
3418e8da:	0a1b      	lsrs	r3, r3, #8
3418e8dc:	f003 031f 	and.w	r3, r3, #31
3418e8e0:	fa22 f303 	lsr.w	r3, r2, r3
3418e8e4:	041a      	lsls	r2, r3, #16
3418e8e6:	687b      	ldr	r3, [r7, #4]
3418e8e8:	4313      	orrs	r3, r2
}
3418e8ea:	4618      	mov	r0, r3
3418e8ec:	3714      	adds	r7, #20
3418e8ee:	46bd      	mov	sp, r7
3418e8f0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e8f4:	4770      	bx	lr
3418e8f6:	bf00      	nop
3418e8f8:	56028144 	.word	0x56028144

3418e8fc <LL_RCC_GetADCClockSource>:
{
3418e8fc:	b480      	push	{r7}
3418e8fe:	b083      	sub	sp, #12
3418e900:	af00      	add	r7, sp, #0
3418e902:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3418e904:	4b05      	ldr	r3, [pc, #20]	@ (3418e91c <LL_RCC_GetADCClockSource+0x20>)
3418e906:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e90a:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3418e90e:	4618      	mov	r0, r3
3418e910:	370c      	adds	r7, #12
3418e912:	46bd      	mov	sp, r7
3418e914:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e918:	4770      	bx	lr
3418e91a:	bf00      	nop
3418e91c:	56028000 	.word	0x56028000

3418e920 <LL_RCC_GetADFClockSource>:
{
3418e920:	b480      	push	{r7}
3418e922:	b083      	sub	sp, #12
3418e924:	af00      	add	r7, sp, #0
3418e926:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3418e928:	4b05      	ldr	r3, [pc, #20]	@ (3418e940 <LL_RCC_GetADFClockSource+0x20>)
3418e92a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e92e:	f003 0307 	and.w	r3, r3, #7
}
3418e932:	4618      	mov	r0, r3
3418e934:	370c      	adds	r7, #12
3418e936:	46bd      	mov	sp, r7
3418e938:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e93c:	4770      	bx	lr
3418e93e:	bf00      	nop
3418e940:	56028000 	.word	0x56028000

3418e944 <LL_RCC_GetCLKPClockSource>:
{
3418e944:	b480      	push	{r7}
3418e946:	b083      	sub	sp, #12
3418e948:	af00      	add	r7, sp, #0
3418e94a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3418e94c:	4b05      	ldr	r3, [pc, #20]	@ (3418e964 <LL_RCC_GetCLKPClockSource+0x20>)
3418e94e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418e952:	f003 0307 	and.w	r3, r3, #7
}
3418e956:	4618      	mov	r0, r3
3418e958:	370c      	adds	r7, #12
3418e95a:	46bd      	mov	sp, r7
3418e95c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e960:	4770      	bx	lr
3418e962:	bf00      	nop
3418e964:	56028000 	.word	0x56028000

3418e968 <LL_RCC_GetDCMIPPClockSource>:
{
3418e968:	b480      	push	{r7}
3418e96a:	b083      	sub	sp, #12
3418e96c:	af00      	add	r7, sp, #0
3418e96e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3418e970:	4b05      	ldr	r3, [pc, #20]	@ (3418e988 <LL_RCC_GetDCMIPPClockSource+0x20>)
3418e972:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3418e976:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3418e97a:	4618      	mov	r0, r3
3418e97c:	370c      	adds	r7, #12
3418e97e:	46bd      	mov	sp, r7
3418e980:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e984:	4770      	bx	lr
3418e986:	bf00      	nop
3418e988:	56028000 	.word	0x56028000

3418e98c <LL_RCC_GetETHClockSource>:
{
3418e98c:	b480      	push	{r7}
3418e98e:	b083      	sub	sp, #12
3418e990:	af00      	add	r7, sp, #0
3418e992:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3418e994:	4b05      	ldr	r3, [pc, #20]	@ (3418e9ac <LL_RCC_GetETHClockSource+0x20>)
3418e996:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e99a:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
3418e99e:	4618      	mov	r0, r3
3418e9a0:	370c      	adds	r7, #12
3418e9a2:	46bd      	mov	sp, r7
3418e9a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e9a8:	4770      	bx	lr
3418e9aa:	bf00      	nop
3418e9ac:	56028000 	.word	0x56028000

3418e9b0 <LL_RCC_GetETHPTPClockSource>:
{
3418e9b0:	b480      	push	{r7}
3418e9b2:	b083      	sub	sp, #12
3418e9b4:	af00      	add	r7, sp, #0
3418e9b6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3418e9b8:	4b05      	ldr	r3, [pc, #20]	@ (3418e9d0 <LL_RCC_GetETHPTPClockSource+0x20>)
3418e9ba:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3418e9be:	f003 0303 	and.w	r3, r3, #3
}
3418e9c2:	4618      	mov	r0, r3
3418e9c4:	370c      	adds	r7, #12
3418e9c6:	46bd      	mov	sp, r7
3418e9c8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e9cc:	4770      	bx	lr
3418e9ce:	bf00      	nop
3418e9d0:	56028000 	.word	0x56028000

3418e9d4 <LL_RCC_GetFDCANClockSource>:
{
3418e9d4:	b480      	push	{r7}
3418e9d6:	b083      	sub	sp, #12
3418e9d8:	af00      	add	r7, sp, #0
3418e9da:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3418e9dc:	4b05      	ldr	r3, [pc, #20]	@ (3418e9f4 <LL_RCC_GetFDCANClockSource+0x20>)
3418e9de:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418e9e2:	f003 0303 	and.w	r3, r3, #3
}
3418e9e6:	4618      	mov	r0, r3
3418e9e8:	370c      	adds	r7, #12
3418e9ea:	46bd      	mov	sp, r7
3418e9ec:	f85d 7b04 	ldr.w	r7, [sp], #4
3418e9f0:	4770      	bx	lr
3418e9f2:	bf00      	nop
3418e9f4:	56028000 	.word	0x56028000

3418e9f8 <LL_RCC_GetFMCClockSource>:
{
3418e9f8:	b480      	push	{r7}
3418e9fa:	b083      	sub	sp, #12
3418e9fc:	af00      	add	r7, sp, #0
3418e9fe:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3418ea00:	4b05      	ldr	r3, [pc, #20]	@ (3418ea18 <LL_RCC_GetFMCClockSource+0x20>)
3418ea02:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3418ea06:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3418ea0a:	4618      	mov	r0, r3
3418ea0c:	370c      	adds	r7, #12
3418ea0e:	46bd      	mov	sp, r7
3418ea10:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ea14:	4770      	bx	lr
3418ea16:	bf00      	nop
3418ea18:	56028000 	.word	0x56028000

3418ea1c <LL_RCC_GetI2CClockSource>:
{
3418ea1c:	b580      	push	{r7, lr}
3418ea1e:	b082      	sub	sp, #8
3418ea20:	af00      	add	r7, sp, #0
3418ea22:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418ea24:	6878      	ldr	r0, [r7, #4]
3418ea26:	f7ff ff43 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418ea2a:	4603      	mov	r3, r0
}
3418ea2c:	4618      	mov	r0, r3
3418ea2e:	3708      	adds	r7, #8
3418ea30:	46bd      	mov	sp, r7
3418ea32:	bd80      	pop	{r7, pc}

3418ea34 <LL_RCC_GetI3CClockSource>:
{
3418ea34:	b580      	push	{r7, lr}
3418ea36:	b082      	sub	sp, #8
3418ea38:	af00      	add	r7, sp, #0
3418ea3a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418ea3c:	6878      	ldr	r0, [r7, #4]
3418ea3e:	f7ff ff37 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418ea42:	4603      	mov	r3, r0
}
3418ea44:	4618      	mov	r0, r3
3418ea46:	3708      	adds	r7, #8
3418ea48:	46bd      	mov	sp, r7
3418ea4a:	bd80      	pop	{r7, pc}

3418ea4c <LL_RCC_GetLPTIMClockSource>:
{
3418ea4c:	b580      	push	{r7, lr}
3418ea4e:	b082      	sub	sp, #8
3418ea50:	af00      	add	r7, sp, #0
3418ea52:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418ea54:	6878      	ldr	r0, [r7, #4]
3418ea56:	f7ff ff2b 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418ea5a:	4603      	mov	r3, r0
}
3418ea5c:	4618      	mov	r0, r3
3418ea5e:	3708      	adds	r7, #8
3418ea60:	46bd      	mov	sp, r7
3418ea62:	bd80      	pop	{r7, pc}

3418ea64 <LL_RCC_GetLPUARTClockSource>:
{
3418ea64:	b480      	push	{r7}
3418ea66:	b083      	sub	sp, #12
3418ea68:	af00      	add	r7, sp, #0
3418ea6a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3418ea6c:	4b05      	ldr	r3, [pc, #20]	@ (3418ea84 <LL_RCC_GetLPUARTClockSource+0x20>)
3418ea6e:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3418ea72:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
3418ea76:	4618      	mov	r0, r3
3418ea78:	370c      	adds	r7, #12
3418ea7a:	46bd      	mov	sp, r7
3418ea7c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ea80:	4770      	bx	lr
3418ea82:	bf00      	nop
3418ea84:	56028000 	.word	0x56028000

3418ea88 <LL_RCC_GetLTDCClockSource>:
{
3418ea88:	b480      	push	{r7}
3418ea8a:	b083      	sub	sp, #12
3418ea8c:	af00      	add	r7, sp, #0
3418ea8e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3418ea90:	4b05      	ldr	r3, [pc, #20]	@ (3418eaa8 <LL_RCC_GetLTDCClockSource+0x20>)
3418ea92:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3418ea96:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
3418ea9a:	4618      	mov	r0, r3
3418ea9c:	370c      	adds	r7, #12
3418ea9e:	46bd      	mov	sp, r7
3418eaa0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eaa4:	4770      	bx	lr
3418eaa6:	bf00      	nop
3418eaa8:	56028000 	.word	0x56028000

3418eaac <LL_RCC_GetMDFClockSource>:
{
3418eaac:	b480      	push	{r7}
3418eaae:	b083      	sub	sp, #12
3418eab0:	af00      	add	r7, sp, #0
3418eab2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3418eab4:	4b05      	ldr	r3, [pc, #20]	@ (3418eacc <LL_RCC_GetMDFClockSource+0x20>)
3418eab6:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3418eaba:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3418eabe:	4618      	mov	r0, r3
3418eac0:	370c      	adds	r7, #12
3418eac2:	46bd      	mov	sp, r7
3418eac4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eac8:	4770      	bx	lr
3418eaca:	bf00      	nop
3418eacc:	56028000 	.word	0x56028000

3418ead0 <LL_RCC_GetPSSIClockSource>:
{
3418ead0:	b480      	push	{r7}
3418ead2:	b083      	sub	sp, #12
3418ead4:	af00      	add	r7, sp, #0
3418ead6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3418ead8:	4b05      	ldr	r3, [pc, #20]	@ (3418eaf0 <LL_RCC_GetPSSIClockSource+0x20>)
3418eada:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418eade:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3418eae2:	4618      	mov	r0, r3
3418eae4:	370c      	adds	r7, #12
3418eae6:	46bd      	mov	sp, r7
3418eae8:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eaec:	4770      	bx	lr
3418eaee:	bf00      	nop
3418eaf0:	56028000 	.word	0x56028000

3418eaf4 <LL_RCC_GetSAIClockSource>:
{
3418eaf4:	b580      	push	{r7, lr}
3418eaf6:	b082      	sub	sp, #8
3418eaf8:	af00      	add	r7, sp, #0
3418eafa:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eafc:	6878      	ldr	r0, [r7, #4]
3418eafe:	f7ff fed7 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb02:	4603      	mov	r3, r0
}
3418eb04:	4618      	mov	r0, r3
3418eb06:	3708      	adds	r7, #8
3418eb08:	46bd      	mov	sp, r7
3418eb0a:	bd80      	pop	{r7, pc}

3418eb0c <LL_RCC_GetSDMMCClockSource>:
{
3418eb0c:	b580      	push	{r7, lr}
3418eb0e:	b082      	sub	sp, #8
3418eb10:	af00      	add	r7, sp, #0
3418eb12:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eb14:	6878      	ldr	r0, [r7, #4]
3418eb16:	f7ff fecb 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb1a:	4603      	mov	r3, r0
}
3418eb1c:	4618      	mov	r0, r3
3418eb1e:	3708      	adds	r7, #8
3418eb20:	46bd      	mov	sp, r7
3418eb22:	bd80      	pop	{r7, pc}

3418eb24 <LL_RCC_GetSPDIFRXClockSource>:
{
3418eb24:	b480      	push	{r7}
3418eb26:	b083      	sub	sp, #12
3418eb28:	af00      	add	r7, sp, #0
3418eb2a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3418eb2c:	4b05      	ldr	r3, [pc, #20]	@ (3418eb44 <LL_RCC_GetSPDIFRXClockSource+0x20>)
3418eb2e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3418eb32:	f003 0307 	and.w	r3, r3, #7
}
3418eb36:	4618      	mov	r0, r3
3418eb38:	370c      	adds	r7, #12
3418eb3a:	46bd      	mov	sp, r7
3418eb3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eb40:	4770      	bx	lr
3418eb42:	bf00      	nop
3418eb44:	56028000 	.word	0x56028000

3418eb48 <LL_RCC_GetSPIClockSource>:
{
3418eb48:	b580      	push	{r7, lr}
3418eb4a:	b082      	sub	sp, #8
3418eb4c:	af00      	add	r7, sp, #0
3418eb4e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eb50:	6878      	ldr	r0, [r7, #4]
3418eb52:	f7ff fead 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb56:	4603      	mov	r3, r0
}
3418eb58:	4618      	mov	r0, r3
3418eb5a:	3708      	adds	r7, #8
3418eb5c:	46bd      	mov	sp, r7
3418eb5e:	bd80      	pop	{r7, pc}

3418eb60 <LL_RCC_GetUSARTClockSource>:
{
3418eb60:	b580      	push	{r7, lr}
3418eb62:	b082      	sub	sp, #8
3418eb64:	af00      	add	r7, sp, #0
3418eb66:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eb68:	6878      	ldr	r0, [r7, #4]
3418eb6a:	f7ff fea1 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb6e:	4603      	mov	r3, r0
}
3418eb70:	4618      	mov	r0, r3
3418eb72:	3708      	adds	r7, #8
3418eb74:	46bd      	mov	sp, r7
3418eb76:	bd80      	pop	{r7, pc}

3418eb78 <LL_RCC_GetUARTClockSource>:
{
3418eb78:	b580      	push	{r7, lr}
3418eb7a:	b082      	sub	sp, #8
3418eb7c:	af00      	add	r7, sp, #0
3418eb7e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eb80:	6878      	ldr	r0, [r7, #4]
3418eb82:	f7ff fe95 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb86:	4603      	mov	r3, r0
}
3418eb88:	4618      	mov	r0, r3
3418eb8a:	3708      	adds	r7, #8
3418eb8c:	46bd      	mov	sp, r7
3418eb8e:	bd80      	pop	{r7, pc}

3418eb90 <LL_RCC_GetUSBClockSource>:
{
3418eb90:	b580      	push	{r7, lr}
3418eb92:	b082      	sub	sp, #8
3418eb94:	af00      	add	r7, sp, #0
3418eb96:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418eb98:	6878      	ldr	r0, [r7, #4]
3418eb9a:	f7ff fe89 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418eb9e:	4603      	mov	r3, r0
}
3418eba0:	4618      	mov	r0, r3
3418eba2:	3708      	adds	r7, #8
3418eba4:	46bd      	mov	sp, r7
3418eba6:	bd80      	pop	{r7, pc}

3418eba8 <LL_RCC_GetXSPIClockSource>:
{
3418eba8:	b580      	push	{r7, lr}
3418ebaa:	b082      	sub	sp, #8
3418ebac:	af00      	add	r7, sp, #0
3418ebae:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3418ebb0:	6878      	ldr	r0, [r7, #4]
3418ebb2:	f7ff fe7d 	bl	3418e8b0 <LL_RCC_GetClockSource>
3418ebb6:	4603      	mov	r3, r0
}
3418ebb8:	4618      	mov	r0, r3
3418ebba:	3708      	adds	r7, #8
3418ebbc:	46bd      	mov	sp, r7
3418ebbe:	bd80      	pop	{r7, pc}

3418ebc0 <LL_RCC_SetRTCClockSource>:
{
3418ebc0:	b480      	push	{r7}
3418ebc2:	b083      	sub	sp, #12
3418ebc4:	af00      	add	r7, sp, #0
3418ebc6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3418ebc8:	4b07      	ldr	r3, [pc, #28]	@ (3418ebe8 <LL_RCC_SetRTCClockSource+0x28>)
3418ebca:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418ebce:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
3418ebd2:	4905      	ldr	r1, [pc, #20]	@ (3418ebe8 <LL_RCC_SetRTCClockSource+0x28>)
3418ebd4:	687b      	ldr	r3, [r7, #4]
3418ebd6:	4313      	orrs	r3, r2
3418ebd8:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418ebdc:	bf00      	nop
3418ebde:	370c      	adds	r7, #12
3418ebe0:	46bd      	mov	sp, r7
3418ebe2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ebe6:	4770      	bx	lr
3418ebe8:	56028000 	.word	0x56028000

3418ebec <LL_RCC_GetRTCClockSource>:
{
3418ebec:	b480      	push	{r7}
3418ebee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3418ebf0:	4b04      	ldr	r3, [pc, #16]	@ (3418ec04 <LL_RCC_GetRTCClockSource+0x18>)
3418ebf2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418ebf6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3418ebfa:	4618      	mov	r0, r3
3418ebfc:	46bd      	mov	sp, r7
3418ebfe:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ec02:	4770      	bx	lr
3418ec04:	56028000 	.word	0x56028000

3418ec08 <LL_RCC_SetRTC_HSEPrescaler>:
{
3418ec08:	b480      	push	{r7}
3418ec0a:	b083      	sub	sp, #12
3418ec0c:	af00      	add	r7, sp, #0
3418ec0e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3418ec10:	4b07      	ldr	r3, [pc, #28]	@ (3418ec30 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3418ec12:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3418ec16:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3418ec1a:	4905      	ldr	r1, [pc, #20]	@ (3418ec30 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3418ec1c:	687b      	ldr	r3, [r7, #4]
3418ec1e:	4313      	orrs	r3, r2
3418ec20:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3418ec24:	bf00      	nop
3418ec26:	370c      	adds	r7, #12
3418ec28:	46bd      	mov	sp, r7
3418ec2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ec2e:	4770      	bx	lr
3418ec30:	56028000 	.word	0x56028000

3418ec34 <LL_RCC_SetTIMPrescaler>:
{
3418ec34:	b480      	push	{r7}
3418ec36:	b083      	sub	sp, #12
3418ec38:	af00      	add	r7, sp, #0
3418ec3a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3418ec3c:	4b07      	ldr	r3, [pc, #28]	@ (3418ec5c <LL_RCC_SetTIMPrescaler+0x28>)
3418ec3e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ec40:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3418ec44:	687b      	ldr	r3, [r7, #4]
3418ec46:	061b      	lsls	r3, r3, #24
3418ec48:	4904      	ldr	r1, [pc, #16]	@ (3418ec5c <LL_RCC_SetTIMPrescaler+0x28>)
3418ec4a:	4313      	orrs	r3, r2
3418ec4c:	624b      	str	r3, [r1, #36]	@ 0x24
}
3418ec4e:	bf00      	nop
3418ec50:	370c      	adds	r7, #12
3418ec52:	46bd      	mov	sp, r7
3418ec54:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ec58:	4770      	bx	lr
3418ec5a:	bf00      	nop
3418ec5c:	56028000 	.word	0x56028000

3418ec60 <LL_RCC_GetTIMPrescaler>:
{
3418ec60:	b480      	push	{r7}
3418ec62:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3418ec64:	4b04      	ldr	r3, [pc, #16]	@ (3418ec78 <LL_RCC_GetTIMPrescaler+0x18>)
3418ec66:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ec68:	0e1b      	lsrs	r3, r3, #24
3418ec6a:	f003 0303 	and.w	r3, r3, #3
}
3418ec6e:	4618      	mov	r0, r3
3418ec70:	46bd      	mov	sp, r7
3418ec72:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ec76:	4770      	bx	lr
3418ec78:	56028000 	.word	0x56028000

3418ec7c <LL_RCC_PLL1_GetSource>:
{
3418ec7c:	b480      	push	{r7}
3418ec7e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3418ec80:	4b04      	ldr	r3, [pc, #16]	@ (3418ec94 <LL_RCC_PLL1_GetSource+0x18>)
3418ec82:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418ec86:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418ec8a:	4618      	mov	r0, r3
3418ec8c:	46bd      	mov	sp, r7
3418ec8e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ec92:	4770      	bx	lr
3418ec94:	56028000 	.word	0x56028000

3418ec98 <LL_RCC_PLL1_IsReady>:
{
3418ec98:	b480      	push	{r7}
3418ec9a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3418ec9c:	4b07      	ldr	r3, [pc, #28]	@ (3418ecbc <LL_RCC_PLL1_IsReady+0x24>)
3418ec9e:	685b      	ldr	r3, [r3, #4]
3418eca0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418eca4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418eca8:	d101      	bne.n	3418ecae <LL_RCC_PLL1_IsReady+0x16>
3418ecaa:	2301      	movs	r3, #1
3418ecac:	e000      	b.n	3418ecb0 <LL_RCC_PLL1_IsReady+0x18>
3418ecae:	2300      	movs	r3, #0
}
3418ecb0:	4618      	mov	r0, r3
3418ecb2:	46bd      	mov	sp, r7
3418ecb4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ecb8:	4770      	bx	lr
3418ecba:	bf00      	nop
3418ecbc:	56028000 	.word	0x56028000

3418ecc0 <LL_RCC_PLL1_IsEnabledBypass>:
{
3418ecc0:	b480      	push	{r7}
3418ecc2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3418ecc4:	4b07      	ldr	r3, [pc, #28]	@ (3418ece4 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3418ecc6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418ecca:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418ecce:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418ecd2:	d101      	bne.n	3418ecd8 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3418ecd4:	2301      	movs	r3, #1
3418ecd6:	e000      	b.n	3418ecda <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3418ecd8:	2300      	movs	r3, #0
}
3418ecda:	4618      	mov	r0, r3
3418ecdc:	46bd      	mov	sp, r7
3418ecde:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ece2:	4770      	bx	lr
3418ece4:	56028000 	.word	0x56028000

3418ece8 <LL_RCC_PLL1_GetN>:
{
3418ece8:	b480      	push	{r7}
3418ecea:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3418ecec:	4b05      	ldr	r3, [pc, #20]	@ (3418ed04 <LL_RCC_PLL1_GetN+0x1c>)
3418ecee:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418ecf2:	0a1b      	lsrs	r3, r3, #8
3418ecf4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418ecf8:	4618      	mov	r0, r3
3418ecfa:	46bd      	mov	sp, r7
3418ecfc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ed00:	4770      	bx	lr
3418ed02:	bf00      	nop
3418ed04:	56028000 	.word	0x56028000

3418ed08 <LL_RCC_PLL1_GetM>:
{
3418ed08:	b480      	push	{r7}
3418ed0a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3418ed0c:	4b05      	ldr	r3, [pc, #20]	@ (3418ed24 <LL_RCC_PLL1_GetM+0x1c>)
3418ed0e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3418ed12:	0d1b      	lsrs	r3, r3, #20
3418ed14:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418ed18:	4618      	mov	r0, r3
3418ed1a:	46bd      	mov	sp, r7
3418ed1c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ed20:	4770      	bx	lr
3418ed22:	bf00      	nop
3418ed24:	56028000 	.word	0x56028000

3418ed28 <LL_RCC_PLL1_GetP1>:
{
3418ed28:	b480      	push	{r7}
3418ed2a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3418ed2c:	4b05      	ldr	r3, [pc, #20]	@ (3418ed44 <LL_RCC_PLL1_GetP1+0x1c>)
3418ed2e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418ed32:	0edb      	lsrs	r3, r3, #27
3418ed34:	f003 0307 	and.w	r3, r3, #7
}
3418ed38:	4618      	mov	r0, r3
3418ed3a:	46bd      	mov	sp, r7
3418ed3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ed40:	4770      	bx	lr
3418ed42:	bf00      	nop
3418ed44:	56028000 	.word	0x56028000

3418ed48 <LL_RCC_PLL1_GetP2>:
{
3418ed48:	b480      	push	{r7}
3418ed4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3418ed4c:	4b05      	ldr	r3, [pc, #20]	@ (3418ed64 <LL_RCC_PLL1_GetP2+0x1c>)
3418ed4e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418ed52:	0e1b      	lsrs	r3, r3, #24
3418ed54:	f003 0307 	and.w	r3, r3, #7
}
3418ed58:	4618      	mov	r0, r3
3418ed5a:	46bd      	mov	sp, r7
3418ed5c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ed60:	4770      	bx	lr
3418ed62:	bf00      	nop
3418ed64:	56028000 	.word	0x56028000

3418ed68 <LL_RCC_PLL1P_IsEnabled>:
{
3418ed68:	b480      	push	{r7}
3418ed6a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3418ed6c:	4b07      	ldr	r3, [pc, #28]	@ (3418ed8c <LL_RCC_PLL1P_IsEnabled+0x24>)
3418ed6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3418ed72:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418ed76:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418ed7a:	d101      	bne.n	3418ed80 <LL_RCC_PLL1P_IsEnabled+0x18>
3418ed7c:	2301      	movs	r3, #1
3418ed7e:	e000      	b.n	3418ed82 <LL_RCC_PLL1P_IsEnabled+0x1a>
3418ed80:	2300      	movs	r3, #0
}
3418ed82:	4618      	mov	r0, r3
3418ed84:	46bd      	mov	sp, r7
3418ed86:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ed8a:	4770      	bx	lr
3418ed8c:	56028000 	.word	0x56028000

3418ed90 <LL_RCC_PLL1_GetFRACN>:
{
3418ed90:	b480      	push	{r7}
3418ed92:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3418ed94:	4b04      	ldr	r3, [pc, #16]	@ (3418eda8 <LL_RCC_PLL1_GetFRACN+0x18>)
3418ed96:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3418ed9a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418ed9e:	4618      	mov	r0, r3
3418eda0:	46bd      	mov	sp, r7
3418eda2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eda6:	4770      	bx	lr
3418eda8:	56028000 	.word	0x56028000

3418edac <LL_RCC_PLL2_GetSource>:
{
3418edac:	b480      	push	{r7}
3418edae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3418edb0:	4b04      	ldr	r3, [pc, #16]	@ (3418edc4 <LL_RCC_PLL2_GetSource+0x18>)
3418edb2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418edb6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418edba:	4618      	mov	r0, r3
3418edbc:	46bd      	mov	sp, r7
3418edbe:	f85d 7b04 	ldr.w	r7, [sp], #4
3418edc2:	4770      	bx	lr
3418edc4:	56028000 	.word	0x56028000

3418edc8 <LL_RCC_PLL2_IsReady>:
{
3418edc8:	b480      	push	{r7}
3418edca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3418edcc:	4b07      	ldr	r3, [pc, #28]	@ (3418edec <LL_RCC_PLL2_IsReady+0x24>)
3418edce:	685b      	ldr	r3, [r3, #4]
3418edd0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418edd4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418edd8:	d101      	bne.n	3418edde <LL_RCC_PLL2_IsReady+0x16>
3418edda:	2301      	movs	r3, #1
3418eddc:	e000      	b.n	3418ede0 <LL_RCC_PLL2_IsReady+0x18>
3418edde:	2300      	movs	r3, #0
}
3418ede0:	4618      	mov	r0, r3
3418ede2:	46bd      	mov	sp, r7
3418ede4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ede8:	4770      	bx	lr
3418edea:	bf00      	nop
3418edec:	56028000 	.word	0x56028000

3418edf0 <LL_RCC_PLL2_IsEnabledBypass>:
{
3418edf0:	b480      	push	{r7}
3418edf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3418edf4:	4b07      	ldr	r3, [pc, #28]	@ (3418ee14 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3418edf6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418edfa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418edfe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418ee02:	d101      	bne.n	3418ee08 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3418ee04:	2301      	movs	r3, #1
3418ee06:	e000      	b.n	3418ee0a <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3418ee08:	2300      	movs	r3, #0
}
3418ee0a:	4618      	mov	r0, r3
3418ee0c:	46bd      	mov	sp, r7
3418ee0e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ee12:	4770      	bx	lr
3418ee14:	56028000 	.word	0x56028000

3418ee18 <LL_RCC_PLL2_GetN>:
{
3418ee18:	b480      	push	{r7}
3418ee1a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3418ee1c:	4b05      	ldr	r3, [pc, #20]	@ (3418ee34 <LL_RCC_PLL2_GetN+0x1c>)
3418ee1e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418ee22:	0a1b      	lsrs	r3, r3, #8
3418ee24:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418ee28:	4618      	mov	r0, r3
3418ee2a:	46bd      	mov	sp, r7
3418ee2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ee30:	4770      	bx	lr
3418ee32:	bf00      	nop
3418ee34:	56028000 	.word	0x56028000

3418ee38 <LL_RCC_PLL2_GetM>:
{
3418ee38:	b480      	push	{r7}
3418ee3a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3418ee3c:	4b05      	ldr	r3, [pc, #20]	@ (3418ee54 <LL_RCC_PLL2_GetM+0x1c>)
3418ee3e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3418ee42:	0d1b      	lsrs	r3, r3, #20
3418ee44:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418ee48:	4618      	mov	r0, r3
3418ee4a:	46bd      	mov	sp, r7
3418ee4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ee50:	4770      	bx	lr
3418ee52:	bf00      	nop
3418ee54:	56028000 	.word	0x56028000

3418ee58 <LL_RCC_PLL2_GetP1>:
{
3418ee58:	b480      	push	{r7}
3418ee5a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3418ee5c:	4b05      	ldr	r3, [pc, #20]	@ (3418ee74 <LL_RCC_PLL2_GetP1+0x1c>)
3418ee5e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418ee62:	0edb      	lsrs	r3, r3, #27
3418ee64:	f003 0307 	and.w	r3, r3, #7
}
3418ee68:	4618      	mov	r0, r3
3418ee6a:	46bd      	mov	sp, r7
3418ee6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ee70:	4770      	bx	lr
3418ee72:	bf00      	nop
3418ee74:	56028000 	.word	0x56028000

3418ee78 <LL_RCC_PLL2_GetP2>:
{
3418ee78:	b480      	push	{r7}
3418ee7a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3418ee7c:	4b05      	ldr	r3, [pc, #20]	@ (3418ee94 <LL_RCC_PLL2_GetP2+0x1c>)
3418ee7e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418ee82:	0e1b      	lsrs	r3, r3, #24
3418ee84:	f003 0307 	and.w	r3, r3, #7
}
3418ee88:	4618      	mov	r0, r3
3418ee8a:	46bd      	mov	sp, r7
3418ee8c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ee90:	4770      	bx	lr
3418ee92:	bf00      	nop
3418ee94:	56028000 	.word	0x56028000

3418ee98 <LL_RCC_PLL2P_IsEnabled>:
{
3418ee98:	b480      	push	{r7}
3418ee9a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3418ee9c:	4b07      	ldr	r3, [pc, #28]	@ (3418eebc <LL_RCC_PLL2P_IsEnabled+0x24>)
3418ee9e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3418eea2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418eea6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418eeaa:	d101      	bne.n	3418eeb0 <LL_RCC_PLL2P_IsEnabled+0x18>
3418eeac:	2301      	movs	r3, #1
3418eeae:	e000      	b.n	3418eeb2 <LL_RCC_PLL2P_IsEnabled+0x1a>
3418eeb0:	2300      	movs	r3, #0
}
3418eeb2:	4618      	mov	r0, r3
3418eeb4:	46bd      	mov	sp, r7
3418eeb6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eeba:	4770      	bx	lr
3418eebc:	56028000 	.word	0x56028000

3418eec0 <LL_RCC_PLL2_GetFRACN>:
{
3418eec0:	b480      	push	{r7}
3418eec2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3418eec4:	4b04      	ldr	r3, [pc, #16]	@ (3418eed8 <LL_RCC_PLL2_GetFRACN+0x18>)
3418eec6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3418eeca:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418eece:	4618      	mov	r0, r3
3418eed0:	46bd      	mov	sp, r7
3418eed2:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eed6:	4770      	bx	lr
3418eed8:	56028000 	.word	0x56028000

3418eedc <LL_RCC_PLL3_GetSource>:
{
3418eedc:	b480      	push	{r7}
3418eede:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3418eee0:	4b04      	ldr	r3, [pc, #16]	@ (3418eef4 <LL_RCC_PLL3_GetSource+0x18>)
3418eee2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418eee6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418eeea:	4618      	mov	r0, r3
3418eeec:	46bd      	mov	sp, r7
3418eeee:	f85d 7b04 	ldr.w	r7, [sp], #4
3418eef2:	4770      	bx	lr
3418eef4:	56028000 	.word	0x56028000

3418eef8 <LL_RCC_PLL3_IsReady>:
{
3418eef8:	b480      	push	{r7}
3418eefa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3418eefc:	4b07      	ldr	r3, [pc, #28]	@ (3418ef1c <LL_RCC_PLL3_IsReady+0x24>)
3418eefe:	685b      	ldr	r3, [r3, #4]
3418ef00:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3418ef04:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3418ef08:	d101      	bne.n	3418ef0e <LL_RCC_PLL3_IsReady+0x16>
3418ef0a:	2301      	movs	r3, #1
3418ef0c:	e000      	b.n	3418ef10 <LL_RCC_PLL3_IsReady+0x18>
3418ef0e:	2300      	movs	r3, #0
}
3418ef10:	4618      	mov	r0, r3
3418ef12:	46bd      	mov	sp, r7
3418ef14:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ef18:	4770      	bx	lr
3418ef1a:	bf00      	nop
3418ef1c:	56028000 	.word	0x56028000

3418ef20 <LL_RCC_PLL3_IsEnabledBypass>:
{
3418ef20:	b480      	push	{r7}
3418ef22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3418ef24:	4b07      	ldr	r3, [pc, #28]	@ (3418ef44 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3418ef26:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418ef2a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418ef2e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418ef32:	d101      	bne.n	3418ef38 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3418ef34:	2301      	movs	r3, #1
3418ef36:	e000      	b.n	3418ef3a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3418ef38:	2300      	movs	r3, #0
}
3418ef3a:	4618      	mov	r0, r3
3418ef3c:	46bd      	mov	sp, r7
3418ef3e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ef42:	4770      	bx	lr
3418ef44:	56028000 	.word	0x56028000

3418ef48 <LL_RCC_PLL3_GetN>:
{
3418ef48:	b480      	push	{r7}
3418ef4a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3418ef4c:	4b05      	ldr	r3, [pc, #20]	@ (3418ef64 <LL_RCC_PLL3_GetN+0x1c>)
3418ef4e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418ef52:	0a1b      	lsrs	r3, r3, #8
3418ef54:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418ef58:	4618      	mov	r0, r3
3418ef5a:	46bd      	mov	sp, r7
3418ef5c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ef60:	4770      	bx	lr
3418ef62:	bf00      	nop
3418ef64:	56028000 	.word	0x56028000

3418ef68 <LL_RCC_PLL3_GetM>:
{
3418ef68:	b480      	push	{r7}
3418ef6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3418ef6c:	4b05      	ldr	r3, [pc, #20]	@ (3418ef84 <LL_RCC_PLL3_GetM+0x1c>)
3418ef6e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3418ef72:	0d1b      	lsrs	r3, r3, #20
3418ef74:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418ef78:	4618      	mov	r0, r3
3418ef7a:	46bd      	mov	sp, r7
3418ef7c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418ef80:	4770      	bx	lr
3418ef82:	bf00      	nop
3418ef84:	56028000 	.word	0x56028000

3418ef88 <LL_RCC_PLL3_GetP1>:
{
3418ef88:	b480      	push	{r7}
3418ef8a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3418ef8c:	4b05      	ldr	r3, [pc, #20]	@ (3418efa4 <LL_RCC_PLL3_GetP1+0x1c>)
3418ef8e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418ef92:	0edb      	lsrs	r3, r3, #27
3418ef94:	f003 0307 	and.w	r3, r3, #7
}
3418ef98:	4618      	mov	r0, r3
3418ef9a:	46bd      	mov	sp, r7
3418ef9c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418efa0:	4770      	bx	lr
3418efa2:	bf00      	nop
3418efa4:	56028000 	.word	0x56028000

3418efa8 <LL_RCC_PLL3_GetP2>:
{
3418efa8:	b480      	push	{r7}
3418efaa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3418efac:	4b05      	ldr	r3, [pc, #20]	@ (3418efc4 <LL_RCC_PLL3_GetP2+0x1c>)
3418efae:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418efb2:	0e1b      	lsrs	r3, r3, #24
3418efb4:	f003 0307 	and.w	r3, r3, #7
}
3418efb8:	4618      	mov	r0, r3
3418efba:	46bd      	mov	sp, r7
3418efbc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418efc0:	4770      	bx	lr
3418efc2:	bf00      	nop
3418efc4:	56028000 	.word	0x56028000

3418efc8 <LL_RCC_PLL3P_IsEnabled>:
{
3418efc8:	b480      	push	{r7}
3418efca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3418efcc:	4b07      	ldr	r3, [pc, #28]	@ (3418efec <LL_RCC_PLL3P_IsEnabled+0x24>)
3418efce:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418efd2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418efd6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418efda:	d101      	bne.n	3418efe0 <LL_RCC_PLL3P_IsEnabled+0x18>
3418efdc:	2301      	movs	r3, #1
3418efde:	e000      	b.n	3418efe2 <LL_RCC_PLL3P_IsEnabled+0x1a>
3418efe0:	2300      	movs	r3, #0
}
3418efe2:	4618      	mov	r0, r3
3418efe4:	46bd      	mov	sp, r7
3418efe6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418efea:	4770      	bx	lr
3418efec:	56028000 	.word	0x56028000

3418eff0 <LL_RCC_PLL3_GetFRACN>:
{
3418eff0:	b480      	push	{r7}
3418eff2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3418eff4:	4b04      	ldr	r3, [pc, #16]	@ (3418f008 <LL_RCC_PLL3_GetFRACN+0x18>)
3418eff6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418effa:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418effe:	4618      	mov	r0, r3
3418f000:	46bd      	mov	sp, r7
3418f002:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f006:	4770      	bx	lr
3418f008:	56028000 	.word	0x56028000

3418f00c <LL_RCC_PLL4_GetSource>:
{
3418f00c:	b480      	push	{r7}
3418f00e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3418f010:	4b04      	ldr	r3, [pc, #16]	@ (3418f024 <LL_RCC_PLL4_GetSource+0x18>)
3418f012:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418f016:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3418f01a:	4618      	mov	r0, r3
3418f01c:	46bd      	mov	sp, r7
3418f01e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f022:	4770      	bx	lr
3418f024:	56028000 	.word	0x56028000

3418f028 <LL_RCC_PLL4_IsReady>:
{
3418f028:	b480      	push	{r7}
3418f02a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3418f02c:	4b07      	ldr	r3, [pc, #28]	@ (3418f04c <LL_RCC_PLL4_IsReady+0x24>)
3418f02e:	685b      	ldr	r3, [r3, #4]
3418f030:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418f034:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418f038:	d101      	bne.n	3418f03e <LL_RCC_PLL4_IsReady+0x16>
3418f03a:	2301      	movs	r3, #1
3418f03c:	e000      	b.n	3418f040 <LL_RCC_PLL4_IsReady+0x18>
3418f03e:	2300      	movs	r3, #0
}
3418f040:	4618      	mov	r0, r3
3418f042:	46bd      	mov	sp, r7
3418f044:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f048:	4770      	bx	lr
3418f04a:	bf00      	nop
3418f04c:	56028000 	.word	0x56028000

3418f050 <LL_RCC_PLL4_IsEnabledBypass>:
{
3418f050:	b480      	push	{r7}
3418f052:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3418f054:	4b07      	ldr	r3, [pc, #28]	@ (3418f074 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3418f056:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418f05a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3418f05e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3418f062:	d101      	bne.n	3418f068 <LL_RCC_PLL4_IsEnabledBypass+0x18>
3418f064:	2301      	movs	r3, #1
3418f066:	e000      	b.n	3418f06a <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3418f068:	2300      	movs	r3, #0
}
3418f06a:	4618      	mov	r0, r3
3418f06c:	46bd      	mov	sp, r7
3418f06e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f072:	4770      	bx	lr
3418f074:	56028000 	.word	0x56028000

3418f078 <LL_RCC_PLL4_GetN>:
{
3418f078:	b480      	push	{r7}
3418f07a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3418f07c:	4b05      	ldr	r3, [pc, #20]	@ (3418f094 <LL_RCC_PLL4_GetN+0x1c>)
3418f07e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418f082:	0a1b      	lsrs	r3, r3, #8
3418f084:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3418f088:	4618      	mov	r0, r3
3418f08a:	46bd      	mov	sp, r7
3418f08c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f090:	4770      	bx	lr
3418f092:	bf00      	nop
3418f094:	56028000 	.word	0x56028000

3418f098 <LL_RCC_PLL4_GetM>:
{
3418f098:	b480      	push	{r7}
3418f09a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3418f09c:	4b05      	ldr	r3, [pc, #20]	@ (3418f0b4 <LL_RCC_PLL4_GetM+0x1c>)
3418f09e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418f0a2:	0d1b      	lsrs	r3, r3, #20
3418f0a4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3418f0a8:	4618      	mov	r0, r3
3418f0aa:	46bd      	mov	sp, r7
3418f0ac:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f0b0:	4770      	bx	lr
3418f0b2:	bf00      	nop
3418f0b4:	56028000 	.word	0x56028000

3418f0b8 <LL_RCC_PLL4_GetP1>:
{
3418f0b8:	b480      	push	{r7}
3418f0ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
3418f0bc:	4b05      	ldr	r3, [pc, #20]	@ (3418f0d4 <LL_RCC_PLL4_GetP1+0x1c>)
3418f0be:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418f0c2:	0edb      	lsrs	r3, r3, #27
3418f0c4:	f003 0307 	and.w	r3, r3, #7
}
3418f0c8:	4618      	mov	r0, r3
3418f0ca:	46bd      	mov	sp, r7
3418f0cc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f0d0:	4770      	bx	lr
3418f0d2:	bf00      	nop
3418f0d4:	56028000 	.word	0x56028000

3418f0d8 <LL_RCC_PLL4_GetP2>:
{
3418f0d8:	b480      	push	{r7}
3418f0da:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
3418f0dc:	4b05      	ldr	r3, [pc, #20]	@ (3418f0f4 <LL_RCC_PLL4_GetP2+0x1c>)
3418f0de:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418f0e2:	0e1b      	lsrs	r3, r3, #24
3418f0e4:	f003 0307 	and.w	r3, r3, #7
}
3418f0e8:	4618      	mov	r0, r3
3418f0ea:	46bd      	mov	sp, r7
3418f0ec:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f0f0:	4770      	bx	lr
3418f0f2:	bf00      	nop
3418f0f4:	56028000 	.word	0x56028000

3418f0f8 <LL_RCC_PLL4P_IsEnabled>:
{
3418f0f8:	b480      	push	{r7}
3418f0fa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
3418f0fc:	4b07      	ldr	r3, [pc, #28]	@ (3418f11c <LL_RCC_PLL4P_IsEnabled+0x24>)
3418f0fe:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418f102:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3418f106:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3418f10a:	d101      	bne.n	3418f110 <LL_RCC_PLL4P_IsEnabled+0x18>
3418f10c:	2301      	movs	r3, #1
3418f10e:	e000      	b.n	3418f112 <LL_RCC_PLL4P_IsEnabled+0x1a>
3418f110:	2300      	movs	r3, #0
}
3418f112:	4618      	mov	r0, r3
3418f114:	46bd      	mov	sp, r7
3418f116:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f11a:	4770      	bx	lr
3418f11c:	56028000 	.word	0x56028000

3418f120 <LL_RCC_PLL4_GetFRACN>:
{
3418f120:	b480      	push	{r7}
3418f122:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
3418f124:	4b04      	ldr	r3, [pc, #16]	@ (3418f138 <LL_RCC_PLL4_GetFRACN+0x18>)
3418f126:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418f12a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3418f12e:	4618      	mov	r0, r3
3418f130:	46bd      	mov	sp, r7
3418f132:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f136:	4770      	bx	lr
3418f138:	56028000 	.word	0x56028000

3418f13c <LL_RCC_IC3_Enable>:
{
3418f13c:	b480      	push	{r7}
3418f13e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
3418f140:	4b04      	ldr	r3, [pc, #16]	@ (3418f154 <LL_RCC_IC3_Enable+0x18>)
3418f142:	2204      	movs	r2, #4
3418f144:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f148:	bf00      	nop
3418f14a:	46bd      	mov	sp, r7
3418f14c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f150:	4770      	bx	lr
3418f152:	bf00      	nop
3418f154:	56028000 	.word	0x56028000

3418f158 <LL_RCC_IC3_IsEnabled>:
{
3418f158:	b480      	push	{r7}
3418f15a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3418f15c:	4b07      	ldr	r3, [pc, #28]	@ (3418f17c <LL_RCC_IC3_IsEnabled+0x24>)
3418f15e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f162:	f003 0304 	and.w	r3, r3, #4
3418f166:	2b04      	cmp	r3, #4
3418f168:	d101      	bne.n	3418f16e <LL_RCC_IC3_IsEnabled+0x16>
3418f16a:	2301      	movs	r3, #1
3418f16c:	e000      	b.n	3418f170 <LL_RCC_IC3_IsEnabled+0x18>
3418f16e:	2300      	movs	r3, #0
}
3418f170:	4618      	mov	r0, r3
3418f172:	46bd      	mov	sp, r7
3418f174:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f178:	4770      	bx	lr
3418f17a:	bf00      	nop
3418f17c:	56028000 	.word	0x56028000

3418f180 <LL_RCC_IC3_GetSource>:
{
3418f180:	b480      	push	{r7}
3418f182:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
3418f184:	4b04      	ldr	r3, [pc, #16]	@ (3418f198 <LL_RCC_IC3_GetSource+0x18>)
3418f186:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418f18a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f18e:	4618      	mov	r0, r3
3418f190:	46bd      	mov	sp, r7
3418f192:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f196:	4770      	bx	lr
3418f198:	56028000 	.word	0x56028000

3418f19c <LL_RCC_IC3_GetDivider>:
{
3418f19c:	b480      	push	{r7}
3418f19e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
3418f1a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f1b8 <LL_RCC_IC3_GetDivider+0x1c>)
3418f1a2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418f1a6:	0c1b      	lsrs	r3, r3, #16
3418f1a8:	b2db      	uxtb	r3, r3
3418f1aa:	3301      	adds	r3, #1
}
3418f1ac:	4618      	mov	r0, r3
3418f1ae:	46bd      	mov	sp, r7
3418f1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f1b4:	4770      	bx	lr
3418f1b6:	bf00      	nop
3418f1b8:	56028000 	.word	0x56028000

3418f1bc <LL_RCC_IC4_Enable>:
{
3418f1bc:	b480      	push	{r7}
3418f1be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
3418f1c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f1d4 <LL_RCC_IC4_Enable+0x18>)
3418f1c2:	2208      	movs	r2, #8
3418f1c4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f1c8:	bf00      	nop
3418f1ca:	46bd      	mov	sp, r7
3418f1cc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f1d0:	4770      	bx	lr
3418f1d2:	bf00      	nop
3418f1d4:	56028000 	.word	0x56028000

3418f1d8 <LL_RCC_IC4_IsEnabled>:
{
3418f1d8:	b480      	push	{r7}
3418f1da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
3418f1dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f1fc <LL_RCC_IC4_IsEnabled+0x24>)
3418f1de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f1e2:	f003 0308 	and.w	r3, r3, #8
3418f1e6:	2b08      	cmp	r3, #8
3418f1e8:	d101      	bne.n	3418f1ee <LL_RCC_IC4_IsEnabled+0x16>
3418f1ea:	2301      	movs	r3, #1
3418f1ec:	e000      	b.n	3418f1f0 <LL_RCC_IC4_IsEnabled+0x18>
3418f1ee:	2300      	movs	r3, #0
}
3418f1f0:	4618      	mov	r0, r3
3418f1f2:	46bd      	mov	sp, r7
3418f1f4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f1f8:	4770      	bx	lr
3418f1fa:	bf00      	nop
3418f1fc:	56028000 	.word	0x56028000

3418f200 <LL_RCC_IC4_GetSource>:
{
3418f200:	b480      	push	{r7}
3418f202:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
3418f204:	4b04      	ldr	r3, [pc, #16]	@ (3418f218 <LL_RCC_IC4_GetSource+0x18>)
3418f206:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418f20a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f20e:	4618      	mov	r0, r3
3418f210:	46bd      	mov	sp, r7
3418f212:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f216:	4770      	bx	lr
3418f218:	56028000 	.word	0x56028000

3418f21c <LL_RCC_IC4_GetDivider>:
{
3418f21c:	b480      	push	{r7}
3418f21e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
3418f220:	4b05      	ldr	r3, [pc, #20]	@ (3418f238 <LL_RCC_IC4_GetDivider+0x1c>)
3418f222:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418f226:	0c1b      	lsrs	r3, r3, #16
3418f228:	b2db      	uxtb	r3, r3
3418f22a:	3301      	adds	r3, #1
}
3418f22c:	4618      	mov	r0, r3
3418f22e:	46bd      	mov	sp, r7
3418f230:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f234:	4770      	bx	lr
3418f236:	bf00      	nop
3418f238:	56028000 	.word	0x56028000

3418f23c <LL_RCC_IC5_Enable>:
{
3418f23c:	b480      	push	{r7}
3418f23e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3418f240:	4b04      	ldr	r3, [pc, #16]	@ (3418f254 <LL_RCC_IC5_Enable+0x18>)
3418f242:	2210      	movs	r2, #16
3418f244:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f248:	bf00      	nop
3418f24a:	46bd      	mov	sp, r7
3418f24c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f250:	4770      	bx	lr
3418f252:	bf00      	nop
3418f254:	56028000 	.word	0x56028000

3418f258 <LL_RCC_IC5_IsEnabled>:
{
3418f258:	b480      	push	{r7}
3418f25a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3418f25c:	4b07      	ldr	r3, [pc, #28]	@ (3418f27c <LL_RCC_IC5_IsEnabled+0x24>)
3418f25e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f262:	f003 0310 	and.w	r3, r3, #16
3418f266:	2b10      	cmp	r3, #16
3418f268:	d101      	bne.n	3418f26e <LL_RCC_IC5_IsEnabled+0x16>
3418f26a:	2301      	movs	r3, #1
3418f26c:	e000      	b.n	3418f270 <LL_RCC_IC5_IsEnabled+0x18>
3418f26e:	2300      	movs	r3, #0
}
3418f270:	4618      	mov	r0, r3
3418f272:	46bd      	mov	sp, r7
3418f274:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f278:	4770      	bx	lr
3418f27a:	bf00      	nop
3418f27c:	56028000 	.word	0x56028000

3418f280 <LL_RCC_IC5_GetSource>:
{
3418f280:	b480      	push	{r7}
3418f282:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
3418f284:	4b04      	ldr	r3, [pc, #16]	@ (3418f298 <LL_RCC_IC5_GetSource+0x18>)
3418f286:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418f28a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f28e:	4618      	mov	r0, r3
3418f290:	46bd      	mov	sp, r7
3418f292:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f296:	4770      	bx	lr
3418f298:	56028000 	.word	0x56028000

3418f29c <LL_RCC_IC5_GetDivider>:
{
3418f29c:	b480      	push	{r7}
3418f29e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
3418f2a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f2b8 <LL_RCC_IC5_GetDivider+0x1c>)
3418f2a2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418f2a6:	0c1b      	lsrs	r3, r3, #16
3418f2a8:	b2db      	uxtb	r3, r3
3418f2aa:	3301      	adds	r3, #1
}
3418f2ac:	4618      	mov	r0, r3
3418f2ae:	46bd      	mov	sp, r7
3418f2b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f2b4:	4770      	bx	lr
3418f2b6:	bf00      	nop
3418f2b8:	56028000 	.word	0x56028000

3418f2bc <LL_RCC_IC7_Enable>:
{
3418f2bc:	b480      	push	{r7}
3418f2be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3418f2c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f2d4 <LL_RCC_IC7_Enable+0x18>)
3418f2c2:	2240      	movs	r2, #64	@ 0x40
3418f2c4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f2c8:	bf00      	nop
3418f2ca:	46bd      	mov	sp, r7
3418f2cc:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f2d0:	4770      	bx	lr
3418f2d2:	bf00      	nop
3418f2d4:	56028000 	.word	0x56028000

3418f2d8 <LL_RCC_IC7_IsEnabled>:
{
3418f2d8:	b480      	push	{r7}
3418f2da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
3418f2dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f2fc <LL_RCC_IC7_IsEnabled+0x24>)
3418f2de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f2e2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418f2e6:	2b40      	cmp	r3, #64	@ 0x40
3418f2e8:	d101      	bne.n	3418f2ee <LL_RCC_IC7_IsEnabled+0x16>
3418f2ea:	2301      	movs	r3, #1
3418f2ec:	e000      	b.n	3418f2f0 <LL_RCC_IC7_IsEnabled+0x18>
3418f2ee:	2300      	movs	r3, #0
}
3418f2f0:	4618      	mov	r0, r3
3418f2f2:	46bd      	mov	sp, r7
3418f2f4:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f2f8:	4770      	bx	lr
3418f2fa:	bf00      	nop
3418f2fc:	56028000 	.word	0x56028000

3418f300 <LL_RCC_IC7_GetSource>:
{
3418f300:	b480      	push	{r7}
3418f302:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
3418f304:	4b04      	ldr	r3, [pc, #16]	@ (3418f318 <LL_RCC_IC7_GetSource+0x18>)
3418f306:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f30a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f30e:	4618      	mov	r0, r3
3418f310:	46bd      	mov	sp, r7
3418f312:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f316:	4770      	bx	lr
3418f318:	56028000 	.word	0x56028000

3418f31c <LL_RCC_IC7_GetDivider>:
{
3418f31c:	b480      	push	{r7}
3418f31e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
3418f320:	4b05      	ldr	r3, [pc, #20]	@ (3418f338 <LL_RCC_IC7_GetDivider+0x1c>)
3418f322:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3418f326:	0c1b      	lsrs	r3, r3, #16
3418f328:	b2db      	uxtb	r3, r3
3418f32a:	3301      	adds	r3, #1
}
3418f32c:	4618      	mov	r0, r3
3418f32e:	46bd      	mov	sp, r7
3418f330:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f334:	4770      	bx	lr
3418f336:	bf00      	nop
3418f338:	56028000 	.word	0x56028000

3418f33c <LL_RCC_IC8_Enable>:
{
3418f33c:	b480      	push	{r7}
3418f33e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
3418f340:	4b04      	ldr	r3, [pc, #16]	@ (3418f354 <LL_RCC_IC8_Enable+0x18>)
3418f342:	2280      	movs	r2, #128	@ 0x80
3418f344:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f348:	bf00      	nop
3418f34a:	46bd      	mov	sp, r7
3418f34c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f350:	4770      	bx	lr
3418f352:	bf00      	nop
3418f354:	56028000 	.word	0x56028000

3418f358 <LL_RCC_IC8_IsEnabled>:
{
3418f358:	b480      	push	{r7}
3418f35a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3418f35c:	4b07      	ldr	r3, [pc, #28]	@ (3418f37c <LL_RCC_IC8_IsEnabled+0x24>)
3418f35e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f362:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3418f366:	2b80      	cmp	r3, #128	@ 0x80
3418f368:	d101      	bne.n	3418f36e <LL_RCC_IC8_IsEnabled+0x16>
3418f36a:	2301      	movs	r3, #1
3418f36c:	e000      	b.n	3418f370 <LL_RCC_IC8_IsEnabled+0x18>
3418f36e:	2300      	movs	r3, #0
}
3418f370:	4618      	mov	r0, r3
3418f372:	46bd      	mov	sp, r7
3418f374:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f378:	4770      	bx	lr
3418f37a:	bf00      	nop
3418f37c:	56028000 	.word	0x56028000

3418f380 <LL_RCC_IC8_GetSource>:
{
3418f380:	b480      	push	{r7}
3418f382:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
3418f384:	4b04      	ldr	r3, [pc, #16]	@ (3418f398 <LL_RCC_IC8_GetSource+0x18>)
3418f386:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418f38a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f38e:	4618      	mov	r0, r3
3418f390:	46bd      	mov	sp, r7
3418f392:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f396:	4770      	bx	lr
3418f398:	56028000 	.word	0x56028000

3418f39c <LL_RCC_IC8_GetDivider>:
{
3418f39c:	b480      	push	{r7}
3418f39e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
3418f3a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f3b8 <LL_RCC_IC8_GetDivider+0x1c>)
3418f3a2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3418f3a6:	0c1b      	lsrs	r3, r3, #16
3418f3a8:	b2db      	uxtb	r3, r3
3418f3aa:	3301      	adds	r3, #1
}
3418f3ac:	4618      	mov	r0, r3
3418f3ae:	46bd      	mov	sp, r7
3418f3b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f3b4:	4770      	bx	lr
3418f3b6:	bf00      	nop
3418f3b8:	56028000 	.word	0x56028000

3418f3bc <LL_RCC_IC9_Enable>:
{
3418f3bc:	b480      	push	{r7}
3418f3be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
3418f3c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f3d4 <LL_RCC_IC9_Enable+0x18>)
3418f3c2:	f44f 7280 	mov.w	r2, #256	@ 0x100
3418f3c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f3ca:	bf00      	nop
3418f3cc:	46bd      	mov	sp, r7
3418f3ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f3d2:	4770      	bx	lr
3418f3d4:	56028000 	.word	0x56028000

3418f3d8 <LL_RCC_IC9_IsEnabled>:
{
3418f3d8:	b480      	push	{r7}
3418f3da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
3418f3dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f3fc <LL_RCC_IC9_IsEnabled+0x24>)
3418f3de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f3e2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3418f3e6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418f3ea:	d101      	bne.n	3418f3f0 <LL_RCC_IC9_IsEnabled+0x18>
3418f3ec:	2301      	movs	r3, #1
3418f3ee:	e000      	b.n	3418f3f2 <LL_RCC_IC9_IsEnabled+0x1a>
3418f3f0:	2300      	movs	r3, #0
}
3418f3f2:	4618      	mov	r0, r3
3418f3f4:	46bd      	mov	sp, r7
3418f3f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f3fa:	4770      	bx	lr
3418f3fc:	56028000 	.word	0x56028000

3418f400 <LL_RCC_IC9_GetSource>:
{
3418f400:	b480      	push	{r7}
3418f402:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
3418f404:	4b04      	ldr	r3, [pc, #16]	@ (3418f418 <LL_RCC_IC9_GetSource+0x18>)
3418f406:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f40a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f40e:	4618      	mov	r0, r3
3418f410:	46bd      	mov	sp, r7
3418f412:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f416:	4770      	bx	lr
3418f418:	56028000 	.word	0x56028000

3418f41c <LL_RCC_IC9_GetDivider>:
{
3418f41c:	b480      	push	{r7}
3418f41e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
3418f420:	4b05      	ldr	r3, [pc, #20]	@ (3418f438 <LL_RCC_IC9_GetDivider+0x1c>)
3418f422:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3418f426:	0c1b      	lsrs	r3, r3, #16
3418f428:	b2db      	uxtb	r3, r3
3418f42a:	3301      	adds	r3, #1
}
3418f42c:	4618      	mov	r0, r3
3418f42e:	46bd      	mov	sp, r7
3418f430:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f434:	4770      	bx	lr
3418f436:	bf00      	nop
3418f438:	56028000 	.word	0x56028000

3418f43c <LL_RCC_IC10_Enable>:
{
3418f43c:	b480      	push	{r7}
3418f43e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
3418f440:	4b04      	ldr	r3, [pc, #16]	@ (3418f454 <LL_RCC_IC10_Enable+0x18>)
3418f442:	f44f 7200 	mov.w	r2, #512	@ 0x200
3418f446:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f44a:	bf00      	nop
3418f44c:	46bd      	mov	sp, r7
3418f44e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f452:	4770      	bx	lr
3418f454:	56028000 	.word	0x56028000

3418f458 <LL_RCC_IC10_IsEnabled>:
{
3418f458:	b480      	push	{r7}
3418f45a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3418f45c:	4b07      	ldr	r3, [pc, #28]	@ (3418f47c <LL_RCC_IC10_IsEnabled+0x24>)
3418f45e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f462:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3418f466:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3418f46a:	d101      	bne.n	3418f470 <LL_RCC_IC10_IsEnabled+0x18>
3418f46c:	2301      	movs	r3, #1
3418f46e:	e000      	b.n	3418f472 <LL_RCC_IC10_IsEnabled+0x1a>
3418f470:	2300      	movs	r3, #0
}
3418f472:	4618      	mov	r0, r3
3418f474:	46bd      	mov	sp, r7
3418f476:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f47a:	4770      	bx	lr
3418f47c:	56028000 	.word	0x56028000

3418f480 <LL_RCC_IC10_GetSource>:
{
3418f480:	b480      	push	{r7}
3418f482:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
3418f484:	4b04      	ldr	r3, [pc, #16]	@ (3418f498 <LL_RCC_IC10_GetSource+0x18>)
3418f486:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f48a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f48e:	4618      	mov	r0, r3
3418f490:	46bd      	mov	sp, r7
3418f492:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f496:	4770      	bx	lr
3418f498:	56028000 	.word	0x56028000

3418f49c <LL_RCC_IC10_GetDivider>:
{
3418f49c:	b480      	push	{r7}
3418f49e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
3418f4a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f4b8 <LL_RCC_IC10_GetDivider+0x1c>)
3418f4a2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418f4a6:	0c1b      	lsrs	r3, r3, #16
3418f4a8:	b2db      	uxtb	r3, r3
3418f4aa:	3301      	adds	r3, #1
}
3418f4ac:	4618      	mov	r0, r3
3418f4ae:	46bd      	mov	sp, r7
3418f4b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f4b4:	4770      	bx	lr
3418f4b6:	bf00      	nop
3418f4b8:	56028000 	.word	0x56028000

3418f4bc <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
3418f4bc:	b480      	push	{r7}
3418f4be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3418f4c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f4d4 <LL_RCC_IC12_Enable+0x18>)
3418f4c2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3418f4c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f4ca:	bf00      	nop
3418f4cc:	46bd      	mov	sp, r7
3418f4ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f4d2:	4770      	bx	lr
3418f4d4:	56028000 	.word	0x56028000

3418f4d8 <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
3418f4d8:	b480      	push	{r7}
3418f4da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
3418f4dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f4fc <LL_RCC_IC12_IsEnabled+0x24>)
3418f4de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f4e2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3418f4e6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3418f4ea:	d101      	bne.n	3418f4f0 <LL_RCC_IC12_IsEnabled+0x18>
3418f4ec:	2301      	movs	r3, #1
3418f4ee:	e000      	b.n	3418f4f2 <LL_RCC_IC12_IsEnabled+0x1a>
3418f4f0:	2300      	movs	r3, #0
}
3418f4f2:	4618      	mov	r0, r3
3418f4f4:	46bd      	mov	sp, r7
3418f4f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f4fa:	4770      	bx	lr
3418f4fc:	56028000 	.word	0x56028000

3418f500 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
3418f500:	b480      	push	{r7}
3418f502:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
3418f504:	4b04      	ldr	r3, [pc, #16]	@ (3418f518 <LL_RCC_IC12_GetSource+0x18>)
3418f506:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418f50a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f50e:	4618      	mov	r0, r3
3418f510:	46bd      	mov	sp, r7
3418f512:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f516:	4770      	bx	lr
3418f518:	56028000 	.word	0x56028000

3418f51c <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
3418f51c:	b480      	push	{r7}
3418f51e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
3418f520:	4b05      	ldr	r3, [pc, #20]	@ (3418f538 <LL_RCC_IC12_GetDivider+0x1c>)
3418f522:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3418f526:	0c1b      	lsrs	r3, r3, #16
3418f528:	b2db      	uxtb	r3, r3
3418f52a:	3301      	adds	r3, #1
}
3418f52c:	4618      	mov	r0, r3
3418f52e:	46bd      	mov	sp, r7
3418f530:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f534:	4770      	bx	lr
3418f536:	bf00      	nop
3418f538:	56028000 	.word	0x56028000

3418f53c <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3418f53c:	b480      	push	{r7}
3418f53e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
3418f540:	4b04      	ldr	r3, [pc, #16]	@ (3418f554 <LL_RCC_IC13_Enable+0x18>)
3418f542:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3418f546:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f54a:	bf00      	nop
3418f54c:	46bd      	mov	sp, r7
3418f54e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f552:	4770      	bx	lr
3418f554:	56028000 	.word	0x56028000

3418f558 <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
3418f558:	b480      	push	{r7}
3418f55a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3418f55c:	4b07      	ldr	r3, [pc, #28]	@ (3418f57c <LL_RCC_IC13_IsEnabled+0x24>)
3418f55e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f562:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3418f566:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3418f56a:	d101      	bne.n	3418f570 <LL_RCC_IC13_IsEnabled+0x18>
3418f56c:	2301      	movs	r3, #1
3418f56e:	e000      	b.n	3418f572 <LL_RCC_IC13_IsEnabled+0x1a>
3418f570:	2300      	movs	r3, #0
}
3418f572:	4618      	mov	r0, r3
3418f574:	46bd      	mov	sp, r7
3418f576:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f57a:	4770      	bx	lr
3418f57c:	56028000 	.word	0x56028000

3418f580 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
3418f580:	b480      	push	{r7}
3418f582:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
3418f584:	4b04      	ldr	r3, [pc, #16]	@ (3418f598 <LL_RCC_IC13_GetSource+0x18>)
3418f586:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418f58a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f58e:	4618      	mov	r0, r3
3418f590:	46bd      	mov	sp, r7
3418f592:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f596:	4770      	bx	lr
3418f598:	56028000 	.word	0x56028000

3418f59c <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
3418f59c:	b480      	push	{r7}
3418f59e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
3418f5a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f5b8 <LL_RCC_IC13_GetDivider+0x1c>)
3418f5a2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3418f5a6:	0c1b      	lsrs	r3, r3, #16
3418f5a8:	b2db      	uxtb	r3, r3
3418f5aa:	3301      	adds	r3, #1
}
3418f5ac:	4618      	mov	r0, r3
3418f5ae:	46bd      	mov	sp, r7
3418f5b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f5b4:	4770      	bx	lr
3418f5b6:	bf00      	nop
3418f5b8:	56028000 	.word	0x56028000

3418f5bc <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
3418f5bc:	b480      	push	{r7}
3418f5be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
3418f5c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f5d4 <LL_RCC_IC14_Enable+0x18>)
3418f5c2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3418f5c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f5ca:	bf00      	nop
3418f5cc:	46bd      	mov	sp, r7
3418f5ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f5d2:	4770      	bx	lr
3418f5d4:	56028000 	.word	0x56028000

3418f5d8 <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
3418f5d8:	b480      	push	{r7}
3418f5da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
3418f5dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f5fc <LL_RCC_IC14_IsEnabled+0x24>)
3418f5de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f5e2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3418f5e6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
3418f5ea:	d101      	bne.n	3418f5f0 <LL_RCC_IC14_IsEnabled+0x18>
3418f5ec:	2301      	movs	r3, #1
3418f5ee:	e000      	b.n	3418f5f2 <LL_RCC_IC14_IsEnabled+0x1a>
3418f5f0:	2300      	movs	r3, #0
}
3418f5f2:	4618      	mov	r0, r3
3418f5f4:	46bd      	mov	sp, r7
3418f5f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f5fa:	4770      	bx	lr
3418f5fc:	56028000 	.word	0x56028000

3418f600 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
3418f600:	b480      	push	{r7}
3418f602:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
3418f604:	4b04      	ldr	r3, [pc, #16]	@ (3418f618 <LL_RCC_IC14_GetSource+0x18>)
3418f606:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418f60a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f60e:	4618      	mov	r0, r3
3418f610:	46bd      	mov	sp, r7
3418f612:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f616:	4770      	bx	lr
3418f618:	56028000 	.word	0x56028000

3418f61c <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
3418f61c:	b480      	push	{r7}
3418f61e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
3418f620:	4b05      	ldr	r3, [pc, #20]	@ (3418f638 <LL_RCC_IC14_GetDivider+0x1c>)
3418f622:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3418f626:	0c1b      	lsrs	r3, r3, #16
3418f628:	b2db      	uxtb	r3, r3
3418f62a:	3301      	adds	r3, #1
}
3418f62c:	4618      	mov	r0, r3
3418f62e:	46bd      	mov	sp, r7
3418f630:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f634:	4770      	bx	lr
3418f636:	bf00      	nop
3418f638:	56028000 	.word	0x56028000

3418f63c <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
3418f63c:	b480      	push	{r7}
3418f63e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3418f640:	4b04      	ldr	r3, [pc, #16]	@ (3418f654 <LL_RCC_IC15_Enable+0x18>)
3418f642:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
3418f646:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f64a:	bf00      	nop
3418f64c:	46bd      	mov	sp, r7
3418f64e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f652:	4770      	bx	lr
3418f654:	56028000 	.word	0x56028000

3418f658 <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
3418f658:	b480      	push	{r7}
3418f65a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3418f65c:	4b07      	ldr	r3, [pc, #28]	@ (3418f67c <LL_RCC_IC15_IsEnabled+0x24>)
3418f65e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f662:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3418f666:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3418f66a:	d101      	bne.n	3418f670 <LL_RCC_IC15_IsEnabled+0x18>
3418f66c:	2301      	movs	r3, #1
3418f66e:	e000      	b.n	3418f672 <LL_RCC_IC15_IsEnabled+0x1a>
3418f670:	2300      	movs	r3, #0
}
3418f672:	4618      	mov	r0, r3
3418f674:	46bd      	mov	sp, r7
3418f676:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f67a:	4770      	bx	lr
3418f67c:	56028000 	.word	0x56028000

3418f680 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
3418f680:	b480      	push	{r7}
3418f682:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
3418f684:	4b04      	ldr	r3, [pc, #16]	@ (3418f698 <LL_RCC_IC15_GetSource+0x18>)
3418f686:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f68a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f68e:	4618      	mov	r0, r3
3418f690:	46bd      	mov	sp, r7
3418f692:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f696:	4770      	bx	lr
3418f698:	56028000 	.word	0x56028000

3418f69c <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
3418f69c:	b480      	push	{r7}
3418f69e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
3418f6a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f6b8 <LL_RCC_IC15_GetDivider+0x1c>)
3418f6a2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418f6a6:	0c1b      	lsrs	r3, r3, #16
3418f6a8:	b2db      	uxtb	r3, r3
3418f6aa:	3301      	adds	r3, #1
}
3418f6ac:	4618      	mov	r0, r3
3418f6ae:	46bd      	mov	sp, r7
3418f6b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f6b4:	4770      	bx	lr
3418f6b6:	bf00      	nop
3418f6b8:	56028000 	.word	0x56028000

3418f6bc <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
3418f6bc:	b480      	push	{r7}
3418f6be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
3418f6c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f6d4 <LL_RCC_IC16_Enable+0x18>)
3418f6c2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3418f6c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f6ca:	bf00      	nop
3418f6cc:	46bd      	mov	sp, r7
3418f6ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f6d2:	4770      	bx	lr
3418f6d4:	56028000 	.word	0x56028000

3418f6d8 <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
3418f6d8:	b480      	push	{r7}
3418f6da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
3418f6dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f6fc <LL_RCC_IC16_IsEnabled+0x24>)
3418f6de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f6e2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3418f6e6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3418f6ea:	d101      	bne.n	3418f6f0 <LL_RCC_IC16_IsEnabled+0x18>
3418f6ec:	2301      	movs	r3, #1
3418f6ee:	e000      	b.n	3418f6f2 <LL_RCC_IC16_IsEnabled+0x1a>
3418f6f0:	2300      	movs	r3, #0
}
3418f6f2:	4618      	mov	r0, r3
3418f6f4:	46bd      	mov	sp, r7
3418f6f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f6fa:	4770      	bx	lr
3418f6fc:	56028000 	.word	0x56028000

3418f700 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
3418f700:	b480      	push	{r7}
3418f702:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
3418f704:	4b04      	ldr	r3, [pc, #16]	@ (3418f718 <LL_RCC_IC16_GetSource+0x18>)
3418f706:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418f70a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f70e:	4618      	mov	r0, r3
3418f710:	46bd      	mov	sp, r7
3418f712:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f716:	4770      	bx	lr
3418f718:	56028000 	.word	0x56028000

3418f71c <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
3418f71c:	b480      	push	{r7}
3418f71e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
3418f720:	4b05      	ldr	r3, [pc, #20]	@ (3418f738 <LL_RCC_IC16_GetDivider+0x1c>)
3418f722:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3418f726:	0c1b      	lsrs	r3, r3, #16
3418f728:	b2db      	uxtb	r3, r3
3418f72a:	3301      	adds	r3, #1
}
3418f72c:	4618      	mov	r0, r3
3418f72e:	46bd      	mov	sp, r7
3418f730:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f734:	4770      	bx	lr
3418f736:	bf00      	nop
3418f738:	56028000 	.word	0x56028000

3418f73c <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
3418f73c:	b480      	push	{r7}
3418f73e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
3418f740:	4b04      	ldr	r3, [pc, #16]	@ (3418f754 <LL_RCC_IC17_Enable+0x18>)
3418f742:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3418f746:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f74a:	bf00      	nop
3418f74c:	46bd      	mov	sp, r7
3418f74e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f752:	4770      	bx	lr
3418f754:	56028000 	.word	0x56028000

3418f758 <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
3418f758:	b480      	push	{r7}
3418f75a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3418f75c:	4b07      	ldr	r3, [pc, #28]	@ (3418f77c <LL_RCC_IC17_IsEnabled+0x24>)
3418f75e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f762:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3418f766:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3418f76a:	d101      	bne.n	3418f770 <LL_RCC_IC17_IsEnabled+0x18>
3418f76c:	2301      	movs	r3, #1
3418f76e:	e000      	b.n	3418f772 <LL_RCC_IC17_IsEnabled+0x1a>
3418f770:	2300      	movs	r3, #0
}
3418f772:	4618      	mov	r0, r3
3418f774:	46bd      	mov	sp, r7
3418f776:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f77a:	4770      	bx	lr
3418f77c:	56028000 	.word	0x56028000

3418f780 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
3418f780:	b480      	push	{r7}
3418f782:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
3418f784:	4b04      	ldr	r3, [pc, #16]	@ (3418f798 <LL_RCC_IC17_GetSource+0x18>)
3418f786:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418f78a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f78e:	4618      	mov	r0, r3
3418f790:	46bd      	mov	sp, r7
3418f792:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f796:	4770      	bx	lr
3418f798:	56028000 	.word	0x56028000

3418f79c <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
3418f79c:	b480      	push	{r7}
3418f79e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
3418f7a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f7b8 <LL_RCC_IC17_GetDivider+0x1c>)
3418f7a2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3418f7a6:	0c1b      	lsrs	r3, r3, #16
3418f7a8:	b2db      	uxtb	r3, r3
3418f7aa:	3301      	adds	r3, #1
}
3418f7ac:	4618      	mov	r0, r3
3418f7ae:	46bd      	mov	sp, r7
3418f7b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f7b4:	4770      	bx	lr
3418f7b6:	bf00      	nop
3418f7b8:	56028000 	.word	0x56028000

3418f7bc <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
3418f7bc:	b480      	push	{r7}
3418f7be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
3418f7c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f7d4 <LL_RCC_IC18_Enable+0x18>)
3418f7c2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
3418f7c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f7ca:	bf00      	nop
3418f7cc:	46bd      	mov	sp, r7
3418f7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f7d2:	4770      	bx	lr
3418f7d4:	56028000 	.word	0x56028000

3418f7d8 <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
3418f7d8:	b480      	push	{r7}
3418f7da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
3418f7dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f7fc <LL_RCC_IC18_IsEnabled+0x24>)
3418f7de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f7e2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3418f7e6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3418f7ea:	d101      	bne.n	3418f7f0 <LL_RCC_IC18_IsEnabled+0x18>
3418f7ec:	2301      	movs	r3, #1
3418f7ee:	e000      	b.n	3418f7f2 <LL_RCC_IC18_IsEnabled+0x1a>
3418f7f0:	2300      	movs	r3, #0
}
3418f7f2:	4618      	mov	r0, r3
3418f7f4:	46bd      	mov	sp, r7
3418f7f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f7fa:	4770      	bx	lr
3418f7fc:	56028000 	.word	0x56028000

3418f800 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
3418f800:	b480      	push	{r7}
3418f802:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
3418f804:	4b04      	ldr	r3, [pc, #16]	@ (3418f818 <LL_RCC_IC18_GetSource+0x18>)
3418f806:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418f80a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f80e:	4618      	mov	r0, r3
3418f810:	46bd      	mov	sp, r7
3418f812:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f816:	4770      	bx	lr
3418f818:	56028000 	.word	0x56028000

3418f81c <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
3418f81c:	b480      	push	{r7}
3418f81e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
3418f820:	4b05      	ldr	r3, [pc, #20]	@ (3418f838 <LL_RCC_IC18_GetDivider+0x1c>)
3418f822:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3418f826:	0c1b      	lsrs	r3, r3, #16
3418f828:	b2db      	uxtb	r3, r3
3418f82a:	3301      	adds	r3, #1
}
3418f82c:	4618      	mov	r0, r3
3418f82e:	46bd      	mov	sp, r7
3418f830:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f834:	4770      	bx	lr
3418f836:	bf00      	nop
3418f838:	56028000 	.word	0x56028000

3418f83c <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
3418f83c:	b480      	push	{r7}
3418f83e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
3418f840:	4b04      	ldr	r3, [pc, #16]	@ (3418f854 <LL_RCC_IC19_Enable+0x18>)
3418f842:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
3418f846:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f84a:	bf00      	nop
3418f84c:	46bd      	mov	sp, r7
3418f84e:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f852:	4770      	bx	lr
3418f854:	56028000 	.word	0x56028000

3418f858 <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
3418f858:	b480      	push	{r7}
3418f85a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3418f85c:	4b07      	ldr	r3, [pc, #28]	@ (3418f87c <LL_RCC_IC19_IsEnabled+0x24>)
3418f85e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f862:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3418f866:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3418f86a:	d101      	bne.n	3418f870 <LL_RCC_IC19_IsEnabled+0x18>
3418f86c:	2301      	movs	r3, #1
3418f86e:	e000      	b.n	3418f872 <LL_RCC_IC19_IsEnabled+0x1a>
3418f870:	2300      	movs	r3, #0
}
3418f872:	4618      	mov	r0, r3
3418f874:	46bd      	mov	sp, r7
3418f876:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f87a:	4770      	bx	lr
3418f87c:	56028000 	.word	0x56028000

3418f880 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
3418f880:	b480      	push	{r7}
3418f882:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
3418f884:	4b04      	ldr	r3, [pc, #16]	@ (3418f898 <LL_RCC_IC19_GetSource+0x18>)
3418f886:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418f88a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f88e:	4618      	mov	r0, r3
3418f890:	46bd      	mov	sp, r7
3418f892:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f896:	4770      	bx	lr
3418f898:	56028000 	.word	0x56028000

3418f89c <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
3418f89c:	b480      	push	{r7}
3418f89e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
3418f8a0:	4b05      	ldr	r3, [pc, #20]	@ (3418f8b8 <LL_RCC_IC19_GetDivider+0x1c>)
3418f8a2:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418f8a6:	0c1b      	lsrs	r3, r3, #16
3418f8a8:	b2db      	uxtb	r3, r3
3418f8aa:	3301      	adds	r3, #1
}
3418f8ac:	4618      	mov	r0, r3
3418f8ae:	46bd      	mov	sp, r7
3418f8b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f8b4:	4770      	bx	lr
3418f8b6:	bf00      	nop
3418f8b8:	56028000 	.word	0x56028000

3418f8bc <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
3418f8bc:	b480      	push	{r7}
3418f8be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3418f8c0:	4b04      	ldr	r3, [pc, #16]	@ (3418f8d4 <LL_RCC_IC20_Enable+0x18>)
3418f8c2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
3418f8c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3418f8ca:	bf00      	nop
3418f8cc:	46bd      	mov	sp, r7
3418f8ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f8d2:	4770      	bx	lr
3418f8d4:	56028000 	.word	0x56028000

3418f8d8 <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
3418f8d8:	b480      	push	{r7}
3418f8da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
3418f8dc:	4b07      	ldr	r3, [pc, #28]	@ (3418f8fc <LL_RCC_IC20_IsEnabled+0x24>)
3418f8de:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
3418f8e2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3418f8e6:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
3418f8ea:	d101      	bne.n	3418f8f0 <LL_RCC_IC20_IsEnabled+0x18>
3418f8ec:	2301      	movs	r3, #1
3418f8ee:	e000      	b.n	3418f8f2 <LL_RCC_IC20_IsEnabled+0x1a>
3418f8f0:	2300      	movs	r3, #0
}
3418f8f2:	4618      	mov	r0, r3
3418f8f4:	46bd      	mov	sp, r7
3418f8f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f8fa:	4770      	bx	lr
3418f8fc:	56028000 	.word	0x56028000

3418f900 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
3418f900:	b480      	push	{r7}
3418f902:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
3418f904:	4b04      	ldr	r3, [pc, #16]	@ (3418f918 <LL_RCC_IC20_GetSource+0x18>)
3418f906:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418f90a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3418f90e:	4618      	mov	r0, r3
3418f910:	46bd      	mov	sp, r7
3418f912:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f916:	4770      	bx	lr
3418f918:	56028000 	.word	0x56028000

3418f91c <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
3418f91c:	b480      	push	{r7}
3418f91e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
3418f920:	4b05      	ldr	r3, [pc, #20]	@ (3418f938 <LL_RCC_IC20_GetDivider+0x1c>)
3418f922:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418f926:	0c1b      	lsrs	r3, r3, #16
3418f928:	b2db      	uxtb	r3, r3
3418f92a:	3301      	adds	r3, #1
}
3418f92c:	4618      	mov	r0, r3
3418f92e:	46bd      	mov	sp, r7
3418f930:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f934:	4770      	bx	lr
3418f936:	bf00      	nop
3418f938:	56028000 	.word	0x56028000

3418f93c <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
3418f93c:	b480      	push	{r7}
3418f93e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
3418f940:	4b04      	ldr	r3, [pc, #16]	@ (3418f954 <LL_RCC_CLKP_Enable+0x18>)
3418f942:	2240      	movs	r2, #64	@ 0x40
3418f944:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
3418f948:	bf00      	nop
3418f94a:	46bd      	mov	sp, r7
3418f94c:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f950:	4770      	bx	lr
3418f952:	bf00      	nop
3418f954:	56028000 	.word	0x56028000

3418f958 <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
3418f958:	b480      	push	{r7}
3418f95a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3418f95c:	4b07      	ldr	r3, [pc, #28]	@ (3418f97c <LL_RCC_CLKP_IsEnabled+0x24>)
3418f95e:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
3418f962:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3418f966:	2b40      	cmp	r3, #64	@ 0x40
3418f968:	d101      	bne.n	3418f96e <LL_RCC_CLKP_IsEnabled+0x16>
3418f96a:	2301      	movs	r3, #1
3418f96c:	e000      	b.n	3418f970 <LL_RCC_CLKP_IsEnabled+0x18>
3418f96e:	2300      	movs	r3, #0
}
3418f970:	4618      	mov	r0, r3
3418f972:	46bd      	mov	sp, r7
3418f974:	f85d 7b04 	ldr.w	r7, [sp], #4
3418f978:	4770      	bx	lr
3418f97a:	bf00      	nop
3418f97c:	56028000 	.word	0x56028000

3418f980 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
3418f980:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3418f984:	b0f2      	sub	sp, #456	@ 0x1c8
3418f986:	af00      	add	r7, sp, #0
3418f988:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
3418f98c:	2300      	movs	r3, #0
3418f98e:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3418f992:	2300      	movs	r3, #0
3418f994:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
3418f998:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f99c:	e9d3 2300 	ldrd	r2, r3, [r3]
3418f9a0:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
3418f9a4:	2500      	movs	r5, #0
3418f9a6:	ea54 0305 	orrs.w	r3, r4, r5
3418f9aa:	d06c      	beq.n	3418fa86 <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
3418f9ac:	f7ff f91e 	bl	3418ebec <LL_RCC_GetRTCClockSource>
3418f9b0:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
3418f9b4:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
3418f9b8:	2b00      	cmp	r3, #0
3418f9ba:	d018      	beq.n	3418f9ee <HAL_RCCEx_PeriphCLKConfig+0x6e>
3418f9bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9c0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418f9c4:	f403 7240 	and.w	r2, r3, #768	@ 0x300
3418f9c8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
3418f9cc:	4293      	cmp	r3, r2
3418f9ce:	d00e      	beq.n	3418f9ee <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3418f9d0:	4bc3      	ldr	r3, [pc, #780]	@ (3418fce0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418f9d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418f9d4:	4ac2      	ldr	r2, [pc, #776]	@ (3418fce0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418f9d6:	f043 0301 	orr.w	r3, r3, #1
3418f9da:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
3418f9dc:	4bc0      	ldr	r3, [pc, #768]	@ (3418fce0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
3418f9de:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418f9e0:	f003 0301 	and.w	r3, r3, #1
3418f9e4:	2b00      	cmp	r3, #0
3418f9e6:	d102      	bne.n	3418f9ee <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
3418f9e8:	2301      	movs	r3, #1
3418f9ea:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
3418f9ee:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418f9f2:	2b00      	cmp	r3, #0
3418f9f4:	d143      	bne.n	3418fa7e <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
3418f9f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418f9fa:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418f9fe:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3418fa02:	d117      	bne.n	3418fa34 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3418fa04:	f7f6 fd84 	bl	34186510 <HAL_GetTick>
3418fa08:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
3418fa0c:	e00d      	b.n	3418fa2a <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3418fa0e:	f7f6 fd7f 	bl	34186510 <HAL_GetTick>
3418fa12:	4602      	mov	r2, r0
3418fa14:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
3418fa18:	1ad2      	subs	r2, r2, r3
3418fa1a:	f241 3388 	movw	r3, #5000	@ 0x1388
3418fa1e:	429a      	cmp	r2, r3
3418fa20:	d903      	bls.n	3418fa2a <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
3418fa22:	2303      	movs	r3, #3
3418fa24:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
3418fa28:	e004      	b.n	3418fa34 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
3418fa2a:	f7fe fcf1 	bl	3418e410 <LL_RCC_LSE_IsReady>
3418fa2e:	4603      	mov	r3, r0
3418fa30:	2b00      	cmp	r3, #0
3418fa32:	d0ec      	beq.n	3418fa0e <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
3418fa34:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418fa38:	2b00      	cmp	r3, #0
3418fa3a:	d11b      	bne.n	3418fa74 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3418fa3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa40:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418fa44:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3418fa48:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3418fa4c:	d108      	bne.n	3418fa60 <HAL_RCCEx_PeriphCLKConfig+0xe0>
3418fa4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa52:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418fa56:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3418fa5a:	4618      	mov	r0, r3
3418fa5c:	f7ff f8d4 	bl	3418ec08 <LL_RCC_SetRTC_HSEPrescaler>
3418fa60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa64:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3418fa68:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3418fa6c:	4618      	mov	r0, r3
3418fa6e:	f7ff f8a7 	bl	3418ebc0 <LL_RCC_SetRTCClockSource>
3418fa72:	e008      	b.n	3418fa86 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
3418fa74:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418fa78:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
3418fa7c:	e003      	b.n	3418fa86 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3418fa7e:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3418fa82:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
3418fa86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fa8a:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fa8e:	f002 0804 	and.w	r8, r2, #4
3418fa92:	f04f 0900 	mov.w	r9, #0
3418fa96:	ea58 0309 	orrs.w	r3, r8, r9
3418fa9a:	f000 809b 	beq.w	3418fbd4 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3418fa9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418faa2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418faa6:	2b04      	cmp	r3, #4
3418faa8:	d116      	bne.n	3418fad8 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418faaa:	4b8e      	ldr	r3, [pc, #568]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418faac:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418fab0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fab4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fab8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fabc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418fabe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fac2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418fac4:	3b01      	subs	r3, #1
3418fac6:	041b      	lsls	r3, r3, #16
3418fac8:	4313      	orrs	r3, r2
3418faca:	4a86      	ldr	r2, [pc, #536]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418facc:	430b      	orrs	r3, r1
3418face:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3418fad2:	f7ff fbb3 	bl	3418f23c <LL_RCC_IC5_Enable>
3418fad6:	e076      	b.n	3418fbc6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
3418fad8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fadc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418fae0:	2b05      	cmp	r3, #5
3418fae2:	d116      	bne.n	3418fb12 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3418fae4:	4b7f      	ldr	r3, [pc, #508]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fae6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3418faea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418faee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418faf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418faf6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3418faf8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fafc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3418fafe:	3b01      	subs	r3, #1
3418fb00:	041b      	lsls	r3, r3, #16
3418fb02:	4313      	orrs	r3, r2
3418fb04:	4a77      	ldr	r2, [pc, #476]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb06:	430b      	orrs	r3, r1
3418fb08:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3418fb0c:	f7ff fc96 	bl	3418f43c <LL_RCC_IC10_Enable>
3418fb10:	e059      	b.n	3418fbc6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
3418fb12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb16:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418fb1a:	2b06      	cmp	r3, #6
3418fb1c:	d116      	bne.n	3418fb4c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3418fb1e:	4b71      	ldr	r3, [pc, #452]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb20:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3418fb24:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fb28:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fb2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb30:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3418fb32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb36:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3418fb38:	3b01      	subs	r3, #1
3418fb3a:	041b      	lsls	r3, r3, #16
3418fb3c:	4313      	orrs	r3, r2
3418fb3e:	4a69      	ldr	r2, [pc, #420]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb40:	430b      	orrs	r3, r1
3418fb42:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3418fb46:	f7ff fd79 	bl	3418f63c <LL_RCC_IC15_Enable>
3418fb4a:	e03c      	b.n	3418fbc6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
3418fb4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb50:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418fb54:	2b03      	cmp	r3, #3
3418fb56:	d118      	bne.n	3418fb8a <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3418fb58:	4b62      	ldr	r3, [pc, #392]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb5a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3418fb5e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fb62:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fb66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb6a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3418fb6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb72:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
3418fb76:	3b01      	subs	r3, #1
3418fb78:	041b      	lsls	r3, r3, #16
3418fb7a:	4313      	orrs	r3, r2
3418fb7c:	4a59      	ldr	r2, [pc, #356]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb7e:	430b      	orrs	r3, r1
3418fb80:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3418fb84:	f7ff fe5a 	bl	3418f83c <LL_RCC_IC19_Enable>
3418fb88:	e01d      	b.n	3418fbc6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3418fb8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fb8e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418fb92:	2b07      	cmp	r3, #7
3418fb94:	d117      	bne.n	3418fbc6 <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3418fb96:	4b53      	ldr	r3, [pc, #332]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fb98:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3418fb9c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fba0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fba4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fba8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
3418fbac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbb0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3418fbb4:	3b01      	subs	r3, #1
3418fbb6:	041b      	lsls	r3, r3, #16
3418fbb8:	4313      	orrs	r3, r2
3418fbba:	4a4a      	ldr	r2, [pc, #296]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fbbc:	430b      	orrs	r3, r1
3418fbbe:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3418fbc2:	f7ff fe7b 	bl	3418f8bc <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3418fbc6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3418fbce:	4618      	mov	r0, r3
3418fbd0:	f7fe fcd2 	bl	3418e578 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
3418fbd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbd8:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fbdc:	f04f 0a00 	mov.w	sl, #0
3418fbe0:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
3418fbe4:	ea5a 030b 	orrs.w	r3, sl, fp
3418fbe8:	d04b      	beq.n	3418fc82 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3418fbea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fbee:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418fbf2:	4b3d      	ldr	r3, [pc, #244]	@ (3418fce8 <HAL_RCCEx_PeriphCLKConfig+0x368>)
3418fbf4:	429a      	cmp	r2, r3
3418fbf6:	d116      	bne.n	3418fc26 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418fbf8:	4b3a      	ldr	r3, [pc, #232]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fbfa:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418fbfe:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fc02:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fc06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc0a:	699a      	ldr	r2, [r3, #24]
3418fc0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc10:	69db      	ldr	r3, [r3, #28]
3418fc12:	3b01      	subs	r3, #1
3418fc14:	041b      	lsls	r3, r3, #16
3418fc16:	4313      	orrs	r3, r2
3418fc18:	4a32      	ldr	r2, [pc, #200]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fc1a:	430b      	orrs	r3, r1
3418fc1c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418fc20:	f7ff fa8c 	bl	3418f13c <LL_RCC_IC3_Enable>
3418fc24:	e026      	b.n	3418fc74 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
3418fc26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc2a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418fc2e:	4b2f      	ldr	r3, [pc, #188]	@ (3418fcec <HAL_RCCEx_PeriphCLKConfig+0x36c>)
3418fc30:	429a      	cmp	r2, r3
3418fc32:	d116      	bne.n	3418fc62 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418fc34:	4b2b      	ldr	r3, [pc, #172]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fc36:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418fc3a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fc3e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fc42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc46:	6a1a      	ldr	r2, [r3, #32]
3418fc48:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc4c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418fc4e:	3b01      	subs	r3, #1
3418fc50:	041b      	lsls	r3, r3, #16
3418fc52:	4313      	orrs	r3, r2
3418fc54:	4a23      	ldr	r2, [pc, #140]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fc56:	430b      	orrs	r3, r1
3418fc58:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418fc5c:	f7ff faae 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418fc60:	e008      	b.n	3418fc74 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
3418fc62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc66:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3418fc6a:	4b21      	ldr	r3, [pc, #132]	@ (3418fcf0 <HAL_RCCEx_PeriphCLKConfig+0x370>)
3418fc6c:	429a      	cmp	r2, r3
3418fc6e:	d101      	bne.n	3418fc74 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
3418fc70:	f7ff fe64 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
3418fc74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc78:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3418fc7c:	4618      	mov	r0, r3
3418fc7e:	f7fe fe0b 	bl	3418e898 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
3418fc82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fc86:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fc8a:	2100      	movs	r1, #0
3418fc8c:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
3418fc90:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3418fc94:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3418fc98:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
3418fc9c:	4603      	mov	r3, r0
3418fc9e:	460a      	mov	r2, r1
3418fca0:	4313      	orrs	r3, r2
3418fca2:	d057      	beq.n	3418fd54 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
3418fca4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fca8:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418fcac:	4b11      	ldr	r3, [pc, #68]	@ (3418fcf4 <HAL_RCCEx_PeriphCLKConfig+0x374>)
3418fcae:	429a      	cmp	r2, r3
3418fcb0:	d122      	bne.n	3418fcf8 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418fcb2:	4b0c      	ldr	r3, [pc, #48]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fcb4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418fcb8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fcbc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fcc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcc4:	699a      	ldr	r2, [r3, #24]
3418fcc6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcca:	69db      	ldr	r3, [r3, #28]
3418fccc:	3b01      	subs	r3, #1
3418fcce:	041b      	lsls	r3, r3, #16
3418fcd0:	4313      	orrs	r3, r2
3418fcd2:	4a04      	ldr	r2, [pc, #16]	@ (3418fce4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3418fcd4:	430b      	orrs	r3, r1
3418fcd6:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418fcda:	f7ff fa2f 	bl	3418f13c <LL_RCC_IC3_Enable>
3418fcde:	e032      	b.n	3418fd46 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
3418fce0:	56024800 	.word	0x56024800
3418fce4:	56028000 	.word	0x56028000
3418fce8:	03020014 	.word	0x03020014
3418fcec:	03030014 	.word	0x03030014
3418fcf0:	03010014 	.word	0x03010014
3418fcf4:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3418fcf8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fcfc:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418fd00:	4bc5      	ldr	r3, [pc, #788]	@ (34190018 <HAL_RCCEx_PeriphCLKConfig+0x698>)
3418fd02:	429a      	cmp	r2, r3
3418fd04:	d116      	bne.n	3418fd34 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418fd06:	4bc5      	ldr	r3, [pc, #788]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fd08:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418fd0c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fd10:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fd14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd18:	6a1a      	ldr	r2, [r3, #32]
3418fd1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd1e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418fd20:	3b01      	subs	r3, #1
3418fd22:	041b      	lsls	r3, r3, #16
3418fd24:	4313      	orrs	r3, r2
3418fd26:	4abd      	ldr	r2, [pc, #756]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fd28:	430b      	orrs	r3, r1
3418fd2a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418fd2e:	f7ff fa45 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418fd32:	e008      	b.n	3418fd46 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
3418fd34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd38:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3418fd3c:	4bb8      	ldr	r3, [pc, #736]	@ (34190020 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
3418fd3e:	429a      	cmp	r2, r3
3418fd40:	d101      	bne.n	3418fd46 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
3418fd42:	f7ff fdfb 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
3418fd46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd4a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3418fd4e:	4618      	mov	r0, r3
3418fd50:	f7fe fda2 	bl	3418e898 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
3418fd54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd58:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fd5c:	2100      	movs	r1, #0
3418fd5e:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
3418fd62:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3418fd66:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
3418fd6a:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
3418fd6e:	4603      	mov	r3, r0
3418fd70:	460a      	mov	r2, r1
3418fd72:	4313      	orrs	r3, r2
3418fd74:	d04b      	beq.n	3418fe0e <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
3418fd76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd7a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418fd7e:	4ba9      	ldr	r3, [pc, #676]	@ (34190024 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
3418fd80:	429a      	cmp	r2, r3
3418fd82:	d116      	bne.n	3418fdb2 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418fd84:	4ba5      	ldr	r3, [pc, #660]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fd86:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418fd8a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fd8e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fd92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd96:	699a      	ldr	r2, [r3, #24]
3418fd98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fd9c:	69db      	ldr	r3, [r3, #28]
3418fd9e:	3b01      	subs	r3, #1
3418fda0:	041b      	lsls	r3, r3, #16
3418fda2:	4313      	orrs	r3, r2
3418fda4:	4a9d      	ldr	r2, [pc, #628]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fda6:	430b      	orrs	r3, r1
3418fda8:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418fdac:	f7ff f9c6 	bl	3418f13c <LL_RCC_IC3_Enable>
3418fdb0:	e026      	b.n	3418fe00 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
3418fdb2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdb6:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418fdba:	4b9b      	ldr	r3, [pc, #620]	@ (34190028 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
3418fdbc:	429a      	cmp	r2, r3
3418fdbe:	d116      	bne.n	3418fdee <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418fdc0:	4b96      	ldr	r3, [pc, #600]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fdc2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418fdc6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fdca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fdce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdd2:	6a1a      	ldr	r2, [r3, #32]
3418fdd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdd8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418fdda:	3b01      	subs	r3, #1
3418fddc:	041b      	lsls	r3, r3, #16
3418fdde:	4313      	orrs	r3, r2
3418fde0:	4a8e      	ldr	r2, [pc, #568]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fde2:	430b      	orrs	r3, r1
3418fde4:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418fde8:	f7ff f9e8 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418fdec:	e008      	b.n	3418fe00 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
3418fdee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fdf2:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3418fdf6:	4b8d      	ldr	r3, [pc, #564]	@ (3419002c <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
3418fdf8:	429a      	cmp	r2, r3
3418fdfa:	d101      	bne.n	3418fe00 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
3418fdfc:	f7ff fd9e 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
3418fe00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe04:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3418fe08:	4618      	mov	r0, r3
3418fe0a:	f7fe fd45 	bl	3418e898 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3418fe0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe12:	e9d3 2300 	ldrd	r2, r3, [r3]
3418fe16:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3418fe1a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
3418fe1e:	2300      	movs	r3, #0
3418fe20:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
3418fe24:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
3418fe28:	4603      	mov	r3, r0
3418fe2a:	460a      	mov	r2, r1
3418fe2c:	4313      	orrs	r3, r2
3418fe2e:	d048      	beq.n	3418fec2 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
3418fe30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe34:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418fe38:	2b20      	cmp	r3, #32
3418fe3a:	d116      	bne.n	3418fe6a <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3418fe3c:	4b77      	ldr	r3, [pc, #476]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fe3e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3418fe42:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fe46:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fe4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe4e:	699a      	ldr	r2, [r3, #24]
3418fe50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe54:	69db      	ldr	r3, [r3, #28]
3418fe56:	3b01      	subs	r3, #1
3418fe58:	041b      	lsls	r3, r3, #16
3418fe5a:	4313      	orrs	r3, r2
3418fe5c:	4a6f      	ldr	r2, [pc, #444]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fe5e:	430b      	orrs	r3, r1
3418fe60:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3418fe64:	f7ff f96a 	bl	3418f13c <LL_RCC_IC3_Enable>
3418fe68:	e024      	b.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3418fe6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe6e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418fe72:	2b30      	cmp	r3, #48	@ 0x30
3418fe74:	d116      	bne.n	3418fea4 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418fe76:	4b69      	ldr	r3, [pc, #420]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fe78:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418fe7c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fe80:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fe84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe88:	6a1a      	ldr	r2, [r3, #32]
3418fe8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fe8e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418fe90:	3b01      	subs	r3, #1
3418fe92:	041b      	lsls	r3, r3, #16
3418fe94:	4313      	orrs	r3, r2
3418fe96:	4a61      	ldr	r2, [pc, #388]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fe98:	430b      	orrs	r3, r1
3418fe9a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418fe9e:	f7ff f98d 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418fea2:	e007      	b.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
3418fea4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fea8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418feac:	2b10      	cmp	r3, #16
3418feae:	d101      	bne.n	3418feb4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
3418feb0:	f7ff fd44 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
3418feb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418feb8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3418febc:	4618      	mov	r0, r3
3418febe:	f7fe fc03 	bl	3418e6c8 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
3418fec2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fec6:	e9d3 2300 	ldrd	r2, r3, [r3]
3418feca:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
3418fece:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
3418fed2:	2300      	movs	r3, #0
3418fed4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
3418fed8:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
3418fedc:	4603      	mov	r3, r0
3418fede:	460a      	mov	r2, r1
3418fee0:	4313      	orrs	r3, r2
3418fee2:	d04b      	beq.n	3418ff7c <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
3418fee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fee8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418feec:	4b50      	ldr	r3, [pc, #320]	@ (34190030 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
3418feee:	429a      	cmp	r2, r3
3418fef0:	d116      	bne.n	3418ff20 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418fef2:	4b4a      	ldr	r3, [pc, #296]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418fef4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418fef8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fefc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ff00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff04:	6a1a      	ldr	r2, [r3, #32]
3418ff06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff0a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ff0c:	3b01      	subs	r3, #1
3418ff0e:	041b      	lsls	r3, r3, #16
3418ff10:	4313      	orrs	r3, r2
3418ff12:	4a42      	ldr	r2, [pc, #264]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ff14:	430b      	orrs	r3, r1
3418ff16:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418ff1a:	f7ff f94f 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418ff1e:	e026      	b.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
3418ff20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff24:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418ff28:	4b42      	ldr	r3, [pc, #264]	@ (34190034 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
3418ff2a:	429a      	cmp	r2, r3
3418ff2c:	d116      	bne.n	3418ff5c <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418ff2e:	4b3b      	ldr	r3, [pc, #236]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ff30:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418ff34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ff38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ff3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff40:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418ff42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3418ff48:	3b01      	subs	r3, #1
3418ff4a:	041b      	lsls	r3, r3, #16
3418ff4c:	4313      	orrs	r3, r2
3418ff4e:	4a33      	ldr	r2, [pc, #204]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ff50:	430b      	orrs	r3, r1
3418ff52:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3418ff56:	f7ff f971 	bl	3418f23c <LL_RCC_IC5_Enable>
3418ff5a:	e008      	b.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
3418ff5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff60:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
3418ff64:	4b34      	ldr	r3, [pc, #208]	@ (34190038 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
3418ff66:	429a      	cmp	r2, r3
3418ff68:	d101      	bne.n	3418ff6e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
3418ff6a:	f7ff fce7 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
3418ff6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff72:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
3418ff76:	4618      	mov	r0, r3
3418ff78:	f7fe fc57 	bl	3418e82a <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
3418ff7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ff80:	e9d3 2300 	ldrd	r2, r3, [r3]
3418ff84:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3418ff88:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
3418ff8c:	2300      	movs	r3, #0
3418ff8e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
3418ff92:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3418ff96:	4603      	mov	r3, r0
3418ff98:	460a      	mov	r2, r1
3418ff9a:	4313      	orrs	r3, r2
3418ff9c:	d062      	beq.n	34190064 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
3418ff9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffa2:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418ffa6:	4b25      	ldr	r3, [pc, #148]	@ (3419003c <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
3418ffa8:	429a      	cmp	r2, r3
3418ffaa:	d116      	bne.n	3418ffda <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3418ffac:	4b1b      	ldr	r3, [pc, #108]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ffae:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3418ffb2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418ffb6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418ffba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffbe:	6a1a      	ldr	r2, [r3, #32]
3418ffc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3418ffc6:	3b01      	subs	r3, #1
3418ffc8:	041b      	lsls	r3, r3, #16
3418ffca:	4313      	orrs	r3, r2
3418ffcc:	4a13      	ldr	r2, [pc, #76]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ffce:	430b      	orrs	r3, r1
3418ffd0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3418ffd4:	f7ff f8f2 	bl	3418f1bc <LL_RCC_IC4_Enable>
3418ffd8:	e03d      	b.n	34190056 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3418ffda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418ffde:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3418ffe2:	4b17      	ldr	r3, [pc, #92]	@ (34190040 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
3418ffe4:	429a      	cmp	r2, r3
3418ffe6:	d12d      	bne.n	34190044 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3418ffe8:	4b0c      	ldr	r3, [pc, #48]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3418ffea:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3418ffee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3418fff2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3418fff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3418fffa:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3418fffc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190000:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34190002:	3b01      	subs	r3, #1
34190004:	041b      	lsls	r3, r3, #16
34190006:	4313      	orrs	r3, r2
34190008:	4a04      	ldr	r2, [pc, #16]	@ (3419001c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3419000a:	430b      	orrs	r3, r1
3419000c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34190010:	f7ff f914 	bl	3418f23c <LL_RCC_IC5_Enable>
34190014:	e01f      	b.n	34190056 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
34190016:	bf00      	nop
34190018:	03030414 	.word	0x03030414
3419001c:	56028000 	.word	0x56028000
34190020:	03010414 	.word	0x03010414
34190024:	03020814 	.word	0x03020814
34190028:	03030814 	.word	0x03030814
3419002c:	03010814 	.word	0x03010814
34190030:	0302001c 	.word	0x0302001c
34190034:	0303001c 	.word	0x0303001c
34190038:	0301001c 	.word	0x0301001c
3419003c:	0302041c 	.word	0x0302041c
34190040:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34190044:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190048:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3419004c:	4bb3      	ldr	r3, [pc, #716]	@ (3419031c <HAL_RCCEx_PeriphCLKConfig+0x99c>)
3419004e:	429a      	cmp	r2, r3
34190050:	d101      	bne.n	34190056 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
34190052:	f7ff fc73 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
34190056:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419005a:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
3419005e:	4618      	mov	r0, r3
34190060:	f7fe fbe3 	bl	3418e82a <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
34190064:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190068:	e9d3 2300 	ldrd	r2, r3, [r3]
3419006c:	f002 0301 	and.w	r3, r2, #1
34190070:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
34190074:	2300      	movs	r3, #0
34190076:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
3419007a:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
3419007e:	4603      	mov	r3, r0
34190080:	460a      	mov	r2, r1
34190082:	4313      	orrs	r3, r2
34190084:	d057      	beq.n	34190136 <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
34190086:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419008a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3419008e:	2b20      	cmp	r3, #32
34190090:	d116      	bne.n	341900c0 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34190092:	4ba3      	ldr	r3, [pc, #652]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190094:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34190098:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419009c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341900a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900a4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
341900a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900aa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
341900ac:	3b01      	subs	r3, #1
341900ae:	041b      	lsls	r3, r3, #16
341900b0:	4313      	orrs	r3, r2
341900b2:	4a9b      	ldr	r2, [pc, #620]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341900b4:	430b      	orrs	r3, r1
341900b6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
341900ba:	f7ff f8ff 	bl	3418f2bc <LL_RCC_IC7_Enable>
341900be:	e024      	b.n	3419010a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
341900c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900c4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
341900c8:	2b30      	cmp	r3, #48	@ 0x30
341900ca:	d116      	bne.n	341900fa <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341900cc:	4b94      	ldr	r3, [pc, #592]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341900ce:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341900d2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341900d6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341900da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900de:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341900e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900e4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341900e6:	3b01      	subs	r3, #1
341900e8:	041b      	lsls	r3, r3, #16
341900ea:	4313      	orrs	r3, r2
341900ec:	4a8c      	ldr	r2, [pc, #560]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341900ee:	430b      	orrs	r3, r1
341900f0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341900f4:	f7ff f922 	bl	3418f33c <LL_RCC_IC8_Enable>
341900f8:	e007      	b.n	3419010a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
341900fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341900fe:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34190102:	2b10      	cmp	r3, #16
34190104:	d101      	bne.n	3419010a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
34190106:	f7ff fc19 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3419010a:	4b85      	ldr	r3, [pc, #532]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3419010c:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34190110:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34190114:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
34190118:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419011c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
34190120:	3b01      	subs	r3, #1
34190122:	021a      	lsls	r2, r3, #8
34190124:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190128:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3419012c:	4313      	orrs	r3, r2
3419012e:	4a7c      	ldr	r2, [pc, #496]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190130:	430b      	orrs	r3, r1
34190132:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34190136:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419013a:	e9d3 2300 	ldrd	r2, r3, [r3]
3419013e:	f002 0302 	and.w	r3, r2, #2
34190142:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
34190146:	2300      	movs	r3, #0
34190148:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
3419014c:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34190150:	4603      	mov	r3, r0
34190152:	460a      	mov	r2, r1
34190154:	4313      	orrs	r3, r2
34190156:	d048      	beq.n	341901ea <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34190158:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419015c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34190160:	2b02      	cmp	r3, #2
34190162:	d116      	bne.n	34190192 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34190164:	4b6e      	ldr	r3, [pc, #440]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190166:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419016a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419016e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190172:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190176:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34190178:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419017c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3419017e:	3b01      	subs	r3, #1
34190180:	041b      	lsls	r3, r3, #16
34190182:	4313      	orrs	r3, r2
34190184:	4a66      	ldr	r2, [pc, #408]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190186:	430b      	orrs	r3, r1
34190188:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3419018c:	f7ff f896 	bl	3418f2bc <LL_RCC_IC7_Enable>
34190190:	e024      	b.n	341901dc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34190192:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190196:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3419019a:	2b03      	cmp	r3, #3
3419019c:	d116      	bne.n	341901cc <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3419019e:	4b60      	ldr	r3, [pc, #384]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341901a0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341901a4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341901a8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341901ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901b0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341901b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901b6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341901b8:	3b01      	subs	r3, #1
341901ba:	041b      	lsls	r3, r3, #16
341901bc:	4313      	orrs	r3, r2
341901be:	4a58      	ldr	r2, [pc, #352]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341901c0:	430b      	orrs	r3, r1
341901c2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341901c6:	f7ff f8b9 	bl	3418f33c <LL_RCC_IC8_Enable>
341901ca:	e007      	b.n	341901dc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
341901cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901d0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341901d4:	2b01      	cmp	r3, #1
341901d6:	d101      	bne.n	341901dc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
341901d8:	f7ff fbb0 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
341901dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901e0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
341901e4:	4618      	mov	r0, r3
341901e6:	f7fe f9b1 	bl	3418e54c <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
341901ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341901ee:	e9d3 2300 	ldrd	r2, r3, [r3]
341901f2:	f002 0308 	and.w	r3, r2, #8
341901f6:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
341901fa:	2300      	movs	r3, #0
341901fc:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34190200:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34190204:	4603      	mov	r3, r0
34190206:	460a      	mov	r2, r1
34190208:	4313      	orrs	r3, r2
3419020a:	d017      	beq.n	3419023c <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
3419020c:	4b44      	ldr	r3, [pc, #272]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3419020e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34190212:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190216:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419021a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419021e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34190222:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190226:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3419022a:	3b01      	subs	r3, #1
3419022c:	041b      	lsls	r3, r3, #16
3419022e:	4313      	orrs	r3, r2
34190230:	4a3b      	ldr	r2, [pc, #236]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190232:	430b      	orrs	r3, r1
34190234:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34190238:	f7ff fac0 	bl	3418f7bc <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3419023c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190240:	e9d3 2300 	ldrd	r2, r3, [r3]
34190244:	f002 0310 	and.w	r3, r2, #16
34190248:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
3419024c:	2300      	movs	r3, #0
3419024e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
34190252:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
34190256:	4603      	mov	r3, r0
34190258:	460a      	mov	r2, r1
3419025a:	4313      	orrs	r3, r2
3419025c:	d02f      	beq.n	341902be <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3419025e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190262:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34190266:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3419026a:	d118      	bne.n	3419029e <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3419026c:	4b2c      	ldr	r3, [pc, #176]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3419026e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34190272:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190276:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419027a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419027e:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34190282:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190286:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3419028a:	3b01      	subs	r3, #1
3419028c:	041b      	lsls	r3, r3, #16
3419028e:	4313      	orrs	r3, r2
34190290:	4a23      	ldr	r2, [pc, #140]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190292:	430b      	orrs	r3, r1
34190294:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34190298:	f7ff fa50 	bl	3418f73c <LL_RCC_IC17_Enable>
3419029c:	e008      	b.n	341902b0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3419029e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902a2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
341902a6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341902aa:	d101      	bne.n	341902b0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
341902ac:	f7ff fb46 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
341902b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902b4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
341902b8:	4618      	mov	r0, r3
341902ba:	f7fe f973 	bl	3418e5a4 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
341902be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902c2:	e9d3 2300 	ldrd	r2, r3, [r3]
341902c6:	f002 0320 	and.w	r3, r2, #32
341902ca:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
341902ce:	2300      	movs	r3, #0
341902d0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
341902d4:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
341902d8:	4603      	mov	r3, r0
341902da:	460a      	mov	r2, r1
341902dc:	4313      	orrs	r3, r2
341902de:	d031      	beq.n	34190344 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
341902e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341902e4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
341902e8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
341902ec:	d11a      	bne.n	34190324 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
341902ee:	4b0c      	ldr	r3, [pc, #48]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
341902f0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
341902f4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341902f8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341902fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190300:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34190302:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190306:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34190308:	3b01      	subs	r3, #1
3419030a:	041b      	lsls	r3, r3, #16
3419030c:	4313      	orrs	r3, r2
3419030e:	4a04      	ldr	r2, [pc, #16]	@ (34190320 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34190310:	430b      	orrs	r3, r1
34190312:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34190316:	f7ff f8d1 	bl	3418f4bc <LL_RCC_IC12_Enable>
3419031a:	e00c      	b.n	34190336 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
3419031c:	0301041c 	.word	0x0301041c
34190320:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34190324:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190328:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3419032c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34190330:	d101      	bne.n	34190336 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
34190332:	f7ff fb03 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34190336:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419033a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3419033e:	4618      	mov	r0, r3
34190340:	f7fe f946 	bl	3418e5d0 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34190344:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190348:	e9d3 2300 	ldrd	r2, r3, [r3]
3419034c:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34190350:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34190354:	2300      	movs	r3, #0
34190356:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
3419035a:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
3419035e:	4603      	mov	r3, r0
34190360:	460a      	mov	r2, r1
34190362:	4313      	orrs	r3, r2
34190364:	d006      	beq.n	34190374 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34190366:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419036a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3419036e:	4618      	mov	r0, r3
34190370:	f7fe f944 	bl	3418e5fc <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34190374:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190378:	e9d3 2300 	ldrd	r2, r3, [r3]
3419037c:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34190380:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34190384:	2300      	movs	r3, #0
34190386:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
3419038a:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
3419038e:	4603      	mov	r3, r0
34190390:	460a      	mov	r2, r1
34190392:	4313      	orrs	r3, r2
34190394:	d006      	beq.n	341903a4 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34190396:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419039a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3419039e:	4618      	mov	r0, r3
341903a0:	f7fe f950 	bl	3418e644 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
341903a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903a8:	e9d3 2300 	ldrd	r2, r3, [r3]
341903ac:	f402 7380 	and.w	r3, r2, #256	@ 0x100
341903b0:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
341903b4:	2300      	movs	r3, #0
341903b6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
341903ba:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
341903be:	4603      	mov	r3, r0
341903c0:	460a      	mov	r2, r1
341903c2:	4313      	orrs	r3, r2
341903c4:	d006      	beq.n	341903d4 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
341903c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903ca:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
341903ce:	4618      	mov	r0, r3
341903d0:	f7fe f94e 	bl	3418e670 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
341903d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903d8:	e9d3 2300 	ldrd	r2, r3, [r3]
341903dc:	f402 7300 	and.w	r3, r2, #512	@ 0x200
341903e0:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
341903e4:	2300      	movs	r3, #0
341903e6:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
341903ea:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
341903ee:	4603      	mov	r3, r0
341903f0:	460a      	mov	r2, r1
341903f2:	4313      	orrs	r3, r2
341903f4:	d038      	beq.n	34190468 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
341903f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341903fa:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
341903fe:	2b02      	cmp	r3, #2
34190400:	d116      	bne.n	34190430 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34190402:	4bbc      	ldr	r3, [pc, #752]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190404:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34190408:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419040c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190410:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190414:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34190416:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419041a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3419041c:	3b01      	subs	r3, #1
3419041e:	041b      	lsls	r3, r3, #16
34190420:	4313      	orrs	r3, r2
34190422:	4ab4      	ldr	r2, [pc, #720]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190424:	430b      	orrs	r3, r1
34190426:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
3419042a:	f7ff f887 	bl	3418f53c <LL_RCC_IC13_Enable>
3419042e:	e007      	b.n	34190440 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34190430:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190434:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34190438:	2b01      	cmp	r3, #1
3419043a:	d101      	bne.n	34190440 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
3419043c:	f7ff fa7e 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34190440:	4bac      	ldr	r3, [pc, #688]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190442:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34190446:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
3419044a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419044e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34190452:	3b01      	subs	r3, #1
34190454:	011a      	lsls	r2, r3, #4
34190456:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419045a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3419045e:	4313      	orrs	r3, r2
34190460:	4aa4      	ldr	r2, [pc, #656]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190462:	430b      	orrs	r3, r1
34190464:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34190468:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419046c:	e9d3 2300 	ldrd	r2, r3, [r3]
34190470:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34190474:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34190478:	2300      	movs	r3, #0
3419047a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3419047e:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34190482:	4603      	mov	r3, r0
34190484:	460a      	mov	r2, r1
34190486:	4313      	orrs	r3, r2
34190488:	d02d      	beq.n	341904e6 <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3419048a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419048e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190492:	2b02      	cmp	r3, #2
34190494:	d118      	bne.n	341904c8 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34190496:	4b97      	ldr	r3, [pc, #604]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190498:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3419049c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341904a0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341904a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904a8:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
341904ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904b0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
341904b4:	3b01      	subs	r3, #1
341904b6:	041b      	lsls	r3, r3, #16
341904b8:	4313      	orrs	r3, r2
341904ba:	4a8e      	ldr	r2, [pc, #568]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341904bc:	430b      	orrs	r3, r1
341904be:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
341904c2:	f7ff f9bb 	bl	3418f83c <LL_RCC_IC19_Enable>
341904c6:	e007      	b.n	341904d8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
341904c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341904d0:	2b01      	cmp	r3, #1
341904d2:	d101      	bne.n	341904d8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
341904d4:	f7ff fa32 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
341904d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904dc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341904e0:	4618      	mov	r0, r3
341904e2:	f7fe f8db 	bl	3418e69c <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
341904e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341904ea:	e9d3 2300 	ldrd	r2, r3, [r3]
341904ee:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
341904f2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
341904f6:	2300      	movs	r3, #0
341904f8:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
341904fc:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34190500:	4603      	mov	r3, r0
34190502:	460a      	mov	r2, r1
34190504:	4313      	orrs	r3, r2
34190506:	d04b      	beq.n	341905a0 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34190508:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419050c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34190510:	4b79      	ldr	r3, [pc, #484]	@ (341906f8 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34190512:	429a      	cmp	r2, r3
34190514:	d116      	bne.n	34190544 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34190516:	4b77      	ldr	r3, [pc, #476]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190518:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3419051c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190520:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190524:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190528:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3419052a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419052e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34190530:	3b01      	subs	r3, #1
34190532:	041b      	lsls	r3, r3, #16
34190534:	4313      	orrs	r3, r2
34190536:	4a6f      	ldr	r2, [pc, #444]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190538:	430b      	orrs	r3, r1
3419053a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3419053e:	f7fe ff7d 	bl	3418f43c <LL_RCC_IC10_Enable>
34190542:	e026      	b.n	34190592 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
34190544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190548:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3419054c:	4b6b      	ldr	r3, [pc, #428]	@ (341906fc <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
3419054e:	429a      	cmp	r2, r3
34190550:	d116      	bne.n	34190580 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190552:	4b68      	ldr	r3, [pc, #416]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190554:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190558:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419055c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190560:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190564:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190566:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419056a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3419056c:	3b01      	subs	r3, #1
3419056e:	041b      	lsls	r3, r3, #16
34190570:	4313      	orrs	r3, r2
34190572:	4a60      	ldr	r2, [pc, #384]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34190574:	430b      	orrs	r3, r1
34190576:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3419057a:	f7ff f85f 	bl	3418f63c <LL_RCC_IC15_Enable>
3419057e:	e008      	b.n	34190592 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34190580:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190584:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34190588:	4b5d      	ldr	r3, [pc, #372]	@ (34190700 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
3419058a:	429a      	cmp	r2, r3
3419058c:	d101      	bne.n	34190592 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
3419058e:	f7ff f9d5 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
34190592:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190596:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3419059a:	4618      	mov	r0, r3
3419059c:	f7fe f8aa 	bl	3418e6f4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
341905a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905a4:	e9d3 2300 	ldrd	r2, r3, [r3]
341905a8:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
341905ac:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
341905b0:	2300      	movs	r3, #0
341905b2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
341905b6:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
341905ba:	4603      	mov	r3, r0
341905bc:	460a      	mov	r2, r1
341905be:	4313      	orrs	r3, r2
341905c0:	d04b      	beq.n	3419065a <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
341905c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905c6:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
341905ca:	4b4e      	ldr	r3, [pc, #312]	@ (34190704 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
341905cc:	429a      	cmp	r2, r3
341905ce:	d116      	bne.n	341905fe <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341905d0:	4b48      	ldr	r3, [pc, #288]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341905d2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
341905d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341905da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341905de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905e2:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
341905e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341905e8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341905ea:	3b01      	subs	r3, #1
341905ec:	041b      	lsls	r3, r3, #16
341905ee:	4313      	orrs	r3, r2
341905f0:	4a40      	ldr	r2, [pc, #256]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341905f2:	430b      	orrs	r3, r1
341905f4:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
341905f8:	f7fe ff20 	bl	3418f43c <LL_RCC_IC10_Enable>
341905fc:	e026      	b.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
341905fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190602:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34190606:	4b40      	ldr	r3, [pc, #256]	@ (34190708 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
34190608:	429a      	cmp	r2, r3
3419060a:	d116      	bne.n	3419063a <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3419060c:	4b39      	ldr	r3, [pc, #228]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3419060e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190612:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190616:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419061a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419061e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190620:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190624:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190626:	3b01      	subs	r3, #1
34190628:	041b      	lsls	r3, r3, #16
3419062a:	4313      	orrs	r3, r2
3419062c:	4a31      	ldr	r2, [pc, #196]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3419062e:	430b      	orrs	r3, r1
34190630:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190634:	f7ff f802 	bl	3418f63c <LL_RCC_IC15_Enable>
34190638:	e008      	b.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3419063a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419063e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34190642:	4b32      	ldr	r3, [pc, #200]	@ (3419070c <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
34190644:	429a      	cmp	r2, r3
34190646:	d101      	bne.n	3419064c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34190648:	f7ff f978 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3419064c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190650:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34190654:	4618      	mov	r0, r3
34190656:	f7fe f84d 	bl	3418e6f4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3419065a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419065e:	e9d3 2300 	ldrd	r2, r3, [r3]
34190662:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34190666:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3419066a:	2300      	movs	r3, #0
3419066c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34190670:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34190674:	4603      	mov	r3, r0
34190676:	460a      	mov	r2, r1
34190678:	4313      	orrs	r3, r2
3419067a:	d05d      	beq.n	34190738 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3419067c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190680:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34190684:	4b22      	ldr	r3, [pc, #136]	@ (34190710 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34190686:	429a      	cmp	r2, r3
34190688:	d116      	bne.n	341906b8 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3419068a:	4b1a      	ldr	r3, [pc, #104]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3419068c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34190690:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190694:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190698:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419069c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3419069e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906a2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341906a4:	3b01      	subs	r3, #1
341906a6:	041b      	lsls	r3, r3, #16
341906a8:	4313      	orrs	r3, r2
341906aa:	4a12      	ldr	r2, [pc, #72]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341906ac:	430b      	orrs	r3, r1
341906ae:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
341906b2:	f7fe fec3 	bl	3418f43c <LL_RCC_IC10_Enable>
341906b6:	e038      	b.n	3419072a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
341906b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906bc:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
341906c0:	4b14      	ldr	r3, [pc, #80]	@ (34190714 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
341906c2:	429a      	cmp	r2, r3
341906c4:	d128      	bne.n	34190718 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341906c6:	4b0b      	ldr	r3, [pc, #44]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341906c8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341906cc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341906d0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341906d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906d8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341906da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341906de:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341906e0:	3b01      	subs	r3, #1
341906e2:	041b      	lsls	r3, r3, #16
341906e4:	4313      	orrs	r3, r2
341906e6:	4a03      	ldr	r2, [pc, #12]	@ (341906f4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
341906e8:	430b      	orrs	r3, r1
341906ea:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341906ee:	f7fe ffa5 	bl	3418f63c <LL_RCC_IC15_Enable>
341906f2:	e01a      	b.n	3419072a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
341906f4:	56028000 	.word	0x56028000
341906f8:	0702000c 	.word	0x0702000c
341906fc:	0703000c 	.word	0x0703000c
34190700:	0701000c 	.word	0x0701000c
34190704:	0702040c 	.word	0x0702040c
34190708:	0703040c 	.word	0x0703040c
3419070c:	0701040c 	.word	0x0701040c
34190710:	0702080c 	.word	0x0702080c
34190714:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34190718:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419071c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34190720:	4bc8      	ldr	r3, [pc, #800]	@ (34190a44 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
34190722:	429a      	cmp	r2, r3
34190724:	d101      	bne.n	3419072a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
34190726:	f7ff f909 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
3419072a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419072e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34190732:	4618      	mov	r0, r3
34190734:	f7fd ffde 	bl	3418e6f4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34190738:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419073c:	e9d3 2300 	ldrd	r2, r3, [r3]
34190740:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34190744:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34190748:	2300      	movs	r3, #0
3419074a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
3419074e:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
34190752:	4603      	mov	r3, r0
34190754:	460a      	mov	r2, r1
34190756:	4313      	orrs	r3, r2
34190758:	d04b      	beq.n	341907f2 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3419075a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419075e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34190762:	4bb9      	ldr	r3, [pc, #740]	@ (34190a48 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
34190764:	429a      	cmp	r2, r3
34190766:	d116      	bne.n	34190796 <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34190768:	4bb8      	ldr	r3, [pc, #736]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3419076a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3419076e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190772:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190776:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419077a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3419077c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190780:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34190782:	3b01      	subs	r3, #1
34190784:	041b      	lsls	r3, r3, #16
34190786:	4313      	orrs	r3, r2
34190788:	4ab0      	ldr	r2, [pc, #704]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3419078a:	430b      	orrs	r3, r1
3419078c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34190790:	f7fe fe54 	bl	3418f43c <LL_RCC_IC10_Enable>
34190794:	e026      	b.n	341907e4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34190796:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419079a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3419079e:	4bac      	ldr	r3, [pc, #688]	@ (34190a50 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
341907a0:	429a      	cmp	r2, r3
341907a2:	d116      	bne.n	341907d2 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
341907a4:	4ba9      	ldr	r3, [pc, #676]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341907a6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
341907aa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341907ae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341907b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907b6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341907b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907bc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341907be:	3b01      	subs	r3, #1
341907c0:	041b      	lsls	r3, r3, #16
341907c2:	4313      	orrs	r3, r2
341907c4:	4aa1      	ldr	r2, [pc, #644]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341907c6:	430b      	orrs	r3, r1
341907c8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341907cc:	f7fe ff36 	bl	3418f63c <LL_RCC_IC15_Enable>
341907d0:	e008      	b.n	341907e4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
341907d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907d6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
341907da:	4b9e      	ldr	r3, [pc, #632]	@ (34190a54 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
341907dc:	429a      	cmp	r2, r3
341907de:	d101      	bne.n	341907e4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
341907e0:	f7ff f8ac 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
341907e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907e8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
341907ec:	4618      	mov	r0, r3
341907ee:	f7fd ff81 	bl	3418e6f4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
341907f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341907f6:	e9d3 2300 	ldrd	r2, r3, [r3]
341907fa:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
341907fe:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
34190802:	2300      	movs	r3, #0
34190804:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34190808:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
3419080c:	4603      	mov	r3, r0
3419080e:	460a      	mov	r2, r1
34190810:	4313      	orrs	r3, r2
34190812:	d04b      	beq.n	341908ac <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34190814:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190818:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3419081c:	4b8e      	ldr	r3, [pc, #568]	@ (34190a58 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
3419081e:	429a      	cmp	r2, r3
34190820:	d116      	bne.n	34190850 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34190822:	4b8a      	ldr	r3, [pc, #552]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190824:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34190828:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419082c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190830:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190834:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34190836:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419083a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3419083c:	3b01      	subs	r3, #1
3419083e:	041b      	lsls	r3, r3, #16
34190840:	4313      	orrs	r3, r2
34190842:	4a82      	ldr	r2, [pc, #520]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190844:	430b      	orrs	r3, r1
34190846:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3419084a:	f7fe fdf7 	bl	3418f43c <LL_RCC_IC10_Enable>
3419084e:	e026      	b.n	3419089e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34190850:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190854:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34190858:	4b80      	ldr	r3, [pc, #512]	@ (34190a5c <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
3419085a:	429a      	cmp	r2, r3
3419085c:	d116      	bne.n	3419088c <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3419085e:	4b7b      	ldr	r3, [pc, #492]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190860:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190864:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190868:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419086c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190870:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190872:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190876:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190878:	3b01      	subs	r3, #1
3419087a:	041b      	lsls	r3, r3, #16
3419087c:	4313      	orrs	r3, r2
3419087e:	4a73      	ldr	r2, [pc, #460]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190880:	430b      	orrs	r3, r1
34190882:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190886:	f7fe fed9 	bl	3418f63c <LL_RCC_IC15_Enable>
3419088a:	e008      	b.n	3419089e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3419088c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190890:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34190894:	4b72      	ldr	r3, [pc, #456]	@ (34190a60 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
34190896:	429a      	cmp	r2, r3
34190898:	d101      	bne.n	3419089e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
3419089a:	f7ff f84f 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
3419089e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908a2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341908a6:	4618      	mov	r0, r3
341908a8:	f7fd ff2f 	bl	3418e70a <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
341908ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908b0:	e9d3 2300 	ldrd	r2, r3, [r3]
341908b4:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
341908b8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
341908bc:	2300      	movs	r3, #0
341908be:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
341908c2:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
341908c6:	4603      	mov	r3, r0
341908c8:	460a      	mov	r2, r1
341908ca:	4313      	orrs	r3, r2
341908cc:	d04b      	beq.n	34190966 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
341908ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908d2:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
341908d6:	4b63      	ldr	r3, [pc, #396]	@ (34190a64 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
341908d8:	429a      	cmp	r2, r3
341908da:	d116      	bne.n	3419090a <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
341908dc:	4b5b      	ldr	r3, [pc, #364]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341908de:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
341908e2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341908e6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341908ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908ee:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
341908f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341908f4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
341908f6:	3b01      	subs	r3, #1
341908f8:	041b      	lsls	r3, r3, #16
341908fa:	4313      	orrs	r3, r2
341908fc:	4a53      	ldr	r2, [pc, #332]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341908fe:	430b      	orrs	r3, r1
34190900:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34190904:	f7fe fd9a 	bl	3418f43c <LL_RCC_IC10_Enable>
34190908:	e026      	b.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3419090a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419090e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34190912:	4b55      	ldr	r3, [pc, #340]	@ (34190a68 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
34190914:	429a      	cmp	r2, r3
34190916:	d116      	bne.n	34190946 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190918:	4b4c      	ldr	r3, [pc, #304]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3419091a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419091e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190922:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190926:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419092a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3419092c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190930:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190932:	3b01      	subs	r3, #1
34190934:	041b      	lsls	r3, r3, #16
34190936:	4313      	orrs	r3, r2
34190938:	4a44      	ldr	r2, [pc, #272]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3419093a:	430b      	orrs	r3, r1
3419093c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190940:	f7fe fe7c 	bl	3418f63c <LL_RCC_IC15_Enable>
34190944:	e008      	b.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
34190946:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419094a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3419094e:	4b47      	ldr	r3, [pc, #284]	@ (34190a6c <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
34190950:	429a      	cmp	r2, r3
34190952:	d101      	bne.n	34190958 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
34190954:	f7fe fff2 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34190958:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419095c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190960:	4618      	mov	r0, r3
34190962:	f7fd fed2 	bl	3418e70a <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34190966:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419096a:	e9d3 2300 	ldrd	r2, r3, [r3]
3419096e:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
34190972:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34190976:	2300      	movs	r3, #0
34190978:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3419097c:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34190980:	4603      	mov	r3, r0
34190982:	460a      	mov	r2, r1
34190984:	4313      	orrs	r3, r2
34190986:	d02d      	beq.n	341909e4 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34190988:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419098c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34190990:	4b37      	ldr	r3, [pc, #220]	@ (34190a70 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
34190992:	429a      	cmp	r2, r3
34190994:	d116      	bne.n	341909c4 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190996:	4b2d      	ldr	r3, [pc, #180]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190998:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419099c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341909a0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341909a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909a8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
341909aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909ae:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
341909b0:	3b01      	subs	r3, #1
341909b2:	041b      	lsls	r3, r3, #16
341909b4:	4313      	orrs	r3, r2
341909b6:	4a25      	ldr	r2, [pc, #148]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
341909b8:	430b      	orrs	r3, r1
341909ba:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
341909be:	f7fe fe3d 	bl	3418f63c <LL_RCC_IC15_Enable>
341909c2:	e008      	b.n	341909d6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
341909c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909c8:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
341909cc:	4b29      	ldr	r3, [pc, #164]	@ (34190a74 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
341909ce:	429a      	cmp	r2, r3
341909d0:	d101      	bne.n	341909d6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
341909d2:	f7fe ffb3 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
341909d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909da:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
341909de:	4618      	mov	r0, r3
341909e0:	f7fd fe9e 	bl	3418e720 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
341909e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341909e8:	e9d3 2300 	ldrd	r2, r3, [r3]
341909ec:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
341909f0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
341909f4:	2300      	movs	r3, #0
341909f6:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
341909fa:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
341909fe:	4603      	mov	r3, r0
34190a00:	460a      	mov	r2, r1
34190a02:	4313      	orrs	r3, r2
34190a04:	d04a      	beq.n	34190a9c <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34190a06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a0a:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34190a0e:	4b1a      	ldr	r3, [pc, #104]	@ (34190a78 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
34190a10:	429a      	cmp	r2, r3
34190a12:	d133      	bne.n	34190a7c <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190a14:	4b0d      	ldr	r3, [pc, #52]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190a16:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190a1a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190a1e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190a22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a26:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190a28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a2c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190a2e:	3b01      	subs	r3, #1
34190a30:	041b      	lsls	r3, r3, #16
34190a32:	4313      	orrs	r3, r2
34190a34:	4a05      	ldr	r2, [pc, #20]	@ (34190a4c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34190a36:	430b      	orrs	r3, r1
34190a38:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190a3c:	f7fe fdfe 	bl	3418f63c <LL_RCC_IC15_Enable>
34190a40:	e025      	b.n	34190a8e <HAL_RCCEx_PeriphCLKConfig+0x110e>
34190a42:	bf00      	nop
34190a44:	0701080c 	.word	0x0701080c
34190a48:	07020c0c 	.word	0x07020c0c
34190a4c:	56028000 	.word	0x56028000
34190a50:	07030c0c 	.word	0x07030c0c
34190a54:	07010c0c 	.word	0x07010c0c
34190a58:	0702100c 	.word	0x0702100c
34190a5c:	0703100c 	.word	0x0703100c
34190a60:	0701100c 	.word	0x0701100c
34190a64:	0702140c 	.word	0x0702140c
34190a68:	0703140c 	.word	0x0703140c
34190a6c:	0701140c 	.word	0x0701140c
34190a70:	0702082c 	.word	0x0702082c
34190a74:	0701082c 	.word	0x0701082c
34190a78:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34190a7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a80:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34190a84:	4bca      	ldr	r3, [pc, #808]	@ (34190db0 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
34190a86:	429a      	cmp	r2, r3
34190a88:	d101      	bne.n	34190a8e <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
34190a8a:	f7fe ff57 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34190a8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190a92:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34190a96:	4618      	mov	r0, r3
34190a98:	f7fd fe42 	bl	3418e720 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34190a9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190aa0:	e9d3 2300 	ldrd	r2, r3, [r3]
34190aa4:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34190aa8:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34190aac:	2300      	movs	r3, #0
34190aae:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
34190ab2:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
34190ab6:	4603      	mov	r3, r0
34190ab8:	460a      	mov	r2, r1
34190aba:	4313      	orrs	r3, r2
34190abc:	d02d      	beq.n	34190b1a <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34190abe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ac2:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34190ac6:	4bbb      	ldr	r3, [pc, #748]	@ (34190db4 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
34190ac8:	429a      	cmp	r2, r3
34190aca:	d116      	bne.n	34190afa <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190acc:	4bba      	ldr	r3, [pc, #744]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190ace:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190ad2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190ad6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190ada:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ade:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190ae0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ae4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190ae6:	3b01      	subs	r3, #1
34190ae8:	041b      	lsls	r3, r3, #16
34190aea:	4313      	orrs	r3, r2
34190aec:	4ab2      	ldr	r2, [pc, #712]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190aee:	430b      	orrs	r3, r1
34190af0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190af4:	f7fe fda2 	bl	3418f63c <LL_RCC_IC15_Enable>
34190af8:	e008      	b.n	34190b0c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
34190afa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190afe:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34190b02:	4bae      	ldr	r3, [pc, #696]	@ (34190dbc <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34190b04:	429a      	cmp	r2, r3
34190b06:	d101      	bne.n	34190b0c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
34190b08:	f7fe ff18 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34190b0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b10:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34190b14:	4618      	mov	r0, r3
34190b16:	f7fd fe03 	bl	3418e720 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
34190b1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b1e:	e9d3 2300 	ldrd	r2, r3, [r3]
34190b22:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
34190b26:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
34190b2a:	2300      	movs	r3, #0
34190b2c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34190b30:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
34190b34:	4603      	mov	r3, r0
34190b36:	460a      	mov	r2, r1
34190b38:	4313      	orrs	r3, r2
34190b3a:	d02d      	beq.n	34190b98 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34190b3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b40:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34190b44:	4b9e      	ldr	r3, [pc, #632]	@ (34190dc0 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
34190b46:	429a      	cmp	r2, r3
34190b48:	d116      	bne.n	34190b78 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190b4a:	4b9b      	ldr	r3, [pc, #620]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190b4c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190b50:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190b54:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190b58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b5c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190b5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b62:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190b64:	3b01      	subs	r3, #1
34190b66:	041b      	lsls	r3, r3, #16
34190b68:	4313      	orrs	r3, r2
34190b6a:	4a93      	ldr	r2, [pc, #588]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190b6c:	430b      	orrs	r3, r1
34190b6e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190b72:	f7fe fd63 	bl	3418f63c <LL_RCC_IC15_Enable>
34190b76:	e008      	b.n	34190b8a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34190b78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b7c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34190b80:	4b90      	ldr	r3, [pc, #576]	@ (34190dc4 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
34190b82:	429a      	cmp	r2, r3
34190b84:	d101      	bne.n	34190b8a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
34190b86:	f7fe fed9 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
34190b8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b8e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34190b92:	4618      	mov	r0, r3
34190b94:	f7fd fdc4 	bl	3418e720 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34190b98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190b9c:	e9d3 2300 	ldrd	r2, r3, [r3]
34190ba0:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
34190ba4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
34190ba8:	2300      	movs	r3, #0
34190baa:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34190bae:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
34190bb2:	4603      	mov	r3, r0
34190bb4:	460a      	mov	r2, r1
34190bb6:	4313      	orrs	r3, r2
34190bb8:	d02d      	beq.n	34190c16 <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
34190bba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190bbe:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34190bc2:	4b81      	ldr	r3, [pc, #516]	@ (34190dc8 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
34190bc4:	429a      	cmp	r2, r3
34190bc6:	d116      	bne.n	34190bf6 <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34190bc8:	4b7b      	ldr	r3, [pc, #492]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190bca:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34190bce:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190bd2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190bd6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190bda:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34190bdc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190be0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34190be2:	3b01      	subs	r3, #1
34190be4:	041b      	lsls	r3, r3, #16
34190be6:	4313      	orrs	r3, r2
34190be8:	4a73      	ldr	r2, [pc, #460]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190bea:	430b      	orrs	r3, r1
34190bec:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34190bf0:	f7fe fd24 	bl	3418f63c <LL_RCC_IC15_Enable>
34190bf4:	e008      	b.n	34190c08 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34190bf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190bfa:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34190bfe:	4b73      	ldr	r3, [pc, #460]	@ (34190dcc <HAL_RCCEx_PeriphCLKConfig+0x144c>)
34190c00:	429a      	cmp	r2, r3
34190c02:	d101      	bne.n	34190c08 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34190c04:	f7fe fe9a 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
34190c08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c0c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34190c10:	4618      	mov	r0, r3
34190c12:	f7fd fd85 	bl	3418e720 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
34190c16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c1a:	e9d3 2300 	ldrd	r2, r3, [r3]
34190c1e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
34190c22:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
34190c26:	2300      	movs	r3, #0
34190c28:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
34190c2c:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
34190c30:	4603      	mov	r3, r0
34190c32:	460a      	mov	r2, r1
34190c34:	4313      	orrs	r3, r2
34190c36:	d04b      	beq.n	34190cd0 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34190c38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c3c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34190c40:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34190c44:	d116      	bne.n	34190c74 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34190c46:	4b5c      	ldr	r3, [pc, #368]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190c48:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34190c4c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190c50:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190c54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c58:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34190c5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c5e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34190c60:	3b01      	subs	r3, #1
34190c62:	041b      	lsls	r3, r3, #16
34190c64:	4313      	orrs	r3, r2
34190c66:	4a54      	ldr	r2, [pc, #336]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190c68:	430b      	orrs	r3, r1
34190c6a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34190c6e:	f7fe fba5 	bl	3418f3bc <LL_RCC_IC9_Enable>
34190c72:	e026      	b.n	34190cc2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
34190c74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c78:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34190c7c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34190c80:	d116      	bne.n	34190cb0 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34190c82:	4b4d      	ldr	r3, [pc, #308]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190c84:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34190c88:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190c8c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190c90:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c94:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34190c96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190c9a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34190c9c:	3b01      	subs	r3, #1
34190c9e:	041b      	lsls	r3, r3, #16
34190ca0:	4313      	orrs	r3, r2
34190ca2:	4a45      	ldr	r2, [pc, #276]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190ca4:	430b      	orrs	r3, r1
34190ca6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34190caa:	f7fe fc87 	bl	3418f5bc <LL_RCC_IC14_Enable>
34190cae:	e008      	b.n	34190cc2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34190cb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190cb4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34190cb8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34190cbc:	d101      	bne.n	34190cc2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34190cbe:	f7fe fe3d 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34190cc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190cc6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34190cca:	4618      	mov	r0, r3
34190ccc:	f7fd fd34 	bl	3418e738 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34190cd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190cd4:	e9d3 2300 	ldrd	r2, r3, [r3]
34190cd8:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
34190cdc:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34190ce0:	2300      	movs	r3, #0
34190ce2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
34190ce6:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
34190cea:	4603      	mov	r3, r0
34190cec:	460a      	mov	r2, r1
34190cee:	4313      	orrs	r3, r2
34190cf0:	d02f      	beq.n	34190d52 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34190cf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190cf6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34190cfa:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34190cfe:	d118      	bne.n	34190d32 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34190d00:	4b2d      	ldr	r3, [pc, #180]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190d02:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34190d06:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190d0a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190d0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d12:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34190d16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d1a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34190d1e:	3b01      	subs	r3, #1
34190d20:	041b      	lsls	r3, r3, #16
34190d22:	4313      	orrs	r3, r2
34190d24:	4a24      	ldr	r2, [pc, #144]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190d26:	430b      	orrs	r3, r1
34190d28:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
34190d2c:	f7fe fcc6 	bl	3418f6bc <LL_RCC_IC16_Enable>
34190d30:	e008      	b.n	34190d44 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34190d32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d36:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34190d3a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34190d3e:	d101      	bne.n	34190d44 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
34190d40:	f7fe fdfc 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
34190d44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d48:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34190d4c:	4618      	mov	r0, r3
34190d4e:	f7fd fd09 	bl	3418e764 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34190d52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d56:	e9d3 2300 	ldrd	r2, r3, [r3]
34190d5a:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
34190d5e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34190d62:	2300      	movs	r3, #0
34190d64:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34190d68:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
34190d6c:	4603      	mov	r3, r0
34190d6e:	460a      	mov	r2, r1
34190d70:	4313      	orrs	r3, r2
34190d72:	d05b      	beq.n	34190e2c <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34190d74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d78:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34190d7c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34190d80:	d126      	bne.n	34190dd0 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34190d82:	4b0d      	ldr	r3, [pc, #52]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190d84:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34190d88:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190d8c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190d90:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d94:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34190d96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190d9a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34190d9c:	3b01      	subs	r3, #1
34190d9e:	041b      	lsls	r3, r3, #16
34190da0:	4313      	orrs	r3, r2
34190da2:	4a05      	ldr	r2, [pc, #20]	@ (34190db8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34190da4:	430b      	orrs	r3, r1
34190da6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34190daa:	f7fe fa87 	bl	3418f2bc <LL_RCC_IC7_Enable>
34190dae:	e036      	b.n	34190e1e <HAL_RCCEx_PeriphCLKConfig+0x149e>
34190db0:	07010c2c 	.word	0x07010c2c
34190db4:	0702102c 	.word	0x0702102c
34190db8:	56028000 	.word	0x56028000
34190dbc:	0701102c 	.word	0x0701102c
34190dc0:	0702142c 	.word	0x0702142c
34190dc4:	0701142c 	.word	0x0701142c
34190dc8:	0702182c 	.word	0x0702182c
34190dcc:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34190dd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190dd4:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34190dd8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34190ddc:	d116      	bne.n	34190e0c <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34190dde:	4bb5      	ldr	r3, [pc, #724]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190de0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34190de4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190de8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190dec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190df0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34190df2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190df6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190df8:	3b01      	subs	r3, #1
34190dfa:	041b      	lsls	r3, r3, #16
34190dfc:	4313      	orrs	r3, r2
34190dfe:	4aad      	ldr	r2, [pc, #692]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190e00:	430b      	orrs	r3, r1
34190e02:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34190e06:	f7fe fa99 	bl	3418f33c <LL_RCC_IC8_Enable>
34190e0a:	e008      	b.n	34190e1e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34190e0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e10:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34190e14:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34190e18:	d101      	bne.n	34190e1e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
34190e1a:	f7fe fd8f 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
34190e1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e22:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34190e26:	4618      	mov	r0, r3
34190e28:	f7fd fcb2 	bl	3418e790 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34190e2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e30:	e9d3 2300 	ldrd	r2, r3, [r3]
34190e34:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34190e38:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34190e3c:	2300      	movs	r3, #0
34190e3e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34190e42:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
34190e46:	4603      	mov	r3, r0
34190e48:	460a      	mov	r2, r1
34190e4a:	4313      	orrs	r3, r2
34190e4c:	d02d      	beq.n	34190eaa <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
34190e4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e52:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34190e56:	2b20      	cmp	r3, #32
34190e58:	d118      	bne.n	34190e8c <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34190e5a:	4b96      	ldr	r3, [pc, #600]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190e5c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34190e60:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190e64:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190e68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e6c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34190e70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e74:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34190e78:	3b01      	subs	r3, #1
34190e7a:	041b      	lsls	r3, r3, #16
34190e7c:	4313      	orrs	r3, r2
34190e7e:	4a8d      	ldr	r2, [pc, #564]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190e80:	430b      	orrs	r3, r1
34190e82:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34190e86:	f7fe fd19 	bl	3418f8bc <LL_RCC_IC20_Enable>
34190e8a:	e007      	b.n	34190e9c <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34190e8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190e90:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34190e94:	2b10      	cmp	r3, #16
34190e96:	d101      	bne.n	34190e9c <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
34190e98:	f7fe fd50 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34190e9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ea0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34190ea4:	4618      	mov	r0, r3
34190ea6:	f7fd fc9f 	bl	3418e7e8 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
34190eaa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190eae:	e9d3 2300 	ldrd	r2, r3, [r3]
34190eb2:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
34190eb6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
34190eba:	2300      	movs	r3, #0
34190ebc:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34190ec0:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34190ec4:	4603      	mov	r3, r0
34190ec6:	460a      	mov	r2, r1
34190ec8:	4313      	orrs	r3, r2
34190eca:	d04b      	beq.n	34190f64 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34190ecc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ed0:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34190ed4:	4b78      	ldr	r3, [pc, #480]	@ (341910b8 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
34190ed6:	429a      	cmp	r2, r3
34190ed8:	d116      	bne.n	34190f08 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34190eda:	4b76      	ldr	r3, [pc, #472]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190edc:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34190ee0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190ee4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190ee8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190eec:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34190eee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190ef2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34190ef4:	3b01      	subs	r3, #1
34190ef6:	041b      	lsls	r3, r3, #16
34190ef8:	4313      	orrs	r3, r2
34190efa:	4a6e      	ldr	r2, [pc, #440]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190efc:	430b      	orrs	r3, r1
34190efe:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34190f02:	f7fe f9db 	bl	3418f2bc <LL_RCC_IC7_Enable>
34190f06:	e026      	b.n	34190f56 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
34190f08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f0c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34190f10:	4b6a      	ldr	r3, [pc, #424]	@ (341910bc <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34190f12:	429a      	cmp	r2, r3
34190f14:	d116      	bne.n	34190f44 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34190f16:	4b67      	ldr	r3, [pc, #412]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190f18:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34190f1c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190f20:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190f24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f28:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34190f2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f2e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190f30:	3b01      	subs	r3, #1
34190f32:	041b      	lsls	r3, r3, #16
34190f34:	4313      	orrs	r3, r2
34190f36:	4a5f      	ldr	r2, [pc, #380]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190f38:	430b      	orrs	r3, r1
34190f3a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34190f3e:	f7fe f9fd 	bl	3418f33c <LL_RCC_IC8_Enable>
34190f42:	e008      	b.n	34190f56 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34190f44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f48:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34190f4c:	4b5c      	ldr	r3, [pc, #368]	@ (341910c0 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
34190f4e:	429a      	cmp	r2, r3
34190f50:	d101      	bne.n	34190f56 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
34190f52:	f7fe fcf3 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
34190f56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f5a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34190f5e:	4618      	mov	r0, r3
34190f60:	f7fd fc58 	bl	3418e814 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34190f64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f68:	e9d3 2300 	ldrd	r2, r3, [r3]
34190f6c:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
34190f70:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
34190f74:	2300      	movs	r3, #0
34190f76:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
34190f7a:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34190f7e:	4603      	mov	r3, r0
34190f80:	460a      	mov	r2, r1
34190f82:	4313      	orrs	r3, r2
34190f84:	d04b      	beq.n	3419101e <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34190f86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190f8a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34190f8e:	4b4d      	ldr	r3, [pc, #308]	@ (341910c4 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34190f90:	429a      	cmp	r2, r3
34190f92:	d116      	bne.n	34190fc2 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34190f94:	4b47      	ldr	r3, [pc, #284]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190f96:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34190f9a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190f9e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190fa2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190fa6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34190fa8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190fac:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34190fae:	3b01      	subs	r3, #1
34190fb0:	041b      	lsls	r3, r3, #16
34190fb2:	4313      	orrs	r3, r2
34190fb4:	4a3f      	ldr	r2, [pc, #252]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190fb6:	430b      	orrs	r3, r1
34190fb8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34190fbc:	f7fe f97e 	bl	3418f2bc <LL_RCC_IC7_Enable>
34190fc0:	e026      	b.n	34191010 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34190fc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190fc6:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34190fca:	4b3f      	ldr	r3, [pc, #252]	@ (341910c8 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34190fcc:	429a      	cmp	r2, r3
34190fce:	d116      	bne.n	34190ffe <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34190fd0:	4b38      	ldr	r3, [pc, #224]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190fd2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34190fd6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34190fda:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34190fde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190fe2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34190fe4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34190fe8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34190fea:	3b01      	subs	r3, #1
34190fec:	041b      	lsls	r3, r3, #16
34190fee:	4313      	orrs	r3, r2
34190ff0:	4a30      	ldr	r2, [pc, #192]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34190ff2:	430b      	orrs	r3, r1
34190ff4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34190ff8:	f7fe f9a0 	bl	3418f33c <LL_RCC_IC8_Enable>
34190ffc:	e008      	b.n	34191010 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34190ffe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191002:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34191006:	4b31      	ldr	r3, [pc, #196]	@ (341910cc <HAL_RCCEx_PeriphCLKConfig+0x174c>)
34191008:	429a      	cmp	r2, r3
3419100a:	d101      	bne.n	34191010 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
3419100c:	f7fe fc96 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34191010:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191014:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34191018:	4618      	mov	r0, r3
3419101a:	f7fd fbfb 	bl	3418e814 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3419101e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191022:	e9d3 2300 	ldrd	r2, r3, [r3]
34191026:	2100      	movs	r1, #0
34191028:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
3419102c:	f003 0301 	and.w	r3, r3, #1
34191030:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34191034:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34191038:	4603      	mov	r3, r0
3419103a:	460a      	mov	r2, r1
3419103c:	4313      	orrs	r3, r2
3419103e:	d056      	beq.n	341910ee <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34191040:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191044:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34191048:	2b02      	cmp	r3, #2
3419104a:	d116      	bne.n	3419107a <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3419104c:	4b19      	ldr	r3, [pc, #100]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3419104e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34191052:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191056:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419105a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419105e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34191060:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191064:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34191066:	3b01      	subs	r3, #1
34191068:	041b      	lsls	r3, r3, #16
3419106a:	4313      	orrs	r3, r2
3419106c:	4a11      	ldr	r2, [pc, #68]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3419106e:	430b      	orrs	r3, r1
34191070:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34191074:	f7fe f922 	bl	3418f2bc <LL_RCC_IC7_Enable>
34191078:	e032      	b.n	341910e0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3419107a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419107e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34191082:	2b03      	cmp	r3, #3
34191084:	d124      	bne.n	341910d0 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34191086:	4b0b      	ldr	r3, [pc, #44]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34191088:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3419108c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191090:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191094:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191098:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3419109a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419109e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341910a0:	3b01      	subs	r3, #1
341910a2:	041b      	lsls	r3, r3, #16
341910a4:	4313      	orrs	r3, r2
341910a6:	4a03      	ldr	r2, [pc, #12]	@ (341910b4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
341910a8:	430b      	orrs	r3, r1
341910aa:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341910ae:	f7fe f945 	bl	3418f33c <LL_RCC_IC8_Enable>
341910b2:	e015      	b.n	341910e0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
341910b4:	56028000 	.word	0x56028000
341910b8:	07021418 	.word	0x07021418
341910bc:	07031418 	.word	0x07031418
341910c0:	07011418 	.word	0x07011418
341910c4:	07021818 	.word	0x07021818
341910c8:	07031818 	.word	0x07031818
341910cc:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
341910d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341910d4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
341910d8:	2b01      	cmp	r3, #1
341910da:	d101      	bne.n	341910e0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
341910dc:	f7fe fc2e 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
341910e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341910e4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
341910e8:	4618      	mov	r0, r3
341910ea:	f7fd fba9 	bl	3418e840 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
341910ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341910f2:	e9d3 2300 	ldrd	r2, r3, [r3]
341910f6:	2100      	movs	r1, #0
341910f8:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
341910fc:	f003 0302 	and.w	r3, r3, #2
34191100:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34191104:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34191108:	4603      	mov	r3, r0
3419110a:	460a      	mov	r2, r1
3419110c:	4313      	orrs	r3, r2
3419110e:	d04b      	beq.n	341911a8 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34191110:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191114:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34191118:	4bc6      	ldr	r3, [pc, #792]	@ (34191434 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
3419111a:	429a      	cmp	r2, r3
3419111c:	d116      	bne.n	3419114c <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3419111e:	4bc6      	ldr	r3, [pc, #792]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191120:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34191124:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191128:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419112c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191130:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34191132:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191136:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34191138:	3b01      	subs	r3, #1
3419113a:	041b      	lsls	r3, r3, #16
3419113c:	4313      	orrs	r3, r2
3419113e:	4abe      	ldr	r2, [pc, #760]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191140:	430b      	orrs	r3, r1
34191142:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34191146:	f7fe f8f9 	bl	3418f33c <LL_RCC_IC8_Enable>
3419114a:	e026      	b.n	3419119a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3419114c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191150:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34191154:	4bb9      	ldr	r3, [pc, #740]	@ (3419143c <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
34191156:	429a      	cmp	r2, r3
34191158:	d116      	bne.n	34191188 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3419115a:	4bb7      	ldr	r3, [pc, #732]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419115c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191160:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191164:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191168:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419116c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419116e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191172:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191174:	3b01      	subs	r3, #1
34191176:	041b      	lsls	r3, r3, #16
34191178:	4313      	orrs	r3, r2
3419117a:	4aaf      	ldr	r2, [pc, #700]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419117c:	430b      	orrs	r3, r1
3419117e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191182:	f7fe f91b 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191186:	e008      	b.n	3419119a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34191188:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419118c:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34191190:	4bab      	ldr	r3, [pc, #684]	@ (34191440 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34191192:	429a      	cmp	r2, r3
34191194:	d101      	bne.n	3419119a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
34191196:	f7fe fbd1 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3419119a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419119e:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
341911a2:	4618      	mov	r0, r3
341911a4:	f7fd fb62 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
341911a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341911ac:	e9d3 2300 	ldrd	r2, r3, [r3]
341911b0:	2100      	movs	r1, #0
341911b2:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
341911b6:	f003 0304 	and.w	r3, r3, #4
341911ba:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
341911be:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
341911c2:	4603      	mov	r3, r0
341911c4:	460a      	mov	r2, r1
341911c6:	4313      	orrs	r3, r2
341911c8:	d04b      	beq.n	34191262 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
341911ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341911ce:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
341911d2:	4b9c      	ldr	r3, [pc, #624]	@ (34191444 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
341911d4:	429a      	cmp	r2, r3
341911d6:	d116      	bne.n	34191206 <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341911d8:	4b97      	ldr	r3, [pc, #604]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341911da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341911de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341911e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341911e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341911ea:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341911ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341911f0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341911f2:	3b01      	subs	r3, #1
341911f4:	041b      	lsls	r3, r3, #16
341911f6:	4313      	orrs	r3, r2
341911f8:	4a8f      	ldr	r2, [pc, #572]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341911fa:	430b      	orrs	r3, r1
341911fc:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34191200:	f7fe f89c 	bl	3418f33c <LL_RCC_IC8_Enable>
34191204:	e026      	b.n	34191254 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
34191206:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419120a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3419120e:	4b8e      	ldr	r3, [pc, #568]	@ (34191448 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34191210:	429a      	cmp	r2, r3
34191212:	d116      	bne.n	34191242 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191214:	4b88      	ldr	r3, [pc, #544]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191216:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419121a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419121e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191222:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191226:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191228:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419122c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419122e:	3b01      	subs	r3, #1
34191230:	041b      	lsls	r3, r3, #16
34191232:	4313      	orrs	r3, r2
34191234:	4a80      	ldr	r2, [pc, #512]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191236:	430b      	orrs	r3, r1
34191238:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419123c:	f7fe f8be 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191240:	e008      	b.n	34191254 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
34191242:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191246:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3419124a:	4b80      	ldr	r3, [pc, #512]	@ (3419144c <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
3419124c:	429a      	cmp	r2, r3
3419124e:	d101      	bne.n	34191254 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
34191250:	f7fe fb74 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
34191254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191258:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419125c:	4618      	mov	r0, r3
3419125e:	f7fd fb05 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34191262:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191266:	e9d3 2300 	ldrd	r2, r3, [r3]
3419126a:	2100      	movs	r1, #0
3419126c:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
34191270:	f003 0308 	and.w	r3, r3, #8
34191274:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34191278:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
3419127c:	4603      	mov	r3, r0
3419127e:	460a      	mov	r2, r1
34191280:	4313      	orrs	r3, r2
34191282:	d04b      	beq.n	3419131c <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34191284:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191288:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3419128c:	4b70      	ldr	r3, [pc, #448]	@ (34191450 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
3419128e:	429a      	cmp	r2, r3
34191290:	d116      	bne.n	341912c0 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34191292:	4b69      	ldr	r3, [pc, #420]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191294:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34191298:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419129c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341912a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341912a4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
341912a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341912aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341912ac:	3b01      	subs	r3, #1
341912ae:	041b      	lsls	r3, r3, #16
341912b0:	4313      	orrs	r3, r2
341912b2:	4a61      	ldr	r2, [pc, #388]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341912b4:	430b      	orrs	r3, r1
341912b6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
341912ba:	f7fe f83f 	bl	3418f33c <LL_RCC_IC8_Enable>
341912be:	e026      	b.n	3419130e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
341912c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341912c4:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
341912c8:	4b62      	ldr	r3, [pc, #392]	@ (34191454 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
341912ca:	429a      	cmp	r2, r3
341912cc:	d116      	bne.n	341912fc <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341912ce:	4b5a      	ldr	r3, [pc, #360]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341912d0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341912d4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341912d8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341912dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341912e0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341912e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341912e6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341912e8:	3b01      	subs	r3, #1
341912ea:	041b      	lsls	r3, r3, #16
341912ec:	4313      	orrs	r3, r2
341912ee:	4a52      	ldr	r2, [pc, #328]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341912f0:	430b      	orrs	r3, r1
341912f2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341912f6:	f7fe f861 	bl	3418f3bc <LL_RCC_IC9_Enable>
341912fa:	e008      	b.n	3419130e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
341912fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191300:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34191304:	4b54      	ldr	r3, [pc, #336]	@ (34191458 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
34191306:	429a      	cmp	r2, r3
34191308:	d101      	bne.n	3419130e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
3419130a:	f7fe fb17 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
3419130e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191312:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
34191316:	4618      	mov	r0, r3
34191318:	f7fd faa8 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3419131c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191320:	e9d3 2300 	ldrd	r2, r3, [r3]
34191324:	2100      	movs	r1, #0
34191326:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3419132a:	f003 0310 	and.w	r3, r3, #16
3419132e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34191332:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
34191336:	4603      	mov	r3, r0
34191338:	460a      	mov	r2, r1
3419133a:	4313      	orrs	r3, r2
3419133c:	d04b      	beq.n	341913d6 <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3419133e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191342:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34191346:	4b45      	ldr	r3, [pc, #276]	@ (3419145c <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
34191348:	429a      	cmp	r2, r3
3419134a:	d116      	bne.n	3419137a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3419134c:	4b3a      	ldr	r3, [pc, #232]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419134e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191352:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191356:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419135a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419135e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191360:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191364:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191366:	3b01      	subs	r3, #1
34191368:	041b      	lsls	r3, r3, #16
3419136a:	4313      	orrs	r3, r2
3419136c:	4a32      	ldr	r2, [pc, #200]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419136e:	430b      	orrs	r3, r1
34191370:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191374:	f7fe f822 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191378:	e026      	b.n	341913c8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3419137a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419137e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34191382:	4b37      	ldr	r3, [pc, #220]	@ (34191460 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34191384:	429a      	cmp	r2, r3
34191386:	d116      	bne.n	341913b6 <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191388:	4b2b      	ldr	r3, [pc, #172]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3419138a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419138e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191392:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191396:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419139a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3419139c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341913a0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341913a2:	3b01      	subs	r3, #1
341913a4:	041b      	lsls	r3, r3, #16
341913a6:	4313      	orrs	r3, r2
341913a8:	4a23      	ldr	r2, [pc, #140]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
341913aa:	430b      	orrs	r3, r1
341913ac:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341913b0:	f7fe f904 	bl	3418f5bc <LL_RCC_IC14_Enable>
341913b4:	e008      	b.n	341913c8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
341913b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341913ba:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
341913be:	4b29      	ldr	r3, [pc, #164]	@ (34191464 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
341913c0:	429a      	cmp	r2, r3
341913c2:	d101      	bne.n	341913c8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
341913c4:	f7fe faba 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
341913c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341913cc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
341913d0:	4618      	mov	r0, r3
341913d2:	f7fd fa4b 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
341913d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341913da:	e9d3 2300 	ldrd	r2, r3, [r3]
341913de:	2100      	movs	r1, #0
341913e0:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
341913e4:	f003 0320 	and.w	r3, r3, #32
341913e8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
341913ec:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
341913f0:	4603      	mov	r3, r0
341913f2:	460a      	mov	r2, r1
341913f4:	4313      	orrs	r3, r2
341913f6:	d067      	beq.n	341914c8 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
341913f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341913fc:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34191400:	4b19      	ldr	r3, [pc, #100]	@ (34191468 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34191402:	429a      	cmp	r2, r3
34191404:	d132      	bne.n	3419146c <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191406:	4b0c      	ldr	r3, [pc, #48]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191408:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419140c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191410:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191414:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191418:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419141a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419141e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191420:	3b01      	subs	r3, #1
34191422:	041b      	lsls	r3, r3, #16
34191424:	4313      	orrs	r3, r2
34191426:	4a04      	ldr	r2, [pc, #16]	@ (34191438 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34191428:	430b      	orrs	r3, r1
3419142a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419142e:	f7fd ffc5 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191432:	e042      	b.n	341914ba <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34191434:	07020420 	.word	0x07020420
34191438:	56028000 	.word	0x56028000
3419143c:	07030420 	.word	0x07030420
34191440:	07010420 	.word	0x07010420
34191444:	07020820 	.word	0x07020820
34191448:	07030820 	.word	0x07030820
3419144c:	07010820 	.word	0x07010820
34191450:	07020c20 	.word	0x07020c20
34191454:	07030c20 	.word	0x07030c20
34191458:	07010c20 	.word	0x07010c20
3419145c:	07021020 	.word	0x07021020
34191460:	07031020 	.word	0x07031020
34191464:	07011020 	.word	0x07011020
34191468:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3419146c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191470:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34191474:	4bc2      	ldr	r3, [pc, #776]	@ (34191780 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
34191476:	429a      	cmp	r2, r3
34191478:	d116      	bne.n	341914a8 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3419147a:	4bc2      	ldr	r3, [pc, #776]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419147c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191480:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191484:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191488:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419148c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3419148e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191492:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191494:	3b01      	subs	r3, #1
34191496:	041b      	lsls	r3, r3, #16
34191498:	4313      	orrs	r3, r2
3419149a:	4aba      	ldr	r2, [pc, #744]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419149c:	430b      	orrs	r3, r1
3419149e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341914a2:	f7fe f88b 	bl	3418f5bc <LL_RCC_IC14_Enable>
341914a6:	e008      	b.n	341914ba <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
341914a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341914ac:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
341914b0:	4bb5      	ldr	r3, [pc, #724]	@ (34191788 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
341914b2:	429a      	cmp	r2, r3
341914b4:	d101      	bne.n	341914ba <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
341914b6:	f7fe fa41 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
341914ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341914be:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
341914c2:	4618      	mov	r0, r3
341914c4:	f7fd f9d2 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
341914c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341914cc:	e9d3 2300 	ldrd	r2, r3, [r3]
341914d0:	2100      	movs	r1, #0
341914d2:	67b9      	str	r1, [r7, #120]	@ 0x78
341914d4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341914d8:	67fb      	str	r3, [r7, #124]	@ 0x7c
341914da:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
341914de:	4603      	mov	r3, r0
341914e0:	460a      	mov	r2, r1
341914e2:	4313      	orrs	r3, r2
341914e4:	d04b      	beq.n	3419157e <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
341914e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341914ea:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
341914ee:	4ba7      	ldr	r3, [pc, #668]	@ (3419178c <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
341914f0:	429a      	cmp	r2, r3
341914f2:	d116      	bne.n	34191522 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
341914f4:	4ba3      	ldr	r3, [pc, #652]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341914f6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
341914fa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341914fe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191502:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191506:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34191508:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419150c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419150e:	3b01      	subs	r3, #1
34191510:	041b      	lsls	r3, r3, #16
34191512:	4313      	orrs	r3, r2
34191514:	4a9b      	ldr	r2, [pc, #620]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191516:	430b      	orrs	r3, r1
34191518:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3419151c:	f7fd ff0e 	bl	3418f33c <LL_RCC_IC8_Enable>
34191520:	e026      	b.n	34191570 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34191522:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191526:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3419152a:	4b99      	ldr	r3, [pc, #612]	@ (34191790 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
3419152c:	429a      	cmp	r2, r3
3419152e:	d116      	bne.n	3419155e <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191530:	4b94      	ldr	r3, [pc, #592]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191532:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191536:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419153a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419153e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191542:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191548:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419154a:	3b01      	subs	r3, #1
3419154c:	041b      	lsls	r3, r3, #16
3419154e:	4313      	orrs	r3, r2
34191550:	4a8c      	ldr	r2, [pc, #560]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191552:	430b      	orrs	r3, r1
34191554:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191558:	f7fd ff30 	bl	3418f3bc <LL_RCC_IC9_Enable>
3419155c:	e008      	b.n	34191570 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3419155e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191562:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34191566:	4b8b      	ldr	r3, [pc, #556]	@ (34191794 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
34191568:	429a      	cmp	r2, r3
3419156a:	d101      	bne.n	34191570 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
3419156c:	f7fe f9e6 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
34191570:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191574:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34191578:	4618      	mov	r0, r3
3419157a:	f7fd f977 	bl	3418e86c <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3419157e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191582:	e9d3 2300 	ldrd	r2, r3, [r3]
34191586:	2100      	movs	r1, #0
34191588:	6739      	str	r1, [r7, #112]	@ 0x70
3419158a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3419158e:	677b      	str	r3, [r7, #116]	@ 0x74
34191590:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
34191594:	4603      	mov	r3, r0
34191596:	460a      	mov	r2, r1
34191598:	4313      	orrs	r3, r2
3419159a:	d04b      	beq.n	34191634 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3419159c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915a0:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
341915a4:	4b7c      	ldr	r3, [pc, #496]	@ (34191798 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
341915a6:	429a      	cmp	r2, r3
341915a8:	d116      	bne.n	341915d8 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341915aa:	4b76      	ldr	r3, [pc, #472]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341915ac:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341915b0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341915b4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341915b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915bc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341915be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915c2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341915c4:	3b01      	subs	r3, #1
341915c6:	041b      	lsls	r3, r3, #16
341915c8:	4313      	orrs	r3, r2
341915ca:	4a6e      	ldr	r2, [pc, #440]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341915cc:	430b      	orrs	r3, r1
341915ce:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341915d2:	f7fd fef3 	bl	3418f3bc <LL_RCC_IC9_Enable>
341915d6:	e026      	b.n	34191626 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
341915d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915dc:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
341915e0:	4b6e      	ldr	r3, [pc, #440]	@ (3419179c <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
341915e2:	429a      	cmp	r2, r3
341915e4:	d116      	bne.n	34191614 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341915e6:	4b67      	ldr	r3, [pc, #412]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341915e8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341915ec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341915f0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341915f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915f8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341915fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341915fe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191600:	3b01      	subs	r3, #1
34191602:	041b      	lsls	r3, r3, #16
34191604:	4313      	orrs	r3, r2
34191606:	4a5f      	ldr	r2, [pc, #380]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191608:	430b      	orrs	r3, r1
3419160a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419160e:	f7fd ffd5 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191612:	e008      	b.n	34191626 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34191614:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191618:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3419161c:	4b60      	ldr	r3, [pc, #384]	@ (341917a0 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
3419161e:	429a      	cmp	r2, r3
34191620:	d101      	bne.n	34191626 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34191622:	f7fe f98b 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34191626:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419162a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3419162e:	4618      	mov	r0, r3
34191630:	f7fd f927 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34191634:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191638:	e9d3 2300 	ldrd	r2, r3, [r3]
3419163c:	2100      	movs	r1, #0
3419163e:	66b9      	str	r1, [r7, #104]	@ 0x68
34191640:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34191644:	66fb      	str	r3, [r7, #108]	@ 0x6c
34191646:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
3419164a:	4603      	mov	r3, r0
3419164c:	460a      	mov	r2, r1
3419164e:	4313      	orrs	r3, r2
34191650:	d04b      	beq.n	341916ea <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34191652:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191656:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3419165a:	4b52      	ldr	r3, [pc, #328]	@ (341917a4 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
3419165c:	429a      	cmp	r2, r3
3419165e:	d116      	bne.n	3419168e <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191660:	4b48      	ldr	r3, [pc, #288]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191662:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191666:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419166a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419166e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191672:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191674:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191678:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419167a:	3b01      	subs	r3, #1
3419167c:	041b      	lsls	r3, r3, #16
3419167e:	4313      	orrs	r3, r2
34191680:	4a40      	ldr	r2, [pc, #256]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191682:	430b      	orrs	r3, r1
34191684:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191688:	f7fd fe98 	bl	3418f3bc <LL_RCC_IC9_Enable>
3419168c:	e026      	b.n	341916dc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3419168e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191692:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34191696:	4b44      	ldr	r3, [pc, #272]	@ (341917a8 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
34191698:	429a      	cmp	r2, r3
3419169a:	d116      	bne.n	341916ca <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3419169c:	4b39      	ldr	r3, [pc, #228]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3419169e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341916a2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341916a6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341916aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341916ae:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341916b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341916b4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341916b6:	3b01      	subs	r3, #1
341916b8:	041b      	lsls	r3, r3, #16
341916ba:	4313      	orrs	r3, r2
341916bc:	4a31      	ldr	r2, [pc, #196]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
341916be:	430b      	orrs	r3, r1
341916c0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341916c4:	f7fd ff7a 	bl	3418f5bc <LL_RCC_IC14_Enable>
341916c8:	e008      	b.n	341916dc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
341916ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341916ce:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
341916d2:	4b36      	ldr	r3, [pc, #216]	@ (341917ac <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
341916d4:	429a      	cmp	r2, r3
341916d6:	d101      	bne.n	341916dc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
341916d8:	f7fe f930 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
341916dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341916e0:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
341916e4:	4618      	mov	r0, r3
341916e6:	f7fd f8cc 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
341916ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341916ee:	e9d3 2300 	ldrd	r2, r3, [r3]
341916f2:	2100      	movs	r1, #0
341916f4:	6639      	str	r1, [r7, #96]	@ 0x60
341916f6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
341916fa:	667b      	str	r3, [r7, #100]	@ 0x64
341916fc:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34191700:	4603      	mov	r3, r0
34191702:	460a      	mov	r2, r1
34191704:	4313      	orrs	r3, r2
34191706:	d067      	beq.n	341917d8 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34191708:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419170c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34191710:	4b27      	ldr	r3, [pc, #156]	@ (341917b0 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34191712:	429a      	cmp	r2, r3
34191714:	d116      	bne.n	34191744 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191716:	4b1b      	ldr	r3, [pc, #108]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191718:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419171c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191720:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191724:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191728:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3419172a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419172e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191730:	3b01      	subs	r3, #1
34191732:	041b      	lsls	r3, r3, #16
34191734:	4313      	orrs	r3, r2
34191736:	4a13      	ldr	r2, [pc, #76]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191738:	430b      	orrs	r3, r1
3419173a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419173e:	f7fd fe3d 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191742:	e042      	b.n	341917ca <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34191744:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191748:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3419174c:	4b19      	ldr	r3, [pc, #100]	@ (341917b4 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
3419174e:	429a      	cmp	r2, r3
34191750:	d132      	bne.n	341917b8 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191752:	4b0c      	ldr	r3, [pc, #48]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191754:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191758:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419175c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191760:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191764:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34191766:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419176a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3419176c:	3b01      	subs	r3, #1
3419176e:	041b      	lsls	r3, r3, #16
34191770:	4313      	orrs	r3, r2
34191772:	4a04      	ldr	r2, [pc, #16]	@ (34191784 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34191774:	430b      	orrs	r3, r1
34191776:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419177a:	f7fd ff1f 	bl	3418f5bc <LL_RCC_IC14_Enable>
3419177e:	e024      	b.n	341917ca <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34191780:	07031420 	.word	0x07031420
34191784:	56028000 	.word	0x56028000
34191788:	07011420 	.word	0x07011420
3419178c:	07021820 	.word	0x07021820
34191790:	07031820 	.word	0x07031820
34191794:	07011820 	.word	0x07011820
34191798:	07020030 	.word	0x07020030
3419179c:	07030030 	.word	0x07030030
341917a0:	07010030 	.word	0x07010030
341917a4:	07020430 	.word	0x07020430
341917a8:	07030430 	.word	0x07030430
341917ac:	07010430 	.word	0x07010430
341917b0:	07020830 	.word	0x07020830
341917b4:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
341917b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341917bc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
341917c0:	4bb3      	ldr	r3, [pc, #716]	@ (34191a90 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
341917c2:	429a      	cmp	r2, r3
341917c4:	d101      	bne.n	341917ca <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
341917c6:	f7fe f8b9 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
341917ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341917ce:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
341917d2:	4618      	mov	r0, r3
341917d4:	f7fd f855 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
341917d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341917dc:	e9d3 2300 	ldrd	r2, r3, [r3]
341917e0:	2100      	movs	r1, #0
341917e2:	65b9      	str	r1, [r7, #88]	@ 0x58
341917e4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
341917e8:	65fb      	str	r3, [r7, #92]	@ 0x5c
341917ea:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
341917ee:	4603      	mov	r3, r0
341917f0:	460a      	mov	r2, r1
341917f2:	4313      	orrs	r3, r2
341917f4:	d04b      	beq.n	3419188e <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
341917f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341917fa:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
341917fe:	4ba5      	ldr	r3, [pc, #660]	@ (34191a94 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
34191800:	429a      	cmp	r2, r3
34191802:	d116      	bne.n	34191832 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191804:	4ba4      	ldr	r3, [pc, #656]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191806:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3419180a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419180e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191812:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191816:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191818:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419181c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419181e:	3b01      	subs	r3, #1
34191820:	041b      	lsls	r3, r3, #16
34191822:	4313      	orrs	r3, r2
34191824:	4a9c      	ldr	r2, [pc, #624]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191826:	430b      	orrs	r3, r1
34191828:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3419182c:	f7fd fdc6 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191830:	e026      	b.n	34191880 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34191832:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191836:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3419183a:	4b98      	ldr	r3, [pc, #608]	@ (34191a9c <HAL_RCCEx_PeriphCLKConfig+0x211c>)
3419183c:	429a      	cmp	r2, r3
3419183e:	d116      	bne.n	3419186e <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191840:	4b95      	ldr	r3, [pc, #596]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191842:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191846:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419184a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419184e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191852:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34191854:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191858:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3419185a:	3b01      	subs	r3, #1
3419185c:	041b      	lsls	r3, r3, #16
3419185e:	4313      	orrs	r3, r2
34191860:	4a8d      	ldr	r2, [pc, #564]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191862:	430b      	orrs	r3, r1
34191864:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34191868:	f7fd fea8 	bl	3418f5bc <LL_RCC_IC14_Enable>
3419186c:	e008      	b.n	34191880 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3419186e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191872:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34191876:	4b8a      	ldr	r3, [pc, #552]	@ (34191aa0 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34191878:	429a      	cmp	r2, r3
3419187a:	d101      	bne.n	34191880 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
3419187c:	f7fe f85e 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34191880:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191884:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34191888:	4618      	mov	r0, r3
3419188a:	f7fc fffa 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3419188e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191892:	e9d3 2300 	ldrd	r2, r3, [r3]
34191896:	2100      	movs	r1, #0
34191898:	6539      	str	r1, [r7, #80]	@ 0x50
3419189a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3419189e:	657b      	str	r3, [r7, #84]	@ 0x54
341918a0:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
341918a4:	4603      	mov	r3, r0
341918a6:	460a      	mov	r2, r1
341918a8:	4313      	orrs	r3, r2
341918aa:	d04b      	beq.n	34191944 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
341918ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341918b0:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
341918b4:	4b7b      	ldr	r3, [pc, #492]	@ (34191aa4 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
341918b6:	429a      	cmp	r2, r3
341918b8:	d116      	bne.n	341918e8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
341918ba:	4b77      	ldr	r3, [pc, #476]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341918bc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
341918c0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341918c4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341918c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341918cc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
341918ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341918d2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341918d4:	3b01      	subs	r3, #1
341918d6:	041b      	lsls	r3, r3, #16
341918d8:	4313      	orrs	r3, r2
341918da:	4a6f      	ldr	r2, [pc, #444]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341918dc:	430b      	orrs	r3, r1
341918de:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
341918e2:	f7fd fd6b 	bl	3418f3bc <LL_RCC_IC9_Enable>
341918e6:	e026      	b.n	34191936 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
341918e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341918ec:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
341918f0:	4b6d      	ldr	r3, [pc, #436]	@ (34191aa8 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
341918f2:	429a      	cmp	r2, r3
341918f4:	d116      	bne.n	34191924 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341918f6:	4b68      	ldr	r3, [pc, #416]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341918f8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341918fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191900:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191904:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191908:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3419190a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419190e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191910:	3b01      	subs	r3, #1
34191912:	041b      	lsls	r3, r3, #16
34191914:	4313      	orrs	r3, r2
34191916:	4a60      	ldr	r2, [pc, #384]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191918:	430b      	orrs	r3, r1
3419191a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3419191e:	f7fd fe4d 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191922:	e008      	b.n	34191936 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34191924:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191928:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3419192c:	4b5f      	ldr	r3, [pc, #380]	@ (34191aac <HAL_RCCEx_PeriphCLKConfig+0x212c>)
3419192e:	429a      	cmp	r2, r3
34191930:	d101      	bne.n	34191936 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
34191932:	f7fe f803 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
34191936:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3419193a:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3419193e:	4618      	mov	r0, r3
34191940:	f7fc ff9f 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
34191944:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191948:	e9d3 2300 	ldrd	r2, r3, [r3]
3419194c:	2100      	movs	r1, #0
3419194e:	64b9      	str	r1, [r7, #72]	@ 0x48
34191950:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34191954:	64fb      	str	r3, [r7, #76]	@ 0x4c
34191956:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3419195a:	4603      	mov	r3, r0
3419195c:	460a      	mov	r2, r1
3419195e:	4313      	orrs	r3, r2
34191960:	d04b      	beq.n	341919fa <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34191962:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191966:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3419196a:	4b51      	ldr	r3, [pc, #324]	@ (34191ab0 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
3419196c:	429a      	cmp	r2, r3
3419196e:	d116      	bne.n	3419199e <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191970:	4b49      	ldr	r3, [pc, #292]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191972:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191976:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3419197a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3419197e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191982:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191984:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191988:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419198a:	3b01      	subs	r3, #1
3419198c:	041b      	lsls	r3, r3, #16
3419198e:	4313      	orrs	r3, r2
34191990:	4a41      	ldr	r2, [pc, #260]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191992:	430b      	orrs	r3, r1
34191994:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191998:	f7fd fd10 	bl	3418f3bc <LL_RCC_IC9_Enable>
3419199c:	e026      	b.n	341919ec <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3419199e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919a2:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
341919a6:	4b43      	ldr	r3, [pc, #268]	@ (34191ab4 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
341919a8:	429a      	cmp	r2, r3
341919aa:	d116      	bne.n	341919da <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
341919ac:	4b3a      	ldr	r3, [pc, #232]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341919ae:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
341919b2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
341919b6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
341919ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919be:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
341919c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919c4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
341919c6:	3b01      	subs	r3, #1
341919c8:	041b      	lsls	r3, r3, #16
341919ca:	4313      	orrs	r3, r2
341919cc:	4a32      	ldr	r2, [pc, #200]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
341919ce:	430b      	orrs	r3, r1
341919d0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
341919d4:	f7fd fdf2 	bl	3418f5bc <LL_RCC_IC14_Enable>
341919d8:	e008      	b.n	341919ec <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
341919da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919de:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
341919e2:	4b35      	ldr	r3, [pc, #212]	@ (34191ab8 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
341919e4:	429a      	cmp	r2, r3
341919e6:	d101      	bne.n	341919ec <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
341919e8:	f7fd ffa8 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
341919ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919f0:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
341919f4:	4618      	mov	r0, r3
341919f6:	f7fc ff44 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
341919fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
341919fe:	e9d3 2300 	ldrd	r2, r3, [r3]
34191a02:	2100      	movs	r1, #0
34191a04:	6439      	str	r1, [r7, #64]	@ 0x40
34191a06:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34191a0a:	647b      	str	r3, [r7, #68]	@ 0x44
34191a0c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34191a10:	4603      	mov	r3, r0
34191a12:	460a      	mov	r2, r1
34191a14:	4313      	orrs	r3, r2
34191a16:	d065      	beq.n	34191ae4 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34191a18:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a1c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34191a20:	4b26      	ldr	r3, [pc, #152]	@ (34191abc <HAL_RCCEx_PeriphCLKConfig+0x213c>)
34191a22:	429a      	cmp	r2, r3
34191a24:	d116      	bne.n	34191a54 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191a26:	4b1c      	ldr	r3, [pc, #112]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191a28:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191a2c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191a30:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191a34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a38:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191a3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a3e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191a40:	3b01      	subs	r3, #1
34191a42:	041b      	lsls	r3, r3, #16
34191a44:	4313      	orrs	r3, r2
34191a46:	4a14      	ldr	r2, [pc, #80]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191a48:	430b      	orrs	r3, r1
34191a4a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191a4e:	f7fd fcb5 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191a52:	e040      	b.n	34191ad6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34191a54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a58:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34191a5c:	4b18      	ldr	r3, [pc, #96]	@ (34191ac0 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
34191a5e:	429a      	cmp	r2, r3
34191a60:	d130      	bne.n	34191ac4 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191a62:	4b0d      	ldr	r3, [pc, #52]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191a64:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191a68:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191a6c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191a70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a74:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34191a76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191a7a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191a7c:	3b01      	subs	r3, #1
34191a7e:	041b      	lsls	r3, r3, #16
34191a80:	4313      	orrs	r3, r2
34191a82:	4a05      	ldr	r2, [pc, #20]	@ (34191a98 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34191a84:	430b      	orrs	r3, r1
34191a86:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34191a8a:	f7fd fd97 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191a8e:	e022      	b.n	34191ad6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
34191a90:	07010830 	.word	0x07010830
34191a94:	07020c30 	.word	0x07020c30
34191a98:	56028000 	.word	0x56028000
34191a9c:	07030c30 	.word	0x07030c30
34191aa0:	07010c30 	.word	0x07010c30
34191aa4:	07021030 	.word	0x07021030
34191aa8:	07031030 	.word	0x07031030
34191aac:	07011030 	.word	0x07011030
34191ab0:	07021430 	.word	0x07021430
34191ab4:	07031430 	.word	0x07031430
34191ab8:	07011430 	.word	0x07011430
34191abc:	07021830 	.word	0x07021830
34191ac0:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34191ac4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ac8:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34191acc:	4bc8      	ldr	r3, [pc, #800]	@ (34191df0 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
34191ace:	429a      	cmp	r2, r3
34191ad0:	d101      	bne.n	34191ad6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
34191ad2:	f7fd ff33 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
34191ad6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ada:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
34191ade:	4618      	mov	r0, r3
34191ae0:	f7fc fecf 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34191ae4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ae8:	e9d3 2300 	ldrd	r2, r3, [r3]
34191aec:	2100      	movs	r1, #0
34191aee:	63b9      	str	r1, [r7, #56]	@ 0x38
34191af0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34191af4:	63fb      	str	r3, [r7, #60]	@ 0x3c
34191af6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
34191afa:	4603      	mov	r3, r0
34191afc:	460a      	mov	r2, r1
34191afe:	4313      	orrs	r3, r2
34191b00:	d04b      	beq.n	34191b9a <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34191b02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b06:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34191b0a:	4bba      	ldr	r3, [pc, #744]	@ (34191df4 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
34191b0c:	429a      	cmp	r2, r3
34191b0e:	d116      	bne.n	34191b3e <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191b10:	4bb9      	ldr	r3, [pc, #740]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191b12:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191b16:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191b1a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191b1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b22:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191b24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b28:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191b2a:	3b01      	subs	r3, #1
34191b2c:	041b      	lsls	r3, r3, #16
34191b2e:	4313      	orrs	r3, r2
34191b30:	4ab1      	ldr	r2, [pc, #708]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191b32:	430b      	orrs	r3, r1
34191b34:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191b38:	f7fd fc40 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191b3c:	e026      	b.n	34191b8c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34191b3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b42:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34191b46:	4bad      	ldr	r3, [pc, #692]	@ (34191dfc <HAL_RCCEx_PeriphCLKConfig+0x247c>)
34191b48:	429a      	cmp	r2, r3
34191b4a:	d116      	bne.n	34191b7a <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191b4c:	4baa      	ldr	r3, [pc, #680]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191b4e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191b52:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191b56:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191b5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b5e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34191b60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b64:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191b66:	3b01      	subs	r3, #1
34191b68:	041b      	lsls	r3, r3, #16
34191b6a:	4313      	orrs	r3, r2
34191b6c:	4aa2      	ldr	r2, [pc, #648]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191b6e:	430b      	orrs	r3, r1
34191b70:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34191b74:	f7fd fd22 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191b78:	e008      	b.n	34191b8c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
34191b7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b7e:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34191b82:	4b9f      	ldr	r3, [pc, #636]	@ (34191e00 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34191b84:	429a      	cmp	r2, r3
34191b86:	d101      	bne.n	34191b8c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
34191b88:	f7fd fed8 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
34191b8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b90:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
34191b94:	4618      	mov	r0, r3
34191b96:	f7fc fe74 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
34191b9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191b9e:	e9d3 2300 	ldrd	r2, r3, [r3]
34191ba2:	2100      	movs	r1, #0
34191ba4:	6339      	str	r1, [r7, #48]	@ 0x30
34191ba6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34191baa:	637b      	str	r3, [r7, #52]	@ 0x34
34191bac:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34191bb0:	4603      	mov	r3, r0
34191bb2:	460a      	mov	r2, r1
34191bb4:	4313      	orrs	r3, r2
34191bb6:	d04b      	beq.n	34191c50 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
34191bb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191bbc:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34191bc0:	4a90      	ldr	r2, [pc, #576]	@ (34191e04 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
34191bc2:	4293      	cmp	r3, r2
34191bc4:	d116      	bne.n	34191bf4 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191bc6:	4b8c      	ldr	r3, [pc, #560]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191bc8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191bcc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191bd0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191bd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191bd8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34191bda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191bde:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34191be0:	3b01      	subs	r3, #1
34191be2:	041b      	lsls	r3, r3, #16
34191be4:	4313      	orrs	r3, r2
34191be6:	4a84      	ldr	r2, [pc, #528]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191be8:	430b      	orrs	r3, r1
34191bea:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191bee:	f7fd fbe5 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191bf2:	e026      	b.n	34191c42 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34191bf4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191bf8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34191bfc:	4a82      	ldr	r2, [pc, #520]	@ (34191e08 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
34191bfe:	4293      	cmp	r3, r2
34191c00:	d116      	bne.n	34191c30 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191c02:	4b7d      	ldr	r3, [pc, #500]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191c04:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191c08:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34191c0c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34191c10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c14:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34191c16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c1a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34191c1c:	3b01      	subs	r3, #1
34191c1e:	041b      	lsls	r3, r3, #16
34191c20:	4313      	orrs	r3, r2
34191c22:	4a75      	ldr	r2, [pc, #468]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191c24:	430b      	orrs	r3, r1
34191c26:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34191c2a:	f7fd fcc7 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191c2e:	e008      	b.n	34191c42 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34191c30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c34:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34191c38:	4a74      	ldr	r2, [pc, #464]	@ (34191e0c <HAL_RCCEx_PeriphCLKConfig+0x248c>)
34191c3a:	4293      	cmp	r3, r2
34191c3c:	d101      	bne.n	34191c42 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
34191c3e:	f7fd fe7d 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
34191c42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c46:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34191c4a:	4618      	mov	r0, r3
34191c4c:	f7fc fe19 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34191c50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c54:	e9d3 2300 	ldrd	r2, r3, [r3]
34191c58:	2100      	movs	r1, #0
34191c5a:	62b9      	str	r1, [r7, #40]	@ 0x28
34191c5c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34191c60:	62fb      	str	r3, [r7, #44]	@ 0x2c
34191c62:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
34191c66:	4603      	mov	r3, r0
34191c68:	460a      	mov	r2, r1
34191c6a:	4313      	orrs	r3, r2
34191c6c:	d04b      	beq.n	34191d06 <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
34191c6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191c72:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34191c76:	4a66      	ldr	r2, [pc, #408]	@ (34191e10 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
34191c78:	4293      	cmp	r3, r2
34191c7a:	d116      	bne.n	34191caa <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34191c7c:	4b5e      	ldr	r3, [pc, #376]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191c7e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34191c82:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34191c86:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34191c8a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191c8e:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34191c90:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191c94:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
34191c96:	3a01      	subs	r2, #1
34191c98:	0412      	lsls	r2, r2, #16
34191c9a:	430a      	orrs	r2, r1
34191c9c:	4956      	ldr	r1, [pc, #344]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191c9e:	4313      	orrs	r3, r2
34191ca0:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34191ca4:	f7fd fb8a 	bl	3418f3bc <LL_RCC_IC9_Enable>
34191ca8:	e026      	b.n	34191cf8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
34191caa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191cae:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34191cb2:	4a58      	ldr	r2, [pc, #352]	@ (34191e14 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
34191cb4:	4293      	cmp	r3, r2
34191cb6:	d116      	bne.n	34191ce6 <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34191cb8:	4b4f      	ldr	r3, [pc, #316]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191cba:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34191cbe:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34191cc2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34191cc6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191cca:	6f11      	ldr	r1, [r2, #112]	@ 0x70
34191ccc:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191cd0:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34191cd2:	3a01      	subs	r2, #1
34191cd4:	0412      	lsls	r2, r2, #16
34191cd6:	430a      	orrs	r2, r1
34191cd8:	4947      	ldr	r1, [pc, #284]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191cda:	4313      	orrs	r3, r2
34191cdc:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34191ce0:	f7fd fc6c 	bl	3418f5bc <LL_RCC_IC14_Enable>
34191ce4:	e008      	b.n	34191cf8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34191ce6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191cea:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34191cee:	4a4a      	ldr	r2, [pc, #296]	@ (34191e18 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
34191cf0:	4293      	cmp	r3, r2
34191cf2:	d101      	bne.n	34191cf8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34191cf4:	f7fd fe22 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34191cf8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191cfc:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34191d00:	4618      	mov	r0, r3
34191d02:	f7fc fdbe 	bl	3418e882 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34191d06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d0a:	e9d3 2300 	ldrd	r2, r3, [r3]
34191d0e:	2100      	movs	r1, #0
34191d10:	6239      	str	r1, [r7, #32]
34191d12:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34191d16:	627b      	str	r3, [r7, #36]	@ 0x24
34191d18:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34191d1c:	4603      	mov	r3, r0
34191d1e:	460a      	mov	r2, r1
34191d20:	4313      	orrs	r3, r2
34191d22:	d014      	beq.n	34191d4e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34191d24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d28:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34191d2c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34191d30:	4618      	mov	r0, r3
34191d32:	f7fc fd4e 	bl	3418e7d2 <LL_RCC_SetOTGPHYCKREFClockSource>
34191d36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d3a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34191d3e:	0fdb      	lsrs	r3, r3, #31
34191d40:	2b01      	cmp	r3, #1
34191d42:	d102      	bne.n	34191d4a <HAL_RCCEx_PeriphCLKConfig+0x23ca>
34191d44:	f7fc faf0 	bl	3418e328 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34191d48:	e001      	b.n	34191d4e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
34191d4a:	f7fc fadd 	bl	3418e308 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34191d4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d52:	e9d3 2300 	ldrd	r2, r3, [r3]
34191d56:	2100      	movs	r1, #0
34191d58:	61b9      	str	r1, [r7, #24]
34191d5a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34191d5e:	61fb      	str	r3, [r7, #28]
34191d60:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34191d64:	4603      	mov	r3, r0
34191d66:	460a      	mov	r2, r1
34191d68:	4313      	orrs	r3, r2
34191d6a:	d014      	beq.n	34191d96 <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34191d6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d70:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34191d74:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34191d78:	4618      	mov	r0, r3
34191d7a:	f7fc fd2a 	bl	3418e7d2 <LL_RCC_SetOTGPHYCKREFClockSource>
34191d7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d82:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34191d86:	0fdb      	lsrs	r3, r3, #31
34191d88:	2b01      	cmp	r3, #1
34191d8a:	d102      	bne.n	34191d92 <HAL_RCCEx_PeriphCLKConfig+0x2412>
34191d8c:	f7fc facc 	bl	3418e328 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34191d90:	e001      	b.n	34191d96 <HAL_RCCEx_PeriphCLKConfig+0x2416>
34191d92:	f7fc fab9 	bl	3418e308 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
34191d96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191d9a:	e9d3 2300 	ldrd	r2, r3, [r3]
34191d9e:	2100      	movs	r1, #0
34191da0:	6139      	str	r1, [r7, #16]
34191da2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34191da6:	617b      	str	r3, [r7, #20]
34191da8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34191dac:	4603      	mov	r3, r0
34191dae:	460a      	mov	r2, r1
34191db0:	4313      	orrs	r3, r2
34191db2:	d053      	beq.n	34191e5c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
34191db4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191db8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34191dbc:	4a17      	ldr	r2, [pc, #92]	@ (34191e1c <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34191dbe:	4293      	cmp	r3, r2
34191dc0:	d12e      	bne.n	34191e20 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34191dc2:	4b0d      	ldr	r3, [pc, #52]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191dc4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34191dc8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34191dcc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34191dd0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191dd4:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34191dd6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191dda:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34191ddc:	3a01      	subs	r2, #1
34191dde:	0412      	lsls	r2, r2, #16
34191de0:	430a      	orrs	r2, r1
34191de2:	4905      	ldr	r1, [pc, #20]	@ (34191df8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34191de4:	4313      	orrs	r3, r2
34191de6:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34191dea:	f7fd fc27 	bl	3418f63c <LL_RCC_IC15_Enable>
34191dee:	e020      	b.n	34191e32 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
34191df0:	07011830 	.word	0x07011830
34191df4:	07021c30 	.word	0x07021c30
34191df8:	56028000 	.word	0x56028000
34191dfc:	07031c30 	.word	0x07031c30
34191e00:	07011c30 	.word	0x07011c30
34191e04:	07020034 	.word	0x07020034
34191e08:	07030034 	.word	0x07030034
34191e0c:	07010034 	.word	0x07010034
34191e10:	07020434 	.word	0x07020434
34191e14:	07030434 	.word	0x07030434
34191e18:	07010434 	.word	0x07010434
34191e1c:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34191e20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191e24:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34191e28:	4a43      	ldr	r2, [pc, #268]	@ (34191f38 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
34191e2a:	4293      	cmp	r3, r2
34191e2c:	d101      	bne.n	34191e32 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
34191e2e:	f7fd fd85 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34191e32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191e36:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34191e3a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34191e3e:	4618      	mov	r0, r3
34191e40:	f7fc fcbc 	bl	3418e7bc <LL_RCC_SetOTGPHYClockSource>
34191e44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191e48:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34191e4c:	0fdb      	lsrs	r3, r3, #31
34191e4e:	2b01      	cmp	r3, #1
34191e50:	d102      	bne.n	34191e58 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
34191e52:	f7fc fa69 	bl	3418e328 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34191e56:	e001      	b.n	34191e5c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
34191e58:	f7fc fa56 	bl	3418e308 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34191e5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191e60:	e9d3 2300 	ldrd	r2, r3, [r3]
34191e64:	2100      	movs	r1, #0
34191e66:	60b9      	str	r1, [r7, #8]
34191e68:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34191e6c:	60fb      	str	r3, [r7, #12]
34191e6e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34191e72:	4603      	mov	r3, r0
34191e74:	460a      	mov	r2, r1
34191e76:	4313      	orrs	r3, r2
34191e78:	d03b      	beq.n	34191ef2 <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
34191e7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191e7e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34191e82:	4a2e      	ldr	r2, [pc, #184]	@ (34191f3c <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
34191e84:	4293      	cmp	r3, r2
34191e86:	d116      	bne.n	34191eb6 <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34191e88:	4b2d      	ldr	r3, [pc, #180]	@ (34191f40 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34191e8a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34191e8e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34191e92:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34191e96:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191e9a:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34191e9c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34191ea0:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34191ea2:	3a01      	subs	r2, #1
34191ea4:	0412      	lsls	r2, r2, #16
34191ea6:	430a      	orrs	r2, r1
34191ea8:	4925      	ldr	r1, [pc, #148]	@ (34191f40 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34191eaa:	4313      	orrs	r3, r2
34191eac:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34191eb0:	f7fd fbc4 	bl	3418f63c <LL_RCC_IC15_Enable>
34191eb4:	e008      	b.n	34191ec8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
34191eb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191eba:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34191ebe:	4a21      	ldr	r2, [pc, #132]	@ (34191f44 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
34191ec0:	4293      	cmp	r3, r2
34191ec2:	d101      	bne.n	34191ec8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
34191ec4:	f7fd fd3a 	bl	3418f93c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34191ec8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ecc:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34191ed0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34191ed4:	4618      	mov	r0, r3
34191ed6:	f7fc fc71 	bl	3418e7bc <LL_RCC_SetOTGPHYClockSource>
34191eda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ede:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34191ee2:	0fdb      	lsrs	r3, r3, #31
34191ee4:	2b01      	cmp	r3, #1
34191ee6:	d102      	bne.n	34191eee <HAL_RCCEx_PeriphCLKConfig+0x256e>
34191ee8:	f7fc fa1e 	bl	3418e328 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34191eec:	e001      	b.n	34191ef2 <HAL_RCCEx_PeriphCLKConfig+0x2572>
34191eee:	f7fc fa0b 	bl	3418e308 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34191ef2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191ef6:	e9d3 2300 	ldrd	r2, r3, [r3]
34191efa:	2100      	movs	r1, #0
34191efc:	6039      	str	r1, [r7, #0]
34191efe:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34191f02:	607b      	str	r3, [r7, #4]
34191f04:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f08:	4603      	mov	r3, r0
34191f0a:	460a      	mov	r2, r1
34191f0c:	4313      	orrs	r3, r2
34191f0e:	d006      	beq.n	34191f1e <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
34191f10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34191f14:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34191f18:	4618      	mov	r0, r3
34191f1a:	f7fc fe8b 	bl	3418ec34 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
34191f1e:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
34191f22:	2b00      	cmp	r3, #0
34191f24:	d101      	bne.n	34191f2a <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
34191f26:	2300      	movs	r3, #0
34191f28:	e000      	b.n	34191f2c <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
34191f2a:	2301      	movs	r3, #1
}
34191f2c:	4618      	mov	r0, r3
34191f2e:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
34191f32:	46bd      	mov	sp, r7
34191f34:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34191f38:	03010c14 	.word	0x03010c14
34191f3c:	03021414 	.word	0x03021414
34191f40:	56028000 	.word	0x56028000
34191f44:	03011414 	.word	0x03011414

34191f48 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
34191f48:	b590      	push	{r4, r7, lr}
34191f4a:	b085      	sub	sp, #20
34191f4c:	af00      	add	r7, sp, #0
34191f4e:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
34191f52:	2100      	movs	r1, #0
34191f54:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
34191f56:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f5a:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
34191f5e:	ea50 0104 	orrs.w	r1, r0, r4
34191f62:	f000 8436 	beq.w	341927d2 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
34191f66:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f6a:	2801      	cmp	r0, #1
34191f6c:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
34191f70:	f080 8434 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191f74:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f78:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
34191f7c:	ea50 0104 	orrs.w	r1, r0, r4
34191f80:	f000 8422 	beq.w	341927c8 <HAL_RCCEx_GetPeriphCLKFreq+0x880>
34191f84:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f88:	2801      	cmp	r0, #1
34191f8a:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
34191f8e:	f080 8425 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191f92:	e9d7 0100 	ldrd	r0, r1, [r7]
34191f96:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
34191f9a:	ea50 0104 	orrs.w	r1, r0, r4
34191f9e:	f000 840e 	beq.w	341927be <HAL_RCCEx_GetPeriphCLKFreq+0x876>
34191fa2:	e9d7 0100 	ldrd	r0, r1, [r7]
34191fa6:	2801      	cmp	r0, #1
34191fa8:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34191fac:	f080 8416 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191fb0:	e9d7 0100 	ldrd	r0, r1, [r7]
34191fb4:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
34191fb8:	ea50 0104 	orrs.w	r1, r0, r4
34191fbc:	f000 83fa 	beq.w	341927b4 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
34191fc0:	e9d7 0100 	ldrd	r0, r1, [r7]
34191fc4:	2801      	cmp	r0, #1
34191fc6:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
34191fca:	f080 8407 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191fce:	e9d7 0100 	ldrd	r0, r1, [r7]
34191fd2:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
34191fd6:	ea50 0104 	orrs.w	r1, r0, r4
34191fda:	f000 83e6 	beq.w	341927aa <HAL_RCCEx_GetPeriphCLKFreq+0x862>
34191fde:	e9d7 0100 	ldrd	r0, r1, [r7]
34191fe2:	2801      	cmp	r0, #1
34191fe4:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
34191fe8:	f080 83f8 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34191fec:	e9d7 0100 	ldrd	r0, r1, [r7]
34191ff0:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
34191ff4:	ea50 0104 	orrs.w	r1, r0, r4
34191ff8:	f000 83d2 	beq.w	341927a0 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
34191ffc:	e9d7 0100 	ldrd	r0, r1, [r7]
34192000:	2801      	cmp	r0, #1
34192002:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
34192006:	f080 83e9 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419200a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419200e:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
34192012:	ea50 0104 	orrs.w	r1, r0, r4
34192016:	f000 83be 	beq.w	34192796 <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
3419201a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419201e:	2801      	cmp	r0, #1
34192020:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
34192024:	f080 83da 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192028:	e9d7 0100 	ldrd	r0, r1, [r7]
3419202c:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
34192030:	ea50 0104 	orrs.w	r1, r0, r4
34192034:	f000 83aa 	beq.w	3419278c <HAL_RCCEx_GetPeriphCLKFreq+0x844>
34192038:	e9d7 0100 	ldrd	r0, r1, [r7]
3419203c:	2801      	cmp	r0, #1
3419203e:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
34192042:	f080 83cb 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192046:	e9d7 0100 	ldrd	r0, r1, [r7]
3419204a:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
3419204e:	ea50 0104 	orrs.w	r1, r0, r4
34192052:	f000 8396 	beq.w	34192782 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
34192056:	e9d7 0100 	ldrd	r0, r1, [r7]
3419205a:	2801      	cmp	r0, #1
3419205c:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
34192060:	f080 83bc 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192064:	e9d7 0100 	ldrd	r0, r1, [r7]
34192068:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
3419206c:	ea50 0104 	orrs.w	r1, r0, r4
34192070:	f000 8382 	beq.w	34192778 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
34192074:	e9d7 0100 	ldrd	r0, r1, [r7]
34192078:	2801      	cmp	r0, #1
3419207a:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
3419207e:	f080 83ad 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192082:	e9d7 0100 	ldrd	r0, r1, [r7]
34192086:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
3419208a:	ea50 0104 	orrs.w	r1, r0, r4
3419208e:	f000 836e 	beq.w	3419276e <HAL_RCCEx_GetPeriphCLKFreq+0x826>
34192092:	e9d7 0100 	ldrd	r0, r1, [r7]
34192096:	2801      	cmp	r0, #1
34192098:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
3419209c:	f080 839e 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341920a0:	e9d7 0100 	ldrd	r0, r1, [r7]
341920a4:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
341920a8:	ea50 0104 	orrs.w	r1, r0, r4
341920ac:	f000 835a 	beq.w	34192764 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
341920b0:	e9d7 0100 	ldrd	r0, r1, [r7]
341920b4:	2801      	cmp	r0, #1
341920b6:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
341920ba:	f080 838f 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341920be:	e9d7 0100 	ldrd	r0, r1, [r7]
341920c2:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
341920c6:	ea50 0104 	orrs.w	r1, r0, r4
341920ca:	f000 8346 	beq.w	3419275a <HAL_RCCEx_GetPeriphCLKFreq+0x812>
341920ce:	e9d7 0100 	ldrd	r0, r1, [r7]
341920d2:	2801      	cmp	r0, #1
341920d4:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
341920d8:	f080 8380 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341920dc:	e9d7 0100 	ldrd	r0, r1, [r7]
341920e0:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
341920e4:	ea50 0104 	orrs.w	r1, r0, r4
341920e8:	f000 8332 	beq.w	34192750 <HAL_RCCEx_GetPeriphCLKFreq+0x808>
341920ec:	e9d7 0100 	ldrd	r0, r1, [r7]
341920f0:	2801      	cmp	r0, #1
341920f2:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
341920f6:	f080 8371 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341920fa:	e9d7 0100 	ldrd	r0, r1, [r7]
341920fe:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
34192102:	ea50 0104 	orrs.w	r1, r0, r4
34192106:	f000 831e 	beq.w	34192746 <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
3419210a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419210e:	2801      	cmp	r0, #1
34192110:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
34192114:	f080 8362 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192118:	e9d7 0100 	ldrd	r0, r1, [r7]
3419211c:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
34192120:	ea50 0104 	orrs.w	r1, r0, r4
34192124:	f000 830a 	beq.w	3419273c <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
34192128:	e9d7 0100 	ldrd	r0, r1, [r7]
3419212c:	2801      	cmp	r0, #1
3419212e:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
34192132:	f080 8353 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192136:	e9d7 0100 	ldrd	r0, r1, [r7]
3419213a:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
3419213e:	ea50 0104 	orrs.w	r1, r0, r4
34192142:	f000 82f6 	beq.w	34192732 <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
34192146:	e9d7 0100 	ldrd	r0, r1, [r7]
3419214a:	2801      	cmp	r0, #1
3419214c:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
34192150:	f080 8344 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192154:	e9d7 0100 	ldrd	r0, r1, [r7]
34192158:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
3419215c:	ea50 0104 	orrs.w	r1, r0, r4
34192160:	f000 82e2 	beq.w	34192728 <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
34192164:	e9d7 0100 	ldrd	r0, r1, [r7]
34192168:	2801      	cmp	r0, #1
3419216a:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
3419216e:	f080 8335 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192172:	e9d7 0100 	ldrd	r0, r1, [r7]
34192176:	f1a1 0420 	sub.w	r4, r1, #32
3419217a:	ea50 0104 	orrs.w	r1, r0, r4
3419217e:	f000 82ce 	beq.w	3419271e <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
34192182:	e9d7 0100 	ldrd	r0, r1, [r7]
34192186:	2801      	cmp	r0, #1
34192188:	f171 0120 	sbcs.w	r1, r1, #32
3419218c:	f080 8326 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192190:	e9d7 0100 	ldrd	r0, r1, [r7]
34192194:	f1a1 0410 	sub.w	r4, r1, #16
34192198:	ea50 0104 	orrs.w	r1, r0, r4
3419219c:	f000 82ba 	beq.w	34192714 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
341921a0:	e9d7 0100 	ldrd	r0, r1, [r7]
341921a4:	2801      	cmp	r0, #1
341921a6:	f171 0110 	sbcs.w	r1, r1, #16
341921aa:	f080 8317 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341921ae:	e9d7 0100 	ldrd	r0, r1, [r7]
341921b2:	f1a1 0408 	sub.w	r4, r1, #8
341921b6:	ea50 0104 	orrs.w	r1, r0, r4
341921ba:	f000 82a6 	beq.w	3419270a <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
341921be:	e9d7 0100 	ldrd	r0, r1, [r7]
341921c2:	2801      	cmp	r0, #1
341921c4:	f171 0108 	sbcs.w	r1, r1, #8
341921c8:	f080 8308 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341921cc:	e9d7 0100 	ldrd	r0, r1, [r7]
341921d0:	1f0c      	subs	r4, r1, #4
341921d2:	ea50 0104 	orrs.w	r1, r0, r4
341921d6:	f000 8293 	beq.w	34192700 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
341921da:	e9d7 0100 	ldrd	r0, r1, [r7]
341921de:	2801      	cmp	r0, #1
341921e0:	f171 0104 	sbcs.w	r1, r1, #4
341921e4:	f080 82fa 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341921e8:	e9d7 0100 	ldrd	r0, r1, [r7]
341921ec:	1e8c      	subs	r4, r1, #2
341921ee:	ea50 0104 	orrs.w	r1, r0, r4
341921f2:	f000 8280 	beq.w	341926f6 <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
341921f6:	e9d7 0100 	ldrd	r0, r1, [r7]
341921fa:	2801      	cmp	r0, #1
341921fc:	f171 0102 	sbcs.w	r1, r1, #2
34192200:	f080 82ec 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192204:	e9d7 0100 	ldrd	r0, r1, [r7]
34192208:	1e4c      	subs	r4, r1, #1
3419220a:	ea50 0104 	orrs.w	r1, r0, r4
3419220e:	f000 826d 	beq.w	341926ec <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
34192212:	e9d7 0100 	ldrd	r0, r1, [r7]
34192216:	2801      	cmp	r0, #1
34192218:	f171 0101 	sbcs.w	r1, r1, #1
3419221c:	f080 82de 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192220:	e9d7 0100 	ldrd	r0, r1, [r7]
34192224:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
34192228:	4321      	orrs	r1, r4
3419222a:	f000 825a 	beq.w	341926e2 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
3419222e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192232:	4cda      	ldr	r4, [pc, #872]	@ (3419259c <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
34192234:	42a0      	cmp	r0, r4
34192236:	f171 0100 	sbcs.w	r1, r1, #0
3419223a:	f080 82cf 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419223e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192242:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
34192246:	4321      	orrs	r1, r4
34192248:	f000 8246 	beq.w	341926d8 <HAL_RCCEx_GetPeriphCLKFreq+0x790>
3419224c:	e9d7 0100 	ldrd	r0, r1, [r7]
34192250:	4cd3      	ldr	r4, [pc, #844]	@ (341925a0 <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
34192252:	42a0      	cmp	r0, r4
34192254:	f171 0100 	sbcs.w	r1, r1, #0
34192258:	f080 82c0 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419225c:	e9d7 0100 	ldrd	r0, r1, [r7]
34192260:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
34192264:	4321      	orrs	r1, r4
34192266:	f000 8232 	beq.w	341926ce <HAL_RCCEx_GetPeriphCLKFreq+0x786>
3419226a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419226e:	4ccd      	ldr	r4, [pc, #820]	@ (341925a4 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
34192270:	42a0      	cmp	r0, r4
34192272:	f171 0100 	sbcs.w	r1, r1, #0
34192276:	f080 82b1 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419227a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419227e:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
34192282:	4321      	orrs	r1, r4
34192284:	f000 821e 	beq.w	341926c4 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
34192288:	e9d7 0100 	ldrd	r0, r1, [r7]
3419228c:	4cc6      	ldr	r4, [pc, #792]	@ (341925a8 <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
3419228e:	42a0      	cmp	r0, r4
34192290:	f171 0100 	sbcs.w	r1, r1, #0
34192294:	f080 82a2 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192298:	e9d7 0100 	ldrd	r0, r1, [r7]
3419229c:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
341922a0:	4321      	orrs	r1, r4
341922a2:	f000 820b 	beq.w	341926bc <HAL_RCCEx_GetPeriphCLKFreq+0x774>
341922a6:	e9d7 0100 	ldrd	r0, r1, [r7]
341922aa:	4cc0      	ldr	r4, [pc, #768]	@ (341925ac <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
341922ac:	42a0      	cmp	r0, r4
341922ae:	f171 0100 	sbcs.w	r1, r1, #0
341922b2:	f080 8293 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341922b6:	e9d7 0100 	ldrd	r0, r1, [r7]
341922ba:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
341922be:	4321      	orrs	r1, r4
341922c0:	f000 81f7 	beq.w	341926b2 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
341922c4:	e9d7 0100 	ldrd	r0, r1, [r7]
341922c8:	4cb9      	ldr	r4, [pc, #740]	@ (341925b0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
341922ca:	42a0      	cmp	r0, r4
341922cc:	f171 0100 	sbcs.w	r1, r1, #0
341922d0:	f080 8284 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341922d4:	e9d7 0100 	ldrd	r0, r1, [r7]
341922d8:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
341922dc:	4321      	orrs	r1, r4
341922de:	f000 81e2 	beq.w	341926a6 <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
341922e2:	e9d7 0100 	ldrd	r0, r1, [r7]
341922e6:	4cb3      	ldr	r4, [pc, #716]	@ (341925b4 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
341922e8:	42a0      	cmp	r0, r4
341922ea:	f171 0100 	sbcs.w	r1, r1, #0
341922ee:	f080 8275 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341922f2:	e9d7 0100 	ldrd	r0, r1, [r7]
341922f6:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
341922fa:	4321      	orrs	r1, r4
341922fc:	f000 81cd 	beq.w	3419269a <HAL_RCCEx_GetPeriphCLKFreq+0x752>
34192300:	e9d7 0100 	ldrd	r0, r1, [r7]
34192304:	4cac      	ldr	r4, [pc, #688]	@ (341925b8 <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
34192306:	42a0      	cmp	r0, r4
34192308:	f171 0100 	sbcs.w	r1, r1, #0
3419230c:	f080 8266 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192310:	e9d7 0100 	ldrd	r0, r1, [r7]
34192314:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
34192318:	4321      	orrs	r1, r4
3419231a:	f000 81b8 	beq.w	3419268e <HAL_RCCEx_GetPeriphCLKFreq+0x746>
3419231e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192322:	4ca6      	ldr	r4, [pc, #664]	@ (341925bc <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
34192324:	42a0      	cmp	r0, r4
34192326:	f171 0100 	sbcs.w	r1, r1, #0
3419232a:	f080 8257 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419232e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192332:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
34192336:	4321      	orrs	r1, r4
34192338:	f000 81a4 	beq.w	34192684 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
3419233c:	e9d7 0100 	ldrd	r0, r1, [r7]
34192340:	4c9f      	ldr	r4, [pc, #636]	@ (341925c0 <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
34192342:	42a0      	cmp	r0, r4
34192344:	f171 0100 	sbcs.w	r1, r1, #0
34192348:	f080 8248 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419234c:	e9d7 0100 	ldrd	r0, r1, [r7]
34192350:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
34192354:	4321      	orrs	r1, r4
34192356:	f000 8190 	beq.w	3419267a <HAL_RCCEx_GetPeriphCLKFreq+0x732>
3419235a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419235e:	4c99      	ldr	r4, [pc, #612]	@ (341925c4 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
34192360:	42a0      	cmp	r0, r4
34192362:	f171 0100 	sbcs.w	r1, r1, #0
34192366:	f080 8239 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3419236a:	e9d7 0100 	ldrd	r0, r1, [r7]
3419236e:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
34192372:	4321      	orrs	r1, r4
34192374:	f000 817c 	beq.w	34192670 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
34192378:	e9d7 0100 	ldrd	r0, r1, [r7]
3419237c:	4c92      	ldr	r4, [pc, #584]	@ (341925c8 <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
3419237e:	42a0      	cmp	r0, r4
34192380:	f171 0100 	sbcs.w	r1, r1, #0
34192384:	f080 822a 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192388:	e9d7 0100 	ldrd	r0, r1, [r7]
3419238c:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
34192390:	4321      	orrs	r1, r4
34192392:	f000 8168 	beq.w	34192666 <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
34192396:	e9d7 0100 	ldrd	r0, r1, [r7]
3419239a:	4c8c      	ldr	r4, [pc, #560]	@ (341925cc <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
3419239c:	42a0      	cmp	r0, r4
3419239e:	f171 0100 	sbcs.w	r1, r1, #0
341923a2:	f080 821b 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341923a6:	e9d7 0100 	ldrd	r0, r1, [r7]
341923aa:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
341923ae:	4321      	orrs	r1, r4
341923b0:	f000 8154 	beq.w	3419265c <HAL_RCCEx_GetPeriphCLKFreq+0x714>
341923b4:	e9d7 0100 	ldrd	r0, r1, [r7]
341923b8:	4c85      	ldr	r4, [pc, #532]	@ (341925d0 <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
341923ba:	42a0      	cmp	r0, r4
341923bc:	f171 0100 	sbcs.w	r1, r1, #0
341923c0:	f080 820c 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341923c4:	e9d7 0100 	ldrd	r0, r1, [r7]
341923c8:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
341923cc:	4321      	orrs	r1, r4
341923ce:	f000 8140 	beq.w	34192652 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
341923d2:	e9d7 0100 	ldrd	r0, r1, [r7]
341923d6:	4c7f      	ldr	r4, [pc, #508]	@ (341925d4 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
341923d8:	42a0      	cmp	r0, r4
341923da:	f171 0100 	sbcs.w	r1, r1, #0
341923de:	f080 81fd 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341923e2:	e9d7 0100 	ldrd	r0, r1, [r7]
341923e6:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
341923ea:	4321      	orrs	r1, r4
341923ec:	f000 812c 	beq.w	34192648 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
341923f0:	e9d7 0100 	ldrd	r0, r1, [r7]
341923f4:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
341923f8:	f171 0100 	sbcs.w	r1, r1, #0
341923fc:	f080 81ee 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192400:	e9d7 0100 	ldrd	r0, r1, [r7]
34192404:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
34192408:	4321      	orrs	r1, r4
3419240a:	f000 8118 	beq.w	3419263e <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
3419240e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192412:	f248 0401 	movw	r4, #32769	@ 0x8001
34192416:	42a0      	cmp	r0, r4
34192418:	f171 0100 	sbcs.w	r1, r1, #0
3419241c:	f080 81de 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192420:	e9d7 0100 	ldrd	r0, r1, [r7]
34192424:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
34192428:	4321      	orrs	r1, r4
3419242a:	f000 8103 	beq.w	34192634 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3419242e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192432:	f244 0401 	movw	r4, #16385	@ 0x4001
34192436:	42a0      	cmp	r0, r4
34192438:	f171 0100 	sbcs.w	r1, r1, #0
3419243c:	f080 81ce 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192440:	e9d7 0100 	ldrd	r0, r1, [r7]
34192444:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
34192448:	4321      	orrs	r1, r4
3419244a:	f000 80ee 	beq.w	3419262a <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3419244e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192452:	f242 0401 	movw	r4, #8193	@ 0x2001
34192456:	42a0      	cmp	r0, r4
34192458:	f171 0100 	sbcs.w	r1, r1, #0
3419245c:	f080 81be 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192460:	e9d7 0100 	ldrd	r0, r1, [r7]
34192464:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
34192468:	4321      	orrs	r1, r4
3419246a:	f000 80d9 	beq.w	34192620 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3419246e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192472:	f241 0401 	movw	r4, #4097	@ 0x1001
34192476:	42a0      	cmp	r0, r4
34192478:	f171 0100 	sbcs.w	r1, r1, #0
3419247c:	f080 81ae 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34192480:	e9d7 0100 	ldrd	r0, r1, [r7]
34192484:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
34192488:	4321      	orrs	r1, r4
3419248a:	f000 80c4 	beq.w	34192616 <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
3419248e:	e9d7 0100 	ldrd	r0, r1, [r7]
34192492:	f640 0401 	movw	r4, #2049	@ 0x801
34192496:	42a0      	cmp	r0, r4
34192498:	f171 0100 	sbcs.w	r1, r1, #0
3419249c:	f080 819e 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341924a0:	e9d7 0100 	ldrd	r0, r1, [r7]
341924a4:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
341924a8:	4321      	orrs	r1, r4
341924aa:	f000 80af 	beq.w	3419260c <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
341924ae:	e9d7 0100 	ldrd	r0, r1, [r7]
341924b2:	f240 4401 	movw	r4, #1025	@ 0x401
341924b6:	42a0      	cmp	r0, r4
341924b8:	f171 0100 	sbcs.w	r1, r1, #0
341924bc:	f080 818e 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341924c0:	e9d7 0100 	ldrd	r0, r1, [r7]
341924c4:	2821      	cmp	r0, #33	@ 0x21
341924c6:	f171 0100 	sbcs.w	r1, r1, #0
341924ca:	d255      	bcs.n	34192578 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
341924cc:	e9d7 0100 	ldrd	r0, r1, [r7]
341924d0:	4301      	orrs	r1, r0
341924d2:	f000 8183 	beq.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341924d6:	e9d7 0100 	ldrd	r0, r1, [r7]
341924da:	1e42      	subs	r2, r0, #1
341924dc:	f141 33ff 	adc.w	r3, r1, #4294967295
341924e0:	2a20      	cmp	r2, #32
341924e2:	f173 0100 	sbcs.w	r1, r3, #0
341924e6:	f080 8179 	bcs.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341924ea:	2a1f      	cmp	r2, #31
341924ec:	f200 8176 	bhi.w	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
341924f0:	a101      	add	r1, pc, #4	@ (adr r1, 341924f8 <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
341924f2:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
341924f6:	bf00      	nop
341924f8:	34192587 	.word	0x34192587
341924fc:	34192591 	.word	0x34192591
34192500:	341927dd 	.word	0x341927dd
34192504:	341925e1 	.word	0x341925e1
34192508:	341927dd 	.word	0x341927dd
3419250c:	341927dd 	.word	0x341927dd
34192510:	341927dd 	.word	0x341927dd
34192514:	341925d9 	.word	0x341925d9
34192518:	341927dd 	.word	0x341927dd
3419251c:	341927dd 	.word	0x341927dd
34192520:	341927dd 	.word	0x341927dd
34192524:	341927dd 	.word	0x341927dd
34192528:	341927dd 	.word	0x341927dd
3419252c:	341927dd 	.word	0x341927dd
34192530:	341927dd 	.word	0x341927dd
34192534:	341925eb 	.word	0x341925eb
34192538:	341927dd 	.word	0x341927dd
3419253c:	341927dd 	.word	0x341927dd
34192540:	341927dd 	.word	0x341927dd
34192544:	341927dd 	.word	0x341927dd
34192548:	341927dd 	.word	0x341927dd
3419254c:	341927dd 	.word	0x341927dd
34192550:	341927dd 	.word	0x341927dd
34192554:	341927dd 	.word	0x341927dd
34192558:	341927dd 	.word	0x341927dd
3419255c:	341927dd 	.word	0x341927dd
34192560:	341927dd 	.word	0x341927dd
34192564:	341927dd 	.word	0x341927dd
34192568:	341927dd 	.word	0x341927dd
3419256c:	341927dd 	.word	0x341927dd
34192570:	341927dd 	.word	0x341927dd
34192574:	341925f7 	.word	0x341925f7
34192578:	e9d7 2300 	ldrd	r2, r3, [r7]
3419257c:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
34192580:	430b      	orrs	r3, r1
34192582:	d03e      	beq.n	34192602 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
34192584:	e12a      	b.n	341927dc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
34192586:	2070      	movs	r0, #112	@ 0x70
34192588:	f000 fb90 	bl	34192cac <RCCEx_GetADCCLKFreq>
3419258c:	60f8      	str	r0, [r7, #12]
      break;
3419258e:	e126      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
34192590:	2007      	movs	r0, #7
34192592:	f000 fc8d 	bl	34192eb0 <RCCEx_GetADFCLKFreq>
34192596:	60f8      	str	r0, [r7, #12]
      break;
34192598:	e121      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
3419259a:	bf00      	nop
3419259c:	80000001 	.word	0x80000001
341925a0:	40000001 	.word	0x40000001
341925a4:	20000001 	.word	0x20000001
341925a8:	10000001 	.word	0x10000001
341925ac:	08000001 	.word	0x08000001
341925b0:	04000001 	.word	0x04000001
341925b4:	02000001 	.word	0x02000001
341925b8:	01000001 	.word	0x01000001
341925bc:	00800001 	.word	0x00800001
341925c0:	00400001 	.word	0x00400001
341925c4:	00200001 	.word	0x00200001
341925c8:	00100001 	.word	0x00100001
341925cc:	00080001 	.word	0x00080001
341925d0:	00040001 	.word	0x00040001
341925d4:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
341925d8:	f000 ff0c 	bl	341933f4 <RCCEx_GetCSICLKFreq>
341925dc:	60f8      	str	r0, [r7, #12]
      break;
341925de:	e0fe      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341925e0:	2007      	movs	r0, #7
341925e2:	f000 fd51 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341925e6:	60f8      	str	r0, [r7, #12]
      break;
341925e8:	e0f9      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
341925ea:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
341925ee:	f000 ff4d 	bl	3419348c <RCCEx_GetDCMIPPCLKFreq>
341925f2:	60f8      	str	r0, [r7, #12]
      break;
341925f4:	e0f3      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
341925f6:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
341925fa:	f000 ffd1 	bl	341935a0 <RCCEx_GetETH1CLKFreq>
341925fe:	60f8      	str	r0, [r7, #12]
      break;
34192600:	e0ed      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
34192602:	2003      	movs	r0, #3
34192604:	f001 f84c 	bl	341936a0 <RCCEx_GetETH1PTPCLKFreq>
34192608:	60f8      	str	r0, [r7, #12]
      break;
3419260a:	e0e8      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
3419260c:	2003      	movs	r0, #3
3419260e:	f001 f8cb 	bl	341937a8 <RCCEx_GetFDCANCLKFreq>
34192612:	60f8      	str	r0, [r7, #12]
      break;
34192614:	e0e3      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34192616:	2030      	movs	r0, #48	@ 0x30
34192618:	f001 f946 	bl	341938a8 <RCCEx_GetFMCCLKFreq>
3419261c:	60f8      	str	r0, [r7, #12]
      break;
3419261e:	e0de      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34192620:	4871      	ldr	r0, [pc, #452]	@ (341927e8 <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
34192622:	f001 f9f9 	bl	34193a18 <RCCEx_GetI2CCLKFreq>
34192626:	60f8      	str	r0, [r7, #12]
      break;
34192628:	e0d9      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3419262a:	4870      	ldr	r0, [pc, #448]	@ (341927ec <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
3419262c:	f001 f9f4 	bl	34193a18 <RCCEx_GetI2CCLKFreq>
34192630:	60f8      	str	r0, [r7, #12]
      break;
34192632:	e0d4      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34192634:	486e      	ldr	r0, [pc, #440]	@ (341927f0 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34192636:	f001 f9ef 	bl	34193a18 <RCCEx_GetI2CCLKFreq>
3419263a:	60f8      	str	r0, [r7, #12]
      break;
3419263c:	e0cf      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3419263e:	486d      	ldr	r0, [pc, #436]	@ (341927f4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
34192640:	f001 f9ea 	bl	34193a18 <RCCEx_GetI2CCLKFreq>
34192644:	60f8      	str	r0, [r7, #12]
      break;
34192646:	e0ca      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
34192648:	486b      	ldr	r0, [pc, #428]	@ (341927f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
3419264a:	f001 fb8d 	bl	34193d68 <RCCEx_GetI3CCLKFreq>
3419264e:	60f8      	str	r0, [r7, #12]
      break;
34192650:	e0c5      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
34192652:	486a      	ldr	r0, [pc, #424]	@ (341927fc <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
34192654:	f001 fb88 	bl	34193d68 <RCCEx_GetI3CCLKFreq>
34192658:	60f8      	str	r0, [r7, #12]
      break;
3419265a:	e0c0      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3419265c:	4868      	ldr	r0, [pc, #416]	@ (34192800 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
3419265e:	f001 fcb7 	bl	34193fd0 <RCCEx_GetLPTIMCLKFreq>
34192662:	60f8      	str	r0, [r7, #12]
      break;
34192664:	e0bb      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
34192666:	4867      	ldr	r0, [pc, #412]	@ (34192804 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
34192668:	f001 fcb2 	bl	34193fd0 <RCCEx_GetLPTIMCLKFreq>
3419266c:	60f8      	str	r0, [r7, #12]
      break;
3419266e:	e0b6      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
34192670:	4865      	ldr	r0, [pc, #404]	@ (34192808 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
34192672:	f001 fcad 	bl	34193fd0 <RCCEx_GetLPTIMCLKFreq>
34192676:	60f8      	str	r0, [r7, #12]
      break;
34192678:	e0b1      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3419267a:	4864      	ldr	r0, [pc, #400]	@ (3419280c <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
3419267c:	f001 fca8 	bl	34193fd0 <RCCEx_GetLPTIMCLKFreq>
34192680:	60f8      	str	r0, [r7, #12]
      break;
34192682:	e0ac      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
34192684:	4862      	ldr	r0, [pc, #392]	@ (34192810 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
34192686:	f001 fca3 	bl	34193fd0 <RCCEx_GetLPTIMCLKFreq>
3419268a:	60f8      	str	r0, [r7, #12]
      break;
3419268c:	e0a7      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
3419268e:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
34192692:	f001 fe47 	bl	34194324 <RCCEx_GetLPUARTCLKFreq>
34192696:	60f8      	str	r0, [r7, #12]
      break;
34192698:	e0a1      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
3419269a:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
3419269e:	f001 ff43 	bl	34194528 <RCCEx_GetLTDCCLKFreq>
341926a2:	60f8      	str	r0, [r7, #12]
      break;
341926a4:	e09b      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
341926a6:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
341926aa:	f001 ffc7 	bl	3419463c <RCCEx_GetMDFCLKFreq>
341926ae:	60f8      	str	r0, [r7, #12]
      break;
341926b0:	e095      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
341926b2:	2030      	movs	r0, #48	@ 0x30
341926b4:	f002 f8cc 	bl	34194850 <RCCEx_GetPSSICLKFreq>
341926b8:	60f8      	str	r0, [r7, #12]
      break;
341926ba:	e090      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
341926bc:	f002 f94a 	bl	34194954 <RCCEx_GetRTCCLKFreq>
341926c0:	60f8      	str	r0, [r7, #12]
      break;
341926c2:	e08c      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
341926c4:	4853      	ldr	r0, [pc, #332]	@ (34192814 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
341926c6:	f002 f997 	bl	341949f8 <RCCEx_GetSAICLKFreq>
341926ca:	60f8      	str	r0, [r7, #12]
      break;
341926cc:	e087      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
341926ce:	4852      	ldr	r0, [pc, #328]	@ (34192818 <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
341926d0:	f002 f992 	bl	341949f8 <RCCEx_GetSAICLKFreq>
341926d4:	60f8      	str	r0, [r7, #12]
      break;
341926d6:	e082      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
341926d8:	4850      	ldr	r0, [pc, #320]	@ (3419281c <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
341926da:	f002 faf3 	bl	34194cc4 <RCCEx_GetSDMMCCLKFreq>
341926de:	60f8      	str	r0, [r7, #12]
      break;
341926e0:	e07d      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
341926e2:	484f      	ldr	r0, [pc, #316]	@ (34192820 <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
341926e4:	f002 faee 	bl	34194cc4 <RCCEx_GetSDMMCCLKFreq>
341926e8:	60f8      	str	r0, [r7, #12]
      break;
341926ea:	e078      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
341926ec:	2007      	movs	r0, #7
341926ee:	f002 fbd3 	bl	34194e98 <RCCEx_GetSPDIFRXCLKFreq>
341926f2:	60f8      	str	r0, [r7, #12]
      break;
341926f4:	e073      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
341926f6:	484b      	ldr	r0, [pc, #300]	@ (34192824 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
341926f8:	f002 fcb2 	bl	34195060 <RCCEx_GetSPICLKFreq>
341926fc:	60f8      	str	r0, [r7, #12]
      break;
341926fe:	e06e      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
34192700:	4849      	ldr	r0, [pc, #292]	@ (34192828 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
34192702:	f002 fcad 	bl	34195060 <RCCEx_GetSPICLKFreq>
34192706:	60f8      	str	r0, [r7, #12]
      break;
34192708:	e069      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
3419270a:	4848      	ldr	r0, [pc, #288]	@ (3419282c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
3419270c:	f002 fca8 	bl	34195060 <RCCEx_GetSPICLKFreq>
34192710:	60f8      	str	r0, [r7, #12]
      break;
34192712:	e064      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34192714:	4846      	ldr	r0, [pc, #280]	@ (34192830 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34192716:	f002 fca3 	bl	34195060 <RCCEx_GetSPICLKFreq>
3419271a:	60f8      	str	r0, [r7, #12]
      break;
3419271c:	e05f      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3419271e:	4845      	ldr	r0, [pc, #276]	@ (34192834 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
34192720:	f002 fc9e 	bl	34195060 <RCCEx_GetSPICLKFreq>
34192724:	60f8      	str	r0, [r7, #12]
      break;
34192726:	e05a      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34192728:	4843      	ldr	r0, [pc, #268]	@ (34192838 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
3419272a:	f002 fc99 	bl	34195060 <RCCEx_GetSPICLKFreq>
3419272e:	60f8      	str	r0, [r7, #12]
      break;
34192730:	e055      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
34192732:	4842      	ldr	r0, [pc, #264]	@ (3419283c <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34192734:	f003 f990 	bl	34195a58 <RCCEx_GetUSARTCLKFreq>
34192738:	60f8      	str	r0, [r7, #12]
      break;
3419273a:	e050      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3419273c:	4840      	ldr	r0, [pc, #256]	@ (34192840 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
3419273e:	f003 f98b 	bl	34195a58 <RCCEx_GetUSARTCLKFreq>
34192742:	60f8      	str	r0, [r7, #12]
      break;
34192744:	e04b      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
34192746:	483f      	ldr	r0, [pc, #252]	@ (34192844 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
34192748:	f003 f986 	bl	34195a58 <RCCEx_GetUSARTCLKFreq>
3419274c:	60f8      	str	r0, [r7, #12]
      break;
3419274e:	e046      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
34192750:	483d      	ldr	r0, [pc, #244]	@ (34192848 <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
34192752:	f002 ff57 	bl	34195604 <RCCEx_GetUARTCLKFreq>
34192756:	60f8      	str	r0, [r7, #12]
      break;
34192758:	e041      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3419275a:	483c      	ldr	r0, [pc, #240]	@ (3419284c <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
3419275c:	f002 ff52 	bl	34195604 <RCCEx_GetUARTCLKFreq>
34192760:	60f8      	str	r0, [r7, #12]
      break;
34192762:	e03c      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
34192764:	483a      	ldr	r0, [pc, #232]	@ (34192850 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34192766:	f003 f977 	bl	34195a58 <RCCEx_GetUSARTCLKFreq>
3419276a:	60f8      	str	r0, [r7, #12]
      break;
3419276c:	e037      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3419276e:	4839      	ldr	r0, [pc, #228]	@ (34192854 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
34192770:	f002 ff48 	bl	34195604 <RCCEx_GetUARTCLKFreq>
34192774:	60f8      	str	r0, [r7, #12]
      break;
34192776:	e032      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
34192778:	4837      	ldr	r0, [pc, #220]	@ (34192858 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3419277a:	f002 ff43 	bl	34195604 <RCCEx_GetUARTCLKFreq>
3419277e:	60f8      	str	r0, [r7, #12]
      break;
34192780:	e02d      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
34192782:	4836      	ldr	r0, [pc, #216]	@ (3419285c <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
34192784:	f002 ff3e 	bl	34195604 <RCCEx_GetUARTCLKFreq>
34192788:	60f8      	str	r0, [r7, #12]
      break;
3419278a:	e028      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3419278c:	4834      	ldr	r0, [pc, #208]	@ (34192860 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
3419278e:	f003 f963 	bl	34195a58 <RCCEx_GetUSARTCLKFreq>
34192792:	60f8      	str	r0, [r7, #12]
      break;
34192794:	e023      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
34192796:	4833      	ldr	r0, [pc, #204]	@ (34192864 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
34192798:	f003 fc3e 	bl	34196018 <RCCEx_GetOTGPHYCKREFCLKFreq>
3419279c:	60f8      	str	r0, [r7, #12]
      break;
3419279e:	e01e      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
341927a0:	4831      	ldr	r0, [pc, #196]	@ (34192868 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
341927a2:	f003 fb83 	bl	34195eac <RCCEx_GetOTGPHYCLKFreq>
341927a6:	60f8      	str	r0, [r7, #12]
      break;
341927a8:	e019      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
341927aa:	4830      	ldr	r0, [pc, #192]	@ (3419286c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
341927ac:	f003 fc34 	bl	34196018 <RCCEx_GetOTGPHYCKREFCLKFreq>
341927b0:	60f8      	str	r0, [r7, #12]
      break;
341927b2:	e014      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
341927b4:	482e      	ldr	r0, [pc, #184]	@ (34192870 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
341927b6:	f003 fb79 	bl	34195eac <RCCEx_GetOTGPHYCLKFreq>
341927ba:	60f8      	str	r0, [r7, #12]
      break;
341927bc:	e00f      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
341927be:	482d      	ldr	r0, [pc, #180]	@ (34192874 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
341927c0:	f003 fc7a 	bl	341960b8 <RCCEx_GetXSPICLKFreq>
341927c4:	60f8      	str	r0, [r7, #12]
      break;
341927c6:	e00a      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
341927c8:	482b      	ldr	r0, [pc, #172]	@ (34192878 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
341927ca:	f003 fc75 	bl	341960b8 <RCCEx_GetXSPICLKFreq>
341927ce:	60f8      	str	r0, [r7, #12]
      break;
341927d0:	e005      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
341927d2:	482a      	ldr	r0, [pc, #168]	@ (3419287c <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
341927d4:	f003 fc70 	bl	341960b8 <RCCEx_GetXSPICLKFreq>
341927d8:	60f8      	str	r0, [r7, #12]
      break;
341927da:	e000      	b.n	341927de <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
341927dc:	bf00      	nop
  }

  return frequency;
341927de:	68fb      	ldr	r3, [r7, #12]
}
341927e0:	4618      	mov	r0, r3
341927e2:	3714      	adds	r7, #20
341927e4:	46bd      	mov	sp, r7
341927e6:	bd90      	pop	{r4, r7, pc}
341927e8:	0700000c 	.word	0x0700000c
341927ec:	0700040c 	.word	0x0700040c
341927f0:	0700080c 	.word	0x0700080c
341927f4:	07000c0c 	.word	0x07000c0c
341927f8:	0700100c 	.word	0x0700100c
341927fc:	0700140c 	.word	0x0700140c
34192800:	0700082c 	.word	0x0700082c
34192804:	07000c2c 	.word	0x07000c2c
34192808:	0700102c 	.word	0x0700102c
3419280c:	0700142c 	.word	0x0700142c
34192810:	0700182c 	.word	0x0700182c
34192814:	07001418 	.word	0x07001418
34192818:	07001818 	.word	0x07001818
3419281c:	0300001c 	.word	0x0300001c
34192820:	0300041c 	.word	0x0300041c
34192824:	07000420 	.word	0x07000420
34192828:	07000820 	.word	0x07000820
3419282c:	07000c20 	.word	0x07000c20
34192830:	07001020 	.word	0x07001020
34192834:	07001420 	.word	0x07001420
34192838:	07001820 	.word	0x07001820
3419283c:	07000030 	.word	0x07000030
34192840:	07000430 	.word	0x07000430
34192844:	07000830 	.word	0x07000830
34192848:	07000c30 	.word	0x07000c30
3419284c:	07001030 	.word	0x07001030
34192850:	07001430 	.word	0x07001430
34192854:	07001830 	.word	0x07001830
34192858:	07001c30 	.word	0x07001c30
3419285c:	07000034 	.word	0x07000034
34192860:	07000434 	.word	0x07000434
34192864:	01001014 	.word	0x01001014
34192868:	03000c14 	.word	0x03000c14
3419286c:	01001814 	.word	0x01001814
34192870:	03001414 	.word	0x03001414
34192874:	03000014 	.word	0x03000014
34192878:	03000414 	.word	0x03000414
3419287c:	03000814 	.word	0x03000814

34192880 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34192880:	b5f0      	push	{r4, r5, r6, r7, lr}
34192882:	b087      	sub	sp, #28
34192884:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34192886:	2300      	movs	r3, #0
34192888:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
3419288a:	f7fc fa05 	bl	3418ec98 <LL_RCC_PLL1_IsReady>
3419288e:	4603      	mov	r3, r0
34192890:	2b00      	cmp	r3, #0
34192892:	d02a      	beq.n	341928ea <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34192894:	f7fc fa68 	bl	3418ed68 <LL_RCC_PLL1P_IsEnabled>
34192898:	4603      	mov	r3, r0
3419289a:	2b00      	cmp	r3, #0
3419289c:	d031      	beq.n	34192902 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3419289e:	f7fc f9ed 	bl	3418ec7c <LL_RCC_PLL1_GetSource>
341928a2:	4603      	mov	r3, r0
341928a4:	4618      	mov	r0, r3
341928a6:	f000 f957 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
341928aa:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
341928ac:	68bb      	ldr	r3, [r7, #8]
341928ae:	2b00      	cmp	r3, #0
341928b0:	d027      	beq.n	34192902 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
341928b2:	f7fc fa29 	bl	3418ed08 <LL_RCC_PLL1_GetM>
341928b6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341928b8:	687b      	ldr	r3, [r7, #4]
341928ba:	2b00      	cmp	r3, #0
341928bc:	d021      	beq.n	34192902 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
341928be:	f7fc fa13 	bl	3418ece8 <LL_RCC_PLL1_GetN>
341928c2:	4605      	mov	r5, r0
341928c4:	f7fc fa64 	bl	3418ed90 <LL_RCC_PLL1_GetFRACN>
341928c8:	4606      	mov	r6, r0
341928ca:	f7fc fa2d 	bl	3418ed28 <LL_RCC_PLL1_GetP1>
341928ce:	4604      	mov	r4, r0
341928d0:	f7fc fa3a 	bl	3418ed48 <LL_RCC_PLL1_GetP2>
341928d4:	4603      	mov	r3, r0
341928d6:	9301      	str	r3, [sp, #4]
341928d8:	9400      	str	r4, [sp, #0]
341928da:	4633      	mov	r3, r6
341928dc:	462a      	mov	r2, r5
341928de:	6879      	ldr	r1, [r7, #4]
341928e0:	68b8      	ldr	r0, [r7, #8]
341928e2:	f000 f997 	bl	34192c14 <RCCEx_CalcPLLFreq>
341928e6:	60f8      	str	r0, [r7, #12]
341928e8:	e00b      	b.n	34192902 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
341928ea:	f7fc f9e9 	bl	3418ecc0 <LL_RCC_PLL1_IsEnabledBypass>
341928ee:	4603      	mov	r3, r0
341928f0:	2b00      	cmp	r3, #0
341928f2:	d006      	beq.n	34192902 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
341928f4:	f7fc f9c2 	bl	3418ec7c <LL_RCC_PLL1_GetSource>
341928f8:	4603      	mov	r3, r0
341928fa:	4618      	mov	r0, r3
341928fc:	f000 f92c 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
34192900:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34192902:	68fb      	ldr	r3, [r7, #12]
}
34192904:	4618      	mov	r0, r3
34192906:	3714      	adds	r7, #20
34192908:	46bd      	mov	sp, r7
3419290a:	bdf0      	pop	{r4, r5, r6, r7, pc}

3419290c <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
3419290c:	b5f0      	push	{r4, r5, r6, r7, lr}
3419290e:	b087      	sub	sp, #28
34192910:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34192912:	2300      	movs	r3, #0
34192914:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34192916:	f7fc fa57 	bl	3418edc8 <LL_RCC_PLL2_IsReady>
3419291a:	4603      	mov	r3, r0
3419291c:	2b00      	cmp	r3, #0
3419291e:	d02a      	beq.n	34192976 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34192920:	f7fc faba 	bl	3418ee98 <LL_RCC_PLL2P_IsEnabled>
34192924:	4603      	mov	r3, r0
34192926:	2b00      	cmp	r3, #0
34192928:	d031      	beq.n	3419298e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3419292a:	f7fc fa3f 	bl	3418edac <LL_RCC_PLL2_GetSource>
3419292e:	4603      	mov	r3, r0
34192930:	4618      	mov	r0, r3
34192932:	f000 f911 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
34192936:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34192938:	68bb      	ldr	r3, [r7, #8]
3419293a:	2b00      	cmp	r3, #0
3419293c:	d027      	beq.n	3419298e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
3419293e:	f7fc fa7b 	bl	3418ee38 <LL_RCC_PLL2_GetM>
34192942:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34192944:	687b      	ldr	r3, [r7, #4]
34192946:	2b00      	cmp	r3, #0
34192948:	d021      	beq.n	3419298e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3419294a:	f7fc fa65 	bl	3418ee18 <LL_RCC_PLL2_GetN>
3419294e:	4605      	mov	r5, r0
34192950:	f7fc fab6 	bl	3418eec0 <LL_RCC_PLL2_GetFRACN>
34192954:	4606      	mov	r6, r0
34192956:	f7fc fa7f 	bl	3418ee58 <LL_RCC_PLL2_GetP1>
3419295a:	4604      	mov	r4, r0
3419295c:	f7fc fa8c 	bl	3418ee78 <LL_RCC_PLL2_GetP2>
34192960:	4603      	mov	r3, r0
34192962:	9301      	str	r3, [sp, #4]
34192964:	9400      	str	r4, [sp, #0]
34192966:	4633      	mov	r3, r6
34192968:	462a      	mov	r2, r5
3419296a:	6879      	ldr	r1, [r7, #4]
3419296c:	68b8      	ldr	r0, [r7, #8]
3419296e:	f000 f951 	bl	34192c14 <RCCEx_CalcPLLFreq>
34192972:	60f8      	str	r0, [r7, #12]
34192974:	e00b      	b.n	3419298e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
34192976:	f7fc fa3b 	bl	3418edf0 <LL_RCC_PLL2_IsEnabledBypass>
3419297a:	4603      	mov	r3, r0
3419297c:	2b00      	cmp	r3, #0
3419297e:	d006      	beq.n	3419298e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34192980:	f7fc fa14 	bl	3418edac <LL_RCC_PLL2_GetSource>
34192984:	4603      	mov	r3, r0
34192986:	4618      	mov	r0, r3
34192988:	f000 f8e6 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
3419298c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3419298e:	68fb      	ldr	r3, [r7, #12]
}
34192990:	4618      	mov	r0, r3
34192992:	3714      	adds	r7, #20
34192994:	46bd      	mov	sp, r7
34192996:	bdf0      	pop	{r4, r5, r6, r7, pc}

34192998 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
34192998:	b5f0      	push	{r4, r5, r6, r7, lr}
3419299a:	b087      	sub	sp, #28
3419299c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3419299e:	2300      	movs	r3, #0
341929a0:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
341929a2:	f7fc faa9 	bl	3418eef8 <LL_RCC_PLL3_IsReady>
341929a6:	4603      	mov	r3, r0
341929a8:	2b00      	cmp	r3, #0
341929aa:	d02a      	beq.n	34192a02 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
341929ac:	f7fc fb0c 	bl	3418efc8 <LL_RCC_PLL3P_IsEnabled>
341929b0:	4603      	mov	r3, r0
341929b2:	2b00      	cmp	r3, #0
341929b4:	d031      	beq.n	34192a1a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
341929b6:	f7fc fa91 	bl	3418eedc <LL_RCC_PLL3_GetSource>
341929ba:	4603      	mov	r3, r0
341929bc:	4618      	mov	r0, r3
341929be:	f000 f8cb 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
341929c2:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
341929c4:	68bb      	ldr	r3, [r7, #8]
341929c6:	2b00      	cmp	r3, #0
341929c8:	d027      	beq.n	34192a1a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
341929ca:	f7fc facd 	bl	3418ef68 <LL_RCC_PLL3_GetM>
341929ce:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
341929d0:	687b      	ldr	r3, [r7, #4]
341929d2:	2b00      	cmp	r3, #0
341929d4:	d021      	beq.n	34192a1a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
341929d6:	f7fc fab7 	bl	3418ef48 <LL_RCC_PLL3_GetN>
341929da:	4605      	mov	r5, r0
341929dc:	f7fc fb08 	bl	3418eff0 <LL_RCC_PLL3_GetFRACN>
341929e0:	4606      	mov	r6, r0
341929e2:	f7fc fad1 	bl	3418ef88 <LL_RCC_PLL3_GetP1>
341929e6:	4604      	mov	r4, r0
341929e8:	f7fc fade 	bl	3418efa8 <LL_RCC_PLL3_GetP2>
341929ec:	4603      	mov	r3, r0
341929ee:	9301      	str	r3, [sp, #4]
341929f0:	9400      	str	r4, [sp, #0]
341929f2:	4633      	mov	r3, r6
341929f4:	462a      	mov	r2, r5
341929f6:	6879      	ldr	r1, [r7, #4]
341929f8:	68b8      	ldr	r0, [r7, #8]
341929fa:	f000 f90b 	bl	34192c14 <RCCEx_CalcPLLFreq>
341929fe:	60f8      	str	r0, [r7, #12]
34192a00:	e00b      	b.n	34192a1a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
34192a02:	f7fc fa8d 	bl	3418ef20 <LL_RCC_PLL3_IsEnabledBypass>
34192a06:	4603      	mov	r3, r0
34192a08:	2b00      	cmp	r3, #0
34192a0a:	d006      	beq.n	34192a1a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34192a0c:	f7fc fa66 	bl	3418eedc <LL_RCC_PLL3_GetSource>
34192a10:	4603      	mov	r3, r0
34192a12:	4618      	mov	r0, r3
34192a14:	f000 f8a0 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
34192a18:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34192a1a:	68fb      	ldr	r3, [r7, #12]
}
34192a1c:	4618      	mov	r0, r3
34192a1e:	3714      	adds	r7, #20
34192a20:	46bd      	mov	sp, r7
34192a22:	bdf0      	pop	{r4, r5, r6, r7, pc}

34192a24 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34192a24:	b5f0      	push	{r4, r5, r6, r7, lr}
34192a26:	b087      	sub	sp, #28
34192a28:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34192a2a:	2300      	movs	r3, #0
34192a2c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34192a2e:	f7fc fafb 	bl	3418f028 <LL_RCC_PLL4_IsReady>
34192a32:	4603      	mov	r3, r0
34192a34:	2b00      	cmp	r3, #0
34192a36:	d02a      	beq.n	34192a8e <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34192a38:	f7fc fb5e 	bl	3418f0f8 <LL_RCC_PLL4P_IsEnabled>
34192a3c:	4603      	mov	r3, r0
34192a3e:	2b00      	cmp	r3, #0
34192a40:	d031      	beq.n	34192aa6 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34192a42:	f7fc fae3 	bl	3418f00c <LL_RCC_PLL4_GetSource>
34192a46:	4603      	mov	r3, r0
34192a48:	4618      	mov	r0, r3
34192a4a:	f000 f885 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
34192a4e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34192a50:	68bb      	ldr	r3, [r7, #8]
34192a52:	2b00      	cmp	r3, #0
34192a54:	d027      	beq.n	34192aa6 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
34192a56:	f7fc fb1f 	bl	3418f098 <LL_RCC_PLL4_GetM>
34192a5a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34192a5c:	687b      	ldr	r3, [r7, #4]
34192a5e:	2b00      	cmp	r3, #0
34192a60:	d021      	beq.n	34192aa6 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34192a62:	f7fc fb09 	bl	3418f078 <LL_RCC_PLL4_GetN>
34192a66:	4605      	mov	r5, r0
34192a68:	f7fc fb5a 	bl	3418f120 <LL_RCC_PLL4_GetFRACN>
34192a6c:	4606      	mov	r6, r0
34192a6e:	f7fc fb23 	bl	3418f0b8 <LL_RCC_PLL4_GetP1>
34192a72:	4604      	mov	r4, r0
34192a74:	f7fc fb30 	bl	3418f0d8 <LL_RCC_PLL4_GetP2>
34192a78:	4603      	mov	r3, r0
34192a7a:	9301      	str	r3, [sp, #4]
34192a7c:	9400      	str	r4, [sp, #0]
34192a7e:	4633      	mov	r3, r6
34192a80:	462a      	mov	r2, r5
34192a82:	6879      	ldr	r1, [r7, #4]
34192a84:	68b8      	ldr	r0, [r7, #8]
34192a86:	f000 f8c5 	bl	34192c14 <RCCEx_CalcPLLFreq>
34192a8a:	60f8      	str	r0, [r7, #12]
34192a8c:	e00b      	b.n	34192aa6 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34192a8e:	f7fc fadf 	bl	3418f050 <LL_RCC_PLL4_IsEnabledBypass>
34192a92:	4603      	mov	r3, r0
34192a94:	2b00      	cmp	r3, #0
34192a96:	d006      	beq.n	34192aa6 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34192a98:	f7fc fab8 	bl	3418f00c <LL_RCC_PLL4_GetSource>
34192a9c:	4603      	mov	r3, r0
34192a9e:	4618      	mov	r0, r3
34192aa0:	f000 f85a 	bl	34192b58 <RCCEx_GetPLLSourceFreq>
34192aa4:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34192aa6:	68fb      	ldr	r3, [r7, #12]
}
34192aa8:	4618      	mov	r0, r3
34192aaa:	3714      	adds	r7, #20
34192aac:	46bd      	mov	sp, r7
34192aae:	bdf0      	pop	{r4, r5, r6, r7, pc}

34192ab0 <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34192ab0:	b580      	push	{r7, lr}
34192ab2:	b082      	sub	sp, #8
34192ab4:	af00      	add	r7, sp, #0
34192ab6:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34192ab8:	f7fb fcca 	bl	3418e450 <LL_RCC_GetAHBPrescaler>
34192abc:	4603      	mov	r3, r0
34192abe:	0d1b      	lsrs	r3, r3, #20
34192ac0:	f003 0307 	and.w	r3, r3, #7
34192ac4:	687a      	ldr	r2, [r7, #4]
34192ac6:	fa22 f303 	lsr.w	r3, r2, r3
}
34192aca:	4618      	mov	r0, r3
34192acc:	3708      	adds	r7, #8
34192ace:	46bd      	mov	sp, r7
34192ad0:	bd80      	pop	{r7, pc}

34192ad2 <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34192ad2:	b580      	push	{r7, lr}
34192ad4:	b082      	sub	sp, #8
34192ad6:	af00      	add	r7, sp, #0
34192ad8:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
34192ada:	f7fb fcc7 	bl	3418e46c <LL_RCC_GetAPB1Prescaler>
34192ade:	4603      	mov	r3, r0
34192ae0:	f003 0307 	and.w	r3, r3, #7
34192ae4:	687a      	ldr	r2, [r7, #4]
34192ae6:	fa22 f303 	lsr.w	r3, r2, r3
}
34192aea:	4618      	mov	r0, r3
34192aec:	3708      	adds	r7, #8
34192aee:	46bd      	mov	sp, r7
34192af0:	bd80      	pop	{r7, pc}

34192af2 <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
34192af2:	b580      	push	{r7, lr}
34192af4:	b082      	sub	sp, #8
34192af6:	af00      	add	r7, sp, #0
34192af8:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34192afa:	f7fb fcc5 	bl	3418e488 <LL_RCC_GetAPB2Prescaler>
34192afe:	4603      	mov	r3, r0
34192b00:	091b      	lsrs	r3, r3, #4
34192b02:	f003 0307 	and.w	r3, r3, #7
34192b06:	687a      	ldr	r2, [r7, #4]
34192b08:	fa22 f303 	lsr.w	r3, r2, r3
}
34192b0c:	4618      	mov	r0, r3
34192b0e:	3708      	adds	r7, #8
34192b10:	46bd      	mov	sp, r7
34192b12:	bd80      	pop	{r7, pc}

34192b14 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
34192b14:	b580      	push	{r7, lr}
34192b16:	b082      	sub	sp, #8
34192b18:	af00      	add	r7, sp, #0
34192b1a:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34192b1c:	f7fb fcc2 	bl	3418e4a4 <LL_RCC_GetAPB4Prescaler>
34192b20:	4603      	mov	r3, r0
34192b22:	0b1b      	lsrs	r3, r3, #12
34192b24:	f003 0307 	and.w	r3, r3, #7
34192b28:	687a      	ldr	r2, [r7, #4]
34192b2a:	fa22 f303 	lsr.w	r3, r2, r3
}
34192b2e:	4618      	mov	r0, r3
34192b30:	3708      	adds	r7, #8
34192b32:	46bd      	mov	sp, r7
34192b34:	bd80      	pop	{r7, pc}

34192b36 <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
34192b36:	b580      	push	{r7, lr}
34192b38:	b082      	sub	sp, #8
34192b3a:	af00      	add	r7, sp, #0
34192b3c:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
34192b3e:	f7fb fcbf 	bl	3418e4c0 <LL_RCC_GetAPB5Prescaler>
34192b42:	4603      	mov	r3, r0
34192b44:	0c1b      	lsrs	r3, r3, #16
34192b46:	f003 0307 	and.w	r3, r3, #7
34192b4a:	687a      	ldr	r2, [r7, #4]
34192b4c:	fa22 f303 	lsr.w	r3, r2, r3
}
34192b50:	4618      	mov	r0, r3
34192b52:	3708      	adds	r7, #8
34192b54:	46bd      	mov	sp, r7
34192b56:	bd80      	pop	{r7, pc}

34192b58 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
34192b58:	b580      	push	{r7, lr}
34192b5a:	b084      	sub	sp, #16
34192b5c:	af00      	add	r7, sp, #0
34192b5e:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34192b60:	2300      	movs	r3, #0
34192b62:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34192b64:	687b      	ldr	r3, [r7, #4]
34192b66:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192b6a:	d039      	beq.n	34192be0 <RCCEx_GetPLLSourceFreq+0x88>
34192b6c:	687b      	ldr	r3, [r7, #4]
34192b6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192b72:	d838      	bhi.n	34192be6 <RCCEx_GetPLLSourceFreq+0x8e>
34192b74:	687b      	ldr	r3, [r7, #4]
34192b76:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192b7a:	d029      	beq.n	34192bd0 <RCCEx_GetPLLSourceFreq+0x78>
34192b7c:	687b      	ldr	r3, [r7, #4]
34192b7e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192b82:	d830      	bhi.n	34192be6 <RCCEx_GetPLLSourceFreq+0x8e>
34192b84:	687b      	ldr	r3, [r7, #4]
34192b86:	2b00      	cmp	r3, #0
34192b88:	d004      	beq.n	34192b94 <RCCEx_GetPLLSourceFreq+0x3c>
34192b8a:	687b      	ldr	r3, [r7, #4]
34192b8c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192b90:	d00e      	beq.n	34192bb0 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34192b92:	e028      	b.n	34192be6 <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34192b94:	f7fb fbfc 	bl	3418e390 <LL_RCC_HSI_IsReady>
34192b98:	4603      	mov	r3, r0
34192b9a:	2b00      	cmp	r3, #0
34192b9c:	d025      	beq.n	34192bea <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34192b9e:	f7fb fc09 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34192ba2:	4603      	mov	r3, r0
34192ba4:	09db      	lsrs	r3, r3, #7
34192ba6:	4a16      	ldr	r2, [pc, #88]	@ (34192c00 <RCCEx_GetPLLSourceFreq+0xa8>)
34192ba8:	fa22 f303 	lsr.w	r3, r2, r3
34192bac:	60fb      	str	r3, [r7, #12]
      break;
34192bae:	e01c      	b.n	34192bea <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34192bb0:	f7fb fc0e 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34192bb4:	4603      	mov	r3, r0
34192bb6:	2b00      	cmp	r3, #0
34192bb8:	d019      	beq.n	34192bee <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34192bba:	f7fb fc1b 	bl	3418e3f4 <LL_RCC_MSI_GetFrequency>
34192bbe:	4603      	mov	r3, r0
34192bc0:	2b00      	cmp	r3, #0
34192bc2:	d102      	bne.n	34192bca <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34192bc4:	4b0f      	ldr	r3, [pc, #60]	@ (34192c04 <RCCEx_GetPLLSourceFreq+0xac>)
34192bc6:	60fb      	str	r3, [r7, #12]
      break;
34192bc8:	e011      	b.n	34192bee <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
34192bca:	4b0f      	ldr	r3, [pc, #60]	@ (34192c08 <RCCEx_GetPLLSourceFreq+0xb0>)
34192bcc:	60fb      	str	r3, [r7, #12]
      break;
34192bce:	e00e      	b.n	34192bee <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34192bd0:	f7fb fbcc 	bl	3418e36c <LL_RCC_HSE_IsReady>
34192bd4:	4603      	mov	r3, r0
34192bd6:	2b00      	cmp	r3, #0
34192bd8:	d00b      	beq.n	34192bf2 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
34192bda:	4b0c      	ldr	r3, [pc, #48]	@ (34192c0c <RCCEx_GetPLLSourceFreq+0xb4>)
34192bdc:	60fb      	str	r3, [r7, #12]
      break;
34192bde:	e008      	b.n	34192bf2 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34192be0:	4b0b      	ldr	r3, [pc, #44]	@ (34192c10 <RCCEx_GetPLLSourceFreq+0xb8>)
34192be2:	60fb      	str	r3, [r7, #12]
      break;
34192be4:	e006      	b.n	34192bf4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34192be6:	bf00      	nop
34192be8:	e004      	b.n	34192bf4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34192bea:	bf00      	nop
34192bec:	e002      	b.n	34192bf4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34192bee:	bf00      	nop
34192bf0:	e000      	b.n	34192bf4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34192bf2:	bf00      	nop
  }

  return pllinputfreq;
34192bf4:	68fb      	ldr	r3, [r7, #12]
}
34192bf6:	4618      	mov	r0, r3
34192bf8:	3710      	adds	r7, #16
34192bfa:	46bd      	mov	sp, r7
34192bfc:	bd80      	pop	{r7, pc}
34192bfe:	bf00      	nop
34192c00:	03d09000 	.word	0x03d09000
34192c04:	003d0900 	.word	0x003d0900
34192c08:	00f42400 	.word	0x00f42400
34192c0c:	02dc6c00 	.word	0x02dc6c00
34192c10:	00bb8000 	.word	0x00bb8000

34192c14 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34192c14:	b480      	push	{r7}
34192c16:	b087      	sub	sp, #28
34192c18:	af00      	add	r7, sp, #0
34192c1a:	60f8      	str	r0, [r7, #12]
34192c1c:	60b9      	str	r1, [r7, #8]
34192c1e:	607a      	str	r2, [r7, #4]
34192c20:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34192c22:	68fb      	ldr	r3, [r7, #12]
34192c24:	ee07 3a90 	vmov	s15, r3
34192c28:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34192c2c:	687b      	ldr	r3, [r7, #4]
34192c2e:	ee07 3a90 	vmov	s15, r3
34192c32:	eef8 6a67 	vcvt.f32.u32	s13, s15
34192c36:	683b      	ldr	r3, [r7, #0]
34192c38:	ee07 3a90 	vmov	s15, r3
34192c3c:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34192c40:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34192ca8 <RCCEx_CalcPLLFreq+0x94>
34192c44:	eec6 7a25 	vdiv.f32	s15, s12, s11
34192c48:	ee76 7aa7 	vadd.f32	s15, s13, s15
34192c4c:	ee67 6a27 	vmul.f32	s13, s14, s15
34192c50:	68bb      	ldr	r3, [r7, #8]
34192c52:	ee07 3a90 	vmov	s15, r3
34192c56:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34192c5a:	eec6 7a87 	vdiv.f32	s15, s13, s14
34192c5e:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34192c62:	6a3b      	ldr	r3, [r7, #32]
34192c64:	ee07 3a90 	vmov	s15, r3
34192c68:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34192c6c:	edd7 6a05 	vldr	s13, [r7, #20]
34192c70:	eec6 7a87 	vdiv.f32	s15, s13, s14
34192c74:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
34192c78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34192c7a:	ee07 3a90 	vmov	s15, r3
34192c7e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34192c82:	edd7 6a05 	vldr	s13, [r7, #20]
34192c86:	eec6 7a87 	vdiv.f32	s15, s13, s14
34192c8a:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34192c8e:	edd7 7a05 	vldr	s15, [r7, #20]
34192c92:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34192c96:	ee17 3a90 	vmov	r3, s15
}
34192c9a:	4618      	mov	r0, r3
34192c9c:	371c      	adds	r7, #28
34192c9e:	46bd      	mov	sp, r7
34192ca0:	f85d 7b04 	ldr.w	r7, [sp], #4
34192ca4:	4770      	bx	lr
34192ca6:	bf00      	nop
34192ca8:	4b800000 	.word	0x4b800000

34192cac <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
34192cac:	b590      	push	{r4, r7, lr}
34192cae:	b085      	sub	sp, #20
34192cb0:	af00      	add	r7, sp, #0
34192cb2:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34192cb4:	2300      	movs	r3, #0
34192cb6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
34192cb8:	6878      	ldr	r0, [r7, #4]
34192cba:	f7fb fe1f 	bl	3418e8fc <LL_RCC_GetADCClockSource>
34192cbe:	4603      	mov	r3, r0
34192cc0:	2b70      	cmp	r3, #112	@ 0x70
34192cc2:	f000 80d1 	beq.w	34192e68 <RCCEx_GetADCCLKFreq+0x1bc>
34192cc6:	2b70      	cmp	r3, #112	@ 0x70
34192cc8:	f200 80d8 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192ccc:	2b60      	cmp	r3, #96	@ 0x60
34192cce:	f000 80c8 	beq.w	34192e62 <RCCEx_GetADCCLKFreq+0x1b6>
34192cd2:	2b60      	cmp	r3, #96	@ 0x60
34192cd4:	f200 80d2 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192cd8:	2b50      	cmp	r3, #80	@ 0x50
34192cda:	f000 80ac 	beq.w	34192e36 <RCCEx_GetADCCLKFreq+0x18a>
34192cde:	2b50      	cmp	r3, #80	@ 0x50
34192ce0:	f200 80cc 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192ce4:	2b40      	cmp	r3, #64	@ 0x40
34192ce6:	f000 80b4 	beq.w	34192e52 <RCCEx_GetADCCLKFreq+0x1a6>
34192cea:	2b40      	cmp	r3, #64	@ 0x40
34192cec:	f200 80c6 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192cf0:	2b30      	cmp	r3, #48	@ 0x30
34192cf2:	d05d      	beq.n	34192db0 <RCCEx_GetADCCLKFreq+0x104>
34192cf4:	2b30      	cmp	r3, #48	@ 0x30
34192cf6:	f200 80c1 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192cfa:	2b20      	cmp	r3, #32
34192cfc:	d014      	beq.n	34192d28 <RCCEx_GetADCCLKFreq+0x7c>
34192cfe:	2b20      	cmp	r3, #32
34192d00:	f200 80bc 	bhi.w	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
34192d04:	2b00      	cmp	r3, #0
34192d06:	d002      	beq.n	34192d0e <RCCEx_GetADCCLKFreq+0x62>
34192d08:	2b10      	cmp	r3, #16
34192d0a:	d008      	beq.n	34192d1e <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34192d0c:	e0b6      	b.n	34192e7c <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34192d0e:	f7fa ff17 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34192d12:	4603      	mov	r3, r0
34192d14:	4618      	mov	r0, r3
34192d16:	f7ff fecb 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34192d1a:	60f8      	str	r0, [r7, #12]
      break;
34192d1c:	e0b7      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192d1e:	2007      	movs	r0, #7
34192d20:	f000 f9b2 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34192d24:	60f8      	str	r0, [r7, #12]
      break;
34192d26:	e0b2      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34192d28:	f7fc fad6 	bl	3418f2d8 <LL_RCC_IC7_IsEnabled>
34192d2c:	4603      	mov	r3, r0
34192d2e:	2b00      	cmp	r3, #0
34192d30:	f000 80a6 	beq.w	34192e80 <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
34192d34:	f7fc faf2 	bl	3418f31c <LL_RCC_IC7_GetDivider>
34192d38:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34192d3a:	f7fc fae1 	bl	3418f300 <LL_RCC_IC7_GetSource>
34192d3e:	4603      	mov	r3, r0
34192d40:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192d44:	d029      	beq.n	34192d9a <RCCEx_GetADCCLKFreq+0xee>
34192d46:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192d4a:	d82f      	bhi.n	34192dac <RCCEx_GetADCCLKFreq+0x100>
34192d4c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192d50:	d01a      	beq.n	34192d88 <RCCEx_GetADCCLKFreq+0xdc>
34192d52:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192d56:	d829      	bhi.n	34192dac <RCCEx_GetADCCLKFreq+0x100>
34192d58:	2b00      	cmp	r3, #0
34192d5a:	d003      	beq.n	34192d64 <RCCEx_GetADCCLKFreq+0xb8>
34192d5c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192d60:	d009      	beq.n	34192d76 <RCCEx_GetADCCLKFreq+0xca>
            break;
34192d62:	e023      	b.n	34192dac <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192d64:	f7ff fd8c 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34192d68:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192d6a:	68fa      	ldr	r2, [r7, #12]
34192d6c:	68bb      	ldr	r3, [r7, #8]
34192d6e:	fbb2 f3f3 	udiv	r3, r2, r3
34192d72:	60fb      	str	r3, [r7, #12]
            break;
34192d74:	e01b      	b.n	34192dae <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192d76:	f7ff fdc9 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34192d7a:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192d7c:	68fa      	ldr	r2, [r7, #12]
34192d7e:	68bb      	ldr	r3, [r7, #8]
34192d80:	fbb2 f3f3 	udiv	r3, r2, r3
34192d84:	60fb      	str	r3, [r7, #12]
            break;
34192d86:	e012      	b.n	34192dae <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192d88:	f7ff fe06 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34192d8c:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192d8e:	68fa      	ldr	r2, [r7, #12]
34192d90:	68bb      	ldr	r3, [r7, #8]
34192d92:	fbb2 f3f3 	udiv	r3, r2, r3
34192d96:	60fb      	str	r3, [r7, #12]
            break;
34192d98:	e009      	b.n	34192dae <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192d9a:	f7ff fe43 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34192d9e:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192da0:	68fa      	ldr	r2, [r7, #12]
34192da2:	68bb      	ldr	r3, [r7, #8]
34192da4:	fbb2 f3f3 	udiv	r3, r2, r3
34192da8:	60fb      	str	r3, [r7, #12]
            break;
34192daa:	e000      	b.n	34192dae <RCCEx_GetADCCLKFreq+0x102>
            break;
34192dac:	bf00      	nop
      break;
34192dae:	e067      	b.n	34192e80 <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34192db0:	f7fc fad2 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
34192db4:	4603      	mov	r3, r0
34192db6:	2b00      	cmp	r3, #0
34192db8:	d064      	beq.n	34192e84 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
34192dba:	f7fc faef 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34192dbe:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34192dc0:	f7fc fade 	bl	3418f380 <LL_RCC_IC8_GetSource>
34192dc4:	4603      	mov	r3, r0
34192dc6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192dca:	d029      	beq.n	34192e20 <RCCEx_GetADCCLKFreq+0x174>
34192dcc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192dd0:	d82f      	bhi.n	34192e32 <RCCEx_GetADCCLKFreq+0x186>
34192dd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192dd6:	d01a      	beq.n	34192e0e <RCCEx_GetADCCLKFreq+0x162>
34192dd8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192ddc:	d829      	bhi.n	34192e32 <RCCEx_GetADCCLKFreq+0x186>
34192dde:	2b00      	cmp	r3, #0
34192de0:	d003      	beq.n	34192dea <RCCEx_GetADCCLKFreq+0x13e>
34192de2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192de6:	d009      	beq.n	34192dfc <RCCEx_GetADCCLKFreq+0x150>
            break;
34192de8:	e023      	b.n	34192e32 <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192dea:	f7ff fd49 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34192dee:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192df0:	68fa      	ldr	r2, [r7, #12]
34192df2:	68bb      	ldr	r3, [r7, #8]
34192df4:	fbb2 f3f3 	udiv	r3, r2, r3
34192df8:	60fb      	str	r3, [r7, #12]
            break;
34192dfa:	e01b      	b.n	34192e34 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192dfc:	f7ff fd86 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34192e00:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192e02:	68fa      	ldr	r2, [r7, #12]
34192e04:	68bb      	ldr	r3, [r7, #8]
34192e06:	fbb2 f3f3 	udiv	r3, r2, r3
34192e0a:	60fb      	str	r3, [r7, #12]
            break;
34192e0c:	e012      	b.n	34192e34 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192e0e:	f7ff fdc3 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34192e12:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192e14:	68fa      	ldr	r2, [r7, #12]
34192e16:	68bb      	ldr	r3, [r7, #8]
34192e18:	fbb2 f3f3 	udiv	r3, r2, r3
34192e1c:	60fb      	str	r3, [r7, #12]
            break;
34192e1e:	e009      	b.n	34192e34 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192e20:	f7ff fe00 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34192e24:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34192e26:	68fa      	ldr	r2, [r7, #12]
34192e28:	68bb      	ldr	r3, [r7, #8]
34192e2a:	fbb2 f3f3 	udiv	r3, r2, r3
34192e2e:	60fb      	str	r3, [r7, #12]
            break;
34192e30:	e000      	b.n	34192e34 <RCCEx_GetADCCLKFreq+0x188>
            break;
34192e32:	bf00      	nop
      break;
34192e34:	e026      	b.n	34192e84 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
34192e36:	f7fb faab 	bl	3418e390 <LL_RCC_HSI_IsReady>
34192e3a:	4603      	mov	r3, r0
34192e3c:	2b00      	cmp	r3, #0
34192e3e:	d023      	beq.n	34192e88 <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34192e40:	f7fb fab8 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34192e44:	4603      	mov	r3, r0
34192e46:	09db      	lsrs	r3, r3, #7
34192e48:	4a16      	ldr	r2, [pc, #88]	@ (34192ea4 <RCCEx_GetADCCLKFreq+0x1f8>)
34192e4a:	fa22 f303 	lsr.w	r3, r2, r3
34192e4e:	60fb      	str	r3, [r7, #12]
      break;
34192e50:	e01a      	b.n	34192e88 <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
34192e52:	f7fb fabd 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34192e56:	4603      	mov	r3, r0
34192e58:	2b00      	cmp	r3, #0
34192e5a:	d017      	beq.n	34192e8c <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
34192e5c:	4b12      	ldr	r3, [pc, #72]	@ (34192ea8 <RCCEx_GetADCCLKFreq+0x1fc>)
34192e5e:	60fb      	str	r3, [r7, #12]
      break;
34192e60:	e014      	b.n	34192e8c <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
34192e62:	4b12      	ldr	r3, [pc, #72]	@ (34192eac <RCCEx_GetADCCLKFreq+0x200>)
34192e64:	60fb      	str	r3, [r7, #12]
      break;
34192e66:	e012      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34192e68:	f7fa fe6a 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34192e6c:	4604      	mov	r4, r0
34192e6e:	f7fb fef7 	bl	3418ec60 <LL_RCC_GetTIMPrescaler>
34192e72:	4603      	mov	r3, r0
34192e74:	fa24 f303 	lsr.w	r3, r4, r3
34192e78:	60fb      	str	r3, [r7, #12]
      break;
34192e7a:	e008      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34192e7c:	bf00      	nop
34192e7e:	e006      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34192e80:	bf00      	nop
34192e82:	e004      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34192e84:	bf00      	nop
34192e86:	e002      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34192e88:	bf00      	nop
34192e8a:	e000      	b.n	34192e8e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34192e8c:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
34192e8e:	f7fb fb4f 	bl	3418e530 <LL_RCC_GetADCPrescaler>
34192e92:	4603      	mov	r3, r0
34192e94:	3301      	adds	r3, #1
34192e96:	68fa      	ldr	r2, [r7, #12]
34192e98:	fbb2 f3f3 	udiv	r3, r2, r3
}
34192e9c:	4618      	mov	r0, r3
34192e9e:	3714      	adds	r7, #20
34192ea0:	46bd      	mov	sp, r7
34192ea2:	bd90      	pop	{r4, r7, pc}
34192ea4:	03d09000 	.word	0x03d09000
34192ea8:	003d0900 	.word	0x003d0900
34192eac:	00bb8000 	.word	0x00bb8000

34192eb0 <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
34192eb0:	b590      	push	{r4, r7, lr}
34192eb2:	b085      	sub	sp, #20
34192eb4:	af00      	add	r7, sp, #0
34192eb6:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34192eb8:	2300      	movs	r3, #0
34192eba:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34192ebc:	6878      	ldr	r0, [r7, #4]
34192ebe:	f7fb fd2f 	bl	3418e920 <LL_RCC_GetADFClockSource>
34192ec2:	4603      	mov	r3, r0
34192ec4:	2b07      	cmp	r3, #7
34192ec6:	f200 80ca 	bhi.w	3419305e <RCCEx_GetADFCLKFreq+0x1ae>
34192eca:	a201      	add	r2, pc, #4	@ (adr r2, 34192ed0 <RCCEx_GetADFCLKFreq+0x20>)
34192ecc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34192ed0:	34192ef1 	.word	0x34192ef1
34192ed4:	34192f01 	.word	0x34192f01
34192ed8:	34192f0b 	.word	0x34192f0b
34192edc:	34192f93 	.word	0x34192f93
34192ee0:	34193035 	.word	0x34193035
34192ee4:	34193019 	.word	0x34193019
34192ee8:	34193045 	.word	0x34193045
34192eec:	3419304b 	.word	0x3419304b
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34192ef0:	f7fa fe26 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34192ef4:	4603      	mov	r3, r0
34192ef6:	4618      	mov	r0, r3
34192ef8:	f7ff fdda 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34192efc:	60f8      	str	r0, [r7, #12]
      break;
34192efe:	e0b7      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34192f00:	2007      	movs	r0, #7
34192f02:	f000 f8c1 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34192f06:	60f8      	str	r0, [r7, #12]
      break;
34192f08:	e0b2      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34192f0a:	f7fc f9e5 	bl	3418f2d8 <LL_RCC_IC7_IsEnabled>
34192f0e:	4603      	mov	r3, r0
34192f10:	2b00      	cmp	r3, #0
34192f12:	f000 80a6 	beq.w	34193062 <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34192f16:	f7fc fa01 	bl	3418f31c <LL_RCC_IC7_GetDivider>
34192f1a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34192f1c:	f7fc f9f0 	bl	3418f300 <LL_RCC_IC7_GetSource>
34192f20:	4603      	mov	r3, r0
34192f22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192f26:	d029      	beq.n	34192f7c <RCCEx_GetADFCLKFreq+0xcc>
34192f28:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192f2c:	d82f      	bhi.n	34192f8e <RCCEx_GetADFCLKFreq+0xde>
34192f2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192f32:	d01a      	beq.n	34192f6a <RCCEx_GetADFCLKFreq+0xba>
34192f34:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192f38:	d829      	bhi.n	34192f8e <RCCEx_GetADFCLKFreq+0xde>
34192f3a:	2b00      	cmp	r3, #0
34192f3c:	d003      	beq.n	34192f46 <RCCEx_GetADFCLKFreq+0x96>
34192f3e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192f42:	d009      	beq.n	34192f58 <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192f44:	e023      	b.n	34192f8e <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192f46:	f7ff fc9b 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34192f4a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192f4c:	68fa      	ldr	r2, [r7, #12]
34192f4e:	68bb      	ldr	r3, [r7, #8]
34192f50:	fbb2 f3f3 	udiv	r3, r2, r3
34192f54:	60fb      	str	r3, [r7, #12]
            break;
34192f56:	e01b      	b.n	34192f90 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192f58:	f7ff fcd8 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34192f5c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192f5e:	68fa      	ldr	r2, [r7, #12]
34192f60:	68bb      	ldr	r3, [r7, #8]
34192f62:	fbb2 f3f3 	udiv	r3, r2, r3
34192f66:	60fb      	str	r3, [r7, #12]
            break;
34192f68:	e012      	b.n	34192f90 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192f6a:	f7ff fd15 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34192f6e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192f70:	68fa      	ldr	r2, [r7, #12]
34192f72:	68bb      	ldr	r3, [r7, #8]
34192f74:	fbb2 f3f3 	udiv	r3, r2, r3
34192f78:	60fb      	str	r3, [r7, #12]
            break;
34192f7a:	e009      	b.n	34192f90 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34192f7c:	f7ff fd52 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34192f80:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192f82:	68fa      	ldr	r2, [r7, #12]
34192f84:	68bb      	ldr	r3, [r7, #8]
34192f86:	fbb2 f3f3 	udiv	r3, r2, r3
34192f8a:	60fb      	str	r3, [r7, #12]
            break;
34192f8c:	e000      	b.n	34192f90 <RCCEx_GetADFCLKFreq+0xe0>
            break;
34192f8e:	bf00      	nop
        }
      }
      break;
34192f90:	e067      	b.n	34193062 <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34192f92:	f7fc f9e1 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
34192f96:	4603      	mov	r3, r0
34192f98:	2b00      	cmp	r3, #0
34192f9a:	d064      	beq.n	34193066 <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34192f9c:	f7fc f9fe 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34192fa0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34192fa2:	f7fc f9ed 	bl	3418f380 <LL_RCC_IC8_GetSource>
34192fa6:	4603      	mov	r3, r0
34192fa8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192fac:	d029      	beq.n	34193002 <RCCEx_GetADFCLKFreq+0x152>
34192fae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34192fb2:	d82f      	bhi.n	34193014 <RCCEx_GetADFCLKFreq+0x164>
34192fb4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192fb8:	d01a      	beq.n	34192ff0 <RCCEx_GetADFCLKFreq+0x140>
34192fba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34192fbe:	d829      	bhi.n	34193014 <RCCEx_GetADFCLKFreq+0x164>
34192fc0:	2b00      	cmp	r3, #0
34192fc2:	d003      	beq.n	34192fcc <RCCEx_GetADFCLKFreq+0x11c>
34192fc4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34192fc8:	d009      	beq.n	34192fde <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34192fca:	e023      	b.n	34193014 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34192fcc:	f7ff fc58 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34192fd0:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192fd2:	68fa      	ldr	r2, [r7, #12]
34192fd4:	68bb      	ldr	r3, [r7, #8]
34192fd6:	fbb2 f3f3 	udiv	r3, r2, r3
34192fda:	60fb      	str	r3, [r7, #12]
            break;
34192fdc:	e01b      	b.n	34193016 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34192fde:	f7ff fc95 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34192fe2:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192fe4:	68fa      	ldr	r2, [r7, #12]
34192fe6:	68bb      	ldr	r3, [r7, #8]
34192fe8:	fbb2 f3f3 	udiv	r3, r2, r3
34192fec:	60fb      	str	r3, [r7, #12]
            break;
34192fee:	e012      	b.n	34193016 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34192ff0:	f7ff fcd2 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34192ff4:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34192ff6:	68fa      	ldr	r2, [r7, #12]
34192ff8:	68bb      	ldr	r3, [r7, #8]
34192ffa:	fbb2 f3f3 	udiv	r3, r2, r3
34192ffe:	60fb      	str	r3, [r7, #12]
            break;
34193000:	e009      	b.n	34193016 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193002:	f7ff fd0f 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193006:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34193008:	68fa      	ldr	r2, [r7, #12]
3419300a:	68bb      	ldr	r3, [r7, #8]
3419300c:	fbb2 f3f3 	udiv	r3, r2, r3
34193010:	60fb      	str	r3, [r7, #12]
            break;
34193012:	e000      	b.n	34193016 <RCCEx_GetADFCLKFreq+0x166>
            break;
34193014:	bf00      	nop
        }
      }
      break;
34193016:	e026      	b.n	34193066 <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34193018:	f7fb f9ba 	bl	3418e390 <LL_RCC_HSI_IsReady>
3419301c:	4603      	mov	r3, r0
3419301e:	2b00      	cmp	r3, #0
34193020:	d023      	beq.n	3419306a <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193022:	f7fb f9c7 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34193026:	4603      	mov	r3, r0
34193028:	09db      	lsrs	r3, r3, #7
3419302a:	4a14      	ldr	r2, [pc, #80]	@ (3419307c <RCCEx_GetADFCLKFreq+0x1cc>)
3419302c:	fa22 f303 	lsr.w	r3, r2, r3
34193030:	60fb      	str	r3, [r7, #12]
      }
      break;
34193032:	e01a      	b.n	3419306a <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34193034:	f7fb f9cc 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34193038:	4603      	mov	r3, r0
3419303a:	2b00      	cmp	r3, #0
3419303c:	d017      	beq.n	3419306e <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
3419303e:	4b10      	ldr	r3, [pc, #64]	@ (34193080 <RCCEx_GetADFCLKFreq+0x1d0>)
34193040:	60fb      	str	r3, [r7, #12]
      }
      break;
34193042:	e014      	b.n	3419306e <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34193044:	4b0f      	ldr	r3, [pc, #60]	@ (34193084 <RCCEx_GetADFCLKFreq+0x1d4>)
34193046:	60fb      	str	r3, [r7, #12]
      break;
34193048:	e012      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3419304a:	f7fa fd79 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
3419304e:	4604      	mov	r4, r0
34193050:	f7fb fe06 	bl	3418ec60 <LL_RCC_GetTIMPrescaler>
34193054:	4603      	mov	r3, r0
34193056:	fa24 f303 	lsr.w	r3, r4, r3
3419305a:	60fb      	str	r3, [r7, #12]
      break;
3419305c:	e008      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
3419305e:	bf00      	nop
34193060:	e006      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34193062:	bf00      	nop
34193064:	e004      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34193066:	bf00      	nop
34193068:	e002      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3419306a:	bf00      	nop
3419306c:	e000      	b.n	34193070 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3419306e:	bf00      	nop
  }

  return adf_frequency;
34193070:	68fb      	ldr	r3, [r7, #12]
}
34193072:	4618      	mov	r0, r3
34193074:	3714      	adds	r7, #20
34193076:	46bd      	mov	sp, r7
34193078:	bd90      	pop	{r4, r7, pc}
3419307a:	bf00      	nop
3419307c:	03d09000 	.word	0x03d09000
34193080:	003d0900 	.word	0x003d0900
34193084:	00bb8000 	.word	0x00bb8000

34193088 <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
34193088:	b580      	push	{r7, lr}
3419308a:	b084      	sub	sp, #16
3419308c:	af00      	add	r7, sp, #0
3419308e:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34193090:	2300      	movs	r3, #0
34193092:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
34193094:	f7fc fc60 	bl	3418f958 <LL_RCC_CLKP_IsEnabled>
34193098:	4603      	mov	r3, r0
3419309a:	2b01      	cmp	r3, #1
3419309c:	f040 81a5 	bne.w	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
341930a0:	6878      	ldr	r0, [r7, #4]
341930a2:	f7fb fc4f 	bl	3418e944 <LL_RCC_GetCLKPClockSource>
341930a6:	4603      	mov	r3, r0
341930a8:	2b07      	cmp	r3, #7
341930aa:	f200 818d 	bhi.w	341933c8 <RCCEx_GetCLKPCLKFreq+0x340>
341930ae:	a201      	add	r2, pc, #4	@ (adr r2, 341930b4 <RCCEx_GetCLKPCLKFreq+0x2c>)
341930b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341930b4:	341930d5 	.word	0x341930d5
341930b8:	341930f3 	.word	0x341930f3
341930bc:	34193105 	.word	0x34193105
341930c0:	341932af 	.word	0x341932af
341930c4:	34193117 	.word	0x34193117
341930c8:	3419319f 	.word	0x3419319f
341930cc:	34193227 	.word	0x34193227
341930d0:	34193337 	.word	0x34193337
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
341930d4:	f7fb f95c 	bl	3418e390 <LL_RCC_HSI_IsReady>
341930d8:	4603      	mov	r3, r0
341930da:	2b00      	cmp	r3, #0
341930dc:	f000 8176 	beq.w	341933cc <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341930e0:	f7fb f968 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
341930e4:	4603      	mov	r3, r0
341930e6:	09db      	lsrs	r3, r3, #7
341930e8:	4aa1      	ldr	r2, [pc, #644]	@ (34193370 <RCCEx_GetCLKPCLKFreq+0x2e8>)
341930ea:	fa22 f303 	lsr.w	r3, r2, r3
341930ee:	60fb      	str	r3, [r7, #12]
        }
        break;
341930f0:	e16c      	b.n	341933cc <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
341930f2:	f7fb f96d 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
341930f6:	4603      	mov	r3, r0
341930f8:	2b00      	cmp	r3, #0
341930fa:	f000 8169 	beq.w	341933d0 <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
341930fe:	4b9d      	ldr	r3, [pc, #628]	@ (34193374 <RCCEx_GetCLKPCLKFreq+0x2ec>)
34193100:	60fb      	str	r3, [r7, #12]
        }
        break;
34193102:	e165      	b.n	341933d0 <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
34193104:	f7fb f932 	bl	3418e36c <LL_RCC_HSE_IsReady>
34193108:	4603      	mov	r3, r0
3419310a:	2b00      	cmp	r3, #0
3419310c:	f000 8162 	beq.w	341933d4 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
34193110:	4b99      	ldr	r3, [pc, #612]	@ (34193378 <RCCEx_GetCLKPCLKFreq+0x2f0>)
34193112:	60fb      	str	r3, [r7, #12]
        }
        break;
34193114:	e15e      	b.n	341933d4 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
34193116:	f7fc f89f 	bl	3418f258 <LL_RCC_IC5_IsEnabled>
3419311a:	4603      	mov	r3, r0
3419311c:	2b00      	cmp	r3, #0
3419311e:	f000 815b 	beq.w	341933d8 <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
34193122:	f7fc f8bb 	bl	3418f29c <LL_RCC_IC5_GetDivider>
34193126:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
34193128:	f7fc f8aa 	bl	3418f280 <LL_RCC_IC5_GetSource>
3419312c:	4603      	mov	r3, r0
3419312e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193132:	d029      	beq.n	34193188 <RCCEx_GetCLKPCLKFreq+0x100>
34193134:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193138:	d82f      	bhi.n	3419319a <RCCEx_GetCLKPCLKFreq+0x112>
3419313a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419313e:	d01a      	beq.n	34193176 <RCCEx_GetCLKPCLKFreq+0xee>
34193140:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193144:	d829      	bhi.n	3419319a <RCCEx_GetCLKPCLKFreq+0x112>
34193146:	2b00      	cmp	r3, #0
34193148:	d003      	beq.n	34193152 <RCCEx_GetCLKPCLKFreq+0xca>
3419314a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419314e:	d009      	beq.n	34193164 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34193150:	e023      	b.n	3419319a <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193152:	f7ff fb95 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193156:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193158:	68fa      	ldr	r2, [r7, #12]
3419315a:	68bb      	ldr	r3, [r7, #8]
3419315c:	fbb2 f3f3 	udiv	r3, r2, r3
34193160:	60fb      	str	r3, [r7, #12]
              break;
34193162:	e01b      	b.n	3419319c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193164:	f7ff fbd2 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193168:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419316a:	68fa      	ldr	r2, [r7, #12]
3419316c:	68bb      	ldr	r3, [r7, #8]
3419316e:	fbb2 f3f3 	udiv	r3, r2, r3
34193172:	60fb      	str	r3, [r7, #12]
              break;
34193174:	e012      	b.n	3419319c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193176:	f7ff fc0f 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419317a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419317c:	68fa      	ldr	r2, [r7, #12]
3419317e:	68bb      	ldr	r3, [r7, #8]
34193180:	fbb2 f3f3 	udiv	r3, r2, r3
34193184:	60fb      	str	r3, [r7, #12]
              break;
34193186:	e009      	b.n	3419319c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193188:	f7ff fc4c 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419318c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419318e:	68fa      	ldr	r2, [r7, #12]
34193190:	68bb      	ldr	r3, [r7, #8]
34193192:	fbb2 f3f3 	udiv	r3, r2, r3
34193196:	60fb      	str	r3, [r7, #12]
              break;
34193198:	e000      	b.n	3419319c <RCCEx_GetCLKPCLKFreq+0x114>
              break;
3419319a:	bf00      	nop
          }
        }
        break;
3419319c:	e11c      	b.n	341933d8 <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
3419319e:	f7fc f95b 	bl	3418f458 <LL_RCC_IC10_IsEnabled>
341931a2:	4603      	mov	r3, r0
341931a4:	2b00      	cmp	r3, #0
341931a6:	f000 8119 	beq.w	341933dc <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
341931aa:	f7fc f977 	bl	3418f49c <LL_RCC_IC10_GetDivider>
341931ae:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
341931b0:	f7fc f966 	bl	3418f480 <LL_RCC_IC10_GetSource>
341931b4:	4603      	mov	r3, r0
341931b6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341931ba:	d029      	beq.n	34193210 <RCCEx_GetCLKPCLKFreq+0x188>
341931bc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341931c0:	d82f      	bhi.n	34193222 <RCCEx_GetCLKPCLKFreq+0x19a>
341931c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341931c6:	d01a      	beq.n	341931fe <RCCEx_GetCLKPCLKFreq+0x176>
341931c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341931cc:	d829      	bhi.n	34193222 <RCCEx_GetCLKPCLKFreq+0x19a>
341931ce:	2b00      	cmp	r3, #0
341931d0:	d003      	beq.n	341931da <RCCEx_GetCLKPCLKFreq+0x152>
341931d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341931d6:	d009      	beq.n	341931ec <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
341931d8:	e023      	b.n	34193222 <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341931da:	f7ff fb51 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341931de:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
341931e0:	68fa      	ldr	r2, [r7, #12]
341931e2:	68bb      	ldr	r3, [r7, #8]
341931e4:	fbb2 f3f3 	udiv	r3, r2, r3
341931e8:	60fb      	str	r3, [r7, #12]
              break;
341931ea:	e01b      	b.n	34193224 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341931ec:	f7ff fb8e 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341931f0:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
341931f2:	68fa      	ldr	r2, [r7, #12]
341931f4:	68bb      	ldr	r3, [r7, #8]
341931f6:	fbb2 f3f3 	udiv	r3, r2, r3
341931fa:	60fb      	str	r3, [r7, #12]
              break;
341931fc:	e012      	b.n	34193224 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341931fe:	f7ff fbcb 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193202:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193204:	68fa      	ldr	r2, [r7, #12]
34193206:	68bb      	ldr	r3, [r7, #8]
34193208:	fbb2 f3f3 	udiv	r3, r2, r3
3419320c:	60fb      	str	r3, [r7, #12]
              break;
3419320e:	e009      	b.n	34193224 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193210:	f7ff fc08 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193214:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193216:	68fa      	ldr	r2, [r7, #12]
34193218:	68bb      	ldr	r3, [r7, #8]
3419321a:	fbb2 f3f3 	udiv	r3, r2, r3
3419321e:	60fb      	str	r3, [r7, #12]
              break;
34193220:	e000      	b.n	34193224 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
34193222:	bf00      	nop
          }
        }
        break;
34193224:	e0da      	b.n	341933dc <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
34193226:	f7fc fa17 	bl	3418f658 <LL_RCC_IC15_IsEnabled>
3419322a:	4603      	mov	r3, r0
3419322c:	2b00      	cmp	r3, #0
3419322e:	f000 80d7 	beq.w	341933e0 <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
34193232:	f7fc fa33 	bl	3418f69c <LL_RCC_IC15_GetDivider>
34193236:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
34193238:	f7fc fa22 	bl	3418f680 <LL_RCC_IC15_GetSource>
3419323c:	4603      	mov	r3, r0
3419323e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193242:	d029      	beq.n	34193298 <RCCEx_GetCLKPCLKFreq+0x210>
34193244:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193248:	d82f      	bhi.n	341932aa <RCCEx_GetCLKPCLKFreq+0x222>
3419324a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419324e:	d01a      	beq.n	34193286 <RCCEx_GetCLKPCLKFreq+0x1fe>
34193250:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193254:	d829      	bhi.n	341932aa <RCCEx_GetCLKPCLKFreq+0x222>
34193256:	2b00      	cmp	r3, #0
34193258:	d003      	beq.n	34193262 <RCCEx_GetCLKPCLKFreq+0x1da>
3419325a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419325e:	d009      	beq.n	34193274 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34193260:	e023      	b.n	341932aa <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193262:	f7ff fb0d 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193266:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193268:	68fa      	ldr	r2, [r7, #12]
3419326a:	68bb      	ldr	r3, [r7, #8]
3419326c:	fbb2 f3f3 	udiv	r3, r2, r3
34193270:	60fb      	str	r3, [r7, #12]
              break;
34193272:	e01b      	b.n	341932ac <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193274:	f7ff fb4a 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193278:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419327a:	68fa      	ldr	r2, [r7, #12]
3419327c:	68bb      	ldr	r3, [r7, #8]
3419327e:	fbb2 f3f3 	udiv	r3, r2, r3
34193282:	60fb      	str	r3, [r7, #12]
              break;
34193284:	e012      	b.n	341932ac <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193286:	f7ff fb87 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419328a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419328c:	68fa      	ldr	r2, [r7, #12]
3419328e:	68bb      	ldr	r3, [r7, #8]
34193290:	fbb2 f3f3 	udiv	r3, r2, r3
34193294:	60fb      	str	r3, [r7, #12]
              break;
34193296:	e009      	b.n	341932ac <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193298:	f7ff fbc4 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419329c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3419329e:	68fa      	ldr	r2, [r7, #12]
341932a0:	68bb      	ldr	r3, [r7, #8]
341932a2:	fbb2 f3f3 	udiv	r3, r2, r3
341932a6:	60fb      	str	r3, [r7, #12]
              break;
341932a8:	e000      	b.n	341932ac <RCCEx_GetCLKPCLKFreq+0x224>
              break;
341932aa:	bf00      	nop
          }
        }
        break;
341932ac:	e098      	b.n	341933e0 <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
341932ae:	f7fc fad3 	bl	3418f858 <LL_RCC_IC19_IsEnabled>
341932b2:	4603      	mov	r3, r0
341932b4:	2b00      	cmp	r3, #0
341932b6:	f000 8095 	beq.w	341933e4 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
341932ba:	f7fc faef 	bl	3418f89c <LL_RCC_IC19_GetDivider>
341932be:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
341932c0:	f7fc fade 	bl	3418f880 <LL_RCC_IC19_GetSource>
341932c4:	4603      	mov	r3, r0
341932c6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341932ca:	d029      	beq.n	34193320 <RCCEx_GetCLKPCLKFreq+0x298>
341932cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341932d0:	d82f      	bhi.n	34193332 <RCCEx_GetCLKPCLKFreq+0x2aa>
341932d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341932d6:	d01a      	beq.n	3419330e <RCCEx_GetCLKPCLKFreq+0x286>
341932d8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341932dc:	d829      	bhi.n	34193332 <RCCEx_GetCLKPCLKFreq+0x2aa>
341932de:	2b00      	cmp	r3, #0
341932e0:	d003      	beq.n	341932ea <RCCEx_GetCLKPCLKFreq+0x262>
341932e2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341932e6:	d009      	beq.n	341932fc <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
341932e8:	e023      	b.n	34193332 <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341932ea:	f7ff fac9 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341932ee:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
341932f0:	68fa      	ldr	r2, [r7, #12]
341932f2:	68bb      	ldr	r3, [r7, #8]
341932f4:	fbb2 f3f3 	udiv	r3, r2, r3
341932f8:	60fb      	str	r3, [r7, #12]
              break;
341932fa:	e01b      	b.n	34193334 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341932fc:	f7ff fb06 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193300:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193302:	68fa      	ldr	r2, [r7, #12]
34193304:	68bb      	ldr	r3, [r7, #8]
34193306:	fbb2 f3f3 	udiv	r3, r2, r3
3419330a:	60fb      	str	r3, [r7, #12]
              break;
3419330c:	e012      	b.n	34193334 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3419330e:	f7ff fb43 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193312:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193314:	68fa      	ldr	r2, [r7, #12]
34193316:	68bb      	ldr	r3, [r7, #8]
34193318:	fbb2 f3f3 	udiv	r3, r2, r3
3419331c:	60fb      	str	r3, [r7, #12]
              break;
3419331e:	e009      	b.n	34193334 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193320:	f7ff fb80 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193324:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193326:	68fa      	ldr	r2, [r7, #12]
34193328:	68bb      	ldr	r3, [r7, #8]
3419332a:	fbb2 f3f3 	udiv	r3, r2, r3
3419332e:	60fb      	str	r3, [r7, #12]
              break;
34193330:	e000      	b.n	34193334 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
34193332:	bf00      	nop
          }
        }
        break;
34193334:	e056      	b.n	341933e4 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
34193336:	f7fc facf 	bl	3418f8d8 <LL_RCC_IC20_IsEnabled>
3419333a:	4603      	mov	r3, r0
3419333c:	2b00      	cmp	r3, #0
3419333e:	d053      	beq.n	341933e8 <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
34193340:	f7fc faec 	bl	3418f91c <LL_RCC_IC20_GetDivider>
34193344:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
34193346:	f7fc fadb 	bl	3418f900 <LL_RCC_IC20_GetSource>
3419334a:	4603      	mov	r3, r0
3419334c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193350:	d02f      	beq.n	341933b2 <RCCEx_GetCLKPCLKFreq+0x32a>
34193352:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193356:	d835      	bhi.n	341933c4 <RCCEx_GetCLKPCLKFreq+0x33c>
34193358:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419335c:	d020      	beq.n	341933a0 <RCCEx_GetCLKPCLKFreq+0x318>
3419335e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193362:	d82f      	bhi.n	341933c4 <RCCEx_GetCLKPCLKFreq+0x33c>
34193364:	2b00      	cmp	r3, #0
34193366:	d009      	beq.n	3419337c <RCCEx_GetCLKPCLKFreq+0x2f4>
34193368:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419336c:	d00f      	beq.n	3419338e <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3419336e:	e029      	b.n	341933c4 <RCCEx_GetCLKPCLKFreq+0x33c>
34193370:	03d09000 	.word	0x03d09000
34193374:	003d0900 	.word	0x003d0900
34193378:	02dc6c00 	.word	0x02dc6c00
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419337c:	f7ff fa80 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193380:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193382:	68fa      	ldr	r2, [r7, #12]
34193384:	68bb      	ldr	r3, [r7, #8]
34193386:	fbb2 f3f3 	udiv	r3, r2, r3
3419338a:	60fb      	str	r3, [r7, #12]
              break;
3419338c:	e01b      	b.n	341933c6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419338e:	f7ff fabd 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193392:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34193394:	68fa      	ldr	r2, [r7, #12]
34193396:	68bb      	ldr	r3, [r7, #8]
34193398:	fbb2 f3f3 	udiv	r3, r2, r3
3419339c:	60fb      	str	r3, [r7, #12]
              break;
3419339e:	e012      	b.n	341933c6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341933a0:	f7ff fafa 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341933a4:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
341933a6:	68fa      	ldr	r2, [r7, #12]
341933a8:	68bb      	ldr	r3, [r7, #8]
341933aa:	fbb2 f3f3 	udiv	r3, r2, r3
341933ae:	60fb      	str	r3, [r7, #12]
              break;
341933b0:	e009      	b.n	341933c6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341933b2:	f7ff fb37 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341933b6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
341933b8:	68fa      	ldr	r2, [r7, #12]
341933ba:	68bb      	ldr	r3, [r7, #8]
341933bc:	fbb2 f3f3 	udiv	r3, r2, r3
341933c0:	60fb      	str	r3, [r7, #12]
              break;
341933c2:	e000      	b.n	341933c6 <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
341933c4:	bf00      	nop
          }
        }
        break;
341933c6:	e00f      	b.n	341933e8 <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
341933c8:	bf00      	nop
341933ca:	e00e      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933cc:	bf00      	nop
341933ce:	e00c      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933d0:	bf00      	nop
341933d2:	e00a      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933d4:	bf00      	nop
341933d6:	e008      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933d8:	bf00      	nop
341933da:	e006      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933dc:	bf00      	nop
341933de:	e004      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933e0:	bf00      	nop
341933e2:	e002      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933e4:	bf00      	nop
341933e6:	e000      	b.n	341933ea <RCCEx_GetCLKPCLKFreq+0x362>
        break;
341933e8:	bf00      	nop
    }
  }

  return clkp_frequency;
341933ea:	68fb      	ldr	r3, [r7, #12]
}
341933ec:	4618      	mov	r0, r3
341933ee:	3710      	adds	r7, #16
341933f0:	46bd      	mov	sp, r7
341933f2:	bd80      	pop	{r7, pc}

341933f4 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
341933f4:	b580      	push	{r7, lr}
341933f6:	b082      	sub	sp, #8
341933f8:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
341933fa:	2300      	movs	r3, #0
341933fc:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
341933fe:	f7fc f9eb 	bl	3418f7d8 <LL_RCC_IC18_IsEnabled>
34193402:	4603      	mov	r3, r0
34193404:	2b00      	cmp	r3, #0
34193406:	d03c      	beq.n	34193482 <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
34193408:	f7fc fa08 	bl	3418f81c <LL_RCC_IC18_GetDivider>
3419340c:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
3419340e:	f7fc f9f7 	bl	3418f800 <LL_RCC_IC18_GetSource>
34193412:	4603      	mov	r3, r0
34193414:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193418:	d029      	beq.n	3419346e <RCCEx_GetCSICLKFreq+0x7a>
3419341a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419341e:	d82f      	bhi.n	34193480 <RCCEx_GetCSICLKFreq+0x8c>
34193420:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193424:	d01a      	beq.n	3419345c <RCCEx_GetCSICLKFreq+0x68>
34193426:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419342a:	d829      	bhi.n	34193480 <RCCEx_GetCSICLKFreq+0x8c>
3419342c:	2b00      	cmp	r3, #0
3419342e:	d003      	beq.n	34193438 <RCCEx_GetCSICLKFreq+0x44>
34193430:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193434:	d009      	beq.n	3419344a <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
34193436:	e023      	b.n	34193480 <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193438:	f7ff fa22 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
3419343c:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
3419343e:	687a      	ldr	r2, [r7, #4]
34193440:	683b      	ldr	r3, [r7, #0]
34193442:	fbb2 f3f3 	udiv	r3, r2, r3
34193446:	607b      	str	r3, [r7, #4]
        break;
34193448:	e01b      	b.n	34193482 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419344a:	f7ff fa5f 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3419344e:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34193450:	687a      	ldr	r2, [r7, #4]
34193452:	683b      	ldr	r3, [r7, #0]
34193454:	fbb2 f3f3 	udiv	r3, r2, r3
34193458:	607b      	str	r3, [r7, #4]
        break;
3419345a:	e012      	b.n	34193482 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3419345c:	f7ff fa9c 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193460:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34193462:	687a      	ldr	r2, [r7, #4]
34193464:	683b      	ldr	r3, [r7, #0]
34193466:	fbb2 f3f3 	udiv	r3, r2, r3
3419346a:	607b      	str	r3, [r7, #4]
        break;
3419346c:	e009      	b.n	34193482 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419346e:	f7ff fad9 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193472:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34193474:	687a      	ldr	r2, [r7, #4]
34193476:	683b      	ldr	r3, [r7, #0]
34193478:	fbb2 f3f3 	udiv	r3, r2, r3
3419347c:	607b      	str	r3, [r7, #4]
        break;
3419347e:	e000      	b.n	34193482 <RCCEx_GetCSICLKFreq+0x8e>
        break;
34193480:	bf00      	nop
    }
  }

  return clkp_frequency;
34193482:	687b      	ldr	r3, [r7, #4]
}
34193484:	4618      	mov	r0, r3
34193486:	3708      	adds	r7, #8
34193488:	46bd      	mov	sp, r7
3419348a:	bd80      	pop	{r7, pc}

3419348c <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
3419348c:	b580      	push	{r7, lr}
3419348e:	b084      	sub	sp, #16
34193490:	af00      	add	r7, sp, #0
34193492:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
34193494:	2300      	movs	r3, #0
34193496:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
34193498:	6878      	ldr	r0, [r7, #4]
3419349a:	f7fb fa65 	bl	3418e968 <LL_RCC_GetDCMIPPClockSource>
3419349e:	4603      	mov	r3, r0
341934a0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341934a4:	d062      	beq.n	3419356c <RCCEx_GetDCMIPPCLKFreq+0xe0>
341934a6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
341934aa:	d86d      	bhi.n	34193588 <RCCEx_GetDCMIPPCLKFreq+0xfc>
341934ac:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341934b0:	d019      	beq.n	341934e6 <RCCEx_GetDCMIPPCLKFreq+0x5a>
341934b2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341934b6:	d867      	bhi.n	34193588 <RCCEx_GetDCMIPPCLKFreq+0xfc>
341934b8:	2b00      	cmp	r3, #0
341934ba:	d003      	beq.n	341934c4 <RCCEx_GetDCMIPPCLKFreq+0x38>
341934bc:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341934c0:	d00c      	beq.n	341934dc <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
341934c2:	e061      	b.n	34193588 <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341934c4:	f7fa fb3c 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341934c8:	4603      	mov	r3, r0
341934ca:	4618      	mov	r0, r3
341934cc:	f7ff faf0 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341934d0:	4603      	mov	r3, r0
341934d2:	4618      	mov	r0, r3
341934d4:	f7ff fb2f 	bl	34192b36 <RCCEx_GetPCLK5Freq>
341934d8:	60f8      	str	r0, [r7, #12]
      break;
341934da:	e05a      	b.n	34193592 <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341934dc:	2007      	movs	r0, #7
341934de:	f7ff fdd3 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341934e2:	60f8      	str	r0, [r7, #12]
      break;
341934e4:	e055      	b.n	34193592 <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
341934e6:	f7fc f937 	bl	3418f758 <LL_RCC_IC17_IsEnabled>
341934ea:	4603      	mov	r3, r0
341934ec:	2b00      	cmp	r3, #0
341934ee:	d04d      	beq.n	3419358c <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
341934f0:	f7fc f954 	bl	3418f79c <LL_RCC_IC17_GetDivider>
341934f4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
341934f6:	f7fc f943 	bl	3418f780 <LL_RCC_IC17_GetSource>
341934fa:	4603      	mov	r3, r0
341934fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193500:	d029      	beq.n	34193556 <RCCEx_GetDCMIPPCLKFreq+0xca>
34193502:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193506:	d82f      	bhi.n	34193568 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34193508:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419350c:	d01a      	beq.n	34193544 <RCCEx_GetDCMIPPCLKFreq+0xb8>
3419350e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193512:	d829      	bhi.n	34193568 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34193514:	2b00      	cmp	r3, #0
34193516:	d003      	beq.n	34193520 <RCCEx_GetDCMIPPCLKFreq+0x94>
34193518:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419351c:	d009      	beq.n	34193532 <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
3419351e:	e023      	b.n	34193568 <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193520:	f7ff f9ae 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193524:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34193526:	68fa      	ldr	r2, [r7, #12]
34193528:	68bb      	ldr	r3, [r7, #8]
3419352a:	fbb2 f3f3 	udiv	r3, r2, r3
3419352e:	60fb      	str	r3, [r7, #12]
            break;
34193530:	e01b      	b.n	3419356a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193532:	f7ff f9eb 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193536:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34193538:	68fa      	ldr	r2, [r7, #12]
3419353a:	68bb      	ldr	r3, [r7, #8]
3419353c:	fbb2 f3f3 	udiv	r3, r2, r3
34193540:	60fb      	str	r3, [r7, #12]
            break;
34193542:	e012      	b.n	3419356a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193544:	f7ff fa28 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193548:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
3419354a:	68fa      	ldr	r2, [r7, #12]
3419354c:	68bb      	ldr	r3, [r7, #8]
3419354e:	fbb2 f3f3 	udiv	r3, r2, r3
34193552:	60fb      	str	r3, [r7, #12]
            break;
34193554:	e009      	b.n	3419356a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193556:	f7ff fa65 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419355a:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
3419355c:	68fa      	ldr	r2, [r7, #12]
3419355e:	68bb      	ldr	r3, [r7, #8]
34193560:	fbb2 f3f3 	udiv	r3, r2, r3
34193564:	60fb      	str	r3, [r7, #12]
            break;
34193566:	e000      	b.n	3419356a <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
34193568:	bf00      	nop
      break;
3419356a:	e00f      	b.n	3419358c <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
3419356c:	f7fa ff10 	bl	3418e390 <LL_RCC_HSI_IsReady>
34193570:	4603      	mov	r3, r0
34193572:	2b00      	cmp	r3, #0
34193574:	d00c      	beq.n	34193590 <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193576:	f7fa ff1d 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
3419357a:	4603      	mov	r3, r0
3419357c:	09db      	lsrs	r3, r3, #7
3419357e:	4a07      	ldr	r2, [pc, #28]	@ (3419359c <RCCEx_GetDCMIPPCLKFreq+0x110>)
34193580:	fa22 f303 	lsr.w	r3, r2, r3
34193584:	60fb      	str	r3, [r7, #12]
      break;
34193586:	e003      	b.n	34193590 <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
34193588:	bf00      	nop
3419358a:	e002      	b.n	34193592 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
3419358c:	bf00      	nop
3419358e:	e000      	b.n	34193592 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34193590:	bf00      	nop
  }

  return dcmipp_frequency;
34193592:	68fb      	ldr	r3, [r7, #12]
}
34193594:	4618      	mov	r0, r3
34193596:	3710      	adds	r7, #16
34193598:	46bd      	mov	sp, r7
3419359a:	bd80      	pop	{r7, pc}
3419359c:	03d09000 	.word	0x03d09000

341935a0 <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
341935a0:	b580      	push	{r7, lr}
341935a2:	b084      	sub	sp, #16
341935a4:	af00      	add	r7, sp, #0
341935a6:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
341935a8:	2300      	movs	r3, #0
341935aa:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
341935ac:	6878      	ldr	r0, [r7, #4]
341935ae:	f7fb f9ed 	bl	3418e98c <LL_RCC_GetETHClockSource>
341935b2:	4603      	mov	r3, r0
341935b4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
341935b8:	d05e      	beq.n	34193678 <RCCEx_GetETH1CLKFreq+0xd8>
341935ba:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
341935be:	d863      	bhi.n	34193688 <RCCEx_GetETH1CLKFreq+0xe8>
341935c0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
341935c4:	d015      	beq.n	341935f2 <RCCEx_GetETH1CLKFreq+0x52>
341935c6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
341935ca:	d85d      	bhi.n	34193688 <RCCEx_GetETH1CLKFreq+0xe8>
341935cc:	2b00      	cmp	r3, #0
341935ce:	d003      	beq.n	341935d8 <RCCEx_GetETH1CLKFreq+0x38>
341935d0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
341935d4:	d008      	beq.n	341935e8 <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
341935d6:	e057      	b.n	34193688 <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
341935d8:	f7fa fab2 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341935dc:	4603      	mov	r3, r0
341935de:	4618      	mov	r0, r3
341935e0:	f7ff fa66 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341935e4:	60f8      	str	r0, [r7, #12]
      break;
341935e6:	e054      	b.n	34193692 <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341935e8:	2007      	movs	r0, #7
341935ea:	f7ff fd4d 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341935ee:	60f8      	str	r0, [r7, #12]
      break;
341935f0:	e04f      	b.n	34193692 <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
341935f2:	f7fb ff71 	bl	3418f4d8 <LL_RCC_IC12_IsEnabled>
341935f6:	4603      	mov	r3, r0
341935f8:	2b00      	cmp	r3, #0
341935fa:	d047      	beq.n	3419368c <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
341935fc:	f7fb ff8e 	bl	3418f51c <LL_RCC_IC12_GetDivider>
34193600:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
34193602:	f7fb ff7d 	bl	3418f500 <LL_RCC_IC12_GetSource>
34193606:	4603      	mov	r3, r0
34193608:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419360c:	d029      	beq.n	34193662 <RCCEx_GetETH1CLKFreq+0xc2>
3419360e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193612:	d82f      	bhi.n	34193674 <RCCEx_GetETH1CLKFreq+0xd4>
34193614:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193618:	d01a      	beq.n	34193650 <RCCEx_GetETH1CLKFreq+0xb0>
3419361a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419361e:	d829      	bhi.n	34193674 <RCCEx_GetETH1CLKFreq+0xd4>
34193620:	2b00      	cmp	r3, #0
34193622:	d003      	beq.n	3419362c <RCCEx_GetETH1CLKFreq+0x8c>
34193624:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193628:	d009      	beq.n	3419363e <RCCEx_GetETH1CLKFreq+0x9e>
            break;
3419362a:	e023      	b.n	34193674 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419362c:	f7ff f928 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193630:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34193632:	68fa      	ldr	r2, [r7, #12]
34193634:	68bb      	ldr	r3, [r7, #8]
34193636:	fbb2 f3f3 	udiv	r3, r2, r3
3419363a:	60fb      	str	r3, [r7, #12]
            break;
3419363c:	e01b      	b.n	34193676 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419363e:	f7ff f965 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193642:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34193644:	68fa      	ldr	r2, [r7, #12]
34193646:	68bb      	ldr	r3, [r7, #8]
34193648:	fbb2 f3f3 	udiv	r3, r2, r3
3419364c:	60fb      	str	r3, [r7, #12]
            break;
3419364e:	e012      	b.n	34193676 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193650:	f7ff f9a2 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193654:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34193656:	68fa      	ldr	r2, [r7, #12]
34193658:	68bb      	ldr	r3, [r7, #8]
3419365a:	fbb2 f3f3 	udiv	r3, r2, r3
3419365e:	60fb      	str	r3, [r7, #12]
            break;
34193660:	e009      	b.n	34193676 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193662:	f7ff f9df 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193666:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34193668:	68fa      	ldr	r2, [r7, #12]
3419366a:	68bb      	ldr	r3, [r7, #8]
3419366c:	fbb2 f3f3 	udiv	r3, r2, r3
34193670:	60fb      	str	r3, [r7, #12]
            break;
34193672:	e000      	b.n	34193676 <RCCEx_GetETH1CLKFreq+0xd6>
            break;
34193674:	bf00      	nop
      break;
34193676:	e009      	b.n	3419368c <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
34193678:	f7fa fe78 	bl	3418e36c <LL_RCC_HSE_IsReady>
3419367c:	4603      	mov	r3, r0
3419367e:	2b00      	cmp	r3, #0
34193680:	d006      	beq.n	34193690 <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
34193682:	4b06      	ldr	r3, [pc, #24]	@ (3419369c <RCCEx_GetETH1CLKFreq+0xfc>)
34193684:	60fb      	str	r3, [r7, #12]
      break;
34193686:	e003      	b.n	34193690 <RCCEx_GetETH1CLKFreq+0xf0>
      break;
34193688:	bf00      	nop
3419368a:	e002      	b.n	34193692 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
3419368c:	bf00      	nop
3419368e:	e000      	b.n	34193692 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34193690:	bf00      	nop
  }

  return eth1_frequency;
34193692:	68fb      	ldr	r3, [r7, #12]
}
34193694:	4618      	mov	r0, r3
34193696:	3710      	adds	r7, #16
34193698:	46bd      	mov	sp, r7
3419369a:	bd80      	pop	{r7, pc}
3419369c:	02dc6c00 	.word	0x02dc6c00

341936a0 <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
341936a0:	b580      	push	{r7, lr}
341936a2:	b084      	sub	sp, #16
341936a4:	af00      	add	r7, sp, #0
341936a6:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
341936a8:	2300      	movs	r3, #0
341936aa:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
341936ac:	6878      	ldr	r0, [r7, #4]
341936ae:	f7fb f97f 	bl	3418e9b0 <LL_RCC_GetETHPTPClockSource>
341936b2:	4603      	mov	r3, r0
341936b4:	2b03      	cmp	r3, #3
341936b6:	d863      	bhi.n	34193780 <RCCEx_GetETH1PTPCLKFreq+0xe0>
341936b8:	a201      	add	r2, pc, #4	@ (adr r2, 341936c0 <RCCEx_GetETH1PTPCLKFreq+0x20>)
341936ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341936be:	bf00      	nop
341936c0:	341936d1 	.word	0x341936d1
341936c4:	341936e1 	.word	0x341936e1
341936c8:	341936eb 	.word	0x341936eb
341936cc:	34193771 	.word	0x34193771
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
341936d0:	f7fa fa36 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341936d4:	4603      	mov	r3, r0
341936d6:	4618      	mov	r0, r3
341936d8:	f7ff f9ea 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341936dc:	60f8      	str	r0, [r7, #12]
      break;
341936de:	e054      	b.n	3419378a <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341936e0:	2007      	movs	r0, #7
341936e2:	f7ff fcd1 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341936e6:	60f8      	str	r0, [r7, #12]
      break;
341936e8:	e04f      	b.n	3419378a <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
341936ea:	f7fb ff35 	bl	3418f558 <LL_RCC_IC13_IsEnabled>
341936ee:	4603      	mov	r3, r0
341936f0:	2b00      	cmp	r3, #0
341936f2:	d047      	beq.n	34193784 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
341936f4:	f7fb ff52 	bl	3418f59c <LL_RCC_IC13_GetDivider>
341936f8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
341936fa:	f7fb ff41 	bl	3418f580 <LL_RCC_IC13_GetSource>
341936fe:	4603      	mov	r3, r0
34193700:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193704:	d029      	beq.n	3419375a <RCCEx_GetETH1PTPCLKFreq+0xba>
34193706:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419370a:	d82f      	bhi.n	3419376c <RCCEx_GetETH1PTPCLKFreq+0xcc>
3419370c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193710:	d01a      	beq.n	34193748 <RCCEx_GetETH1PTPCLKFreq+0xa8>
34193712:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193716:	d829      	bhi.n	3419376c <RCCEx_GetETH1PTPCLKFreq+0xcc>
34193718:	2b00      	cmp	r3, #0
3419371a:	d003      	beq.n	34193724 <RCCEx_GetETH1PTPCLKFreq+0x84>
3419371c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193720:	d009      	beq.n	34193736 <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193722:	e023      	b.n	3419376c <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193724:	f7ff f8ac 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193728:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3419372a:	68fa      	ldr	r2, [r7, #12]
3419372c:	68bb      	ldr	r3, [r7, #8]
3419372e:	fbb2 f3f3 	udiv	r3, r2, r3
34193732:	60fb      	str	r3, [r7, #12]
            break;
34193734:	e01b      	b.n	3419376e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193736:	f7ff f8e9 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3419373a:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3419373c:	68fa      	ldr	r2, [r7, #12]
3419373e:	68bb      	ldr	r3, [r7, #8]
34193740:	fbb2 f3f3 	udiv	r3, r2, r3
34193744:	60fb      	str	r3, [r7, #12]
            break;
34193746:	e012      	b.n	3419376e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193748:	f7ff f926 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419374c:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3419374e:	68fa      	ldr	r2, [r7, #12]
34193750:	68bb      	ldr	r3, [r7, #8]
34193752:	fbb2 f3f3 	udiv	r3, r2, r3
34193756:	60fb      	str	r3, [r7, #12]
            break;
34193758:	e009      	b.n	3419376e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419375a:	f7ff f963 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419375e:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34193760:	68fa      	ldr	r2, [r7, #12]
34193762:	68bb      	ldr	r3, [r7, #8]
34193764:	fbb2 f3f3 	udiv	r3, r2, r3
34193768:	60fb      	str	r3, [r7, #12]
            break;
3419376a:	e000      	b.n	3419376e <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
3419376c:	bf00      	nop
        }
      }
      break;
3419376e:	e009      	b.n	34193784 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34193770:	f7fa fdfc 	bl	3418e36c <LL_RCC_HSE_IsReady>
34193774:	4603      	mov	r3, r0
34193776:	2b00      	cmp	r3, #0
34193778:	d006      	beq.n	34193788 <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
3419377a:	4b0a      	ldr	r3, [pc, #40]	@ (341937a4 <RCCEx_GetETH1PTPCLKFreq+0x104>)
3419377c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419377e:	e003      	b.n	34193788 <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
34193780:	bf00      	nop
34193782:	e002      	b.n	3419378a <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34193784:	bf00      	nop
34193786:	e000      	b.n	3419378a <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34193788:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3419378a:	f7fa ff4d 	bl	3418e628 <LL_RCC_GetETH1PTPDivider>
3419378e:	4603      	mov	r3, r0
34193790:	091b      	lsrs	r3, r3, #4
34193792:	3301      	adds	r3, #1
34193794:	68fa      	ldr	r2, [r7, #12]
34193796:	fbb2 f3f3 	udiv	r3, r2, r3
}
3419379a:	4618      	mov	r0, r3
3419379c:	3710      	adds	r7, #16
3419379e:	46bd      	mov	sp, r7
341937a0:	bd80      	pop	{r7, pc}
341937a2:	bf00      	nop
341937a4:	02dc6c00 	.word	0x02dc6c00

341937a8 <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
341937a8:	b580      	push	{r7, lr}
341937aa:	b084      	sub	sp, #16
341937ac:	af00      	add	r7, sp, #0
341937ae:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
341937b0:	2300      	movs	r3, #0
341937b2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
341937b4:	6878      	ldr	r0, [r7, #4]
341937b6:	f7fb f90d 	bl	3418e9d4 <LL_RCC_GetFDCANClockSource>
341937ba:	4603      	mov	r3, r0
341937bc:	2b03      	cmp	r3, #3
341937be:	d867      	bhi.n	34193890 <RCCEx_GetFDCANCLKFreq+0xe8>
341937c0:	a201      	add	r2, pc, #4	@ (adr r2, 341937c8 <RCCEx_GetFDCANCLKFreq+0x20>)
341937c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341937c6:	bf00      	nop
341937c8:	341937d9 	.word	0x341937d9
341937cc:	341937f1 	.word	0x341937f1
341937d0:	341937fb 	.word	0x341937fb
341937d4:	34193881 	.word	0x34193881
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341937d8:	f7fa f9b2 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341937dc:	4603      	mov	r3, r0
341937de:	4618      	mov	r0, r3
341937e0:	f7ff f966 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341937e4:	4603      	mov	r3, r0
341937e6:	4618      	mov	r0, r3
341937e8:	f7ff f973 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
341937ec:	60f8      	str	r0, [r7, #12]
      break;
341937ee:	e054      	b.n	3419389a <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341937f0:	2007      	movs	r0, #7
341937f2:	f7ff fc49 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341937f6:	60f8      	str	r0, [r7, #12]
      break;
341937f8:	e04f      	b.n	3419389a <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
341937fa:	f7fc f82d 	bl	3418f858 <LL_RCC_IC19_IsEnabled>
341937fe:	4603      	mov	r3, r0
34193800:	2b00      	cmp	r3, #0
34193802:	d047      	beq.n	34193894 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
34193804:	f7fc f84a 	bl	3418f89c <LL_RCC_IC19_GetDivider>
34193808:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
3419380a:	f7fc f839 	bl	3418f880 <LL_RCC_IC19_GetSource>
3419380e:	4603      	mov	r3, r0
34193810:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193814:	d029      	beq.n	3419386a <RCCEx_GetFDCANCLKFreq+0xc2>
34193816:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419381a:	d82f      	bhi.n	3419387c <RCCEx_GetFDCANCLKFreq+0xd4>
3419381c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193820:	d01a      	beq.n	34193858 <RCCEx_GetFDCANCLKFreq+0xb0>
34193822:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193826:	d829      	bhi.n	3419387c <RCCEx_GetFDCANCLKFreq+0xd4>
34193828:	2b00      	cmp	r3, #0
3419382a:	d003      	beq.n	34193834 <RCCEx_GetFDCANCLKFreq+0x8c>
3419382c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193830:	d009      	beq.n	34193846 <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193832:	e023      	b.n	3419387c <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193834:	f7ff f824 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193838:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3419383a:	68fa      	ldr	r2, [r7, #12]
3419383c:	68bb      	ldr	r3, [r7, #8]
3419383e:	fbb2 f3f3 	udiv	r3, r2, r3
34193842:	60fb      	str	r3, [r7, #12]
            break;
34193844:	e01b      	b.n	3419387e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193846:	f7ff f861 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3419384a:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3419384c:	68fa      	ldr	r2, [r7, #12]
3419384e:	68bb      	ldr	r3, [r7, #8]
34193850:	fbb2 f3f3 	udiv	r3, r2, r3
34193854:	60fb      	str	r3, [r7, #12]
            break;
34193856:	e012      	b.n	3419387e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193858:	f7ff f89e 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419385c:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3419385e:	68fa      	ldr	r2, [r7, #12]
34193860:	68bb      	ldr	r3, [r7, #8]
34193862:	fbb2 f3f3 	udiv	r3, r2, r3
34193866:	60fb      	str	r3, [r7, #12]
            break;
34193868:	e009      	b.n	3419387e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419386a:	f7ff f8db 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419386e:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34193870:	68fa      	ldr	r2, [r7, #12]
34193872:	68bb      	ldr	r3, [r7, #8]
34193874:	fbb2 f3f3 	udiv	r3, r2, r3
34193878:	60fb      	str	r3, [r7, #12]
            break;
3419387a:	e000      	b.n	3419387e <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
3419387c:	bf00      	nop
        }
      }
      break;
3419387e:	e009      	b.n	34193894 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34193880:	f7fa fd74 	bl	3418e36c <LL_RCC_HSE_IsReady>
34193884:	4603      	mov	r3, r0
34193886:	2b00      	cmp	r3, #0
34193888:	d006      	beq.n	34193898 <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
3419388a:	4b06      	ldr	r3, [pc, #24]	@ (341938a4 <RCCEx_GetFDCANCLKFreq+0xfc>)
3419388c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419388e:	e003      	b.n	34193898 <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
34193890:	bf00      	nop
34193892:	e002      	b.n	3419389a <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34193894:	bf00      	nop
34193896:	e000      	b.n	3419389a <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34193898:	bf00      	nop
  }

  return fdcan_frequency;
3419389a:	68fb      	ldr	r3, [r7, #12]
}
3419389c:	4618      	mov	r0, r3
3419389e:	3710      	adds	r7, #16
341938a0:	46bd      	mov	sp, r7
341938a2:	bd80      	pop	{r7, pc}
341938a4:	02dc6c00 	.word	0x02dc6c00

341938a8 <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
341938a8:	b580      	push	{r7, lr}
341938aa:	b084      	sub	sp, #16
341938ac:	af00      	add	r7, sp, #0
341938ae:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
341938b0:	2300      	movs	r3, #0
341938b2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
341938b4:	6878      	ldr	r0, [r7, #4]
341938b6:	f7fb f89f 	bl	3418e9f8 <LL_RCC_GetFMCClockSource>
341938ba:	4603      	mov	r3, r0
341938bc:	2b30      	cmp	r3, #48	@ 0x30
341938be:	d05d      	beq.n	3419397c <RCCEx_GetFMCCLKFreq+0xd4>
341938c0:	2b30      	cmp	r3, #48	@ 0x30
341938c2:	f200 809e 	bhi.w	34193a02 <RCCEx_GetFMCCLKFreq+0x15a>
341938c6:	2b20      	cmp	r3, #32
341938c8:	d014      	beq.n	341938f4 <RCCEx_GetFMCCLKFreq+0x4c>
341938ca:	2b20      	cmp	r3, #32
341938cc:	f200 8099 	bhi.w	34193a02 <RCCEx_GetFMCCLKFreq+0x15a>
341938d0:	2b00      	cmp	r3, #0
341938d2:	d002      	beq.n	341938da <RCCEx_GetFMCCLKFreq+0x32>
341938d4:	2b10      	cmp	r3, #16
341938d6:	d008      	beq.n	341938ea <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
341938d8:	e093      	b.n	34193a02 <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
341938da:	f7fa f931 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341938de:	4603      	mov	r3, r0
341938e0:	4618      	mov	r0, r3
341938e2:	f7ff f8e5 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341938e6:	60f8      	str	r0, [r7, #12]
      break;
341938e8:	e090      	b.n	34193a0c <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341938ea:	2007      	movs	r0, #7
341938ec:	f7ff fbcc 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341938f0:	60f8      	str	r0, [r7, #12]
      break;
341938f2:	e08b      	b.n	34193a0c <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
341938f4:	f7fb fc30 	bl	3418f158 <LL_RCC_IC3_IsEnabled>
341938f8:	4603      	mov	r3, r0
341938fa:	2b00      	cmp	r3, #0
341938fc:	f000 8083 	beq.w	34193a06 <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
34193900:	f7fb fc4c 	bl	3418f19c <LL_RCC_IC3_GetDivider>
34193904:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34193906:	f7fb fc3b 	bl	3418f180 <LL_RCC_IC3_GetSource>
3419390a:	4603      	mov	r3, r0
3419390c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193910:	d029      	beq.n	34193966 <RCCEx_GetFMCCLKFreq+0xbe>
34193912:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193916:	d82f      	bhi.n	34193978 <RCCEx_GetFMCCLKFreq+0xd0>
34193918:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419391c:	d01a      	beq.n	34193954 <RCCEx_GetFMCCLKFreq+0xac>
3419391e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193922:	d829      	bhi.n	34193978 <RCCEx_GetFMCCLKFreq+0xd0>
34193924:	2b00      	cmp	r3, #0
34193926:	d003      	beq.n	34193930 <RCCEx_GetFMCCLKFreq+0x88>
34193928:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419392c:	d009      	beq.n	34193942 <RCCEx_GetFMCCLKFreq+0x9a>
            break;
3419392e:	e023      	b.n	34193978 <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193930:	f7fe ffa6 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193934:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34193936:	68fa      	ldr	r2, [r7, #12]
34193938:	68bb      	ldr	r3, [r7, #8]
3419393a:	fbb2 f3f3 	udiv	r3, r2, r3
3419393e:	60fb      	str	r3, [r7, #12]
            break;
34193940:	e01b      	b.n	3419397a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193942:	f7fe ffe3 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193946:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34193948:	68fa      	ldr	r2, [r7, #12]
3419394a:	68bb      	ldr	r3, [r7, #8]
3419394c:	fbb2 f3f3 	udiv	r3, r2, r3
34193950:	60fb      	str	r3, [r7, #12]
            break;
34193952:	e012      	b.n	3419397a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193954:	f7ff f820 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193958:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3419395a:	68fa      	ldr	r2, [r7, #12]
3419395c:	68bb      	ldr	r3, [r7, #8]
3419395e:	fbb2 f3f3 	udiv	r3, r2, r3
34193962:	60fb      	str	r3, [r7, #12]
            break;
34193964:	e009      	b.n	3419397a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193966:	f7ff f85d 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419396a:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3419396c:	68fa      	ldr	r2, [r7, #12]
3419396e:	68bb      	ldr	r3, [r7, #8]
34193970:	fbb2 f3f3 	udiv	r3, r2, r3
34193974:	60fb      	str	r3, [r7, #12]
            break;
34193976:	e000      	b.n	3419397a <RCCEx_GetFMCCLKFreq+0xd2>
            break;
34193978:	bf00      	nop
      break;
3419397a:	e044      	b.n	34193a06 <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
3419397c:	f7fb fc2c 	bl	3418f1d8 <LL_RCC_IC4_IsEnabled>
34193980:	4603      	mov	r3, r0
34193982:	2b00      	cmp	r3, #0
34193984:	d041      	beq.n	34193a0a <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
34193986:	f7fb fc49 	bl	3418f21c <LL_RCC_IC4_GetDivider>
3419398a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3419398c:	f7fb fc38 	bl	3418f200 <LL_RCC_IC4_GetSource>
34193990:	4603      	mov	r3, r0
34193992:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193996:	d029      	beq.n	341939ec <RCCEx_GetFMCCLKFreq+0x144>
34193998:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419399c:	d82f      	bhi.n	341939fe <RCCEx_GetFMCCLKFreq+0x156>
3419399e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341939a2:	d01a      	beq.n	341939da <RCCEx_GetFMCCLKFreq+0x132>
341939a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341939a8:	d829      	bhi.n	341939fe <RCCEx_GetFMCCLKFreq+0x156>
341939aa:	2b00      	cmp	r3, #0
341939ac:	d003      	beq.n	341939b6 <RCCEx_GetFMCCLKFreq+0x10e>
341939ae:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341939b2:	d009      	beq.n	341939c8 <RCCEx_GetFMCCLKFreq+0x120>
            break;
341939b4:	e023      	b.n	341939fe <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341939b6:	f7fe ff63 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341939ba:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341939bc:	68fa      	ldr	r2, [r7, #12]
341939be:	68bb      	ldr	r3, [r7, #8]
341939c0:	fbb2 f3f3 	udiv	r3, r2, r3
341939c4:	60fb      	str	r3, [r7, #12]
            break;
341939c6:	e01b      	b.n	34193a00 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341939c8:	f7fe ffa0 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341939cc:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341939ce:	68fa      	ldr	r2, [r7, #12]
341939d0:	68bb      	ldr	r3, [r7, #8]
341939d2:	fbb2 f3f3 	udiv	r3, r2, r3
341939d6:	60fb      	str	r3, [r7, #12]
            break;
341939d8:	e012      	b.n	34193a00 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341939da:	f7fe ffdd 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341939de:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341939e0:	68fa      	ldr	r2, [r7, #12]
341939e2:	68bb      	ldr	r3, [r7, #8]
341939e4:	fbb2 f3f3 	udiv	r3, r2, r3
341939e8:	60fb      	str	r3, [r7, #12]
            break;
341939ea:	e009      	b.n	34193a00 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341939ec:	f7ff f81a 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341939f0:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
341939f2:	68fa      	ldr	r2, [r7, #12]
341939f4:	68bb      	ldr	r3, [r7, #8]
341939f6:	fbb2 f3f3 	udiv	r3, r2, r3
341939fa:	60fb      	str	r3, [r7, #12]
            break;
341939fc:	e000      	b.n	34193a00 <RCCEx_GetFMCCLKFreq+0x158>
            break;
341939fe:	bf00      	nop
      break;
34193a00:	e003      	b.n	34193a0a <RCCEx_GetFMCCLKFreq+0x162>
      break;
34193a02:	bf00      	nop
34193a04:	e002      	b.n	34193a0c <RCCEx_GetFMCCLKFreq+0x164>
      break;
34193a06:	bf00      	nop
34193a08:	e000      	b.n	34193a0c <RCCEx_GetFMCCLKFreq+0x164>
      break;
34193a0a:	bf00      	nop
  }

  return fmc_frequency;
34193a0c:	68fb      	ldr	r3, [r7, #12]
}
34193a0e:	4618      	mov	r0, r3
34193a10:	3710      	adds	r7, #16
34193a12:	46bd      	mov	sp, r7
34193a14:	bd80      	pop	{r7, pc}
	...

34193a18 <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
34193a18:	b580      	push	{r7, lr}
34193a1a:	b084      	sub	sp, #16
34193a1c:	af00      	add	r7, sp, #0
34193a1e:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34193a20:	2300      	movs	r3, #0
34193a22:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34193a24:	6878      	ldr	r0, [r7, #4]
34193a26:	f7fa fff9 	bl	3418ea1c <LL_RCC_GetI2CClockSource>
34193a2a:	4603      	mov	r3, r0
34193a2c:	4aa2      	ldr	r2, [pc, #648]	@ (34193cb8 <RCCEx_GetI2CCLKFreq+0x2a0>)
34193a2e:	4293      	cmp	r3, r2
34193a30:	f000 8172 	beq.w	34193d18 <RCCEx_GetI2CCLKFreq+0x300>
34193a34:	4aa0      	ldr	r2, [pc, #640]	@ (34193cb8 <RCCEx_GetI2CCLKFreq+0x2a0>)
34193a36:	4293      	cmp	r3, r2
34193a38:	f200 8184 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a3c:	4a9f      	ldr	r2, [pc, #636]	@ (34193cbc <RCCEx_GetI2CCLKFreq+0x2a4>)
34193a3e:	4293      	cmp	r3, r2
34193a40:	f000 816a 	beq.w	34193d18 <RCCEx_GetI2CCLKFreq+0x300>
34193a44:	4a9d      	ldr	r2, [pc, #628]	@ (34193cbc <RCCEx_GetI2CCLKFreq+0x2a4>)
34193a46:	4293      	cmp	r3, r2
34193a48:	f200 817c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a4c:	4a9c      	ldr	r2, [pc, #624]	@ (34193cc0 <RCCEx_GetI2CCLKFreq+0x2a8>)
34193a4e:	4293      	cmp	r3, r2
34193a50:	f000 8162 	beq.w	34193d18 <RCCEx_GetI2CCLKFreq+0x300>
34193a54:	4a9a      	ldr	r2, [pc, #616]	@ (34193cc0 <RCCEx_GetI2CCLKFreq+0x2a8>)
34193a56:	4293      	cmp	r3, r2
34193a58:	f200 8174 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a5c:	4a99      	ldr	r2, [pc, #612]	@ (34193cc4 <RCCEx_GetI2CCLKFreq+0x2ac>)
34193a5e:	4293      	cmp	r3, r2
34193a60:	f000 815a 	beq.w	34193d18 <RCCEx_GetI2CCLKFreq+0x300>
34193a64:	4a97      	ldr	r2, [pc, #604]	@ (34193cc4 <RCCEx_GetI2CCLKFreq+0x2ac>)
34193a66:	4293      	cmp	r3, r2
34193a68:	f200 816c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a6c:	4a96      	ldr	r2, [pc, #600]	@ (34193cc8 <RCCEx_GetI2CCLKFreq+0x2b0>)
34193a6e:	4293      	cmp	r3, r2
34193a70:	f000 8160 	beq.w	34193d34 <RCCEx_GetI2CCLKFreq+0x31c>
34193a74:	4a94      	ldr	r2, [pc, #592]	@ (34193cc8 <RCCEx_GetI2CCLKFreq+0x2b0>)
34193a76:	4293      	cmp	r3, r2
34193a78:	f200 8164 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a7c:	4a93      	ldr	r2, [pc, #588]	@ (34193ccc <RCCEx_GetI2CCLKFreq+0x2b4>)
34193a7e:	4293      	cmp	r3, r2
34193a80:	f000 8158 	beq.w	34193d34 <RCCEx_GetI2CCLKFreq+0x31c>
34193a84:	4a91      	ldr	r2, [pc, #580]	@ (34193ccc <RCCEx_GetI2CCLKFreq+0x2b4>)
34193a86:	4293      	cmp	r3, r2
34193a88:	f200 815c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a8c:	4a90      	ldr	r2, [pc, #576]	@ (34193cd0 <RCCEx_GetI2CCLKFreq+0x2b8>)
34193a8e:	4293      	cmp	r3, r2
34193a90:	f000 8150 	beq.w	34193d34 <RCCEx_GetI2CCLKFreq+0x31c>
34193a94:	4a8e      	ldr	r2, [pc, #568]	@ (34193cd0 <RCCEx_GetI2CCLKFreq+0x2b8>)
34193a96:	4293      	cmp	r3, r2
34193a98:	f200 8154 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193a9c:	4a8d      	ldr	r2, [pc, #564]	@ (34193cd4 <RCCEx_GetI2CCLKFreq+0x2bc>)
34193a9e:	4293      	cmp	r3, r2
34193aa0:	f000 8148 	beq.w	34193d34 <RCCEx_GetI2CCLKFreq+0x31c>
34193aa4:	4a8b      	ldr	r2, [pc, #556]	@ (34193cd4 <RCCEx_GetI2CCLKFreq+0x2bc>)
34193aa6:	4293      	cmp	r3, r2
34193aa8:	f200 814c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193aac:	4a8a      	ldr	r2, [pc, #552]	@ (34193cd8 <RCCEx_GetI2CCLKFreq+0x2c0>)
34193aae:	4293      	cmp	r3, r2
34193ab0:	f000 80be 	beq.w	34193c30 <RCCEx_GetI2CCLKFreq+0x218>
34193ab4:	4a88      	ldr	r2, [pc, #544]	@ (34193cd8 <RCCEx_GetI2CCLKFreq+0x2c0>)
34193ab6:	4293      	cmp	r3, r2
34193ab8:	f200 8144 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193abc:	4a87      	ldr	r2, [pc, #540]	@ (34193cdc <RCCEx_GetI2CCLKFreq+0x2c4>)
34193abe:	4293      	cmp	r3, r2
34193ac0:	f000 80b6 	beq.w	34193c30 <RCCEx_GetI2CCLKFreq+0x218>
34193ac4:	4a85      	ldr	r2, [pc, #532]	@ (34193cdc <RCCEx_GetI2CCLKFreq+0x2c4>)
34193ac6:	4293      	cmp	r3, r2
34193ac8:	f200 813c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193acc:	4a84      	ldr	r2, [pc, #528]	@ (34193ce0 <RCCEx_GetI2CCLKFreq+0x2c8>)
34193ace:	4293      	cmp	r3, r2
34193ad0:	f000 80ae 	beq.w	34193c30 <RCCEx_GetI2CCLKFreq+0x218>
34193ad4:	4a82      	ldr	r2, [pc, #520]	@ (34193ce0 <RCCEx_GetI2CCLKFreq+0x2c8>)
34193ad6:	4293      	cmp	r3, r2
34193ad8:	f200 8134 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193adc:	4a81      	ldr	r2, [pc, #516]	@ (34193ce4 <RCCEx_GetI2CCLKFreq+0x2cc>)
34193ade:	4293      	cmp	r3, r2
34193ae0:	f000 80a6 	beq.w	34193c30 <RCCEx_GetI2CCLKFreq+0x218>
34193ae4:	4a7f      	ldr	r2, [pc, #508]	@ (34193ce4 <RCCEx_GetI2CCLKFreq+0x2cc>)
34193ae6:	4293      	cmp	r3, r2
34193ae8:	f200 812c 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193aec:	4a7e      	ldr	r2, [pc, #504]	@ (34193ce8 <RCCEx_GetI2CCLKFreq+0x2d0>)
34193aee:	4293      	cmp	r3, r2
34193af0:	d05a      	beq.n	34193ba8 <RCCEx_GetI2CCLKFreq+0x190>
34193af2:	4a7d      	ldr	r2, [pc, #500]	@ (34193ce8 <RCCEx_GetI2CCLKFreq+0x2d0>)
34193af4:	4293      	cmp	r3, r2
34193af6:	f200 8125 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193afa:	4a7c      	ldr	r2, [pc, #496]	@ (34193cec <RCCEx_GetI2CCLKFreq+0x2d4>)
34193afc:	4293      	cmp	r3, r2
34193afe:	d053      	beq.n	34193ba8 <RCCEx_GetI2CCLKFreq+0x190>
34193b00:	4a7a      	ldr	r2, [pc, #488]	@ (34193cec <RCCEx_GetI2CCLKFreq+0x2d4>)
34193b02:	4293      	cmp	r3, r2
34193b04:	f200 811e 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b08:	4a79      	ldr	r2, [pc, #484]	@ (34193cf0 <RCCEx_GetI2CCLKFreq+0x2d8>)
34193b0a:	4293      	cmp	r3, r2
34193b0c:	d04c      	beq.n	34193ba8 <RCCEx_GetI2CCLKFreq+0x190>
34193b0e:	4a78      	ldr	r2, [pc, #480]	@ (34193cf0 <RCCEx_GetI2CCLKFreq+0x2d8>)
34193b10:	4293      	cmp	r3, r2
34193b12:	f200 8117 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b16:	4a77      	ldr	r2, [pc, #476]	@ (34193cf4 <RCCEx_GetI2CCLKFreq+0x2dc>)
34193b18:	4293      	cmp	r3, r2
34193b1a:	d045      	beq.n	34193ba8 <RCCEx_GetI2CCLKFreq+0x190>
34193b1c:	4a75      	ldr	r2, [pc, #468]	@ (34193cf4 <RCCEx_GetI2CCLKFreq+0x2dc>)
34193b1e:	4293      	cmp	r3, r2
34193b20:	f200 8110 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b24:	4a74      	ldr	r2, [pc, #464]	@ (34193cf8 <RCCEx_GetI2CCLKFreq+0x2e0>)
34193b26:	4293      	cmp	r3, r2
34193b28:	d039      	beq.n	34193b9e <RCCEx_GetI2CCLKFreq+0x186>
34193b2a:	4a73      	ldr	r2, [pc, #460]	@ (34193cf8 <RCCEx_GetI2CCLKFreq+0x2e0>)
34193b2c:	4293      	cmp	r3, r2
34193b2e:	f200 8109 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b32:	4a72      	ldr	r2, [pc, #456]	@ (34193cfc <RCCEx_GetI2CCLKFreq+0x2e4>)
34193b34:	4293      	cmp	r3, r2
34193b36:	d032      	beq.n	34193b9e <RCCEx_GetI2CCLKFreq+0x186>
34193b38:	4a70      	ldr	r2, [pc, #448]	@ (34193cfc <RCCEx_GetI2CCLKFreq+0x2e4>)
34193b3a:	4293      	cmp	r3, r2
34193b3c:	f200 8102 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b40:	4a6f      	ldr	r2, [pc, #444]	@ (34193d00 <RCCEx_GetI2CCLKFreq+0x2e8>)
34193b42:	4293      	cmp	r3, r2
34193b44:	d02b      	beq.n	34193b9e <RCCEx_GetI2CCLKFreq+0x186>
34193b46:	4a6e      	ldr	r2, [pc, #440]	@ (34193d00 <RCCEx_GetI2CCLKFreq+0x2e8>)
34193b48:	4293      	cmp	r3, r2
34193b4a:	f200 80fb 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b4e:	4a6d      	ldr	r2, [pc, #436]	@ (34193d04 <RCCEx_GetI2CCLKFreq+0x2ec>)
34193b50:	4293      	cmp	r3, r2
34193b52:	d024      	beq.n	34193b9e <RCCEx_GetI2CCLKFreq+0x186>
34193b54:	4a6b      	ldr	r2, [pc, #428]	@ (34193d04 <RCCEx_GetI2CCLKFreq+0x2ec>)
34193b56:	4293      	cmp	r3, r2
34193b58:	f200 80f4 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b5c:	4a6a      	ldr	r2, [pc, #424]	@ (34193d08 <RCCEx_GetI2CCLKFreq+0x2f0>)
34193b5e:	4293      	cmp	r3, r2
34193b60:	d011      	beq.n	34193b86 <RCCEx_GetI2CCLKFreq+0x16e>
34193b62:	4a69      	ldr	r2, [pc, #420]	@ (34193d08 <RCCEx_GetI2CCLKFreq+0x2f0>)
34193b64:	4293      	cmp	r3, r2
34193b66:	f200 80ed 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b6a:	4a68      	ldr	r2, [pc, #416]	@ (34193d0c <RCCEx_GetI2CCLKFreq+0x2f4>)
34193b6c:	4293      	cmp	r3, r2
34193b6e:	d00a      	beq.n	34193b86 <RCCEx_GetI2CCLKFreq+0x16e>
34193b70:	4a66      	ldr	r2, [pc, #408]	@ (34193d0c <RCCEx_GetI2CCLKFreq+0x2f4>)
34193b72:	4293      	cmp	r3, r2
34193b74:	f200 80e6 	bhi.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
34193b78:	4a65      	ldr	r2, [pc, #404]	@ (34193d10 <RCCEx_GetI2CCLKFreq+0x2f8>)
34193b7a:	4293      	cmp	r3, r2
34193b7c:	d003      	beq.n	34193b86 <RCCEx_GetI2CCLKFreq+0x16e>
34193b7e:	4a65      	ldr	r2, [pc, #404]	@ (34193d14 <RCCEx_GetI2CCLKFreq+0x2fc>)
34193b80:	4293      	cmp	r3, r2
34193b82:	f040 80df 	bne.w	34193d44 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34193b86:	f7f9 ffdb 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34193b8a:	4603      	mov	r3, r0
34193b8c:	4618      	mov	r0, r3
34193b8e:	f7fe ff8f 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34193b92:	4603      	mov	r3, r0
34193b94:	4618      	mov	r0, r3
34193b96:	f7fe ff9c 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34193b9a:	60f8      	str	r0, [r7, #12]
      break;
34193b9c:	e0db      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193b9e:	2007      	movs	r0, #7
34193ba0:	f7ff fa72 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34193ba4:	60f8      	str	r0, [r7, #12]
      break;
34193ba6:	e0d6      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34193ba8:	f7fb fc56 	bl	3418f458 <LL_RCC_IC10_IsEnabled>
34193bac:	4603      	mov	r3, r0
34193bae:	2b00      	cmp	r3, #0
34193bb0:	f000 80ca 	beq.w	34193d48 <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34193bb4:	f7fb fc72 	bl	3418f49c <LL_RCC_IC10_GetDivider>
34193bb8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34193bba:	f7fb fc61 	bl	3418f480 <LL_RCC_IC10_GetSource>
34193bbe:	4603      	mov	r3, r0
34193bc0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193bc4:	d029      	beq.n	34193c1a <RCCEx_GetI2CCLKFreq+0x202>
34193bc6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193bca:	d82f      	bhi.n	34193c2c <RCCEx_GetI2CCLKFreq+0x214>
34193bcc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193bd0:	d01a      	beq.n	34193c08 <RCCEx_GetI2CCLKFreq+0x1f0>
34193bd2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193bd6:	d829      	bhi.n	34193c2c <RCCEx_GetI2CCLKFreq+0x214>
34193bd8:	2b00      	cmp	r3, #0
34193bda:	d003      	beq.n	34193be4 <RCCEx_GetI2CCLKFreq+0x1cc>
34193bdc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193be0:	d009      	beq.n	34193bf6 <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193be2:	e023      	b.n	34193c2c <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193be4:	f7fe fe4c 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193be8:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193bea:	68fa      	ldr	r2, [r7, #12]
34193bec:	68bb      	ldr	r3, [r7, #8]
34193bee:	fbb2 f3f3 	udiv	r3, r2, r3
34193bf2:	60fb      	str	r3, [r7, #12]
            break;
34193bf4:	e01b      	b.n	34193c2e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193bf6:	f7fe fe89 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193bfa:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193bfc:	68fa      	ldr	r2, [r7, #12]
34193bfe:	68bb      	ldr	r3, [r7, #8]
34193c00:	fbb2 f3f3 	udiv	r3, r2, r3
34193c04:	60fb      	str	r3, [r7, #12]
            break;
34193c06:	e012      	b.n	34193c2e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193c08:	f7fe fec6 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193c0c:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193c0e:	68fa      	ldr	r2, [r7, #12]
34193c10:	68bb      	ldr	r3, [r7, #8]
34193c12:	fbb2 f3f3 	udiv	r3, r2, r3
34193c16:	60fb      	str	r3, [r7, #12]
            break;
34193c18:	e009      	b.n	34193c2e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193c1a:	f7fe ff03 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193c1e:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193c20:	68fa      	ldr	r2, [r7, #12]
34193c22:	68bb      	ldr	r3, [r7, #8]
34193c24:	fbb2 f3f3 	udiv	r3, r2, r3
34193c28:	60fb      	str	r3, [r7, #12]
            break;
34193c2a:	e000      	b.n	34193c2e <RCCEx_GetI2CCLKFreq+0x216>
            break;
34193c2c:	bf00      	nop
        }
      }
      break;
34193c2e:	e08b      	b.n	34193d48 <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34193c30:	f7fb fd12 	bl	3418f658 <LL_RCC_IC15_IsEnabled>
34193c34:	4603      	mov	r3, r0
34193c36:	2b00      	cmp	r3, #0
34193c38:	f000 8088 	beq.w	34193d4c <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34193c3c:	f7fb fd2e 	bl	3418f69c <LL_RCC_IC15_GetDivider>
34193c40:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34193c42:	f7fb fd1d 	bl	3418f680 <LL_RCC_IC15_GetSource>
34193c46:	4603      	mov	r3, r0
34193c48:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193c4c:	d029      	beq.n	34193ca2 <RCCEx_GetI2CCLKFreq+0x28a>
34193c4e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193c52:	d82f      	bhi.n	34193cb4 <RCCEx_GetI2CCLKFreq+0x29c>
34193c54:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193c58:	d01a      	beq.n	34193c90 <RCCEx_GetI2CCLKFreq+0x278>
34193c5a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193c5e:	d829      	bhi.n	34193cb4 <RCCEx_GetI2CCLKFreq+0x29c>
34193c60:	2b00      	cmp	r3, #0
34193c62:	d003      	beq.n	34193c6c <RCCEx_GetI2CCLKFreq+0x254>
34193c64:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193c68:	d009      	beq.n	34193c7e <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193c6a:	e023      	b.n	34193cb4 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193c6c:	f7fe fe08 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193c70:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193c72:	68fa      	ldr	r2, [r7, #12]
34193c74:	68bb      	ldr	r3, [r7, #8]
34193c76:	fbb2 f3f3 	udiv	r3, r2, r3
34193c7a:	60fb      	str	r3, [r7, #12]
            break;
34193c7c:	e01b      	b.n	34193cb6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193c7e:	f7fe fe45 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193c82:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193c84:	68fa      	ldr	r2, [r7, #12]
34193c86:	68bb      	ldr	r3, [r7, #8]
34193c88:	fbb2 f3f3 	udiv	r3, r2, r3
34193c8c:	60fb      	str	r3, [r7, #12]
            break;
34193c8e:	e012      	b.n	34193cb6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193c90:	f7fe fe82 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193c94:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193c96:	68fa      	ldr	r2, [r7, #12]
34193c98:	68bb      	ldr	r3, [r7, #8]
34193c9a:	fbb2 f3f3 	udiv	r3, r2, r3
34193c9e:	60fb      	str	r3, [r7, #12]
            break;
34193ca0:	e009      	b.n	34193cb6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193ca2:	f7fe febf 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193ca6:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34193ca8:	68fa      	ldr	r2, [r7, #12]
34193caa:	68bb      	ldr	r3, [r7, #8]
34193cac:	fbb2 f3f3 	udiv	r3, r2, r3
34193cb0:	60fb      	str	r3, [r7, #12]
            break;
34193cb2:	e000      	b.n	34193cb6 <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34193cb4:	bf00      	nop
        }
      }
      break;
34193cb6:	e049      	b.n	34193d4c <RCCEx_GetI2CCLKFreq+0x334>
34193cb8:	07050c0c 	.word	0x07050c0c
34193cbc:	0705080c 	.word	0x0705080c
34193cc0:	0705040c 	.word	0x0705040c
34193cc4:	0705000c 	.word	0x0705000c
34193cc8:	07040c0c 	.word	0x07040c0c
34193ccc:	0704080c 	.word	0x0704080c
34193cd0:	0704040c 	.word	0x0704040c
34193cd4:	0704000c 	.word	0x0704000c
34193cd8:	07030c0c 	.word	0x07030c0c
34193cdc:	0703080c 	.word	0x0703080c
34193ce0:	0703040c 	.word	0x0703040c
34193ce4:	0703000c 	.word	0x0703000c
34193ce8:	07020c0c 	.word	0x07020c0c
34193cec:	0702080c 	.word	0x0702080c
34193cf0:	0702040c 	.word	0x0702040c
34193cf4:	0702000c 	.word	0x0702000c
34193cf8:	07010c0c 	.word	0x07010c0c
34193cfc:	0701080c 	.word	0x0701080c
34193d00:	0701040c 	.word	0x0701040c
34193d04:	0701000c 	.word	0x0701000c
34193d08:	07000c0c 	.word	0x07000c0c
34193d0c:	0700080c 	.word	0x0700080c
34193d10:	0700000c 	.word	0x0700000c
34193d14:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34193d18:	f7fa fb3a 	bl	3418e390 <LL_RCC_HSI_IsReady>
34193d1c:	4603      	mov	r3, r0
34193d1e:	2b00      	cmp	r3, #0
34193d20:	d016      	beq.n	34193d50 <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193d22:	f7fa fb47 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34193d26:	4603      	mov	r3, r0
34193d28:	09db      	lsrs	r3, r3, #7
34193d2a:	4a0d      	ldr	r2, [pc, #52]	@ (34193d60 <RCCEx_GetI2CCLKFreq+0x348>)
34193d2c:	fa22 f303 	lsr.w	r3, r2, r3
34193d30:	60fb      	str	r3, [r7, #12]
      }
      break;
34193d32:	e00d      	b.n	34193d50 <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34193d34:	f7fa fb4c 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34193d38:	4603      	mov	r3, r0
34193d3a:	2b00      	cmp	r3, #0
34193d3c:	d00a      	beq.n	34193d54 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
34193d3e:	4b09      	ldr	r3, [pc, #36]	@ (34193d64 <RCCEx_GetI2CCLKFreq+0x34c>)
34193d40:	60fb      	str	r3, [r7, #12]
      }
      break;
34193d42:	e007      	b.n	34193d54 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
34193d44:	bf00      	nop
34193d46:	e006      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34193d48:	bf00      	nop
34193d4a:	e004      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34193d4c:	bf00      	nop
34193d4e:	e002      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34193d50:	bf00      	nop
34193d52:	e000      	b.n	34193d56 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34193d54:	bf00      	nop
  }

  return i2c_frequency;
34193d56:	68fb      	ldr	r3, [r7, #12]
}
34193d58:	4618      	mov	r0, r3
34193d5a:	3710      	adds	r7, #16
34193d5c:	46bd      	mov	sp, r7
34193d5e:	bd80      	pop	{r7, pc}
34193d60:	03d09000 	.word	0x03d09000
34193d64:	003d0900 	.word	0x003d0900

34193d68 <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
34193d68:	b580      	push	{r7, lr}
34193d6a:	b084      	sub	sp, #16
34193d6c:	af00      	add	r7, sp, #0
34193d6e:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
34193d70:	2300      	movs	r3, #0
34193d72:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34193d74:	6878      	ldr	r0, [r7, #4]
34193d76:	f7fa fe5d 	bl	3418ea34 <LL_RCC_GetI3CClockSource>
34193d7a:	4603      	mov	r3, r0
34193d7c:	4a86      	ldr	r2, [pc, #536]	@ (34193f98 <RCCEx_GetI3CCLKFreq+0x230>)
34193d7e:	4293      	cmp	r3, r2
34193d80:	f000 80e6 	beq.w	34193f50 <RCCEx_GetI3CCLKFreq+0x1e8>
34193d84:	4a84      	ldr	r2, [pc, #528]	@ (34193f98 <RCCEx_GetI3CCLKFreq+0x230>)
34193d86:	4293      	cmp	r3, r2
34193d88:	f200 80f8 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193d8c:	4a83      	ldr	r2, [pc, #524]	@ (34193f9c <RCCEx_GetI3CCLKFreq+0x234>)
34193d8e:	4293      	cmp	r3, r2
34193d90:	f000 80de 	beq.w	34193f50 <RCCEx_GetI3CCLKFreq+0x1e8>
34193d94:	4a81      	ldr	r2, [pc, #516]	@ (34193f9c <RCCEx_GetI3CCLKFreq+0x234>)
34193d96:	4293      	cmp	r3, r2
34193d98:	f200 80f0 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193d9c:	4a80      	ldr	r2, [pc, #512]	@ (34193fa0 <RCCEx_GetI3CCLKFreq+0x238>)
34193d9e:	4293      	cmp	r3, r2
34193da0:	f000 80e4 	beq.w	34193f6c <RCCEx_GetI3CCLKFreq+0x204>
34193da4:	4a7e      	ldr	r2, [pc, #504]	@ (34193fa0 <RCCEx_GetI3CCLKFreq+0x238>)
34193da6:	4293      	cmp	r3, r2
34193da8:	f200 80e8 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193dac:	4a7d      	ldr	r2, [pc, #500]	@ (34193fa4 <RCCEx_GetI3CCLKFreq+0x23c>)
34193dae:	4293      	cmp	r3, r2
34193db0:	f000 80dc 	beq.w	34193f6c <RCCEx_GetI3CCLKFreq+0x204>
34193db4:	4a7b      	ldr	r2, [pc, #492]	@ (34193fa4 <RCCEx_GetI3CCLKFreq+0x23c>)
34193db6:	4293      	cmp	r3, r2
34193db8:	f200 80e0 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193dbc:	4a7a      	ldr	r2, [pc, #488]	@ (34193fa8 <RCCEx_GetI3CCLKFreq+0x240>)
34193dbe:	4293      	cmp	r3, r2
34193dc0:	f000 8083 	beq.w	34193eca <RCCEx_GetI3CCLKFreq+0x162>
34193dc4:	4a78      	ldr	r2, [pc, #480]	@ (34193fa8 <RCCEx_GetI3CCLKFreq+0x240>)
34193dc6:	4293      	cmp	r3, r2
34193dc8:	f200 80d8 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193dcc:	4a77      	ldr	r2, [pc, #476]	@ (34193fac <RCCEx_GetI3CCLKFreq+0x244>)
34193dce:	4293      	cmp	r3, r2
34193dd0:	d07b      	beq.n	34193eca <RCCEx_GetI3CCLKFreq+0x162>
34193dd2:	4a76      	ldr	r2, [pc, #472]	@ (34193fac <RCCEx_GetI3CCLKFreq+0x244>)
34193dd4:	4293      	cmp	r3, r2
34193dd6:	f200 80d1 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193dda:	4a75      	ldr	r2, [pc, #468]	@ (34193fb0 <RCCEx_GetI3CCLKFreq+0x248>)
34193ddc:	4293      	cmp	r3, r2
34193dde:	d030      	beq.n	34193e42 <RCCEx_GetI3CCLKFreq+0xda>
34193de0:	4a73      	ldr	r2, [pc, #460]	@ (34193fb0 <RCCEx_GetI3CCLKFreq+0x248>)
34193de2:	4293      	cmp	r3, r2
34193de4:	f200 80ca 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193de8:	4a72      	ldr	r2, [pc, #456]	@ (34193fb4 <RCCEx_GetI3CCLKFreq+0x24c>)
34193dea:	4293      	cmp	r3, r2
34193dec:	d029      	beq.n	34193e42 <RCCEx_GetI3CCLKFreq+0xda>
34193dee:	4a71      	ldr	r2, [pc, #452]	@ (34193fb4 <RCCEx_GetI3CCLKFreq+0x24c>)
34193df0:	4293      	cmp	r3, r2
34193df2:	f200 80c3 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193df6:	4a70      	ldr	r2, [pc, #448]	@ (34193fb8 <RCCEx_GetI3CCLKFreq+0x250>)
34193df8:	4293      	cmp	r3, r2
34193dfa:	d01d      	beq.n	34193e38 <RCCEx_GetI3CCLKFreq+0xd0>
34193dfc:	4a6e      	ldr	r2, [pc, #440]	@ (34193fb8 <RCCEx_GetI3CCLKFreq+0x250>)
34193dfe:	4293      	cmp	r3, r2
34193e00:	f200 80bc 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193e04:	4a6d      	ldr	r2, [pc, #436]	@ (34193fbc <RCCEx_GetI3CCLKFreq+0x254>)
34193e06:	4293      	cmp	r3, r2
34193e08:	d016      	beq.n	34193e38 <RCCEx_GetI3CCLKFreq+0xd0>
34193e0a:	4a6c      	ldr	r2, [pc, #432]	@ (34193fbc <RCCEx_GetI3CCLKFreq+0x254>)
34193e0c:	4293      	cmp	r3, r2
34193e0e:	f200 80b5 	bhi.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
34193e12:	4a6b      	ldr	r2, [pc, #428]	@ (34193fc0 <RCCEx_GetI3CCLKFreq+0x258>)
34193e14:	4293      	cmp	r3, r2
34193e16:	d003      	beq.n	34193e20 <RCCEx_GetI3CCLKFreq+0xb8>
34193e18:	4a6a      	ldr	r2, [pc, #424]	@ (34193fc4 <RCCEx_GetI3CCLKFreq+0x25c>)
34193e1a:	4293      	cmp	r3, r2
34193e1c:	f040 80ae 	bne.w	34193f7c <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34193e20:	f7f9 fe8e 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34193e24:	4603      	mov	r3, r0
34193e26:	4618      	mov	r0, r3
34193e28:	f7fe fe42 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34193e2c:	4603      	mov	r3, r0
34193e2e:	4618      	mov	r0, r3
34193e30:	f7fe fe4f 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34193e34:	60f8      	str	r0, [r7, #12]
      break;
34193e36:	e0aa      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34193e38:	2007      	movs	r0, #7
34193e3a:	f7ff f925 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34193e3e:	60f8      	str	r0, [r7, #12]
      break;
34193e40:	e0a5      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34193e42:	f7fb fb09 	bl	3418f458 <LL_RCC_IC10_IsEnabled>
34193e46:	4603      	mov	r3, r0
34193e48:	2b00      	cmp	r3, #0
34193e4a:	f000 8099 	beq.w	34193f80 <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34193e4e:	f7fb fb25 	bl	3418f49c <LL_RCC_IC10_GetDivider>
34193e52:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34193e54:	f7fb fb14 	bl	3418f480 <LL_RCC_IC10_GetSource>
34193e58:	4603      	mov	r3, r0
34193e5a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193e5e:	d029      	beq.n	34193eb4 <RCCEx_GetI3CCLKFreq+0x14c>
34193e60:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193e64:	d82f      	bhi.n	34193ec6 <RCCEx_GetI3CCLKFreq+0x15e>
34193e66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193e6a:	d01a      	beq.n	34193ea2 <RCCEx_GetI3CCLKFreq+0x13a>
34193e6c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193e70:	d829      	bhi.n	34193ec6 <RCCEx_GetI3CCLKFreq+0x15e>
34193e72:	2b00      	cmp	r3, #0
34193e74:	d003      	beq.n	34193e7e <RCCEx_GetI3CCLKFreq+0x116>
34193e76:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193e7a:	d009      	beq.n	34193e90 <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193e7c:	e023      	b.n	34193ec6 <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193e7e:	f7fe fcff 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193e82:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193e84:	68fa      	ldr	r2, [r7, #12]
34193e86:	68bb      	ldr	r3, [r7, #8]
34193e88:	fbb2 f3f3 	udiv	r3, r2, r3
34193e8c:	60fb      	str	r3, [r7, #12]
            break;
34193e8e:	e01b      	b.n	34193ec8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193e90:	f7fe fd3c 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193e94:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193e96:	68fa      	ldr	r2, [r7, #12]
34193e98:	68bb      	ldr	r3, [r7, #8]
34193e9a:	fbb2 f3f3 	udiv	r3, r2, r3
34193e9e:	60fb      	str	r3, [r7, #12]
            break;
34193ea0:	e012      	b.n	34193ec8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193ea2:	f7fe fd79 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193ea6:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193ea8:	68fa      	ldr	r2, [r7, #12]
34193eaa:	68bb      	ldr	r3, [r7, #8]
34193eac:	fbb2 f3f3 	udiv	r3, r2, r3
34193eb0:	60fb      	str	r3, [r7, #12]
            break;
34193eb2:	e009      	b.n	34193ec8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193eb4:	f7fe fdb6 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193eb8:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193eba:	68fa      	ldr	r2, [r7, #12]
34193ebc:	68bb      	ldr	r3, [r7, #8]
34193ebe:	fbb2 f3f3 	udiv	r3, r2, r3
34193ec2:	60fb      	str	r3, [r7, #12]
            break;
34193ec4:	e000      	b.n	34193ec8 <RCCEx_GetI3CCLKFreq+0x160>
            break;
34193ec6:	bf00      	nop
        }
      }
      break;
34193ec8:	e05a      	b.n	34193f80 <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34193eca:	f7fb fbc5 	bl	3418f658 <LL_RCC_IC15_IsEnabled>
34193ece:	4603      	mov	r3, r0
34193ed0:	2b00      	cmp	r3, #0
34193ed2:	d057      	beq.n	34193f84 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34193ed4:	f7fb fbe2 	bl	3418f69c <LL_RCC_IC15_GetDivider>
34193ed8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34193eda:	f7fb fbd1 	bl	3418f680 <LL_RCC_IC15_GetSource>
34193ede:	4603      	mov	r3, r0
34193ee0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193ee4:	d029      	beq.n	34193f3a <RCCEx_GetI3CCLKFreq+0x1d2>
34193ee6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34193eea:	d82f      	bhi.n	34193f4c <RCCEx_GetI3CCLKFreq+0x1e4>
34193eec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193ef0:	d01a      	beq.n	34193f28 <RCCEx_GetI3CCLKFreq+0x1c0>
34193ef2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34193ef6:	d829      	bhi.n	34193f4c <RCCEx_GetI3CCLKFreq+0x1e4>
34193ef8:	2b00      	cmp	r3, #0
34193efa:	d003      	beq.n	34193f04 <RCCEx_GetI3CCLKFreq+0x19c>
34193efc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34193f00:	d009      	beq.n	34193f16 <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34193f02:	e023      	b.n	34193f4c <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34193f04:	f7fe fcbc 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34193f08:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193f0a:	68fa      	ldr	r2, [r7, #12]
34193f0c:	68bb      	ldr	r3, [r7, #8]
34193f0e:	fbb2 f3f3 	udiv	r3, r2, r3
34193f12:	60fb      	str	r3, [r7, #12]
            break;
34193f14:	e01b      	b.n	34193f4e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34193f16:	f7fe fcf9 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34193f1a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193f1c:	68fa      	ldr	r2, [r7, #12]
34193f1e:	68bb      	ldr	r3, [r7, #8]
34193f20:	fbb2 f3f3 	udiv	r3, r2, r3
34193f24:	60fb      	str	r3, [r7, #12]
            break;
34193f26:	e012      	b.n	34193f4e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34193f28:	f7fe fd36 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34193f2c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193f2e:	68fa      	ldr	r2, [r7, #12]
34193f30:	68bb      	ldr	r3, [r7, #8]
34193f32:	fbb2 f3f3 	udiv	r3, r2, r3
34193f36:	60fb      	str	r3, [r7, #12]
            break;
34193f38:	e009      	b.n	34193f4e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34193f3a:	f7fe fd73 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34193f3e:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34193f40:	68fa      	ldr	r2, [r7, #12]
34193f42:	68bb      	ldr	r3, [r7, #8]
34193f44:	fbb2 f3f3 	udiv	r3, r2, r3
34193f48:	60fb      	str	r3, [r7, #12]
            break;
34193f4a:	e000      	b.n	34193f4e <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
34193f4c:	bf00      	nop
        }
      }
      break;
34193f4e:	e019      	b.n	34193f84 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34193f50:	f7fa fa1e 	bl	3418e390 <LL_RCC_HSI_IsReady>
34193f54:	4603      	mov	r3, r0
34193f56:	2b00      	cmp	r3, #0
34193f58:	d016      	beq.n	34193f88 <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34193f5a:	f7fa fa2b 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34193f5e:	4603      	mov	r3, r0
34193f60:	09db      	lsrs	r3, r3, #7
34193f62:	4a19      	ldr	r2, [pc, #100]	@ (34193fc8 <RCCEx_GetI3CCLKFreq+0x260>)
34193f64:	fa22 f303 	lsr.w	r3, r2, r3
34193f68:	60fb      	str	r3, [r7, #12]
      }
      break;
34193f6a:	e00d      	b.n	34193f88 <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34193f6c:	f7fa fa30 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34193f70:	4603      	mov	r3, r0
34193f72:	2b00      	cmp	r3, #0
34193f74:	d00a      	beq.n	34193f8c <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
34193f76:	4b15      	ldr	r3, [pc, #84]	@ (34193fcc <RCCEx_GetI3CCLKFreq+0x264>)
34193f78:	60fb      	str	r3, [r7, #12]
      }
      break;
34193f7a:	e007      	b.n	34193f8c <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
34193f7c:	bf00      	nop
34193f7e:	e006      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34193f80:	bf00      	nop
34193f82:	e004      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34193f84:	bf00      	nop
34193f86:	e002      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34193f88:	bf00      	nop
34193f8a:	e000      	b.n	34193f8e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34193f8c:	bf00      	nop
  }

  return i3c_frequency;
34193f8e:	68fb      	ldr	r3, [r7, #12]
}
34193f90:	4618      	mov	r0, r3
34193f92:	3710      	adds	r7, #16
34193f94:	46bd      	mov	sp, r7
34193f96:	bd80      	pop	{r7, pc}
34193f98:	0705140c 	.word	0x0705140c
34193f9c:	0705100c 	.word	0x0705100c
34193fa0:	0704140c 	.word	0x0704140c
34193fa4:	0704100c 	.word	0x0704100c
34193fa8:	0703140c 	.word	0x0703140c
34193fac:	0703100c 	.word	0x0703100c
34193fb0:	0702140c 	.word	0x0702140c
34193fb4:	0702100c 	.word	0x0702100c
34193fb8:	0701140c 	.word	0x0701140c
34193fbc:	0701100c 	.word	0x0701100c
34193fc0:	0700100c 	.word	0x0700100c
34193fc4:	0700140c 	.word	0x0700140c
34193fc8:	03d09000 	.word	0x03d09000
34193fcc:	003d0900 	.word	0x003d0900

34193fd0 <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
34193fd0:	b590      	push	{r4, r7, lr}
34193fd2:	b085      	sub	sp, #20
34193fd4:	af00      	add	r7, sp, #0
34193fd6:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
34193fd8:	2300      	movs	r3, #0
34193fda:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34193fdc:	6878      	ldr	r0, [r7, #4]
34193fde:	f7fa fd35 	bl	3418ea4c <LL_RCC_GetLPTIMClockSource>
34193fe2:	4603      	mov	r3, r0
34193fe4:	4aa1      	ldr	r2, [pc, #644]	@ (3419426c <RCCEx_GetLPTIMCLKFreq+0x29c>)
34193fe6:	4293      	cmp	r3, r2
34193fe8:	f000 8185 	beq.w	341942f6 <RCCEx_GetLPTIMCLKFreq+0x326>
34193fec:	4a9f      	ldr	r2, [pc, #636]	@ (3419426c <RCCEx_GetLPTIMCLKFreq+0x29c>)
34193fee:	4293      	cmp	r3, r2
34193ff0:	f200 818b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34193ff4:	4a9e      	ldr	r2, [pc, #632]	@ (34194270 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34193ff6:	4293      	cmp	r3, r2
34193ff8:	f000 817d 	beq.w	341942f6 <RCCEx_GetLPTIMCLKFreq+0x326>
34193ffc:	4a9c      	ldr	r2, [pc, #624]	@ (34194270 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34193ffe:	4293      	cmp	r3, r2
34194000:	f200 8183 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194004:	4a9b      	ldr	r2, [pc, #620]	@ (34194274 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34194006:	4293      	cmp	r3, r2
34194008:	f000 8175 	beq.w	341942f6 <RCCEx_GetLPTIMCLKFreq+0x326>
3419400c:	4a99      	ldr	r2, [pc, #612]	@ (34194274 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
3419400e:	4293      	cmp	r3, r2
34194010:	f200 817b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194014:	4a98      	ldr	r2, [pc, #608]	@ (34194278 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
34194016:	4293      	cmp	r3, r2
34194018:	f000 816d 	beq.w	341942f6 <RCCEx_GetLPTIMCLKFreq+0x326>
3419401c:	4a96      	ldr	r2, [pc, #600]	@ (34194278 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
3419401e:	4293      	cmp	r3, r2
34194020:	f200 8173 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194024:	4a95      	ldr	r2, [pc, #596]	@ (3419427c <RCCEx_GetLPTIMCLKFreq+0x2ac>)
34194026:	4293      	cmp	r3, r2
34194028:	f000 8165 	beq.w	341942f6 <RCCEx_GetLPTIMCLKFreq+0x326>
3419402c:	4a93      	ldr	r2, [pc, #588]	@ (3419427c <RCCEx_GetLPTIMCLKFreq+0x2ac>)
3419402e:	4293      	cmp	r3, r2
34194030:	f200 816b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194034:	4a92      	ldr	r2, [pc, #584]	@ (34194280 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
34194036:	4293      	cmp	r3, r2
34194038:	f000 8154 	beq.w	341942e4 <RCCEx_GetLPTIMCLKFreq+0x314>
3419403c:	4a90      	ldr	r2, [pc, #576]	@ (34194280 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
3419403e:	4293      	cmp	r3, r2
34194040:	f200 8163 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194044:	4a8f      	ldr	r2, [pc, #572]	@ (34194284 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
34194046:	4293      	cmp	r3, r2
34194048:	f000 814c 	beq.w	341942e4 <RCCEx_GetLPTIMCLKFreq+0x314>
3419404c:	4a8d      	ldr	r2, [pc, #564]	@ (34194284 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
3419404e:	4293      	cmp	r3, r2
34194050:	f200 815b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194054:	4a8c      	ldr	r2, [pc, #560]	@ (34194288 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
34194056:	4293      	cmp	r3, r2
34194058:	f000 8144 	beq.w	341942e4 <RCCEx_GetLPTIMCLKFreq+0x314>
3419405c:	4a8a      	ldr	r2, [pc, #552]	@ (34194288 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
3419405e:	4293      	cmp	r3, r2
34194060:	f200 8153 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194064:	4a89      	ldr	r2, [pc, #548]	@ (3419428c <RCCEx_GetLPTIMCLKFreq+0x2bc>)
34194066:	4293      	cmp	r3, r2
34194068:	f000 813c 	beq.w	341942e4 <RCCEx_GetLPTIMCLKFreq+0x314>
3419406c:	4a87      	ldr	r2, [pc, #540]	@ (3419428c <RCCEx_GetLPTIMCLKFreq+0x2bc>)
3419406e:	4293      	cmp	r3, r2
34194070:	f200 814b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194074:	4a86      	ldr	r2, [pc, #536]	@ (34194290 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34194076:	4293      	cmp	r3, r2
34194078:	f000 8134 	beq.w	341942e4 <RCCEx_GetLPTIMCLKFreq+0x314>
3419407c:	4a84      	ldr	r2, [pc, #528]	@ (34194290 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
3419407e:	4293      	cmp	r3, r2
34194080:	f200 8143 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194084:	4a83      	ldr	r2, [pc, #524]	@ (34194294 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34194086:	4293      	cmp	r3, r2
34194088:	f000 80e7 	beq.w	3419425a <RCCEx_GetLPTIMCLKFreq+0x28a>
3419408c:	4a81      	ldr	r2, [pc, #516]	@ (34194294 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
3419408e:	4293      	cmp	r3, r2
34194090:	f200 813b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194094:	4a80      	ldr	r2, [pc, #512]	@ (34194298 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34194096:	4293      	cmp	r3, r2
34194098:	f000 80df 	beq.w	3419425a <RCCEx_GetLPTIMCLKFreq+0x28a>
3419409c:	4a7e      	ldr	r2, [pc, #504]	@ (34194298 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
3419409e:	4293      	cmp	r3, r2
341940a0:	f200 8133 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940a4:	4a7d      	ldr	r2, [pc, #500]	@ (3419429c <RCCEx_GetLPTIMCLKFreq+0x2cc>)
341940a6:	4293      	cmp	r3, r2
341940a8:	f000 80d7 	beq.w	3419425a <RCCEx_GetLPTIMCLKFreq+0x28a>
341940ac:	4a7b      	ldr	r2, [pc, #492]	@ (3419429c <RCCEx_GetLPTIMCLKFreq+0x2cc>)
341940ae:	4293      	cmp	r3, r2
341940b0:	f200 812b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940b4:	4a7a      	ldr	r2, [pc, #488]	@ (341942a0 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
341940b6:	4293      	cmp	r3, r2
341940b8:	f000 80cf 	beq.w	3419425a <RCCEx_GetLPTIMCLKFreq+0x28a>
341940bc:	4a78      	ldr	r2, [pc, #480]	@ (341942a0 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
341940be:	4293      	cmp	r3, r2
341940c0:	f200 8123 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940c4:	4a77      	ldr	r2, [pc, #476]	@ (341942a4 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
341940c6:	4293      	cmp	r3, r2
341940c8:	f000 80c7 	beq.w	3419425a <RCCEx_GetLPTIMCLKFreq+0x28a>
341940cc:	4a75      	ldr	r2, [pc, #468]	@ (341942a4 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
341940ce:	4293      	cmp	r3, r2
341940d0:	f200 811b 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940d4:	4a74      	ldr	r2, [pc, #464]	@ (341942a8 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
341940d6:	4293      	cmp	r3, r2
341940d8:	d07b      	beq.n	341941d2 <RCCEx_GetLPTIMCLKFreq+0x202>
341940da:	4a73      	ldr	r2, [pc, #460]	@ (341942a8 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
341940dc:	4293      	cmp	r3, r2
341940de:	f200 8114 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940e2:	4a72      	ldr	r2, [pc, #456]	@ (341942ac <RCCEx_GetLPTIMCLKFreq+0x2dc>)
341940e4:	4293      	cmp	r3, r2
341940e6:	d074      	beq.n	341941d2 <RCCEx_GetLPTIMCLKFreq+0x202>
341940e8:	4a70      	ldr	r2, [pc, #448]	@ (341942ac <RCCEx_GetLPTIMCLKFreq+0x2dc>)
341940ea:	4293      	cmp	r3, r2
341940ec:	f200 810d 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940f0:	4a6f      	ldr	r2, [pc, #444]	@ (341942b0 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
341940f2:	4293      	cmp	r3, r2
341940f4:	d06d      	beq.n	341941d2 <RCCEx_GetLPTIMCLKFreq+0x202>
341940f6:	4a6e      	ldr	r2, [pc, #440]	@ (341942b0 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
341940f8:	4293      	cmp	r3, r2
341940fa:	f200 8106 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
341940fe:	4a6d      	ldr	r2, [pc, #436]	@ (341942b4 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34194100:	4293      	cmp	r3, r2
34194102:	d066      	beq.n	341941d2 <RCCEx_GetLPTIMCLKFreq+0x202>
34194104:	4a6b      	ldr	r2, [pc, #428]	@ (341942b4 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34194106:	4293      	cmp	r3, r2
34194108:	f200 80ff 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
3419410c:	4a6a      	ldr	r2, [pc, #424]	@ (341942b8 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
3419410e:	4293      	cmp	r3, r2
34194110:	d05f      	beq.n	341941d2 <RCCEx_GetLPTIMCLKFreq+0x202>
34194112:	4a69      	ldr	r2, [pc, #420]	@ (341942b8 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34194114:	4293      	cmp	r3, r2
34194116:	f200 80f8 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
3419411a:	4a68      	ldr	r2, [pc, #416]	@ (341942bc <RCCEx_GetLPTIMCLKFreq+0x2ec>)
3419411c:	4293      	cmp	r3, r2
3419411e:	d053      	beq.n	341941c8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34194120:	4a66      	ldr	r2, [pc, #408]	@ (341942bc <RCCEx_GetLPTIMCLKFreq+0x2ec>)
34194122:	4293      	cmp	r3, r2
34194124:	f200 80f1 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194128:	4a65      	ldr	r2, [pc, #404]	@ (341942c0 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
3419412a:	4293      	cmp	r3, r2
3419412c:	d04c      	beq.n	341941c8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3419412e:	4a64      	ldr	r2, [pc, #400]	@ (341942c0 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
34194130:	4293      	cmp	r3, r2
34194132:	f200 80ea 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194136:	4a63      	ldr	r2, [pc, #396]	@ (341942c4 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
34194138:	4293      	cmp	r3, r2
3419413a:	d045      	beq.n	341941c8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3419413c:	4a61      	ldr	r2, [pc, #388]	@ (341942c4 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
3419413e:	4293      	cmp	r3, r2
34194140:	f200 80e3 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194144:	4a60      	ldr	r2, [pc, #384]	@ (341942c8 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
34194146:	4293      	cmp	r3, r2
34194148:	d03e      	beq.n	341941c8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3419414a:	4a5f      	ldr	r2, [pc, #380]	@ (341942c8 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
3419414c:	4293      	cmp	r3, r2
3419414e:	f200 80dc 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194152:	4a5e      	ldr	r2, [pc, #376]	@ (341942cc <RCCEx_GetLPTIMCLKFreq+0x2fc>)
34194154:	4293      	cmp	r3, r2
34194156:	d037      	beq.n	341941c8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34194158:	4a5c      	ldr	r2, [pc, #368]	@ (341942cc <RCCEx_GetLPTIMCLKFreq+0x2fc>)
3419415a:	4293      	cmp	r3, r2
3419415c:	f200 80d5 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
34194160:	4a5b      	ldr	r2, [pc, #364]	@ (341942d0 <RCCEx_GetLPTIMCLKFreq+0x300>)
34194162:	4293      	cmp	r3, r2
34194164:	d024      	beq.n	341941b0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34194166:	4a5a      	ldr	r2, [pc, #360]	@ (341942d0 <RCCEx_GetLPTIMCLKFreq+0x300>)
34194168:	4293      	cmp	r3, r2
3419416a:	f200 80ce 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
3419416e:	4a59      	ldr	r2, [pc, #356]	@ (341942d4 <RCCEx_GetLPTIMCLKFreq+0x304>)
34194170:	4293      	cmp	r3, r2
34194172:	d01d      	beq.n	341941b0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34194174:	4a57      	ldr	r2, [pc, #348]	@ (341942d4 <RCCEx_GetLPTIMCLKFreq+0x304>)
34194176:	4293      	cmp	r3, r2
34194178:	f200 80c7 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
3419417c:	4a56      	ldr	r2, [pc, #344]	@ (341942d8 <RCCEx_GetLPTIMCLKFreq+0x308>)
3419417e:	4293      	cmp	r3, r2
34194180:	d016      	beq.n	341941b0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34194182:	4a55      	ldr	r2, [pc, #340]	@ (341942d8 <RCCEx_GetLPTIMCLKFreq+0x308>)
34194184:	4293      	cmp	r3, r2
34194186:	f200 80c0 	bhi.w	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
3419418a:	4a54      	ldr	r2, [pc, #336]	@ (341942dc <RCCEx_GetLPTIMCLKFreq+0x30c>)
3419418c:	4293      	cmp	r3, r2
3419418e:	d003      	beq.n	34194198 <RCCEx_GetLPTIMCLKFreq+0x1c8>
34194190:	4a53      	ldr	r2, [pc, #332]	@ (341942e0 <RCCEx_GetLPTIMCLKFreq+0x310>)
34194192:	4293      	cmp	r3, r2
34194194:	d00c      	beq.n	341941b0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34194196:	e0b8      	b.n	3419430a <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194198:	f7f9 fcd2 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
3419419c:	4603      	mov	r3, r0
3419419e:	4618      	mov	r0, r3
341941a0:	f7fe fc86 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341941a4:	4603      	mov	r3, r0
341941a6:	4618      	mov	r0, r3
341941a8:	f7fe fc93 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
341941ac:	60f8      	str	r0, [r7, #12]
      break;
341941ae:	e0b3      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341941b0:	f7f9 fcc6 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341941b4:	4603      	mov	r3, r0
341941b6:	4618      	mov	r0, r3
341941b8:	f7fe fc7a 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341941bc:	4603      	mov	r3, r0
341941be:	4618      	mov	r0, r3
341941c0:	f7fe fca8 	bl	34192b14 <RCCEx_GetPCLK4Freq>
341941c4:	60f8      	str	r0, [r7, #12]
      break;
341941c6:	e0a7      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341941c8:	2007      	movs	r0, #7
341941ca:	f7fe ff5d 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341941ce:	60f8      	str	r0, [r7, #12]
      break;
341941d0:	e0a2      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
341941d2:	f7fb fa41 	bl	3418f658 <LL_RCC_IC15_IsEnabled>
341941d6:	4603      	mov	r3, r0
341941d8:	2b00      	cmp	r3, #0
341941da:	f000 8098 	beq.w	3419430e <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
341941de:	f7fb fa5d 	bl	3418f69c <LL_RCC_IC15_GetDivider>
341941e2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
341941e4:	f7fb fa4c 	bl	3418f680 <LL_RCC_IC15_GetSource>
341941e8:	4603      	mov	r3, r0
341941ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341941ee:	d029      	beq.n	34194244 <RCCEx_GetLPTIMCLKFreq+0x274>
341941f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341941f4:	d82f      	bhi.n	34194256 <RCCEx_GetLPTIMCLKFreq+0x286>
341941f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341941fa:	d01a      	beq.n	34194232 <RCCEx_GetLPTIMCLKFreq+0x262>
341941fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194200:	d829      	bhi.n	34194256 <RCCEx_GetLPTIMCLKFreq+0x286>
34194202:	2b00      	cmp	r3, #0
34194204:	d003      	beq.n	3419420e <RCCEx_GetLPTIMCLKFreq+0x23e>
34194206:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419420a:	d009      	beq.n	34194220 <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
3419420c:	e023      	b.n	34194256 <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419420e:	f7fe fb37 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194212:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34194214:	68fa      	ldr	r2, [r7, #12]
34194216:	68bb      	ldr	r3, [r7, #8]
34194218:	fbb2 f3f3 	udiv	r3, r2, r3
3419421c:	60fb      	str	r3, [r7, #12]
            break;
3419421e:	e01b      	b.n	34194258 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194220:	f7fe fb74 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194224:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34194226:	68fa      	ldr	r2, [r7, #12]
34194228:	68bb      	ldr	r3, [r7, #8]
3419422a:	fbb2 f3f3 	udiv	r3, r2, r3
3419422e:	60fb      	str	r3, [r7, #12]
            break;
34194230:	e012      	b.n	34194258 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194232:	f7fe fbb1 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194236:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34194238:	68fa      	ldr	r2, [r7, #12]
3419423a:	68bb      	ldr	r3, [r7, #8]
3419423c:	fbb2 f3f3 	udiv	r3, r2, r3
34194240:	60fb      	str	r3, [r7, #12]
            break;
34194242:	e009      	b.n	34194258 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194244:	f7fe fbee 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194248:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
3419424a:	68fa      	ldr	r2, [r7, #12]
3419424c:	68bb      	ldr	r3, [r7, #8]
3419424e:	fbb2 f3f3 	udiv	r3, r2, r3
34194252:	60fb      	str	r3, [r7, #12]
            break;
34194254:	e000      	b.n	34194258 <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
34194256:	bf00      	nop
      break;
34194258:	e059      	b.n	3419430e <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
3419425a:	f7fa f8d9 	bl	3418e410 <LL_RCC_LSE_IsReady>
3419425e:	4603      	mov	r3, r0
34194260:	2b00      	cmp	r3, #0
34194262:	d056      	beq.n	34194312 <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
34194264:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34194268:	60fb      	str	r3, [r7, #12]
      break;
3419426a:	e052      	b.n	34194312 <RCCEx_GetLPTIMCLKFreq+0x342>
3419426c:	0705182c 	.word	0x0705182c
34194270:	0705142c 	.word	0x0705142c
34194274:	0705102c 	.word	0x0705102c
34194278:	07050c2c 	.word	0x07050c2c
3419427c:	0705082c 	.word	0x0705082c
34194280:	0704182c 	.word	0x0704182c
34194284:	0704142c 	.word	0x0704142c
34194288:	0704102c 	.word	0x0704102c
3419428c:	07040c2c 	.word	0x07040c2c
34194290:	0704082c 	.word	0x0704082c
34194294:	0703182c 	.word	0x0703182c
34194298:	0703142c 	.word	0x0703142c
3419429c:	0703102c 	.word	0x0703102c
341942a0:	07030c2c 	.word	0x07030c2c
341942a4:	0703082c 	.word	0x0703082c
341942a8:	0702182c 	.word	0x0702182c
341942ac:	0702142c 	.word	0x0702142c
341942b0:	0702102c 	.word	0x0702102c
341942b4:	07020c2c 	.word	0x07020c2c
341942b8:	0702082c 	.word	0x0702082c
341942bc:	0701182c 	.word	0x0701182c
341942c0:	0701142c 	.word	0x0701142c
341942c4:	0701102c 	.word	0x0701102c
341942c8:	07010c2c 	.word	0x07010c2c
341942cc:	0701082c 	.word	0x0701082c
341942d0:	0700182c 	.word	0x0700182c
341942d4:	0700142c 	.word	0x0700142c
341942d8:	0700102c 	.word	0x0700102c
341942dc:	0700082c 	.word	0x0700082c
341942e0:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
341942e4:	f7fa f8a6 	bl	3418e434 <LL_RCC_LSI_IsReady>
341942e8:	4603      	mov	r3, r0
341942ea:	2b00      	cmp	r3, #0
341942ec:	d013      	beq.n	34194316 <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
341942ee:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
341942f2:	60fb      	str	r3, [r7, #12]
      break;
341942f4:	e00f      	b.n	34194316 <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
341942f6:	f7f9 fc23 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341942fa:	4604      	mov	r4, r0
341942fc:	f7fa fcb0 	bl	3418ec60 <LL_RCC_GetTIMPrescaler>
34194300:	4603      	mov	r3, r0
34194302:	fa24 f303 	lsr.w	r3, r4, r3
34194306:	60fb      	str	r3, [r7, #12]
      break;
34194308:	e006      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3419430a:	bf00      	nop
3419430c:	e004      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3419430e:	bf00      	nop
34194310:	e002      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34194312:	bf00      	nop
34194314:	e000      	b.n	34194318 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34194316:	bf00      	nop
  }

  return lptim_frequency;
34194318:	68fb      	ldr	r3, [r7, #12]
}
3419431a:	4618      	mov	r0, r3
3419431c:	3714      	adds	r7, #20
3419431e:	46bd      	mov	sp, r7
34194320:	bd90      	pop	{r4, r7, pc}
34194322:	bf00      	nop

34194324 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
34194324:	b580      	push	{r7, lr}
34194326:	b084      	sub	sp, #16
34194328:	af00      	add	r7, sp, #0
3419432a:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
3419432c:	2300      	movs	r3, #0
3419432e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
34194330:	6878      	ldr	r0, [r7, #4]
34194332:	f7fa fb97 	bl	3418ea64 <LL_RCC_GetLPUARTClockSource>
34194336:	4603      	mov	r3, r0
34194338:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3419433c:	f000 80c0 	beq.w	341944c0 <RCCEx_GetLPUARTCLKFreq+0x19c>
34194340:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34194344:	f200 80db 	bhi.w	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
34194348:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3419434c:	f000 80c6 	beq.w	341944dc <RCCEx_GetLPUARTCLKFreq+0x1b8>
34194350:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34194354:	f200 80d3 	bhi.w	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
34194358:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419435c:	f000 80c6 	beq.w	341944ec <RCCEx_GetLPUARTCLKFreq+0x1c8>
34194360:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34194364:	f200 80cb 	bhi.w	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
34194368:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3419436c:	d065      	beq.n	3419443a <RCCEx_GetLPUARTCLKFreq+0x116>
3419436e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34194372:	f200 80c4 	bhi.w	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
34194376:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3419437a:	d01a      	beq.n	341943b2 <RCCEx_GetLPUARTCLKFreq+0x8e>
3419437c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34194380:	f200 80bd 	bhi.w	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
34194384:	2b00      	cmp	r3, #0
34194386:	d003      	beq.n	34194390 <RCCEx_GetLPUARTCLKFreq+0x6c>
34194388:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3419438c:	d00c      	beq.n	341943a8 <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
3419438e:	e0b6      	b.n	341944fe <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194390:	f7f9 fbd6 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194394:	4603      	mov	r3, r0
34194396:	4618      	mov	r0, r3
34194398:	f7fe fb8a 	bl	34192ab0 <RCCEx_GetHCLKFreq>
3419439c:	4603      	mov	r3, r0
3419439e:	4618      	mov	r0, r3
341943a0:	f7fe fbb8 	bl	34192b14 <RCCEx_GetPCLK4Freq>
341943a4:	60f8      	str	r0, [r7, #12]
      break;
341943a6:	e0b5      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341943a8:	2007      	movs	r0, #7
341943aa:	f7fe fe6d 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341943ae:	60f8      	str	r0, [r7, #12]
      break;
341943b0:	e0b0      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
341943b2:	f7fb f811 	bl	3418f3d8 <LL_RCC_IC9_IsEnabled>
341943b6:	4603      	mov	r3, r0
341943b8:	2b00      	cmp	r3, #0
341943ba:	f000 80a2 	beq.w	34194502 <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
341943be:	f7fb f82d 	bl	3418f41c <LL_RCC_IC9_GetDivider>
341943c2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
341943c4:	f7fb f81c 	bl	3418f400 <LL_RCC_IC9_GetSource>
341943c8:	4603      	mov	r3, r0
341943ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341943ce:	d029      	beq.n	34194424 <RCCEx_GetLPUARTCLKFreq+0x100>
341943d0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341943d4:	d82f      	bhi.n	34194436 <RCCEx_GetLPUARTCLKFreq+0x112>
341943d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341943da:	d01a      	beq.n	34194412 <RCCEx_GetLPUARTCLKFreq+0xee>
341943dc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341943e0:	d829      	bhi.n	34194436 <RCCEx_GetLPUARTCLKFreq+0x112>
341943e2:	2b00      	cmp	r3, #0
341943e4:	d003      	beq.n	341943ee <RCCEx_GetLPUARTCLKFreq+0xca>
341943e6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341943ea:	d009      	beq.n	34194400 <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
341943ec:	e023      	b.n	34194436 <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341943ee:	f7fe fa47 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341943f2:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
341943f4:	68fa      	ldr	r2, [r7, #12]
341943f6:	68bb      	ldr	r3, [r7, #8]
341943f8:	fbb2 f3f3 	udiv	r3, r2, r3
341943fc:	60fb      	str	r3, [r7, #12]
            break;
341943fe:	e01b      	b.n	34194438 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194400:	f7fe fa84 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194404:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34194406:	68fa      	ldr	r2, [r7, #12]
34194408:	68bb      	ldr	r3, [r7, #8]
3419440a:	fbb2 f3f3 	udiv	r3, r2, r3
3419440e:	60fb      	str	r3, [r7, #12]
            break;
34194410:	e012      	b.n	34194438 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194412:	f7fe fac1 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194416:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34194418:	68fa      	ldr	r2, [r7, #12]
3419441a:	68bb      	ldr	r3, [r7, #8]
3419441c:	fbb2 f3f3 	udiv	r3, r2, r3
34194420:	60fb      	str	r3, [r7, #12]
            break;
34194422:	e009      	b.n	34194438 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194424:	f7fe fafe 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194428:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3419442a:	68fa      	ldr	r2, [r7, #12]
3419442c:	68bb      	ldr	r3, [r7, #8]
3419442e:	fbb2 f3f3 	udiv	r3, r2, r3
34194432:	60fb      	str	r3, [r7, #12]
            break;
34194434:	e000      	b.n	34194438 <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
34194436:	bf00      	nop
      break;
34194438:	e063      	b.n	34194502 <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3419443a:	f7fb f8cd 	bl	3418f5d8 <LL_RCC_IC14_IsEnabled>
3419443e:	4603      	mov	r3, r0
34194440:	2b00      	cmp	r3, #0
34194442:	d060      	beq.n	34194506 <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
34194444:	f7fb f8ea 	bl	3418f61c <LL_RCC_IC14_GetDivider>
34194448:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3419444a:	f7fb f8d9 	bl	3418f600 <LL_RCC_IC14_GetSource>
3419444e:	4603      	mov	r3, r0
34194450:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194454:	d029      	beq.n	341944aa <RCCEx_GetLPUARTCLKFreq+0x186>
34194456:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419445a:	d82f      	bhi.n	341944bc <RCCEx_GetLPUARTCLKFreq+0x198>
3419445c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194460:	d01a      	beq.n	34194498 <RCCEx_GetLPUARTCLKFreq+0x174>
34194462:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194466:	d829      	bhi.n	341944bc <RCCEx_GetLPUARTCLKFreq+0x198>
34194468:	2b00      	cmp	r3, #0
3419446a:	d003      	beq.n	34194474 <RCCEx_GetLPUARTCLKFreq+0x150>
3419446c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194470:	d009      	beq.n	34194486 <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
34194472:	e023      	b.n	341944bc <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194474:	f7fe fa04 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194478:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3419447a:	68fa      	ldr	r2, [r7, #12]
3419447c:	68bb      	ldr	r3, [r7, #8]
3419447e:	fbb2 f3f3 	udiv	r3, r2, r3
34194482:	60fb      	str	r3, [r7, #12]
            break;
34194484:	e01b      	b.n	341944be <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194486:	f7fe fa41 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3419448a:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3419448c:	68fa      	ldr	r2, [r7, #12]
3419448e:	68bb      	ldr	r3, [r7, #8]
34194490:	fbb2 f3f3 	udiv	r3, r2, r3
34194494:	60fb      	str	r3, [r7, #12]
            break;
34194496:	e012      	b.n	341944be <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194498:	f7fe fa7e 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419449c:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3419449e:	68fa      	ldr	r2, [r7, #12]
341944a0:	68bb      	ldr	r3, [r7, #8]
341944a2:	fbb2 f3f3 	udiv	r3, r2, r3
341944a6:	60fb      	str	r3, [r7, #12]
            break;
341944a8:	e009      	b.n	341944be <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341944aa:	f7fe fabb 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341944ae:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
341944b0:	68fa      	ldr	r2, [r7, #12]
341944b2:	68bb      	ldr	r3, [r7, #8]
341944b4:	fbb2 f3f3 	udiv	r3, r2, r3
341944b8:	60fb      	str	r3, [r7, #12]
            break;
341944ba:	e000      	b.n	341944be <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
341944bc:	bf00      	nop
      break;
341944be:	e022      	b.n	34194506 <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
341944c0:	f7f9 ff66 	bl	3418e390 <LL_RCC_HSI_IsReady>
341944c4:	4603      	mov	r3, r0
341944c6:	2b00      	cmp	r3, #0
341944c8:	d01f      	beq.n	3419450a <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341944ca:	f7f9 ff73 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
341944ce:	4603      	mov	r3, r0
341944d0:	09db      	lsrs	r3, r3, #7
341944d2:	4a13      	ldr	r2, [pc, #76]	@ (34194520 <RCCEx_GetLPUARTCLKFreq+0x1fc>)
341944d4:	fa22 f303 	lsr.w	r3, r2, r3
341944d8:	60fb      	str	r3, [r7, #12]
      break;
341944da:	e016      	b.n	3419450a <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
341944dc:	f7f9 ff78 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
341944e0:	4603      	mov	r3, r0
341944e2:	2b00      	cmp	r3, #0
341944e4:	d013      	beq.n	3419450e <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
341944e6:	4b0f      	ldr	r3, [pc, #60]	@ (34194524 <RCCEx_GetLPUARTCLKFreq+0x200>)
341944e8:	60fb      	str	r3, [r7, #12]
      break;
341944ea:	e010      	b.n	3419450e <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
341944ec:	f7f9 ff90 	bl	3418e410 <LL_RCC_LSE_IsReady>
341944f0:	4603      	mov	r3, r0
341944f2:	2b00      	cmp	r3, #0
341944f4:	d00d      	beq.n	34194512 <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
341944f6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
341944fa:	60fb      	str	r3, [r7, #12]
      break;
341944fc:	e009      	b.n	34194512 <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
341944fe:	bf00      	nop
34194500:	e008      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34194502:	bf00      	nop
34194504:	e006      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34194506:	bf00      	nop
34194508:	e004      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3419450a:	bf00      	nop
3419450c:	e002      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3419450e:	bf00      	nop
34194510:	e000      	b.n	34194514 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34194512:	bf00      	nop
  }

  return lpuart_frequency;
34194514:	68fb      	ldr	r3, [r7, #12]
}
34194516:	4618      	mov	r0, r3
34194518:	3710      	adds	r7, #16
3419451a:	46bd      	mov	sp, r7
3419451c:	bd80      	pop	{r7, pc}
3419451e:	bf00      	nop
34194520:	03d09000 	.word	0x03d09000
34194524:	003d0900 	.word	0x003d0900

34194528 <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
34194528:	b580      	push	{r7, lr}
3419452a:	b084      	sub	sp, #16
3419452c:	af00      	add	r7, sp, #0
3419452e:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
34194530:	2300      	movs	r3, #0
34194532:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34194534:	6878      	ldr	r0, [r7, #4]
34194536:	f7fa faa7 	bl	3418ea88 <LL_RCC_GetLTDCClockSource>
3419453a:	4603      	mov	r3, r0
3419453c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34194540:	d062      	beq.n	34194608 <RCCEx_GetLTDCCLKFreq+0xe0>
34194542:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34194546:	d86d      	bhi.n	34194624 <RCCEx_GetLTDCCLKFreq+0xfc>
34194548:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3419454c:	d019      	beq.n	34194582 <RCCEx_GetLTDCCLKFreq+0x5a>
3419454e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34194552:	d867      	bhi.n	34194624 <RCCEx_GetLTDCCLKFreq+0xfc>
34194554:	2b00      	cmp	r3, #0
34194556:	d003      	beq.n	34194560 <RCCEx_GetLTDCCLKFreq+0x38>
34194558:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3419455c:	d00c      	beq.n	34194578 <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
3419455e:	e061      	b.n	34194624 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194560:	f7f9 faee 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194564:	4603      	mov	r3, r0
34194566:	4618      	mov	r0, r3
34194568:	f7fe faa2 	bl	34192ab0 <RCCEx_GetHCLKFreq>
3419456c:	4603      	mov	r3, r0
3419456e:	4618      	mov	r0, r3
34194570:	f7fe fae1 	bl	34192b36 <RCCEx_GetPCLK5Freq>
34194574:	60f8      	str	r0, [r7, #12]
      break;
34194576:	e05a      	b.n	3419462e <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194578:	2007      	movs	r0, #7
3419457a:	f7fe fd85 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
3419457e:	60f8      	str	r0, [r7, #12]
      break;
34194580:	e055      	b.n	3419462e <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
34194582:	f7fb f8a9 	bl	3418f6d8 <LL_RCC_IC16_IsEnabled>
34194586:	4603      	mov	r3, r0
34194588:	2b00      	cmp	r3, #0
3419458a:	d04d      	beq.n	34194628 <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
3419458c:	f7fb f8c6 	bl	3418f71c <LL_RCC_IC16_GetDivider>
34194590:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
34194592:	f7fb f8b5 	bl	3418f700 <LL_RCC_IC16_GetSource>
34194596:	4603      	mov	r3, r0
34194598:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419459c:	d029      	beq.n	341945f2 <RCCEx_GetLTDCCLKFreq+0xca>
3419459e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341945a2:	d82f      	bhi.n	34194604 <RCCEx_GetLTDCCLKFreq+0xdc>
341945a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341945a8:	d01a      	beq.n	341945e0 <RCCEx_GetLTDCCLKFreq+0xb8>
341945aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341945ae:	d829      	bhi.n	34194604 <RCCEx_GetLTDCCLKFreq+0xdc>
341945b0:	2b00      	cmp	r3, #0
341945b2:	d003      	beq.n	341945bc <RCCEx_GetLTDCCLKFreq+0x94>
341945b4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341945b8:	d009      	beq.n	341945ce <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
341945ba:	e023      	b.n	34194604 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341945bc:	f7fe f960 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341945c0:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
341945c2:	68fa      	ldr	r2, [r7, #12]
341945c4:	68bb      	ldr	r3, [r7, #8]
341945c6:	fbb2 f3f3 	udiv	r3, r2, r3
341945ca:	60fb      	str	r3, [r7, #12]
            break;
341945cc:	e01b      	b.n	34194606 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341945ce:	f7fe f99d 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341945d2:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
341945d4:	68fa      	ldr	r2, [r7, #12]
341945d6:	68bb      	ldr	r3, [r7, #8]
341945d8:	fbb2 f3f3 	udiv	r3, r2, r3
341945dc:	60fb      	str	r3, [r7, #12]
            break;
341945de:	e012      	b.n	34194606 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341945e0:	f7fe f9da 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341945e4:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
341945e6:	68fa      	ldr	r2, [r7, #12]
341945e8:	68bb      	ldr	r3, [r7, #8]
341945ea:	fbb2 f3f3 	udiv	r3, r2, r3
341945ee:	60fb      	str	r3, [r7, #12]
            break;
341945f0:	e009      	b.n	34194606 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341945f2:	f7fe fa17 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341945f6:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
341945f8:	68fa      	ldr	r2, [r7, #12]
341945fa:	68bb      	ldr	r3, [r7, #8]
341945fc:	fbb2 f3f3 	udiv	r3, r2, r3
34194600:	60fb      	str	r3, [r7, #12]
            break;
34194602:	e000      	b.n	34194606 <RCCEx_GetLTDCCLKFreq+0xde>
            break;
34194604:	bf00      	nop
      break;
34194606:	e00f      	b.n	34194628 <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34194608:	f7f9 fec2 	bl	3418e390 <LL_RCC_HSI_IsReady>
3419460c:	4603      	mov	r3, r0
3419460e:	2b00      	cmp	r3, #0
34194610:	d00c      	beq.n	3419462c <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34194612:	f7f9 fecf 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34194616:	4603      	mov	r3, r0
34194618:	09db      	lsrs	r3, r3, #7
3419461a:	4a07      	ldr	r2, [pc, #28]	@ (34194638 <RCCEx_GetLTDCCLKFreq+0x110>)
3419461c:	fa22 f303 	lsr.w	r3, r2, r3
34194620:	60fb      	str	r3, [r7, #12]
      break;
34194622:	e003      	b.n	3419462c <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34194624:	bf00      	nop
34194626:	e002      	b.n	3419462e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34194628:	bf00      	nop
3419462a:	e000      	b.n	3419462e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
3419462c:	bf00      	nop
  }

  return ltdc_frequency;
3419462e:	68fb      	ldr	r3, [r7, #12]
}
34194630:	4618      	mov	r0, r3
34194632:	3710      	adds	r7, #16
34194634:	46bd      	mov	sp, r7
34194636:	bd80      	pop	{r7, pc}
34194638:	03d09000 	.word	0x03d09000

3419463c <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
3419463c:	b590      	push	{r4, r7, lr}
3419463e:	b085      	sub	sp, #20
34194640:	af00      	add	r7, sp, #0
34194642:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34194644:	2300      	movs	r3, #0
34194646:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
34194648:	6878      	ldr	r0, [r7, #4]
3419464a:	f7fa fa2f 	bl	3418eaac <LL_RCC_GetMDFClockSource>
3419464e:	4603      	mov	r3, r0
34194650:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34194654:	f000 80dd 	beq.w	34194812 <RCCEx_GetMDFCLKFreq+0x1d6>
34194658:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3419465c:	f200 80e3 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
34194660:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34194664:	f000 80d2 	beq.w	3419480c <RCCEx_GetMDFCLKFreq+0x1d0>
34194668:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3419466c:	f200 80db 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
34194670:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34194674:	f000 80b4 	beq.w	341947e0 <RCCEx_GetMDFCLKFreq+0x1a4>
34194678:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3419467c:	f200 80d3 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
34194680:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34194684:	f000 80ba 	beq.w	341947fc <RCCEx_GetMDFCLKFreq+0x1c0>
34194688:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3419468c:	f200 80cb 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
34194690:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34194694:	d061      	beq.n	3419475a <RCCEx_GetMDFCLKFreq+0x11e>
34194696:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3419469a:	f200 80c4 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
3419469e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
341946a2:	d016      	beq.n	341946d2 <RCCEx_GetMDFCLKFreq+0x96>
341946a4:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
341946a8:	f200 80bd 	bhi.w	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
341946ac:	2b00      	cmp	r3, #0
341946ae:	d003      	beq.n	341946b8 <RCCEx_GetMDFCLKFreq+0x7c>
341946b0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
341946b4:	d008      	beq.n	341946c8 <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
341946b6:	e0b6      	b.n	34194826 <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
341946b8:	f7f9 fa42 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341946bc:	4603      	mov	r3, r0
341946be:	4618      	mov	r0, r3
341946c0:	f7fe f9f6 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341946c4:	60f8      	str	r0, [r7, #12]
      break;
341946c6:	e0b7      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341946c8:	2007      	movs	r0, #7
341946ca:	f7fe fcdd 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341946ce:	60f8      	str	r0, [r7, #12]
      break;
341946d0:	e0b2      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
341946d2:	f7fa fe01 	bl	3418f2d8 <LL_RCC_IC7_IsEnabled>
341946d6:	4603      	mov	r3, r0
341946d8:	2b00      	cmp	r3, #0
341946da:	f000 80a6 	beq.w	3419482a <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
341946de:	f7fa fe1d 	bl	3418f31c <LL_RCC_IC7_GetDivider>
341946e2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
341946e4:	f7fa fe0c 	bl	3418f300 <LL_RCC_IC7_GetSource>
341946e8:	4603      	mov	r3, r0
341946ea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341946ee:	d029      	beq.n	34194744 <RCCEx_GetMDFCLKFreq+0x108>
341946f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341946f4:	d82f      	bhi.n	34194756 <RCCEx_GetMDFCLKFreq+0x11a>
341946f6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341946fa:	d01a      	beq.n	34194732 <RCCEx_GetMDFCLKFreq+0xf6>
341946fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194700:	d829      	bhi.n	34194756 <RCCEx_GetMDFCLKFreq+0x11a>
34194702:	2b00      	cmp	r3, #0
34194704:	d003      	beq.n	3419470e <RCCEx_GetMDFCLKFreq+0xd2>
34194706:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419470a:	d009      	beq.n	34194720 <RCCEx_GetMDFCLKFreq+0xe4>
            break;
3419470c:	e023      	b.n	34194756 <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3419470e:	f7fe f8b7 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194712:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34194714:	68fa      	ldr	r2, [r7, #12]
34194716:	68bb      	ldr	r3, [r7, #8]
34194718:	fbb2 f3f3 	udiv	r3, r2, r3
3419471c:	60fb      	str	r3, [r7, #12]
            break;
3419471e:	e01b      	b.n	34194758 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194720:	f7fe f8f4 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194724:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34194726:	68fa      	ldr	r2, [r7, #12]
34194728:	68bb      	ldr	r3, [r7, #8]
3419472a:	fbb2 f3f3 	udiv	r3, r2, r3
3419472e:	60fb      	str	r3, [r7, #12]
            break;
34194730:	e012      	b.n	34194758 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194732:	f7fe f931 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194736:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34194738:	68fa      	ldr	r2, [r7, #12]
3419473a:	68bb      	ldr	r3, [r7, #8]
3419473c:	fbb2 f3f3 	udiv	r3, r2, r3
34194740:	60fb      	str	r3, [r7, #12]
            break;
34194742:	e009      	b.n	34194758 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194744:	f7fe f96e 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194748:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3419474a:	68fa      	ldr	r2, [r7, #12]
3419474c:	68bb      	ldr	r3, [r7, #8]
3419474e:	fbb2 f3f3 	udiv	r3, r2, r3
34194752:	60fb      	str	r3, [r7, #12]
            break;
34194754:	e000      	b.n	34194758 <RCCEx_GetMDFCLKFreq+0x11c>
            break;
34194756:	bf00      	nop
      break;
34194758:	e067      	b.n	3419482a <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3419475a:	f7fa fdfd 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
3419475e:	4603      	mov	r3, r0
34194760:	2b00      	cmp	r3, #0
34194762:	d064      	beq.n	3419482e <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
34194764:	f7fa fe1a 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34194768:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3419476a:	f7fa fe09 	bl	3418f380 <LL_RCC_IC8_GetSource>
3419476e:	4603      	mov	r3, r0
34194770:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194774:	d029      	beq.n	341947ca <RCCEx_GetMDFCLKFreq+0x18e>
34194776:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419477a:	d82f      	bhi.n	341947dc <RCCEx_GetMDFCLKFreq+0x1a0>
3419477c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194780:	d01a      	beq.n	341947b8 <RCCEx_GetMDFCLKFreq+0x17c>
34194782:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194786:	d829      	bhi.n	341947dc <RCCEx_GetMDFCLKFreq+0x1a0>
34194788:	2b00      	cmp	r3, #0
3419478a:	d003      	beq.n	34194794 <RCCEx_GetMDFCLKFreq+0x158>
3419478c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194790:	d009      	beq.n	341947a6 <RCCEx_GetMDFCLKFreq+0x16a>
            break;
34194792:	e023      	b.n	341947dc <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194794:	f7fe f874 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194798:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3419479a:	68fa      	ldr	r2, [r7, #12]
3419479c:	68bb      	ldr	r3, [r7, #8]
3419479e:	fbb2 f3f3 	udiv	r3, r2, r3
341947a2:	60fb      	str	r3, [r7, #12]
            break;
341947a4:	e01b      	b.n	341947de <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341947a6:	f7fe f8b1 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341947aa:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
341947ac:	68fa      	ldr	r2, [r7, #12]
341947ae:	68bb      	ldr	r3, [r7, #8]
341947b0:	fbb2 f3f3 	udiv	r3, r2, r3
341947b4:	60fb      	str	r3, [r7, #12]
            break;
341947b6:	e012      	b.n	341947de <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341947b8:	f7fe f8ee 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341947bc:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
341947be:	68fa      	ldr	r2, [r7, #12]
341947c0:	68bb      	ldr	r3, [r7, #8]
341947c2:	fbb2 f3f3 	udiv	r3, r2, r3
341947c6:	60fb      	str	r3, [r7, #12]
            break;
341947c8:	e009      	b.n	341947de <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341947ca:	f7fe f92b 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341947ce:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
341947d0:	68fa      	ldr	r2, [r7, #12]
341947d2:	68bb      	ldr	r3, [r7, #8]
341947d4:	fbb2 f3f3 	udiv	r3, r2, r3
341947d8:	60fb      	str	r3, [r7, #12]
            break;
341947da:	e000      	b.n	341947de <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
341947dc:	bf00      	nop
      break;
341947de:	e026      	b.n	3419482e <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
341947e0:	f7f9 fdd6 	bl	3418e390 <LL_RCC_HSI_IsReady>
341947e4:	4603      	mov	r3, r0
341947e6:	2b00      	cmp	r3, #0
341947e8:	d023      	beq.n	34194832 <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341947ea:	f7f9 fde3 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
341947ee:	4603      	mov	r3, r0
341947f0:	09db      	lsrs	r3, r3, #7
341947f2:	4a14      	ldr	r2, [pc, #80]	@ (34194844 <RCCEx_GetMDFCLKFreq+0x208>)
341947f4:	fa22 f303 	lsr.w	r3, r2, r3
341947f8:	60fb      	str	r3, [r7, #12]
      break;
341947fa:	e01a      	b.n	34194832 <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
341947fc:	f7f9 fde8 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34194800:	4603      	mov	r3, r0
34194802:	2b00      	cmp	r3, #0
34194804:	d017      	beq.n	34194836 <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
34194806:	4b10      	ldr	r3, [pc, #64]	@ (34194848 <RCCEx_GetMDFCLKFreq+0x20c>)
34194808:	60fb      	str	r3, [r7, #12]
      break;
3419480a:	e014      	b.n	34194836 <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
3419480c:	4b0f      	ldr	r3, [pc, #60]	@ (3419484c <RCCEx_GetMDFCLKFreq+0x210>)
3419480e:	60fb      	str	r3, [r7, #12]
      break;
34194810:	e012      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34194812:	f7f9 f995 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194816:	4604      	mov	r4, r0
34194818:	f7fa fa22 	bl	3418ec60 <LL_RCC_GetTIMPrescaler>
3419481c:	4603      	mov	r3, r0
3419481e:	fa24 f303 	lsr.w	r3, r4, r3
34194822:	60fb      	str	r3, [r7, #12]
      break;
34194824:	e008      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34194826:	bf00      	nop
34194828:	e006      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3419482a:	bf00      	nop
3419482c:	e004      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3419482e:	bf00      	nop
34194830:	e002      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34194832:	bf00      	nop
34194834:	e000      	b.n	34194838 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34194836:	bf00      	nop
  }

  return adf_frequency;
34194838:	68fb      	ldr	r3, [r7, #12]
}
3419483a:	4618      	mov	r0, r3
3419483c:	3714      	adds	r7, #20
3419483e:	46bd      	mov	sp, r7
34194840:	bd90      	pop	{r4, r7, pc}
34194842:	bf00      	nop
34194844:	03d09000 	.word	0x03d09000
34194848:	003d0900 	.word	0x003d0900
3419484c:	00bb8000 	.word	0x00bb8000

34194850 <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
34194850:	b580      	push	{r7, lr}
34194852:	b084      	sub	sp, #16
34194854:	af00      	add	r7, sp, #0
34194856:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
34194858:	2300      	movs	r3, #0
3419485a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3419485c:	6878      	ldr	r0, [r7, #4]
3419485e:	f7fa f937 	bl	3418ead0 <LL_RCC_GetPSSIClockSource>
34194862:	4603      	mov	r3, r0
34194864:	2b30      	cmp	r3, #48	@ 0x30
34194866:	d05a      	beq.n	3419491e <RCCEx_GetPSSICLKFreq+0xce>
34194868:	2b30      	cmp	r3, #48	@ 0x30
3419486a:	d866      	bhi.n	3419493a <RCCEx_GetPSSICLKFreq+0xea>
3419486c:	2b20      	cmp	r3, #32
3419486e:	d013      	beq.n	34194898 <RCCEx_GetPSSICLKFreq+0x48>
34194870:	2b20      	cmp	r3, #32
34194872:	d862      	bhi.n	3419493a <RCCEx_GetPSSICLKFreq+0xea>
34194874:	2b00      	cmp	r3, #0
34194876:	d002      	beq.n	3419487e <RCCEx_GetPSSICLKFreq+0x2e>
34194878:	2b10      	cmp	r3, #16
3419487a:	d008      	beq.n	3419488e <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
3419487c:	e05d      	b.n	3419493a <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3419487e:	f7f9 f95f 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194882:	4603      	mov	r3, r0
34194884:	4618      	mov	r0, r3
34194886:	f7fe f913 	bl	34192ab0 <RCCEx_GetHCLKFreq>
3419488a:	60f8      	str	r0, [r7, #12]
      break;
3419488c:	e05a      	b.n	34194944 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419488e:	2007      	movs	r0, #7
34194890:	f7fe fbfa 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34194894:	60f8      	str	r0, [r7, #12]
      break;
34194896:	e055      	b.n	34194944 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
34194898:	f7fb f81e 	bl	3418f8d8 <LL_RCC_IC20_IsEnabled>
3419489c:	4603      	mov	r3, r0
3419489e:	2b00      	cmp	r3, #0
341948a0:	d04d      	beq.n	3419493e <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
341948a2:	f7fb f83b 	bl	3418f91c <LL_RCC_IC20_GetDivider>
341948a6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
341948a8:	f7fb f82a 	bl	3418f900 <LL_RCC_IC20_GetSource>
341948ac:	4603      	mov	r3, r0
341948ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341948b2:	d029      	beq.n	34194908 <RCCEx_GetPSSICLKFreq+0xb8>
341948b4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341948b8:	d82f      	bhi.n	3419491a <RCCEx_GetPSSICLKFreq+0xca>
341948ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341948be:	d01a      	beq.n	341948f6 <RCCEx_GetPSSICLKFreq+0xa6>
341948c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341948c4:	d829      	bhi.n	3419491a <RCCEx_GetPSSICLKFreq+0xca>
341948c6:	2b00      	cmp	r3, #0
341948c8:	d003      	beq.n	341948d2 <RCCEx_GetPSSICLKFreq+0x82>
341948ca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341948ce:	d009      	beq.n	341948e4 <RCCEx_GetPSSICLKFreq+0x94>
            break;
341948d0:	e023      	b.n	3419491a <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341948d2:	f7fd ffd5 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341948d6:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
341948d8:	68fa      	ldr	r2, [r7, #12]
341948da:	68bb      	ldr	r3, [r7, #8]
341948dc:	fbb2 f3f3 	udiv	r3, r2, r3
341948e0:	60fb      	str	r3, [r7, #12]
            break;
341948e2:	e01b      	b.n	3419491c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341948e4:	f7fe f812 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341948e8:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
341948ea:	68fa      	ldr	r2, [r7, #12]
341948ec:	68bb      	ldr	r3, [r7, #8]
341948ee:	fbb2 f3f3 	udiv	r3, r2, r3
341948f2:	60fb      	str	r3, [r7, #12]
            break;
341948f4:	e012      	b.n	3419491c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341948f6:	f7fe f84f 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341948fa:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
341948fc:	68fa      	ldr	r2, [r7, #12]
341948fe:	68bb      	ldr	r3, [r7, #8]
34194900:	fbb2 f3f3 	udiv	r3, r2, r3
34194904:	60fb      	str	r3, [r7, #12]
            break;
34194906:	e009      	b.n	3419491c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194908:	f7fe f88c 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419490c:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
3419490e:	68fa      	ldr	r2, [r7, #12]
34194910:	68bb      	ldr	r3, [r7, #8]
34194912:	fbb2 f3f3 	udiv	r3, r2, r3
34194916:	60fb      	str	r3, [r7, #12]
            break;
34194918:	e000      	b.n	3419491c <RCCEx_GetPSSICLKFreq+0xcc>
            break;
3419491a:	bf00      	nop
      break;
3419491c:	e00f      	b.n	3419493e <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
3419491e:	f7f9 fd37 	bl	3418e390 <LL_RCC_HSI_IsReady>
34194922:	4603      	mov	r3, r0
34194924:	2b00      	cmp	r3, #0
34194926:	d00c      	beq.n	34194942 <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34194928:	f7f9 fd44 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
3419492c:	4603      	mov	r3, r0
3419492e:	09db      	lsrs	r3, r3, #7
34194930:	4a07      	ldr	r2, [pc, #28]	@ (34194950 <RCCEx_GetPSSICLKFreq+0x100>)
34194932:	fa22 f303 	lsr.w	r3, r2, r3
34194936:	60fb      	str	r3, [r7, #12]
      break;
34194938:	e003      	b.n	34194942 <RCCEx_GetPSSICLKFreq+0xf2>
      break;
3419493a:	bf00      	nop
3419493c:	e002      	b.n	34194944 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
3419493e:	bf00      	nop
34194940:	e000      	b.n	34194944 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34194942:	bf00      	nop
  }

  return pssi_frequency;
34194944:	68fb      	ldr	r3, [r7, #12]
}
34194946:	4618      	mov	r0, r3
34194948:	3710      	adds	r7, #16
3419494a:	46bd      	mov	sp, r7
3419494c:	bd80      	pop	{r7, pc}
3419494e:	bf00      	nop
34194950:	03d09000 	.word	0x03d09000

34194954 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
34194954:	b580      	push	{r7, lr}
34194956:	b082      	sub	sp, #8
34194958:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
3419495a:	2300      	movs	r3, #0
3419495c:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
3419495e:	f7fa f945 	bl	3418ebec <LL_RCC_GetRTCClockSource>
34194962:	4603      	mov	r3, r0
34194964:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34194968:	d020      	beq.n	341949ac <RCCEx_GetRTCCLKFreq+0x58>
3419496a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3419496e:	d830      	bhi.n	341949d2 <RCCEx_GetRTCCLKFreq+0x7e>
34194970:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34194974:	d011      	beq.n	3419499a <RCCEx_GetRTCCLKFreq+0x46>
34194976:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3419497a:	d82a      	bhi.n	341949d2 <RCCEx_GetRTCCLKFreq+0x7e>
3419497c:	2b00      	cmp	r3, #0
3419497e:	d02a      	beq.n	341949d6 <RCCEx_GetRTCCLKFreq+0x82>
34194980:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34194984:	d000      	beq.n	34194988 <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
34194986:	e024      	b.n	341949d2 <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
34194988:	f7f9 fd42 	bl	3418e410 <LL_RCC_LSE_IsReady>
3419498c:	4603      	mov	r3, r0
3419498e:	2b00      	cmp	r3, #0
34194990:	d023      	beq.n	341949da <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
34194992:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34194996:	607b      	str	r3, [r7, #4]
      break;
34194998:	e01f      	b.n	341949da <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
3419499a:	f7f9 fd4b 	bl	3418e434 <LL_RCC_LSI_IsReady>
3419499e:	4603      	mov	r3, r0
341949a0:	2b00      	cmp	r3, #0
341949a2:	d01c      	beq.n	341949de <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
341949a4:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
341949a8:	607b      	str	r3, [r7, #4]
      break;
341949aa:	e018      	b.n	341949de <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
341949ac:	f7f9 fcde 	bl	3418e36c <LL_RCC_HSE_IsReady>
341949b0:	4603      	mov	r3, r0
341949b2:	2b00      	cmp	r3, #0
341949b4:	d015      	beq.n	341949e2 <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
341949b6:	4b0e      	ldr	r3, [pc, #56]	@ (341949f0 <RCCEx_GetRTCCLKFreq+0x9c>)
341949b8:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
341949bc:	0b1b      	lsrs	r3, r3, #12
341949be:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341949c2:	3301      	adds	r3, #1
341949c4:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
341949c6:	4a0b      	ldr	r2, [pc, #44]	@ (341949f4 <RCCEx_GetRTCCLKFreq+0xa0>)
341949c8:	683b      	ldr	r3, [r7, #0]
341949ca:	fbb2 f3f3 	udiv	r3, r2, r3
341949ce:	607b      	str	r3, [r7, #4]
      break;
341949d0:	e007      	b.n	341949e2 <RCCEx_GetRTCCLKFreq+0x8e>
      break;
341949d2:	bf00      	nop
341949d4:	e006      	b.n	341949e4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
341949d6:	bf00      	nop
341949d8:	e004      	b.n	341949e4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
341949da:	bf00      	nop
341949dc:	e002      	b.n	341949e4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
341949de:	bf00      	nop
341949e0:	e000      	b.n	341949e4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
341949e2:	bf00      	nop
  }

  return rtc_frequency;
341949e4:	687b      	ldr	r3, [r7, #4]
}
341949e6:	4618      	mov	r0, r3
341949e8:	3708      	adds	r7, #8
341949ea:	46bd      	mov	sp, r7
341949ec:	bd80      	pop	{r7, pc}
341949ee:	bf00      	nop
341949f0:	56028000 	.word	0x56028000
341949f4:	02dc6c00 	.word	0x02dc6c00

341949f8 <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
341949f8:	b580      	push	{r7, lr}
341949fa:	b084      	sub	sp, #16
341949fc:	af00      	add	r7, sp, #0
341949fe:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
34194a00:	2300      	movs	r3, #0
34194a02:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34194a04:	6878      	ldr	r0, [r7, #4]
34194a06:	f7fa f875 	bl	3418eaf4 <LL_RCC_GetSAIClockSource>
34194a0a:	4603      	mov	r3, r0
34194a0c:	4a9a      	ldr	r2, [pc, #616]	@ (34194c78 <RCCEx_GetSAICLKFreq+0x280>)
34194a0e:	4293      	cmp	r3, r2
34194a10:	f000 811f 	beq.w	34194c52 <RCCEx_GetSAICLKFreq+0x25a>
34194a14:	4a98      	ldr	r2, [pc, #608]	@ (34194c78 <RCCEx_GetSAICLKFreq+0x280>)
34194a16:	4293      	cmp	r3, r2
34194a18:	f200 8120 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a1c:	4a97      	ldr	r2, [pc, #604]	@ (34194c7c <RCCEx_GetSAICLKFreq+0x284>)
34194a1e:	4293      	cmp	r3, r2
34194a20:	f000 8117 	beq.w	34194c52 <RCCEx_GetSAICLKFreq+0x25a>
34194a24:	4a95      	ldr	r2, [pc, #596]	@ (34194c7c <RCCEx_GetSAICLKFreq+0x284>)
34194a26:	4293      	cmp	r3, r2
34194a28:	f200 8118 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a2c:	4a94      	ldr	r2, [pc, #592]	@ (34194c80 <RCCEx_GetSAICLKFreq+0x288>)
34194a2e:	4293      	cmp	r3, r2
34194a30:	f000 810c 	beq.w	34194c4c <RCCEx_GetSAICLKFreq+0x254>
34194a34:	4a92      	ldr	r2, [pc, #584]	@ (34194c80 <RCCEx_GetSAICLKFreq+0x288>)
34194a36:	4293      	cmp	r3, r2
34194a38:	f200 8110 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a3c:	4a91      	ldr	r2, [pc, #580]	@ (34194c84 <RCCEx_GetSAICLKFreq+0x28c>)
34194a3e:	4293      	cmp	r3, r2
34194a40:	f000 8104 	beq.w	34194c4c <RCCEx_GetSAICLKFreq+0x254>
34194a44:	4a8f      	ldr	r2, [pc, #572]	@ (34194c84 <RCCEx_GetSAICLKFreq+0x28c>)
34194a46:	4293      	cmp	r3, r2
34194a48:	f200 8108 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a4c:	4a8e      	ldr	r2, [pc, #568]	@ (34194c88 <RCCEx_GetSAICLKFreq+0x290>)
34194a4e:	4293      	cmp	r3, r2
34194a50:	f000 80e6 	beq.w	34194c20 <RCCEx_GetSAICLKFreq+0x228>
34194a54:	4a8c      	ldr	r2, [pc, #560]	@ (34194c88 <RCCEx_GetSAICLKFreq+0x290>)
34194a56:	4293      	cmp	r3, r2
34194a58:	f200 8100 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a5c:	4a8b      	ldr	r2, [pc, #556]	@ (34194c8c <RCCEx_GetSAICLKFreq+0x294>)
34194a5e:	4293      	cmp	r3, r2
34194a60:	f000 80de 	beq.w	34194c20 <RCCEx_GetSAICLKFreq+0x228>
34194a64:	4a89      	ldr	r2, [pc, #548]	@ (34194c8c <RCCEx_GetSAICLKFreq+0x294>)
34194a66:	4293      	cmp	r3, r2
34194a68:	f200 80f8 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a6c:	4a88      	ldr	r2, [pc, #544]	@ (34194c90 <RCCEx_GetSAICLKFreq+0x298>)
34194a6e:	4293      	cmp	r3, r2
34194a70:	f000 80e4 	beq.w	34194c3c <RCCEx_GetSAICLKFreq+0x244>
34194a74:	4a86      	ldr	r2, [pc, #536]	@ (34194c90 <RCCEx_GetSAICLKFreq+0x298>)
34194a76:	4293      	cmp	r3, r2
34194a78:	f200 80f0 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a7c:	4a85      	ldr	r2, [pc, #532]	@ (34194c94 <RCCEx_GetSAICLKFreq+0x29c>)
34194a7e:	4293      	cmp	r3, r2
34194a80:	f000 80dc 	beq.w	34194c3c <RCCEx_GetSAICLKFreq+0x244>
34194a84:	4a83      	ldr	r2, [pc, #524]	@ (34194c94 <RCCEx_GetSAICLKFreq+0x29c>)
34194a86:	4293      	cmp	r3, r2
34194a88:	f200 80e8 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a8c:	4a82      	ldr	r2, [pc, #520]	@ (34194c98 <RCCEx_GetSAICLKFreq+0x2a0>)
34194a8e:	4293      	cmp	r3, r2
34194a90:	f000 8083 	beq.w	34194b9a <RCCEx_GetSAICLKFreq+0x1a2>
34194a94:	4a80      	ldr	r2, [pc, #512]	@ (34194c98 <RCCEx_GetSAICLKFreq+0x2a0>)
34194a96:	4293      	cmp	r3, r2
34194a98:	f200 80e0 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194a9c:	4a7f      	ldr	r2, [pc, #508]	@ (34194c9c <RCCEx_GetSAICLKFreq+0x2a4>)
34194a9e:	4293      	cmp	r3, r2
34194aa0:	d07b      	beq.n	34194b9a <RCCEx_GetSAICLKFreq+0x1a2>
34194aa2:	4a7e      	ldr	r2, [pc, #504]	@ (34194c9c <RCCEx_GetSAICLKFreq+0x2a4>)
34194aa4:	4293      	cmp	r3, r2
34194aa6:	f200 80d9 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194aaa:	4a7d      	ldr	r2, [pc, #500]	@ (34194ca0 <RCCEx_GetSAICLKFreq+0x2a8>)
34194aac:	4293      	cmp	r3, r2
34194aae:	d030      	beq.n	34194b12 <RCCEx_GetSAICLKFreq+0x11a>
34194ab0:	4a7b      	ldr	r2, [pc, #492]	@ (34194ca0 <RCCEx_GetSAICLKFreq+0x2a8>)
34194ab2:	4293      	cmp	r3, r2
34194ab4:	f200 80d2 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194ab8:	4a7a      	ldr	r2, [pc, #488]	@ (34194ca4 <RCCEx_GetSAICLKFreq+0x2ac>)
34194aba:	4293      	cmp	r3, r2
34194abc:	d029      	beq.n	34194b12 <RCCEx_GetSAICLKFreq+0x11a>
34194abe:	4a79      	ldr	r2, [pc, #484]	@ (34194ca4 <RCCEx_GetSAICLKFreq+0x2ac>)
34194ac0:	4293      	cmp	r3, r2
34194ac2:	f200 80cb 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194ac6:	4a78      	ldr	r2, [pc, #480]	@ (34194ca8 <RCCEx_GetSAICLKFreq+0x2b0>)
34194ac8:	4293      	cmp	r3, r2
34194aca:	d01d      	beq.n	34194b08 <RCCEx_GetSAICLKFreq+0x110>
34194acc:	4a76      	ldr	r2, [pc, #472]	@ (34194ca8 <RCCEx_GetSAICLKFreq+0x2b0>)
34194ace:	4293      	cmp	r3, r2
34194ad0:	f200 80c4 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194ad4:	4a75      	ldr	r2, [pc, #468]	@ (34194cac <RCCEx_GetSAICLKFreq+0x2b4>)
34194ad6:	4293      	cmp	r3, r2
34194ad8:	d016      	beq.n	34194b08 <RCCEx_GetSAICLKFreq+0x110>
34194ada:	4a74      	ldr	r2, [pc, #464]	@ (34194cac <RCCEx_GetSAICLKFreq+0x2b4>)
34194adc:	4293      	cmp	r3, r2
34194ade:	f200 80bd 	bhi.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
34194ae2:	4a73      	ldr	r2, [pc, #460]	@ (34194cb0 <RCCEx_GetSAICLKFreq+0x2b8>)
34194ae4:	4293      	cmp	r3, r2
34194ae6:	d003      	beq.n	34194af0 <RCCEx_GetSAICLKFreq+0xf8>
34194ae8:	4a72      	ldr	r2, [pc, #456]	@ (34194cb4 <RCCEx_GetSAICLKFreq+0x2bc>)
34194aea:	4293      	cmp	r3, r2
34194aec:	f040 80b6 	bne.w	34194c5c <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194af0:	f7f9 f826 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194af4:	4603      	mov	r3, r0
34194af6:	4618      	mov	r0, r3
34194af8:	f7fd ffda 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34194afc:	4603      	mov	r3, r0
34194afe:	4618      	mov	r0, r3
34194b00:	f7fd fff7 	bl	34192af2 <RCCEx_GetPCLK2Freq>
34194b04:	60f8      	str	r0, [r7, #12]
      break;
34194b06:	e0b2      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194b08:	2007      	movs	r0, #7
34194b0a:	f7fe fabd 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34194b0e:	60f8      	str	r0, [r7, #12]
      break;
34194b10:	e0ad      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34194b12:	f7fa fbe1 	bl	3418f2d8 <LL_RCC_IC7_IsEnabled>
34194b16:	4603      	mov	r3, r0
34194b18:	2b00      	cmp	r3, #0
34194b1a:	f000 80a1 	beq.w	34194c60 <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34194b1e:	f7fa fbfd 	bl	3418f31c <LL_RCC_IC7_GetDivider>
34194b22:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34194b24:	f7fa fbec 	bl	3418f300 <LL_RCC_IC7_GetSource>
34194b28:	4603      	mov	r3, r0
34194b2a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194b2e:	d029      	beq.n	34194b84 <RCCEx_GetSAICLKFreq+0x18c>
34194b30:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194b34:	d82f      	bhi.n	34194b96 <RCCEx_GetSAICLKFreq+0x19e>
34194b36:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194b3a:	d01a      	beq.n	34194b72 <RCCEx_GetSAICLKFreq+0x17a>
34194b3c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194b40:	d829      	bhi.n	34194b96 <RCCEx_GetSAICLKFreq+0x19e>
34194b42:	2b00      	cmp	r3, #0
34194b44:	d003      	beq.n	34194b4e <RCCEx_GetSAICLKFreq+0x156>
34194b46:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194b4a:	d009      	beq.n	34194b60 <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194b4c:	e023      	b.n	34194b96 <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194b4e:	f7fd fe97 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194b52:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194b54:	68fa      	ldr	r2, [r7, #12]
34194b56:	68bb      	ldr	r3, [r7, #8]
34194b58:	fbb2 f3f3 	udiv	r3, r2, r3
34194b5c:	60fb      	str	r3, [r7, #12]
            break;
34194b5e:	e01b      	b.n	34194b98 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194b60:	f7fd fed4 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194b64:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194b66:	68fa      	ldr	r2, [r7, #12]
34194b68:	68bb      	ldr	r3, [r7, #8]
34194b6a:	fbb2 f3f3 	udiv	r3, r2, r3
34194b6e:	60fb      	str	r3, [r7, #12]
            break;
34194b70:	e012      	b.n	34194b98 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194b72:	f7fd ff11 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194b76:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194b78:	68fa      	ldr	r2, [r7, #12]
34194b7a:	68bb      	ldr	r3, [r7, #8]
34194b7c:	fbb2 f3f3 	udiv	r3, r2, r3
34194b80:	60fb      	str	r3, [r7, #12]
            break;
34194b82:	e009      	b.n	34194b98 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194b84:	f7fd ff4e 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194b88:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194b8a:	68fa      	ldr	r2, [r7, #12]
34194b8c:	68bb      	ldr	r3, [r7, #8]
34194b8e:	fbb2 f3f3 	udiv	r3, r2, r3
34194b92:	60fb      	str	r3, [r7, #12]
            break;
34194b94:	e000      	b.n	34194b98 <RCCEx_GetSAICLKFreq+0x1a0>
            break;
34194b96:	bf00      	nop
        }
      }
      break;
34194b98:	e062      	b.n	34194c60 <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34194b9a:	f7fa fbdd 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
34194b9e:	4603      	mov	r3, r0
34194ba0:	2b00      	cmp	r3, #0
34194ba2:	d05f      	beq.n	34194c64 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34194ba4:	f7fa fbfa 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34194ba8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34194baa:	f7fa fbe9 	bl	3418f380 <LL_RCC_IC8_GetSource>
34194bae:	4603      	mov	r3, r0
34194bb0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194bb4:	d029      	beq.n	34194c0a <RCCEx_GetSAICLKFreq+0x212>
34194bb6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194bba:	d82f      	bhi.n	34194c1c <RCCEx_GetSAICLKFreq+0x224>
34194bbc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194bc0:	d01a      	beq.n	34194bf8 <RCCEx_GetSAICLKFreq+0x200>
34194bc2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194bc6:	d829      	bhi.n	34194c1c <RCCEx_GetSAICLKFreq+0x224>
34194bc8:	2b00      	cmp	r3, #0
34194bca:	d003      	beq.n	34194bd4 <RCCEx_GetSAICLKFreq+0x1dc>
34194bcc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194bd0:	d009      	beq.n	34194be6 <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194bd2:	e023      	b.n	34194c1c <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194bd4:	f7fd fe54 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194bd8:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194bda:	68fa      	ldr	r2, [r7, #12]
34194bdc:	68bb      	ldr	r3, [r7, #8]
34194bde:	fbb2 f3f3 	udiv	r3, r2, r3
34194be2:	60fb      	str	r3, [r7, #12]
            break;
34194be4:	e01b      	b.n	34194c1e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194be6:	f7fd fe91 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194bea:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194bec:	68fa      	ldr	r2, [r7, #12]
34194bee:	68bb      	ldr	r3, [r7, #8]
34194bf0:	fbb2 f3f3 	udiv	r3, r2, r3
34194bf4:	60fb      	str	r3, [r7, #12]
            break;
34194bf6:	e012      	b.n	34194c1e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194bf8:	f7fd fece 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194bfc:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194bfe:	68fa      	ldr	r2, [r7, #12]
34194c00:	68bb      	ldr	r3, [r7, #8]
34194c02:	fbb2 f3f3 	udiv	r3, r2, r3
34194c06:	60fb      	str	r3, [r7, #12]
            break;
34194c08:	e009      	b.n	34194c1e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194c0a:	f7fd ff0b 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194c0e:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34194c10:	68fa      	ldr	r2, [r7, #12]
34194c12:	68bb      	ldr	r3, [r7, #8]
34194c14:	fbb2 f3f3 	udiv	r3, r2, r3
34194c18:	60fb      	str	r3, [r7, #12]
            break;
34194c1a:	e000      	b.n	34194c1e <RCCEx_GetSAICLKFreq+0x226>
            break;
34194c1c:	bf00      	nop
        }
      }
      break;
34194c1e:	e021      	b.n	34194c64 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34194c20:	f7f9 fbb6 	bl	3418e390 <LL_RCC_HSI_IsReady>
34194c24:	4603      	mov	r3, r0
34194c26:	2b00      	cmp	r3, #0
34194c28:	d01e      	beq.n	34194c68 <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34194c2a:	f7f9 fbc3 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34194c2e:	4603      	mov	r3, r0
34194c30:	09db      	lsrs	r3, r3, #7
34194c32:	4a21      	ldr	r2, [pc, #132]	@ (34194cb8 <RCCEx_GetSAICLKFreq+0x2c0>)
34194c34:	fa22 f303 	lsr.w	r3, r2, r3
34194c38:	60fb      	str	r3, [r7, #12]
      }
      break;
34194c3a:	e015      	b.n	34194c68 <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34194c3c:	f7f9 fbc8 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34194c40:	4603      	mov	r3, r0
34194c42:	2b00      	cmp	r3, #0
34194c44:	d012      	beq.n	34194c6c <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
34194c46:	4b1d      	ldr	r3, [pc, #116]	@ (34194cbc <RCCEx_GetSAICLKFreq+0x2c4>)
34194c48:	60fb      	str	r3, [r7, #12]
      }
      break;
34194c4a:	e00f      	b.n	34194c6c <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
34194c4c:	4b1c      	ldr	r3, [pc, #112]	@ (34194cc0 <RCCEx_GetSAICLKFreq+0x2c8>)
34194c4e:	60fb      	str	r3, [r7, #12]
      break;
34194c50:	e00d      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34194c52:	2007      	movs	r0, #7
34194c54:	f000 f920 	bl	34194e98 <RCCEx_GetSPDIFRXCLKFreq>
34194c58:	60f8      	str	r0, [r7, #12]
      break;
34194c5a:	e008      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
34194c5c:	bf00      	nop
34194c5e:	e006      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>
      break;
34194c60:	bf00      	nop
34194c62:	e004      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>
      break;
34194c64:	bf00      	nop
34194c66:	e002      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>
      break;
34194c68:	bf00      	nop
34194c6a:	e000      	b.n	34194c6e <RCCEx_GetSAICLKFreq+0x276>
      break;
34194c6c:	bf00      	nop
  }

  return sai_frequency;
34194c6e:	68fb      	ldr	r3, [r7, #12]
}
34194c70:	4618      	mov	r0, r3
34194c72:	3710      	adds	r7, #16
34194c74:	46bd      	mov	sp, r7
34194c76:	bd80      	pop	{r7, pc}
34194c78:	07071818 	.word	0x07071818
34194c7c:	07071418 	.word	0x07071418
34194c80:	07061818 	.word	0x07061818
34194c84:	07061418 	.word	0x07061418
34194c88:	07051818 	.word	0x07051818
34194c8c:	07051418 	.word	0x07051418
34194c90:	07041818 	.word	0x07041818
34194c94:	07041418 	.word	0x07041418
34194c98:	07031818 	.word	0x07031818
34194c9c:	07031418 	.word	0x07031418
34194ca0:	07021818 	.word	0x07021818
34194ca4:	07021418 	.word	0x07021418
34194ca8:	07011818 	.word	0x07011818
34194cac:	07011418 	.word	0x07011418
34194cb0:	07001418 	.word	0x07001418
34194cb4:	07001818 	.word	0x07001818
34194cb8:	03d09000 	.word	0x03d09000
34194cbc:	003d0900 	.word	0x003d0900
34194cc0:	00bb8000 	.word	0x00bb8000

34194cc4 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
34194cc4:	b580      	push	{r7, lr}
34194cc6:	b084      	sub	sp, #16
34194cc8:	af00      	add	r7, sp, #0
34194cca:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34194ccc:	2300      	movs	r3, #0
34194cce:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34194cd0:	6878      	ldr	r0, [r7, #4]
34194cd2:	f7f9 ff1b 	bl	3418eb0c <LL_RCC_GetSDMMCClockSource>
34194cd6:	4603      	mov	r3, r0
34194cd8:	4a67      	ldr	r2, [pc, #412]	@ (34194e78 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34194cda:	4293      	cmp	r3, r2
34194cdc:	d07e      	beq.n	34194ddc <RCCEx_GetSDMMCCLKFreq+0x118>
34194cde:	4a66      	ldr	r2, [pc, #408]	@ (34194e78 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34194ce0:	4293      	cmp	r3, r2
34194ce2:	f200 80be 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194ce6:	4a65      	ldr	r2, [pc, #404]	@ (34194e7c <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34194ce8:	4293      	cmp	r3, r2
34194cea:	d077      	beq.n	34194ddc <RCCEx_GetSDMMCCLKFreq+0x118>
34194cec:	4a63      	ldr	r2, [pc, #396]	@ (34194e7c <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34194cee:	4293      	cmp	r3, r2
34194cf0:	f200 80b7 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194cf4:	4a62      	ldr	r2, [pc, #392]	@ (34194e80 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34194cf6:	4293      	cmp	r3, r2
34194cf8:	d02c      	beq.n	34194d54 <RCCEx_GetSDMMCCLKFreq+0x90>
34194cfa:	4a61      	ldr	r2, [pc, #388]	@ (34194e80 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34194cfc:	4293      	cmp	r3, r2
34194cfe:	f200 80b0 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194d02:	4a60      	ldr	r2, [pc, #384]	@ (34194e84 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34194d04:	4293      	cmp	r3, r2
34194d06:	d025      	beq.n	34194d54 <RCCEx_GetSDMMCCLKFreq+0x90>
34194d08:	4a5e      	ldr	r2, [pc, #376]	@ (34194e84 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34194d0a:	4293      	cmp	r3, r2
34194d0c:	f200 80a9 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194d10:	4a5d      	ldr	r2, [pc, #372]	@ (34194e88 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34194d12:	4293      	cmp	r3, r2
34194d14:	d019      	beq.n	34194d4a <RCCEx_GetSDMMCCLKFreq+0x86>
34194d16:	4a5c      	ldr	r2, [pc, #368]	@ (34194e88 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34194d18:	4293      	cmp	r3, r2
34194d1a:	f200 80a2 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194d1e:	4a5b      	ldr	r2, [pc, #364]	@ (34194e8c <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34194d20:	4293      	cmp	r3, r2
34194d22:	d012      	beq.n	34194d4a <RCCEx_GetSDMMCCLKFreq+0x86>
34194d24:	4a59      	ldr	r2, [pc, #356]	@ (34194e8c <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34194d26:	4293      	cmp	r3, r2
34194d28:	f200 809b 	bhi.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
34194d2c:	4a58      	ldr	r2, [pc, #352]	@ (34194e90 <RCCEx_GetSDMMCCLKFreq+0x1cc>)
34194d2e:	4293      	cmp	r3, r2
34194d30:	d003      	beq.n	34194d3a <RCCEx_GetSDMMCCLKFreq+0x76>
34194d32:	4a58      	ldr	r2, [pc, #352]	@ (34194e94 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
34194d34:	4293      	cmp	r3, r2
34194d36:	f040 8094 	bne.w	34194e62 <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34194d3a:	f7f8 ff01 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194d3e:	4603      	mov	r3, r0
34194d40:	4618      	mov	r0, r3
34194d42:	f7fd feb5 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34194d46:	60f8      	str	r0, [r7, #12]
      break;
34194d48:	e090      	b.n	34194e6c <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194d4a:	2007      	movs	r0, #7
34194d4c:	f7fe f99c 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34194d50:	60f8      	str	r0, [r7, #12]
      break;
34194d52:	e08b      	b.n	34194e6c <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
34194d54:	f7fa fa40 	bl	3418f1d8 <LL_RCC_IC4_IsEnabled>
34194d58:	4603      	mov	r3, r0
34194d5a:	2b00      	cmp	r3, #0
34194d5c:	f000 8083 	beq.w	34194e66 <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34194d60:	f7fa fa5c 	bl	3418f21c <LL_RCC_IC4_GetDivider>
34194d64:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34194d66:	f7fa fa4b 	bl	3418f200 <LL_RCC_IC4_GetSource>
34194d6a:	4603      	mov	r3, r0
34194d6c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194d70:	d029      	beq.n	34194dc6 <RCCEx_GetSDMMCCLKFreq+0x102>
34194d72:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194d76:	d82f      	bhi.n	34194dd8 <RCCEx_GetSDMMCCLKFreq+0x114>
34194d78:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194d7c:	d01a      	beq.n	34194db4 <RCCEx_GetSDMMCCLKFreq+0xf0>
34194d7e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194d82:	d829      	bhi.n	34194dd8 <RCCEx_GetSDMMCCLKFreq+0x114>
34194d84:	2b00      	cmp	r3, #0
34194d86:	d003      	beq.n	34194d90 <RCCEx_GetSDMMCCLKFreq+0xcc>
34194d88:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194d8c:	d009      	beq.n	34194da2 <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194d8e:	e023      	b.n	34194dd8 <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194d90:	f7fd fd76 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194d94:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194d96:	68fa      	ldr	r2, [r7, #12]
34194d98:	68bb      	ldr	r3, [r7, #8]
34194d9a:	fbb2 f3f3 	udiv	r3, r2, r3
34194d9e:	60fb      	str	r3, [r7, #12]
            break;
34194da0:	e01b      	b.n	34194dda <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194da2:	f7fd fdb3 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194da6:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194da8:	68fa      	ldr	r2, [r7, #12]
34194daa:	68bb      	ldr	r3, [r7, #8]
34194dac:	fbb2 f3f3 	udiv	r3, r2, r3
34194db0:	60fb      	str	r3, [r7, #12]
            break;
34194db2:	e012      	b.n	34194dda <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194db4:	f7fd fdf0 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194db8:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194dba:	68fa      	ldr	r2, [r7, #12]
34194dbc:	68bb      	ldr	r3, [r7, #8]
34194dbe:	fbb2 f3f3 	udiv	r3, r2, r3
34194dc2:	60fb      	str	r3, [r7, #12]
            break;
34194dc4:	e009      	b.n	34194dda <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194dc6:	f7fd fe2d 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194dca:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194dcc:	68fa      	ldr	r2, [r7, #12]
34194dce:	68bb      	ldr	r3, [r7, #8]
34194dd0:	fbb2 f3f3 	udiv	r3, r2, r3
34194dd4:	60fb      	str	r3, [r7, #12]
            break;
34194dd6:	e000      	b.n	34194dda <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
34194dd8:	bf00      	nop
        }
      }
      break;
34194dda:	e044      	b.n	34194e66 <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
34194ddc:	f7fa fa3c 	bl	3418f258 <LL_RCC_IC5_IsEnabled>
34194de0:	4603      	mov	r3, r0
34194de2:	2b00      	cmp	r3, #0
34194de4:	d041      	beq.n	34194e6a <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
34194de6:	f7fa fa59 	bl	3418f29c <LL_RCC_IC5_GetDivider>
34194dea:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
34194dec:	f7fa fa48 	bl	3418f280 <LL_RCC_IC5_GetSource>
34194df0:	4603      	mov	r3, r0
34194df2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194df6:	d029      	beq.n	34194e4c <RCCEx_GetSDMMCCLKFreq+0x188>
34194df8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194dfc:	d82f      	bhi.n	34194e5e <RCCEx_GetSDMMCCLKFreq+0x19a>
34194dfe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e02:	d01a      	beq.n	34194e3a <RCCEx_GetSDMMCCLKFreq+0x176>
34194e04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194e08:	d829      	bhi.n	34194e5e <RCCEx_GetSDMMCCLKFreq+0x19a>
34194e0a:	2b00      	cmp	r3, #0
34194e0c:	d003      	beq.n	34194e16 <RCCEx_GetSDMMCCLKFreq+0x152>
34194e0e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194e12:	d009      	beq.n	34194e28 <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194e14:	e023      	b.n	34194e5e <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194e16:	f7fd fd33 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194e1a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194e1c:	68fa      	ldr	r2, [r7, #12]
34194e1e:	68bb      	ldr	r3, [r7, #8]
34194e20:	fbb2 f3f3 	udiv	r3, r2, r3
34194e24:	60fb      	str	r3, [r7, #12]
            break;
34194e26:	e01b      	b.n	34194e60 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194e28:	f7fd fd70 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194e2c:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194e2e:	68fa      	ldr	r2, [r7, #12]
34194e30:	68bb      	ldr	r3, [r7, #8]
34194e32:	fbb2 f3f3 	udiv	r3, r2, r3
34194e36:	60fb      	str	r3, [r7, #12]
            break;
34194e38:	e012      	b.n	34194e60 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194e3a:	f7fd fdad 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194e3e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194e40:	68fa      	ldr	r2, [r7, #12]
34194e42:	68bb      	ldr	r3, [r7, #8]
34194e44:	fbb2 f3f3 	udiv	r3, r2, r3
34194e48:	60fb      	str	r3, [r7, #12]
            break;
34194e4a:	e009      	b.n	34194e60 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194e4c:	f7fd fdea 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194e50:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34194e52:	68fa      	ldr	r2, [r7, #12]
34194e54:	68bb      	ldr	r3, [r7, #8]
34194e56:	fbb2 f3f3 	udiv	r3, r2, r3
34194e5a:	60fb      	str	r3, [r7, #12]
            break;
34194e5c:	e000      	b.n	34194e60 <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
34194e5e:	bf00      	nop
        }
      }
      break;
34194e60:	e003      	b.n	34194e6a <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
34194e62:	bf00      	nop
34194e64:	e002      	b.n	34194e6c <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34194e66:	bf00      	nop
34194e68:	e000      	b.n	34194e6c <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34194e6a:	bf00      	nop
  }

  return sdmmc_frequency;
34194e6c:	68fb      	ldr	r3, [r7, #12]
}
34194e6e:	4618      	mov	r0, r3
34194e70:	3710      	adds	r7, #16
34194e72:	46bd      	mov	sp, r7
34194e74:	bd80      	pop	{r7, pc}
34194e76:	bf00      	nop
34194e78:	0303041c 	.word	0x0303041c
34194e7c:	0303001c 	.word	0x0303001c
34194e80:	0302041c 	.word	0x0302041c
34194e84:	0302001c 	.word	0x0302001c
34194e88:	0301041c 	.word	0x0301041c
34194e8c:	0301001c 	.word	0x0301001c
34194e90:	0300001c 	.word	0x0300001c
34194e94:	0300041c 	.word	0x0300041c

34194e98 <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
34194e98:	b580      	push	{r7, lr}
34194e9a:	b084      	sub	sp, #16
34194e9c:	af00      	add	r7, sp, #0
34194e9e:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
34194ea0:	2300      	movs	r3, #0
34194ea2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34194ea4:	6878      	ldr	r0, [r7, #4]
34194ea6:	f7f9 fe3d 	bl	3418eb24 <LL_RCC_GetSPDIFRXClockSource>
34194eaa:	4603      	mov	r3, r0
34194eac:	2b06      	cmp	r3, #6
34194eae:	f200 80c2 	bhi.w	34195036 <RCCEx_GetSPDIFRXCLKFreq+0x19e>
34194eb2:	a201      	add	r2, pc, #4	@ (adr r2, 34194eb8 <RCCEx_GetSPDIFRXCLKFreq+0x20>)
34194eb4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34194eb8:	34194ed5 	.word	0x34194ed5
34194ebc:	34194eed 	.word	0x34194eed
34194ec0:	34194ef7 	.word	0x34194ef7
34194ec4:	34194f7f 	.word	0x34194f7f
34194ec8:	34195021 	.word	0x34195021
34194ecc:	34195005 	.word	0x34195005
34194ed0:	34195031 	.word	0x34195031
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34194ed4:	f7f8 fe34 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34194ed8:	4603      	mov	r3, r0
34194eda:	4618      	mov	r0, r3
34194edc:	f7fd fde8 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34194ee0:	4603      	mov	r3, r0
34194ee2:	4618      	mov	r0, r3
34194ee4:	f7fd fdf5 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34194ee8:	60f8      	str	r0, [r7, #12]
      break;
34194eea:	e0ad      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34194eec:	2007      	movs	r0, #7
34194eee:	f7fe f8cb 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34194ef2:	60f8      	str	r0, [r7, #12]
      break;
34194ef4:	e0a8      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34194ef6:	f7fa f9ef 	bl	3418f2d8 <LL_RCC_IC7_IsEnabled>
34194efa:	4603      	mov	r3, r0
34194efc:	2b00      	cmp	r3, #0
34194efe:	f000 809c 	beq.w	3419503a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34194f02:	f7fa fa0b 	bl	3418f31c <LL_RCC_IC7_GetDivider>
34194f06:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34194f08:	f7fa f9fa 	bl	3418f300 <LL_RCC_IC7_GetSource>
34194f0c:	4603      	mov	r3, r0
34194f0e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194f12:	d029      	beq.n	34194f68 <RCCEx_GetSPDIFRXCLKFreq+0xd0>
34194f14:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194f18:	d82f      	bhi.n	34194f7a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34194f1a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194f1e:	d01a      	beq.n	34194f56 <RCCEx_GetSPDIFRXCLKFreq+0xbe>
34194f20:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194f24:	d829      	bhi.n	34194f7a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34194f26:	2b00      	cmp	r3, #0
34194f28:	d003      	beq.n	34194f32 <RCCEx_GetSPDIFRXCLKFreq+0x9a>
34194f2a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194f2e:	d009      	beq.n	34194f44 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194f30:	e023      	b.n	34194f7a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194f32:	f7fd fca5 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194f36:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194f38:	68fa      	ldr	r2, [r7, #12]
34194f3a:	68bb      	ldr	r3, [r7, #8]
34194f3c:	fbb2 f3f3 	udiv	r3, r2, r3
34194f40:	60fb      	str	r3, [r7, #12]
            break;
34194f42:	e01b      	b.n	34194f7c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194f44:	f7fd fce2 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194f48:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194f4a:	68fa      	ldr	r2, [r7, #12]
34194f4c:	68bb      	ldr	r3, [r7, #8]
34194f4e:	fbb2 f3f3 	udiv	r3, r2, r3
34194f52:	60fb      	str	r3, [r7, #12]
            break;
34194f54:	e012      	b.n	34194f7c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194f56:	f7fd fd1f 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194f5a:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194f5c:	68fa      	ldr	r2, [r7, #12]
34194f5e:	68bb      	ldr	r3, [r7, #8]
34194f60:	fbb2 f3f3 	udiv	r3, r2, r3
34194f64:	60fb      	str	r3, [r7, #12]
            break;
34194f66:	e009      	b.n	34194f7c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194f68:	f7fd fd5c 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194f6c:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194f6e:	68fa      	ldr	r2, [r7, #12]
34194f70:	68bb      	ldr	r3, [r7, #8]
34194f72:	fbb2 f3f3 	udiv	r3, r2, r3
34194f76:	60fb      	str	r3, [r7, #12]
            break;
34194f78:	e000      	b.n	34194f7c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
34194f7a:	bf00      	nop
        }
      }
      break;
34194f7c:	e05d      	b.n	3419503a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34194f7e:	f7fa f9eb 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
34194f82:	4603      	mov	r3, r0
34194f84:	2b00      	cmp	r3, #0
34194f86:	d05a      	beq.n	3419503e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34194f88:	f7fa fa08 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34194f8c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34194f8e:	f7fa f9f7 	bl	3418f380 <LL_RCC_IC8_GetSource>
34194f92:	4603      	mov	r3, r0
34194f94:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194f98:	d029      	beq.n	34194fee <RCCEx_GetSPDIFRXCLKFreq+0x156>
34194f9a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34194f9e:	d82f      	bhi.n	34195000 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34194fa0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194fa4:	d01a      	beq.n	34194fdc <RCCEx_GetSPDIFRXCLKFreq+0x144>
34194fa6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34194faa:	d829      	bhi.n	34195000 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34194fac:	2b00      	cmp	r3, #0
34194fae:	d003      	beq.n	34194fb8 <RCCEx_GetSPDIFRXCLKFreq+0x120>
34194fb0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34194fb4:	d009      	beq.n	34194fca <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34194fb6:	e023      	b.n	34195000 <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34194fb8:	f7fd fc62 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34194fbc:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194fbe:	68fa      	ldr	r2, [r7, #12]
34194fc0:	68bb      	ldr	r3, [r7, #8]
34194fc2:	fbb2 f3f3 	udiv	r3, r2, r3
34194fc6:	60fb      	str	r3, [r7, #12]
            break;
34194fc8:	e01b      	b.n	34195002 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34194fca:	f7fd fc9f 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34194fce:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194fd0:	68fa      	ldr	r2, [r7, #12]
34194fd2:	68bb      	ldr	r3, [r7, #8]
34194fd4:	fbb2 f3f3 	udiv	r3, r2, r3
34194fd8:	60fb      	str	r3, [r7, #12]
            break;
34194fda:	e012      	b.n	34195002 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34194fdc:	f7fd fcdc 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34194fe0:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194fe2:	68fa      	ldr	r2, [r7, #12]
34194fe4:	68bb      	ldr	r3, [r7, #8]
34194fe6:	fbb2 f3f3 	udiv	r3, r2, r3
34194fea:	60fb      	str	r3, [r7, #12]
            break;
34194fec:	e009      	b.n	34195002 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34194fee:	f7fd fd19 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34194ff2:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34194ff4:	68fa      	ldr	r2, [r7, #12]
34194ff6:	68bb      	ldr	r3, [r7, #8]
34194ff8:	fbb2 f3f3 	udiv	r3, r2, r3
34194ffc:	60fb      	str	r3, [r7, #12]
            break;
34194ffe:	e000      	b.n	34195002 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
34195000:	bf00      	nop
        }
      }
      break;
34195002:	e01c      	b.n	3419503e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34195004:	f7f9 f9c4 	bl	3418e390 <LL_RCC_HSI_IsReady>
34195008:	4603      	mov	r3, r0
3419500a:	2b00      	cmp	r3, #0
3419500c:	d019      	beq.n	34195042 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3419500e:	f7f9 f9d1 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34195012:	4603      	mov	r3, r0
34195014:	09db      	lsrs	r3, r3, #7
34195016:	4a0f      	ldr	r2, [pc, #60]	@ (34195054 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
34195018:	fa22 f303 	lsr.w	r3, r2, r3
3419501c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419501e:	e010      	b.n	34195042 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34195020:	f7f9 f9d6 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34195024:	4603      	mov	r3, r0
34195026:	2b00      	cmp	r3, #0
34195028:	d00d      	beq.n	34195046 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
3419502a:	4b0b      	ldr	r3, [pc, #44]	@ (34195058 <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
3419502c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419502e:	e00a      	b.n	34195046 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
34195030:	4b0a      	ldr	r3, [pc, #40]	@ (3419505c <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
34195032:	60fb      	str	r3, [r7, #12]
      break;
34195034:	e008      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
34195036:	bf00      	nop
34195038:	e006      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3419503a:	bf00      	nop
3419503c:	e004      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3419503e:	bf00      	nop
34195040:	e002      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34195042:	bf00      	nop
34195044:	e000      	b.n	34195048 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34195046:	bf00      	nop
  }

  return spdifrx_frequency;
34195048:	68fb      	ldr	r3, [r7, #12]
}
3419504a:	4618      	mov	r0, r3
3419504c:	3710      	adds	r7, #16
3419504e:	46bd      	mov	sp, r7
34195050:	bd80      	pop	{r7, pc}
34195052:	bf00      	nop
34195054:	03d09000 	.word	0x03d09000
34195058:	003d0900 	.word	0x003d0900
3419505c:	00bb8000 	.word	0x00bb8000

34195060 <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
34195060:	b580      	push	{r7, lr}
34195062:	b084      	sub	sp, #16
34195064:	af00      	add	r7, sp, #0
34195066:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
34195068:	2300      	movs	r3, #0
3419506a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3419506c:	6878      	ldr	r0, [r7, #4]
3419506e:	f7f9 fd6b 	bl	3418eb48 <LL_RCC_GetSPIClockSource>
34195072:	4603      	mov	r3, r0
34195074:	4aa7      	ldr	r2, [pc, #668]	@ (34195314 <RCCEx_GetSPICLKFreq+0x2b4>)
34195076:	4293      	cmp	r3, r2
34195078:	f000 829e 	beq.w	341955b8 <RCCEx_GetSPICLKFreq+0x558>
3419507c:	4aa5      	ldr	r2, [pc, #660]	@ (34195314 <RCCEx_GetSPICLKFreq+0x2b4>)
3419507e:	4293      	cmp	r3, r2
34195080:	f200 82a5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195084:	4aa4      	ldr	r2, [pc, #656]	@ (34195318 <RCCEx_GetSPICLKFreq+0x2b8>)
34195086:	4293      	cmp	r3, r2
34195088:	f000 8299 	beq.w	341955be <RCCEx_GetSPICLKFreq+0x55e>
3419508c:	4aa2      	ldr	r2, [pc, #648]	@ (34195318 <RCCEx_GetSPICLKFreq+0x2b8>)
3419508e:	4293      	cmp	r3, r2
34195090:	f200 829d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195094:	4aa1      	ldr	r2, [pc, #644]	@ (3419531c <RCCEx_GetSPICLKFreq+0x2bc>)
34195096:	4293      	cmp	r3, r2
34195098:	f000 8291 	beq.w	341955be <RCCEx_GetSPICLKFreq+0x55e>
3419509c:	4a9f      	ldr	r2, [pc, #636]	@ (3419531c <RCCEx_GetSPICLKFreq+0x2bc>)
3419509e:	4293      	cmp	r3, r2
341950a0:	f200 8295 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950a4:	4a9e      	ldr	r2, [pc, #632]	@ (34195320 <RCCEx_GetSPICLKFreq+0x2c0>)
341950a6:	4293      	cmp	r3, r2
341950a8:	f000 8286 	beq.w	341955b8 <RCCEx_GetSPICLKFreq+0x558>
341950ac:	4a9c      	ldr	r2, [pc, #624]	@ (34195320 <RCCEx_GetSPICLKFreq+0x2c0>)
341950ae:	4293      	cmp	r3, r2
341950b0:	f200 828d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950b4:	4a9b      	ldr	r2, [pc, #620]	@ (34195324 <RCCEx_GetSPICLKFreq+0x2c4>)
341950b6:	4293      	cmp	r3, r2
341950b8:	f000 827e 	beq.w	341955b8 <RCCEx_GetSPICLKFreq+0x558>
341950bc:	4a99      	ldr	r2, [pc, #612]	@ (34195324 <RCCEx_GetSPICLKFreq+0x2c4>)
341950be:	4293      	cmp	r3, r2
341950c0:	f200 8285 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950c4:	4a98      	ldr	r2, [pc, #608]	@ (34195328 <RCCEx_GetSPICLKFreq+0x2c8>)
341950c6:	4293      	cmp	r3, r2
341950c8:	f000 8276 	beq.w	341955b8 <RCCEx_GetSPICLKFreq+0x558>
341950cc:	4a96      	ldr	r2, [pc, #600]	@ (34195328 <RCCEx_GetSPICLKFreq+0x2c8>)
341950ce:	4293      	cmp	r3, r2
341950d0:	f200 827d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950d4:	4a95      	ldr	r2, [pc, #596]	@ (3419532c <RCCEx_GetSPICLKFreq+0x2cc>)
341950d6:	4293      	cmp	r3, r2
341950d8:	f000 8258 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
341950dc:	4a93      	ldr	r2, [pc, #588]	@ (3419532c <RCCEx_GetSPICLKFreq+0x2cc>)
341950de:	4293      	cmp	r3, r2
341950e0:	f200 8275 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950e4:	4a92      	ldr	r2, [pc, #584]	@ (34195330 <RCCEx_GetSPICLKFreq+0x2d0>)
341950e6:	4293      	cmp	r3, r2
341950e8:	f000 8250 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
341950ec:	4a90      	ldr	r2, [pc, #576]	@ (34195330 <RCCEx_GetSPICLKFreq+0x2d0>)
341950ee:	4293      	cmp	r3, r2
341950f0:	f200 826d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341950f4:	4a8f      	ldr	r2, [pc, #572]	@ (34195334 <RCCEx_GetSPICLKFreq+0x2d4>)
341950f6:	4293      	cmp	r3, r2
341950f8:	f000 8248 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
341950fc:	4a8d      	ldr	r2, [pc, #564]	@ (34195334 <RCCEx_GetSPICLKFreq+0x2d4>)
341950fe:	4293      	cmp	r3, r2
34195100:	f200 8265 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195104:	4a8c      	ldr	r2, [pc, #560]	@ (34195338 <RCCEx_GetSPICLKFreq+0x2d8>)
34195106:	4293      	cmp	r3, r2
34195108:	f000 8240 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
3419510c:	4a8a      	ldr	r2, [pc, #552]	@ (34195338 <RCCEx_GetSPICLKFreq+0x2d8>)
3419510e:	4293      	cmp	r3, r2
34195110:	f200 825d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195114:	4a89      	ldr	r2, [pc, #548]	@ (3419533c <RCCEx_GetSPICLKFreq+0x2dc>)
34195116:	4293      	cmp	r3, r2
34195118:	f000 8238 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
3419511c:	4a87      	ldr	r2, [pc, #540]	@ (3419533c <RCCEx_GetSPICLKFreq+0x2dc>)
3419511e:	4293      	cmp	r3, r2
34195120:	f200 8255 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195124:	4a86      	ldr	r2, [pc, #536]	@ (34195340 <RCCEx_GetSPICLKFreq+0x2e0>)
34195126:	4293      	cmp	r3, r2
34195128:	f000 8230 	beq.w	3419558c <RCCEx_GetSPICLKFreq+0x52c>
3419512c:	4a84      	ldr	r2, [pc, #528]	@ (34195340 <RCCEx_GetSPICLKFreq+0x2e0>)
3419512e:	4293      	cmp	r3, r2
34195130:	f200 824d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195134:	4a83      	ldr	r2, [pc, #524]	@ (34195344 <RCCEx_GetSPICLKFreq+0x2e4>)
34195136:	4293      	cmp	r3, r2
34195138:	f000 8236 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419513c:	4a81      	ldr	r2, [pc, #516]	@ (34195344 <RCCEx_GetSPICLKFreq+0x2e4>)
3419513e:	4293      	cmp	r3, r2
34195140:	f200 8245 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195144:	4a80      	ldr	r2, [pc, #512]	@ (34195348 <RCCEx_GetSPICLKFreq+0x2e8>)
34195146:	4293      	cmp	r3, r2
34195148:	f000 822e 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419514c:	4a7e      	ldr	r2, [pc, #504]	@ (34195348 <RCCEx_GetSPICLKFreq+0x2e8>)
3419514e:	4293      	cmp	r3, r2
34195150:	f200 823d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195154:	4a7d      	ldr	r2, [pc, #500]	@ (3419534c <RCCEx_GetSPICLKFreq+0x2ec>)
34195156:	4293      	cmp	r3, r2
34195158:	f000 8226 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419515c:	4a7b      	ldr	r2, [pc, #492]	@ (3419534c <RCCEx_GetSPICLKFreq+0x2ec>)
3419515e:	4293      	cmp	r3, r2
34195160:	f200 8235 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195164:	4a7a      	ldr	r2, [pc, #488]	@ (34195350 <RCCEx_GetSPICLKFreq+0x2f0>)
34195166:	4293      	cmp	r3, r2
34195168:	f000 821e 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419516c:	4a78      	ldr	r2, [pc, #480]	@ (34195350 <RCCEx_GetSPICLKFreq+0x2f0>)
3419516e:	4293      	cmp	r3, r2
34195170:	f200 822d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195174:	4a77      	ldr	r2, [pc, #476]	@ (34195354 <RCCEx_GetSPICLKFreq+0x2f4>)
34195176:	4293      	cmp	r3, r2
34195178:	f000 8216 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419517c:	4a75      	ldr	r2, [pc, #468]	@ (34195354 <RCCEx_GetSPICLKFreq+0x2f4>)
3419517e:	4293      	cmp	r3, r2
34195180:	f200 8225 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195184:	4a74      	ldr	r2, [pc, #464]	@ (34195358 <RCCEx_GetSPICLKFreq+0x2f8>)
34195186:	4293      	cmp	r3, r2
34195188:	f000 820e 	beq.w	341955a8 <RCCEx_GetSPICLKFreq+0x548>
3419518c:	4a72      	ldr	r2, [pc, #456]	@ (34195358 <RCCEx_GetSPICLKFreq+0x2f8>)
3419518e:	4293      	cmp	r3, r2
34195190:	f200 821d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195194:	4a71      	ldr	r2, [pc, #452]	@ (3419535c <RCCEx_GetSPICLKFreq+0x2fc>)
34195196:	4293      	cmp	r3, r2
34195198:	f000 8171 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
3419519c:	4a6f      	ldr	r2, [pc, #444]	@ (3419535c <RCCEx_GetSPICLKFreq+0x2fc>)
3419519e:	4293      	cmp	r3, r2
341951a0:	f200 8215 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951a4:	4a6e      	ldr	r2, [pc, #440]	@ (34195360 <RCCEx_GetSPICLKFreq+0x300>)
341951a6:	4293      	cmp	r3, r2
341951a8:	f000 81ad 	beq.w	34195506 <RCCEx_GetSPICLKFreq+0x4a6>
341951ac:	4a6c      	ldr	r2, [pc, #432]	@ (34195360 <RCCEx_GetSPICLKFreq+0x300>)
341951ae:	4293      	cmp	r3, r2
341951b0:	f200 820d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951b4:	4a6b      	ldr	r2, [pc, #428]	@ (34195364 <RCCEx_GetSPICLKFreq+0x304>)
341951b6:	4293      	cmp	r3, r2
341951b8:	f000 81a5 	beq.w	34195506 <RCCEx_GetSPICLKFreq+0x4a6>
341951bc:	4a69      	ldr	r2, [pc, #420]	@ (34195364 <RCCEx_GetSPICLKFreq+0x304>)
341951be:	4293      	cmp	r3, r2
341951c0:	f200 8205 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951c4:	4a68      	ldr	r2, [pc, #416]	@ (34195368 <RCCEx_GetSPICLKFreq+0x308>)
341951c6:	4293      	cmp	r3, r2
341951c8:	f000 8159 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
341951cc:	4a66      	ldr	r2, [pc, #408]	@ (34195368 <RCCEx_GetSPICLKFreq+0x308>)
341951ce:	4293      	cmp	r3, r2
341951d0:	f200 81fd 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951d4:	4a65      	ldr	r2, [pc, #404]	@ (3419536c <RCCEx_GetSPICLKFreq+0x30c>)
341951d6:	4293      	cmp	r3, r2
341951d8:	f000 8151 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
341951dc:	4a63      	ldr	r2, [pc, #396]	@ (3419536c <RCCEx_GetSPICLKFreq+0x30c>)
341951de:	4293      	cmp	r3, r2
341951e0:	f200 81f5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951e4:	4a62      	ldr	r2, [pc, #392]	@ (34195370 <RCCEx_GetSPICLKFreq+0x310>)
341951e6:	4293      	cmp	r3, r2
341951e8:	f000 8149 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
341951ec:	4a60      	ldr	r2, [pc, #384]	@ (34195370 <RCCEx_GetSPICLKFreq+0x310>)
341951ee:	4293      	cmp	r3, r2
341951f0:	f200 81ed 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341951f4:	4a5f      	ldr	r2, [pc, #380]	@ (34195374 <RCCEx_GetSPICLKFreq+0x314>)
341951f6:	4293      	cmp	r3, r2
341951f8:	f000 80fd 	beq.w	341953f6 <RCCEx_GetSPICLKFreq+0x396>
341951fc:	4a5d      	ldr	r2, [pc, #372]	@ (34195374 <RCCEx_GetSPICLKFreq+0x314>)
341951fe:	4293      	cmp	r3, r2
34195200:	f200 81e5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195204:	4a5c      	ldr	r2, [pc, #368]	@ (34195378 <RCCEx_GetSPICLKFreq+0x318>)
34195206:	4293      	cmp	r3, r2
34195208:	f000 8139 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
3419520c:	4a5a      	ldr	r2, [pc, #360]	@ (34195378 <RCCEx_GetSPICLKFreq+0x318>)
3419520e:	4293      	cmp	r3, r2
34195210:	f200 81dd 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195214:	4a59      	ldr	r2, [pc, #356]	@ (3419537c <RCCEx_GetSPICLKFreq+0x31c>)
34195216:	4293      	cmp	r3, r2
34195218:	f000 8131 	beq.w	3419547e <RCCEx_GetSPICLKFreq+0x41e>
3419521c:	4a57      	ldr	r2, [pc, #348]	@ (3419537c <RCCEx_GetSPICLKFreq+0x31c>)
3419521e:	4293      	cmp	r3, r2
34195220:	f200 81d5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195224:	4a56      	ldr	r2, [pc, #344]	@ (34195380 <RCCEx_GetSPICLKFreq+0x320>)
34195226:	4293      	cmp	r3, r2
34195228:	f000 80e5 	beq.w	341953f6 <RCCEx_GetSPICLKFreq+0x396>
3419522c:	4a54      	ldr	r2, [pc, #336]	@ (34195380 <RCCEx_GetSPICLKFreq+0x320>)
3419522e:	4293      	cmp	r3, r2
34195230:	f200 81cd 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195234:	4a53      	ldr	r2, [pc, #332]	@ (34195384 <RCCEx_GetSPICLKFreq+0x324>)
34195236:	4293      	cmp	r3, r2
34195238:	f000 80dd 	beq.w	341953f6 <RCCEx_GetSPICLKFreq+0x396>
3419523c:	4a51      	ldr	r2, [pc, #324]	@ (34195384 <RCCEx_GetSPICLKFreq+0x324>)
3419523e:	4293      	cmp	r3, r2
34195240:	f200 81c5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195244:	4a50      	ldr	r2, [pc, #320]	@ (34195388 <RCCEx_GetSPICLKFreq+0x328>)
34195246:	4293      	cmp	r3, r2
34195248:	f000 80d5 	beq.w	341953f6 <RCCEx_GetSPICLKFreq+0x396>
3419524c:	4a4e      	ldr	r2, [pc, #312]	@ (34195388 <RCCEx_GetSPICLKFreq+0x328>)
3419524e:	4293      	cmp	r3, r2
34195250:	f200 81bd 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195254:	4a4d      	ldr	r2, [pc, #308]	@ (3419538c <RCCEx_GetSPICLKFreq+0x32c>)
34195256:	4293      	cmp	r3, r2
34195258:	f000 80c8 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
3419525c:	4a4b      	ldr	r2, [pc, #300]	@ (3419538c <RCCEx_GetSPICLKFreq+0x32c>)
3419525e:	4293      	cmp	r3, r2
34195260:	f200 81b5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195264:	4a4a      	ldr	r2, [pc, #296]	@ (34195390 <RCCEx_GetSPICLKFreq+0x330>)
34195266:	4293      	cmp	r3, r2
34195268:	f000 80c0 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
3419526c:	4a48      	ldr	r2, [pc, #288]	@ (34195390 <RCCEx_GetSPICLKFreq+0x330>)
3419526e:	4293      	cmp	r3, r2
34195270:	f200 81ad 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195274:	4a47      	ldr	r2, [pc, #284]	@ (34195394 <RCCEx_GetSPICLKFreq+0x334>)
34195276:	4293      	cmp	r3, r2
34195278:	f000 80b8 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
3419527c:	4a45      	ldr	r2, [pc, #276]	@ (34195394 <RCCEx_GetSPICLKFreq+0x334>)
3419527e:	4293      	cmp	r3, r2
34195280:	f200 81a5 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195284:	4a44      	ldr	r2, [pc, #272]	@ (34195398 <RCCEx_GetSPICLKFreq+0x338>)
34195286:	4293      	cmp	r3, r2
34195288:	f000 80b0 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
3419528c:	4a42      	ldr	r2, [pc, #264]	@ (34195398 <RCCEx_GetSPICLKFreq+0x338>)
3419528e:	4293      	cmp	r3, r2
34195290:	f200 819d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
34195294:	4a41      	ldr	r2, [pc, #260]	@ (3419539c <RCCEx_GetSPICLKFreq+0x33c>)
34195296:	4293      	cmp	r3, r2
34195298:	f000 80a8 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
3419529c:	4a3f      	ldr	r2, [pc, #252]	@ (3419539c <RCCEx_GetSPICLKFreq+0x33c>)
3419529e:	4293      	cmp	r3, r2
341952a0:	f200 8195 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952a4:	4a3e      	ldr	r2, [pc, #248]	@ (341953a0 <RCCEx_GetSPICLKFreq+0x340>)
341952a6:	4293      	cmp	r3, r2
341952a8:	f000 80a0 	beq.w	341953ec <RCCEx_GetSPICLKFreq+0x38c>
341952ac:	4a3c      	ldr	r2, [pc, #240]	@ (341953a0 <RCCEx_GetSPICLKFreq+0x340>)
341952ae:	4293      	cmp	r3, r2
341952b0:	f200 818d 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952b4:	4a3b      	ldr	r2, [pc, #236]	@ (341953a4 <RCCEx_GetSPICLKFreq+0x344>)
341952b6:	4293      	cmp	r3, r2
341952b8:	f000 808c 	beq.w	341953d4 <RCCEx_GetSPICLKFreq+0x374>
341952bc:	4a39      	ldr	r2, [pc, #228]	@ (341953a4 <RCCEx_GetSPICLKFreq+0x344>)
341952be:	4293      	cmp	r3, r2
341952c0:	f200 8185 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952c4:	4a38      	ldr	r2, [pc, #224]	@ (341953a8 <RCCEx_GetSPICLKFreq+0x348>)
341952c6:	4293      	cmp	r3, r2
341952c8:	d078      	beq.n	341953bc <RCCEx_GetSPICLKFreq+0x35c>
341952ca:	4a37      	ldr	r2, [pc, #220]	@ (341953a8 <RCCEx_GetSPICLKFreq+0x348>)
341952cc:	4293      	cmp	r3, r2
341952ce:	f200 817e 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952d2:	4a36      	ldr	r2, [pc, #216]	@ (341953ac <RCCEx_GetSPICLKFreq+0x34c>)
341952d4:	4293      	cmp	r3, r2
341952d6:	d071      	beq.n	341953bc <RCCEx_GetSPICLKFreq+0x35c>
341952d8:	4a34      	ldr	r2, [pc, #208]	@ (341953ac <RCCEx_GetSPICLKFreq+0x34c>)
341952da:	4293      	cmp	r3, r2
341952dc:	f200 8177 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952e0:	4a33      	ldr	r2, [pc, #204]	@ (341953b0 <RCCEx_GetSPICLKFreq+0x350>)
341952e2:	4293      	cmp	r3, r2
341952e4:	d00a      	beq.n	341952fc <RCCEx_GetSPICLKFreq+0x29c>
341952e6:	4a32      	ldr	r2, [pc, #200]	@ (341953b0 <RCCEx_GetSPICLKFreq+0x350>)
341952e8:	4293      	cmp	r3, r2
341952ea:	f200 8170 	bhi.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
341952ee:	4a31      	ldr	r2, [pc, #196]	@ (341953b4 <RCCEx_GetSPICLKFreq+0x354>)
341952f0:	4293      	cmp	r3, r2
341952f2:	d063      	beq.n	341953bc <RCCEx_GetSPICLKFreq+0x35c>
341952f4:	4a30      	ldr	r2, [pc, #192]	@ (341953b8 <RCCEx_GetSPICLKFreq+0x358>)
341952f6:	4293      	cmp	r3, r2
341952f8:	f040 8169 	bne.w	341955ce <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341952fc:	f7f8 fc20 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34195300:	4603      	mov	r3, r0
34195302:	4618      	mov	r0, r3
34195304:	f7fd fbd4 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34195308:	4603      	mov	r3, r0
3419530a:	4618      	mov	r0, r3
3419530c:	f7fd fbe1 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34195310:	60f8      	str	r0, [r7, #12]
      break;
34195312:	e169      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
34195314:	07061820 	.word	0x07061820
34195318:	07061420 	.word	0x07061420
3419531c:	07061020 	.word	0x07061020
34195320:	07060c20 	.word	0x07060c20
34195324:	07060820 	.word	0x07060820
34195328:	07060420 	.word	0x07060420
3419532c:	07051820 	.word	0x07051820
34195330:	07051420 	.word	0x07051420
34195334:	07051020 	.word	0x07051020
34195338:	07050c20 	.word	0x07050c20
3419533c:	07050820 	.word	0x07050820
34195340:	07050420 	.word	0x07050420
34195344:	07041820 	.word	0x07041820
34195348:	07041420 	.word	0x07041420
3419534c:	07041020 	.word	0x07041020
34195350:	07040c20 	.word	0x07040c20
34195354:	07040820 	.word	0x07040820
34195358:	07040420 	.word	0x07040420
3419535c:	07031820 	.word	0x07031820
34195360:	07031420 	.word	0x07031420
34195364:	07031020 	.word	0x07031020
34195368:	07030c20 	.word	0x07030c20
3419536c:	07030820 	.word	0x07030820
34195370:	07030420 	.word	0x07030420
34195374:	07021820 	.word	0x07021820
34195378:	07021420 	.word	0x07021420
3419537c:	07021020 	.word	0x07021020
34195380:	07020c20 	.word	0x07020c20
34195384:	07020820 	.word	0x07020820
34195388:	07020420 	.word	0x07020420
3419538c:	07011820 	.word	0x07011820
34195390:	07011420 	.word	0x07011420
34195394:	07011020 	.word	0x07011020
34195398:	07010c20 	.word	0x07010c20
3419539c:	07010820 	.word	0x07010820
341953a0:	07010420 	.word	0x07010420
341953a4:	07001820 	.word	0x07001820
341953a8:	07001420 	.word	0x07001420
341953ac:	07001020 	.word	0x07001020
341953b0:	07000c20 	.word	0x07000c20
341953b4:	07000420 	.word	0x07000420
341953b8:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341953bc:	f7f8 fbc0 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341953c0:	4603      	mov	r3, r0
341953c2:	4618      	mov	r0, r3
341953c4:	f7fd fb74 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341953c8:	4603      	mov	r3, r0
341953ca:	4618      	mov	r0, r3
341953cc:	f7fd fb91 	bl	34192af2 <RCCEx_GetPCLK2Freq>
341953d0:	60f8      	str	r0, [r7, #12]
      break;
341953d2:	e109      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
341953d4:	f7f8 fbb4 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
341953d8:	4603      	mov	r3, r0
341953da:	4618      	mov	r0, r3
341953dc:	f7fd fb68 	bl	34192ab0 <RCCEx_GetHCLKFreq>
341953e0:	4603      	mov	r3, r0
341953e2:	4618      	mov	r0, r3
341953e4:	f7fd fb96 	bl	34192b14 <RCCEx_GetPCLK4Freq>
341953e8:	60f8      	str	r0, [r7, #12]
      break;
341953ea:	e0fd      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
341953ec:	2007      	movs	r0, #7
341953ee:	f7fd fe4b 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
341953f2:	60f8      	str	r0, [r7, #12]
      break;
341953f4:	e0f8      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
341953f6:	f7f9 ffaf 	bl	3418f358 <LL_RCC_IC8_IsEnabled>
341953fa:	4603      	mov	r3, r0
341953fc:	2b00      	cmp	r3, #0
341953fe:	f000 80e8 	beq.w	341955d2 <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34195402:	f7f9 ffcb 	bl	3418f39c <LL_RCC_IC8_GetDivider>
34195406:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34195408:	f7f9 ffba 	bl	3418f380 <LL_RCC_IC8_GetSource>
3419540c:	4603      	mov	r3, r0
3419540e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195412:	d029      	beq.n	34195468 <RCCEx_GetSPICLKFreq+0x408>
34195414:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195418:	d82f      	bhi.n	3419547a <RCCEx_GetSPICLKFreq+0x41a>
3419541a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419541e:	d01a      	beq.n	34195456 <RCCEx_GetSPICLKFreq+0x3f6>
34195420:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195424:	d829      	bhi.n	3419547a <RCCEx_GetSPICLKFreq+0x41a>
34195426:	2b00      	cmp	r3, #0
34195428:	d003      	beq.n	34195432 <RCCEx_GetSPICLKFreq+0x3d2>
3419542a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419542e:	d009      	beq.n	34195444 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34195430:	e023      	b.n	3419547a <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195432:	f7fd fa25 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195436:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34195438:	68fa      	ldr	r2, [r7, #12]
3419543a:	68bb      	ldr	r3, [r7, #8]
3419543c:	fbb2 f3f3 	udiv	r3, r2, r3
34195440:	60fb      	str	r3, [r7, #12]
            break;
34195442:	e01b      	b.n	3419547c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195444:	f7fd fa62 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195448:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3419544a:	68fa      	ldr	r2, [r7, #12]
3419544c:	68bb      	ldr	r3, [r7, #8]
3419544e:	fbb2 f3f3 	udiv	r3, r2, r3
34195452:	60fb      	str	r3, [r7, #12]
            break;
34195454:	e012      	b.n	3419547c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195456:	f7fd fa9f 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
3419545a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3419545c:	68fa      	ldr	r2, [r7, #12]
3419545e:	68bb      	ldr	r3, [r7, #8]
34195460:	fbb2 f3f3 	udiv	r3, r2, r3
34195464:	60fb      	str	r3, [r7, #12]
            break;
34195466:	e009      	b.n	3419547c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195468:	f7fd fadc 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419546c:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3419546e:	68fa      	ldr	r2, [r7, #12]
34195470:	68bb      	ldr	r3, [r7, #8]
34195472:	fbb2 f3f3 	udiv	r3, r2, r3
34195476:	60fb      	str	r3, [r7, #12]
            break;
34195478:	e000      	b.n	3419547c <RCCEx_GetSPICLKFreq+0x41c>
            break;
3419547a:	bf00      	nop
        }
      }
      break;
3419547c:	e0a9      	b.n	341955d2 <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
3419547e:	f7f9 ffab 	bl	3418f3d8 <LL_RCC_IC9_IsEnabled>
34195482:	4603      	mov	r3, r0
34195484:	2b00      	cmp	r3, #0
34195486:	f000 80a6 	beq.w	341955d6 <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
3419548a:	f7f9 ffc7 	bl	3418f41c <LL_RCC_IC9_GetDivider>
3419548e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34195490:	f7f9 ffb6 	bl	3418f400 <LL_RCC_IC9_GetSource>
34195494:	4603      	mov	r3, r0
34195496:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419549a:	d029      	beq.n	341954f0 <RCCEx_GetSPICLKFreq+0x490>
3419549c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341954a0:	d82f      	bhi.n	34195502 <RCCEx_GetSPICLKFreq+0x4a2>
341954a2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341954a6:	d01a      	beq.n	341954de <RCCEx_GetSPICLKFreq+0x47e>
341954a8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341954ac:	d829      	bhi.n	34195502 <RCCEx_GetSPICLKFreq+0x4a2>
341954ae:	2b00      	cmp	r3, #0
341954b0:	d003      	beq.n	341954ba <RCCEx_GetSPICLKFreq+0x45a>
341954b2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341954b6:	d009      	beq.n	341954cc <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341954b8:	e023      	b.n	34195502 <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341954ba:	f7fd f9e1 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341954be:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341954c0:	68fa      	ldr	r2, [r7, #12]
341954c2:	68bb      	ldr	r3, [r7, #8]
341954c4:	fbb2 f3f3 	udiv	r3, r2, r3
341954c8:	60fb      	str	r3, [r7, #12]
            break;
341954ca:	e01b      	b.n	34195504 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341954cc:	f7fd fa1e 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341954d0:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341954d2:	68fa      	ldr	r2, [r7, #12]
341954d4:	68bb      	ldr	r3, [r7, #8]
341954d6:	fbb2 f3f3 	udiv	r3, r2, r3
341954da:	60fb      	str	r3, [r7, #12]
            break;
341954dc:	e012      	b.n	34195504 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341954de:	f7fd fa5b 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341954e2:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341954e4:	68fa      	ldr	r2, [r7, #12]
341954e6:	68bb      	ldr	r3, [r7, #8]
341954e8:	fbb2 f3f3 	udiv	r3, r2, r3
341954ec:	60fb      	str	r3, [r7, #12]
            break;
341954ee:	e009      	b.n	34195504 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341954f0:	f7fd fa98 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341954f4:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
341954f6:	68fa      	ldr	r2, [r7, #12]
341954f8:	68bb      	ldr	r3, [r7, #8]
341954fa:	fbb2 f3f3 	udiv	r3, r2, r3
341954fe:	60fb      	str	r3, [r7, #12]
            break;
34195500:	e000      	b.n	34195504 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
34195502:	bf00      	nop
        }
      }
      break;
34195504:	e067      	b.n	341955d6 <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
34195506:	f7fa f867 	bl	3418f5d8 <LL_RCC_IC14_IsEnabled>
3419550a:	4603      	mov	r3, r0
3419550c:	2b00      	cmp	r3, #0
3419550e:	d064      	beq.n	341955da <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34195510:	f7fa f884 	bl	3418f61c <LL_RCC_IC14_GetDivider>
34195514:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34195516:	f7fa f873 	bl	3418f600 <LL_RCC_IC14_GetSource>
3419551a:	4603      	mov	r3, r0
3419551c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195520:	d029      	beq.n	34195576 <RCCEx_GetSPICLKFreq+0x516>
34195522:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195526:	d82f      	bhi.n	34195588 <RCCEx_GetSPICLKFreq+0x528>
34195528:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419552c:	d01a      	beq.n	34195564 <RCCEx_GetSPICLKFreq+0x504>
3419552e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195532:	d829      	bhi.n	34195588 <RCCEx_GetSPICLKFreq+0x528>
34195534:	2b00      	cmp	r3, #0
34195536:	d003      	beq.n	34195540 <RCCEx_GetSPICLKFreq+0x4e0>
34195538:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419553c:	d009      	beq.n	34195552 <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3419553e:	e023      	b.n	34195588 <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195540:	f7fd f99e 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195544:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34195546:	68fa      	ldr	r2, [r7, #12]
34195548:	68bb      	ldr	r3, [r7, #8]
3419554a:	fbb2 f3f3 	udiv	r3, r2, r3
3419554e:	60fb      	str	r3, [r7, #12]
            break;
34195550:	e01b      	b.n	3419558a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195552:	f7fd f9db 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195556:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34195558:	68fa      	ldr	r2, [r7, #12]
3419555a:	68bb      	ldr	r3, [r7, #8]
3419555c:	fbb2 f3f3 	udiv	r3, r2, r3
34195560:	60fb      	str	r3, [r7, #12]
            break;
34195562:	e012      	b.n	3419558a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195564:	f7fd fa18 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34195568:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3419556a:	68fa      	ldr	r2, [r7, #12]
3419556c:	68bb      	ldr	r3, [r7, #8]
3419556e:	fbb2 f3f3 	udiv	r3, r2, r3
34195572:	60fb      	str	r3, [r7, #12]
            break;
34195574:	e009      	b.n	3419558a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195576:	f7fd fa55 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
3419557a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3419557c:	68fa      	ldr	r2, [r7, #12]
3419557e:	68bb      	ldr	r3, [r7, #8]
34195580:	fbb2 f3f3 	udiv	r3, r2, r3
34195584:	60fb      	str	r3, [r7, #12]
            break;
34195586:	e000      	b.n	3419558a <RCCEx_GetSPICLKFreq+0x52a>
            break;
34195588:	bf00      	nop
        }
      }
      break;
3419558a:	e026      	b.n	341955da <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3419558c:	f7f8 ff00 	bl	3418e390 <LL_RCC_HSI_IsReady>
34195590:	4603      	mov	r3, r0
34195592:	2b00      	cmp	r3, #0
34195594:	d023      	beq.n	341955de <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34195596:	f7f8 ff0d 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
3419559a:	4603      	mov	r3, r0
3419559c:	09db      	lsrs	r3, r3, #7
3419559e:	4a15      	ldr	r2, [pc, #84]	@ (341955f4 <RCCEx_GetSPICLKFreq+0x594>)
341955a0:	fa22 f303 	lsr.w	r3, r2, r3
341955a4:	60fb      	str	r3, [r7, #12]
      }
      break;
341955a6:	e01a      	b.n	341955de <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
341955a8:	f7f8 ff12 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
341955ac:	4603      	mov	r3, r0
341955ae:	2b00      	cmp	r3, #0
341955b0:	d017      	beq.n	341955e2 <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
341955b2:	4b11      	ldr	r3, [pc, #68]	@ (341955f8 <RCCEx_GetSPICLKFreq+0x598>)
341955b4:	60fb      	str	r3, [r7, #12]
      }
      break;
341955b6:	e014      	b.n	341955e2 <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
341955b8:	4b10      	ldr	r3, [pc, #64]	@ (341955fc <RCCEx_GetSPICLKFreq+0x59c>)
341955ba:	60fb      	str	r3, [r7, #12]
      break;
341955bc:	e014      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
341955be:	f7f8 fed5 	bl	3418e36c <LL_RCC_HSE_IsReady>
341955c2:	4603      	mov	r3, r0
341955c4:	2b00      	cmp	r3, #0
341955c6:	d00e      	beq.n	341955e6 <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
341955c8:	4b0d      	ldr	r3, [pc, #52]	@ (34195600 <RCCEx_GetSPICLKFreq+0x5a0>)
341955ca:	60fb      	str	r3, [r7, #12]
      }
      break;
341955cc:	e00b      	b.n	341955e6 <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
341955ce:	bf00      	nop
341955d0:	e00a      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955d2:	bf00      	nop
341955d4:	e008      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955d6:	bf00      	nop
341955d8:	e006      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955da:	bf00      	nop
341955dc:	e004      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955de:	bf00      	nop
341955e0:	e002      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955e2:	bf00      	nop
341955e4:	e000      	b.n	341955e8 <RCCEx_GetSPICLKFreq+0x588>
      break;
341955e6:	bf00      	nop
  }

  return spi_frequency;
341955e8:	68fb      	ldr	r3, [r7, #12]
}
341955ea:	4618      	mov	r0, r3
341955ec:	3710      	adds	r7, #16
341955ee:	46bd      	mov	sp, r7
341955f0:	bd80      	pop	{r7, pc}
341955f2:	bf00      	nop
341955f4:	03d09000 	.word	0x03d09000
341955f8:	003d0900 	.word	0x003d0900
341955fc:	00bb8000 	.word	0x00bb8000
34195600:	02dc6c00 	.word	0x02dc6c00

34195604 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
34195604:	b580      	push	{r7, lr}
34195606:	b084      	sub	sp, #16
34195608:	af00      	add	r7, sp, #0
3419560a:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3419560c:	2300      	movs	r3, #0
3419560e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
34195610:	6878      	ldr	r0, [r7, #4]
34195612:	f7f9 fab1 	bl	3418eb78 <LL_RCC_GetUARTClockSource>
34195616:	4603      	mov	r3, r0
34195618:	4aa2      	ldr	r2, [pc, #648]	@ (341958a4 <RCCEx_GetUARTCLKFreq+0x2a0>)
3419561a:	4293      	cmp	r3, r2
3419561c:	f000 81e8 	beq.w	341959f0 <RCCEx_GetUARTCLKFreq+0x3ec>
34195620:	4aa0      	ldr	r2, [pc, #640]	@ (341958a4 <RCCEx_GetUARTCLKFreq+0x2a0>)
34195622:	4293      	cmp	r3, r2
34195624:	f200 8203 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195628:	4a9f      	ldr	r2, [pc, #636]	@ (341958a8 <RCCEx_GetUARTCLKFreq+0x2a4>)
3419562a:	4293      	cmp	r3, r2
3419562c:	f000 81e0 	beq.w	341959f0 <RCCEx_GetUARTCLKFreq+0x3ec>
34195630:	4a9d      	ldr	r2, [pc, #628]	@ (341958a8 <RCCEx_GetUARTCLKFreq+0x2a4>)
34195632:	4293      	cmp	r3, r2
34195634:	f200 81fb 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195638:	4a9c      	ldr	r2, [pc, #624]	@ (341958ac <RCCEx_GetUARTCLKFreq+0x2a8>)
3419563a:	4293      	cmp	r3, r2
3419563c:	f000 81d8 	beq.w	341959f0 <RCCEx_GetUARTCLKFreq+0x3ec>
34195640:	4a9a      	ldr	r2, [pc, #616]	@ (341958ac <RCCEx_GetUARTCLKFreq+0x2a8>)
34195642:	4293      	cmp	r3, r2
34195644:	f200 81f3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195648:	4a99      	ldr	r2, [pc, #612]	@ (341958b0 <RCCEx_GetUARTCLKFreq+0x2ac>)
3419564a:	4293      	cmp	r3, r2
3419564c:	f000 81d0 	beq.w	341959f0 <RCCEx_GetUARTCLKFreq+0x3ec>
34195650:	4a97      	ldr	r2, [pc, #604]	@ (341958b0 <RCCEx_GetUARTCLKFreq+0x2ac>)
34195652:	4293      	cmp	r3, r2
34195654:	f200 81eb 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195658:	4a96      	ldr	r2, [pc, #600]	@ (341958b4 <RCCEx_GetUARTCLKFreq+0x2b0>)
3419565a:	4293      	cmp	r3, r2
3419565c:	f000 81c8 	beq.w	341959f0 <RCCEx_GetUARTCLKFreq+0x3ec>
34195660:	4a94      	ldr	r2, [pc, #592]	@ (341958b4 <RCCEx_GetUARTCLKFreq+0x2b0>)
34195662:	4293      	cmp	r3, r2
34195664:	f200 81e3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195668:	4a93      	ldr	r2, [pc, #588]	@ (341958b8 <RCCEx_GetUARTCLKFreq+0x2b4>)
3419566a:	4293      	cmp	r3, r2
3419566c:	f000 81ce 	beq.w	34195a0c <RCCEx_GetUARTCLKFreq+0x408>
34195670:	4a91      	ldr	r2, [pc, #580]	@ (341958b8 <RCCEx_GetUARTCLKFreq+0x2b4>)
34195672:	4293      	cmp	r3, r2
34195674:	f200 81db 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195678:	4a90      	ldr	r2, [pc, #576]	@ (341958bc <RCCEx_GetUARTCLKFreq+0x2b8>)
3419567a:	4293      	cmp	r3, r2
3419567c:	f000 81c6 	beq.w	34195a0c <RCCEx_GetUARTCLKFreq+0x408>
34195680:	4a8e      	ldr	r2, [pc, #568]	@ (341958bc <RCCEx_GetUARTCLKFreq+0x2b8>)
34195682:	4293      	cmp	r3, r2
34195684:	f200 81d3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195688:	4a8d      	ldr	r2, [pc, #564]	@ (341958c0 <RCCEx_GetUARTCLKFreq+0x2bc>)
3419568a:	4293      	cmp	r3, r2
3419568c:	f000 81be 	beq.w	34195a0c <RCCEx_GetUARTCLKFreq+0x408>
34195690:	4a8b      	ldr	r2, [pc, #556]	@ (341958c0 <RCCEx_GetUARTCLKFreq+0x2bc>)
34195692:	4293      	cmp	r3, r2
34195694:	f200 81cb 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195698:	4a8a      	ldr	r2, [pc, #552]	@ (341958c4 <RCCEx_GetUARTCLKFreq+0x2c0>)
3419569a:	4293      	cmp	r3, r2
3419569c:	f000 81b6 	beq.w	34195a0c <RCCEx_GetUARTCLKFreq+0x408>
341956a0:	4a88      	ldr	r2, [pc, #544]	@ (341958c4 <RCCEx_GetUARTCLKFreq+0x2c0>)
341956a2:	4293      	cmp	r3, r2
341956a4:	f200 81c3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956a8:	4a87      	ldr	r2, [pc, #540]	@ (341958c8 <RCCEx_GetUARTCLKFreq+0x2c4>)
341956aa:	4293      	cmp	r3, r2
341956ac:	f000 81ae 	beq.w	34195a0c <RCCEx_GetUARTCLKFreq+0x408>
341956b0:	4a85      	ldr	r2, [pc, #532]	@ (341958c8 <RCCEx_GetUARTCLKFreq+0x2c4>)
341956b2:	4293      	cmp	r3, r2
341956b4:	f200 81bb 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956b8:	4a84      	ldr	r2, [pc, #528]	@ (341958cc <RCCEx_GetUARTCLKFreq+0x2c8>)
341956ba:	4293      	cmp	r3, r2
341956bc:	f000 81ae 	beq.w	34195a1c <RCCEx_GetUARTCLKFreq+0x418>
341956c0:	4a82      	ldr	r2, [pc, #520]	@ (341958cc <RCCEx_GetUARTCLKFreq+0x2c8>)
341956c2:	4293      	cmp	r3, r2
341956c4:	f200 81b3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956c8:	4a81      	ldr	r2, [pc, #516]	@ (341958d0 <RCCEx_GetUARTCLKFreq+0x2cc>)
341956ca:	4293      	cmp	r3, r2
341956cc:	f000 81a6 	beq.w	34195a1c <RCCEx_GetUARTCLKFreq+0x418>
341956d0:	4a7f      	ldr	r2, [pc, #508]	@ (341958d0 <RCCEx_GetUARTCLKFreq+0x2cc>)
341956d2:	4293      	cmp	r3, r2
341956d4:	f200 81ab 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956d8:	4a7e      	ldr	r2, [pc, #504]	@ (341958d4 <RCCEx_GetUARTCLKFreq+0x2d0>)
341956da:	4293      	cmp	r3, r2
341956dc:	f000 819e 	beq.w	34195a1c <RCCEx_GetUARTCLKFreq+0x418>
341956e0:	4a7c      	ldr	r2, [pc, #496]	@ (341958d4 <RCCEx_GetUARTCLKFreq+0x2d0>)
341956e2:	4293      	cmp	r3, r2
341956e4:	f200 81a3 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956e8:	4a7b      	ldr	r2, [pc, #492]	@ (341958d8 <RCCEx_GetUARTCLKFreq+0x2d4>)
341956ea:	4293      	cmp	r3, r2
341956ec:	f000 8196 	beq.w	34195a1c <RCCEx_GetUARTCLKFreq+0x418>
341956f0:	4a79      	ldr	r2, [pc, #484]	@ (341958d8 <RCCEx_GetUARTCLKFreq+0x2d4>)
341956f2:	4293      	cmp	r3, r2
341956f4:	f200 819b 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341956f8:	4a78      	ldr	r2, [pc, #480]	@ (341958dc <RCCEx_GetUARTCLKFreq+0x2d8>)
341956fa:	4293      	cmp	r3, r2
341956fc:	f000 818e 	beq.w	34195a1c <RCCEx_GetUARTCLKFreq+0x418>
34195700:	4a76      	ldr	r2, [pc, #472]	@ (341958dc <RCCEx_GetUARTCLKFreq+0x2d8>)
34195702:	4293      	cmp	r3, r2
34195704:	f200 8193 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195708:	4a75      	ldr	r2, [pc, #468]	@ (341958e0 <RCCEx_GetUARTCLKFreq+0x2dc>)
3419570a:	4293      	cmp	r3, r2
3419570c:	f000 812d 	beq.w	3419596a <RCCEx_GetUARTCLKFreq+0x366>
34195710:	4a73      	ldr	r2, [pc, #460]	@ (341958e0 <RCCEx_GetUARTCLKFreq+0x2dc>)
34195712:	4293      	cmp	r3, r2
34195714:	f200 818b 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195718:	4a72      	ldr	r2, [pc, #456]	@ (341958e4 <RCCEx_GetUARTCLKFreq+0x2e0>)
3419571a:	4293      	cmp	r3, r2
3419571c:	f000 8125 	beq.w	3419596a <RCCEx_GetUARTCLKFreq+0x366>
34195720:	4a70      	ldr	r2, [pc, #448]	@ (341958e4 <RCCEx_GetUARTCLKFreq+0x2e0>)
34195722:	4293      	cmp	r3, r2
34195724:	f200 8183 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195728:	4a6f      	ldr	r2, [pc, #444]	@ (341958e8 <RCCEx_GetUARTCLKFreq+0x2e4>)
3419572a:	4293      	cmp	r3, r2
3419572c:	f000 811d 	beq.w	3419596a <RCCEx_GetUARTCLKFreq+0x366>
34195730:	4a6d      	ldr	r2, [pc, #436]	@ (341958e8 <RCCEx_GetUARTCLKFreq+0x2e4>)
34195732:	4293      	cmp	r3, r2
34195734:	f200 817b 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195738:	4a6c      	ldr	r2, [pc, #432]	@ (341958ec <RCCEx_GetUARTCLKFreq+0x2e8>)
3419573a:	4293      	cmp	r3, r2
3419573c:	f000 8115 	beq.w	3419596a <RCCEx_GetUARTCLKFreq+0x366>
34195740:	4a6a      	ldr	r2, [pc, #424]	@ (341958ec <RCCEx_GetUARTCLKFreq+0x2e8>)
34195742:	4293      	cmp	r3, r2
34195744:	f200 8173 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195748:	4a69      	ldr	r2, [pc, #420]	@ (341958f0 <RCCEx_GetUARTCLKFreq+0x2ec>)
3419574a:	4293      	cmp	r3, r2
3419574c:	f000 810d 	beq.w	3419596a <RCCEx_GetUARTCLKFreq+0x366>
34195750:	4a67      	ldr	r2, [pc, #412]	@ (341958f0 <RCCEx_GetUARTCLKFreq+0x2ec>)
34195752:	4293      	cmp	r3, r2
34195754:	f200 816b 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195758:	4a66      	ldr	r2, [pc, #408]	@ (341958f4 <RCCEx_GetUARTCLKFreq+0x2f0>)
3419575a:	4293      	cmp	r3, r2
3419575c:	d07b      	beq.n	34195856 <RCCEx_GetUARTCLKFreq+0x252>
3419575e:	4a65      	ldr	r2, [pc, #404]	@ (341958f4 <RCCEx_GetUARTCLKFreq+0x2f0>)
34195760:	4293      	cmp	r3, r2
34195762:	f200 8164 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195766:	4a64      	ldr	r2, [pc, #400]	@ (341958f8 <RCCEx_GetUARTCLKFreq+0x2f4>)
34195768:	4293      	cmp	r3, r2
3419576a:	d074      	beq.n	34195856 <RCCEx_GetUARTCLKFreq+0x252>
3419576c:	4a62      	ldr	r2, [pc, #392]	@ (341958f8 <RCCEx_GetUARTCLKFreq+0x2f4>)
3419576e:	4293      	cmp	r3, r2
34195770:	f200 815d 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195774:	4a61      	ldr	r2, [pc, #388]	@ (341958fc <RCCEx_GetUARTCLKFreq+0x2f8>)
34195776:	4293      	cmp	r3, r2
34195778:	d06d      	beq.n	34195856 <RCCEx_GetUARTCLKFreq+0x252>
3419577a:	4a60      	ldr	r2, [pc, #384]	@ (341958fc <RCCEx_GetUARTCLKFreq+0x2f8>)
3419577c:	4293      	cmp	r3, r2
3419577e:	f200 8156 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195782:	4a5f      	ldr	r2, [pc, #380]	@ (34195900 <RCCEx_GetUARTCLKFreq+0x2fc>)
34195784:	4293      	cmp	r3, r2
34195786:	d066      	beq.n	34195856 <RCCEx_GetUARTCLKFreq+0x252>
34195788:	4a5d      	ldr	r2, [pc, #372]	@ (34195900 <RCCEx_GetUARTCLKFreq+0x2fc>)
3419578a:	4293      	cmp	r3, r2
3419578c:	f200 814f 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195790:	4a5c      	ldr	r2, [pc, #368]	@ (34195904 <RCCEx_GetUARTCLKFreq+0x300>)
34195792:	4293      	cmp	r3, r2
34195794:	d05f      	beq.n	34195856 <RCCEx_GetUARTCLKFreq+0x252>
34195796:	4a5b      	ldr	r2, [pc, #364]	@ (34195904 <RCCEx_GetUARTCLKFreq+0x300>)
34195798:	4293      	cmp	r3, r2
3419579a:	f200 8148 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
3419579e:	4a5a      	ldr	r2, [pc, #360]	@ (34195908 <RCCEx_GetUARTCLKFreq+0x304>)
341957a0:	4293      	cmp	r3, r2
341957a2:	d053      	beq.n	3419584c <RCCEx_GetUARTCLKFreq+0x248>
341957a4:	4a58      	ldr	r2, [pc, #352]	@ (34195908 <RCCEx_GetUARTCLKFreq+0x304>)
341957a6:	4293      	cmp	r3, r2
341957a8:	f200 8141 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957ac:	4a57      	ldr	r2, [pc, #348]	@ (3419590c <RCCEx_GetUARTCLKFreq+0x308>)
341957ae:	4293      	cmp	r3, r2
341957b0:	d04c      	beq.n	3419584c <RCCEx_GetUARTCLKFreq+0x248>
341957b2:	4a56      	ldr	r2, [pc, #344]	@ (3419590c <RCCEx_GetUARTCLKFreq+0x308>)
341957b4:	4293      	cmp	r3, r2
341957b6:	f200 813a 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957ba:	4a55      	ldr	r2, [pc, #340]	@ (34195910 <RCCEx_GetUARTCLKFreq+0x30c>)
341957bc:	4293      	cmp	r3, r2
341957be:	d045      	beq.n	3419584c <RCCEx_GetUARTCLKFreq+0x248>
341957c0:	4a53      	ldr	r2, [pc, #332]	@ (34195910 <RCCEx_GetUARTCLKFreq+0x30c>)
341957c2:	4293      	cmp	r3, r2
341957c4:	f200 8133 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957c8:	4a52      	ldr	r2, [pc, #328]	@ (34195914 <RCCEx_GetUARTCLKFreq+0x310>)
341957ca:	4293      	cmp	r3, r2
341957cc:	d03e      	beq.n	3419584c <RCCEx_GetUARTCLKFreq+0x248>
341957ce:	4a51      	ldr	r2, [pc, #324]	@ (34195914 <RCCEx_GetUARTCLKFreq+0x310>)
341957d0:	4293      	cmp	r3, r2
341957d2:	f200 812c 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957d6:	4a50      	ldr	r2, [pc, #320]	@ (34195918 <RCCEx_GetUARTCLKFreq+0x314>)
341957d8:	4293      	cmp	r3, r2
341957da:	d037      	beq.n	3419584c <RCCEx_GetUARTCLKFreq+0x248>
341957dc:	4a4e      	ldr	r2, [pc, #312]	@ (34195918 <RCCEx_GetUARTCLKFreq+0x314>)
341957de:	4293      	cmp	r3, r2
341957e0:	f200 8125 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957e4:	4a4d      	ldr	r2, [pc, #308]	@ (3419591c <RCCEx_GetUARTCLKFreq+0x318>)
341957e6:	4293      	cmp	r3, r2
341957e8:	d018      	beq.n	3419581c <RCCEx_GetUARTCLKFreq+0x218>
341957ea:	4a4c      	ldr	r2, [pc, #304]	@ (3419591c <RCCEx_GetUARTCLKFreq+0x318>)
341957ec:	4293      	cmp	r3, r2
341957ee:	f200 811e 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
341957f2:	4a4b      	ldr	r2, [pc, #300]	@ (34195920 <RCCEx_GetUARTCLKFreq+0x31c>)
341957f4:	4293      	cmp	r3, r2
341957f6:	d011      	beq.n	3419581c <RCCEx_GetUARTCLKFreq+0x218>
341957f8:	4a49      	ldr	r2, [pc, #292]	@ (34195920 <RCCEx_GetUARTCLKFreq+0x31c>)
341957fa:	4293      	cmp	r3, r2
341957fc:	f200 8117 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
34195800:	4a48      	ldr	r2, [pc, #288]	@ (34195924 <RCCEx_GetUARTCLKFreq+0x320>)
34195802:	4293      	cmp	r3, r2
34195804:	d00a      	beq.n	3419581c <RCCEx_GetUARTCLKFreq+0x218>
34195806:	4a47      	ldr	r2, [pc, #284]	@ (34195924 <RCCEx_GetUARTCLKFreq+0x320>)
34195808:	4293      	cmp	r3, r2
3419580a:	f200 8110 	bhi.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
3419580e:	4a46      	ldr	r2, [pc, #280]	@ (34195928 <RCCEx_GetUARTCLKFreq+0x324>)
34195810:	4293      	cmp	r3, r2
34195812:	d00f      	beq.n	34195834 <RCCEx_GetUARTCLKFreq+0x230>
34195814:	4a45      	ldr	r2, [pc, #276]	@ (3419592c <RCCEx_GetUARTCLKFreq+0x328>)
34195816:	4293      	cmp	r3, r2
34195818:	f040 8109 	bne.w	34195a2e <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3419581c:	f7f8 f990 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34195820:	4603      	mov	r3, r0
34195822:	4618      	mov	r0, r3
34195824:	f7fd f944 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34195828:	4603      	mov	r3, r0
3419582a:	4618      	mov	r0, r3
3419582c:	f7fd f951 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34195830:	60f8      	str	r0, [r7, #12]
      break;
34195832:	e107      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34195834:	f7f8 f984 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34195838:	4603      	mov	r3, r0
3419583a:	4618      	mov	r0, r3
3419583c:	f7fd f938 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34195840:	4603      	mov	r3, r0
34195842:	4618      	mov	r0, r3
34195844:	f7fd f955 	bl	34192af2 <RCCEx_GetPCLK2Freq>
34195848:	60f8      	str	r0, [r7, #12]
      break;
3419584a:	e0fb      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419584c:	2007      	movs	r0, #7
3419584e:	f7fd fc1b 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34195852:	60f8      	str	r0, [r7, #12]
      break;
34195854:	e0f6      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
34195856:	f7f9 fdbf 	bl	3418f3d8 <LL_RCC_IC9_IsEnabled>
3419585a:	4603      	mov	r3, r0
3419585c:	2b00      	cmp	r3, #0
3419585e:	f000 80e8 	beq.w	34195a32 <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
34195862:	f7f9 fddb 	bl	3418f41c <LL_RCC_IC9_GetDivider>
34195866:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34195868:	f7f9 fdca 	bl	3418f400 <LL_RCC_IC9_GetSource>
3419586c:	4603      	mov	r3, r0
3419586e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195872:	d06f      	beq.n	34195954 <RCCEx_GetUARTCLKFreq+0x350>
34195874:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195878:	d875      	bhi.n	34195966 <RCCEx_GetUARTCLKFreq+0x362>
3419587a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419587e:	d060      	beq.n	34195942 <RCCEx_GetUARTCLKFreq+0x33e>
34195880:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195884:	d86f      	bhi.n	34195966 <RCCEx_GetUARTCLKFreq+0x362>
34195886:	2b00      	cmp	r3, #0
34195888:	d003      	beq.n	34195892 <RCCEx_GetUARTCLKFreq+0x28e>
3419588a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3419588e:	d04f      	beq.n	34195930 <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34195890:	e069      	b.n	34195966 <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195892:	f7fc fff5 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195896:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34195898:	68fa      	ldr	r2, [r7, #12]
3419589a:	68bb      	ldr	r3, [r7, #8]
3419589c:	fbb2 f3f3 	udiv	r3, r2, r3
341958a0:	60fb      	str	r3, [r7, #12]
            break;
341958a2:	e061      	b.n	34195968 <RCCEx_GetUARTCLKFreq+0x364>
341958a4:	07061c30 	.word	0x07061c30
341958a8:	07061830 	.word	0x07061830
341958ac:	07061030 	.word	0x07061030
341958b0:	07060c30 	.word	0x07060c30
341958b4:	07060034 	.word	0x07060034
341958b8:	07051c30 	.word	0x07051c30
341958bc:	07051830 	.word	0x07051830
341958c0:	07051030 	.word	0x07051030
341958c4:	07050c30 	.word	0x07050c30
341958c8:	07050034 	.word	0x07050034
341958cc:	07041c30 	.word	0x07041c30
341958d0:	07041830 	.word	0x07041830
341958d4:	07041030 	.word	0x07041030
341958d8:	07040c30 	.word	0x07040c30
341958dc:	07040034 	.word	0x07040034
341958e0:	07031c30 	.word	0x07031c30
341958e4:	07031830 	.word	0x07031830
341958e8:	07031030 	.word	0x07031030
341958ec:	07030c30 	.word	0x07030c30
341958f0:	07030034 	.word	0x07030034
341958f4:	07021c30 	.word	0x07021c30
341958f8:	07021830 	.word	0x07021830
341958fc:	07021030 	.word	0x07021030
34195900:	07020c30 	.word	0x07020c30
34195904:	07020034 	.word	0x07020034
34195908:	07011c30 	.word	0x07011c30
3419590c:	07011830 	.word	0x07011830
34195910:	07011030 	.word	0x07011030
34195914:	07010c30 	.word	0x07010c30
34195918:	07010034 	.word	0x07010034
3419591c:	07001c30 	.word	0x07001c30
34195920:	07001830 	.word	0x07001830
34195924:	07001030 	.word	0x07001030
34195928:	07000034 	.word	0x07000034
3419592c:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195930:	f7fc ffec 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195934:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34195936:	68fa      	ldr	r2, [r7, #12]
34195938:	68bb      	ldr	r3, [r7, #8]
3419593a:	fbb2 f3f3 	udiv	r3, r2, r3
3419593e:	60fb      	str	r3, [r7, #12]
            break;
34195940:	e012      	b.n	34195968 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195942:	f7fd f829 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34195946:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34195948:	68fa      	ldr	r2, [r7, #12]
3419594a:	68bb      	ldr	r3, [r7, #8]
3419594c:	fbb2 f3f3 	udiv	r3, r2, r3
34195950:	60fb      	str	r3, [r7, #12]
            break;
34195952:	e009      	b.n	34195968 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195954:	f7fd f866 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34195958:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3419595a:	68fa      	ldr	r2, [r7, #12]
3419595c:	68bb      	ldr	r3, [r7, #8]
3419595e:	fbb2 f3f3 	udiv	r3, r2, r3
34195962:	60fb      	str	r3, [r7, #12]
            break;
34195964:	e000      	b.n	34195968 <RCCEx_GetUARTCLKFreq+0x364>
            break;
34195966:	bf00      	nop
        }
      }
      break;
34195968:	e063      	b.n	34195a32 <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
3419596a:	f7f9 fe35 	bl	3418f5d8 <LL_RCC_IC14_IsEnabled>
3419596e:	4603      	mov	r3, r0
34195970:	2b00      	cmp	r3, #0
34195972:	d060      	beq.n	34195a36 <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34195974:	f7f9 fe52 	bl	3418f61c <LL_RCC_IC14_GetDivider>
34195978:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3419597a:	f7f9 fe41 	bl	3418f600 <LL_RCC_IC14_GetSource>
3419597e:	4603      	mov	r3, r0
34195980:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195984:	d029      	beq.n	341959da <RCCEx_GetUARTCLKFreq+0x3d6>
34195986:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419598a:	d82f      	bhi.n	341959ec <RCCEx_GetUARTCLKFreq+0x3e8>
3419598c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195990:	d01a      	beq.n	341959c8 <RCCEx_GetUARTCLKFreq+0x3c4>
34195992:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195996:	d829      	bhi.n	341959ec <RCCEx_GetUARTCLKFreq+0x3e8>
34195998:	2b00      	cmp	r3, #0
3419599a:	d003      	beq.n	341959a4 <RCCEx_GetUARTCLKFreq+0x3a0>
3419599c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341959a0:	d009      	beq.n	341959b6 <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341959a2:	e023      	b.n	341959ec <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341959a4:	f7fc ff6c 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341959a8:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341959aa:	68fa      	ldr	r2, [r7, #12]
341959ac:	68bb      	ldr	r3, [r7, #8]
341959ae:	fbb2 f3f3 	udiv	r3, r2, r3
341959b2:	60fb      	str	r3, [r7, #12]
            break;
341959b4:	e01b      	b.n	341959ee <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341959b6:	f7fc ffa9 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341959ba:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341959bc:	68fa      	ldr	r2, [r7, #12]
341959be:	68bb      	ldr	r3, [r7, #8]
341959c0:	fbb2 f3f3 	udiv	r3, r2, r3
341959c4:	60fb      	str	r3, [r7, #12]
            break;
341959c6:	e012      	b.n	341959ee <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341959c8:	f7fc ffe6 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341959cc:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341959ce:	68fa      	ldr	r2, [r7, #12]
341959d0:	68bb      	ldr	r3, [r7, #8]
341959d2:	fbb2 f3f3 	udiv	r3, r2, r3
341959d6:	60fb      	str	r3, [r7, #12]
            break;
341959d8:	e009      	b.n	341959ee <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341959da:	f7fd f823 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341959de:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
341959e0:	68fa      	ldr	r2, [r7, #12]
341959e2:	68bb      	ldr	r3, [r7, #8]
341959e4:	fbb2 f3f3 	udiv	r3, r2, r3
341959e8:	60fb      	str	r3, [r7, #12]
            break;
341959ea:	e000      	b.n	341959ee <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
341959ec:	bf00      	nop
        }
      }
      break;
341959ee:	e022      	b.n	34195a36 <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
341959f0:	f7f8 fcce 	bl	3418e390 <LL_RCC_HSI_IsReady>
341959f4:	4603      	mov	r3, r0
341959f6:	2b00      	cmp	r3, #0
341959f8:	d01f      	beq.n	34195a3a <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
341959fa:	f7f8 fcdb 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
341959fe:	4603      	mov	r3, r0
34195a00:	09db      	lsrs	r3, r3, #7
34195a02:	4a13      	ldr	r2, [pc, #76]	@ (34195a50 <RCCEx_GetUARTCLKFreq+0x44c>)
34195a04:	fa22 f303 	lsr.w	r3, r2, r3
34195a08:	60fb      	str	r3, [r7, #12]
      }
      break;
34195a0a:	e016      	b.n	34195a3a <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34195a0c:	f7f8 fce0 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34195a10:	4603      	mov	r3, r0
34195a12:	2b00      	cmp	r3, #0
34195a14:	d013      	beq.n	34195a3e <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
34195a16:	4b0f      	ldr	r3, [pc, #60]	@ (34195a54 <RCCEx_GetUARTCLKFreq+0x450>)
34195a18:	60fb      	str	r3, [r7, #12]
      }
      break;
34195a1a:	e010      	b.n	34195a3e <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
34195a1c:	f7f8 fcf8 	bl	3418e410 <LL_RCC_LSE_IsReady>
34195a20:	4603      	mov	r3, r0
34195a22:	2b00      	cmp	r3, #0
34195a24:	d00d      	beq.n	34195a42 <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
34195a26:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34195a2a:	60fb      	str	r3, [r7, #12]
      }
      break;
34195a2c:	e009      	b.n	34195a42 <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
34195a2e:	bf00      	nop
34195a30:	e008      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34195a32:	bf00      	nop
34195a34:	e006      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34195a36:	bf00      	nop
34195a38:	e004      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34195a3a:	bf00      	nop
34195a3c:	e002      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34195a3e:	bf00      	nop
34195a40:	e000      	b.n	34195a44 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34195a42:	bf00      	nop
  }

  return uart_frequency;
34195a44:	68fb      	ldr	r3, [r7, #12]
}
34195a46:	4618      	mov	r0, r3
34195a48:	3710      	adds	r7, #16
34195a4a:	46bd      	mov	sp, r7
34195a4c:	bd80      	pop	{r7, pc}
34195a4e:	bf00      	nop
34195a50:	03d09000 	.word	0x03d09000
34195a54:	003d0900 	.word	0x003d0900

34195a58 <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
34195a58:	b580      	push	{r7, lr}
34195a5a:	b084      	sub	sp, #16
34195a5c:	af00      	add	r7, sp, #0
34195a5e:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
34195a60:	2300      	movs	r3, #0
34195a62:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34195a64:	6878      	ldr	r0, [r7, #4]
34195a66:	f7f9 f87b 	bl	3418eb60 <LL_RCC_GetUSARTClockSource>
34195a6a:	4603      	mov	r3, r0
34195a6c:	4aa2      	ldr	r2, [pc, #648]	@ (34195cf8 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34195a6e:	4293      	cmp	r3, r2
34195a70:	f000 81e8 	beq.w	34195e44 <RCCEx_GetUSARTCLKFreq+0x3ec>
34195a74:	4aa0      	ldr	r2, [pc, #640]	@ (34195cf8 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34195a76:	4293      	cmp	r3, r2
34195a78:	f200 8203 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195a7c:	4a9f      	ldr	r2, [pc, #636]	@ (34195cfc <RCCEx_GetUSARTCLKFreq+0x2a4>)
34195a7e:	4293      	cmp	r3, r2
34195a80:	f000 81e0 	beq.w	34195e44 <RCCEx_GetUSARTCLKFreq+0x3ec>
34195a84:	4a9d      	ldr	r2, [pc, #628]	@ (34195cfc <RCCEx_GetUSARTCLKFreq+0x2a4>)
34195a86:	4293      	cmp	r3, r2
34195a88:	f200 81fb 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195a8c:	4a9c      	ldr	r2, [pc, #624]	@ (34195d00 <RCCEx_GetUSARTCLKFreq+0x2a8>)
34195a8e:	4293      	cmp	r3, r2
34195a90:	f000 81d8 	beq.w	34195e44 <RCCEx_GetUSARTCLKFreq+0x3ec>
34195a94:	4a9a      	ldr	r2, [pc, #616]	@ (34195d00 <RCCEx_GetUSARTCLKFreq+0x2a8>)
34195a96:	4293      	cmp	r3, r2
34195a98:	f200 81f3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195a9c:	4a99      	ldr	r2, [pc, #612]	@ (34195d04 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34195a9e:	4293      	cmp	r3, r2
34195aa0:	f000 81d0 	beq.w	34195e44 <RCCEx_GetUSARTCLKFreq+0x3ec>
34195aa4:	4a97      	ldr	r2, [pc, #604]	@ (34195d04 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34195aa6:	4293      	cmp	r3, r2
34195aa8:	f200 81eb 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195aac:	4a96      	ldr	r2, [pc, #600]	@ (34195d08 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34195aae:	4293      	cmp	r3, r2
34195ab0:	f000 81c8 	beq.w	34195e44 <RCCEx_GetUSARTCLKFreq+0x3ec>
34195ab4:	4a94      	ldr	r2, [pc, #592]	@ (34195d08 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34195ab6:	4293      	cmp	r3, r2
34195ab8:	f200 81e3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195abc:	4a93      	ldr	r2, [pc, #588]	@ (34195d0c <RCCEx_GetUSARTCLKFreq+0x2b4>)
34195abe:	4293      	cmp	r3, r2
34195ac0:	f000 81ce 	beq.w	34195e60 <RCCEx_GetUSARTCLKFreq+0x408>
34195ac4:	4a91      	ldr	r2, [pc, #580]	@ (34195d0c <RCCEx_GetUSARTCLKFreq+0x2b4>)
34195ac6:	4293      	cmp	r3, r2
34195ac8:	f200 81db 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195acc:	4a90      	ldr	r2, [pc, #576]	@ (34195d10 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34195ace:	4293      	cmp	r3, r2
34195ad0:	f000 81c6 	beq.w	34195e60 <RCCEx_GetUSARTCLKFreq+0x408>
34195ad4:	4a8e      	ldr	r2, [pc, #568]	@ (34195d10 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34195ad6:	4293      	cmp	r3, r2
34195ad8:	f200 81d3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195adc:	4a8d      	ldr	r2, [pc, #564]	@ (34195d14 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34195ade:	4293      	cmp	r3, r2
34195ae0:	f000 81be 	beq.w	34195e60 <RCCEx_GetUSARTCLKFreq+0x408>
34195ae4:	4a8b      	ldr	r2, [pc, #556]	@ (34195d14 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34195ae6:	4293      	cmp	r3, r2
34195ae8:	f200 81cb 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195aec:	4a8a      	ldr	r2, [pc, #552]	@ (34195d18 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34195aee:	4293      	cmp	r3, r2
34195af0:	f000 81b6 	beq.w	34195e60 <RCCEx_GetUSARTCLKFreq+0x408>
34195af4:	4a88      	ldr	r2, [pc, #544]	@ (34195d18 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34195af6:	4293      	cmp	r3, r2
34195af8:	f200 81c3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195afc:	4a87      	ldr	r2, [pc, #540]	@ (34195d1c <RCCEx_GetUSARTCLKFreq+0x2c4>)
34195afe:	4293      	cmp	r3, r2
34195b00:	f000 81ae 	beq.w	34195e60 <RCCEx_GetUSARTCLKFreq+0x408>
34195b04:	4a85      	ldr	r2, [pc, #532]	@ (34195d1c <RCCEx_GetUSARTCLKFreq+0x2c4>)
34195b06:	4293      	cmp	r3, r2
34195b08:	f200 81bb 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b0c:	4a84      	ldr	r2, [pc, #528]	@ (34195d20 <RCCEx_GetUSARTCLKFreq+0x2c8>)
34195b0e:	4293      	cmp	r3, r2
34195b10:	f000 81ae 	beq.w	34195e70 <RCCEx_GetUSARTCLKFreq+0x418>
34195b14:	4a82      	ldr	r2, [pc, #520]	@ (34195d20 <RCCEx_GetUSARTCLKFreq+0x2c8>)
34195b16:	4293      	cmp	r3, r2
34195b18:	f200 81b3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b1c:	4a81      	ldr	r2, [pc, #516]	@ (34195d24 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34195b1e:	4293      	cmp	r3, r2
34195b20:	f000 81a6 	beq.w	34195e70 <RCCEx_GetUSARTCLKFreq+0x418>
34195b24:	4a7f      	ldr	r2, [pc, #508]	@ (34195d24 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34195b26:	4293      	cmp	r3, r2
34195b28:	f200 81ab 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b2c:	4a7e      	ldr	r2, [pc, #504]	@ (34195d28 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34195b2e:	4293      	cmp	r3, r2
34195b30:	f000 819e 	beq.w	34195e70 <RCCEx_GetUSARTCLKFreq+0x418>
34195b34:	4a7c      	ldr	r2, [pc, #496]	@ (34195d28 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34195b36:	4293      	cmp	r3, r2
34195b38:	f200 81a3 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b3c:	4a7b      	ldr	r2, [pc, #492]	@ (34195d2c <RCCEx_GetUSARTCLKFreq+0x2d4>)
34195b3e:	4293      	cmp	r3, r2
34195b40:	f000 8196 	beq.w	34195e70 <RCCEx_GetUSARTCLKFreq+0x418>
34195b44:	4a79      	ldr	r2, [pc, #484]	@ (34195d2c <RCCEx_GetUSARTCLKFreq+0x2d4>)
34195b46:	4293      	cmp	r3, r2
34195b48:	f200 819b 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b4c:	4a78      	ldr	r2, [pc, #480]	@ (34195d30 <RCCEx_GetUSARTCLKFreq+0x2d8>)
34195b4e:	4293      	cmp	r3, r2
34195b50:	f000 818e 	beq.w	34195e70 <RCCEx_GetUSARTCLKFreq+0x418>
34195b54:	4a76      	ldr	r2, [pc, #472]	@ (34195d30 <RCCEx_GetUSARTCLKFreq+0x2d8>)
34195b56:	4293      	cmp	r3, r2
34195b58:	f200 8193 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b5c:	4a75      	ldr	r2, [pc, #468]	@ (34195d34 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34195b5e:	4293      	cmp	r3, r2
34195b60:	f000 812d 	beq.w	34195dbe <RCCEx_GetUSARTCLKFreq+0x366>
34195b64:	4a73      	ldr	r2, [pc, #460]	@ (34195d34 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34195b66:	4293      	cmp	r3, r2
34195b68:	f200 818b 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b6c:	4a72      	ldr	r2, [pc, #456]	@ (34195d38 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34195b6e:	4293      	cmp	r3, r2
34195b70:	f000 8125 	beq.w	34195dbe <RCCEx_GetUSARTCLKFreq+0x366>
34195b74:	4a70      	ldr	r2, [pc, #448]	@ (34195d38 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34195b76:	4293      	cmp	r3, r2
34195b78:	f200 8183 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b7c:	4a6f      	ldr	r2, [pc, #444]	@ (34195d3c <RCCEx_GetUSARTCLKFreq+0x2e4>)
34195b7e:	4293      	cmp	r3, r2
34195b80:	f000 811d 	beq.w	34195dbe <RCCEx_GetUSARTCLKFreq+0x366>
34195b84:	4a6d      	ldr	r2, [pc, #436]	@ (34195d3c <RCCEx_GetUSARTCLKFreq+0x2e4>)
34195b86:	4293      	cmp	r3, r2
34195b88:	f200 817b 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b8c:	4a6c      	ldr	r2, [pc, #432]	@ (34195d40 <RCCEx_GetUSARTCLKFreq+0x2e8>)
34195b8e:	4293      	cmp	r3, r2
34195b90:	f000 8115 	beq.w	34195dbe <RCCEx_GetUSARTCLKFreq+0x366>
34195b94:	4a6a      	ldr	r2, [pc, #424]	@ (34195d40 <RCCEx_GetUSARTCLKFreq+0x2e8>)
34195b96:	4293      	cmp	r3, r2
34195b98:	f200 8173 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195b9c:	4a69      	ldr	r2, [pc, #420]	@ (34195d44 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34195b9e:	4293      	cmp	r3, r2
34195ba0:	f000 810d 	beq.w	34195dbe <RCCEx_GetUSARTCLKFreq+0x366>
34195ba4:	4a67      	ldr	r2, [pc, #412]	@ (34195d44 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34195ba6:	4293      	cmp	r3, r2
34195ba8:	f200 816b 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195bac:	4a66      	ldr	r2, [pc, #408]	@ (34195d48 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34195bae:	4293      	cmp	r3, r2
34195bb0:	d07b      	beq.n	34195caa <RCCEx_GetUSARTCLKFreq+0x252>
34195bb2:	4a65      	ldr	r2, [pc, #404]	@ (34195d48 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34195bb4:	4293      	cmp	r3, r2
34195bb6:	f200 8164 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195bba:	4a64      	ldr	r2, [pc, #400]	@ (34195d4c <RCCEx_GetUSARTCLKFreq+0x2f4>)
34195bbc:	4293      	cmp	r3, r2
34195bbe:	d074      	beq.n	34195caa <RCCEx_GetUSARTCLKFreq+0x252>
34195bc0:	4a62      	ldr	r2, [pc, #392]	@ (34195d4c <RCCEx_GetUSARTCLKFreq+0x2f4>)
34195bc2:	4293      	cmp	r3, r2
34195bc4:	f200 815d 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195bc8:	4a61      	ldr	r2, [pc, #388]	@ (34195d50 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34195bca:	4293      	cmp	r3, r2
34195bcc:	d06d      	beq.n	34195caa <RCCEx_GetUSARTCLKFreq+0x252>
34195bce:	4a60      	ldr	r2, [pc, #384]	@ (34195d50 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34195bd0:	4293      	cmp	r3, r2
34195bd2:	f200 8156 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195bd6:	4a5f      	ldr	r2, [pc, #380]	@ (34195d54 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34195bd8:	4293      	cmp	r3, r2
34195bda:	d066      	beq.n	34195caa <RCCEx_GetUSARTCLKFreq+0x252>
34195bdc:	4a5d      	ldr	r2, [pc, #372]	@ (34195d54 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34195bde:	4293      	cmp	r3, r2
34195be0:	f200 814f 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195be4:	4a5c      	ldr	r2, [pc, #368]	@ (34195d58 <RCCEx_GetUSARTCLKFreq+0x300>)
34195be6:	4293      	cmp	r3, r2
34195be8:	d05f      	beq.n	34195caa <RCCEx_GetUSARTCLKFreq+0x252>
34195bea:	4a5b      	ldr	r2, [pc, #364]	@ (34195d58 <RCCEx_GetUSARTCLKFreq+0x300>)
34195bec:	4293      	cmp	r3, r2
34195bee:	f200 8148 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195bf2:	4a5a      	ldr	r2, [pc, #360]	@ (34195d5c <RCCEx_GetUSARTCLKFreq+0x304>)
34195bf4:	4293      	cmp	r3, r2
34195bf6:	d053      	beq.n	34195ca0 <RCCEx_GetUSARTCLKFreq+0x248>
34195bf8:	4a58      	ldr	r2, [pc, #352]	@ (34195d5c <RCCEx_GetUSARTCLKFreq+0x304>)
34195bfa:	4293      	cmp	r3, r2
34195bfc:	f200 8141 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c00:	4a57      	ldr	r2, [pc, #348]	@ (34195d60 <RCCEx_GetUSARTCLKFreq+0x308>)
34195c02:	4293      	cmp	r3, r2
34195c04:	d04c      	beq.n	34195ca0 <RCCEx_GetUSARTCLKFreq+0x248>
34195c06:	4a56      	ldr	r2, [pc, #344]	@ (34195d60 <RCCEx_GetUSARTCLKFreq+0x308>)
34195c08:	4293      	cmp	r3, r2
34195c0a:	f200 813a 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c0e:	4a55      	ldr	r2, [pc, #340]	@ (34195d64 <RCCEx_GetUSARTCLKFreq+0x30c>)
34195c10:	4293      	cmp	r3, r2
34195c12:	d045      	beq.n	34195ca0 <RCCEx_GetUSARTCLKFreq+0x248>
34195c14:	4a53      	ldr	r2, [pc, #332]	@ (34195d64 <RCCEx_GetUSARTCLKFreq+0x30c>)
34195c16:	4293      	cmp	r3, r2
34195c18:	f200 8133 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c1c:	4a52      	ldr	r2, [pc, #328]	@ (34195d68 <RCCEx_GetUSARTCLKFreq+0x310>)
34195c1e:	4293      	cmp	r3, r2
34195c20:	d03e      	beq.n	34195ca0 <RCCEx_GetUSARTCLKFreq+0x248>
34195c22:	4a51      	ldr	r2, [pc, #324]	@ (34195d68 <RCCEx_GetUSARTCLKFreq+0x310>)
34195c24:	4293      	cmp	r3, r2
34195c26:	f200 812c 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c2a:	4a50      	ldr	r2, [pc, #320]	@ (34195d6c <RCCEx_GetUSARTCLKFreq+0x314>)
34195c2c:	4293      	cmp	r3, r2
34195c2e:	d037      	beq.n	34195ca0 <RCCEx_GetUSARTCLKFreq+0x248>
34195c30:	4a4e      	ldr	r2, [pc, #312]	@ (34195d6c <RCCEx_GetUSARTCLKFreq+0x314>)
34195c32:	4293      	cmp	r3, r2
34195c34:	f200 8125 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c38:	4a4d      	ldr	r2, [pc, #308]	@ (34195d70 <RCCEx_GetUSARTCLKFreq+0x318>)
34195c3a:	4293      	cmp	r3, r2
34195c3c:	d018      	beq.n	34195c70 <RCCEx_GetUSARTCLKFreq+0x218>
34195c3e:	4a4c      	ldr	r2, [pc, #304]	@ (34195d70 <RCCEx_GetUSARTCLKFreq+0x318>)
34195c40:	4293      	cmp	r3, r2
34195c42:	f200 811e 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c46:	4a4b      	ldr	r2, [pc, #300]	@ (34195d74 <RCCEx_GetUSARTCLKFreq+0x31c>)
34195c48:	4293      	cmp	r3, r2
34195c4a:	d01d      	beq.n	34195c88 <RCCEx_GetUSARTCLKFreq+0x230>
34195c4c:	4a49      	ldr	r2, [pc, #292]	@ (34195d74 <RCCEx_GetUSARTCLKFreq+0x31c>)
34195c4e:	4293      	cmp	r3, r2
34195c50:	f200 8117 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c54:	4a48      	ldr	r2, [pc, #288]	@ (34195d78 <RCCEx_GetUSARTCLKFreq+0x320>)
34195c56:	4293      	cmp	r3, r2
34195c58:	d00a      	beq.n	34195c70 <RCCEx_GetUSARTCLKFreq+0x218>
34195c5a:	4a47      	ldr	r2, [pc, #284]	@ (34195d78 <RCCEx_GetUSARTCLKFreq+0x320>)
34195c5c:	4293      	cmp	r3, r2
34195c5e:	f200 8110 	bhi.w	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
34195c62:	4a46      	ldr	r2, [pc, #280]	@ (34195d7c <RCCEx_GetUSARTCLKFreq+0x324>)
34195c64:	4293      	cmp	r3, r2
34195c66:	d003      	beq.n	34195c70 <RCCEx_GetUSARTCLKFreq+0x218>
34195c68:	4a45      	ldr	r2, [pc, #276]	@ (34195d80 <RCCEx_GetUSARTCLKFreq+0x328>)
34195c6a:	4293      	cmp	r3, r2
34195c6c:	d00c      	beq.n	34195c88 <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
34195c6e:	e108      	b.n	34195e82 <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34195c70:	f7f7 ff66 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34195c74:	4603      	mov	r3, r0
34195c76:	4618      	mov	r0, r3
34195c78:	f7fc ff1a 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34195c7c:	4603      	mov	r3, r0
34195c7e:	4618      	mov	r0, r3
34195c80:	f7fc ff37 	bl	34192af2 <RCCEx_GetPCLK2Freq>
34195c84:	60f8      	str	r0, [r7, #12]
      break;
34195c86:	e107      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34195c88:	f7f7 ff5a 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34195c8c:	4603      	mov	r3, r0
34195c8e:	4618      	mov	r0, r3
34195c90:	f7fc ff0e 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34195c94:	4603      	mov	r3, r0
34195c96:	4618      	mov	r0, r3
34195c98:	f7fc ff1b 	bl	34192ad2 <RCCEx_GetPCLK1Freq>
34195c9c:	60f8      	str	r0, [r7, #12]
      break;
34195c9e:	e0fb      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34195ca0:	2007      	movs	r0, #7
34195ca2:	f7fd f9f1 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34195ca6:	60f8      	str	r0, [r7, #12]
      break;
34195ca8:	e0f6      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34195caa:	f7f9 fb95 	bl	3418f3d8 <LL_RCC_IC9_IsEnabled>
34195cae:	4603      	mov	r3, r0
34195cb0:	2b00      	cmp	r3, #0
34195cb2:	f000 80e8 	beq.w	34195e86 <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
34195cb6:	f7f9 fbb1 	bl	3418f41c <LL_RCC_IC9_GetDivider>
34195cba:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34195cbc:	f7f9 fba0 	bl	3418f400 <LL_RCC_IC9_GetSource>
34195cc0:	4603      	mov	r3, r0
34195cc2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195cc6:	d06f      	beq.n	34195da8 <RCCEx_GetUSARTCLKFreq+0x350>
34195cc8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195ccc:	d875      	bhi.n	34195dba <RCCEx_GetUSARTCLKFreq+0x362>
34195cce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195cd2:	d060      	beq.n	34195d96 <RCCEx_GetUSARTCLKFreq+0x33e>
34195cd4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195cd8:	d86f      	bhi.n	34195dba <RCCEx_GetUSARTCLKFreq+0x362>
34195cda:	2b00      	cmp	r3, #0
34195cdc:	d003      	beq.n	34195ce6 <RCCEx_GetUSARTCLKFreq+0x28e>
34195cde:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34195ce2:	d04f      	beq.n	34195d84 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
34195ce4:	e069      	b.n	34195dba <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195ce6:	f7fc fdcb 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195cea:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195cec:	68fa      	ldr	r2, [r7, #12]
34195cee:	68bb      	ldr	r3, [r7, #8]
34195cf0:	fbb2 f3f3 	udiv	r3, r2, r3
34195cf4:	60fb      	str	r3, [r7, #12]
            break;
34195cf6:	e061      	b.n	34195dbc <RCCEx_GetUSARTCLKFreq+0x364>
34195cf8:	07061430 	.word	0x07061430
34195cfc:	07060830 	.word	0x07060830
34195d00:	07060434 	.word	0x07060434
34195d04:	07060430 	.word	0x07060430
34195d08:	07060030 	.word	0x07060030
34195d0c:	07051430 	.word	0x07051430
34195d10:	07050830 	.word	0x07050830
34195d14:	07050434 	.word	0x07050434
34195d18:	07050430 	.word	0x07050430
34195d1c:	07050030 	.word	0x07050030
34195d20:	07041430 	.word	0x07041430
34195d24:	07040830 	.word	0x07040830
34195d28:	07040434 	.word	0x07040434
34195d2c:	07040430 	.word	0x07040430
34195d30:	07040030 	.word	0x07040030
34195d34:	07031430 	.word	0x07031430
34195d38:	07030830 	.word	0x07030830
34195d3c:	07030434 	.word	0x07030434
34195d40:	07030430 	.word	0x07030430
34195d44:	07030030 	.word	0x07030030
34195d48:	07021430 	.word	0x07021430
34195d4c:	07020830 	.word	0x07020830
34195d50:	07020434 	.word	0x07020434
34195d54:	07020430 	.word	0x07020430
34195d58:	07020030 	.word	0x07020030
34195d5c:	07011430 	.word	0x07011430
34195d60:	07010830 	.word	0x07010830
34195d64:	07010434 	.word	0x07010434
34195d68:	07010430 	.word	0x07010430
34195d6c:	07010030 	.word	0x07010030
34195d70:	07001430 	.word	0x07001430
34195d74:	07000830 	.word	0x07000830
34195d78:	07000434 	.word	0x07000434
34195d7c:	07000030 	.word	0x07000030
34195d80:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195d84:	f7fc fdc2 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195d88:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195d8a:	68fa      	ldr	r2, [r7, #12]
34195d8c:	68bb      	ldr	r3, [r7, #8]
34195d8e:	fbb2 f3f3 	udiv	r3, r2, r3
34195d92:	60fb      	str	r3, [r7, #12]
            break;
34195d94:	e012      	b.n	34195dbc <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195d96:	f7fc fdff 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34195d9a:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195d9c:	68fa      	ldr	r2, [r7, #12]
34195d9e:	68bb      	ldr	r3, [r7, #8]
34195da0:	fbb2 f3f3 	udiv	r3, r2, r3
34195da4:	60fb      	str	r3, [r7, #12]
            break;
34195da6:	e009      	b.n	34195dbc <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195da8:	f7fc fe3c 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34195dac:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195dae:	68fa      	ldr	r2, [r7, #12]
34195db0:	68bb      	ldr	r3, [r7, #8]
34195db2:	fbb2 f3f3 	udiv	r3, r2, r3
34195db6:	60fb      	str	r3, [r7, #12]
            break;
34195db8:	e000      	b.n	34195dbc <RCCEx_GetUSARTCLKFreq+0x364>
            break;
34195dba:	bf00      	nop
      break;
34195dbc:	e063      	b.n	34195e86 <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34195dbe:	f7f9 fc0b 	bl	3418f5d8 <LL_RCC_IC14_IsEnabled>
34195dc2:	4603      	mov	r3, r0
34195dc4:	2b00      	cmp	r3, #0
34195dc6:	d060      	beq.n	34195e8a <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
34195dc8:	f7f9 fc28 	bl	3418f61c <LL_RCC_IC14_GetDivider>
34195dcc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34195dce:	f7f9 fc17 	bl	3418f600 <LL_RCC_IC14_GetSource>
34195dd2:	4603      	mov	r3, r0
34195dd4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195dd8:	d029      	beq.n	34195e2e <RCCEx_GetUSARTCLKFreq+0x3d6>
34195dda:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195dde:	d82f      	bhi.n	34195e40 <RCCEx_GetUSARTCLKFreq+0x3e8>
34195de0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195de4:	d01a      	beq.n	34195e1c <RCCEx_GetUSARTCLKFreq+0x3c4>
34195de6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195dea:	d829      	bhi.n	34195e40 <RCCEx_GetUSARTCLKFreq+0x3e8>
34195dec:	2b00      	cmp	r3, #0
34195dee:	d003      	beq.n	34195df8 <RCCEx_GetUSARTCLKFreq+0x3a0>
34195df0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34195df4:	d009      	beq.n	34195e0a <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
34195df6:	e023      	b.n	34195e40 <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195df8:	f7fc fd42 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195dfc:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195dfe:	68fa      	ldr	r2, [r7, #12]
34195e00:	68bb      	ldr	r3, [r7, #8]
34195e02:	fbb2 f3f3 	udiv	r3, r2, r3
34195e06:	60fb      	str	r3, [r7, #12]
            break;
34195e08:	e01b      	b.n	34195e42 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195e0a:	f7fc fd7f 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195e0e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195e10:	68fa      	ldr	r2, [r7, #12]
34195e12:	68bb      	ldr	r3, [r7, #8]
34195e14:	fbb2 f3f3 	udiv	r3, r2, r3
34195e18:	60fb      	str	r3, [r7, #12]
            break;
34195e1a:	e012      	b.n	34195e42 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195e1c:	f7fc fdbc 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34195e20:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195e22:	68fa      	ldr	r2, [r7, #12]
34195e24:	68bb      	ldr	r3, [r7, #8]
34195e26:	fbb2 f3f3 	udiv	r3, r2, r3
34195e2a:	60fb      	str	r3, [r7, #12]
            break;
34195e2c:	e009      	b.n	34195e42 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195e2e:	f7fc fdf9 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34195e32:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34195e34:	68fa      	ldr	r2, [r7, #12]
34195e36:	68bb      	ldr	r3, [r7, #8]
34195e38:	fbb2 f3f3 	udiv	r3, r2, r3
34195e3c:	60fb      	str	r3, [r7, #12]
            break;
34195e3e:	e000      	b.n	34195e42 <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
34195e40:	bf00      	nop
      break;
34195e42:	e022      	b.n	34195e8a <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
34195e44:	f7f8 faa4 	bl	3418e390 <LL_RCC_HSI_IsReady>
34195e48:	4603      	mov	r3, r0
34195e4a:	2b00      	cmp	r3, #0
34195e4c:	d01f      	beq.n	34195e8e <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34195e4e:	f7f8 fab1 	bl	3418e3b4 <LL_RCC_HSI_GetDivider>
34195e52:	4603      	mov	r3, r0
34195e54:	09db      	lsrs	r3, r3, #7
34195e56:	4a13      	ldr	r2, [pc, #76]	@ (34195ea4 <RCCEx_GetUSARTCLKFreq+0x44c>)
34195e58:	fa22 f303 	lsr.w	r3, r2, r3
34195e5c:	60fb      	str	r3, [r7, #12]
      break;
34195e5e:	e016      	b.n	34195e8e <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
34195e60:	f7f8 fab6 	bl	3418e3d0 <LL_RCC_MSI_IsReady>
34195e64:	4603      	mov	r3, r0
34195e66:	2b00      	cmp	r3, #0
34195e68:	d013      	beq.n	34195e92 <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
34195e6a:	4b0f      	ldr	r3, [pc, #60]	@ (34195ea8 <RCCEx_GetUSARTCLKFreq+0x450>)
34195e6c:	60fb      	str	r3, [r7, #12]
      break;
34195e6e:	e010      	b.n	34195e92 <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
34195e70:	f7f8 face 	bl	3418e410 <LL_RCC_LSE_IsReady>
34195e74:	4603      	mov	r3, r0
34195e76:	2b00      	cmp	r3, #0
34195e78:	d00d      	beq.n	34195e96 <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
34195e7a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34195e7e:	60fb      	str	r3, [r7, #12]
      break;
34195e80:	e009      	b.n	34195e96 <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
34195e82:	bf00      	nop
34195e84:	e008      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34195e86:	bf00      	nop
34195e88:	e006      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34195e8a:	bf00      	nop
34195e8c:	e004      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34195e8e:	bf00      	nop
34195e90:	e002      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34195e92:	bf00      	nop
34195e94:	e000      	b.n	34195e98 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34195e96:	bf00      	nop
  }

  return usart_frequency;
34195e98:	68fb      	ldr	r3, [r7, #12]
}
34195e9a:	4618      	mov	r0, r3
34195e9c:	3710      	adds	r7, #16
34195e9e:	46bd      	mov	sp, r7
34195ea0:	bd80      	pop	{r7, pc}
34195ea2:	bf00      	nop
34195ea4:	03d09000 	.word	0x03d09000
34195ea8:	003d0900 	.word	0x003d0900

34195eac <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
34195eac:	b580      	push	{r7, lr}
34195eae:	b084      	sub	sp, #16
34195eb0:	af00      	add	r7, sp, #0
34195eb2:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34195eb4:	2300      	movs	r3, #0
34195eb6:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
34195eb8:	6878      	ldr	r0, [r7, #4]
34195eba:	f7f8 fe69 	bl	3418eb90 <LL_RCC_GetUSBClockSource>
34195ebe:	4603      	mov	r3, r0
34195ec0:	4a4b      	ldr	r2, [pc, #300]	@ (34195ff0 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34195ec2:	4293      	cmp	r3, r2
34195ec4:	d035      	beq.n	34195f32 <RCCEx_GetOTGPHYCLKFreq+0x86>
34195ec6:	4a4a      	ldr	r2, [pc, #296]	@ (34195ff0 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34195ec8:	4293      	cmp	r3, r2
34195eca:	f200 8085 	bhi.w	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195ece:	4a49      	ldr	r2, [pc, #292]	@ (34195ff4 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34195ed0:	4293      	cmp	r3, r2
34195ed2:	d02e      	beq.n	34195f32 <RCCEx_GetOTGPHYCLKFreq+0x86>
34195ed4:	4a47      	ldr	r2, [pc, #284]	@ (34195ff4 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34195ed6:	4293      	cmp	r3, r2
34195ed8:	d87e      	bhi.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195eda:	4a47      	ldr	r2, [pc, #284]	@ (34195ff8 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34195edc:	4293      	cmp	r3, r2
34195ede:	d038      	beq.n	34195f52 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34195ee0:	4a45      	ldr	r2, [pc, #276]	@ (34195ff8 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34195ee2:	4293      	cmp	r3, r2
34195ee4:	d878      	bhi.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195ee6:	4a45      	ldr	r2, [pc, #276]	@ (34195ffc <RCCEx_GetOTGPHYCLKFreq+0x150>)
34195ee8:	4293      	cmp	r3, r2
34195eea:	d032      	beq.n	34195f52 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34195eec:	4a43      	ldr	r2, [pc, #268]	@ (34195ffc <RCCEx_GetOTGPHYCLKFreq+0x150>)
34195eee:	4293      	cmp	r3, r2
34195ef0:	d872      	bhi.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195ef2:	4a43      	ldr	r2, [pc, #268]	@ (34196000 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34195ef4:	4293      	cmp	r3, r2
34195ef6:	d00f      	beq.n	34195f18 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34195ef8:	4a41      	ldr	r2, [pc, #260]	@ (34196000 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34195efa:	4293      	cmp	r3, r2
34195efc:	d86c      	bhi.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195efe:	4a41      	ldr	r2, [pc, #260]	@ (34196004 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34195f00:	4293      	cmp	r3, r2
34195f02:	d009      	beq.n	34195f18 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34195f04:	4a3f      	ldr	r2, [pc, #252]	@ (34196004 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34195f06:	4293      	cmp	r3, r2
34195f08:	d866      	bhi.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34195f0a:	4a3f      	ldr	r2, [pc, #252]	@ (34196008 <RCCEx_GetOTGPHYCLKFreq+0x15c>)
34195f0c:	4293      	cmp	r3, r2
34195f0e:	d008      	beq.n	34195f22 <RCCEx_GetOTGPHYCLKFreq+0x76>
34195f10:	4a3e      	ldr	r2, [pc, #248]	@ (3419600c <RCCEx_GetOTGPHYCLKFreq+0x160>)
34195f12:	4293      	cmp	r3, r2
34195f14:	d005      	beq.n	34195f22 <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
34195f16:	e05f      	b.n	34195fd8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34195f18:	2007      	movs	r0, #7
34195f1a:	f7fd f8b5 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34195f1e:	60f8      	str	r0, [r7, #12]
      break;
34195f20:	e061      	b.n	34195fe6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
34195f22:	f7f8 fa23 	bl	3418e36c <LL_RCC_HSE_IsReady>
34195f26:	4603      	mov	r3, r0
34195f28:	2b00      	cmp	r3, #0
34195f2a:	d057      	beq.n	34195fdc <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
34195f2c:	4b38      	ldr	r3, [pc, #224]	@ (34196010 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34195f2e:	60fb      	str	r3, [r7, #12]
      break;
34195f30:	e054      	b.n	34195fdc <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
34195f32:	f7f8 fa1b 	bl	3418e36c <LL_RCC_HSE_IsReady>
34195f36:	4603      	mov	r3, r0
34195f38:	2b00      	cmp	r3, #0
34195f3a:	d051      	beq.n	34195fe0 <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34195f3c:	f7f8 fa04 	bl	3418e348 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34195f40:	4603      	mov	r3, r0
34195f42:	2b00      	cmp	r3, #0
34195f44:	d102      	bne.n	34195f4c <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
34195f46:	4b33      	ldr	r3, [pc, #204]	@ (34196014 <RCCEx_GetOTGPHYCLKFreq+0x168>)
34195f48:	60fb      	str	r3, [r7, #12]
      break;
34195f4a:	e049      	b.n	34195fe0 <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
34195f4c:	4b30      	ldr	r3, [pc, #192]	@ (34196010 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34195f4e:	60fb      	str	r3, [r7, #12]
      break;
34195f50:	e046      	b.n	34195fe0 <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34195f52:	f7f9 fb81 	bl	3418f658 <LL_RCC_IC15_IsEnabled>
34195f56:	4603      	mov	r3, r0
34195f58:	2b00      	cmp	r3, #0
34195f5a:	d043      	beq.n	34195fe4 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
34195f5c:	f7f9 fb9e 	bl	3418f69c <LL_RCC_IC15_GetDivider>
34195f60:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34195f62:	f7f9 fb8d 	bl	3418f680 <LL_RCC_IC15_GetSource>
34195f66:	4603      	mov	r3, r0
34195f68:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195f6c:	d029      	beq.n	34195fc2 <RCCEx_GetOTGPHYCLKFreq+0x116>
34195f6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34195f72:	d82f      	bhi.n	34195fd4 <RCCEx_GetOTGPHYCLKFreq+0x128>
34195f74:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195f78:	d01a      	beq.n	34195fb0 <RCCEx_GetOTGPHYCLKFreq+0x104>
34195f7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34195f7e:	d829      	bhi.n	34195fd4 <RCCEx_GetOTGPHYCLKFreq+0x128>
34195f80:	2b00      	cmp	r3, #0
34195f82:	d003      	beq.n	34195f8c <RCCEx_GetOTGPHYCLKFreq+0xe0>
34195f84:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34195f88:	d009      	beq.n	34195f9e <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
34195f8a:	e023      	b.n	34195fd4 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34195f8c:	f7fc fc78 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
34195f90:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34195f92:	68fa      	ldr	r2, [r7, #12]
34195f94:	68bb      	ldr	r3, [r7, #8]
34195f96:	fbb2 f3f3 	udiv	r3, r2, r3
34195f9a:	60fb      	str	r3, [r7, #12]
            break;
34195f9c:	e01b      	b.n	34195fd6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34195f9e:	f7fc fcb5 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
34195fa2:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34195fa4:	68fa      	ldr	r2, [r7, #12]
34195fa6:	68bb      	ldr	r3, [r7, #8]
34195fa8:	fbb2 f3f3 	udiv	r3, r2, r3
34195fac:	60fb      	str	r3, [r7, #12]
            break;
34195fae:	e012      	b.n	34195fd6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34195fb0:	f7fc fcf2 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34195fb4:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34195fb6:	68fa      	ldr	r2, [r7, #12]
34195fb8:	68bb      	ldr	r3, [r7, #8]
34195fba:	fbb2 f3f3 	udiv	r3, r2, r3
34195fbe:	60fb      	str	r3, [r7, #12]
            break;
34195fc0:	e009      	b.n	34195fd6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34195fc2:	f7fc fd2f 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34195fc6:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34195fc8:	68fa      	ldr	r2, [r7, #12]
34195fca:	68bb      	ldr	r3, [r7, #8]
34195fcc:	fbb2 f3f3 	udiv	r3, r2, r3
34195fd0:	60fb      	str	r3, [r7, #12]
            break;
34195fd2:	e000      	b.n	34195fd6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
34195fd4:	bf00      	nop
      break;
34195fd6:	e005      	b.n	34195fe4 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
34195fd8:	bf00      	nop
34195fda:	e004      	b.n	34195fe6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34195fdc:	bf00      	nop
34195fde:	e002      	b.n	34195fe6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34195fe0:	bf00      	nop
34195fe2:	e000      	b.n	34195fe6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34195fe4:	bf00      	nop
  }

  return usb_frequency;
34195fe6:	68fb      	ldr	r3, [r7, #12]
}
34195fe8:	4618      	mov	r0, r3
34195fea:	3710      	adds	r7, #16
34195fec:	46bd      	mov	sp, r7
34195fee:	bd80      	pop	{r7, pc}
34195ff0:	03031414 	.word	0x03031414
34195ff4:	03030c14 	.word	0x03030c14
34195ff8:	03021414 	.word	0x03021414
34195ffc:	03020c14 	.word	0x03020c14
34196000:	03011414 	.word	0x03011414
34196004:	03010c14 	.word	0x03010c14
34196008:	03000c14 	.word	0x03000c14
3419600c:	03001414 	.word	0x03001414
34196010:	016e3600 	.word	0x016e3600
34196014:	02dc6c00 	.word	0x02dc6c00

34196018 <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
34196018:	b580      	push	{r7, lr}
3419601a:	b084      	sub	sp, #16
3419601c:	af00      	add	r7, sp, #0
3419601e:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34196020:	2300      	movs	r3, #0
34196022:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
34196024:	6878      	ldr	r0, [r7, #4]
34196026:	f7f8 fdb3 	bl	3418eb90 <LL_RCC_GetUSBClockSource>
3419602a:	4603      	mov	r3, r0
3419602c:	4a1a      	ldr	r2, [pc, #104]	@ (34196098 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
3419602e:	4293      	cmp	r3, r2
34196030:	d00f      	beq.n	34196052 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
34196032:	4a19      	ldr	r2, [pc, #100]	@ (34196098 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
34196034:	4293      	cmp	r3, r2
34196036:	d826      	bhi.n	34196086 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34196038:	4a18      	ldr	r2, [pc, #96]	@ (3419609c <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
3419603a:	4293      	cmp	r3, r2
3419603c:	d009      	beq.n	34196052 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3419603e:	4a17      	ldr	r2, [pc, #92]	@ (3419609c <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
34196040:	4293      	cmp	r3, r2
34196042:	d820      	bhi.n	34196086 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34196044:	4a16      	ldr	r2, [pc, #88]	@ (341960a0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
34196046:	4293      	cmp	r3, r2
34196048:	d013      	beq.n	34196072 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
3419604a:	4a16      	ldr	r2, [pc, #88]	@ (341960a4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
3419604c:	4293      	cmp	r3, r2
3419604e:	d015      	beq.n	3419607c <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
34196050:	e019      	b.n	34196086 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
34196052:	f7f8 f98b 	bl	3418e36c <LL_RCC_HSE_IsReady>
34196056:	4603      	mov	r3, r0
34196058:	2b00      	cmp	r3, #0
3419605a:	d016      	beq.n	3419608a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3419605c:	f7f8 f974 	bl	3418e348 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34196060:	4603      	mov	r3, r0
34196062:	2b00      	cmp	r3, #0
34196064:	d102      	bne.n	3419606c <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
34196066:	4b10      	ldr	r3, [pc, #64]	@ (341960a8 <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
34196068:	60fb      	str	r3, [r7, #12]
      break;
3419606a:	e00e      	b.n	3419608a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
3419606c:	4b0f      	ldr	r3, [pc, #60]	@ (341960ac <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
3419606e:	60fb      	str	r3, [r7, #12]
      break;
34196070:	e00b      	b.n	3419608a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34196072:	480f      	ldr	r0, [pc, #60]	@ (341960b0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
34196074:	f7ff ff1a 	bl	34195eac <RCCEx_GetOTGPHYCLKFreq>
34196078:	60f8      	str	r0, [r7, #12]
      break;
3419607a:	e007      	b.n	3419608c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3419607c:	480d      	ldr	r0, [pc, #52]	@ (341960b4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
3419607e:	f7ff ff15 	bl	34195eac <RCCEx_GetOTGPHYCLKFreq>
34196082:	60f8      	str	r0, [r7, #12]
      break;
34196084:	e002      	b.n	3419608c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
34196086:	bf00      	nop
34196088:	e000      	b.n	3419608c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3419608a:	bf00      	nop
  }

  return usb_frequency;
3419608c:	68fb      	ldr	r3, [r7, #12]
}
3419608e:	4618      	mov	r0, r3
34196090:	3710      	adds	r7, #16
34196092:	46bd      	mov	sp, r7
34196094:	bd80      	pop	{r7, pc}
34196096:	bf00      	nop
34196098:	01011814 	.word	0x01011814
3419609c:	01011014 	.word	0x01011014
341960a0:	01001014 	.word	0x01001014
341960a4:	01001814 	.word	0x01001814
341960a8:	02dc6c00 	.word	0x02dc6c00
341960ac:	016e3600 	.word	0x016e3600
341960b0:	03000c14 	.word	0x03000c14
341960b4:	03001414 	.word	0x03001414

341960b8 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
341960b8:	b580      	push	{r7, lr}
341960ba:	b084      	sub	sp, #16
341960bc:	af00      	add	r7, sp, #0
341960be:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
341960c0:	2300      	movs	r3, #0
341960c2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
341960c4:	6878      	ldr	r0, [r7, #4]
341960c6:	f7f8 fd6f 	bl	3418eba8 <LL_RCC_GetXSPIClockSource>
341960ca:	4603      	mov	r3, r0
341960cc:	4a76      	ldr	r2, [pc, #472]	@ (341962a8 <RCCEx_GetXSPICLKFreq+0x1f0>)
341960ce:	4293      	cmp	r3, r2
341960d0:	f000 809d 	beq.w	3419620e <RCCEx_GetXSPICLKFreq+0x156>
341960d4:	4a74      	ldr	r2, [pc, #464]	@ (341962a8 <RCCEx_GetXSPICLKFreq+0x1f0>)
341960d6:	4293      	cmp	r3, r2
341960d8:	f200 80dc 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
341960dc:	4a73      	ldr	r2, [pc, #460]	@ (341962ac <RCCEx_GetXSPICLKFreq+0x1f4>)
341960de:	4293      	cmp	r3, r2
341960e0:	f000 8095 	beq.w	3419620e <RCCEx_GetXSPICLKFreq+0x156>
341960e4:	4a71      	ldr	r2, [pc, #452]	@ (341962ac <RCCEx_GetXSPICLKFreq+0x1f4>)
341960e6:	4293      	cmp	r3, r2
341960e8:	f200 80d4 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
341960ec:	4a70      	ldr	r2, [pc, #448]	@ (341962b0 <RCCEx_GetXSPICLKFreq+0x1f8>)
341960ee:	4293      	cmp	r3, r2
341960f0:	f000 808d 	beq.w	3419620e <RCCEx_GetXSPICLKFreq+0x156>
341960f4:	4a6e      	ldr	r2, [pc, #440]	@ (341962b0 <RCCEx_GetXSPICLKFreq+0x1f8>)
341960f6:	4293      	cmp	r3, r2
341960f8:	f200 80cc 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
341960fc:	4a6d      	ldr	r2, [pc, #436]	@ (341962b4 <RCCEx_GetXSPICLKFreq+0x1fc>)
341960fe:	4293      	cmp	r3, r2
34196100:	d041      	beq.n	34196186 <RCCEx_GetXSPICLKFreq+0xce>
34196102:	4a6c      	ldr	r2, [pc, #432]	@ (341962b4 <RCCEx_GetXSPICLKFreq+0x1fc>)
34196104:	4293      	cmp	r3, r2
34196106:	f200 80c5 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
3419610a:	4a6b      	ldr	r2, [pc, #428]	@ (341962b8 <RCCEx_GetXSPICLKFreq+0x200>)
3419610c:	4293      	cmp	r3, r2
3419610e:	d03a      	beq.n	34196186 <RCCEx_GetXSPICLKFreq+0xce>
34196110:	4a69      	ldr	r2, [pc, #420]	@ (341962b8 <RCCEx_GetXSPICLKFreq+0x200>)
34196112:	4293      	cmp	r3, r2
34196114:	f200 80be 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
34196118:	4a68      	ldr	r2, [pc, #416]	@ (341962bc <RCCEx_GetXSPICLKFreq+0x204>)
3419611a:	4293      	cmp	r3, r2
3419611c:	d033      	beq.n	34196186 <RCCEx_GetXSPICLKFreq+0xce>
3419611e:	4a67      	ldr	r2, [pc, #412]	@ (341962bc <RCCEx_GetXSPICLKFreq+0x204>)
34196120:	4293      	cmp	r3, r2
34196122:	f200 80b7 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
34196126:	4a66      	ldr	r2, [pc, #408]	@ (341962c0 <RCCEx_GetXSPICLKFreq+0x208>)
34196128:	4293      	cmp	r3, r2
3419612a:	d027      	beq.n	3419617c <RCCEx_GetXSPICLKFreq+0xc4>
3419612c:	4a64      	ldr	r2, [pc, #400]	@ (341962c0 <RCCEx_GetXSPICLKFreq+0x208>)
3419612e:	4293      	cmp	r3, r2
34196130:	f200 80b0 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
34196134:	4a63      	ldr	r2, [pc, #396]	@ (341962c4 <RCCEx_GetXSPICLKFreq+0x20c>)
34196136:	4293      	cmp	r3, r2
34196138:	d020      	beq.n	3419617c <RCCEx_GetXSPICLKFreq+0xc4>
3419613a:	4a62      	ldr	r2, [pc, #392]	@ (341962c4 <RCCEx_GetXSPICLKFreq+0x20c>)
3419613c:	4293      	cmp	r3, r2
3419613e:	f200 80a9 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
34196142:	4a61      	ldr	r2, [pc, #388]	@ (341962c8 <RCCEx_GetXSPICLKFreq+0x210>)
34196144:	4293      	cmp	r3, r2
34196146:	d019      	beq.n	3419617c <RCCEx_GetXSPICLKFreq+0xc4>
34196148:	4a5f      	ldr	r2, [pc, #380]	@ (341962c8 <RCCEx_GetXSPICLKFreq+0x210>)
3419614a:	4293      	cmp	r3, r2
3419614c:	f200 80a2 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
34196150:	4a5e      	ldr	r2, [pc, #376]	@ (341962cc <RCCEx_GetXSPICLKFreq+0x214>)
34196152:	4293      	cmp	r3, r2
34196154:	d00a      	beq.n	3419616c <RCCEx_GetXSPICLKFreq+0xb4>
34196156:	4a5d      	ldr	r2, [pc, #372]	@ (341962cc <RCCEx_GetXSPICLKFreq+0x214>)
34196158:	4293      	cmp	r3, r2
3419615a:	f200 809b 	bhi.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
3419615e:	4a5c      	ldr	r2, [pc, #368]	@ (341962d0 <RCCEx_GetXSPICLKFreq+0x218>)
34196160:	4293      	cmp	r3, r2
34196162:	d003      	beq.n	3419616c <RCCEx_GetXSPICLKFreq+0xb4>
34196164:	4a5b      	ldr	r2, [pc, #364]	@ (341962d4 <RCCEx_GetXSPICLKFreq+0x21c>)
34196166:	4293      	cmp	r3, r2
34196168:	f040 8094 	bne.w	34196294 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3419616c:	f7f7 fce8 	bl	3418db40 <HAL_RCC_GetSysClockFreq>
34196170:	4603      	mov	r3, r0
34196172:	4618      	mov	r0, r3
34196174:	f7fc fc9c 	bl	34192ab0 <RCCEx_GetHCLKFreq>
34196178:	60f8      	str	r0, [r7, #12]
      break;
3419617a:	e090      	b.n	3419629e <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3419617c:	2007      	movs	r0, #7
3419617e:	f7fc ff83 	bl	34193088 <RCCEx_GetCLKPCLKFreq>
34196182:	60f8      	str	r0, [r7, #12]
      break;
34196184:	e08b      	b.n	3419629e <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
34196186:	f7f8 ffe7 	bl	3418f158 <LL_RCC_IC3_IsEnabled>
3419618a:	4603      	mov	r3, r0
3419618c:	2b00      	cmp	r3, #0
3419618e:	f000 8083 	beq.w	34196298 <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
34196192:	f7f9 f803 	bl	3418f19c <LL_RCC_IC3_GetDivider>
34196196:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34196198:	f7f8 fff2 	bl	3418f180 <LL_RCC_IC3_GetSource>
3419619c:	4603      	mov	r3, r0
3419619e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341961a2:	d029      	beq.n	341961f8 <RCCEx_GetXSPICLKFreq+0x140>
341961a4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
341961a8:	d82f      	bhi.n	3419620a <RCCEx_GetXSPICLKFreq+0x152>
341961aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341961ae:	d01a      	beq.n	341961e6 <RCCEx_GetXSPICLKFreq+0x12e>
341961b0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
341961b4:	d829      	bhi.n	3419620a <RCCEx_GetXSPICLKFreq+0x152>
341961b6:	2b00      	cmp	r3, #0
341961b8:	d003      	beq.n	341961c2 <RCCEx_GetXSPICLKFreq+0x10a>
341961ba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
341961be:	d009      	beq.n	341961d4 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
341961c0:	e023      	b.n	3419620a <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
341961c2:	f7fc fb5d 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
341961c6:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
341961c8:	68fa      	ldr	r2, [r7, #12]
341961ca:	68bb      	ldr	r3, [r7, #8]
341961cc:	fbb2 f3f3 	udiv	r3, r2, r3
341961d0:	60fb      	str	r3, [r7, #12]
            break;
341961d2:	e01b      	b.n	3419620c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
341961d4:	f7fc fb9a 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
341961d8:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
341961da:	68fa      	ldr	r2, [r7, #12]
341961dc:	68bb      	ldr	r3, [r7, #8]
341961de:	fbb2 f3f3 	udiv	r3, r2, r3
341961e2:	60fb      	str	r3, [r7, #12]
            break;
341961e4:	e012      	b.n	3419620c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
341961e6:	f7fc fbd7 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
341961ea:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
341961ec:	68fa      	ldr	r2, [r7, #12]
341961ee:	68bb      	ldr	r3, [r7, #8]
341961f0:	fbb2 f3f3 	udiv	r3, r2, r3
341961f4:	60fb      	str	r3, [r7, #12]
            break;
341961f6:	e009      	b.n	3419620c <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
341961f8:	f7fc fc14 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
341961fc:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
341961fe:	68fa      	ldr	r2, [r7, #12]
34196200:	68bb      	ldr	r3, [r7, #8]
34196202:	fbb2 f3f3 	udiv	r3, r2, r3
34196206:	60fb      	str	r3, [r7, #12]
            break;
34196208:	e000      	b.n	3419620c <RCCEx_GetXSPICLKFreq+0x154>
            break;
3419620a:	bf00      	nop
        }
      }
      break;
3419620c:	e044      	b.n	34196298 <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
3419620e:	f7f8 ffe3 	bl	3418f1d8 <LL_RCC_IC4_IsEnabled>
34196212:	4603      	mov	r3, r0
34196214:	2b00      	cmp	r3, #0
34196216:	d041      	beq.n	3419629c <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34196218:	f7f9 f800 	bl	3418f21c <LL_RCC_IC4_GetDivider>
3419621c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3419621e:	f7f8 ffef 	bl	3418f200 <LL_RCC_IC4_GetSource>
34196222:	4603      	mov	r3, r0
34196224:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34196228:	d029      	beq.n	3419627e <RCCEx_GetXSPICLKFreq+0x1c6>
3419622a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3419622e:	d82f      	bhi.n	34196290 <RCCEx_GetXSPICLKFreq+0x1d8>
34196230:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34196234:	d01a      	beq.n	3419626c <RCCEx_GetXSPICLKFreq+0x1b4>
34196236:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3419623a:	d829      	bhi.n	34196290 <RCCEx_GetXSPICLKFreq+0x1d8>
3419623c:	2b00      	cmp	r3, #0
3419623e:	d003      	beq.n	34196248 <RCCEx_GetXSPICLKFreq+0x190>
34196240:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34196244:	d009      	beq.n	3419625a <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34196246:	e023      	b.n	34196290 <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34196248:	f7fc fb1a 	bl	34192880 <HAL_RCCEx_GetPLL1CLKFreq>
3419624c:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3419624e:	68fa      	ldr	r2, [r7, #12]
34196250:	68bb      	ldr	r3, [r7, #8]
34196252:	fbb2 f3f3 	udiv	r3, r2, r3
34196256:	60fb      	str	r3, [r7, #12]
            break;
34196258:	e01b      	b.n	34196292 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3419625a:	f7fc fb57 	bl	3419290c <HAL_RCCEx_GetPLL2CLKFreq>
3419625e:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34196260:	68fa      	ldr	r2, [r7, #12]
34196262:	68bb      	ldr	r3, [r7, #8]
34196264:	fbb2 f3f3 	udiv	r3, r2, r3
34196268:	60fb      	str	r3, [r7, #12]
            break;
3419626a:	e012      	b.n	34196292 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3419626c:	f7fc fb94 	bl	34192998 <HAL_RCCEx_GetPLL3CLKFreq>
34196270:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34196272:	68fa      	ldr	r2, [r7, #12]
34196274:	68bb      	ldr	r3, [r7, #8]
34196276:	fbb2 f3f3 	udiv	r3, r2, r3
3419627a:	60fb      	str	r3, [r7, #12]
            break;
3419627c:	e009      	b.n	34196292 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3419627e:	f7fc fbd1 	bl	34192a24 <HAL_RCCEx_GetPLL4CLKFreq>
34196282:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34196284:	68fa      	ldr	r2, [r7, #12]
34196286:	68bb      	ldr	r3, [r7, #8]
34196288:	fbb2 f3f3 	udiv	r3, r2, r3
3419628c:	60fb      	str	r3, [r7, #12]
            break;
3419628e:	e000      	b.n	34196292 <RCCEx_GetXSPICLKFreq+0x1da>
            break;
34196290:	bf00      	nop
        }
      }
      break;
34196292:	e003      	b.n	3419629c <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
34196294:	bf00      	nop
34196296:	e002      	b.n	3419629e <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
34196298:	bf00      	nop
3419629a:	e000      	b.n	3419629e <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
3419629c:	bf00      	nop
  }

  return xspi_frequency;
3419629e:	68fb      	ldr	r3, [r7, #12]
}
341962a0:	4618      	mov	r0, r3
341962a2:	3710      	adds	r7, #16
341962a4:	46bd      	mov	sp, r7
341962a6:	bd80      	pop	{r7, pc}
341962a8:	03030814 	.word	0x03030814
341962ac:	03030414 	.word	0x03030414
341962b0:	03030014 	.word	0x03030014
341962b4:	03020814 	.word	0x03020814
341962b8:	03020414 	.word	0x03020414
341962bc:	03020014 	.word	0x03020014
341962c0:	03010814 	.word	0x03010814
341962c4:	03010414 	.word	0x03010414
341962c8:	03010014 	.word	0x03010014
341962cc:	03000814 	.word	0x03000814
341962d0:	03000014 	.word	0x03000014
341962d4:	03000414 	.word	0x03000414

341962d8 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
341962d8:	b480      	push	{r7}
341962da:	b089      	sub	sp, #36	@ 0x24
341962dc:	af00      	add	r7, sp, #0
341962de:	6078      	str	r0, [r7, #4]
341962e0:	6039      	str	r1, [r7, #0]
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
341962e2:	683b      	ldr	r3, [r7, #0]
341962e4:	681b      	ldr	r3, [r3, #0]
341962e6:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
341962e8:	693b      	ldr	r3, [r7, #16]
341962ea:	fa93 f3a3 	rbit	r3, r3
341962ee:	60fb      	str	r3, [r7, #12]
  return result;
341962f0:	68fb      	ldr	r3, [r7, #12]
341962f2:	617b      	str	r3, [r7, #20]
  if (value == 0U)
341962f4:	697b      	ldr	r3, [r7, #20]
341962f6:	2b00      	cmp	r3, #0
341962f8:	d101      	bne.n	341962fe <HAL_RIF_RIMC_ConfigMasterAttributes+0x26>
    return 32U;
341962fa:	2320      	movs	r3, #32
341962fc:	e003      	b.n	34196306 <HAL_RIF_RIMC_ConfigMasterAttributes+0x2e>
  return __builtin_clz(value);
341962fe:	697b      	ldr	r3, [r7, #20]
34196300:	fab3 f383 	clz	r3, r3
34196304:	b2db      	uxtb	r3, r3
34196306:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
34196308:	4a10      	ldr	r2, [pc, #64]	@ (3419634c <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
3419630a:	687b      	ldr	r3, [r7, #4]
3419630c:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34196310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34196314:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34196316:	69bb      	ldr	r3, [r7, #24]
34196318:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3419631c:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3419631e:	69fb      	ldr	r3, [r7, #28]
34196320:	011a      	lsls	r2, r3, #4
34196322:	683b      	ldr	r3, [r7, #0]
34196324:	685b      	ldr	r3, [r3, #4]
34196326:	021b      	lsls	r3, r3, #8
34196328:	4313      	orrs	r3, r2
3419632a:	69ba      	ldr	r2, [r7, #24]
3419632c:	4313      	orrs	r3, r2
3419632e:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
34196330:	4906      	ldr	r1, [pc, #24]	@ (3419634c <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34196332:	687b      	ldr	r3, [r7, #4]
34196334:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34196338:	69ba      	ldr	r2, [r7, #24]
3419633a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3419633e:	bf00      	nop
34196340:	3724      	adds	r7, #36	@ 0x24
34196342:	46bd      	mov	sp, r7
34196344:	f85d 7b04 	ldr.w	r7, [sp], #4
34196348:	4770      	bx	lr
3419634a:	bf00      	nop
3419634c:	54024000 	.word	0x54024000

34196350 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34196350:	b480      	push	{r7}
34196352:	b085      	sub	sp, #20
34196354:	af00      	add	r7, sp, #0
34196356:	6078      	str	r0, [r7, #4]
34196358:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3419635a:	4a25      	ldr	r2, [pc, #148]	@ (341963f0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3419635c:	687b      	ldr	r3, [r7, #4]
3419635e:	0f1b      	lsrs	r3, r3, #28
34196360:	3304      	adds	r3, #4
34196362:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34196366:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34196368:	687b      	ldr	r3, [r7, #4]
3419636a:	f003 031f 	and.w	r3, r3, #31
3419636e:	2201      	movs	r2, #1
34196370:	fa02 f303 	lsl.w	r3, r2, r3
34196374:	43da      	mvns	r2, r3
34196376:	68fb      	ldr	r3, [r7, #12]
34196378:	4013      	ands	r3, r2
3419637a:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3419637c:	683b      	ldr	r3, [r7, #0]
3419637e:	f003 0201 	and.w	r2, r3, #1
34196382:	687b      	ldr	r3, [r7, #4]
34196384:	f003 031f 	and.w	r3, r3, #31
34196388:	409a      	lsls	r2, r3
3419638a:	68fb      	ldr	r3, [r7, #12]
3419638c:	4313      	orrs	r3, r2
3419638e:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34196390:	4917      	ldr	r1, [pc, #92]	@ (341963f0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34196392:	687b      	ldr	r3, [r7, #4]
34196394:	0f1b      	lsrs	r3, r3, #28
34196396:	68fa      	ldr	r2, [r7, #12]
34196398:	3304      	adds	r3, #4
3419639a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3419639e:	4a14      	ldr	r2, [pc, #80]	@ (341963f0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
341963a0:	687b      	ldr	r3, [r7, #4]
341963a2:	0f1b      	lsrs	r3, r3, #28
341963a4:	330c      	adds	r3, #12
341963a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
341963aa:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1UL << (PeriphId & RIF_PERIPH_BIT_POSITION)));
341963ac:	687b      	ldr	r3, [r7, #4]
341963ae:	f003 031f 	and.w	r3, r3, #31
341963b2:	2201      	movs	r2, #1
341963b4:	fa02 f303 	lsl.w	r3, r2, r3
341963b8:	43da      	mvns	r2, r3
341963ba:	68fb      	ldr	r3, [r7, #12]
341963bc:	4013      	ands	r3, r2
341963be:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
341963c0:	683b      	ldr	r3, [r7, #0]
341963c2:	085b      	lsrs	r3, r3, #1
341963c4:	f003 0201 	and.w	r2, r3, #1
341963c8:	687b      	ldr	r3, [r7, #4]
341963ca:	f003 031f 	and.w	r3, r3, #31
341963ce:	409a      	lsls	r2, r3
341963d0:	68fb      	ldr	r3, [r7, #12]
341963d2:	4313      	orrs	r3, r2
341963d4:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
341963d6:	4906      	ldr	r1, [pc, #24]	@ (341963f0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
341963d8:	687b      	ldr	r3, [r7, #4]
341963da:	0f1b      	lsrs	r3, r3, #28
341963dc:	68fa      	ldr	r2, [r7, #12]
341963de:	330c      	adds	r3, #12
341963e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
341963e4:	bf00      	nop
341963e6:	3714      	adds	r7, #20
341963e8:	46bd      	mov	sp, r7
341963ea:	f85d 7b04 	ldr.w	r7, [sp], #4
341963ee:	4770      	bx	lr
341963f0:	54024000 	.word	0x54024000

341963f4 <LL_AHB5_GRP1_IsEnabledClock>:
{
341963f4:	b480      	push	{r7}
341963f6:	b083      	sub	sp, #12
341963f8:	af00      	add	r7, sp, #0
341963fa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
341963fc:	4b08      	ldr	r3, [pc, #32]	@ (34196420 <LL_AHB5_GRP1_IsEnabledClock+0x2c>)
341963fe:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
34196402:	687b      	ldr	r3, [r7, #4]
34196404:	4013      	ands	r3, r2
34196406:	687a      	ldr	r2, [r7, #4]
34196408:	429a      	cmp	r2, r3
3419640a:	d101      	bne.n	34196410 <LL_AHB5_GRP1_IsEnabledClock+0x1c>
3419640c:	2301      	movs	r3, #1
3419640e:	e000      	b.n	34196412 <LL_AHB5_GRP1_IsEnabledClock+0x1e>
34196410:	2300      	movs	r3, #0
}
34196412:	4618      	mov	r0, r3
34196414:	370c      	adds	r7, #12
34196416:	46bd      	mov	sp, r7
34196418:	f85d 7b04 	ldr.w	r7, [sp], #4
3419641c:	4770      	bx	lr
3419641e:	bf00      	nop
34196420:	56028000 	.word	0x56028000

34196424 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
34196424:	b580      	push	{r7, lr}
34196426:	b086      	sub	sp, #24
34196428:	af02      	add	r7, sp, #8
3419642a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3419642c:	2300      	movs	r3, #0
3419642e:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34196430:	f7f0 f86e 	bl	34186510 <HAL_GetTick>
34196434:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
34196436:	687b      	ldr	r3, [r7, #4]
34196438:	2b00      	cmp	r3, #0
3419643a:	d102      	bne.n	34196442 <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
3419643c:	2301      	movs	r3, #1
3419643e:	73fb      	strb	r3, [r7, #15]
34196440:	e0ec      	b.n	3419661c <HAL_XSPI_Init+0x1f8>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34196442:	687b      	ldr	r3, [r7, #4]
34196444:	2200      	movs	r2, #0
34196446:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
34196448:	687b      	ldr	r3, [r7, #4]
3419644a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3419644c:	2b00      	cmp	r3, #0
3419644e:	f040 80e5 	bne.w	3419661c <HAL_XSPI_Init+0x1f8>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
34196452:	6878      	ldr	r0, [r7, #4]
34196454:	f7ec ff98 	bl	34183388 <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
34196458:	f241 3188 	movw	r1, #5000	@ 0x1388
3419645c:	6878      	ldr	r0, [r7, #4]
3419645e:	f000 fc3c 	bl	34196cda <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
34196462:	687b      	ldr	r3, [r7, #4]
34196464:	681b      	ldr	r3, [r3, #0]
34196466:	689a      	ldr	r2, [r3, #8]
34196468:	4b6f      	ldr	r3, [pc, #444]	@ (34196628 <HAL_XSPI_Init+0x204>)
3419646a:	4013      	ands	r3, r2
3419646c:	687a      	ldr	r2, [r7, #4]
3419646e:	68d1      	ldr	r1, [r2, #12]
34196470:	687a      	ldr	r2, [r7, #4]
34196472:	6912      	ldr	r2, [r2, #16]
34196474:	0412      	lsls	r2, r2, #16
34196476:	4311      	orrs	r1, r2
34196478:	687a      	ldr	r2, [r7, #4]
3419647a:	6952      	ldr	r2, [r2, #20]
3419647c:	3a01      	subs	r2, #1
3419647e:	0212      	lsls	r2, r2, #8
34196480:	4311      	orrs	r1, r2
34196482:	687a      	ldr	r2, [r7, #4]
34196484:	69d2      	ldr	r2, [r2, #28]
34196486:	4311      	orrs	r1, r2
34196488:	687a      	ldr	r2, [r7, #4]
3419648a:	6812      	ldr	r2, [r2, #0]
3419648c:	430b      	orrs	r3, r1
3419648e:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
34196490:	687b      	ldr	r3, [r7, #4]
34196492:	681b      	ldr	r3, [r3, #0]
34196494:	68db      	ldr	r3, [r3, #12]
34196496:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
3419649a:	687b      	ldr	r3, [r7, #4]
3419649c:	6a1a      	ldr	r2, [r3, #32]
3419649e:	687b      	ldr	r3, [r7, #4]
341964a0:	681b      	ldr	r3, [r3, #0]
341964a2:	430a      	orrs	r2, r1
341964a4:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
341964a6:	687b      	ldr	r3, [r7, #4]
341964a8:	681b      	ldr	r3, [r3, #0]
341964aa:	691b      	ldr	r3, [r3, #16]
341964ac:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
341964b0:	687b      	ldr	r3, [r7, #4]
341964b2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341964b4:	041a      	lsls	r2, r3, #16
341964b6:	687b      	ldr	r3, [r7, #4]
341964b8:	681b      	ldr	r3, [r3, #0]
341964ba:	430a      	orrs	r2, r1
341964bc:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
341964be:	687b      	ldr	r3, [r7, #4]
341964c0:	681b      	ldr	r3, [r3, #0]
341964c2:	691b      	ldr	r3, [r3, #16]
341964c4:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
341964c8:	687b      	ldr	r3, [r7, #4]
341964ca:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
341964cc:	687b      	ldr	r3, [r7, #4]
341964ce:	681b      	ldr	r3, [r3, #0]
341964d0:	430a      	orrs	r2, r1
341964d2:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
341964d4:	687b      	ldr	r3, [r7, #4]
341964d6:	681b      	ldr	r3, [r3, #0]
341964d8:	687a      	ldr	r2, [r7, #4]
341964da:	6b92      	ldr	r2, [r2, #56]	@ 0x38
341964dc:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
341964de:	687b      	ldr	r3, [r7, #4]
341964e0:	681b      	ldr	r3, [r3, #0]
341964e2:	681b      	ldr	r3, [r3, #0]
341964e4:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
341964e8:	687b      	ldr	r3, [r7, #4]
341964ea:	685b      	ldr	r3, [r3, #4]
341964ec:	3b01      	subs	r3, #1
341964ee:	021a      	lsls	r2, r3, #8
341964f0:	687b      	ldr	r3, [r7, #4]
341964f2:	681b      	ldr	r3, [r3, #0]
341964f4:	430a      	orrs	r2, r1
341964f6:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
341964f8:	687b      	ldr	r3, [r7, #4]
341964fa:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
341964fc:	9300      	str	r3, [sp, #0]
341964fe:	68bb      	ldr	r3, [r7, #8]
34196500:	2200      	movs	r2, #0
34196502:	2120      	movs	r1, #32
34196504:	6878      	ldr	r0, [r7, #4]
34196506:	f000 fd23 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
3419650a:	4603      	mov	r3, r0
3419650c:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
3419650e:	7bfb      	ldrb	r3, [r7, #15]
34196510:	2b00      	cmp	r3, #0
34196512:	f040 8083 	bne.w	3419661c <HAL_XSPI_Init+0x1f8>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34196516:	687b      	ldr	r3, [r7, #4]
34196518:	681b      	ldr	r3, [r3, #0]
3419651a:	68db      	ldr	r3, [r3, #12]
3419651c:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34196520:	687b      	ldr	r3, [r7, #4]
34196522:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34196524:	687b      	ldr	r3, [r7, #4]
34196526:	681b      	ldr	r3, [r3, #0]
34196528:	430a      	orrs	r2, r1
3419652a:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3419652c:	687b      	ldr	r3, [r7, #4]
3419652e:	681b      	ldr	r3, [r3, #0]
34196530:	4a3e      	ldr	r2, [pc, #248]	@ (3419662c <HAL_XSPI_Init+0x208>)
34196532:	4293      	cmp	r3, r2
34196534:	d018      	beq.n	34196568 <HAL_XSPI_Init+0x144>
34196536:	687b      	ldr	r3, [r7, #4]
34196538:	681b      	ldr	r3, [r3, #0]
3419653a:	4a3d      	ldr	r2, [pc, #244]	@ (34196630 <HAL_XSPI_Init+0x20c>)
3419653c:	4293      	cmp	r3, r2
3419653e:	d013      	beq.n	34196568 <HAL_XSPI_Init+0x144>
34196540:	687b      	ldr	r3, [r7, #4]
34196542:	681b      	ldr	r3, [r3, #0]
34196544:	4a3b      	ldr	r2, [pc, #236]	@ (34196634 <HAL_XSPI_Init+0x210>)
34196546:	4293      	cmp	r3, r2
34196548:	d00e      	beq.n	34196568 <HAL_XSPI_Init+0x144>
3419654a:	687b      	ldr	r3, [r7, #4]
3419654c:	681b      	ldr	r3, [r3, #0]
3419654e:	4a3a      	ldr	r2, [pc, #232]	@ (34196638 <HAL_XSPI_Init+0x214>)
34196550:	4293      	cmp	r3, r2
34196552:	d009      	beq.n	34196568 <HAL_XSPI_Init+0x144>
34196554:	687b      	ldr	r3, [r7, #4]
34196556:	681b      	ldr	r3, [r3, #0]
34196558:	4a38      	ldr	r2, [pc, #224]	@ (3419663c <HAL_XSPI_Init+0x218>)
3419655a:	4293      	cmp	r3, r2
3419655c:	d004      	beq.n	34196568 <HAL_XSPI_Init+0x144>
3419655e:	687b      	ldr	r3, [r7, #4]
34196560:	681b      	ldr	r3, [r3, #0]
34196562:	4a37      	ldr	r2, [pc, #220]	@ (34196640 <HAL_XSPI_Init+0x21c>)
34196564:	4293      	cmp	r3, r2
34196566:	d10f      	bne.n	34196588 <HAL_XSPI_Init+0x164>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34196568:	687b      	ldr	r3, [r7, #4]
3419656a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419656c:	9300      	str	r3, [sp, #0]
3419656e:	68bb      	ldr	r3, [r7, #8]
34196570:	2200      	movs	r2, #0
34196572:	2120      	movs	r1, #32
34196574:	6878      	ldr	r0, [r7, #4]
34196576:	f000 fceb 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
3419657a:	4603      	mov	r3, r0
3419657c:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
3419657e:	7bfb      	ldrb	r3, [r7, #15]
34196580:	2b00      	cmp	r3, #0
34196582:	d001      	beq.n	34196588 <HAL_XSPI_Init+0x164>
          {
            return status;
34196584:	7bfb      	ldrb	r3, [r7, #15]
34196586:	e04a      	b.n	3419661e <HAL_XSPI_Init+0x1fa>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
34196588:	687b      	ldr	r3, [r7, #4]
3419658a:	681b      	ldr	r3, [r3, #0]
3419658c:	681b      	ldr	r3, [r3, #0]
3419658e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
34196592:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34196596:	687a      	ldr	r2, [r7, #4]
34196598:	6891      	ldr	r1, [r2, #8]
3419659a:	687a      	ldr	r2, [r7, #4]
3419659c:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
3419659e:	4311      	orrs	r1, r2
341965a0:	687a      	ldr	r2, [r7, #4]
341965a2:	6812      	ldr	r2, [r2, #0]
341965a4:	430b      	orrs	r3, r1
341965a6:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
341965a8:	687b      	ldr	r3, [r7, #4]
341965aa:	681b      	ldr	r3, [r3, #0]
341965ac:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
341965b0:	f023 4180 	bic.w	r1, r3, #1073741824	@ 0x40000000
341965b4:	687b      	ldr	r3, [r7, #4]
341965b6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
341965b8:	687b      	ldr	r3, [r7, #4]
341965ba:	681b      	ldr	r3, [r3, #0]
341965bc:	430a      	orrs	r2, r1
341965be:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
341965c2:	687b      	ldr	r3, [r7, #4]
341965c4:	681b      	ldr	r3, [r3, #0]
341965c6:	681a      	ldr	r2, [r3, #0]
341965c8:	687b      	ldr	r3, [r7, #4]
341965ca:	681b      	ldr	r3, [r3, #0]
341965cc:	f042 0201 	orr.w	r2, r2, #1
341965d0:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
341965d2:	687b      	ldr	r3, [r7, #4]
341965d4:	699b      	ldr	r3, [r3, #24]
341965d6:	2b02      	cmp	r3, #2
341965d8:	d107      	bne.n	341965ea <HAL_XSPI_Init+0x1c6>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
341965da:	687b      	ldr	r3, [r7, #4]
341965dc:	681b      	ldr	r3, [r3, #0]
341965de:	689a      	ldr	r2, [r3, #8]
341965e0:	687b      	ldr	r3, [r7, #4]
341965e2:	681b      	ldr	r3, [r3, #0]
341965e4:	f042 0202 	orr.w	r2, r2, #2
341965e8:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
341965ea:	687b      	ldr	r3, [r7, #4]
341965ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341965ee:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
341965f2:	d107      	bne.n	34196604 <HAL_XSPI_Init+0x1e0>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
341965f4:	687b      	ldr	r3, [r7, #4]
341965f6:	681b      	ldr	r3, [r3, #0]
341965f8:	689a      	ldr	r2, [r3, #8]
341965fa:	687b      	ldr	r3, [r7, #4]
341965fc:	681b      	ldr	r3, [r3, #0]
341965fe:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
34196602:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34196604:	687b      	ldr	r3, [r7, #4]
34196606:	68db      	ldr	r3, [r3, #12]
34196608:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3419660c:	d103      	bne.n	34196616 <HAL_XSPI_Init+0x1f2>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3419660e:	687b      	ldr	r3, [r7, #4]
34196610:	2201      	movs	r2, #1
34196612:	659a      	str	r2, [r3, #88]	@ 0x58
34196614:	e002      	b.n	3419661c <HAL_XSPI_Init+0x1f8>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
34196616:	687b      	ldr	r3, [r7, #4]
34196618:	2202      	movs	r2, #2
3419661a:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
3419661c:	7bfb      	ldrb	r3, [r7, #15]
}
3419661e:	4618      	mov	r0, r3
34196620:	3710      	adds	r7, #16
34196622:	46bd      	mov	sp, r7
34196624:	bd80      	pop	{r7, pc}
34196626:	bf00      	nop
34196628:	f8e0c0fc 	.word	0xf8e0c0fc
3419662c:	58025000 	.word	0x58025000
34196630:	48025000 	.word	0x48025000
34196634:	5802a000 	.word	0x5802a000
34196638:	4802a000 	.word	0x4802a000
3419663c:	5802d000 	.word	0x5802d000
34196640:	4802d000 	.word	0x4802d000

34196644 <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd, uint32_t Timeout)
{
34196644:	b580      	push	{r7, lr}
34196646:	b08a      	sub	sp, #40	@ 0x28
34196648:	af02      	add	r7, sp, #8
3419664a:	60f8      	str	r0, [r7, #12]
3419664c:	60b9      	str	r1, [r7, #8]
3419664e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
34196650:	f7ef ff5e 	bl	34186510 <HAL_GetTick>
34196654:	61b8      	str	r0, [r7, #24]
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34196656:	68bb      	ldr	r3, [r7, #8]
34196658:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419665a:	2b00      	cmp	r3, #0
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));

  /* Check the state of the driver */
  state = hxspi->State;
3419665c:	68fb      	ldr	r3, [r7, #12]
3419665e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196660:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
34196662:	697b      	ldr	r3, [r7, #20]
34196664:	2b02      	cmp	r3, #2
34196666:	d104      	bne.n	34196672 <HAL_XSPI_Command+0x2e>
34196668:	68fb      	ldr	r3, [r7, #12]
3419666a:	68db      	ldr	r3, [r3, #12]
3419666c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34196670:	d115      	bne.n	3419669e <HAL_XSPI_Command+0x5a>
34196672:	697b      	ldr	r3, [r7, #20]
34196674:	2b14      	cmp	r3, #20
34196676:	d107      	bne.n	34196688 <HAL_XSPI_Command+0x44>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34196678:	68bb      	ldr	r3, [r7, #8]
3419667a:	681b      	ldr	r3, [r3, #0]
3419667c:	2b02      	cmp	r3, #2
3419667e:	d00e      	beq.n	3419669e <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34196680:	68bb      	ldr	r3, [r7, #8]
34196682:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34196684:	2b03      	cmp	r3, #3
34196686:	d00a      	beq.n	3419669e <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34196688:	697b      	ldr	r3, [r7, #20]
3419668a:	2b24      	cmp	r3, #36	@ 0x24
3419668c:	d15e      	bne.n	3419674c <HAL_XSPI_Command+0x108>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
3419668e:	68bb      	ldr	r3, [r7, #8]
34196690:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
34196692:	2b01      	cmp	r3, #1
34196694:	d003      	beq.n	3419669e <HAL_XSPI_Command+0x5a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
34196696:	68bb      	ldr	r3, [r7, #8]
34196698:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
3419669a:	2b03      	cmp	r3, #3
3419669c:	d156      	bne.n	3419674c <HAL_XSPI_Command+0x108>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3419669e:	687b      	ldr	r3, [r7, #4]
341966a0:	9300      	str	r3, [sp, #0]
341966a2:	69bb      	ldr	r3, [r7, #24]
341966a4:	2200      	movs	r2, #0
341966a6:	2120      	movs	r1, #32
341966a8:	68f8      	ldr	r0, [r7, #12]
341966aa:	f000 fc51 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
341966ae:	4603      	mov	r3, r0
341966b0:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
341966b2:	7ffb      	ldrb	r3, [r7, #31]
341966b4:	2b00      	cmp	r3, #0
341966b6:	d146      	bne.n	34196746 <HAL_XSPI_Command+0x102>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
341966b8:	68fb      	ldr	r3, [r7, #12]
341966ba:	2200      	movs	r2, #0
341966bc:	65da      	str	r2, [r3, #92]	@ 0x5c

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
341966be:	68b9      	ldr	r1, [r7, #8]
341966c0:	68f8      	ldr	r0, [r7, #12]
341966c2:	f000 fc7b 	bl	34196fbc <XSPI_ConfigCmd>
341966c6:	4603      	mov	r3, r0
341966c8:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
341966ca:	7ffb      	ldrb	r3, [r7, #31]
341966cc:	2b00      	cmp	r3, #0
341966ce:	d143      	bne.n	34196758 <HAL_XSPI_Command+0x114>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
341966d0:	68bb      	ldr	r3, [r7, #8]
341966d2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341966d4:	2b00      	cmp	r3, #0
341966d6:	d10e      	bne.n	341966f6 <HAL_XSPI_Command+0xb2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until BUSY flag is reset to go back in idle state. */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
341966d8:	687b      	ldr	r3, [r7, #4]
341966da:	9300      	str	r3, [sp, #0]
341966dc:	69bb      	ldr	r3, [r7, #24]
341966de:	2200      	movs	r2, #0
341966e0:	2120      	movs	r1, #32
341966e2:	68f8      	ldr	r0, [r7, #12]
341966e4:	f000 fc34 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
341966e8:	4603      	mov	r3, r0
341966ea:	77fb      	strb	r3, [r7, #31]

          /* Clear TC flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
341966ec:	68fb      	ldr	r3, [r7, #12]
341966ee:	681b      	ldr	r3, [r3, #0]
341966f0:	2202      	movs	r2, #2
341966f2:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
341966f4:	e030      	b.n	34196758 <HAL_XSPI_Command+0x114>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
341966f6:	68bb      	ldr	r3, [r7, #8]
341966f8:	681b      	ldr	r3, [r3, #0]
341966fa:	2b00      	cmp	r3, #0
341966fc:	d103      	bne.n	34196706 <HAL_XSPI_Command+0xc2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
341966fe:	68fb      	ldr	r3, [r7, #12]
34196700:	2204      	movs	r2, #4
34196702:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34196704:	e028      	b.n	34196758 <HAL_XSPI_Command+0x114>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
34196706:	68bb      	ldr	r3, [r7, #8]
34196708:	681b      	ldr	r3, [r3, #0]
3419670a:	2b01      	cmp	r3, #1
3419670c:	d10b      	bne.n	34196726 <HAL_XSPI_Command+0xe2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
3419670e:	68fb      	ldr	r3, [r7, #12]
34196710:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196712:	2b24      	cmp	r3, #36	@ 0x24
34196714:	d103      	bne.n	3419671e <HAL_XSPI_Command+0xda>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34196716:	68fb      	ldr	r3, [r7, #12]
34196718:	2204      	movs	r2, #4
3419671a:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3419671c:	e01c      	b.n	34196758 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
3419671e:	68fb      	ldr	r3, [r7, #12]
34196720:	2214      	movs	r2, #20
34196722:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34196724:	e018      	b.n	34196758 <HAL_XSPI_Command+0x114>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34196726:	68bb      	ldr	r3, [r7, #8]
34196728:	681b      	ldr	r3, [r3, #0]
3419672a:	2b02      	cmp	r3, #2
3419672c:	d114      	bne.n	34196758 <HAL_XSPI_Command+0x114>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
3419672e:	68fb      	ldr	r3, [r7, #12]
34196730:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196732:	2b14      	cmp	r3, #20
34196734:	d103      	bne.n	3419673e <HAL_XSPI_Command+0xfa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34196736:	68fb      	ldr	r3, [r7, #12]
34196738:	2204      	movs	r2, #4
3419673a:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
3419673c:	e00c      	b.n	34196758 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3419673e:	68fb      	ldr	r3, [r7, #12]
34196740:	2224      	movs	r2, #36	@ 0x24
34196742:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34196744:	e008      	b.n	34196758 <HAL_XSPI_Command+0x114>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
34196746:	2302      	movs	r3, #2
34196748:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
3419674a:	e005      	b.n	34196758 <HAL_XSPI_Command+0x114>
    }
  }
  else
  {
    status = HAL_ERROR;
3419674c:	2301      	movs	r3, #1
3419674e:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34196750:	68fb      	ldr	r3, [r7, #12]
34196752:	2210      	movs	r2, #16
34196754:	65da      	str	r2, [r3, #92]	@ 0x5c
34196756:	e000      	b.n	3419675a <HAL_XSPI_Command+0x116>
    if (status == HAL_OK)
34196758:	bf00      	nop
  }

  return status;
3419675a:	7ffb      	ldrb	r3, [r7, #31]
}
3419675c:	4618      	mov	r0, r3
3419675e:	3720      	adds	r7, #32
34196760:	46bd      	mov	sp, r7
34196762:	bd80      	pop	{r7, pc}

34196764 <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
34196764:	b580      	push	{r7, lr}
34196766:	b08a      	sub	sp, #40	@ 0x28
34196768:	af02      	add	r7, sp, #8
3419676a:	60f8      	str	r0, [r7, #12]
3419676c:	60b9      	str	r1, [r7, #8]
3419676e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34196770:	f7ef fece 	bl	34186510 <HAL_GetTick>
34196774:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34196776:	68fb      	ldr	r3, [r7, #12]
34196778:	681b      	ldr	r3, [r3, #0]
3419677a:	3350      	adds	r3, #80	@ 0x50
3419677c:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
3419677e:	68bb      	ldr	r3, [r7, #8]
34196780:	2b00      	cmp	r3, #0
34196782:	d105      	bne.n	34196790 <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
34196784:	2301      	movs	r3, #1
34196786:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34196788:	68fb      	ldr	r3, [r7, #12]
3419678a:	2208      	movs	r2, #8
3419678c:	65da      	str	r2, [r3, #92]	@ 0x5c
3419678e:	e057      	b.n	34196840 <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34196790:	68fb      	ldr	r3, [r7, #12]
34196792:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196794:	2b04      	cmp	r3, #4
34196796:	d14e      	bne.n	34196836 <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34196798:	68fb      	ldr	r3, [r7, #12]
3419679a:	681b      	ldr	r3, [r3, #0]
3419679c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419679e:	1c5a      	adds	r2, r3, #1
341967a0:	68fb      	ldr	r3, [r7, #12]
341967a2:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
341967a4:	68fb      	ldr	r3, [r7, #12]
341967a6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
341967a8:	68fb      	ldr	r3, [r7, #12]
341967aa:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = (uint8_t *)pData;
341967ac:	68fb      	ldr	r3, [r7, #12]
341967ae:	68ba      	ldr	r2, [r7, #8]
341967b0:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
341967b2:	68fb      	ldr	r3, [r7, #12]
341967b4:	681b      	ldr	r3, [r3, #0]
341967b6:	681a      	ldr	r2, [r3, #0]
341967b8:	68fb      	ldr	r3, [r7, #12]
341967ba:	681b      	ldr	r3, [r3, #0]
341967bc:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
341967c0:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
341967c2:	687b      	ldr	r3, [r7, #4]
341967c4:	9300      	str	r3, [sp, #0]
341967c6:	69bb      	ldr	r3, [r7, #24]
341967c8:	2201      	movs	r2, #1
341967ca:	2104      	movs	r1, #4
341967cc:	68f8      	ldr	r0, [r7, #12]
341967ce:	f000 fbbf 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
341967d2:	4603      	mov	r3, r0
341967d4:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
341967d6:	7ffb      	ldrb	r3, [r7, #31]
341967d8:	2b00      	cmp	r3, #0
341967da:	d113      	bne.n	34196804 <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
341967dc:	68fb      	ldr	r3, [r7, #12]
341967de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341967e0:	781a      	ldrb	r2, [r3, #0]
341967e2:	697b      	ldr	r3, [r7, #20]
341967e4:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
341967e6:	68fb      	ldr	r3, [r7, #12]
341967e8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341967ea:	1c5a      	adds	r2, r3, #1
341967ec:	68fb      	ldr	r3, [r7, #12]
341967ee:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
341967f0:	68fb      	ldr	r3, [r7, #12]
341967f2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341967f4:	1e5a      	subs	r2, r3, #1
341967f6:	68fb      	ldr	r3, [r7, #12]
341967f8:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
341967fa:	68fb      	ldr	r3, [r7, #12]
341967fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341967fe:	2b00      	cmp	r3, #0
34196800:	d1df      	bne.n	341967c2 <HAL_XSPI_Transmit+0x5e>
34196802:	e000      	b.n	34196806 <HAL_XSPI_Transmit+0xa2>
          break;
34196804:	bf00      	nop

      if (status == HAL_OK)
34196806:	7ffb      	ldrb	r3, [r7, #31]
34196808:	2b00      	cmp	r3, #0
3419680a:	d119      	bne.n	34196840 <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3419680c:	687b      	ldr	r3, [r7, #4]
3419680e:	9300      	str	r3, [sp, #0]
34196810:	69bb      	ldr	r3, [r7, #24]
34196812:	2201      	movs	r2, #1
34196814:	2102      	movs	r1, #2
34196816:	68f8      	ldr	r0, [r7, #12]
34196818:	f000 fb9a 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
3419681c:	4603      	mov	r3, r0
3419681e:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
34196820:	7ffb      	ldrb	r3, [r7, #31]
34196822:	2b00      	cmp	r3, #0
34196824:	d10c      	bne.n	34196840 <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34196826:	68fb      	ldr	r3, [r7, #12]
34196828:	681b      	ldr	r3, [r3, #0]
3419682a:	2202      	movs	r2, #2
3419682c:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3419682e:	68fb      	ldr	r3, [r7, #12]
34196830:	2202      	movs	r2, #2
34196832:	659a      	str	r2, [r3, #88]	@ 0x58
34196834:	e004      	b.n	34196840 <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
34196836:	2301      	movs	r3, #1
34196838:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3419683a:	68fb      	ldr	r3, [r7, #12]
3419683c:	2210      	movs	r2, #16
3419683e:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
34196840:	7ffb      	ldrb	r3, [r7, #31]
}
34196842:	4618      	mov	r0, r3
34196844:	3720      	adds	r7, #32
34196846:	46bd      	mov	sp, r7
34196848:	bd80      	pop	{r7, pc}

3419684a <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *pData, uint32_t Timeout)
{
3419684a:	b580      	push	{r7, lr}
3419684c:	b08c      	sub	sp, #48	@ 0x30
3419684e:	af02      	add	r7, sp, #8
34196850:	60f8      	str	r0, [r7, #12]
34196852:	60b9      	str	r1, [r7, #8]
34196854:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34196856:	f7ef fe5b 	bl	34186510 <HAL_GetTick>
3419685a:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
3419685c:	68fb      	ldr	r3, [r7, #12]
3419685e:	681b      	ldr	r3, [r3, #0]
34196860:	3350      	adds	r3, #80	@ 0x50
34196862:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
34196864:	68fb      	ldr	r3, [r7, #12]
34196866:	681b      	ldr	r3, [r3, #0]
34196868:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419686a:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
3419686c:	68fb      	ldr	r3, [r7, #12]
3419686e:	681b      	ldr	r3, [r3, #0]
34196870:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34196874:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
34196876:	68bb      	ldr	r3, [r7, #8]
34196878:	2b00      	cmp	r3, #0
3419687a:	d106      	bne.n	3419688a <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
3419687c:	2301      	movs	r3, #1
3419687e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34196882:	68fb      	ldr	r3, [r7, #12]
34196884:	2208      	movs	r2, #8
34196886:	65da      	str	r2, [r3, #92]	@ 0x5c
34196888:	e07c      	b.n	34196984 <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
3419688a:	68fb      	ldr	r3, [r7, #12]
3419688c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3419688e:	2b04      	cmp	r3, #4
34196890:	d172      	bne.n	34196978 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
34196892:	68fb      	ldr	r3, [r7, #12]
34196894:	681b      	ldr	r3, [r3, #0]
34196896:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34196898:	1c5a      	adds	r2, r3, #1
3419689a:	68fb      	ldr	r3, [r7, #12]
3419689c:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
3419689e:	68fb      	ldr	r3, [r7, #12]
341968a0:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
341968a2:	68fb      	ldr	r3, [r7, #12]
341968a4:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = pData;
341968a6:	68fb      	ldr	r3, [r7, #12]
341968a8:	68ba      	ldr	r2, [r7, #8]
341968aa:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
341968ac:	68fb      	ldr	r3, [r7, #12]
341968ae:	681b      	ldr	r3, [r3, #0]
341968b0:	681b      	ldr	r3, [r3, #0]
341968b2:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
341968b6:	68fb      	ldr	r3, [r7, #12]
341968b8:	681b      	ldr	r3, [r3, #0]
341968ba:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
341968be:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
341968c0:	68fb      	ldr	r3, [r7, #12]
341968c2:	68db      	ldr	r3, [r3, #12]
341968c4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
341968c8:	d104      	bne.n	341968d4 <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
341968ca:	68fb      	ldr	r3, [r7, #12]
341968cc:	681b      	ldr	r3, [r3, #0]
341968ce:	69ba      	ldr	r2, [r7, #24]
341968d0:	649a      	str	r2, [r3, #72]	@ 0x48
341968d2:	e011      	b.n	341968f8 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
341968d4:	68fb      	ldr	r3, [r7, #12]
341968d6:	681b      	ldr	r3, [r3, #0]
341968d8:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
341968dc:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
341968e0:	2b00      	cmp	r3, #0
341968e2:	d004      	beq.n	341968ee <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
341968e4:	68fb      	ldr	r3, [r7, #12]
341968e6:	681b      	ldr	r3, [r3, #0]
341968e8:	69ba      	ldr	r2, [r7, #24]
341968ea:	649a      	str	r2, [r3, #72]	@ 0x48
341968ec:	e004      	b.n	341968f8 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
341968ee:	68fb      	ldr	r3, [r7, #12]
341968f0:	681b      	ldr	r3, [r3, #0]
341968f2:	697a      	ldr	r2, [r7, #20]
341968f4:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
341968f8:	687b      	ldr	r3, [r7, #4]
341968fa:	9300      	str	r3, [sp, #0]
341968fc:	6a3b      	ldr	r3, [r7, #32]
341968fe:	2201      	movs	r2, #1
34196900:	2106      	movs	r1, #6
34196902:	68f8      	ldr	r0, [r7, #12]
34196904:	f000 fb24 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
34196908:	4603      	mov	r3, r0
3419690a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
3419690e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196912:	2b00      	cmp	r3, #0
34196914:	d114      	bne.n	34196940 <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
34196916:	68fb      	ldr	r3, [r7, #12]
34196918:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419691a:	69fa      	ldr	r2, [r7, #28]
3419691c:	7812      	ldrb	r2, [r2, #0]
3419691e:	b2d2      	uxtb	r2, r2
34196920:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34196922:	68fb      	ldr	r3, [r7, #12]
34196924:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34196926:	1c5a      	adds	r2, r3, #1
34196928:	68fb      	ldr	r3, [r7, #12]
3419692a:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3419692c:	68fb      	ldr	r3, [r7, #12]
3419692e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34196930:	1e5a      	subs	r2, r3, #1
34196932:	68fb      	ldr	r3, [r7, #12]
34196934:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34196936:	68fb      	ldr	r3, [r7, #12]
34196938:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419693a:	2b00      	cmp	r3, #0
3419693c:	d1dc      	bne.n	341968f8 <HAL_XSPI_Receive+0xae>
3419693e:	e000      	b.n	34196942 <HAL_XSPI_Receive+0xf8>
          break;
34196940:	bf00      	nop

      if (status == HAL_OK)
34196942:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196946:	2b00      	cmp	r3, #0
34196948:	d11c      	bne.n	34196984 <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
3419694a:	687b      	ldr	r3, [r7, #4]
3419694c:	9300      	str	r3, [sp, #0]
3419694e:	6a3b      	ldr	r3, [r7, #32]
34196950:	2201      	movs	r2, #1
34196952:	2102      	movs	r1, #2
34196954:	68f8      	ldr	r0, [r7, #12]
34196956:	f000 fafb 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
3419695a:	4603      	mov	r3, r0
3419695c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
34196960:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34196964:	2b00      	cmp	r3, #0
34196966:	d10d      	bne.n	34196984 <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34196968:	68fb      	ldr	r3, [r7, #12]
3419696a:	681b      	ldr	r3, [r3, #0]
3419696c:	2202      	movs	r2, #2
3419696e:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
34196970:	68fb      	ldr	r3, [r7, #12]
34196972:	2202      	movs	r2, #2
34196974:	659a      	str	r2, [r3, #88]	@ 0x58
34196976:	e005      	b.n	34196984 <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
34196978:	2301      	movs	r3, #1
3419697a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3419697e:	68fb      	ldr	r3, [r7, #12]
34196980:	2210      	movs	r2, #16
34196982:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
34196984:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
34196988:	4618      	mov	r0, r3
3419698a:	3728      	adds	r7, #40	@ 0x28
3419698c:	46bd      	mov	sp, r7
3419698e:	bd80      	pop	{r7, pc}

34196990 <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, const XSPI_AutoPollingTypeDef *pCfg,
                                       uint32_t Timeout)
{
34196990:	b580      	push	{r7, lr}
34196992:	b08a      	sub	sp, #40	@ 0x28
34196994:	af02      	add	r7, sp, #8
34196996:	60f8      	str	r0, [r7, #12]
34196998:	60b9      	str	r1, [r7, #8]
3419699a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3419699c:	f7ef fdb8 	bl	34186510 <HAL_GetTick>
341969a0:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = hxspi->Instance->AR;
341969a2:	68fb      	ldr	r3, [r7, #12]
341969a4:	681b      	ldr	r3, [r3, #0]
341969a6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
341969a8:	617b      	str	r3, [r7, #20]
  uint32_t ir_reg = hxspi->Instance->IR;
341969aa:	68fb      	ldr	r3, [r7, #12]
341969ac:	681b      	ldr	r3, [r3, #0]
341969ae:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
341969b2:	613b      	str	r3, [r7, #16]
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
341969b4:	68fb      	ldr	r3, [r7, #12]
341969b6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
341969b8:	2b04      	cmp	r3, #4
341969ba:	d167      	bne.n	34196a8c <HAL_XSPI_AutoPolling+0xfc>
341969bc:	68bb      	ldr	r3, [r7, #8]
341969be:	68db      	ldr	r3, [r3, #12]
341969c0:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
341969c4:	d162      	bne.n	34196a8c <HAL_XSPI_AutoPolling+0xfc>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
341969c6:	687b      	ldr	r3, [r7, #4]
341969c8:	9300      	str	r3, [sp, #0]
341969ca:	69bb      	ldr	r3, [r7, #24]
341969cc:	2200      	movs	r2, #0
341969ce:	2120      	movs	r1, #32
341969d0:	68f8      	ldr	r0, [r7, #12]
341969d2:	f000 fabd 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
341969d6:	4603      	mov	r3, r0
341969d8:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
341969da:	7ffb      	ldrb	r3, [r7, #31]
341969dc:	2b00      	cmp	r3, #0
341969de:	d152      	bne.n	34196a86 <HAL_XSPI_AutoPolling+0xf6>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
341969e0:	68fb      	ldr	r3, [r7, #12]
341969e2:	681b      	ldr	r3, [r3, #0]
341969e4:	68ba      	ldr	r2, [r7, #8]
341969e6:	6812      	ldr	r2, [r2, #0]
341969e8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
341969ec:	68fb      	ldr	r3, [r7, #12]
341969ee:	681b      	ldr	r3, [r3, #0]
341969f0:	68ba      	ldr	r2, [r7, #8]
341969f2:	6852      	ldr	r2, [r2, #4]
341969f4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
341969f8:	68fb      	ldr	r3, [r7, #12]
341969fa:	681b      	ldr	r3, [r3, #0]
341969fc:	68ba      	ldr	r2, [r7, #8]
341969fe:	6912      	ldr	r2, [r2, #16]
34196a00:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34196a04:	68fb      	ldr	r3, [r7, #12]
34196a06:	681b      	ldr	r3, [r3, #0]
34196a08:	681b      	ldr	r3, [r3, #0]
34196a0a:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
34196a0e:	68bb      	ldr	r3, [r7, #8]
34196a10:	6899      	ldr	r1, [r3, #8]
34196a12:	68bb      	ldr	r3, [r7, #8]
34196a14:	68db      	ldr	r3, [r3, #12]
34196a16:	430b      	orrs	r3, r1
34196a18:	431a      	orrs	r2, r3
34196a1a:	68fb      	ldr	r3, [r7, #12]
34196a1c:	681b      	ldr	r3, [r3, #0]
34196a1e:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
34196a22:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34196a24:	68fb      	ldr	r3, [r7, #12]
34196a26:	68db      	ldr	r3, [r3, #12]
34196a28:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34196a2c:	d104      	bne.n	34196a38 <HAL_XSPI_AutoPolling+0xa8>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
34196a2e:	68fb      	ldr	r3, [r7, #12]
34196a30:	681b      	ldr	r3, [r3, #0]
34196a32:	697a      	ldr	r2, [r7, #20]
34196a34:	649a      	str	r2, [r3, #72]	@ 0x48
34196a36:	e011      	b.n	34196a5c <HAL_XSPI_AutoPolling+0xcc>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34196a38:	68fb      	ldr	r3, [r7, #12]
34196a3a:	681b      	ldr	r3, [r3, #0]
34196a3c:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34196a40:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
34196a44:	2b00      	cmp	r3, #0
34196a46:	d004      	beq.n	34196a52 <HAL_XSPI_AutoPolling+0xc2>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34196a48:	68fb      	ldr	r3, [r7, #12]
34196a4a:	681b      	ldr	r3, [r3, #0]
34196a4c:	697a      	ldr	r2, [r7, #20]
34196a4e:	649a      	str	r2, [r3, #72]	@ 0x48
34196a50:	e004      	b.n	34196a5c <HAL_XSPI_AutoPolling+0xcc>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
34196a52:	68fb      	ldr	r3, [r7, #12]
34196a54:	681b      	ldr	r3, [r3, #0]
34196a56:	693a      	ldr	r2, [r7, #16]
34196a58:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
34196a5c:	687b      	ldr	r3, [r7, #4]
34196a5e:	9300      	str	r3, [sp, #0]
34196a60:	69bb      	ldr	r3, [r7, #24]
34196a62:	2201      	movs	r2, #1
34196a64:	2108      	movs	r1, #8
34196a66:	68f8      	ldr	r0, [r7, #12]
34196a68:	f000 fa72 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
34196a6c:	4603      	mov	r3, r0
34196a6e:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
34196a70:	7ffb      	ldrb	r3, [r7, #31]
34196a72:	2b00      	cmp	r3, #0
34196a74:	d110      	bne.n	34196a98 <HAL_XSPI_AutoPolling+0x108>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
34196a76:	68fb      	ldr	r3, [r7, #12]
34196a78:	681b      	ldr	r3, [r3, #0]
34196a7a:	2208      	movs	r2, #8
34196a7c:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
34196a7e:	68fb      	ldr	r3, [r7, #12]
34196a80:	2202      	movs	r2, #2
34196a82:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34196a84:	e008      	b.n	34196a98 <HAL_XSPI_AutoPolling+0x108>
      }
    }
    else
    {
      status = HAL_BUSY;
34196a86:	2302      	movs	r3, #2
34196a88:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
34196a8a:	e005      	b.n	34196a98 <HAL_XSPI_AutoPolling+0x108>
    }
  }
  else
  {
    status = HAL_ERROR;
34196a8c:	2301      	movs	r3, #1
34196a8e:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34196a90:	68fb      	ldr	r3, [r7, #12]
34196a92:	2210      	movs	r2, #16
34196a94:	65da      	str	r2, [r3, #92]	@ 0x5c
34196a96:	e000      	b.n	34196a9a <HAL_XSPI_AutoPolling+0x10a>
    if (status == HAL_OK)
34196a98:	bf00      	nop
  }

  return status;
34196a9a:	7ffb      	ldrb	r3, [r7, #31]
}
34196a9c:	4618      	mov	r0, r3
34196a9e:	3720      	adds	r7, #32
34196aa0:	46bd      	mov	sp, r7
34196aa2:	bd80      	pop	{r7, pc}

34196aa4 <HAL_XSPI_MemoryMapped>:
  * @param  pCfg   : Pointer to structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_MemoryMapped(XSPI_HandleTypeDef *hxspi, const XSPI_MemoryMappedTypeDef *pCfg)
{
34196aa4:	b580      	push	{r7, lr}
34196aa6:	b086      	sub	sp, #24
34196aa8:	af02      	add	r7, sp, #8
34196aaa:	6078      	str	r0, [r7, #4]
34196aac:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34196aae:	f7ef fd2f 	bl	34186510 <HAL_GetTick>
34196ab2:	60b8      	str	r0, [r7, #8]
  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));

  /* Check the state */
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
34196ab4:	687b      	ldr	r3, [r7, #4]
34196ab6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196ab8:	2b04      	cmp	r3, #4
34196aba:	d155      	bne.n	34196b68 <HAL_XSPI_MemoryMapped+0xc4>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34196abc:	687b      	ldr	r3, [r7, #4]
34196abe:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34196ac0:	9300      	str	r3, [sp, #0]
34196ac2:	68bb      	ldr	r3, [r7, #8]
34196ac4:	2200      	movs	r2, #0
34196ac6:	2120      	movs	r1, #32
34196ac8:	6878      	ldr	r0, [r7, #4]
34196aca:	f000 fa41 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
34196ace:	4603      	mov	r3, r0
34196ad0:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
34196ad2:	7bfb      	ldrb	r3, [r7, #15]
34196ad4:	2b00      	cmp	r3, #0
34196ad6:	d14c      	bne.n	34196b72 <HAL_XSPI_MemoryMapped+0xce>
    {
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
34196ad8:	687b      	ldr	r3, [r7, #4]
34196ada:	2288      	movs	r2, #136	@ 0x88
34196adc:	659a      	str	r2, [r3, #88]	@ 0x58

      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
34196ade:	683b      	ldr	r3, [r7, #0]
34196ae0:	689b      	ldr	r3, [r3, #8]
34196ae2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34196ae6:	d10b      	bne.n	34196b00 <HAL_XSPI_MemoryMapped+0x5c>
      {
        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34196ae8:	687b      	ldr	r3, [r7, #4]
34196aea:	681b      	ldr	r3, [r3, #0]
34196aec:	681b      	ldr	r3, [r3, #0]
34196aee:	f023 7100 	bic.w	r1, r3, #33554432	@ 0x2000000
34196af2:	683b      	ldr	r3, [r7, #0]
34196af4:	689a      	ldr	r2, [r3, #8]
34196af6:	687b      	ldr	r3, [r7, #4]
34196af8:	681b      	ldr	r3, [r3, #0]
34196afa:	430a      	orrs	r2, r1
34196afc:	601a      	str	r2, [r3, #0]
34196afe:	e00d      	b.n	34196b1c <HAL_XSPI_MemoryMapped+0x78>
      else
      {
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));

        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
34196b00:	687b      	ldr	r3, [r7, #4]
34196b02:	681b      	ldr	r3, [r3, #0]
34196b04:	681b      	ldr	r3, [r3, #0]
34196b06:	f023 61c0 	bic.w	r1, r3, #100663296	@ 0x6000000
34196b0a:	683b      	ldr	r3, [r7, #0]
34196b0c:	689a      	ldr	r2, [r3, #8]
34196b0e:	683b      	ldr	r3, [r7, #0]
34196b10:	68db      	ldr	r3, [r3, #12]
34196b12:	431a      	orrs	r2, r3
34196b14:	687b      	ldr	r3, [r7, #4]
34196b16:	681b      	ldr	r3, [r3, #0]
34196b18:	430a      	orrs	r2, r1
34196b1a:	601a      	str	r2, [r3, #0]
                   (pCfg->NoPrefetchData | pCfg->NoPrefetchAXI));
      }
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
34196b1c:	683b      	ldr	r3, [r7, #0]
34196b1e:	681b      	ldr	r3, [r3, #0]
34196b20:	2b08      	cmp	r3, #8
34196b22:	d111      	bne.n	34196b48 <HAL_XSPI_MemoryMapped+0xa4>
      {
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));

        /* Configure register */
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34196b24:	687b      	ldr	r3, [r7, #4]
34196b26:	681b      	ldr	r3, [r3, #0]
34196b28:	683a      	ldr	r2, [r7, #0]
34196b2a:	6852      	ldr	r2, [r2, #4]
34196b2c:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

        /* Clear flags related to interrupt */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
34196b30:	687b      	ldr	r3, [r7, #4]
34196b32:	681b      	ldr	r3, [r3, #0]
34196b34:	2210      	movs	r2, #16
34196b36:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enable the timeout interrupt */
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34196b38:	687b      	ldr	r3, [r7, #4]
34196b3a:	681b      	ldr	r3, [r3, #0]
34196b3c:	681a      	ldr	r2, [r3, #0]
34196b3e:	687b      	ldr	r3, [r7, #4]
34196b40:	681b      	ldr	r3, [r3, #0]
34196b42:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
34196b46:	601a      	str	r2, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
34196b48:	687b      	ldr	r3, [r7, #4]
34196b4a:	681b      	ldr	r3, [r3, #0]
34196b4c:	681b      	ldr	r3, [r3, #0]
34196b4e:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
34196b52:	f023 0308 	bic.w	r3, r3, #8
34196b56:	683a      	ldr	r2, [r7, #0]
34196b58:	6812      	ldr	r2, [r2, #0]
34196b5a:	431a      	orrs	r2, r3
34196b5c:	687b      	ldr	r3, [r7, #4]
34196b5e:	681b      	ldr	r3, [r3, #0]
34196b60:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
34196b64:	601a      	str	r2, [r3, #0]
34196b66:	e004      	b.n	34196b72 <HAL_XSPI_MemoryMapped+0xce>
                 (pCfg->TimeOutActivation | XSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
34196b68:	2301      	movs	r3, #1
34196b6a:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34196b6c:	687b      	ldr	r3, [r7, #4]
34196b6e:	2210      	movs	r2, #16
34196b70:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34196b72:	7bfb      	ldrb	r3, [r7, #15]
}
34196b74:	4618      	mov	r0, r3
34196b76:	3710      	adds	r7, #16
34196b78:	46bd      	mov	sp, r7
34196b7a:	bd80      	pop	{r7, pc}

34196b7c <HAL_XSPI_Abort>:
  * @brief  Abort the current operation, return to the indirect mode.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Abort(XSPI_HandleTypeDef *hxspi)
{
34196b7c:	b580      	push	{r7, lr}
34196b7e:	b086      	sub	sp, #24
34196b80:	af02      	add	r7, sp, #8
34196b82:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34196b84:	2300      	movs	r3, #0
34196b86:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34196b88:	f7ef fcc2 	bl	34186510 <HAL_GetTick>
34196b8c:	60b8      	str	r0, [r7, #8]

  /* Check if the state is not in reset state */
  if (hxspi->State != HAL_XSPI_STATE_RESET)
34196b8e:	687b      	ldr	r3, [r7, #4]
34196b90:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196b92:	2b00      	cmp	r3, #0
34196b94:	d06f      	beq.n	34196c76 <HAL_XSPI_Abort+0xfa>
  {
    /* Check if the DMA is enabled */
    if ((hxspi->Instance->CR & XSPI_CR_DMAEN) != 0U)
34196b96:	687b      	ldr	r3, [r7, #4]
34196b98:	681b      	ldr	r3, [r3, #0]
34196b9a:	681b      	ldr	r3, [r3, #0]
34196b9c:	f003 0304 	and.w	r3, r3, #4
34196ba0:	2b00      	cmp	r3, #0
34196ba2:	d021      	beq.n	34196be8 <HAL_XSPI_Abort+0x6c>
    {
      /* Disable the DMA transfer on the XSPI side */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_DMAEN);
34196ba4:	687b      	ldr	r3, [r7, #4]
34196ba6:	681b      	ldr	r3, [r3, #0]
34196ba8:	681a      	ldr	r2, [r3, #0]
34196baa:	687b      	ldr	r3, [r7, #4]
34196bac:	681b      	ldr	r3, [r3, #0]
34196bae:	f022 0204 	bic.w	r2, r2, #4
34196bb2:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transmit on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmatx);
34196bb4:	687b      	ldr	r3, [r7, #4]
34196bb6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
34196bb8:	4618      	mov	r0, r3
34196bba:	f7f2 ff6f 	bl	34189a9c <HAL_DMA_Abort>
34196bbe:	4603      	mov	r3, r0
34196bc0:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
34196bc2:	7bfb      	ldrb	r3, [r7, #15]
34196bc4:	2b00      	cmp	r3, #0
34196bc6:	d002      	beq.n	34196bce <HAL_XSPI_Abort+0x52>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
34196bc8:	687b      	ldr	r3, [r7, #4]
34196bca:	2204      	movs	r2, #4
34196bcc:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Disable the DMA receive on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmarx);
34196bce:	687b      	ldr	r3, [r7, #4]
34196bd0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34196bd2:	4618      	mov	r0, r3
34196bd4:	f7f2 ff62 	bl	34189a9c <HAL_DMA_Abort>
34196bd8:	4603      	mov	r3, r0
34196bda:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
34196bdc:	7bfb      	ldrb	r3, [r7, #15]
34196bde:	2b00      	cmp	r3, #0
34196be0:	d002      	beq.n	34196be8 <HAL_XSPI_Abort+0x6c>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
34196be2:	687b      	ldr	r3, [r7, #4]
34196be4:	2204      	movs	r2, #4
34196be6:	65da      	str	r2, [r3, #92]	@ 0x5c
      }
    }

    if (HAL_XSPI_GET_FLAG(hxspi, HAL_XSPI_FLAG_BUSY) != RESET)
34196be8:	687b      	ldr	r3, [r7, #4]
34196bea:	681b      	ldr	r3, [r3, #0]
34196bec:	6a1b      	ldr	r3, [r3, #32]
34196bee:	f003 0320 	and.w	r3, r3, #32
34196bf2:	2b00      	cmp	r3, #0
34196bf4:	d033      	beq.n	34196c5e <HAL_XSPI_Abort+0xe2>
    {
      /* Perform an abort of the XSPI */
      SET_BIT(hxspi->Instance->CR, XSPI_CR_ABORT);
34196bf6:	687b      	ldr	r3, [r7, #4]
34196bf8:	681b      	ldr	r3, [r3, #0]
34196bfa:	681a      	ldr	r2, [r3, #0]
34196bfc:	687b      	ldr	r3, [r7, #4]
34196bfe:	681b      	ldr	r3, [r3, #0]
34196c00:	f042 0202 	orr.w	r2, r2, #2
34196c04:	601a      	str	r2, [r3, #0]

      /* Wait until the transfer complete flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, hxspi->Timeout);
34196c06:	687b      	ldr	r3, [r7, #4]
34196c08:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34196c0a:	9300      	str	r3, [sp, #0]
34196c0c:	68bb      	ldr	r3, [r7, #8]
34196c0e:	2201      	movs	r2, #1
34196c10:	2102      	movs	r1, #2
34196c12:	6878      	ldr	r0, [r7, #4]
34196c14:	f000 f99c 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
34196c18:	4603      	mov	r3, r0
34196c1a:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
34196c1c:	7bfb      	ldrb	r3, [r7, #15]
34196c1e:	2b00      	cmp	r3, #0
34196c20:	d12e      	bne.n	34196c80 <HAL_XSPI_Abort+0x104>
      {
        /* Clear transfer complete flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34196c22:	687b      	ldr	r3, [r7, #4]
34196c24:	681b      	ldr	r3, [r3, #0]
34196c26:	2202      	movs	r2, #2
34196c28:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Wait until the busy flag is reset to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34196c2a:	687b      	ldr	r3, [r7, #4]
34196c2c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34196c2e:	9300      	str	r3, [sp, #0]
34196c30:	68bb      	ldr	r3, [r7, #8]
34196c32:	2200      	movs	r2, #0
34196c34:	2120      	movs	r1, #32
34196c36:	6878      	ldr	r0, [r7, #4]
34196c38:	f000 f98a 	bl	34196f50 <XSPI_WaitFlagStateUntilTimeout>
34196c3c:	4603      	mov	r3, r0
34196c3e:	73fb      	strb	r3, [r7, #15]

        if (status == HAL_OK)
34196c40:	7bfb      	ldrb	r3, [r7, #15]
34196c42:	2b00      	cmp	r3, #0
34196c44:	d11c      	bne.n	34196c80 <HAL_XSPI_Abort+0x104>
        {
          /* Return to indirect mode */
          CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
34196c46:	687b      	ldr	r3, [r7, #4]
34196c48:	681b      	ldr	r3, [r3, #0]
34196c4a:	681a      	ldr	r2, [r3, #0]
34196c4c:	687b      	ldr	r3, [r7, #4]
34196c4e:	681b      	ldr	r3, [r3, #0]
34196c50:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34196c54:	601a      	str	r2, [r3, #0]

          hxspi->State = HAL_XSPI_STATE_READY;
34196c56:	687b      	ldr	r3, [r7, #4]
34196c58:	2202      	movs	r2, #2
34196c5a:	659a      	str	r2, [r3, #88]	@ 0x58
34196c5c:	e010      	b.n	34196c80 <HAL_XSPI_Abort+0x104>
      }
    }
    else
    {
      /* Return to indirect mode */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
34196c5e:	687b      	ldr	r3, [r7, #4]
34196c60:	681b      	ldr	r3, [r3, #0]
34196c62:	681a      	ldr	r2, [r3, #0]
34196c64:	687b      	ldr	r3, [r7, #4]
34196c66:	681b      	ldr	r3, [r3, #0]
34196c68:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34196c6c:	601a      	str	r2, [r3, #0]

      hxspi->State = HAL_XSPI_STATE_READY;
34196c6e:	687b      	ldr	r3, [r7, #4]
34196c70:	2202      	movs	r2, #2
34196c72:	659a      	str	r2, [r3, #88]	@ 0x58
34196c74:	e004      	b.n	34196c80 <HAL_XSPI_Abort+0x104>
    }
  }
  else
  {
    status = HAL_ERROR;
34196c76:	2301      	movs	r3, #1
34196c78:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34196c7a:	687b      	ldr	r3, [r7, #4]
34196c7c:	2210      	movs	r2, #16
34196c7e:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34196c80:	7bfb      	ldrb	r3, [r7, #15]
}
34196c82:	4618      	mov	r0, r3
34196c84:	3710      	adds	r7, #16
34196c86:	46bd      	mov	sp, r7
34196c88:	bd80      	pop	{r7, pc}

34196c8a <HAL_XSPI_SetClockPrescaler>:
  * @param  hxspi     : XSPI handle.
  * @param  Prescaler : Clock prescaler.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_SetClockPrescaler(XSPI_HandleTypeDef *hxspi, uint32_t Prescaler)
{
34196c8a:	b480      	push	{r7}
34196c8c:	b085      	sub	sp, #20
34196c8e:	af00      	add	r7, sp, #0
34196c90:	6078      	str	r0, [r7, #4]
34196c92:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34196c94:	2300      	movs	r3, #0
34196c96:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));

  /* Check the state */
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
34196c98:	687b      	ldr	r3, [r7, #4]
34196c9a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34196c9c:	f003 0308 	and.w	r3, r3, #8
34196ca0:	2b00      	cmp	r3, #0
34196ca2:	d10e      	bne.n	34196cc2 <HAL_XSPI_SetClockPrescaler+0x38>
  {
    /* Synchronize initialization structure with the new clock prescaler value */
    hxspi->Init.ClockPrescaler = Prescaler;
34196ca4:	687b      	ldr	r3, [r7, #4]
34196ca6:	683a      	ldr	r2, [r7, #0]
34196ca8:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Configure clock prescaler */
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
34196caa:	687b      	ldr	r3, [r7, #4]
34196cac:	681b      	ldr	r3, [r3, #0]
34196cae:	68db      	ldr	r3, [r3, #12]
34196cb0:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34196cb4:	687b      	ldr	r3, [r7, #4]
34196cb6:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34196cb8:	687b      	ldr	r3, [r7, #4]
34196cba:	681b      	ldr	r3, [r3, #0]
34196cbc:	430a      	orrs	r2, r1
34196cbe:	60da      	str	r2, [r3, #12]
34196cc0:	e004      	b.n	34196ccc <HAL_XSPI_SetClockPrescaler+0x42>
               ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));
  }
  else
  {
    status = HAL_ERROR;
34196cc2:	2301      	movs	r3, #1
34196cc4:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34196cc6:	687b      	ldr	r3, [r7, #4]
34196cc8:	2210      	movs	r2, #16
34196cca:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34196ccc:	7bfb      	ldrb	r3, [r7, #15]
}
34196cce:	4618      	mov	r0, r3
34196cd0:	3714      	adds	r7, #20
34196cd2:	46bd      	mov	sp, r7
34196cd4:	f85d 7b04 	ldr.w	r7, [sp], #4
34196cd8:	4770      	bx	lr

34196cda <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
34196cda:	b480      	push	{r7}
34196cdc:	b083      	sub	sp, #12
34196cde:	af00      	add	r7, sp, #0
34196ce0:	6078      	str	r0, [r7, #4]
34196ce2:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
34196ce4:	687b      	ldr	r3, [r7, #4]
34196ce6:	683a      	ldr	r2, [r7, #0]
34196ce8:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
34196cea:	2300      	movs	r3, #0
}
34196cec:	4618      	mov	r0, r3
34196cee:	370c      	adds	r7, #12
34196cf0:	46bd      	mov	sp, r7
34196cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
34196cf6:	4770      	bx	lr

34196cf8 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *hxspi, const XSPIM_CfgTypeDef *pCfg, uint32_t Timeout)
{
34196cf8:	b580      	push	{r7, lr}
34196cfa:	b08e      	sub	sp, #56	@ 0x38
34196cfc:	af00      	add	r7, sp, #0
34196cfe:	60f8      	str	r0, [r7, #12]
34196d00:	60b9      	str	r1, [r7, #8]
34196d02:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34196d04:	2300      	movs	r3, #0
34196d06:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
  uint8_t index;
  uint8_t xspi_enabled = 0U;
34196d0a:	2300      	movs	r3, #0
34196d0c:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
34196d10:	f107 0310 	add.w	r3, r7, #16
34196d14:	2224      	movs	r2, #36	@ 0x24
34196d16:	2100      	movs	r1, #0
34196d18:	4618      	mov	r0, r3
34196d1a:	f00e fbe9 	bl	341a54f0 <memset>
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34196d1e:	2300      	movs	r3, #0
34196d20:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34196d24:	e014      	b.n	34196d50 <HAL_XSPIM_Config+0x58>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
34196d26:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196d2a:	3301      	adds	r3, #1
34196d2c:	b2d8      	uxtb	r0, r3
34196d2e:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34196d32:	f107 0110 	add.w	r1, r7, #16
34196d36:	4613      	mov	r3, r2
34196d38:	005b      	lsls	r3, r3, #1
34196d3a:	4413      	add	r3, r2
34196d3c:	009b      	lsls	r3, r3, #2
34196d3e:	440b      	add	r3, r1
34196d40:	4619      	mov	r1, r3
34196d42:	f000 fad9 	bl	341972f8 <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34196d46:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196d4a:	3301      	adds	r3, #1
34196d4c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34196d50:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196d54:	2b02      	cmp	r3, #2
34196d56:	d9e6      	bls.n	34196d26 <HAL_XSPIM_Config+0x2e>
  }

  /********** Disable all XSPI to configure XSPI IO Manager **********/
  if (__HAL_RCC_XSPI1_IS_CLK_ENABLED() != 0U)
34196d58:	2020      	movs	r0, #32
34196d5a:	f7ff fb4b 	bl	341963f4 <LL_AHB5_GRP1_IsEnabledClock>
34196d5e:	4603      	mov	r3, r0
34196d60:	2b00      	cmp	r3, #0
34196d62:	d011      	beq.n	34196d88 <HAL_XSPIM_Config+0x90>
  {
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
34196d64:	4b76      	ldr	r3, [pc, #472]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196d66:	681b      	ldr	r3, [r3, #0]
34196d68:	f003 0301 	and.w	r3, r3, #1
34196d6c:	2b00      	cmp	r3, #0
34196d6e:	d00b      	beq.n	34196d88 <HAL_XSPIM_Config+0x90>
    {
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
34196d70:	4b73      	ldr	r3, [pc, #460]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196d72:	681b      	ldr	r3, [r3, #0]
34196d74:	4a72      	ldr	r2, [pc, #456]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196d76:	f023 0301 	bic.w	r3, r3, #1
34196d7a:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x1U;
34196d7c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34196d80:	f043 0301 	orr.w	r3, r3, #1
34196d84:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI2_IS_CLK_ENABLED() != 0U)
34196d88:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34196d8c:	f7ff fb32 	bl	341963f4 <LL_AHB5_GRP1_IsEnabledClock>
34196d90:	4603      	mov	r3, r0
34196d92:	2b00      	cmp	r3, #0
34196d94:	d011      	beq.n	34196dba <HAL_XSPIM_Config+0xc2>
  {
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
34196d96:	4b6b      	ldr	r3, [pc, #428]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196d98:	681b      	ldr	r3, [r3, #0]
34196d9a:	f003 0301 	and.w	r3, r3, #1
34196d9e:	2b00      	cmp	r3, #0
34196da0:	d00b      	beq.n	34196dba <HAL_XSPIM_Config+0xc2>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34196da2:	4b68      	ldr	r3, [pc, #416]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196da4:	681b      	ldr	r3, [r3, #0]
34196da6:	4a67      	ldr	r2, [pc, #412]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196da8:	f023 0301 	bic.w	r3, r3, #1
34196dac:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x2U;
34196dae:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34196db2:	f043 0302 	orr.w	r3, r3, #2
34196db6:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI3_IS_CLK_ENABLED() != 0U)
34196dba:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
34196dbe:	f7ff fb19 	bl	341963f4 <LL_AHB5_GRP1_IsEnabledClock>
34196dc2:	4603      	mov	r3, r0
34196dc4:	2b00      	cmp	r3, #0
34196dc6:	d011      	beq.n	34196dec <HAL_XSPIM_Config+0xf4>
  {
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
34196dc8:	4b5f      	ldr	r3, [pc, #380]	@ (34196f48 <HAL_XSPIM_Config+0x250>)
34196dca:	681b      	ldr	r3, [r3, #0]
34196dcc:	f003 0301 	and.w	r3, r3, #1
34196dd0:	2b00      	cmp	r3, #0
34196dd2:	d00b      	beq.n	34196dec <HAL_XSPIM_Config+0xf4>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34196dd4:	4b5b      	ldr	r3, [pc, #364]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196dd6:	681b      	ldr	r3, [r3, #0]
34196dd8:	4a5a      	ldr	r2, [pc, #360]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196dda:	f023 0301 	bic.w	r3, r3, #1
34196dde:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x4U;
34196de0:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34196de4:	f043 0304 	orr.w	r3, r3, #4
34196de8:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
34196dec:	4b57      	ldr	r3, [pc, #348]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196dee:	2200      	movs	r2, #0
34196df0:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
34196df2:	4b56      	ldr	r3, [pc, #344]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196df4:	681b      	ldr	r3, [r3, #0]
34196df6:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
34196dfa:	68bb      	ldr	r3, [r7, #8]
34196dfc:	689b      	ldr	r3, [r3, #8]
34196dfe:	3b01      	subs	r3, #1
34196e00:	041b      	lsls	r3, r3, #16
34196e02:	4952      	ldr	r1, [pc, #328]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196e04:	4313      	orrs	r3, r2
34196e06:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
34196e08:	68fb      	ldr	r3, [r7, #12]
34196e0a:	681b      	ldr	r3, [r3, #0]
34196e0c:	4a4c      	ldr	r2, [pc, #304]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196e0e:	4293      	cmp	r3, r2
34196e10:	d110      	bne.n	34196e34 <HAL_XSPIM_Config+0x13c>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
34196e12:	68bb      	ldr	r3, [r7, #8]
34196e14:	685b      	ldr	r3, [r3, #4]
34196e16:	617b      	str	r3, [r7, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34196e18:	68bb      	ldr	r3, [r7, #8]
34196e1a:	681b      	ldr	r3, [r3, #0]
34196e1c:	2b00      	cmp	r3, #0
34196e1e:	d03e      	beq.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34196e20:	4b4a      	ldr	r3, [pc, #296]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196e22:	681b      	ldr	r3, [r3, #0]
34196e24:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34196e28:	68bb      	ldr	r3, [r7, #8]
34196e2a:	681b      	ldr	r3, [r3, #0]
34196e2c:	4947      	ldr	r1, [pc, #284]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196e2e:	4313      	orrs	r3, r2
34196e30:	600b      	str	r3, [r1, #0]
34196e32:	e034      	b.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
34196e34:	68fb      	ldr	r3, [r7, #12]
34196e36:	681b      	ldr	r3, [r3, #0]
34196e38:	4a42      	ldr	r2, [pc, #264]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196e3a:	4293      	cmp	r3, r2
34196e3c:	d110      	bne.n	34196e60 <HAL_XSPIM_Config+0x168>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
34196e3e:	68bb      	ldr	r3, [r7, #8]
34196e40:	685b      	ldr	r3, [r3, #4]
34196e42:	623b      	str	r3, [r7, #32]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34196e44:	68bb      	ldr	r3, [r7, #8]
34196e46:	681b      	ldr	r3, [r3, #0]
34196e48:	2b00      	cmp	r3, #0
34196e4a:	d028      	beq.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34196e4c:	4b3f      	ldr	r3, [pc, #252]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196e4e:	681b      	ldr	r3, [r3, #0]
34196e50:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
34196e54:	68bb      	ldr	r3, [r7, #8]
34196e56:	681b      	ldr	r3, [r3, #0]
34196e58:	493c      	ldr	r1, [pc, #240]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196e5a:	4313      	orrs	r3, r2
34196e5c:	600b      	str	r3, [r1, #0]
34196e5e:	e01e      	b.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI3)
34196e60:	68fb      	ldr	r3, [r7, #12]
34196e62:	681b      	ldr	r3, [r3, #0]
34196e64:	4a38      	ldr	r2, [pc, #224]	@ (34196f48 <HAL_XSPIM_Config+0x250>)
34196e66:	4293      	cmp	r3, r2
34196e68:	d111      	bne.n	34196e8e <HAL_XSPIM_Config+0x196>
  {
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
34196e6a:	68bb      	ldr	r3, [r7, #8]
34196e6c:	685b      	ldr	r3, [r3, #4]
34196e6e:	2b00      	cmp	r3, #0
34196e70:	d104      	bne.n	34196e7c <HAL_XSPIM_Config+0x184>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
34196e72:	2301      	movs	r3, #1
34196e74:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
34196e76:	2301      	movs	r3, #1
34196e78:	623b      	str	r3, [r7, #32]
34196e7a:	e010      	b.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    }
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
34196e7c:	68bb      	ldr	r3, [r7, #8]
34196e7e:	685b      	ldr	r3, [r3, #4]
34196e80:	2b01      	cmp	r3, #1
34196e82:	d10c      	bne.n	34196e9e <HAL_XSPIM_Config+0x1a6>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
34196e84:	2300      	movs	r3, #0
34196e86:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
34196e88:	2300      	movs	r3, #0
34196e8a:	623b      	str	r3, [r7, #32]
34196e8c:	e007      	b.n	34196e9e <HAL_XSPIM_Config+0x1a6>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
34196e8e:	68fb      	ldr	r3, [r7, #12]
34196e90:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34196e92:	f043 0208 	orr.w	r2, r3, #8
34196e96:	68fb      	ldr	r3, [r7, #12]
34196e98:	65da      	str	r2, [r3, #92]	@ 0x5c
    return HAL_ERROR;
34196e9a:	2301      	movs	r3, #1
34196e9c:	e04c      	b.n	34196f38 <HAL_XSPIM_Config+0x240>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34196e9e:	2300      	movs	r3, #0
34196ea0:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34196ea4:	e02a      	b.n	34196efc <HAL_XSPIM_Config+0x204>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
34196ea6:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34196eaa:	4613      	mov	r3, r2
34196eac:	005b      	lsls	r3, r3, #1
34196eae:	4413      	add	r3, r2
34196eb0:	009b      	lsls	r3, r3, #2
34196eb2:	3338      	adds	r3, #56	@ 0x38
34196eb4:	443b      	add	r3, r7
34196eb6:	3b24      	subs	r3, #36	@ 0x24
34196eb8:	6819      	ldr	r1, [r3, #0]
34196eba:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196ebe:	1c5a      	adds	r2, r3, #1
34196ec0:	4613      	mov	r3, r2
34196ec2:	005b      	lsls	r3, r3, #1
34196ec4:	4413      	add	r3, r2
34196ec6:	009b      	lsls	r3, r3, #2
34196ec8:	3338      	adds	r3, #56	@ 0x38
34196eca:	443b      	add	r3, r7
34196ecc:	3b24      	subs	r3, #36	@ 0x24
34196ece:	681b      	ldr	r3, [r3, #0]
34196ed0:	4299      	cmp	r1, r3
34196ed2:	d105      	bne.n	34196ee0 <HAL_XSPIM_Config+0x1e8>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
34196ed4:	4b1d      	ldr	r3, [pc, #116]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196ed6:	681b      	ldr	r3, [r3, #0]
34196ed8:	4a1c      	ldr	r2, [pc, #112]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196eda:	f043 0301 	orr.w	r3, r3, #1
34196ede:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
34196ee0:	697b      	ldr	r3, [r7, #20]
34196ee2:	2b01      	cmp	r3, #1
34196ee4:	d105      	bne.n	34196ef2 <HAL_XSPIM_Config+0x1fa>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
34196ee6:	4b19      	ldr	r3, [pc, #100]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196ee8:	681b      	ldr	r3, [r3, #0]
34196eea:	4a18      	ldr	r2, [pc, #96]	@ (34196f4c <HAL_XSPIM_Config+0x254>)
34196eec:	f043 0302 	orr.w	r3, r3, #2
34196ef0:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34196ef2:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196ef6:	3301      	adds	r3, #1
34196ef8:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34196efc:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34196f00:	2b00      	cmp	r3, #0
34196f02:	d0d0      	beq.n	34196ea6 <HAL_XSPIM_Config+0x1ae>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
34196f04:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34196f08:	f003 0301 	and.w	r3, r3, #1
34196f0c:	2b00      	cmp	r3, #0
34196f0e:	d005      	beq.n	34196f1c <HAL_XSPIM_Config+0x224>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
34196f10:	4b0b      	ldr	r3, [pc, #44]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196f12:	681b      	ldr	r3, [r3, #0]
34196f14:	4a0a      	ldr	r2, [pc, #40]	@ (34196f40 <HAL_XSPIM_Config+0x248>)
34196f16:	f043 0301 	orr.w	r3, r3, #1
34196f1a:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
34196f1c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34196f20:	f003 0302 	and.w	r3, r3, #2
34196f24:	2b00      	cmp	r3, #0
34196f26:	d005      	beq.n	34196f34 <HAL_XSPIM_Config+0x23c>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
34196f28:	4b06      	ldr	r3, [pc, #24]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196f2a:	681b      	ldr	r3, [r3, #0]
34196f2c:	4a05      	ldr	r2, [pc, #20]	@ (34196f44 <HAL_XSPIM_Config+0x24c>)
34196f2e:	f043 0301 	orr.w	r3, r3, #1
34196f32:	6013      	str	r3, [r2, #0]
  }

  return status;
34196f34:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
}
34196f38:	4618      	mov	r0, r3
34196f3a:	3738      	adds	r7, #56	@ 0x38
34196f3c:	46bd      	mov	sp, r7
34196f3e:	bd80      	pop	{r7, pc}
34196f40:	58025000 	.word	0x58025000
34196f44:	5802a000 	.word	0x5802a000
34196f48:	5802d000 	.word	0x5802d000
34196f4c:	5802b400 	.word	0x5802b400

34196f50 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34196f50:	b580      	push	{r7, lr}
34196f52:	b084      	sub	sp, #16
34196f54:	af00      	add	r7, sp, #0
34196f56:	60f8      	str	r0, [r7, #12]
34196f58:	60b9      	str	r1, [r7, #8]
34196f5a:	603b      	str	r3, [r7, #0]
34196f5c:	4613      	mov	r3, r2
34196f5e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34196f60:	e019      	b.n	34196f96 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34196f62:	69bb      	ldr	r3, [r7, #24]
34196f64:	f1b3 3fff 	cmp.w	r3, #4294967295
34196f68:	d015      	beq.n	34196f96 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34196f6a:	f7ef fad1 	bl	34186510 <HAL_GetTick>
34196f6e:	4602      	mov	r2, r0
34196f70:	683b      	ldr	r3, [r7, #0]
34196f72:	1ad3      	subs	r3, r2, r3
34196f74:	69ba      	ldr	r2, [r7, #24]
34196f76:	429a      	cmp	r2, r3
34196f78:	d302      	bcc.n	34196f80 <XSPI_WaitFlagStateUntilTimeout+0x30>
34196f7a:	69bb      	ldr	r3, [r7, #24]
34196f7c:	2b00      	cmp	r3, #0
34196f7e:	d10a      	bne.n	34196f96 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
34196f80:	68fb      	ldr	r3, [r7, #12]
34196f82:	2202      	movs	r2, #2
34196f84:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34196f86:	68fb      	ldr	r3, [r7, #12]
34196f88:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34196f8a:	f043 0201 	orr.w	r2, r3, #1
34196f8e:	68fb      	ldr	r3, [r7, #12]
34196f90:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
34196f92:	2303      	movs	r3, #3
34196f94:	e00e      	b.n	34196fb4 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34196f96:	68fb      	ldr	r3, [r7, #12]
34196f98:	681b      	ldr	r3, [r3, #0]
34196f9a:	6a1a      	ldr	r2, [r3, #32]
34196f9c:	68bb      	ldr	r3, [r7, #8]
34196f9e:	4013      	ands	r3, r2
34196fa0:	2b00      	cmp	r3, #0
34196fa2:	bf14      	ite	ne
34196fa4:	2301      	movne	r3, #1
34196fa6:	2300      	moveq	r3, #0
34196fa8:	b2db      	uxtb	r3, r3
34196faa:	461a      	mov	r2, r3
34196fac:	79fb      	ldrb	r3, [r7, #7]
34196fae:	429a      	cmp	r2, r3
34196fb0:	d1d7      	bne.n	34196f62 <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
34196fb2:	2300      	movs	r3, #0
}
34196fb4:	4618      	mov	r0, r3
34196fb6:	3710      	adds	r7, #16
34196fb8:	46bd      	mov	sp, r7
34196fba:	bd80      	pop	{r7, pc}

34196fbc <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd)
{
34196fbc:	b480      	push	{r7}
34196fbe:	b089      	sub	sp, #36	@ 0x24
34196fc0:	af00      	add	r7, sp, #0
34196fc2:	6078      	str	r0, [r7, #4]
34196fc4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34196fc6:	2300      	movs	r3, #0
34196fc8:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
34196fca:	687b      	ldr	r3, [r7, #4]
34196fcc:	681b      	ldr	r3, [r3, #0]
34196fce:	681a      	ldr	r2, [r3, #0]
34196fd0:	687b      	ldr	r3, [r7, #4]
34196fd2:	681b      	ldr	r3, [r3, #0]
34196fd4:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34196fd8:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34196fda:	687b      	ldr	r3, [r7, #4]
34196fdc:	689b      	ldr	r3, [r3, #8]
34196fde:	2b00      	cmp	r3, #0
34196fe0:	d10a      	bne.n	34196ff8 <XSPI_ConfigCmd+0x3c>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
34196fe2:	687b      	ldr	r3, [r7, #4]
34196fe4:	681b      	ldr	r3, [r3, #0]
34196fe6:	681b      	ldr	r3, [r3, #0]
34196fe8:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
34196fec:	683b      	ldr	r3, [r7, #0]
34196fee:	685a      	ldr	r2, [r3, #4]
34196ff0:	687b      	ldr	r3, [r7, #4]
34196ff2:	681b      	ldr	r3, [r3, #0]
34196ff4:	430a      	orrs	r2, r1
34196ff6:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34196ff8:	683b      	ldr	r3, [r7, #0]
34196ffa:	681b      	ldr	r3, [r3, #0]
34196ffc:	2b02      	cmp	r3, #2
34196ffe:	d114      	bne.n	3419702a <XSPI_ConfigCmd+0x6e>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
34197000:	687b      	ldr	r3, [r7, #4]
34197002:	681b      	ldr	r3, [r3, #0]
34197004:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
34197008:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
3419700a:	687b      	ldr	r3, [r7, #4]
3419700c:	681b      	ldr	r3, [r3, #0]
3419700e:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
34197012:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
34197014:	687b      	ldr	r3, [r7, #4]
34197016:	681b      	ldr	r3, [r3, #0]
34197018:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
3419701c:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
3419701e:	687b      	ldr	r3, [r7, #4]
34197020:	681b      	ldr	r3, [r3, #0]
34197022:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
34197026:	60fb      	str	r3, [r7, #12]
34197028:	e02c      	b.n	34197084 <XSPI_ConfigCmd+0xc8>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
3419702a:	683b      	ldr	r3, [r7, #0]
3419702c:	681b      	ldr	r3, [r3, #0]
3419702e:	2b03      	cmp	r3, #3
34197030:	d114      	bne.n	3419705c <XSPI_ConfigCmd+0xa0>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
34197032:	687b      	ldr	r3, [r7, #4]
34197034:	681b      	ldr	r3, [r3, #0]
34197036:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
3419703a:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
3419703c:	687b      	ldr	r3, [r7, #4]
3419703e:	681b      	ldr	r3, [r3, #0]
34197040:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
34197044:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
34197046:	687b      	ldr	r3, [r7, #4]
34197048:	681b      	ldr	r3, [r3, #0]
3419704a:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
3419704e:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
34197050:	687b      	ldr	r3, [r7, #4]
34197052:	681b      	ldr	r3, [r3, #0]
34197054:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34197058:	60fb      	str	r3, [r7, #12]
3419705a:	e013      	b.n	34197084 <XSPI_ConfigCmd+0xc8>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
3419705c:	687b      	ldr	r3, [r7, #4]
3419705e:	681b      	ldr	r3, [r3, #0]
34197060:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34197064:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
34197066:	687b      	ldr	r3, [r7, #4]
34197068:	681b      	ldr	r3, [r3, #0]
3419706a:	f503 7384 	add.w	r3, r3, #264	@ 0x108
3419706e:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
34197070:	687b      	ldr	r3, [r7, #4]
34197072:	681b      	ldr	r3, [r3, #0]
34197074:	f503 7388 	add.w	r3, r3, #272	@ 0x110
34197078:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
3419707a:	687b      	ldr	r3, [r7, #4]
3419707c:	681b      	ldr	r3, [r3, #0]
3419707e:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34197082:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
34197084:	683b      	ldr	r3, [r7, #0]
34197086:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34197088:	69bb      	ldr	r3, [r7, #24]
3419708a:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
3419708c:	683b      	ldr	r3, [r7, #0]
3419708e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34197090:	2b00      	cmp	r3, #0
34197092:	d012      	beq.n	341970ba <XSPI_ConfigCmd+0xfe>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
34197094:	683b      	ldr	r3, [r7, #0]
34197096:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34197098:	68fb      	ldr	r3, [r7, #12]
3419709a:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
3419709c:	69bb      	ldr	r3, [r7, #24]
3419709e:	681b      	ldr	r3, [r3, #0]
341970a0:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
341970a4:	683b      	ldr	r3, [r7, #0]
341970a6:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
341970a8:	683b      	ldr	r3, [r7, #0]
341970aa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
341970ac:	4319      	orrs	r1, r3
341970ae:	683b      	ldr	r3, [r7, #0]
341970b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
341970b2:	430b      	orrs	r3, r1
341970b4:	431a      	orrs	r2, r3
341970b6:	69bb      	ldr	r3, [r7, #24]
341970b8:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
341970ba:	697b      	ldr	r3, [r7, #20]
341970bc:	681b      	ldr	r3, [r3, #0]
341970be:	f023 021f 	bic.w	r2, r3, #31
341970c2:	683b      	ldr	r3, [r7, #0]
341970c4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
341970c6:	431a      	orrs	r2, r3
341970c8:	697b      	ldr	r3, [r7, #20]
341970ca:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
341970cc:	683b      	ldr	r3, [r7, #0]
341970ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341970d0:	2b00      	cmp	r3, #0
341970d2:	d009      	beq.n	341970e8 <XSPI_ConfigCmd+0x12c>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
341970d4:	683b      	ldr	r3, [r7, #0]
341970d6:	681b      	ldr	r3, [r3, #0]
341970d8:	2b00      	cmp	r3, #0
341970da:	d105      	bne.n	341970e8 <XSPI_ConfigCmd+0x12c>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
341970dc:	683b      	ldr	r3, [r7, #0]
341970de:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
341970e0:	687b      	ldr	r3, [r7, #4]
341970e2:	681b      	ldr	r3, [r3, #0]
341970e4:	3a01      	subs	r2, #1
341970e6:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
341970e8:	683b      	ldr	r3, [r7, #0]
341970ea:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341970ec:	2b00      	cmp	r3, #0
341970ee:	d01e      	beq.n	3419712e <XSPI_ConfigCmd+0x172>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
341970f0:	683b      	ldr	r3, [r7, #0]
341970f2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
341970f4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341970f8:	d10a      	bne.n	34197110 <XSPI_ConfigCmd+0x154>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
341970fa:	687b      	ldr	r3, [r7, #4]
341970fc:	681b      	ldr	r3, [r3, #0]
341970fe:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34197102:	687b      	ldr	r3, [r7, #4]
34197104:	681b      	ldr	r3, [r3, #0]
34197106:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
3419710a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
3419710e:	e00e      	b.n	3419712e <XSPI_ConfigCmd+0x172>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
34197110:	687b      	ldr	r3, [r7, #4]
34197112:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34197114:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34197118:	d109      	bne.n	3419712e <XSPI_ConfigCmd+0x172>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
3419711a:	687b      	ldr	r3, [r7, #4]
3419711c:	681b      	ldr	r3, [r3, #0]
3419711e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34197122:	687b      	ldr	r3, [r7, #4]
34197124:	681b      	ldr	r3, [r3, #0]
34197126:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
3419712a:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
3419712e:	683b      	ldr	r3, [r7, #0]
34197130:	68db      	ldr	r3, [r3, #12]
34197132:	2b00      	cmp	r3, #0
34197134:	f000 808f 	beq.w	34197256 <XSPI_ConfigCmd+0x29a>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34197138:	683b      	ldr	r3, [r7, #0]
3419713a:	69db      	ldr	r3, [r3, #28]
3419713c:	2b00      	cmp	r3, #0
3419713e:	d050      	beq.n	341971e2 <XSPI_ConfigCmd+0x226>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34197140:	683b      	ldr	r3, [r7, #0]
34197142:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34197144:	2b00      	cmp	r3, #0
34197146:	d01e      	beq.n	34197186 <XSPI_ConfigCmd+0x1ca>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34197148:	69bb      	ldr	r3, [r7, #24]
3419714a:	681a      	ldr	r2, [r3, #0]
3419714c:	4b69      	ldr	r3, [pc, #420]	@ (341972f4 <XSPI_ConfigCmd+0x338>)
3419714e:	4013      	ands	r3, r2
34197150:	683a      	ldr	r2, [r7, #0]
34197152:	68d1      	ldr	r1, [r2, #12]
34197154:	683a      	ldr	r2, [r7, #0]
34197156:	6952      	ldr	r2, [r2, #20]
34197158:	4311      	orrs	r1, r2
3419715a:	683a      	ldr	r2, [r7, #0]
3419715c:	6912      	ldr	r2, [r2, #16]
3419715e:	4311      	orrs	r1, r2
34197160:	683a      	ldr	r2, [r7, #0]
34197162:	69d2      	ldr	r2, [r2, #28]
34197164:	4311      	orrs	r1, r2
34197166:	683a      	ldr	r2, [r7, #0]
34197168:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3419716a:	4311      	orrs	r1, r2
3419716c:	683a      	ldr	r2, [r7, #0]
3419716e:	6a12      	ldr	r2, [r2, #32]
34197170:	4311      	orrs	r1, r2
34197172:	683a      	ldr	r2, [r7, #0]
34197174:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34197176:	4311      	orrs	r1, r2
34197178:	683a      	ldr	r2, [r7, #0]
3419717a:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3419717c:	430a      	orrs	r2, r1
3419717e:	431a      	orrs	r2, r3
34197180:	69bb      	ldr	r3, [r7, #24]
34197182:	601a      	str	r2, [r3, #0]
34197184:	e023      	b.n	341971ce <XSPI_ConfigCmd+0x212>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34197186:	69bb      	ldr	r3, [r7, #24]
34197188:	681b      	ldr	r3, [r3, #0]
3419718a:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
3419718e:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34197192:	683a      	ldr	r2, [r7, #0]
34197194:	68d1      	ldr	r1, [r2, #12]
34197196:	683a      	ldr	r2, [r7, #0]
34197198:	6952      	ldr	r2, [r2, #20]
3419719a:	4311      	orrs	r1, r2
3419719c:	683a      	ldr	r2, [r7, #0]
3419719e:	6912      	ldr	r2, [r2, #16]
341971a0:	4311      	orrs	r1, r2
341971a2:	683a      	ldr	r2, [r7, #0]
341971a4:	69d2      	ldr	r2, [r2, #28]
341971a6:	4311      	orrs	r1, r2
341971a8:	683a      	ldr	r2, [r7, #0]
341971aa:	6a52      	ldr	r2, [r2, #36]	@ 0x24
341971ac:	4311      	orrs	r1, r2
341971ae:	683a      	ldr	r2, [r7, #0]
341971b0:	6a12      	ldr	r2, [r2, #32]
341971b2:	430a      	orrs	r2, r1
341971b4:	431a      	orrs	r2, r3
341971b6:	69bb      	ldr	r3, [r7, #24]
341971b8:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* DDTR bit should be activated */
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
341971ba:	683b      	ldr	r3, [r7, #0]
341971bc:	695b      	ldr	r3, [r3, #20]
341971be:	2b08      	cmp	r3, #8
341971c0:	d105      	bne.n	341971ce <XSPI_ConfigCmd+0x212>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
341971c2:	69bb      	ldr	r3, [r7, #24]
341971c4:	681b      	ldr	r3, [r3, #0]
341971c6:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
341971ca:	69bb      	ldr	r3, [r7, #24]
341971cc:	601a      	str	r2, [r3, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
341971ce:	683b      	ldr	r3, [r7, #0]
341971d0:	689a      	ldr	r2, [r3, #8]
341971d2:	693b      	ldr	r3, [r7, #16]
341971d4:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
341971d6:	687b      	ldr	r3, [r7, #4]
341971d8:	681b      	ldr	r3, [r3, #0]
341971da:	683a      	ldr	r2, [r7, #0]
341971dc:	6992      	ldr	r2, [r2, #24]
341971de:	649a      	str	r2, [r3, #72]	@ 0x48
341971e0:	e073      	b.n	341972ca <XSPI_ConfigCmd+0x30e>
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
      }
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
341971e2:	683b      	ldr	r3, [r7, #0]
341971e4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341971e6:	2b00      	cmp	r3, #0
341971e8:	d017      	beq.n	3419721a <XSPI_ConfigCmd+0x25e>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
341971ea:	69bb      	ldr	r3, [r7, #24]
341971ec:	681b      	ldr	r3, [r3, #0]
341971ee:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
341971f2:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
341971f6:	683a      	ldr	r2, [r7, #0]
341971f8:	68d1      	ldr	r1, [r2, #12]
341971fa:	683a      	ldr	r2, [r7, #0]
341971fc:	6952      	ldr	r2, [r2, #20]
341971fe:	4311      	orrs	r1, r2
34197200:	683a      	ldr	r2, [r7, #0]
34197202:	6912      	ldr	r2, [r2, #16]
34197204:	4311      	orrs	r1, r2
34197206:	683a      	ldr	r2, [r7, #0]
34197208:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3419720a:	4311      	orrs	r1, r2
3419720c:	683a      	ldr	r2, [r7, #0]
3419720e:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34197210:	430a      	orrs	r2, r1
34197212:	431a      	orrs	r2, r3
34197214:	69bb      	ldr	r3, [r7, #24]
34197216:	601a      	str	r2, [r3, #0]
34197218:	e018      	b.n	3419724c <XSPI_ConfigCmd+0x290>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
3419721a:	69bb      	ldr	r3, [r7, #24]
3419721c:	681b      	ldr	r3, [r3, #0]
3419721e:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
34197222:	683b      	ldr	r3, [r7, #0]
34197224:	68d9      	ldr	r1, [r3, #12]
34197226:	683b      	ldr	r3, [r7, #0]
34197228:	695b      	ldr	r3, [r3, #20]
3419722a:	4319      	orrs	r1, r3
3419722c:	683b      	ldr	r3, [r7, #0]
3419722e:	691b      	ldr	r3, [r3, #16]
34197230:	430b      	orrs	r3, r1
34197232:	431a      	orrs	r2, r3
34197234:	69bb      	ldr	r3, [r7, #24]
34197236:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));

        /* DDTR bit should be activated */
        if (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE)
34197238:	683b      	ldr	r3, [r7, #0]
3419723a:	695b      	ldr	r3, [r3, #20]
3419723c:	2b08      	cmp	r3, #8
3419723e:	d105      	bne.n	3419724c <XSPI_ConfigCmd+0x290>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34197240:	69bb      	ldr	r3, [r7, #24]
34197242:	681b      	ldr	r3, [r3, #0]
34197244:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34197248:	69bb      	ldr	r3, [r7, #24]
3419724a:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
3419724c:	683b      	ldr	r3, [r7, #0]
3419724e:	689a      	ldr	r2, [r3, #8]
34197250:	693b      	ldr	r3, [r7, #16]
34197252:	601a      	str	r2, [r3, #0]
34197254:	e039      	b.n	341972ca <XSPI_ConfigCmd+0x30e>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34197256:	683b      	ldr	r3, [r7, #0]
34197258:	69db      	ldr	r3, [r3, #28]
3419725a:	2b00      	cmp	r3, #0
3419725c:	d030      	beq.n	341972c0 <XSPI_ConfigCmd+0x304>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
3419725e:	683b      	ldr	r3, [r7, #0]
34197260:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34197262:	2b00      	cmp	r3, #0
34197264:	d017      	beq.n	34197296 <XSPI_ConfigCmd+0x2da>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
34197266:	69bb      	ldr	r3, [r7, #24]
34197268:	681b      	ldr	r3, [r3, #0]
3419726a:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
3419726e:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34197272:	683a      	ldr	r2, [r7, #0]
34197274:	69d1      	ldr	r1, [r2, #28]
34197276:	683a      	ldr	r2, [r7, #0]
34197278:	6a52      	ldr	r2, [r2, #36]	@ 0x24
3419727a:	4311      	orrs	r1, r2
3419727c:	683a      	ldr	r2, [r7, #0]
3419727e:	6a12      	ldr	r2, [r2, #32]
34197280:	4311      	orrs	r1, r2
34197282:	683a      	ldr	r2, [r7, #0]
34197284:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34197286:	4311      	orrs	r1, r2
34197288:	683a      	ldr	r2, [r7, #0]
3419728a:	6c12      	ldr	r2, [r2, #64]	@ 0x40
3419728c:	430a      	orrs	r2, r1
3419728e:	431a      	orrs	r2, r3
34197290:	69bb      	ldr	r3, [r7, #24]
34197292:	601a      	str	r2, [r3, #0]
34197294:	e00e      	b.n	341972b4 <XSPI_ConfigCmd+0x2f8>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
34197296:	69bb      	ldr	r3, [r7, #24]
34197298:	681b      	ldr	r3, [r3, #0]
3419729a:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
3419729e:	683b      	ldr	r3, [r7, #0]
341972a0:	69d9      	ldr	r1, [r3, #28]
341972a2:	683b      	ldr	r3, [r7, #0]
341972a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341972a6:	4319      	orrs	r1, r3
341972a8:	683b      	ldr	r3, [r7, #0]
341972aa:	6a1b      	ldr	r3, [r3, #32]
341972ac:	430b      	orrs	r3, r1
341972ae:	431a      	orrs	r2, r3
341972b0:	69bb      	ldr	r3, [r7, #24]
341972b2:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
341972b4:	687b      	ldr	r3, [r7, #4]
341972b6:	681b      	ldr	r3, [r3, #0]
341972b8:	683a      	ldr	r2, [r7, #0]
341972ba:	6992      	ldr	r2, [r2, #24]
341972bc:	649a      	str	r2, [r3, #72]	@ 0x48
341972be:	e004      	b.n	341972ca <XSPI_ConfigCmd+0x30e>
      }
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
341972c0:	2301      	movs	r3, #1
341972c2:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
341972c4:	687b      	ldr	r3, [r7, #4]
341972c6:	2208      	movs	r2, #8
341972c8:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
341972ca:	683b      	ldr	r3, [r7, #0]
341972cc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
341972ce:	2b00      	cmp	r3, #0
341972d0:	d009      	beq.n	341972e6 <XSPI_ConfigCmd+0x32a>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
341972d2:	683b      	ldr	r3, [r7, #0]
341972d4:	681b      	ldr	r3, [r3, #0]
341972d6:	2b00      	cmp	r3, #0
341972d8:	d105      	bne.n	341972e6 <XSPI_ConfigCmd+0x32a>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
341972da:	683b      	ldr	r3, [r7, #0]
341972dc:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
341972de:	687b      	ldr	r3, [r7, #4]
341972e0:	681b      	ldr	r3, [r3, #0]
341972e2:	3a01      	subs	r2, #1
341972e4:	641a      	str	r2, [r3, #64]	@ 0x40
      /* Verify if programmed data fit with requirement of Reference Manual 28.5 chapter */
      assert_param(IS_XSPI_PROG_DATA(hxspi->Instance->DLR, (pCmd->DataLength - 1U)));
    }
  }

  return status;
341972e6:	7ffb      	ldrb	r3, [r7, #31]
}
341972e8:	4618      	mov	r0, r3
341972ea:	3724      	adds	r7, #36	@ 0x24
341972ec:	46bd      	mov	sp, r7
341972ee:	f85d 7b04 	ldr.w	r7, [sp], #4
341972f2:	4770      	bx	lr
341972f4:	f0ffc0c0 	.word	0xf0ffc0c0

341972f8 <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *pCfg)
{
341972f8:	b480      	push	{r7}
341972fa:	b085      	sub	sp, #20
341972fc:	af00      	add	r7, sp, #0
341972fe:	4603      	mov	r3, r0
34197300:	6039      	str	r1, [r7, #0]
34197302:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
34197304:	79fb      	ldrb	r3, [r7, #7]
34197306:	2b01      	cmp	r3, #1
34197308:	d124      	bne.n	34197354 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
3419730a:	4b2c      	ldr	r3, [pc, #176]	@ (341973bc <XSPIM_GetConfig+0xc4>)
3419730c:	681b      	ldr	r3, [r3, #0]
3419730e:	f003 0302 	and.w	r3, r3, #2
34197312:	2b00      	cmp	r3, #0
34197314:	d103      	bne.n	3419731e <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34197316:	683b      	ldr	r3, [r7, #0]
34197318:	2200      	movs	r2, #0
3419731a:	605a      	str	r2, [r3, #4]
3419731c:	e002      	b.n	34197324 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3419731e:	683b      	ldr	r3, [r7, #0]
34197320:	2201      	movs	r2, #1
34197322:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34197324:	4b25      	ldr	r3, [pc, #148]	@ (341973bc <XSPIM_GetConfig+0xc4>)
34197326:	681b      	ldr	r3, [r3, #0]
34197328:	f003 0310 	and.w	r3, r3, #16
3419732c:	2b10      	cmp	r3, #16
3419732e:	d003      	beq.n	34197338 <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
34197330:	683b      	ldr	r3, [r7, #0]
34197332:	2200      	movs	r2, #0
34197334:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
34197336:	e03a      	b.n	341973ae <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
34197338:	4b20      	ldr	r3, [pc, #128]	@ (341973bc <XSPIM_GetConfig+0xc4>)
3419733a:	681b      	ldr	r3, [r3, #0]
3419733c:	f003 0320 	and.w	r3, r3, #32
34197340:	2b20      	cmp	r3, #32
34197342:	d103      	bne.n	3419734c <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
34197344:	683b      	ldr	r3, [r7, #0]
34197346:	2270      	movs	r2, #112	@ 0x70
34197348:	601a      	str	r2, [r3, #0]
}
3419734a:	e030      	b.n	341973ae <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3419734c:	683b      	ldr	r3, [r7, #0]
3419734e:	2210      	movs	r2, #16
34197350:	601a      	str	r2, [r3, #0]
}
34197352:	e02c      	b.n	341973ae <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
34197354:	4b19      	ldr	r3, [pc, #100]	@ (341973bc <XSPIM_GetConfig+0xc4>)
34197356:	681b      	ldr	r3, [r3, #0]
34197358:	f003 0301 	and.w	r3, r3, #1
3419735c:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
3419735e:	4b17      	ldr	r3, [pc, #92]	@ (341973bc <XSPIM_GetConfig+0xc4>)
34197360:	681b      	ldr	r3, [r3, #0]
34197362:	085b      	lsrs	r3, r3, #1
34197364:	f003 0301 	and.w	r3, r3, #1
34197368:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
3419736a:	68fa      	ldr	r2, [r7, #12]
3419736c:	68bb      	ldr	r3, [r7, #8]
3419736e:	429a      	cmp	r2, r3
34197370:	d003      	beq.n	3419737a <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34197372:	683b      	ldr	r3, [r7, #0]
34197374:	2200      	movs	r2, #0
34197376:	605a      	str	r2, [r3, #4]
34197378:	e002      	b.n	34197380 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3419737a:	683b      	ldr	r3, [r7, #0]
3419737c:	2201      	movs	r2, #1
3419737e:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34197380:	4b0e      	ldr	r3, [pc, #56]	@ (341973bc <XSPIM_GetConfig+0xc4>)
34197382:	681b      	ldr	r3, [r3, #0]
34197384:	f003 0310 	and.w	r3, r3, #16
34197388:	2b10      	cmp	r3, #16
3419738a:	d003      	beq.n	34197394 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
3419738c:	683b      	ldr	r3, [r7, #0]
3419738e:	2200      	movs	r2, #0
34197390:	601a      	str	r2, [r3, #0]
}
34197392:	e00c      	b.n	341973ae <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
34197394:	4b09      	ldr	r3, [pc, #36]	@ (341973bc <XSPIM_GetConfig+0xc4>)
34197396:	681b      	ldr	r3, [r3, #0]
34197398:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3419739c:	2b40      	cmp	r3, #64	@ 0x40
3419739e:	d103      	bne.n	341973a8 <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
341973a0:	683b      	ldr	r3, [r7, #0]
341973a2:	2270      	movs	r2, #112	@ 0x70
341973a4:	601a      	str	r2, [r3, #0]
}
341973a6:	e002      	b.n	341973ae <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
341973a8:	683b      	ldr	r3, [r7, #0]
341973aa:	2210      	movs	r2, #16
341973ac:	601a      	str	r2, [r3, #0]
}
341973ae:	bf00      	nop
341973b0:	3714      	adds	r7, #20
341973b2:	46bd      	mov	sp, r7
341973b4:	f85d 7b04 	ldr.w	r7, [sp], #4
341973b8:	4770      	bx	lr
341973ba:	bf00      	nop
341973bc:	5802b400 	.word	0x5802b400

341973c0 <APS256XX_EnableMemoryMappedMode>:
  * @param  BurstType Type of burst used for the access
  * @retval Memory status
  */
int32_t APS256XX_EnableMemoryMappedMode(XSPI_HandleTypeDef *Ctx, uint32_t ReadLatencyCode, uint32_t WriteLatencyCode,
                                        uint32_t IOMode, uint32_t BurstType)
{
341973c0:	b580      	push	{r7, lr}
341973c2:	b09c      	sub	sp, #112	@ 0x70
341973c4:	af00      	add	r7, sp, #0
341973c6:	60f8      	str	r0, [r7, #12]
341973c8:	60b9      	str	r1, [r7, #8]
341973ca:	607a      	str	r2, [r7, #4]
341973cc:	603b      	str	r3, [r7, #0]
  XSPI_RegularCmdTypeDef   sCommand = {0};
341973ce:	f107 0324 	add.w	r3, r7, #36	@ 0x24
341973d2:	224c      	movs	r2, #76	@ 0x4c
341973d4:	2100      	movs	r1, #0
341973d6:	4618      	mov	r0, r3
341973d8:	f00e f88a 	bl	341a54f0 <memset>
  XSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
341973dc:	f107 0314 	add.w	r3, r7, #20
341973e0:	2200      	movs	r2, #0
341973e2:	601a      	str	r2, [r3, #0]
341973e4:	605a      	str	r2, [r3, #4]
341973e6:	609a      	str	r2, [r3, #8]
341973e8:	60da      	str	r2, [r3, #12]

  /* Initialize the write command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_WRITE_CFG;
341973ea:	2302      	movs	r3, #2
341973ec:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
341973ee:	2304      	movs	r3, #4
341973f0:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
341973f2:	2300      	movs	r3, #0
341973f4:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341973f6:	2300      	movs	r3, #0
341973f8:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Instruction         = ((BurstType == 0U) ? APS256XX_WRITE_LINEAR_BURST_CMD : APS256XX_WRITE_CMD);
341973fa:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
341973fc:	2b00      	cmp	r3, #0
341973fe:	d101      	bne.n	34197404 <APS256XX_EnableMemoryMappedMode+0x44>
34197400:	23a0      	movs	r3, #160	@ 0xa0
34197402:	e000      	b.n	34197406 <APS256XX_EnableMemoryMappedMode+0x46>
34197404:	2380      	movs	r3, #128	@ 0x80
34197406:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
34197408:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3419740c:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
3419740e:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34197412:	647b      	str	r3, [r7, #68]	@ 0x44
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
34197414:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34197418:	64bb      	str	r3, [r7, #72]	@ 0x48
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
3419741a:	2300      	movs	r3, #0
3419741c:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DataMode            = ((IOMode == 0U) ? HAL_XSPI_DATA_8_LINES : HAL_XSPI_DATA_16_LINES);
3419741e:	683b      	ldr	r3, [r7, #0]
34197420:	2b00      	cmp	r3, #0
34197422:	d102      	bne.n	3419742a <APS256XX_EnableMemoryMappedMode+0x6a>
34197424:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197428:	e001      	b.n	3419742e <APS256XX_EnableMemoryMappedMode+0x6e>
3419742a:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
3419742e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
34197430:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34197434:	667b      	str	r3, [r7, #100]	@ 0x64
  sCommand.DummyCycles         = (WriteLatencyCode - 1U);
34197436:	687b      	ldr	r3, [r7, #4]
34197438:	3b01      	subs	r3, #1
3419743a:	66bb      	str	r3, [r7, #104]	@ 0x68
  sCommand.DQSMode             = HAL_XSPI_DQS_ENABLE;
3419743c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34197440:	66fb      	str	r3, [r7, #108]	@ 0x6c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197442:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34197446:	f241 3288 	movw	r2, #5000	@ 0x1388
3419744a:	4619      	mov	r1, r3
3419744c:	68f8      	ldr	r0, [r7, #12]
3419744e:	f7ff f8f9 	bl	34196644 <HAL_XSPI_Command>
34197452:	4603      	mov	r3, r0
34197454:	2b00      	cmp	r3, #0
34197456:	d002      	beq.n	3419745e <APS256XX_EnableMemoryMappedMode+0x9e>
  {
    return APS256XX_ERROR;
34197458:	f04f 33ff 	mov.w	r3, #4294967295
3419745c:	e028      	b.n	341974b0 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Initialize the read command */
  sCommand.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
3419745e:	2301      	movs	r3, #1
34197460:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.Instruction   = ((BurstType == 0U) ? APS256XX_READ_LINEAR_BURST_CMD : APS256XX_READ_CMD);
34197462:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34197464:	2b00      	cmp	r3, #0
34197466:	d101      	bne.n	3419746c <APS256XX_EnableMemoryMappedMode+0xac>
34197468:	2320      	movs	r3, #32
3419746a:	e000      	b.n	3419746e <APS256XX_EnableMemoryMappedMode+0xae>
3419746c:	2300      	movs	r3, #0
3419746e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.DummyCycles   = (ReadLatencyCode - 1U);
34197470:	68bb      	ldr	r3, [r7, #8]
34197472:	3b01      	subs	r3, #1
34197474:	66bb      	str	r3, [r7, #104]	@ 0x68

  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197476:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419747a:	f241 3288 	movw	r2, #5000	@ 0x1388
3419747e:	4619      	mov	r1, r3
34197480:	68f8      	ldr	r0, [r7, #12]
34197482:	f7ff f8df 	bl	34196644 <HAL_XSPI_Command>
34197486:	4603      	mov	r3, r0
34197488:	2b00      	cmp	r3, #0
3419748a:	d002      	beq.n	34197492 <APS256XX_EnableMemoryMappedMode+0xd2>
  {
    return APS256XX_ERROR;
3419748c:	f04f 33ff 	mov.w	r3, #4294967295
34197490:	e00e      	b.n	341974b0 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  /* Activation of memory-mapped mode */
  sMemMappedCfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34197492:	2300      	movs	r3, #0
34197494:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_MemoryMapped(Ctx, &sMemMappedCfg) != HAL_OK)
34197496:	f107 0314 	add.w	r3, r7, #20
3419749a:	4619      	mov	r1, r3
3419749c:	68f8      	ldr	r0, [r7, #12]
3419749e:	f7ff fb01 	bl	34196aa4 <HAL_XSPI_MemoryMapped>
341974a2:	4603      	mov	r3, r0
341974a4:	2b00      	cmp	r3, #0
341974a6:	d002      	beq.n	341974ae <APS256XX_EnableMemoryMappedMode+0xee>
  {
    return APS256XX_ERROR;
341974a8:	f04f 33ff 	mov.w	r3, #4294967295
341974ac:	e000      	b.n	341974b0 <APS256XX_EnableMemoryMappedMode+0xf0>
  }

  return APS256XX_OK;
341974ae:	2300      	movs	r3, #0
}
341974b0:	4618      	mov	r0, r3
341974b2:	3770      	adds	r7, #112	@ 0x70
341974b4:	46bd      	mov	sp, r7
341974b6:	bd80      	pop	{r7, pc}

341974b8 <APS256XX_WriteReg>:
  * @param  Address Register address
  * @param  Value Value to write to register
  * @retval error status
  */
int32_t APS256XX_WriteReg(XSPI_HandleTypeDef *Ctx, uint32_t Address, uint8_t Value)
{
341974b8:	b580      	push	{r7, lr}
341974ba:	b098      	sub	sp, #96	@ 0x60
341974bc:	af00      	add	r7, sp, #0
341974be:	60f8      	str	r0, [r7, #12]
341974c0:	60b9      	str	r1, [r7, #8]
341974c2:	4613      	mov	r3, r2
341974c4:	71fb      	strb	r3, [r7, #7]
  XSPI_RegularCmdTypeDef sCommand = {0};
341974c6:	f107 0314 	add.w	r3, r7, #20
341974ca:	224c      	movs	r2, #76	@ 0x4c
341974cc:	2100      	movs	r1, #0
341974ce:	4618      	mov	r0, r3
341974d0:	f00e f80e 	bl	341a54f0 <memset>

  /* Initialize the write register command */
  sCommand.OperationType       = HAL_XSPI_OPTYPE_COMMON_CFG;
341974d4:	2300      	movs	r3, #0
341974d6:	617b      	str	r3, [r7, #20]
  sCommand.InstructionMode     = HAL_XSPI_INSTRUCTION_8_LINES;
341974d8:	2304      	movs	r3, #4
341974da:	623b      	str	r3, [r7, #32]
  sCommand.InstructionWidth    = HAL_XSPI_INSTRUCTION_8_BITS;
341974dc:	2300      	movs	r3, #0
341974de:	627b      	str	r3, [r7, #36]	@ 0x24
  sCommand.InstructionDTRMode  = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341974e0:	2300      	movs	r3, #0
341974e2:	62bb      	str	r3, [r7, #40]	@ 0x28
  sCommand.Instruction         = APS256XX_WRITE_REG_CMD;
341974e4:	23c0      	movs	r3, #192	@ 0xc0
341974e6:	61fb      	str	r3, [r7, #28]
  sCommand.AddressMode         = HAL_XSPI_ADDRESS_8_LINES;
341974e8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341974ec:	633b      	str	r3, [r7, #48]	@ 0x30
  sCommand.AddressWidth        = HAL_XSPI_ADDRESS_32_BITS;
341974ee:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341974f2:	637b      	str	r3, [r7, #52]	@ 0x34
  sCommand.AddressDTRMode      = HAL_XSPI_ADDRESS_DTR_ENABLE;
341974f4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341974f8:	63bb      	str	r3, [r7, #56]	@ 0x38
  sCommand.Address             = Address;
341974fa:	68bb      	ldr	r3, [r7, #8]
341974fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sCommand.AlternateBytesMode  = HAL_XSPI_ALT_BYTES_NONE;
341974fe:	2300      	movs	r3, #0
34197500:	643b      	str	r3, [r7, #64]	@ 0x40
  sCommand.DataMode            = HAL_XSPI_DATA_8_LINES;
34197502:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197506:	64fb      	str	r3, [r7, #76]	@ 0x4c
  sCommand.DataDTRMode         = HAL_XSPI_DATA_DTR_ENABLE;
34197508:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
3419750c:	657b      	str	r3, [r7, #84]	@ 0x54
  sCommand.DataLength          = 2;
3419750e:	2302      	movs	r3, #2
34197510:	653b      	str	r3, [r7, #80]	@ 0x50
  sCommand.DummyCycles         = 0;
34197512:	2300      	movs	r3, #0
34197514:	65bb      	str	r3, [r7, #88]	@ 0x58
  sCommand.DQSMode             = HAL_XSPI_DQS_DISABLE;
34197516:	2300      	movs	r3, #0
34197518:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  sCommand.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Configure the command */
  if (HAL_XSPI_Command(Ctx, &sCommand, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3419751a:	f107 0314 	add.w	r3, r7, #20
3419751e:	f241 3288 	movw	r2, #5000	@ 0x1388
34197522:	4619      	mov	r1, r3
34197524:	68f8      	ldr	r0, [r7, #12]
34197526:	f7ff f88d 	bl	34196644 <HAL_XSPI_Command>
3419752a:	4603      	mov	r3, r0
3419752c:	2b00      	cmp	r3, #0
3419752e:	d002      	beq.n	34197536 <APS256XX_WriteReg+0x7e>
  {
    return APS256XX_ERROR;
34197530:	f04f 33ff 	mov.w	r3, #4294967295
34197534:	e00d      	b.n	34197552 <APS256XX_WriteReg+0x9a>
  }

  /* Transmission of the data */
  if (HAL_XSPI_Transmit(Ctx, (uint8_t *)(&Value), HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197536:	1dfb      	adds	r3, r7, #7
34197538:	f241 3288 	movw	r2, #5000	@ 0x1388
3419753c:	4619      	mov	r1, r3
3419753e:	68f8      	ldr	r0, [r7, #12]
34197540:	f7ff f910 	bl	34196764 <HAL_XSPI_Transmit>
34197544:	4603      	mov	r3, r0
34197546:	2b00      	cmp	r3, #0
34197548:	d002      	beq.n	34197550 <APS256XX_WriteReg+0x98>
  {
    return APS256XX_ERROR;
3419754a:	f04f 33ff 	mov.w	r3, #4294967295
3419754e:	e000      	b.n	34197552 <APS256XX_WriteReg+0x9a>
  }

  return APS256XX_OK;
34197550:	2300      	movs	r3, #0
}
34197552:	4618      	mov	r0, r3
34197554:	3760      	adds	r7, #96	@ 0x60
34197556:	46bd      	mov	sp, r7
34197558:	bd80      	pop	{r7, pc}

3419755a <MX66UW1G45G_GetFlashInfo>:
  * @brief  Get Flash information
  * @param  pInfo pointer to information structure
  * @retval error status
  */
int32_t MX66UW1G45G_GetFlashInfo(MX66UW1G45G_Info_t *pInfo)
{
3419755a:	b480      	push	{r7}
3419755c:	b083      	sub	sp, #12
3419755e:	af00      	add	r7, sp, #0
34197560:	6078      	str	r0, [r7, #4]
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize = MX66UW1G45G_FLASH_SIZE;
34197562:	687b      	ldr	r3, [r7, #4]
34197564:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34197568:	601a      	str	r2, [r3, #0]
  pInfo->EraseSectorSize = MX66UW1G45G_BLOCK_64K;
3419756a:	687b      	ldr	r3, [r7, #4]
3419756c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34197570:	605a      	str	r2, [r3, #4]
  pInfo->EraseSectorsNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_64K);
34197572:	687b      	ldr	r3, [r7, #4]
34197574:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34197578:	609a      	str	r2, [r3, #8]
  pInfo->EraseSubSectorSize = MX66UW1G45G_BLOCK_4K;
3419757a:	687b      	ldr	r3, [r7, #4]
3419757c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34197580:	60da      	str	r2, [r3, #12]
  pInfo->EraseSubSectorNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
34197582:	687b      	ldr	r3, [r7, #4]
34197584:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34197588:	611a      	str	r2, [r3, #16]
  pInfo->EraseSubSector1Size = MX66UW1G45G_BLOCK_4K;
3419758a:	687b      	ldr	r3, [r7, #4]
3419758c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34197590:	615a      	str	r2, [r3, #20]
  pInfo->EraseSubSector1Number = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_BLOCK_4K);
34197592:	687b      	ldr	r3, [r7, #4]
34197594:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34197598:	619a      	str	r2, [r3, #24]
  pInfo->ProgPageSize = MX66UW1G45G_PAGE_SIZE;
3419759a:	687b      	ldr	r3, [r7, #4]
3419759c:	f44f 7280 	mov.w	r2, #256	@ 0x100
341975a0:	61da      	str	r2, [r3, #28]
  pInfo->ProgPagesNumber = (MX66UW1G45G_FLASH_SIZE / MX66UW1G45G_PAGE_SIZE);
341975a2:	687b      	ldr	r3, [r7, #4]
341975a4:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
341975a8:	621a      	str	r2, [r3, #32]

  return MX66UW1G45G_OK;
341975aa:	2300      	movs	r3, #0
};
341975ac:	4618      	mov	r0, r3
341975ae:	370c      	adds	r7, #12
341975b0:	46bd      	mov	sp, r7
341975b2:	f85d 7b04 	ldr.w	r7, [sp], #4
341975b6:	4770      	bx	lr

341975b8 <MX66UW1G45G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX66UW1G45G_AutoPollingMemReady(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                        MX66UW1G45G_Transfer_t Rate)
{
341975b8:	b580      	push	{r7, lr}
341975ba:	b09a      	sub	sp, #104	@ 0x68
341975bc:	af00      	add	r7, sp, #0
341975be:	6078      	str	r0, [r7, #4]
341975c0:	460b      	mov	r3, r1
341975c2:	70fb      	strb	r3, [r7, #3]
341975c4:	4613      	mov	r3, r2
341975c6:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
341975c8:	f107 031c 	add.w	r3, r7, #28
341975cc:	224c      	movs	r2, #76	@ 0x4c
341975ce:	2100      	movs	r1, #0
341975d0:	4618      	mov	r0, r3
341975d2:	f00d ff8d 	bl	341a54f0 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
341975d6:	f107 0308 	add.w	r3, r7, #8
341975da:	2200      	movs	r2, #0
341975dc:	601a      	str	r2, [r3, #0]
341975de:	605a      	str	r2, [r3, #4]
341975e0:	609a      	str	r2, [r3, #8]
341975e2:	60da      	str	r2, [r3, #12]
341975e4:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
341975e6:	78fb      	ldrb	r3, [r7, #3]
341975e8:	2b00      	cmp	r3, #0
341975ea:	d105      	bne.n	341975f8 <MX66UW1G45G_AutoPollingMemReady+0x40>
341975ec:	78bb      	ldrb	r3, [r7, #2]
341975ee:	2b01      	cmp	r3, #1
341975f0:	d102      	bne.n	341975f8 <MX66UW1G45G_AutoPollingMemReady+0x40>
  {
    return MX66UW1G45G_ERROR;
341975f2:	f04f 33ff 	mov.w	r3, #4294967295
341975f6:	e089      	b.n	3419770c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  /* Configure automatic polling mode to wait for memory ready */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
341975f8:	2300      	movs	r3, #0
341975fa:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
341975fc:	78fb      	ldrb	r3, [r7, #3]
341975fe:	2b00      	cmp	r3, #0
34197600:	d101      	bne.n	34197606 <MX66UW1G45G_AutoPollingMemReady+0x4e>
34197602:	2301      	movs	r3, #1
34197604:	e000      	b.n	34197608 <MX66UW1G45G_AutoPollingMemReady+0x50>
34197606:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197608:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
3419760a:	78bb      	ldrb	r3, [r7, #2]
3419760c:	2b01      	cmp	r3, #1
3419760e:	d101      	bne.n	34197614 <MX66UW1G45G_AutoPollingMemReady+0x5c>
34197610:	2308      	movs	r3, #8
34197612:	e000      	b.n	34197616 <MX66UW1G45G_AutoPollingMemReady+0x5e>
34197614:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197616:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197618:	78fb      	ldrb	r3, [r7, #3]
3419761a:	2b00      	cmp	r3, #0
3419761c:	d101      	bne.n	34197622 <MX66UW1G45G_AutoPollingMemReady+0x6a>
3419761e:	2300      	movs	r3, #0
34197620:	e000      	b.n	34197624 <MX66UW1G45G_AutoPollingMemReady+0x6c>
34197622:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197624:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
34197626:	78fb      	ldrb	r3, [r7, #3]
34197628:	2b00      	cmp	r3, #0
3419762a:	d101      	bne.n	34197630 <MX66UW1G45G_AutoPollingMemReady+0x78>
3419762c:	2305      	movs	r3, #5
3419762e:	e001      	b.n	34197634 <MX66UW1G45G_AutoPollingMemReady+0x7c>
34197630:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34197634:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
34197636:	78fb      	ldrb	r3, [r7, #3]
34197638:	2b00      	cmp	r3, #0
3419763a:	d101      	bne.n	34197640 <MX66UW1G45G_AutoPollingMemReady+0x88>
3419763c:	2300      	movs	r3, #0
3419763e:	e001      	b.n	34197644 <MX66UW1G45G_AutoPollingMemReady+0x8c>
34197640:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34197644:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34197646:	78bb      	ldrb	r3, [r7, #2]
34197648:	2b01      	cmp	r3, #1
3419764a:	d102      	bne.n	34197652 <MX66UW1G45G_AutoPollingMemReady+0x9a>
3419764c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34197650:	e000      	b.n	34197654 <MX66UW1G45G_AutoPollingMemReady+0x9c>
34197652:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197654:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34197656:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3419765a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
3419765c:	2300      	movs	r3, #0
3419765e:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34197660:	2300      	movs	r3, #0
34197662:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34197664:	78fb      	ldrb	r3, [r7, #3]
34197666:	2b00      	cmp	r3, #0
34197668:	d102      	bne.n	34197670 <MX66UW1G45G_AutoPollingMemReady+0xb8>
3419766a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3419766e:	e001      	b.n	34197674 <MX66UW1G45G_AutoPollingMemReady+0xbc>
34197670:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197674:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
34197676:	78bb      	ldrb	r3, [r7, #2]
34197678:	2b01      	cmp	r3, #1
3419767a:	d102      	bne.n	34197682 <MX66UW1G45G_AutoPollingMemReady+0xca>
3419767c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34197680:	e000      	b.n	34197684 <MX66UW1G45G_AutoPollingMemReady+0xcc>
34197682:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197684:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34197686:	78fb      	ldrb	r3, [r7, #3]
34197688:	2b00      	cmp	r3, #0
3419768a:	d006      	beq.n	3419769a <MX66UW1G45G_AutoPollingMemReady+0xe2>
3419768c:	78bb      	ldrb	r3, [r7, #2]
3419768e:	2b01      	cmp	r3, #1
34197690:	d101      	bne.n	34197696 <MX66UW1G45G_AutoPollingMemReady+0xde>
34197692:	2305      	movs	r3, #5
34197694:	e002      	b.n	3419769c <MX66UW1G45G_AutoPollingMemReady+0xe4>
34197696:	2304      	movs	r3, #4
34197698:	e000      	b.n	3419769c <MX66UW1G45G_AutoPollingMemReady+0xe4>
3419769a:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
3419769c:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
3419769e:	78bb      	ldrb	r3, [r7, #2]
341976a0:	2b01      	cmp	r3, #1
341976a2:	d101      	bne.n	341976a8 <MX66UW1G45G_AutoPollingMemReady+0xf0>
341976a4:	2302      	movs	r3, #2
341976a6:	e000      	b.n	341976aa <MX66UW1G45G_AutoPollingMemReady+0xf2>
341976a8:	2301      	movs	r3, #1
341976aa:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
341976ac:	78bb      	ldrb	r3, [r7, #2]
341976ae:	2b01      	cmp	r3, #1
341976b0:	d102      	bne.n	341976b8 <MX66UW1G45G_AutoPollingMemReady+0x100>
341976b2:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341976b6:	e000      	b.n	341976ba <MX66UW1G45G_AutoPollingMemReady+0x102>
341976b8:	2300      	movs	r3, #0
341976ba:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  s_config.MatchValue = 0U;
341976bc:	2300      	movs	r3, #0
341976be:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = MX66UW1G45G_SR_WIP;
341976c0:	2301      	movs	r3, #1
341976c2:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
341976c4:	2300      	movs	r3, #0
341976c6:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
341976c8:	2310      	movs	r3, #16
341976ca:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
341976cc:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
341976d0:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341976d2:	f107 031c 	add.w	r3, r7, #28
341976d6:	f241 3288 	movw	r2, #5000	@ 0x1388
341976da:	4619      	mov	r1, r3
341976dc:	6878      	ldr	r0, [r7, #4]
341976de:	f7fe ffb1 	bl	34196644 <HAL_XSPI_Command>
341976e2:	4603      	mov	r3, r0
341976e4:	2b00      	cmp	r3, #0
341976e6:	d002      	beq.n	341976ee <MX66UW1G45G_AutoPollingMemReady+0x136>
  {
    return MX66UW1G45G_ERROR;
341976e8:	f04f 33ff 	mov.w	r3, #4294967295
341976ec:	e00e      	b.n	3419770c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341976ee:	f107 0308 	add.w	r3, r7, #8
341976f2:	f241 3288 	movw	r2, #5000	@ 0x1388
341976f6:	4619      	mov	r1, r3
341976f8:	6878      	ldr	r0, [r7, #4]
341976fa:	f7ff f949 	bl	34196990 <HAL_XSPI_AutoPolling>
341976fe:	4603      	mov	r3, r0
34197700:	2b00      	cmp	r3, #0
34197702:	d002      	beq.n	3419770a <MX66UW1G45G_AutoPollingMemReady+0x152>
  {
    return MX66UW1G45G_ERROR;
34197704:	f04f 33ff 	mov.w	r3, #4294967295
34197708:	e000      	b.n	3419770c <MX66UW1G45G_AutoPollingMemReady+0x154>
  }

  return MX66UW1G45G_OK;
3419770a:	2300      	movs	r3, #0
}
3419770c:	4618      	mov	r0, r3
3419770e:	3768      	adds	r7, #104	@ 0x68
34197710:	46bd      	mov	sp, r7
34197712:	bd80      	pop	{r7, pc}

34197714 <MX66UW1G45G_EnableSTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableSTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                              MX66UW1G45G_AddressWidth_t AddressWidth)
{
34197714:	b580      	push	{r7, lr}
34197716:	b09a      	sub	sp, #104	@ 0x68
34197718:	af00      	add	r7, sp, #0
3419771a:	6078      	str	r0, [r7, #4]
3419771c:	460b      	mov	r3, r1
3419771e:	70fb      	strb	r3, [r7, #3]
34197720:	4613      	mov	r3, r2
34197722:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34197724:	f107 031c 	add.w	r3, r7, #28
34197728:	224c      	movs	r2, #76	@ 0x4c
3419772a:	2100      	movs	r1, #0
3419772c:	4618      	mov	r0, r3
3419772e:	f00d fedf 	bl	341a54f0 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
34197732:	f107 030c 	add.w	r3, r7, #12
34197736:	2200      	movs	r2, #0
34197738:	601a      	str	r2, [r3, #0]
3419773a:	605a      	str	r2, [r3, #4]
3419773c:	609a      	str	r2, [r3, #8]
3419773e:	60da      	str	r2, [r3, #12]

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX66UW1G45G_OPI_MODE) && (AddressWidth == MX66UW1G45G_3BYTES_SIZE))
34197740:	78fb      	ldrb	r3, [r7, #3]
34197742:	2b01      	cmp	r3, #1
34197744:	d105      	bne.n	34197752 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
34197746:	78bb      	ldrb	r3, [r7, #2]
34197748:	2b00      	cmp	r3, #0
3419774a:	d102      	bne.n	34197752 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x3e>
  {
    return MX66UW1G45G_ERROR;
3419774c:	f04f 33ff 	mov.w	r3, #4294967295
34197750:	e084      	b.n	3419785c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34197752:	2301      	movs	r3, #1
34197754:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197756:	78fb      	ldrb	r3, [r7, #3]
34197758:	2b00      	cmp	r3, #0
3419775a:	d101      	bne.n	34197760 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4c>
3419775c:	2301      	movs	r3, #1
3419775e:	e000      	b.n	34197762 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x4e>
34197760:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197762:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197764:	2300      	movs	r3, #0
34197766:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197768:	78fb      	ldrb	r3, [r7, #3]
3419776a:	2b00      	cmp	r3, #0
3419776c:	d101      	bne.n	34197772 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x5e>
3419776e:	2300      	movs	r3, #0
34197770:	e000      	b.n	34197774 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x60>
34197772:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197774:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_FAST_READ_CMD
                                     : MX66UW1G45G_4_BYTE_ADDR_FAST_READ_CMD)
                              : MX66UW1G45G_OCTA_READ_CMD;
34197776:	78fb      	ldrb	r3, [r7, #3]
34197778:	2b00      	cmp	r3, #0
3419777a:	d106      	bne.n	3419778a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x76>
3419777c:	78bb      	ldrb	r3, [r7, #2]
3419777e:	2b00      	cmp	r3, #0
34197780:	d101      	bne.n	34197786 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x72>
34197782:	230b      	movs	r3, #11
34197784:	e003      	b.n	3419778e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
34197786:	230c      	movs	r3, #12
34197788:	e001      	b.n	3419778e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x7a>
3419778a:	f64e 4313 	movw	r3, #60435	@ 0xec13
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3419778e:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34197790:	78fb      	ldrb	r3, [r7, #3]
34197792:	2b00      	cmp	r3, #0
34197794:	d102      	bne.n	3419779c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x88>
34197796:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419779a:	e001      	b.n	341977a0 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x8c>
3419779c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341977a0:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341977a2:	2300      	movs	r3, #0
341977a4:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                               ? HAL_XSPI_ADDRESS_24_BITS
                               : HAL_XSPI_ADDRESS_32_BITS;
341977a6:	78bb      	ldrb	r3, [r7, #2]
341977a8:	2b00      	cmp	r3, #0
341977aa:	d102      	bne.n	341977b2 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x9e>
341977ac:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341977b0:	e001      	b.n	341977b6 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xa2>
341977b2:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
  s_command.AddressWidth = (AddressWidth == MX66UW1G45G_3BYTES_SIZE)
341977b6:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341977b8:	2300      	movs	r3, #0
341977ba:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
341977bc:	78fb      	ldrb	r3, [r7, #3]
341977be:	2b00      	cmp	r3, #0
341977c0:	d102      	bne.n	341977c8 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb4>
341977c2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341977c6:	e001      	b.n	341977cc <MX66UW1G45G_EnableSTRMemoryMappedMode+0xb8>
341977c8:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341977cc:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341977ce:	2300      	movs	r3, #0
341977d0:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
341977d2:	78fb      	ldrb	r3, [r7, #3]
341977d4:	2b00      	cmp	r3, #0
341977d6:	d101      	bne.n	341977dc <MX66UW1G45G_EnableSTRMemoryMappedMode+0xc8>
341977d8:	2308      	movs	r3, #8
341977da:	e000      	b.n	341977de <MX66UW1G45G_EnableSTRMemoryMappedMode+0xca>
341977dc:	230a      	movs	r3, #10
341977de:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
341977e0:	2300      	movs	r3, #0
341977e2:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the read command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341977e4:	f107 031c 	add.w	r3, r7, #28
341977e8:	f241 3288 	movw	r2, #5000	@ 0x1388
341977ec:	4619      	mov	r1, r3
341977ee:	6878      	ldr	r0, [r7, #4]
341977f0:	f7fe ff28 	bl	34196644 <HAL_XSPI_Command>
341977f4:	4603      	mov	r3, r0
341977f6:	2b00      	cmp	r3, #0
341977f8:	d002      	beq.n	34197800 <MX66UW1G45G_EnableSTRMemoryMappedMode+0xec>
  {
    return MX66UW1G45G_ERROR;
341977fa:	f04f 33ff 	mov.w	r3, #4294967295
341977fe:	e02d      	b.n	3419785c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
34197800:	2302      	movs	r3, #2
34197802:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? ((AddressWidth == MX66UW1G45G_3BYTES_SIZE)
                                     ? MX66UW1G45G_PAGE_PROG_CMD
                                     : MX66UW1G45G_4_BYTE_PAGE_PROG_CMD)
                              : MX66UW1G45G_OCTA_PAGE_PROG_CMD;
34197804:	78fb      	ldrb	r3, [r7, #3]
34197806:	2b00      	cmp	r3, #0
34197808:	d106      	bne.n	34197818 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x104>
3419780a:	78bb      	ldrb	r3, [r7, #2]
3419780c:	2b00      	cmp	r3, #0
3419780e:	d101      	bne.n	34197814 <MX66UW1G45G_EnableSTRMemoryMappedMode+0x100>
34197810:	2302      	movs	r3, #2
34197812:	e003      	b.n	3419781c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34197814:	2312      	movs	r3, #18
34197816:	e001      	b.n	3419781c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x108>
34197818:	f241 23ed 	movw	r3, #4845	@ 0x12ed
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
3419781c:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
3419781e:	2300      	movs	r3, #0
34197820:	663b      	str	r3, [r7, #96]	@ 0x60

  /* Send the write command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197822:	f107 031c 	add.w	r3, r7, #28
34197826:	f241 3288 	movw	r2, #5000	@ 0x1388
3419782a:	4619      	mov	r1, r3
3419782c:	6878      	ldr	r0, [r7, #4]
3419782e:	f7fe ff09 	bl	34196644 <HAL_XSPI_Command>
34197832:	4603      	mov	r3, r0
34197834:	2b00      	cmp	r3, #0
34197836:	d002      	beq.n	3419783e <MX66UW1G45G_EnableSTRMemoryMappedMode+0x12a>
  {
    return MX66UW1G45G_ERROR;
34197838:	f04f 33ff 	mov.w	r3, #4294967295
3419783c:	e00e      	b.n	3419785c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
3419783e:	2300      	movs	r3, #0
34197840:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
34197842:	f107 030c 	add.w	r3, r7, #12
34197846:	4619      	mov	r1, r3
34197848:	6878      	ldr	r0, [r7, #4]
3419784a:	f7ff f92b 	bl	34196aa4 <HAL_XSPI_MemoryMapped>
3419784e:	4603      	mov	r3, r0
34197850:	2b00      	cmp	r3, #0
34197852:	d002      	beq.n	3419785a <MX66UW1G45G_EnableSTRMemoryMappedMode+0x146>
  {
    return MX66UW1G45G_ERROR;
34197854:	f04f 33ff 	mov.w	r3, #4294967295
34197858:	e000      	b.n	3419785c <MX66UW1G45G_EnableSTRMemoryMappedMode+0x148>
  }

  return MX66UW1G45G_OK;
3419785a:	2300      	movs	r3, #0
}
3419785c:	4618      	mov	r0, r3
3419785e:	3768      	adds	r7, #104	@ 0x68
34197860:	46bd      	mov	sp, r7
34197862:	bd80      	pop	{r7, pc}

34197864 <MX66UW1G45G_EnableDTRMemoryMappedMode>:
  * @param  AddressWidth Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval XSPI memory status
  */
int32_t MX66UW1G45G_EnableDTRMemoryMappedMode(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode)
{
34197864:	b580      	push	{r7, lr}
34197866:	b09a      	sub	sp, #104	@ 0x68
34197868:	af00      	add	r7, sp, #0
3419786a:	6078      	str	r0, [r7, #4]
3419786c:	460b      	mov	r3, r1
3419786e:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  XSPI_RegularCmdTypeDef s_command = {0};
34197870:	f107 031c 	add.w	r3, r7, #28
34197874:	224c      	movs	r2, #76	@ 0x4c
34197876:	2100      	movs	r1, #0
34197878:	4618      	mov	r0, r3
3419787a:	f00d fe39 	bl	341a54f0 <memset>
  XSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
3419787e:	f107 030c 	add.w	r3, r7, #12
34197882:	2200      	movs	r2, #0
34197884:	601a      	str	r2, [r3, #0]
34197886:	605a      	str	r2, [r3, #4]
34197888:	609a      	str	r2, [r3, #8]
3419788a:	60da      	str	r2, [r3, #12]

  /* Initialize the read command */
  s_command.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
3419788c:	2301      	movs	r3, #1
3419788e:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
34197890:	2304      	movs	r3, #4
34197892:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
34197894:	2308      	movs	r3, #8
34197896:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34197898:	2310      	movs	r3, #16
3419789a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = MX66UW1G45G_OCTA_READ_DTR_CMD;
3419789c:	f64e 6311 	movw	r3, #60945	@ 0xee11
341978a0:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341978a2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341978a6:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341978a8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341978ac:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341978ae:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341978b2:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341978b4:	2300      	movs	r3, #0
341978b6:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_8_LINES;
341978b8:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341978bc:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341978be:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341978c2:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = DUMMY_CYCLES_READ_OCTAL_DTR;
341978c4:	230a      	movs	r3, #10
341978c6:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
341978c8:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341978cc:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341978ce:	f107 031c 	add.w	r3, r7, #28
341978d2:	f241 3288 	movw	r2, #5000	@ 0x1388
341978d6:	4619      	mov	r1, r3
341978d8:	6878      	ldr	r0, [r7, #4]
341978da:	f7fe feb3 	bl	34196644 <HAL_XSPI_Command>
341978de:	4603      	mov	r3, r0
341978e0:	2b00      	cmp	r3, #0
341978e2:	d002      	beq.n	341978ea <MX66UW1G45G_EnableDTRMemoryMappedMode+0x86>
  {
    return MX66UW1G45G_ERROR;
341978e4:	f04f 33ff 	mov.w	r3, #4294967295
341978e8:	e025      	b.n	34197936 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  /* Initialize the program command */
  s_command.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
341978ea:	2302      	movs	r3, #2
341978ec:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = MX66UW1G45G_OCTA_PAGE_PROG_CMD;
341978ee:	f241 23ed 	movw	r3, #4845	@ 0x12ed
341978f2:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.DummyCycles = 0U;
341978f4:	2300      	movs	r3, #0
341978f6:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
341978f8:	2300      	movs	r3, #0
341978fa:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341978fc:	f107 031c 	add.w	r3, r7, #28
34197900:	f241 3288 	movw	r2, #5000	@ 0x1388
34197904:	4619      	mov	r1, r3
34197906:	6878      	ldr	r0, [r7, #4]
34197908:	f7fe fe9c 	bl	34196644 <HAL_XSPI_Command>
3419790c:	4603      	mov	r3, r0
3419790e:	2b00      	cmp	r3, #0
34197910:	d002      	beq.n	34197918 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xb4>
  {
    return MX66UW1G45G_ERROR;
34197912:	f04f 33ff 	mov.w	r3, #4294967295
34197916:	e00e      	b.n	34197936 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }
  /* Configure the memory mapped mode */
  s_mem_mapped_cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34197918:	2300      	movs	r3, #0
3419791a:	60fb      	str	r3, [r7, #12]

  if (HAL_XSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
3419791c:	f107 030c 	add.w	r3, r7, #12
34197920:	4619      	mov	r1, r3
34197922:	6878      	ldr	r0, [r7, #4]
34197924:	f7ff f8be 	bl	34196aa4 <HAL_XSPI_MemoryMapped>
34197928:	4603      	mov	r3, r0
3419792a:	2b00      	cmp	r3, #0
3419792c:	d002      	beq.n	34197934 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd0>
  {
    return MX66UW1G45G_ERROR;
3419792e:	f04f 33ff 	mov.w	r3, #4294967295
34197932:	e000      	b.n	34197936 <MX66UW1G45G_EnableDTRMemoryMappedMode+0xd2>
  }

  return MX66UW1G45G_OK;
34197934:	2300      	movs	r3, #0
}
34197936:	4618      	mov	r0, r3
34197938:	3768      	adds	r7, #104	@ 0x68
3419793a:	46bd      	mov	sp, r7
3419793c:	bd80      	pop	{r7, pc}

3419793e <MX66UW1G45G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_WriteEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
3419793e:	b580      	push	{r7, lr}
34197940:	b09a      	sub	sp, #104	@ 0x68
34197942:	af00      	add	r7, sp, #0
34197944:	6078      	str	r0, [r7, #4]
34197946:	460b      	mov	r3, r1
34197948:	70fb      	strb	r3, [r7, #3]
3419794a:	4613      	mov	r3, r2
3419794c:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
3419794e:	f107 031c 	add.w	r3, r7, #28
34197952:	224c      	movs	r2, #76	@ 0x4c
34197954:	2100      	movs	r1, #0
34197956:	4618      	mov	r0, r3
34197958:	f00d fdca 	bl	341a54f0 <memset>
  XSPI_AutoPollingTypeDef s_config = {0};
3419795c:	f107 0308 	add.w	r3, r7, #8
34197960:	2200      	movs	r2, #0
34197962:	601a      	str	r2, [r3, #0]
34197964:	605a      	str	r2, [r3, #4]
34197966:	609a      	str	r2, [r3, #8]
34197968:	60da      	str	r2, [r3, #12]
3419796a:	611a      	str	r2, [r3, #16]

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
3419796c:	78fb      	ldrb	r3, [r7, #3]
3419796e:	2b00      	cmp	r3, #0
34197970:	d105      	bne.n	3419797e <MX66UW1G45G_WriteEnable+0x40>
34197972:	78bb      	ldrb	r3, [r7, #2]
34197974:	2b01      	cmp	r3, #1
34197976:	d102      	bne.n	3419797e <MX66UW1G45G_WriteEnable+0x40>
  {
    return MX66UW1G45G_ERROR;
34197978:	f04f 33ff 	mov.w	r3, #4294967295
3419797c:	e0a7      	b.n	34197ace <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Initialize the write enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
3419797e:	2300      	movs	r3, #0
34197980:	61fb      	str	r3, [r7, #28]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197982:	78fb      	ldrb	r3, [r7, #3]
34197984:	2b00      	cmp	r3, #0
34197986:	d101      	bne.n	3419798c <MX66UW1G45G_WriteEnable+0x4e>
34197988:	2301      	movs	r3, #1
3419798a:	e000      	b.n	3419798e <MX66UW1G45G_WriteEnable+0x50>
3419798c:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
3419798e:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197990:	78bb      	ldrb	r3, [r7, #2]
34197992:	2b01      	cmp	r3, #1
34197994:	d101      	bne.n	3419799a <MX66UW1G45G_WriteEnable+0x5c>
34197996:	2308      	movs	r3, #8
34197998:	e000      	b.n	3419799c <MX66UW1G45G_WriteEnable+0x5e>
3419799a:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
3419799c:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
3419799e:	78fb      	ldrb	r3, [r7, #3]
341979a0:	2b00      	cmp	r3, #0
341979a2:	d101      	bne.n	341979a8 <MX66UW1G45G_WriteEnable+0x6a>
341979a4:	2300      	movs	r3, #0
341979a6:	e000      	b.n	341979aa <MX66UW1G45G_WriteEnable+0x6c>
341979a8:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
341979aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_ENABLE_CMD
                              : MX66UW1G45G_OCTA_WRITE_ENABLE_CMD;
341979ac:	78fb      	ldrb	r3, [r7, #3]
341979ae:	2b00      	cmp	r3, #0
341979b0:	d101      	bne.n	341979b6 <MX66UW1G45G_WriteEnable+0x78>
341979b2:	2306      	movs	r3, #6
341979b4:	e001      	b.n	341979ba <MX66UW1G45G_WriteEnable+0x7c>
341979b6:	f240 63f9 	movw	r3, #1785	@ 0x6f9
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341979ba:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
341979bc:	2300      	movs	r3, #0
341979be:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341979c0:	2300      	movs	r3, #0
341979c2:	64bb      	str	r3, [r7, #72]	@ 0x48
  s_command.DataMode = HAL_XSPI_DATA_NONE;
341979c4:	2300      	movs	r3, #0
341979c6:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
341979c8:	2300      	movs	r3, #0
341979ca:	663b      	str	r3, [r7, #96]	@ 0x60
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
341979cc:	2300      	movs	r3, #0
341979ce:	667b      	str	r3, [r7, #100]	@ 0x64
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
341979d0:	f107 031c 	add.w	r3, r7, #28
341979d4:	f241 3288 	movw	r2, #5000	@ 0x1388
341979d8:	4619      	mov	r1, r3
341979da:	6878      	ldr	r0, [r7, #4]
341979dc:	f7fe fe32 	bl	34196644 <HAL_XSPI_Command>
341979e0:	4603      	mov	r3, r0
341979e2:	2b00      	cmp	r3, #0
341979e4:	d002      	beq.n	341979ec <MX66UW1G45G_WriteEnable+0xae>
  {
    return MX66UW1G45G_ERROR;
341979e6:	f04f 33ff 	mov.w	r3, #4294967295
341979ea:	e070      	b.n	34197ace <MX66UW1G45G_WriteEnable+0x190>
  }

  /* Configure automatic polling mode to wait for write enabling */
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_STATUS_REG_CMD
                              : MX66UW1G45G_OCTA_READ_STATUS_REG_CMD;
341979ec:	78fb      	ldrb	r3, [r7, #3]
341979ee:	2b00      	cmp	r3, #0
341979f0:	d101      	bne.n	341979f6 <MX66UW1G45G_WriteEnable+0xb8>
341979f2:	2305      	movs	r3, #5
341979f4:	e001      	b.n	341979fa <MX66UW1G45G_WriteEnable+0xbc>
341979f6:	f240 53fa 	movw	r3, #1530	@ 0x5fa
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
341979fa:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_NONE : HAL_XSPI_ADDRESS_8_LINES;
341979fc:	78fb      	ldrb	r3, [r7, #3]
341979fe:	2b00      	cmp	r3, #0
34197a00:	d101      	bne.n	34197a06 <MX66UW1G45G_WriteEnable+0xc8>
34197a02:	2300      	movs	r3, #0
34197a04:	e001      	b.n	34197a0a <MX66UW1G45G_WriteEnable+0xcc>
34197a06:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34197a0a:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34197a0c:	78bb      	ldrb	r3, [r7, #2]
34197a0e:	2b01      	cmp	r3, #1
34197a10:	d102      	bne.n	34197a18 <MX66UW1G45G_WriteEnable+0xda>
34197a12:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34197a16:	e000      	b.n	34197a1a <MX66UW1G45G_WriteEnable+0xdc>
34197a18:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197a1a:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34197a1c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34197a20:	63fb      	str	r3, [r7, #60]	@ 0x3c
  s_command.Address = 0U;
34197a22:	2300      	movs	r3, #0
34197a24:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34197a26:	78fb      	ldrb	r3, [r7, #3]
34197a28:	2b00      	cmp	r3, #0
34197a2a:	d102      	bne.n	34197a32 <MX66UW1G45G_WriteEnable+0xf4>
34197a2c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34197a30:	e001      	b.n	34197a36 <MX66UW1G45G_WriteEnable+0xf8>
34197a32:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197a36:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DATA_DTR_ENABLE : HAL_XSPI_DATA_DTR_DISABLE;
34197a38:	78bb      	ldrb	r3, [r7, #2]
34197a3a:	2b01      	cmp	r3, #1
34197a3c:	d102      	bne.n	34197a44 <MX66UW1G45G_WriteEnable+0x106>
34197a3e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34197a42:	e000      	b.n	34197a46 <MX66UW1G45G_WriteEnable+0x108>
34197a44:	2300      	movs	r3, #0
34197a46:	65fb      	str	r3, [r7, #92]	@ 0x5c
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34197a48:	78fb      	ldrb	r3, [r7, #3]
34197a4a:	2b00      	cmp	r3, #0
34197a4c:	d006      	beq.n	34197a5c <MX66UW1G45G_WriteEnable+0x11e>
34197a4e:	78bb      	ldrb	r3, [r7, #2]
34197a50:	2b01      	cmp	r3, #1
34197a52:	d101      	bne.n	34197a58 <MX66UW1G45G_WriteEnable+0x11a>
34197a54:	2305      	movs	r3, #5
34197a56:	e002      	b.n	34197a5e <MX66UW1G45G_WriteEnable+0x120>
34197a58:	2304      	movs	r3, #4
34197a5a:	e000      	b.n	34197a5e <MX66UW1G45G_WriteEnable+0x120>
34197a5c:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34197a5e:	663b      	str	r3, [r7, #96]	@ 0x60
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34197a60:	78bb      	ldrb	r3, [r7, #2]
34197a62:	2b01      	cmp	r3, #1
34197a64:	d101      	bne.n	34197a6a <MX66UW1G45G_WriteEnable+0x12c>
34197a66:	2302      	movs	r3, #2
34197a68:	e000      	b.n	34197a6c <MX66UW1G45G_WriteEnable+0x12e>
34197a6a:	2301      	movs	r3, #1
34197a6c:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34197a6e:	78bb      	ldrb	r3, [r7, #2]
34197a70:	2b01      	cmp	r3, #1
34197a72:	d102      	bne.n	34197a7a <MX66UW1G45G_WriteEnable+0x13c>
34197a74:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34197a78:	e000      	b.n	34197a7c <MX66UW1G45G_WriteEnable+0x13e>
34197a7a:	2300      	movs	r3, #0
34197a7c:	667b      	str	r3, [r7, #100]	@ 0x64

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197a7e:	f107 031c 	add.w	r3, r7, #28
34197a82:	f241 3288 	movw	r2, #5000	@ 0x1388
34197a86:	4619      	mov	r1, r3
34197a88:	6878      	ldr	r0, [r7, #4]
34197a8a:	f7fe fddb 	bl	34196644 <HAL_XSPI_Command>
34197a8e:	4603      	mov	r3, r0
34197a90:	2b00      	cmp	r3, #0
34197a92:	d002      	beq.n	34197a9a <MX66UW1G45G_WriteEnable+0x15c>
  {
    return MX66UW1G45G_ERROR;
34197a94:	f04f 33ff 	mov.w	r3, #4294967295
34197a98:	e019      	b.n	34197ace <MX66UW1G45G_WriteEnable+0x190>
  }

  s_config.MatchValue = 2U;
34197a9a:	2302      	movs	r3, #2
34197a9c:	60bb      	str	r3, [r7, #8]
  s_config.MatchMask = 2U;
34197a9e:	2302      	movs	r3, #2
34197aa0:	60fb      	str	r3, [r7, #12]
  s_config.MatchMode = HAL_XSPI_MATCH_MODE_AND;
34197aa2:	2300      	movs	r3, #0
34197aa4:	613b      	str	r3, [r7, #16]
  s_config.IntervalTime = MX66UW1G45G_AUTOPOLLING_INTERVAL_TIME;
34197aa6:	2310      	movs	r3, #16
34197aa8:	61bb      	str	r3, [r7, #24]
  s_config.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34197aaa:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34197aae:	617b      	str	r3, [r7, #20]

  if (HAL_XSPI_AutoPolling(Ctx, &s_config, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197ab0:	f107 0308 	add.w	r3, r7, #8
34197ab4:	f241 3288 	movw	r2, #5000	@ 0x1388
34197ab8:	4619      	mov	r1, r3
34197aba:	6878      	ldr	r0, [r7, #4]
34197abc:	f7fe ff68 	bl	34196990 <HAL_XSPI_AutoPolling>
34197ac0:	4603      	mov	r3, r0
34197ac2:	2b00      	cmp	r3, #0
34197ac4:	d002      	beq.n	34197acc <MX66UW1G45G_WriteEnable+0x18e>
  {
    return MX66UW1G45G_ERROR;
34197ac6:	f04f 33ff 	mov.w	r3, #4294967295
34197aca:	e000      	b.n	34197ace <MX66UW1G45G_WriteEnable+0x190>
  }

  return MX66UW1G45G_OK;
34197acc:	2300      	movs	r3, #0
}
34197ace:	4618      	mov	r0, r3
34197ad0:	3768      	adds	r7, #104	@ 0x68
34197ad2:	46bd      	mov	sp, r7
34197ad4:	bd80      	pop	{r7, pc}

34197ad6 <MX66UW1G45G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX66UW1G45G_WriteCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                      MX66UW1G45G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
34197ad6:	b580      	push	{r7, lr}
34197ad8:	b098      	sub	sp, #96	@ 0x60
34197ada:	af00      	add	r7, sp, #0
34197adc:	60f8      	str	r0, [r7, #12]
34197ade:	607b      	str	r3, [r7, #4]
34197ae0:	460b      	mov	r3, r1
34197ae2:	72fb      	strb	r3, [r7, #11]
34197ae4:	4613      	mov	r3, r2
34197ae6:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
34197ae8:	f107 0314 	add.w	r3, r7, #20
34197aec:	224c      	movs	r2, #76	@ 0x4c
34197aee:	2100      	movs	r1, #0
34197af0:	4618      	mov	r0, r3
34197af2:	f00d fcfd 	bl	341a54f0 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34197af6:	7afb      	ldrb	r3, [r7, #11]
34197af8:	2b00      	cmp	r3, #0
34197afa:	d105      	bne.n	34197b08 <MX66UW1G45G_WriteCfg2Register+0x32>
34197afc:	7abb      	ldrb	r3, [r7, #10]
34197afe:	2b01      	cmp	r3, #1
34197b00:	d102      	bne.n	34197b08 <MX66UW1G45G_WriteCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
34197b02:	f04f 33ff 	mov.w	r3, #4294967295
34197b06:	e073      	b.n	34197bf0 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  /* Initialize the writing of configuration register 2 */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34197b08:	2300      	movs	r3, #0
34197b0a:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197b0c:	7afb      	ldrb	r3, [r7, #11]
34197b0e:	2b00      	cmp	r3, #0
34197b10:	d101      	bne.n	34197b16 <MX66UW1G45G_WriteCfg2Register+0x40>
34197b12:	2301      	movs	r3, #1
34197b14:	e000      	b.n	34197b18 <MX66UW1G45G_WriteCfg2Register+0x42>
34197b16:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197b18:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197b1a:	7abb      	ldrb	r3, [r7, #10]
34197b1c:	2b01      	cmp	r3, #1
34197b1e:	d101      	bne.n	34197b24 <MX66UW1G45G_WriteCfg2Register+0x4e>
34197b20:	2308      	movs	r3, #8
34197b22:	e000      	b.n	34197b26 <MX66UW1G45G_WriteCfg2Register+0x50>
34197b24:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197b26:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197b28:	7afb      	ldrb	r3, [r7, #11]
34197b2a:	2b00      	cmp	r3, #0
34197b2c:	d101      	bne.n	34197b32 <MX66UW1G45G_WriteCfg2Register+0x5c>
34197b2e:	2300      	movs	r3, #0
34197b30:	e000      	b.n	34197b34 <MX66UW1G45G_WriteCfg2Register+0x5e>
34197b32:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197b34:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_WRITE_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_WRITE_CFG_REG2_CMD;
34197b36:	7afb      	ldrb	r3, [r7, #11]
34197b38:	2b00      	cmp	r3, #0
34197b3a:	d101      	bne.n	34197b40 <MX66UW1G45G_WriteCfg2Register+0x6a>
34197b3c:	2372      	movs	r3, #114	@ 0x72
34197b3e:	e001      	b.n	34197b44 <MX66UW1G45G_WriteCfg2Register+0x6e>
34197b40:	f247 238d 	movw	r3, #29325	@ 0x728d
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34197b44:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34197b46:	7afb      	ldrb	r3, [r7, #11]
34197b48:	2b00      	cmp	r3, #0
34197b4a:	d102      	bne.n	34197b52 <MX66UW1G45G_WriteCfg2Register+0x7c>
34197b4c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34197b50:	e001      	b.n	34197b56 <MX66UW1G45G_WriteCfg2Register+0x80>
34197b52:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34197b56:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34197b58:	7abb      	ldrb	r3, [r7, #10]
34197b5a:	2b01      	cmp	r3, #1
34197b5c:	d102      	bne.n	34197b64 <MX66UW1G45G_WriteCfg2Register+0x8e>
34197b5e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34197b62:	e000      	b.n	34197b66 <MX66UW1G45G_WriteCfg2Register+0x90>
34197b64:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197b66:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34197b68:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34197b6c:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = WriteAddr;
34197b6e:	687b      	ldr	r3, [r7, #4]
34197b70:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34197b72:	2300      	movs	r3, #0
34197b74:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34197b76:	7afb      	ldrb	r3, [r7, #11]
34197b78:	2b00      	cmp	r3, #0
34197b7a:	d102      	bne.n	34197b82 <MX66UW1G45G_WriteCfg2Register+0xac>
34197b7c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34197b80:	e001      	b.n	34197b86 <MX66UW1G45G_WriteCfg2Register+0xb0>
34197b82:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197b86:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
34197b88:	7abb      	ldrb	r3, [r7, #10]
34197b8a:	2b01      	cmp	r3, #1
34197b8c:	d102      	bne.n	34197b94 <MX66UW1G45G_WriteCfg2Register+0xbe>
34197b8e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34197b92:	e000      	b.n	34197b96 <MX66UW1G45G_WriteCfg2Register+0xc0>
34197b94:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197b96:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = 0U;
34197b98:	2300      	movs	r3, #0
34197b9a:	65bb      	str	r3, [r7, #88]	@ 0x58
  s_command.DataLength = (Mode == MX66UW1G45G_SPI_MODE) ? 1U : ((Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U);
34197b9c:	7afb      	ldrb	r3, [r7, #11]
34197b9e:	2b00      	cmp	r3, #0
34197ba0:	d006      	beq.n	34197bb0 <MX66UW1G45G_WriteCfg2Register+0xda>
34197ba2:	7abb      	ldrb	r3, [r7, #10]
34197ba4:	2b01      	cmp	r3, #1
34197ba6:	d101      	bne.n	34197bac <MX66UW1G45G_WriteCfg2Register+0xd6>
34197ba8:	2302      	movs	r3, #2
34197baa:	e002      	b.n	34197bb2 <MX66UW1G45G_WriteCfg2Register+0xdc>
34197bac:	2301      	movs	r3, #1
34197bae:	e000      	b.n	34197bb2 <MX66UW1G45G_WriteCfg2Register+0xdc>
34197bb0:	2301      	movs	r3, #1
34197bb2:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34197bb4:	2300      	movs	r3, #0
34197bb6:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197bb8:	f107 0314 	add.w	r3, r7, #20
34197bbc:	f241 3288 	movw	r2, #5000	@ 0x1388
34197bc0:	4619      	mov	r1, r3
34197bc2:	68f8      	ldr	r0, [r7, #12]
34197bc4:	f7fe fd3e 	bl	34196644 <HAL_XSPI_Command>
34197bc8:	4603      	mov	r3, r0
34197bca:	2b00      	cmp	r3, #0
34197bcc:	d002      	beq.n	34197bd4 <MX66UW1G45G_WriteCfg2Register+0xfe>
  {
    return MX66UW1G45G_ERROR;
34197bce:	f04f 33ff 	mov.w	r3, #4294967295
34197bd2:	e00d      	b.n	34197bf0 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  if (HAL_XSPI_Transmit(Ctx, &Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197bd4:	f241 3288 	movw	r2, #5000	@ 0x1388
34197bd8:	f107 0168 	add.w	r1, r7, #104	@ 0x68
34197bdc:	68f8      	ldr	r0, [r7, #12]
34197bde:	f7fe fdc1 	bl	34196764 <HAL_XSPI_Transmit>
34197be2:	4603      	mov	r3, r0
34197be4:	2b00      	cmp	r3, #0
34197be6:	d002      	beq.n	34197bee <MX66UW1G45G_WriteCfg2Register+0x118>
  {
    return MX66UW1G45G_ERROR;
34197be8:	f04f 33ff 	mov.w	r3, #4294967295
34197bec:	e000      	b.n	34197bf0 <MX66UW1G45G_WriteCfg2Register+0x11a>
  }

  return MX66UW1G45G_OK;
34197bee:	2300      	movs	r3, #0
}
34197bf0:	4618      	mov	r0, r3
34197bf2:	3760      	adds	r7, #96	@ 0x60
34197bf4:	46bd      	mov	sp, r7
34197bf6:	bd80      	pop	{r7, pc}

34197bf8 <MX66UW1G45G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX66UW1G45G_ReadCfg2Register(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode,
                                     MX66UW1G45G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
34197bf8:	b580      	push	{r7, lr}
34197bfa:	b098      	sub	sp, #96	@ 0x60
34197bfc:	af00      	add	r7, sp, #0
34197bfe:	60f8      	str	r0, [r7, #12]
34197c00:	607b      	str	r3, [r7, #4]
34197c02:	460b      	mov	r3, r1
34197c04:	72fb      	strb	r3, [r7, #11]
34197c06:	4613      	mov	r3, r2
34197c08:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = {0};
34197c0a:	f107 0314 	add.w	r3, r7, #20
34197c0e:	224c      	movs	r2, #76	@ 0x4c
34197c10:	2100      	movs	r1, #0
34197c12:	4618      	mov	r0, r3
34197c14:	f00d fc6c 	bl	341a54f0 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34197c18:	7afb      	ldrb	r3, [r7, #11]
34197c1a:	2b00      	cmp	r3, #0
34197c1c:	d105      	bne.n	34197c2a <MX66UW1G45G_ReadCfg2Register+0x32>
34197c1e:	7abb      	ldrb	r3, [r7, #10]
34197c20:	2b01      	cmp	r3, #1
34197c22:	d102      	bne.n	34197c2a <MX66UW1G45G_ReadCfg2Register+0x32>
  {
    return MX66UW1G45G_ERROR;
34197c24:	f04f 33ff 	mov.w	r3, #4294967295
34197c28:	e07d      	b.n	34197d26 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Initialize the reading of status register */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34197c2a:	2300      	movs	r3, #0
34197c2c:	617b      	str	r3, [r7, #20]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197c2e:	7afb      	ldrb	r3, [r7, #11]
34197c30:	2b00      	cmp	r3, #0
34197c32:	d101      	bne.n	34197c38 <MX66UW1G45G_ReadCfg2Register+0x40>
34197c34:	2301      	movs	r3, #1
34197c36:	e000      	b.n	34197c3a <MX66UW1G45G_ReadCfg2Register+0x42>
34197c38:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197c3a:	623b      	str	r3, [r7, #32]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197c3c:	7abb      	ldrb	r3, [r7, #10]
34197c3e:	2b01      	cmp	r3, #1
34197c40:	d101      	bne.n	34197c46 <MX66UW1G45G_ReadCfg2Register+0x4e>
34197c42:	2308      	movs	r3, #8
34197c44:	e000      	b.n	34197c48 <MX66UW1G45G_ReadCfg2Register+0x50>
34197c46:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197c48:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197c4a:	7afb      	ldrb	r3, [r7, #11]
34197c4c:	2b00      	cmp	r3, #0
34197c4e:	d101      	bne.n	34197c54 <MX66UW1G45G_ReadCfg2Register+0x5c>
34197c50:	2300      	movs	r3, #0
34197c52:	e000      	b.n	34197c56 <MX66UW1G45G_ReadCfg2Register+0x5e>
34197c54:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197c56:	627b      	str	r3, [r7, #36]	@ 0x24
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_READ_CFG_REG2_CMD
                              : MX66UW1G45G_OCTA_READ_CFG_REG2_CMD;
34197c58:	7afb      	ldrb	r3, [r7, #11]
34197c5a:	2b00      	cmp	r3, #0
34197c5c:	d101      	bne.n	34197c62 <MX66UW1G45G_ReadCfg2Register+0x6a>
34197c5e:	2371      	movs	r3, #113	@ 0x71
34197c60:	e001      	b.n	34197c66 <MX66UW1G45G_ReadCfg2Register+0x6e>
34197c62:	f247 138e 	movw	r3, #29070	@ 0x718e
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34197c66:	61fb      	str	r3, [r7, #28]
  s_command.AddressMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_ADDRESS_1_LINE : HAL_XSPI_ADDRESS_8_LINES;
34197c68:	7afb      	ldrb	r3, [r7, #11]
34197c6a:	2b00      	cmp	r3, #0
34197c6c:	d102      	bne.n	34197c74 <MX66UW1G45G_ReadCfg2Register+0x7c>
34197c6e:	f44f 7380 	mov.w	r3, #256	@ 0x100
34197c72:	e001      	b.n	34197c78 <MX66UW1G45G_ReadCfg2Register+0x80>
34197c74:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34197c78:	633b      	str	r3, [r7, #48]	@ 0x30
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                 ? HAL_XSPI_ADDRESS_DTR_ENABLE
                                 : HAL_XSPI_ADDRESS_DTR_DISABLE;
34197c7a:	7abb      	ldrb	r3, [r7, #10]
34197c7c:	2b01      	cmp	r3, #1
34197c7e:	d102      	bne.n	34197c86 <MX66UW1G45G_ReadCfg2Register+0x8e>
34197c80:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34197c84:	e000      	b.n	34197c88 <MX66UW1G45G_ReadCfg2Register+0x90>
34197c86:	2300      	movs	r3, #0
  s_command.AddressDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197c88:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34197c8a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
34197c8e:	637b      	str	r3, [r7, #52]	@ 0x34
  s_command.Address = ReadAddr;
34197c90:	687b      	ldr	r3, [r7, #4]
34197c92:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34197c94:	2300      	movs	r3, #0
34197c96:	643b      	str	r3, [r7, #64]	@ 0x40
  s_command.DataMode = (Mode == MX66UW1G45G_SPI_MODE) ? HAL_XSPI_DATA_1_LINE : HAL_XSPI_DATA_8_LINES;
34197c98:	7afb      	ldrb	r3, [r7, #11]
34197c9a:	2b00      	cmp	r3, #0
34197c9c:	d102      	bne.n	34197ca4 <MX66UW1G45G_ReadCfg2Register+0xac>
34197c9e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34197ca2:	e001      	b.n	34197ca8 <MX66UW1G45G_ReadCfg2Register+0xb0>
34197ca4:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34197ca8:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                              ? HAL_XSPI_DATA_DTR_ENABLE
                              : HAL_XSPI_DATA_DTR_DISABLE;
34197caa:	7abb      	ldrb	r3, [r7, #10]
34197cac:	2b01      	cmp	r3, #1
34197cae:	d102      	bne.n	34197cb6 <MX66UW1G45G_ReadCfg2Register+0xbe>
34197cb0:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
34197cb4:	e000      	b.n	34197cb8 <MX66UW1G45G_ReadCfg2Register+0xc0>
34197cb6:	2300      	movs	r3, #0
  s_command.DataDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197cb8:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
                              ? 0U
                              : ((Rate == MX66UW1G45G_DTR_TRANSFER)
34197cba:	7afb      	ldrb	r3, [r7, #11]
34197cbc:	2b00      	cmp	r3, #0
34197cbe:	d006      	beq.n	34197cce <MX66UW1G45G_ReadCfg2Register+0xd6>
34197cc0:	7abb      	ldrb	r3, [r7, #10]
34197cc2:	2b01      	cmp	r3, #1
34197cc4:	d101      	bne.n	34197cca <MX66UW1G45G_ReadCfg2Register+0xd2>
34197cc6:	2305      	movs	r3, #5
34197cc8:	e002      	b.n	34197cd0 <MX66UW1G45G_ReadCfg2Register+0xd8>
34197cca:	2304      	movs	r3, #4
34197ccc:	e000      	b.n	34197cd0 <MX66UW1G45G_ReadCfg2Register+0xd8>
34197cce:	2300      	movs	r3, #0
  s_command.DummyCycles = (Mode == MX66UW1G45G_SPI_MODE)
34197cd0:	65bb      	str	r3, [r7, #88]	@ 0x58
                                     ? DUMMY_CYCLES_REG_OCTAL_DTR
                                     : DUMMY_CYCLES_REG_OCTAL);
  s_command.DataLength = (Rate == MX66UW1G45G_DTR_TRANSFER) ? 2U : 1U;
34197cd2:	7abb      	ldrb	r3, [r7, #10]
34197cd4:	2b01      	cmp	r3, #1
34197cd6:	d101      	bne.n	34197cdc <MX66UW1G45G_ReadCfg2Register+0xe4>
34197cd8:	2302      	movs	r3, #2
34197cda:	e000      	b.n	34197cde <MX66UW1G45G_ReadCfg2Register+0xe6>
34197cdc:	2301      	movs	r3, #1
34197cde:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = (Rate == MX66UW1G45G_DTR_TRANSFER) ? HAL_XSPI_DQS_ENABLE : HAL_XSPI_DQS_DISABLE;
34197ce0:	7abb      	ldrb	r3, [r7, #10]
34197ce2:	2b01      	cmp	r3, #1
34197ce4:	d102      	bne.n	34197cec <MX66UW1G45G_ReadCfg2Register+0xf4>
34197ce6:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
34197cea:	e000      	b.n	34197cee <MX66UW1G45G_ReadCfg2Register+0xf6>
34197cec:	2300      	movs	r3, #0
34197cee:	65fb      	str	r3, [r7, #92]	@ 0x5c
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197cf0:	f107 0314 	add.w	r3, r7, #20
34197cf4:	f241 3288 	movw	r2, #5000	@ 0x1388
34197cf8:	4619      	mov	r1, r3
34197cfa:	68f8      	ldr	r0, [r7, #12]
34197cfc:	f7fe fca2 	bl	34196644 <HAL_XSPI_Command>
34197d00:	4603      	mov	r3, r0
34197d02:	2b00      	cmp	r3, #0
34197d04:	d002      	beq.n	34197d0c <MX66UW1G45G_ReadCfg2Register+0x114>
  {
    return MX66UW1G45G_ERROR;
34197d06:	f04f 33ff 	mov.w	r3, #4294967295
34197d0a:	e00c      	b.n	34197d26 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  /* Reception of the data */
  if (HAL_XSPI_Receive(Ctx, Value, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197d0c:	f241 3288 	movw	r2, #5000	@ 0x1388
34197d10:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
34197d12:	68f8      	ldr	r0, [r7, #12]
34197d14:	f7fe fd99 	bl	3419684a <HAL_XSPI_Receive>
34197d18:	4603      	mov	r3, r0
34197d1a:	2b00      	cmp	r3, #0
34197d1c:	d002      	beq.n	34197d24 <MX66UW1G45G_ReadCfg2Register+0x12c>
  {
    return MX66UW1G45G_ERROR;
34197d1e:	f04f 33ff 	mov.w	r3, #4294967295
34197d22:	e000      	b.n	34197d26 <MX66UW1G45G_ReadCfg2Register+0x12e>
  }

  return MX66UW1G45G_OK;
34197d24:	2300      	movs	r3, #0
}
34197d26:	4618      	mov	r0, r3
34197d28:	3760      	adds	r7, #96	@ 0x60
34197d2a:	46bd      	mov	sp, r7
34197d2c:	bd80      	pop	{r7, pc}

34197d2e <MX66UW1G45G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetEnable(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34197d2e:	b580      	push	{r7, lr}
34197d30:	b096      	sub	sp, #88	@ 0x58
34197d32:	af00      	add	r7, sp, #0
34197d34:	6078      	str	r0, [r7, #4]
34197d36:	460b      	mov	r3, r1
34197d38:	70fb      	strb	r3, [r7, #3]
34197d3a:	4613      	mov	r3, r2
34197d3c:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34197d3e:	f107 030c 	add.w	r3, r7, #12
34197d42:	224c      	movs	r2, #76	@ 0x4c
34197d44:	2100      	movs	r1, #0
34197d46:	4618      	mov	r0, r3
34197d48:	f00d fbd2 	bl	341a54f0 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34197d4c:	78fb      	ldrb	r3, [r7, #3]
34197d4e:	2b00      	cmp	r3, #0
34197d50:	d105      	bne.n	34197d5e <MX66UW1G45G_ResetEnable+0x30>
34197d52:	78bb      	ldrb	r3, [r7, #2]
34197d54:	2b01      	cmp	r3, #1
34197d56:	d102      	bne.n	34197d5e <MX66UW1G45G_ResetEnable+0x30>
  {
    return MX66UW1G45G_ERROR;
34197d58:	f04f 33ff 	mov.w	r3, #4294967295
34197d5c:	e039      	b.n	34197dd2 <MX66UW1G45G_ResetEnable+0xa4>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34197d5e:	2300      	movs	r3, #0
34197d60:	60fb      	str	r3, [r7, #12]
  s_command.IOSelect =  HAL_XSPI_SELECT_IO_3_0;
34197d62:	2300      	movs	r3, #0
34197d64:	613b      	str	r3, [r7, #16]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197d66:	78fb      	ldrb	r3, [r7, #3]
34197d68:	2b00      	cmp	r3, #0
34197d6a:	d101      	bne.n	34197d70 <MX66UW1G45G_ResetEnable+0x42>
34197d6c:	2301      	movs	r3, #1
34197d6e:	e000      	b.n	34197d72 <MX66UW1G45G_ResetEnable+0x44>
34197d70:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197d72:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197d74:	78bb      	ldrb	r3, [r7, #2]
34197d76:	2b01      	cmp	r3, #1
34197d78:	d101      	bne.n	34197d7e <MX66UW1G45G_ResetEnable+0x50>
34197d7a:	2308      	movs	r3, #8
34197d7c:	e000      	b.n	34197d80 <MX66UW1G45G_ResetEnable+0x52>
34197d7e:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197d80:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197d82:	78fb      	ldrb	r3, [r7, #3]
34197d84:	2b00      	cmp	r3, #0
34197d86:	d101      	bne.n	34197d8c <MX66UW1G45G_ResetEnable+0x5e>
34197d88:	2300      	movs	r3, #0
34197d8a:	e000      	b.n	34197d8e <MX66UW1G45G_ResetEnable+0x60>
34197d8c:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197d8e:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_ENABLE_CMD
                              : MX66UW1G45G_OCTA_RESET_ENABLE_CMD;
34197d90:	78fb      	ldrb	r3, [r7, #3]
34197d92:	2b00      	cmp	r3, #0
34197d94:	d101      	bne.n	34197d9a <MX66UW1G45G_ResetEnable+0x6c>
34197d96:	2366      	movs	r3, #102	@ 0x66
34197d98:	e001      	b.n	34197d9e <MX66UW1G45G_ResetEnable+0x70>
34197d9a:	f246 6399 	movw	r3, #26265	@ 0x6699
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34197d9e:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34197da0:	2300      	movs	r3, #0
34197da2:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34197da4:	2300      	movs	r3, #0
34197da6:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34197da8:	2300      	movs	r3, #0
34197daa:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34197dac:	2300      	movs	r3, #0
34197dae:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34197db0:	2300      	movs	r3, #0
34197db2:	657b      	str	r3, [r7, #84]	@ 0x54


  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197db4:	f107 030c 	add.w	r3, r7, #12
34197db8:	f241 3288 	movw	r2, #5000	@ 0x1388
34197dbc:	4619      	mov	r1, r3
34197dbe:	6878      	ldr	r0, [r7, #4]
34197dc0:	f7fe fc40 	bl	34196644 <HAL_XSPI_Command>
34197dc4:	4603      	mov	r3, r0
34197dc6:	2b00      	cmp	r3, #0
34197dc8:	d002      	beq.n	34197dd0 <MX66UW1G45G_ResetEnable+0xa2>
  {
    return MX66UW1G45G_ERROR;
34197dca:	f04f 33ff 	mov.w	r3, #4294967295
34197dce:	e000      	b.n	34197dd2 <MX66UW1G45G_ResetEnable+0xa4>
  }

  return MX66UW1G45G_OK;
34197dd0:	2300      	movs	r3, #0
}
34197dd2:	4618      	mov	r0, r3
34197dd4:	3758      	adds	r7, #88	@ 0x58
34197dd6:	46bd      	mov	sp, r7
34197dd8:	bd80      	pop	{r7, pc}

34197dda <MX66UW1G45G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX66UW1G45G_ResetMemory(XSPI_HandleTypeDef *Ctx, MX66UW1G45G_Interface_t Mode, MX66UW1G45G_Transfer_t Rate)
{
34197dda:	b580      	push	{r7, lr}
34197ddc:	b096      	sub	sp, #88	@ 0x58
34197dde:	af00      	add	r7, sp, #0
34197de0:	6078      	str	r0, [r7, #4]
34197de2:	460b      	mov	r3, r1
34197de4:	70fb      	strb	r3, [r7, #3]
34197de6:	4613      	mov	r3, r2
34197de8:	70bb      	strb	r3, [r7, #2]
  XSPI_RegularCmdTypeDef s_command = {0};
34197dea:	f107 030c 	add.w	r3, r7, #12
34197dee:	224c      	movs	r2, #76	@ 0x4c
34197df0:	2100      	movs	r1, #0
34197df2:	4618      	mov	r0, r3
34197df4:	f00d fb7c 	bl	341a54f0 <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX66UW1G45G_SPI_MODE) && (Rate == MX66UW1G45G_DTR_TRANSFER))
34197df8:	78fb      	ldrb	r3, [r7, #3]
34197dfa:	2b00      	cmp	r3, #0
34197dfc:	d105      	bne.n	34197e0a <MX66UW1G45G_ResetMemory+0x30>
34197dfe:	78bb      	ldrb	r3, [r7, #2]
34197e00:	2b01      	cmp	r3, #1
34197e02:	d102      	bne.n	34197e0a <MX66UW1G45G_ResetMemory+0x30>
  {
    return MX66UW1G45G_ERROR;
34197e04:	f04f 33ff 	mov.w	r3, #4294967295
34197e08:	e037      	b.n	34197e7a <MX66UW1G45G_ResetMemory+0xa0>
  }

  /* Initialize the reset enable command */
  s_command.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
34197e0a:	2300      	movs	r3, #0
34197e0c:	60fb      	str	r3, [r7, #12]
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
                                  ? HAL_XSPI_INSTRUCTION_1_LINE
                                  : HAL_XSPI_INSTRUCTION_8_LINES;
34197e0e:	78fb      	ldrb	r3, [r7, #3]
34197e10:	2b00      	cmp	r3, #0
34197e12:	d101      	bne.n	34197e18 <MX66UW1G45G_ResetMemory+0x3e>
34197e14:	2301      	movs	r3, #1
34197e16:	e000      	b.n	34197e1a <MX66UW1G45G_ResetMemory+0x40>
34197e18:	2304      	movs	r3, #4
  s_command.InstructionMode = (Mode == MX66UW1G45G_SPI_MODE)
34197e1a:	61bb      	str	r3, [r7, #24]
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
                                     ? HAL_XSPI_INSTRUCTION_DTR_ENABLE
                                     : HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34197e1c:	78bb      	ldrb	r3, [r7, #2]
34197e1e:	2b01      	cmp	r3, #1
34197e20:	d101      	bne.n	34197e26 <MX66UW1G45G_ResetMemory+0x4c>
34197e22:	2308      	movs	r3, #8
34197e24:	e000      	b.n	34197e28 <MX66UW1G45G_ResetMemory+0x4e>
34197e26:	2300      	movs	r3, #0
  s_command.InstructionDTRMode = (Rate == MX66UW1G45G_DTR_TRANSFER)
34197e28:	623b      	str	r3, [r7, #32]
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
                                   ? HAL_XSPI_INSTRUCTION_8_BITS
                                   : HAL_XSPI_INSTRUCTION_16_BITS;
34197e2a:	78fb      	ldrb	r3, [r7, #3]
34197e2c:	2b00      	cmp	r3, #0
34197e2e:	d101      	bne.n	34197e34 <MX66UW1G45G_ResetMemory+0x5a>
34197e30:	2300      	movs	r3, #0
34197e32:	e000      	b.n	34197e36 <MX66UW1G45G_ResetMemory+0x5c>
34197e34:	2310      	movs	r3, #16
  s_command.InstructionWidth = (Mode == MX66UW1G45G_SPI_MODE)
34197e36:	61fb      	str	r3, [r7, #28]
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
                              ? MX66UW1G45G_RESET_MEMORY_CMD
                              : MX66UW1G45G_OCTA_RESET_MEMORY_CMD;
34197e38:	78fb      	ldrb	r3, [r7, #3]
34197e3a:	2b00      	cmp	r3, #0
34197e3c:	d101      	bne.n	34197e42 <MX66UW1G45G_ResetMemory+0x68>
34197e3e:	2399      	movs	r3, #153	@ 0x99
34197e40:	e001      	b.n	34197e46 <MX66UW1G45G_ResetMemory+0x6c>
34197e42:	f649 1366 	movw	r3, #39270	@ 0x9966
  s_command.Instruction = (Mode == MX66UW1G45G_SPI_MODE)
34197e46:	617b      	str	r3, [r7, #20]
  s_command.AddressMode = HAL_XSPI_ADDRESS_NONE;
34197e48:	2300      	movs	r3, #0
34197e4a:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34197e4c:	2300      	movs	r3, #0
34197e4e:	63bb      	str	r3, [r7, #56]	@ 0x38
  s_command.DataMode = HAL_XSPI_DATA_NONE;
34197e50:	2300      	movs	r3, #0
34197e52:	647b      	str	r3, [r7, #68]	@ 0x44
  s_command.DummyCycles = 0U;
34197e54:	2300      	movs	r3, #0
34197e56:	653b      	str	r3, [r7, #80]	@ 0x50
  s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
34197e58:	2300      	movs	r3, #0
34197e5a:	657b      	str	r3, [r7, #84]	@ 0x54
 #if defined (XSPI_CCR_SIOO)
  s_command.SIOOMode            = HAL_XSPI_SIOO_INST_EVERY_CMD;
 #endif

  /* Send the command */
  if (HAL_XSPI_Command(Ctx, &s_command, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34197e5c:	f107 030c 	add.w	r3, r7, #12
34197e60:	f241 3288 	movw	r2, #5000	@ 0x1388
34197e64:	4619      	mov	r1, r3
34197e66:	6878      	ldr	r0, [r7, #4]
34197e68:	f7fe fbec 	bl	34196644 <HAL_XSPI_Command>
34197e6c:	4603      	mov	r3, r0
34197e6e:	2b00      	cmp	r3, #0
34197e70:	d002      	beq.n	34197e78 <MX66UW1G45G_ResetMemory+0x9e>
  {
    return MX66UW1G45G_ERROR;
34197e72:	f04f 33ff 	mov.w	r3, #4294967295
34197e76:	e000      	b.n	34197e7a <MX66UW1G45G_ResetMemory+0xa0>
  }

  return MX66UW1G45G_OK;
34197e78:	2300      	movs	r3, #0
}
34197e7a:	4618      	mov	r0, r3
34197e7c:	3758      	adds	r7, #88	@ 0x58
34197e7e:	46bd      	mov	sp, r7
34197e80:	bd80      	pop	{r7, pc}

34197e82 <ISP_Algo_BadPixel_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
34197e82:	b480      	push	{r7}
34197e84:	b083      	sub	sp, #12
34197e86:	af00      	add	r7, sp, #0
34197e88:	6078      	str	r0, [r7, #4]
34197e8a:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
34197e8c:	683b      	ldr	r3, [r7, #0]
34197e8e:	2200      	movs	r2, #0
34197e90:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34197e92:	2300      	movs	r3, #0
}
34197e94:	4618      	mov	r0, r3
34197e96:	370c      	adds	r7, #12
34197e98:	46bd      	mov	sp, r7
34197e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34197e9e:	4770      	bx	lr

34197ea0 <ISP_Algo_BadPixel_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_DeInit(void *hIsp, void *pAlgo)
{
34197ea0:	b480      	push	{r7}
34197ea2:	b083      	sub	sp, #12
34197ea4:	af00      	add	r7, sp, #0
34197ea6:	6078      	str	r0, [r7, #4]
34197ea8:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
34197eaa:	2300      	movs	r3, #0
}
34197eac:	4618      	mov	r0, r3
34197eae:	370c      	adds	r7, #12
34197eb0:	46bd      	mov	sp, r7
34197eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34197eb6:	4770      	bx	lr

34197eb8 <ISP_Algo_BadPixel_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Process(void *hIsp, void *pAlgo)
{
34197eb8:	b580      	push	{r7, lr}
34197eba:	b088      	sub	sp, #32
34197ebc:	af00      	add	r7, sp, #0
34197ebe:	6078      	str	r0, [r7, #4]
34197ec0:	6039      	str	r1, [r7, #0]
  uint32_t CurrentFrameId;
  ISP_BadPixelTypeDef BadPixelConfig;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34197ec2:	6878      	ldr	r0, [r7, #4]
34197ec4:	f002 ff0c 	bl	3419ace0 <ISP_SVC_IQParam_Get>
34197ec8:	61f8      	str	r0, [r7, #28]

  if (IQParamConfig->badPixelAlgo.enable == false)
34197eca:	69fb      	ldr	r3, [r7, #28]
34197ecc:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34197ed0:	2b00      	cmp	r3, #0
34197ed2:	d101      	bne.n	34197ed8 <ISP_Algo_BadPixel_Process+0x20>
  {
    return ISP_OK;
34197ed4:	2300      	movs	r3, #0
34197ed6:	e069      	b.n	34197fac <ISP_Algo_BadPixel_Process+0xf4>
  }

  /* Wait for a new frame */
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
34197ed8:	6878      	ldr	r0, [r7, #4]
34197eda:	f002 fe3c 	bl	3419ab56 <ISP_SVC_Misc_GetMainFrameId>
34197ede:	61b8      	str	r0, [r7, #24]
  if (CurrentFrameId == LastFrameId)
34197ee0:	4b34      	ldr	r3, [pc, #208]	@ (34197fb4 <ISP_Algo_BadPixel_Process+0xfc>)
34197ee2:	681b      	ldr	r3, [r3, #0]
34197ee4:	69ba      	ldr	r2, [r7, #24]
34197ee6:	429a      	cmp	r2, r3
34197ee8:	d101      	bne.n	34197eee <ISP_Algo_BadPixel_Process+0x36>
  {
    return ISP_OK;
34197eea:	2300      	movs	r3, #0
34197eec:	e05e      	b.n	34197fac <ISP_Algo_BadPixel_Process+0xf4>
  }
  LastFrameId = CurrentFrameId;
34197eee:	4a31      	ldr	r2, [pc, #196]	@ (34197fb4 <ISP_Algo_BadPixel_Process+0xfc>)
34197ef0:	69bb      	ldr	r3, [r7, #24]
34197ef2:	6013      	str	r3, [r2, #0]

  if (Step++ >= 0)
34197ef4:	4b30      	ldr	r3, [pc, #192]	@ (34197fb8 <ISP_Algo_BadPixel_Process+0x100>)
34197ef6:	f993 3000 	ldrsb.w	r3, [r3]
34197efa:	b2da      	uxtb	r2, r3
34197efc:	3201      	adds	r2, #1
34197efe:	b2d2      	uxtb	r2, r2
34197f00:	b251      	sxtb	r1, r2
34197f02:	4a2d      	ldr	r2, [pc, #180]	@ (34197fb8 <ISP_Algo_BadPixel_Process+0x100>)
34197f04:	7011      	strb	r1, [r2, #0]
34197f06:	2b00      	cmp	r3, #0
34197f08:	db12      	blt.n	34197f30 <ISP_Algo_BadPixel_Process+0x78>
  {
    /* Measure the number of bad pixels */
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
34197f0a:	f107 030c 	add.w	r3, r7, #12
34197f0e:	4619      	mov	r1, r3
34197f10:	6878      	ldr	r0, [r7, #4]
34197f12:	f002 face 	bl	3419a4b2 <ISP_SVC_ISP_GetBadPixel>
34197f16:	4603      	mov	r3, r0
34197f18:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
34197f1a:	7dfb      	ldrb	r3, [r7, #23]
34197f1c:	2b00      	cmp	r3, #0
34197f1e:	d001      	beq.n	34197f24 <ISP_Algo_BadPixel_Process+0x6c>
    {
      return ret;
34197f20:	7dfb      	ldrb	r3, [r7, #23]
34197f22:	e043      	b.n	34197fac <ISP_Algo_BadPixel_Process+0xf4>
    }
    BadPixelCount += BadPixelConfig.count;
34197f24:	693a      	ldr	r2, [r7, #16]
34197f26:	4b25      	ldr	r3, [pc, #148]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f28:	681b      	ldr	r3, [r3, #0]
34197f2a:	4413      	add	r3, r2
34197f2c:	4a23      	ldr	r2, [pc, #140]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f2e:	6013      	str	r3, [r2, #0]
  }

  if (Step == 10)
34197f30:	4b21      	ldr	r3, [pc, #132]	@ (34197fb8 <ISP_Algo_BadPixel_Process+0x100>)
34197f32:	f993 3000 	ldrsb.w	r3, [r3]
34197f36:	2b0a      	cmp	r3, #10
34197f38:	d137      	bne.n	34197faa <ISP_Algo_BadPixel_Process+0xf2>
  {
    /* All measures done : make an average and compare with threshold */
    BadPixelCount /= 10;
34197f3a:	4b20      	ldr	r3, [pc, #128]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f3c:	681b      	ldr	r3, [r3, #0]
34197f3e:	4a20      	ldr	r2, [pc, #128]	@ (34197fc0 <ISP_Algo_BadPixel_Process+0x108>)
34197f40:	fba2 2303 	umull	r2, r3, r2, r3
34197f44:	08db      	lsrs	r3, r3, #3
34197f46:	4a1d      	ldr	r2, [pc, #116]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f48:	6013      	str	r3, [r2, #0]

    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
34197f4a:	69fb      	ldr	r3, [r7, #28]
34197f4c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
34197f4e:	4b1b      	ldr	r3, [pc, #108]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f50:	681b      	ldr	r3, [r3, #0]
34197f52:	429a      	cmp	r2, r3
34197f54:	d207      	bcs.n	34197f66 <ISP_Algo_BadPixel_Process+0xae>
34197f56:	7b7b      	ldrb	r3, [r7, #13]
34197f58:	2b00      	cmp	r3, #0
34197f5a:	d004      	beq.n	34197f66 <ISP_Algo_BadPixel_Process+0xae>
    {
      /* Bad pixel is above target : decrease strength */
      BadPixelConfig.strength--;
34197f5c:	7b7b      	ldrb	r3, [r7, #13]
34197f5e:	3b01      	subs	r3, #1
34197f60:	b2db      	uxtb	r3, r3
34197f62:	737b      	strb	r3, [r7, #13]
34197f64:	e00c      	b.n	34197f80 <ISP_Algo_BadPixel_Process+0xc8>
    }
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
34197f66:	69fb      	ldr	r3, [r7, #28]
34197f68:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
34197f6a:	4b14      	ldr	r3, [pc, #80]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197f6c:	681b      	ldr	r3, [r3, #0]
34197f6e:	429a      	cmp	r2, r3
34197f70:	d906      	bls.n	34197f80 <ISP_Algo_BadPixel_Process+0xc8>
34197f72:	7b7b      	ldrb	r3, [r7, #13]
34197f74:	2b05      	cmp	r3, #5
34197f76:	d803      	bhi.n	34197f80 <ISP_Algo_BadPixel_Process+0xc8>
    {
      /* Bad pixel is below target : increase strength. (exclude ISP_BADPIXEL_STRENGTH_MAX which gives weird results) */
      BadPixelConfig.strength++;
34197f78:	7b7b      	ldrb	r3, [r7, #13]
34197f7a:	3301      	adds	r3, #1
34197f7c:	b2db      	uxtb	r3, r3
34197f7e:	737b      	strb	r3, [r7, #13]
    }

    /* Set updated Strength */
    BadPixelConfig.enable = 1;
34197f80:	2301      	movs	r3, #1
34197f82:	733b      	strb	r3, [r7, #12]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
34197f84:	f107 030c 	add.w	r3, r7, #12
34197f88:	4619      	mov	r1, r3
34197f8a:	6878      	ldr	r0, [r7, #4]
34197f8c:	f002 fa52 	bl	3419a434 <ISP_SVC_ISP_SetBadPixel>
34197f90:	4603      	mov	r3, r0
34197f92:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
34197f94:	7dfb      	ldrb	r3, [r7, #23]
34197f96:	2b00      	cmp	r3, #0
34197f98:	d001      	beq.n	34197f9e <ISP_Algo_BadPixel_Process+0xe6>
    {
      return ret;
34197f9a:	7dfb      	ldrb	r3, [r7, #23]
34197f9c:	e006      	b.n	34197fac <ISP_Algo_BadPixel_Process+0xf4>
    }

    /* Set Step to -1 to wait for an extra frame before a new measurement (the ISP HW needs one frame to update after reconfig) */
    Step = -1;
34197f9e:	4b06      	ldr	r3, [pc, #24]	@ (34197fb8 <ISP_Algo_BadPixel_Process+0x100>)
34197fa0:	22ff      	movs	r2, #255	@ 0xff
34197fa2:	701a      	strb	r2, [r3, #0]
    BadPixelCount = 0;
34197fa4:	4b05      	ldr	r3, [pc, #20]	@ (34197fbc <ISP_Algo_BadPixel_Process+0x104>)
34197fa6:	2200      	movs	r2, #0
34197fa8:	601a      	str	r2, [r3, #0]
  }

  return ISP_OK;
34197faa:	2300      	movs	r3, #0
}
34197fac:	4618      	mov	r0, r3
34197fae:	3720      	adds	r7, #32
34197fb0:	46bd      	mov	sp, r7
34197fb2:	bd80      	pop	{r7, pc}
34197fb4:	341c1318 	.word	0x341c1318
34197fb8:	341c131c 	.word	0x341c131c
34197fbc:	341c1320 	.word	0x341c1320
34197fc0:	cccccccd 	.word	0xcccccccd

34197fc4 <log_cb>:

#if defined(ISP_MW_SW_AEC_ALGO_SUPPORT) || defined(ISP_MW_SW_AWB_ALGO_SUPPORT)
static void log_cb(const char *const msg)
{
34197fc4:	b580      	push	{r7, lr}
34197fc6:	b082      	sub	sp, #8
34197fc8:	af00      	add	r7, sp, #0
34197fca:	6078      	str	r0, [r7, #4]
  printf("%s", msg);
34197fcc:	6879      	ldr	r1, [r7, #4]
34197fce:	4805      	ldr	r0, [pc, #20]	@ (34197fe4 <log_cb+0x20>)
34197fd0:	f00d f8f6 	bl	341a51c0 <iprintf>
  printf("\r\n");
34197fd4:	4804      	ldr	r0, [pc, #16]	@ (34197fe8 <log_cb+0x24>)
34197fd6:	f00d f95b 	bl	341a5290 <puts>
}
34197fda:	bf00      	nop
34197fdc:	3708      	adds	r7, #8
34197fde:	46bd      	mov	sp, r7
34197fe0:	bd80      	pop	{r7, pc}
34197fe2:	bf00      	nop
34197fe4:	341a739c 	.word	0x341a739c
34197fe8:	341a73a0 	.word	0x341a73a0
34197fec:	00000000 	.word	0x00000000

34197ff0 <ISP_Algo_AEC_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Init(void *hIsp, void *pAlgo)
{
34197ff0:	b580      	push	{r7, lr}
34197ff2:	b088      	sub	sp, #32
34197ff4:	af00      	add	r7, sp, #0
34197ff6:	6078      	str	r0, [r7, #4]
34197ff8:	6039      	str	r1, [r7, #0]
  ISP_HandleTypeDef *pIsp_handle = (ISP_HandleTypeDef*) hIsp;
34197ffa:	687b      	ldr	r3, [r7, #4]
34197ffc:	61fb      	str	r3, [r7, #28]
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34197ffe:	683b      	ldr	r3, [r7, #0]
34198000:	61bb      	str	r3, [r7, #24]
  ISP_SensorExposureTypeDef exposureConfig;
  ISP_SensorGainTypeDef gainConfig;
  ISP_IQParamTypeDef *IQParamConfig;
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34198002:	6878      	ldr	r0, [r7, #4]
34198004:	f002 fe6c 	bl	3419ace0 <ISP_SVC_IQParam_Get>
34198008:	6178      	str	r0, [r7, #20]

  if (IQParamConfig->sensorDelay.delay == 0)
3419800a:	697b      	ldr	r3, [r7, #20]
3419800c:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
34198010:	2b00      	cmp	r3, #0
34198012:	d103      	bne.n	3419801c <ISP_Algo_AEC_Init+0x2c>
  {
    /* A value of 0 is invalid, it would break the AEC algo */
    IQParamConfig->sensorDelay.delay = 1;
34198014:	697b      	ldr	r3, [r7, #20]
34198016:	2201      	movs	r2, #1
34198018:	f883 2255 	strb.w	r2, [r3, #597]	@ 0x255
  }

  /* Create st_ae_process instance */
  pIspAEprocess = evision_api_st_ae_new(log_cb);
3419801c:	4850      	ldr	r0, [pc, #320]	@ (34198160 <ISP_Algo_AEC_Init+0x170>)
3419801e:	f7e9 f9db 	bl	341813d8 <evision_api_st_ae_new>
34198022:	4603      	mov	r3, r0
34198024:	4a4f      	ldr	r2, [pc, #316]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
34198026:	6013      	str	r3, [r2, #0]
  if (pIspAEprocess == NULL)
34198028:	4b4e      	ldr	r3, [pc, #312]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419802a:	681b      	ldr	r3, [r3, #0]
3419802c:	2b00      	cmp	r3, #0
3419802e:	d101      	bne.n	34198034 <ISP_Algo_AEC_Init+0x44>
  {
    return ISP_ERR_ALGO;
34198030:	23be      	movs	r3, #190	@ 0xbe
34198032:	e087      	b.n	34198144 <ISP_Algo_AEC_Init+0x154>
  }

  /* Initialize st_ae_process instance */
  e_ret = evision_api_st_ae_init(pIspAEprocess);
34198034:	4b4b      	ldr	r3, [pc, #300]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
34198036:	681b      	ldr	r3, [r3, #0]
34198038:	4618      	mov	r0, r3
3419803a:	f7e9 fa21 	bl	34181480 <evision_api_st_ae_init>
3419803e:	4603      	mov	r3, r0
34198040:	74fb      	strb	r3, [r7, #19]
  if (e_ret != EVISION_RET_SUCCESS)
34198042:	f997 3013 	ldrsb.w	r3, [r7, #19]
34198046:	2b01      	cmp	r3, #1
34198048:	d006      	beq.n	34198058 <ISP_Algo_AEC_Init+0x68>
  {
    evision_api_st_ae_delete(pIspAEprocess);
3419804a:	4b46      	ldr	r3, [pc, #280]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419804c:	681b      	ldr	r3, [r3, #0]
3419804e:	4618      	mov	r0, r3
34198050:	f7e9 f9dc 	bl	3418140c <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
34198054:	23be      	movs	r3, #190	@ 0xbe
34198056:	e075      	b.n	34198144 <ISP_Algo_AEC_Init+0x154>
  }

  /* Configure algo (AEC target and anti-flicker setting) */
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34198058:	4b42      	ldr	r3, [pc, #264]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419805a:	681b      	ldr	r3, [r3, #0]
3419805c:	697a      	ldr	r2, [r7, #20]
3419805e:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
34198060:	611a      	str	r2, [r3, #16]
  pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
34198062:	697b      	ldr	r3, [r7, #20]
34198064:	f893 2070 	ldrb.w	r2, [r3, #112]	@ 0x70
34198068:	4b3e      	ldr	r3, [pc, #248]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419806a:	681b      	ldr	r3, [r3, #0]
3419806c:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Configure algo (sensor config) */
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
3419806e:	4b3d      	ldr	r3, [pc, #244]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
34198070:	681b      	ldr	r3, [r3, #0]
34198072:	69fa      	ldr	r2, [r7, #28]
34198074:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
34198078:	641a      	str	r2, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
3419807a:	4b3a      	ldr	r3, [pc, #232]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419807c:	681b      	ldr	r3, [r3, #0]
3419807e:	69fa      	ldr	r2, [r7, #28]
34198080:	f8d2 2084 	ldr.w	r2, [r2, #132]	@ 0x84
34198084:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
34198086:	4b37      	ldr	r3, [pc, #220]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
34198088:	681b      	ldr	r3, [r3, #0]
3419808a:	69fa      	ldr	r2, [r7, #28]
3419808c:	6f92      	ldr	r2, [r2, #120]	@ 0x78
3419808e:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
34198090:	4b34      	ldr	r3, [pc, #208]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
34198092:	681b      	ldr	r3, [r3, #0]
34198094:	69fa      	ldr	r2, [r7, #28]
34198096:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34198098:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Force hyper parameters with configuration defined in evision-api-st-ae.h */
  pIspAEprocess->hyper_params.tolerance = HYPERPARAM_AEC_TOLERANCE;
3419809a:	4b32      	ldr	r3, [pc, #200]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
3419809c:	681b      	ldr	r3, [r3, #0]
3419809e:	220a      	movs	r2, #10
341980a0:	615a      	str	r2, [r3, #20]
  pIspAEprocess->hyper_params.gain_increment_coeff = HYPERPARAM_AEC_GAIN_INCREMENT_COEFF;
341980a2:	4b30      	ldr	r3, [pc, #192]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980a4:	681b      	ldr	r3, [r3, #0]
341980a6:	2264      	movs	r2, #100	@ 0x64
341980a8:	619a      	str	r2, [r3, #24]
  pIspAEprocess->hyper_params.gain_low_delta = HYPERPARAM_AEC_GAIN_LOW_DELTA;
341980aa:	4b2e      	ldr	r3, [pc, #184]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980ac:	681b      	ldr	r3, [r3, #0]
341980ae:	222d      	movs	r2, #45	@ 0x2d
341980b0:	61da      	str	r2, [r3, #28]
  pIspAEprocess->hyper_params.gain_high_delta = HYPERPARAM_AEC_GAIN_HIGH_DELTA;
341980b2:	4b2c      	ldr	r3, [pc, #176]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980b4:	681b      	ldr	r3, [r3, #0]
341980b6:	2278      	movs	r2, #120	@ 0x78
341980b8:	621a      	str	r2, [r3, #32]
  pIspAEprocess->hyper_params.gain_low_increment_max = HYPERPARAM_AEC_GAIN_LOW_INC_MAX;
341980ba:	4b2a      	ldr	r3, [pc, #168]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980bc:	681b      	ldr	r3, [r3, #0]
341980be:	f240 52dc 	movw	r2, #1500	@ 0x5dc
341980c2:	625a      	str	r2, [r3, #36]	@ 0x24
  pIspAEprocess->hyper_params.gain_medium_increment_max = HYPERPARAM_AEC_GAIN_MEDIUM_INC_MAX;
341980c4:	4b27      	ldr	r3, [pc, #156]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980c6:	681b      	ldr	r3, [r3, #0]
341980c8:	f241 7270 	movw	r2, #6000	@ 0x1770
341980cc:	629a      	str	r2, [r3, #40]	@ 0x28
  pIspAEprocess->hyper_params.gain_high_increment_max = HYPERPARAM_AEC_GAIN_HIGH_INC_MAX;
341980ce:	4b25      	ldr	r3, [pc, #148]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980d0:	681b      	ldr	r3, [r3, #0]
341980d2:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
341980d6:	62da      	str	r2, [r3, #44]	@ 0x2c
  pIspAEprocess->hyper_params.exposure_up_ratio = HYPERPARAM_AEC_EXPOSURE_UP_RATIO;
341980d8:	4b22      	ldr	r3, [pc, #136]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980da:	6819      	ldr	r1, [r3, #0]
341980dc:	a31c      	add	r3, pc, #112	@ (adr r3, 34198150 <ISP_Algo_AEC_Init+0x160>)
341980de:	e9d3 2300 	ldrd	r2, r3, [r3]
341980e2:	e9c1 230c 	strd	r2, r3, [r1, #48]	@ 0x30
  pIspAEprocess->hyper_params.exposure_down_ratio = HYPERPARAM_AEC_EXPOSURE_DOWN_RATIO;
341980e6:	4b1f      	ldr	r3, [pc, #124]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980e8:	6819      	ldr	r1, [r3, #0]
341980ea:	a31b      	add	r3, pc, #108	@ (adr r3, 34198158 <ISP_Algo_AEC_Init+0x168>)
341980ec:	e9d3 2300 	ldrd	r2, r3, [r3]
341980f0:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
  pIspAEprocess->hyper_params.dark_zone_lum_limit = HYPERPARAM_AEC_DARKZONE_LUM_LIMIT;
341980f4:	4b1b      	ldr	r3, [pc, #108]	@ (34198164 <ISP_Algo_AEC_Init+0x174>)
341980f6:	681b      	ldr	r3, [r3, #0]
341980f8:	2205      	movs	r2, #5
341980fa:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Initialize exposure and gain at min value */
  if (IQParamConfig->AECAlgo.enable == true)
341980fc:	697b      	ldr	r3, [r7, #20]
341980fe:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34198102:	2b01      	cmp	r3, #1
34198104:	d11a      	bne.n	3419813c <ISP_Algo_AEC_Init+0x14c>
  {
    exposureConfig.exposure = pIsp_handle->sensorInfo.exposure_min;
34198106:	69fb      	ldr	r3, [r7, #28]
34198108:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3419810c:	60fb      	str	r3, [r7, #12]
    gainConfig.gain = pIsp_handle->sensorInfo.gain_min;
3419810e:	69fb      	ldr	r3, [r7, #28]
34198110:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34198112:	60bb      	str	r3, [r7, #8]
    if ((ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig) != ISP_OK) || (ISP_SVC_Sensor_SetGain(hIsp, &gainConfig)!= ISP_OK))
34198114:	f107 030c 	add.w	r3, r7, #12
34198118:	4619      	mov	r1, r3
3419811a:	6878      	ldr	r0, [r7, #4]
3419811c:	f002 fca8 	bl	3419aa70 <ISP_SVC_Sensor_SetExposure>
34198120:	4603      	mov	r3, r0
34198122:	2b00      	cmp	r3, #0
34198124:	d108      	bne.n	34198138 <ISP_Algo_AEC_Init+0x148>
34198126:	f107 0308 	add.w	r3, r7, #8
3419812a:	4619      	mov	r1, r3
3419812c:	6878      	ldr	r0, [r7, #4]
3419812e:	f002 fc53 	bl	3419a9d8 <ISP_SVC_Sensor_SetGain>
34198132:	4603      	mov	r3, r0
34198134:	2b00      	cmp	r3, #0
34198136:	d001      	beq.n	3419813c <ISP_Algo_AEC_Init+0x14c>
    {
      return ISP_ERR_ALGO;
34198138:	23be      	movs	r3, #190	@ 0xbe
3419813a:	e003      	b.n	34198144 <ISP_Algo_AEC_Init+0x154>
    }
  }

  /* Update State */
  algo->state = ISP_ALGO_STATE_INIT;
3419813c:	69bb      	ldr	r3, [r7, #24]
3419813e:	2200      	movs	r2, #0
34198140:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34198142:	2300      	movs	r3, #0
}
34198144:	4618      	mov	r0, r3
34198146:	3720      	adds	r7, #32
34198148:	46bd      	mov	sp, r7
3419814a:	bd80      	pop	{r7, pc}
3419814c:	f3af 8000 	nop.w
34198150:	40000000 	.word	0x40000000
34198154:	3f947ae1 	.word	0x3f947ae1
34198158:	e0000000 	.word	0xe0000000
3419815c:	3f70624d 	.word	0x3f70624d
34198160:	34197fc5 	.word	0x34197fc5
34198164:	341c12f8 	.word	0x341c12f8

34198168 <ISP_Algo_AEC_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_DeInit(void *hIsp, void *pAlgo)
{
34198168:	b580      	push	{r7, lr}
3419816a:	b082      	sub	sp, #8
3419816c:	af00      	add	r7, sp, #0
3419816e:	6078      	str	r0, [r7, #4]
34198170:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAEprocess != NULL)
34198172:	4b07      	ldr	r3, [pc, #28]	@ (34198190 <ISP_Algo_AEC_DeInit+0x28>)
34198174:	681b      	ldr	r3, [r3, #0]
34198176:	2b00      	cmp	r3, #0
34198178:	d004      	beq.n	34198184 <ISP_Algo_AEC_DeInit+0x1c>
  {
    evision_api_st_ae_delete(pIspAEprocess);
3419817a:	4b05      	ldr	r3, [pc, #20]	@ (34198190 <ISP_Algo_AEC_DeInit+0x28>)
3419817c:	681b      	ldr	r3, [r3, #0]
3419817e:	4618      	mov	r0, r3
34198180:	f7e9 f944 	bl	3418140c <evision_api_st_ae_delete>
  }
  return ISP_OK;
34198184:	2300      	movs	r3, #0
}
34198186:	4618      	mov	r0, r3
34198188:	3708      	adds	r7, #8
3419818a:	46bd      	mov	sp, r7
3419818c:	bd80      	pop	{r7, pc}
3419818e:	bf00      	nop
34198190:	341c12f8 	.word	0x341c12f8

34198194 <ISP_Algo_AEC_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
34198194:	b480      	push	{r7}
34198196:	b083      	sub	sp, #12
34198198:	af00      	add	r7, sp, #0
3419819a:	6078      	str	r0, [r7, #4]
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
3419819c:	687b      	ldr	r3, [r7, #4]
3419819e:	2203      	movs	r2, #3
341981a0:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
341981a2:	2300      	movs	r3, #0
}
341981a4:	4618      	mov	r0, r3
341981a6:	370c      	adds	r7, #12
341981a8:	46bd      	mov	sp, r7
341981aa:	f85d 7b04 	ldr.w	r7, [sp], #4
341981ae:	4770      	bx	lr

341981b0 <ISP_Algo_AEC_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Process(void *hIsp, void *pAlgo)
{
341981b0:	b580      	push	{r7, lr}
341981b2:	b08e      	sub	sp, #56	@ 0x38
341981b4:	af04      	add	r7, sp, #16
341981b6:	6078      	str	r0, [r7, #4]
341981b8:	6039      	str	r1, [r7, #0]
  static ISP_SVC_StatStateTypeDef stats;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
341981ba:	683b      	ldr	r3, [r7, #0]
341981bc:	623b      	str	r3, [r7, #32]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret = ISP_OK;
341981be:	2300      	movs	r3, #0
341981c0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#ifdef ALGO_AEC_DBG_LOGS
  static uint32_t currentL;
#endif
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
341981c4:	6878      	ldr	r0, [r7, #4]
341981c6:	f002 fd8b 	bl	3419ace0 <ISP_SVC_IQParam_Get>
341981ca:	61f8      	str	r0, [r7, #28]
  if (IQParamConfig->AECAlgo.enable == false)
341981cc:	69fb      	ldr	r3, [r7, #28]
341981ce:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
341981d2:	2b00      	cmp	r3, #0
341981d4:	d101      	bne.n	341981da <ISP_Algo_AEC_Process+0x2a>
  {
    return ISP_OK;
341981d6:	2300      	movs	r3, #0
341981d8:	e0c3      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
  }

  switch(algo->state)
341981da:	6a3b      	ldr	r3, [r7, #32]
341981dc:	785b      	ldrb	r3, [r3, #1]
341981de:	2b03      	cmp	r3, #3
341981e0:	d027      	beq.n	34198232 <ISP_Algo_AEC_Process+0x82>
341981e2:	2b03      	cmp	r3, #3
341981e4:	f300 80b3 	bgt.w	3419834e <ISP_Algo_AEC_Process+0x19e>
341981e8:	2b01      	cmp	r3, #1
341981ea:	dc02      	bgt.n	341981f2 <ISP_Algo_AEC_Process+0x42>
341981ec:	2b00      	cmp	r3, #0
341981ee:	da04      	bge.n	341981fa <ISP_Algo_AEC_Process+0x4a>
341981f0:	e0ad      	b.n	3419834e <ISP_Algo_AEC_Process+0x19e>
341981f2:	2b02      	cmp	r3, #2
341981f4:	f000 80b2 	beq.w	3419835c <ISP_Algo_AEC_Process+0x1ac>
341981f8:	e0a9      	b.n	3419834e <ISP_Algo_AEC_Process+0x19e>
  {
  case ISP_ALGO_STATE_INIT:
  case ISP_ALGO_STATE_NEED_STAT:
    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
                                ISP_STAT_TYPE_AVG, IQParamConfig->sensorDelay.delay);
341981fa:	69fb      	ldr	r3, [r7, #28]
341981fc:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34198200:	9302      	str	r3, [sp, #8]
34198202:	2301      	movs	r3, #1
34198204:	9301      	str	r3, [sp, #4]
34198206:	2302      	movs	r3, #2
34198208:	9300      	str	r3, [sp, #0]
3419820a:	4b58      	ldr	r3, [pc, #352]	@ (3419836c <ISP_Algo_AEC_Process+0x1bc>)
3419820c:	683a      	ldr	r2, [r7, #0]
3419820e:	4958      	ldr	r1, [pc, #352]	@ (34198370 <ISP_Algo_AEC_Process+0x1c0>)
34198210:	6878      	ldr	r0, [r7, #4]
34198212:	f003 f8cb 	bl	3419b3ac <ISP_SVC_Stats_GetNext>
34198216:	4603      	mov	r3, r0
34198218:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
3419821c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34198220:	2b00      	cmp	r3, #0
34198222:	d002      	beq.n	3419822a <ISP_Algo_AEC_Process+0x7a>
    {
      return ret;
34198224:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34198228:	e09b      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3419822a:	6a3b      	ldr	r3, [r7, #32]
3419822c:	2202      	movs	r2, #2
3419822e:	705a      	strb	r2, [r3, #1]
    break;
34198230:	e095      	b.n	3419835e <ISP_Algo_AEC_Process+0x1ae>
    /* Do nothing */
    break;

  case ISP_ALGO_STATE_STAT_READY:
    /* Align on the target update (may have been updated with ISP_SetExposureTarget()) */
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
34198232:	4b50      	ldr	r3, [pc, #320]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
34198234:	681b      	ldr	r3, [r3, #0]
34198236:	69fa      	ldr	r2, [r7, #28]
34198238:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
3419823a:	611a      	str	r2, [r3, #16]

    /* Align on the anti-flicker frequency (may have been updated by IQTune)*/
    pIspAEprocess->hyper_params.compat_freq = IQParamConfig->AECAlgo.antiFlickerFreq;
3419823c:	69fb      	ldr	r3, [r7, #28]
3419823e:	f893 2070 	ldrb.w	r2, [r3, #112]	@ 0x70
34198242:	4b4c      	ldr	r3, [pc, #304]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
34198244:	681b      	ldr	r3, [r3, #0]
34198246:	655a      	str	r2, [r3, #84]	@ 0x54

    avgL = stats.down.averageL;
34198248:	4b48      	ldr	r3, [pc, #288]	@ (3419836c <ISP_Algo_AEC_Process+0x1bc>)
3419824a:	f893 3037 	ldrb.w	r3, [r3, #55]	@ 0x37
3419824e:	61bb      	str	r3, [r7, #24]
      printf("L = %"PRIu32"\r\n", avgL);
      currentL = avgL;
    }
#endif
    /* Read the current sensor gain */
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
34198250:	f107 0310 	add.w	r3, r7, #16
34198254:	4619      	mov	r1, r3
34198256:	6878      	ldr	r0, [r7, #4]
34198258:	f002 fbe8 	bl	3419aa2c <ISP_SVC_Sensor_GetGain>
3419825c:	4603      	mov	r3, r0
3419825e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
34198262:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34198266:	2b00      	cmp	r3, #0
34198268:	d002      	beq.n	34198270 <ISP_Algo_AEC_Process+0xc0>
    {
      return ret;
3419826a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3419826e:	e078      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
    }

    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
34198270:	f107 030c 	add.w	r3, r7, #12
34198274:	4619      	mov	r1, r3
34198276:	6878      	ldr	r0, [r7, #4]
34198278:	f002 fc24 	bl	3419aac4 <ISP_SVC_Sensor_GetExposure>
3419827c:	4603      	mov	r3, r0
3419827e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
34198282:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34198286:	2b00      	cmp	r3, #0
34198288:	d002      	beq.n	34198290 <ISP_Algo_AEC_Process+0xe0>
    {
      return ret;
3419828a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3419828e:	e068      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
    }

    /* Store meta data */
    Meta.averageL = (uint8_t)avgL;
34198290:	69bb      	ldr	r3, [r7, #24]
34198292:	b2da      	uxtb	r2, r3
34198294:	4b38      	ldr	r3, [pc, #224]	@ (34198378 <ISP_Algo_AEC_Process+0x1c8>)
34198296:	705a      	strb	r2, [r3, #1]
    Meta.exposureTarget = IQParamConfig->AECAlgo.exposureTarget;
34198298:	69fb      	ldr	r3, [r7, #28]
3419829a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3419829c:	4a36      	ldr	r2, [pc, #216]	@ (34198378 <ISP_Algo_AEC_Process+0x1c8>)
3419829e:	6053      	str	r3, [r2, #4]

    /* Run algo to calculate new gain and exposure */
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, (uint8_t)avgL);
341982a0:	4b34      	ldr	r3, [pc, #208]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
341982a2:	6818      	ldr	r0, [r3, #0]
341982a4:	6939      	ldr	r1, [r7, #16]
341982a6:	68fa      	ldr	r2, [r7, #12]
341982a8:	69bb      	ldr	r3, [r7, #24]
341982aa:	b2db      	uxtb	r3, r3
341982ac:	f7e9 f8f3 	bl	34181496 <evision_api_st_ae_process>
341982b0:	4603      	mov	r3, r0
341982b2:	75fb      	strb	r3, [r7, #23]
    if (e_ret == EVISION_RET_SUCCESS)
341982b4:	f997 3017 	ldrsb.w	r3, [r7, #23]
341982b8:	2b01      	cmp	r3, #1
341982ba:	d133      	bne.n	34198324 <ISP_Algo_AEC_Process+0x174>
    {
      if (gainConfig.gain != pIspAEprocess->new_gain)
341982bc:	693a      	ldr	r2, [r7, #16]
341982be:	4b2d      	ldr	r3, [pc, #180]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
341982c0:	681b      	ldr	r3, [r3, #0]
341982c2:	689b      	ldr	r3, [r3, #8]
341982c4:	429a      	cmp	r2, r3
341982c6:	d013      	beq.n	341982f0 <ISP_Algo_AEC_Process+0x140>
      {
        /* Set new gain */
        gainConfig.gain = pIspAEprocess->new_gain;
341982c8:	4b2a      	ldr	r3, [pc, #168]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
341982ca:	681b      	ldr	r3, [r3, #0]
341982cc:	689b      	ldr	r3, [r3, #8]
341982ce:	613b      	str	r3, [r7, #16]

        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
341982d0:	f107 0310 	add.w	r3, r7, #16
341982d4:	4619      	mov	r1, r3
341982d6:	6878      	ldr	r0, [r7, #4]
341982d8:	f002 fb7e 	bl	3419a9d8 <ISP_SVC_Sensor_SetGain>
341982dc:	4603      	mov	r3, r0
341982de:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
341982e2:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341982e6:	2b00      	cmp	r3, #0
341982e8:	d002      	beq.n	341982f0 <ISP_Algo_AEC_Process+0x140>
        {
          return ret;
341982ea:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341982ee:	e038      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
#ifdef ALGO_AEC_DBG_LOGS
        printf("New gain = %"PRIu32"\r\n", gainConfig.gain);
#endif
      }

      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
341982f0:	68fa      	ldr	r2, [r7, #12]
341982f2:	4b20      	ldr	r3, [pc, #128]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
341982f4:	681b      	ldr	r3, [r3, #0]
341982f6:	685b      	ldr	r3, [r3, #4]
341982f8:	429a      	cmp	r2, r3
341982fa:	d013      	beq.n	34198324 <ISP_Algo_AEC_Process+0x174>
      {
        /* Set new exposure */
        exposureConfig.exposure = pIspAEprocess->new_exposure;
341982fc:	4b1d      	ldr	r3, [pc, #116]	@ (34198374 <ISP_Algo_AEC_Process+0x1c4>)
341982fe:	681b      	ldr	r3, [r3, #0]
34198300:	685b      	ldr	r3, [r3, #4]
34198302:	60fb      	str	r3, [r7, #12]

        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
34198304:	f107 030c 	add.w	r3, r7, #12
34198308:	4619      	mov	r1, r3
3419830a:	6878      	ldr	r0, [r7, #4]
3419830c:	f002 fbb0 	bl	3419aa70 <ISP_SVC_Sensor_SetExposure>
34198310:	4603      	mov	r3, r0
34198312:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
34198316:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3419831a:	2b00      	cmp	r3, #0
3419831c:	d002      	beq.n	34198324 <ISP_Algo_AEC_Process+0x174>
        {
          return ret;
3419831e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34198322:	e01e      	b.n	34198362 <ISP_Algo_AEC_Process+0x1b2>
      }
    }

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
                                ISP_STAT_TYPE_AVG, IQParamConfig->sensorDelay.delay);
34198324:	69fb      	ldr	r3, [r7, #28]
34198326:	f893 3255 	ldrb.w	r3, [r3, #597]	@ 0x255
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3419832a:	9302      	str	r3, [sp, #8]
3419832c:	2301      	movs	r3, #1
3419832e:	9301      	str	r3, [sp, #4]
34198330:	2302      	movs	r3, #2
34198332:	9300      	str	r3, [sp, #0]
34198334:	4b0d      	ldr	r3, [pc, #52]	@ (3419836c <ISP_Algo_AEC_Process+0x1bc>)
34198336:	683a      	ldr	r2, [r7, #0]
34198338:	490d      	ldr	r1, [pc, #52]	@ (34198370 <ISP_Algo_AEC_Process+0x1c0>)
3419833a:	6878      	ldr	r0, [r7, #4]
3419833c:	f003 f836 	bl	3419b3ac <ISP_SVC_Stats_GetNext>
34198340:	4603      	mov	r3, r0
34198342:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34198346:	6a3b      	ldr	r3, [r7, #32]
34198348:	2202      	movs	r2, #2
3419834a:	705a      	strb	r2, [r3, #1]
    break;
3419834c:	e007      	b.n	3419835e <ISP_Algo_AEC_Process+0x1ae>

  default:
    printf("WARNING: Unknown AE algo state\r\n");
3419834e:	480b      	ldr	r0, [pc, #44]	@ (3419837c <ISP_Algo_AEC_Process+0x1cc>)
34198350:	f00c ff9e 	bl	341a5290 <puts>
    /* Reset state to ISP_ALGO_STATE_INIT */
    algo->state = ISP_ALGO_STATE_INIT;
34198354:	6a3b      	ldr	r3, [r7, #32]
34198356:	2200      	movs	r2, #0
34198358:	705a      	strb	r2, [r3, #1]
    break;
3419835a:	e000      	b.n	3419835e <ISP_Algo_AEC_Process+0x1ae>
    break;
3419835c:	bf00      	nop

  }

  return ret;
3419835e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
34198362:	4618      	mov	r0, r3
34198364:	3728      	adds	r7, #40	@ 0x28
34198366:	46bd      	mov	sp, r7
34198368:	bd80      	pop	{r7, pc}
3419836a:	bf00      	nop
3419836c:	341c1324 	.word	0x341c1324
34198370:	34198195 	.word	0x34198195
34198374:	341c12f8 	.word	0x341c12f8
34198378:	341c1304 	.word	0x341c1304
3419837c:	341a73a4 	.word	0x341a73a4

34198380 <ISP_Algo_ApplyGammaInverse>:
  * @param  hIsp:  ISP device handle.
  * @param  comp: component value
  * @retval gamma corrected value
  */
double ISP_Algo_ApplyGammaInverse(ISP_HandleTypeDef *hIsp, uint32_t comp)
{
34198380:	b580      	push	{r7, lr}
34198382:	b084      	sub	sp, #16
34198384:	af00      	add	r7, sp, #0
34198386:	6078      	str	r0, [r7, #4]
34198388:	6039      	str	r1, [r7, #0]
  double out;

  /* Check if gamma is enabled */
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
3419838a:	2101      	movs	r1, #1
3419838c:	6878      	ldr	r0, [r7, #4]
3419838e:	f002 fc1f 	bl	3419abd0 <ISP_SVC_Misc_IsGammaEnabled>
34198392:	4603      	mov	r3, r0
34198394:	2b00      	cmp	r3, #0
34198396:	d019      	beq.n	341983cc <ISP_Algo_ApplyGammaInverse+0x4c>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
34198398:	683b      	ldr	r3, [r7, #0]
3419839a:	ee07 3a90 	vmov	s15, r3
3419839e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
341983a2:	eddf 6a17 	vldr	s13, [pc, #92]	@ 34198400 <ISP_Algo_ApplyGammaInverse+0x80>
341983a6:	eec7 7a26 	vdiv.f32	s15, s14, s13
341983aa:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
341983ae:	ed9f 1b10 	vldr	d1, [pc, #64]	@ 341983f0 <ISP_Algo_ApplyGammaInverse+0x70>
341983b2:	eeb0 0b47 	vmov.f64	d0, d7
341983b6:	f00e f8a7 	bl	341a6508 <pow>
341983ba:	eeb0 7b40 	vmov.f64	d7, d0
341983be:	ed9f 6b0e 	vldr	d6, [pc, #56]	@ 341983f8 <ISP_Algo_ApplyGammaInverse+0x78>
341983c2:	ee27 7b06 	vmul.f64	d7, d7, d6
341983c6:	ed87 7b02 	vstr	d7, [r7, #8]
341983ca:	e006      	b.n	341983da <ISP_Algo_ApplyGammaInverse+0x5a>
  }
  else
  {
    out = (double) comp;
341983cc:	683b      	ldr	r3, [r7, #0]
341983ce:	ee07 3a90 	vmov	s15, r3
341983d2:	eeb8 7b67 	vcvt.f64.u32	d7, s15
341983d6:	ed87 7b02 	vstr	d7, [r7, #8]
  }
  return out;
341983da:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
341983de:	ec43 2b17 	vmov	d7, r2, r3
}
341983e2:	eeb0 0b47 	vmov.f64	d0, d7
341983e6:	3710      	adds	r7, #16
341983e8:	46bd      	mov	sp, r7
341983ea:	bd80      	pop	{r7, pc}
341983ec:	f3af 8000 	nop.w
341983f0:	d1745d17 	.word	0xd1745d17
341983f4:	3fdd1745 	.word	0x3fdd1745
341983f8:	00000000 	.word	0x00000000
341983fc:	406fe000 	.word	0x406fe000
34198400:	437f0000 	.word	0x437f0000

34198404 <ISP_Algo_GetUpStat>:
  *         Recalculate average up statistics from collected down statistics
  * @param  hIsp:  ISP device handle.
  * @param  pStats: pointer to the statistics
  */
void ISP_Algo_GetUpStat(ISP_HandleTypeDef *hIsp, ISP_SVC_StatStateTypeDef *pStats)
{
34198404:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34198408:	b09a      	sub	sp, #104	@ 0x68
3419840a:	af00      	add	r7, sp, #0
3419840c:	6378      	str	r0, [r7, #52]	@ 0x34
3419840e:	6339      	str	r1, [r7, #48]	@ 0x30
  ISP_ISPGainTypeDef ISPGain;
  ISP_BlackLevelTypeDef BlackLevel;
  int64_t upR, upG, upB;

  if ((ISP_SVC_ISP_GetGain(hIsp, &ISPGain) == ISP_OK) && (ISPGain.enable == 1))
34198410:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34198414:	4619      	mov	r1, r3
34198416:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34198418:	f002 f95a 	bl	3419a6d0 <ISP_SVC_ISP_GetGain>
3419841c:	4603      	mov	r3, r0
3419841e:	2b00      	cmp	r3, #0
34198420:	f040 80a8 	bne.w	34198574 <ISP_Algo_GetUpStat+0x170>
34198424:	f897 3040 	ldrb.w	r3, [r7, #64]	@ 0x40
34198428:	2b01      	cmp	r3, #1
3419842a:	f040 80a3 	bne.w	34198574 <ISP_Algo_GetUpStat+0x170>
  {

    /* reverse gain */
    upR = (int64_t) pStats->down.averageR * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainR;
3419842e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198430:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
34198434:	b2db      	uxtb	r3, r3
34198436:	2200      	movs	r2, #0
34198438:	461c      	mov	r4, r3
3419843a:	4615      	mov	r5, r2
3419843c:	4b58      	ldr	r3, [pc, #352]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
3419843e:	fb03 f205 	mul.w	r2, r3, r5
34198442:	2300      	movs	r3, #0
34198444:	fb04 f303 	mul.w	r3, r4, r3
34198448:	441a      	add	r2, r3
3419844a:	4b55      	ldr	r3, [pc, #340]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
3419844c:	fba4 1303 	umull	r1, r3, r4, r3
34198450:	62fb      	str	r3, [r7, #44]	@ 0x2c
34198452:	460b      	mov	r3, r1
34198454:	62bb      	str	r3, [r7, #40]	@ 0x28
34198456:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34198458:	18d3      	adds	r3, r2, r3
3419845a:	62fb      	str	r3, [r7, #44]	@ 0x2c
3419845c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419845e:	2200      	movs	r2, #0
34198460:	623b      	str	r3, [r7, #32]
34198462:	627a      	str	r2, [r7, #36]	@ 0x24
34198464:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34198468:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
3419846c:	f7e9 f966 	bl	3418173c <__aeabi_ldivmod>
34198470:	4602      	mov	r2, r0
34198472:	460b      	mov	r3, r1
34198474:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
    upG = (int64_t) pStats->down.averageG * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainG;
34198478:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419847a:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
3419847e:	b2db      	uxtb	r3, r3
34198480:	2200      	movs	r2, #0
34198482:	61bb      	str	r3, [r7, #24]
34198484:	61fa      	str	r2, [r7, #28]
34198486:	4b46      	ldr	r3, [pc, #280]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
34198488:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
3419848c:	462a      	mov	r2, r5
3419848e:	fb03 f202 	mul.w	r2, r3, r2
34198492:	2300      	movs	r3, #0
34198494:	4621      	mov	r1, r4
34198496:	fb01 f303 	mul.w	r3, r1, r3
3419849a:	4413      	add	r3, r2
3419849c:	4a40      	ldr	r2, [pc, #256]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
3419849e:	4621      	mov	r1, r4
341984a0:	fba1 ab02 	umull	sl, fp, r1, r2
341984a4:	445b      	add	r3, fp
341984a6:	469b      	mov	fp, r3
341984a8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
341984aa:	2200      	movs	r2, #0
341984ac:	613b      	str	r3, [r7, #16]
341984ae:	617a      	str	r2, [r7, #20]
341984b0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
341984b4:	4650      	mov	r0, sl
341984b6:	4659      	mov	r1, fp
341984b8:	f7e9 f940 	bl	3418173c <__aeabi_ldivmod>
341984bc:	4602      	mov	r2, r0
341984be:	460b      	mov	r3, r1
341984c0:	e9c7 2316 	strd	r2, r3, [r7, #88]	@ 0x58
    upB = (int64_t) pStats->down.averageB * ISP_GAIN_PRECISION_FACTOR / ISPGain.ispGainB;
341984c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
341984c6:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
341984ca:	b2db      	uxtb	r3, r3
341984cc:	2200      	movs	r2, #0
341984ce:	60bb      	str	r3, [r7, #8]
341984d0:	60fa      	str	r2, [r7, #12]
341984d2:	4b33      	ldr	r3, [pc, #204]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
341984d4:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
341984d8:	462a      	mov	r2, r5
341984da:	fb03 f202 	mul.w	r2, r3, r2
341984de:	2300      	movs	r3, #0
341984e0:	4621      	mov	r1, r4
341984e2:	fb01 f303 	mul.w	r3, r1, r3
341984e6:	4413      	add	r3, r2
341984e8:	4a2d      	ldr	r2, [pc, #180]	@ (341985a0 <ISP_Algo_GetUpStat+0x19c>)
341984ea:	4621      	mov	r1, r4
341984ec:	fba1 8902 	umull	r8, r9, r1, r2
341984f0:	444b      	add	r3, r9
341984f2:	4699      	mov	r9, r3
341984f4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
341984f6:	2200      	movs	r2, #0
341984f8:	603b      	str	r3, [r7, #0]
341984fa:	607a      	str	r2, [r7, #4]
341984fc:	e9d7 2300 	ldrd	r2, r3, [r7]
34198500:	4640      	mov	r0, r8
34198502:	4649      	mov	r1, r9
34198504:	f7e9 f91a 	bl	3418173c <__aeabi_ldivmod>
34198508:	4602      	mov	r2, r0
3419850a:	460b      	mov	r3, r1
3419850c:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50

    pStats->up.averageR = (uint8_t) upR;
34198510:	f897 2060 	ldrb.w	r2, [r7, #96]	@ 0x60
34198514:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198516:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG = (uint8_t) upG;
34198518:	f897 2058 	ldrb.w	r2, [r7, #88]	@ 0x58
3419851c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419851e:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB = (uint8_t) upB;
34198520:	f897 2050 	ldrb.w	r2, [r7, #80]	@ 0x50
34198524:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198526:	709a      	strb	r2, [r3, #2]

    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
34198528:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
3419852c:	4619      	mov	r1, r3
3419852e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34198530:	f002 f836 	bl	3419a5a0 <ISP_SVC_ISP_GetBlackLevel>
34198534:	4603      	mov	r3, r0
34198536:	2b00      	cmp	r3, #0
34198538:	d12c      	bne.n	34198594 <ISP_Algo_GetUpStat+0x190>
3419853a:	f897 303c 	ldrb.w	r3, [r7, #60]	@ 0x3c
3419853e:	2b01      	cmp	r3, #1
34198540:	d128      	bne.n	34198594 <ISP_Algo_GetUpStat+0x190>
    {
        /* reverse black level */
    pStats->up.averageR += BlackLevel.BLCR;
34198542:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198544:	781a      	ldrb	r2, [r3, #0]
34198546:	f897 303d 	ldrb.w	r3, [r7, #61]	@ 0x3d
3419854a:	4413      	add	r3, r2
3419854c:	b2da      	uxtb	r2, r3
3419854e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198550:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG += BlackLevel.BLCG;
34198552:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198554:	785a      	ldrb	r2, [r3, #1]
34198556:	f897 303e 	ldrb.w	r3, [r7, #62]	@ 0x3e
3419855a:	4413      	add	r3, r2
3419855c:	b2da      	uxtb	r2, r3
3419855e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198560:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB += BlackLevel.BLCB;
34198562:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198564:	789a      	ldrb	r2, [r3, #2]
34198566:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
3419856a:	4413      	add	r3, r2
3419856c:	b2da      	uxtb	r2, r3
3419856e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198570:	709a      	strb	r2, [r3, #2]
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
34198572:	e00f      	b.n	34198594 <ISP_Algo_GetUpStat+0x190>
    }
  }
  else
  {
    pStats->up.averageR = pStats->down.averageR;
34198574:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198576:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
3419857a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419857c:	701a      	strb	r2, [r3, #0]
    pStats->up.averageG = pStats->down.averageG;
3419857e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198580:	f893 2035 	ldrb.w	r2, [r3, #53]	@ 0x35
34198584:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198586:	705a      	strb	r2, [r3, #1]
    pStats->up.averageB = pStats->down.averageB;
34198588:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3419858a:	f893 2036 	ldrb.w	r2, [r3, #54]	@ 0x36
3419858e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34198590:	709a      	strb	r2, [r3, #2]
  }
}
34198592:	e000      	b.n	34198596 <ISP_Algo_GetUpStat+0x192>
    if ((ISP_SVC_ISP_GetBlackLevel(hIsp, &BlackLevel) == ISP_OK) && (BlackLevel.enable == 1))
34198594:	bf00      	nop
}
34198596:	bf00      	nop
34198598:	3768      	adds	r7, #104	@ 0x68
3419859a:	46bd      	mov	sp, r7
3419859c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
341985a0:	05f5e100 	.word	0x05f5e100
341985a4:	00000000 	.word	0x00000000

341985a8 <ISP_Algo_ApplyCConv>:
  * @param  outG: pointer to Green component value after color conversion
  * @param  outB: pointer to Blue component value after color conversion
  * @retval None
  */
void ISP_Algo_ApplyCConv(ISP_HandleTypeDef *hIsp, uint32_t inR, uint32_t inG, uint32_t inB, uint32_t *outR, uint32_t *outG, uint32_t *outB)
{
341985a8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
341985ac:	b0d0      	sub	sp, #320	@ 0x140
341985ae:	af00      	add	r7, sp, #0
341985b0:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
341985b4:	f8c7 10f8 	str.w	r1, [r7, #248]	@ 0xf8
341985b8:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
341985bc:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  ISP_ColorConvTypeDef colorConv;
  int64_t ccR, ccG, ccB;

  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
341985c0:	f507 7380 	add.w	r3, r7, #256	@ 0x100
341985c4:	4619      	mov	r1, r3
341985c6:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
341985ca:	f002 f977 	bl	3419a8bc <ISP_SVC_ISP_GetColorConv>
341985ce:	4603      	mov	r3, r0
341985d0:	2b00      	cmp	r3, #0
341985d2:	f040 8216 	bne.w	34198a02 <ISP_Algo_ApplyCConv+0x45a>
341985d6:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
341985da:	2b01      	cmp	r3, #1
341985dc:	f040 8211 	bne.w	34198a02 <ISP_Algo_ApplyCConv+0x45a>
  {
    /* Apply ColorConversion matrix to the input components */
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
341985e0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
341985e4:	2200      	movs	r2, #0
341985e6:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
341985ea:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
341985ee:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
341985f2:	17da      	asrs	r2, r3, #31
341985f4:	461c      	mov	r4, r3
341985f6:	4615      	mov	r5, r2
341985f8:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
341985fc:	460b      	mov	r3, r1
341985fe:	fb04 f203 	mul.w	r2, r4, r3
34198602:	4603      	mov	r3, r0
34198604:	fb03 f305 	mul.w	r3, r3, r5
34198608:	4413      	add	r3, r2
3419860a:	4602      	mov	r2, r0
3419860c:	fba2 ab04 	umull	sl, fp, r2, r4
34198610:	445b      	add	r3, fp
34198612:	469b      	mov	fp, r3
34198614:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
34198618:	2200      	movs	r2, #0
3419861a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
3419861e:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
34198622:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
34198626:	17da      	asrs	r2, r3, #31
34198628:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3419862c:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
34198630:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34198634:	460b      	mov	r3, r1
34198636:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
3419863a:	4622      	mov	r2, r4
3419863c:	fb02 f203 	mul.w	r2, r2, r3
34198640:	e9c7 453a 	strd	r4, r5, [r7, #232]	@ 0xe8
34198644:	462b      	mov	r3, r5
34198646:	4604      	mov	r4, r0
34198648:	460d      	mov	r5, r1
3419864a:	4621      	mov	r1, r4
3419864c:	fb01 f303 	mul.w	r3, r1, r3
34198650:	4413      	add	r3, r2
34198652:	4622      	mov	r2, r4
34198654:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
34198658:	fba2 8901 	umull	r8, r9, r2, r1
3419865c:	444b      	add	r3, r9
3419865e:	4699      	mov	r9, r3
34198660:	eb1a 0308 	adds.w	r3, sl, r8
34198664:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
34198668:	eb4b 0309 	adc.w	r3, fp, r9
3419866c:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34198670:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
34198674:	2200      	movs	r2, #0
34198676:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3419867a:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
3419867e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
34198682:	17da      	asrs	r2, r3, #31
34198684:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34198688:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
3419868c:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
34198690:	462b      	mov	r3, r5
34198692:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	@ 0x88
34198696:	4642      	mov	r2, r8
34198698:	fb02 f203 	mul.w	r2, r2, r3
3419869c:	464b      	mov	r3, r9
3419869e:	4621      	mov	r1, r4
341986a0:	fb01 f303 	mul.w	r3, r1, r3
341986a4:	4413      	add	r3, r2
341986a6:	4622      	mov	r2, r4
341986a8:	4641      	mov	r1, r8
341986aa:	fba2 1201 	umull	r1, r2, r2, r1
341986ae:	f8c7 20e4 	str.w	r2, [r7, #228]	@ 0xe4
341986b2:	460a      	mov	r2, r1
341986b4:	f8c7 20e0 	str.w	r2, [r7, #224]	@ 0xe0
341986b8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
341986bc:	4413      	add	r3, r2
341986be:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
341986c2:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
341986c6:	4623      	mov	r3, r4
341986c8:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
341986cc:	4602      	mov	r2, r0
341986ce:	189b      	adds	r3, r3, r2
341986d0:	613b      	str	r3, [r7, #16]
341986d2:	460b      	mov	r3, r1
341986d4:	462a      	mov	r2, r5
341986d6:	eb42 0303 	adc.w	r3, r2, r3
341986da:	617b      	str	r3, [r7, #20]
341986dc:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
341986e0:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
341986e4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
341986e8:	2200      	movs	r2, #0
341986ea:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
341986ee:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
341986f2:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
341986f6:	17da      	asrs	r2, r3, #31
341986f8:	67bb      	str	r3, [r7, #120]	@ 0x78
341986fa:	67fa      	str	r2, [r7, #124]	@ 0x7c
341986fc:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
34198700:	462b      	mov	r3, r5
34198702:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
34198706:	4642      	mov	r2, r8
34198708:	fb02 f203 	mul.w	r2, r2, r3
3419870c:	464b      	mov	r3, r9
3419870e:	4621      	mov	r1, r4
34198710:	fb01 f303 	mul.w	r3, r1, r3
34198714:	4413      	add	r3, r2
34198716:	4622      	mov	r2, r4
34198718:	4641      	mov	r1, r8
3419871a:	fba2 1201 	umull	r1, r2, r2, r1
3419871e:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
34198722:	460a      	mov	r2, r1
34198724:	f8c7 20d8 	str.w	r2, [r7, #216]	@ 0xd8
34198728:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
3419872c:	4413      	add	r3, r2
3419872e:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
34198732:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
34198736:	2200      	movs	r2, #0
34198738:	673b      	str	r3, [r7, #112]	@ 0x70
3419873a:	677a      	str	r2, [r7, #116]	@ 0x74
3419873c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
34198740:	17da      	asrs	r2, r3, #31
34198742:	66bb      	str	r3, [r7, #104]	@ 0x68
34198744:	66fa      	str	r2, [r7, #108]	@ 0x6c
34198746:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
3419874a:	462b      	mov	r3, r5
3419874c:	e9d7 891a 	ldrd	r8, r9, [r7, #104]	@ 0x68
34198750:	4642      	mov	r2, r8
34198752:	fb02 f203 	mul.w	r2, r2, r3
34198756:	464b      	mov	r3, r9
34198758:	4621      	mov	r1, r4
3419875a:	fb01 f303 	mul.w	r3, r1, r3
3419875e:	4413      	add	r3, r2
34198760:	4622      	mov	r2, r4
34198762:	4641      	mov	r1, r8
34198764:	fba2 1201 	umull	r1, r2, r2, r1
34198768:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
3419876c:	460a      	mov	r2, r1
3419876e:	f8c7 20d0 	str.w	r2, [r7, #208]	@ 0xd0
34198772:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
34198776:	4413      	add	r3, r2
34198778:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3419877c:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
34198780:	4623      	mov	r3, r4
34198782:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
34198786:	4602      	mov	r2, r0
34198788:	189b      	adds	r3, r3, r2
3419878a:	663b      	str	r3, [r7, #96]	@ 0x60
3419878c:	460b      	mov	r3, r1
3419878e:	462a      	mov	r2, r5
34198790:	eb42 0303 	adc.w	r3, r2, r3
34198794:	667b      	str	r3, [r7, #100]	@ 0x64
34198796:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
3419879a:	2200      	movs	r2, #0
3419879c:	65bb      	str	r3, [r7, #88]	@ 0x58
3419879e:	65fa      	str	r2, [r7, #92]	@ 0x5c
341987a0:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
341987a4:	17da      	asrs	r2, r3, #31
341987a6:	653b      	str	r3, [r7, #80]	@ 0x50
341987a8:	657a      	str	r2, [r7, #84]	@ 0x54
341987aa:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
341987ae:	462b      	mov	r3, r5
341987b0:	e9d7 8914 	ldrd	r8, r9, [r7, #80]	@ 0x50
341987b4:	4642      	mov	r2, r8
341987b6:	fb02 f203 	mul.w	r2, r2, r3
341987ba:	464b      	mov	r3, r9
341987bc:	4621      	mov	r1, r4
341987be:	fb01 f303 	mul.w	r3, r1, r3
341987c2:	4413      	add	r3, r2
341987c4:	4622      	mov	r2, r4
341987c6:	4641      	mov	r1, r8
341987c8:	fba2 1201 	umull	r1, r2, r2, r1
341987cc:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
341987d0:	460a      	mov	r2, r1
341987d2:	f8c7 20c8 	str.w	r2, [r7, #200]	@ 0xc8
341987d6:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
341987da:	4413      	add	r3, r2
341987dc:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
341987e0:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
341987e4:	4623      	mov	r3, r4
341987e6:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
341987ea:	4602      	mov	r2, r0
341987ec:	189b      	adds	r3, r3, r2
341987ee:	60bb      	str	r3, [r7, #8]
341987f0:	460b      	mov	r3, r1
341987f2:	462a      	mov	r2, r5
341987f4:	eb42 0303 	adc.w	r3, r2, r3
341987f8:	60fb      	str	r3, [r7, #12]
341987fa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
341987fe:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
34198802:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
34198806:	2200      	movs	r2, #0
34198808:	64bb      	str	r3, [r7, #72]	@ 0x48
3419880a:	64fa      	str	r2, [r7, #76]	@ 0x4c
3419880c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
34198810:	17da      	asrs	r2, r3, #31
34198812:	643b      	str	r3, [r7, #64]	@ 0x40
34198814:	647a      	str	r2, [r7, #68]	@ 0x44
34198816:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
3419881a:	462b      	mov	r3, r5
3419881c:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	@ 0x40
34198820:	4642      	mov	r2, r8
34198822:	fb02 f203 	mul.w	r2, r2, r3
34198826:	464b      	mov	r3, r9
34198828:	4621      	mov	r1, r4
3419882a:	fb01 f303 	mul.w	r3, r1, r3
3419882e:	4413      	add	r3, r2
34198830:	4622      	mov	r2, r4
34198832:	4641      	mov	r1, r8
34198834:	fba2 1201 	umull	r1, r2, r2, r1
34198838:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
3419883c:	460a      	mov	r2, r1
3419883e:	f8c7 20c0 	str.w	r2, [r7, #192]	@ 0xc0
34198842:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
34198846:	4413      	add	r3, r2
34198848:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3419884c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
34198850:	2200      	movs	r2, #0
34198852:	63bb      	str	r3, [r7, #56]	@ 0x38
34198854:	63fa      	str	r2, [r7, #60]	@ 0x3c
34198856:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
3419885a:	17da      	asrs	r2, r3, #31
3419885c:	633b      	str	r3, [r7, #48]	@ 0x30
3419885e:	637a      	str	r2, [r7, #52]	@ 0x34
34198860:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
34198864:	462b      	mov	r3, r5
34198866:	e9d7 890c 	ldrd	r8, r9, [r7, #48]	@ 0x30
3419886a:	4642      	mov	r2, r8
3419886c:	fb02 f203 	mul.w	r2, r2, r3
34198870:	464b      	mov	r3, r9
34198872:	4621      	mov	r1, r4
34198874:	fb01 f303 	mul.w	r3, r1, r3
34198878:	4413      	add	r3, r2
3419887a:	4622      	mov	r2, r4
3419887c:	4641      	mov	r1, r8
3419887e:	fba2 1201 	umull	r1, r2, r2, r1
34198882:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
34198886:	460a      	mov	r2, r1
34198888:	f8c7 20b8 	str.w	r2, [r7, #184]	@ 0xb8
3419888c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
34198890:	4413      	add	r3, r2
34198892:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34198896:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	@ 0xc0
3419889a:	4623      	mov	r3, r4
3419889c:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
341988a0:	4602      	mov	r2, r0
341988a2:	189b      	adds	r3, r3, r2
341988a4:	62bb      	str	r3, [r7, #40]	@ 0x28
341988a6:	460b      	mov	r3, r1
341988a8:	462a      	mov	r2, r5
341988aa:	eb42 0303 	adc.w	r3, r2, r3
341988ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
341988b0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
341988b4:	2200      	movs	r2, #0
341988b6:	623b      	str	r3, [r7, #32]
341988b8:	627a      	str	r2, [r7, #36]	@ 0x24
341988ba:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
341988be:	17da      	asrs	r2, r3, #31
341988c0:	61bb      	str	r3, [r7, #24]
341988c2:	61fa      	str	r2, [r7, #28]
341988c4:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
341988c8:	462b      	mov	r3, r5
341988ca:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
341988ce:	4642      	mov	r2, r8
341988d0:	fb02 f203 	mul.w	r2, r2, r3
341988d4:	464b      	mov	r3, r9
341988d6:	4621      	mov	r1, r4
341988d8:	fb01 f303 	mul.w	r3, r1, r3
341988dc:	4413      	add	r3, r2
341988de:	4622      	mov	r2, r4
341988e0:	4641      	mov	r1, r8
341988e2:	fba2 1201 	umull	r1, r2, r2, r1
341988e6:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
341988ea:	460a      	mov	r2, r1
341988ec:	f8c7 20b0 	str.w	r2, [r7, #176]	@ 0xb0
341988f0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
341988f4:	4413      	add	r3, r2
341988f6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
341988fa:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
341988fe:	4623      	mov	r3, r4
34198900:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34198904:	4602      	mov	r2, r0
34198906:	189b      	adds	r3, r3, r2
34198908:	603b      	str	r3, [r7, #0]
3419890a:	460b      	mov	r3, r1
3419890c:	462a      	mov	r2, r5
3419890e:	eb42 0303 	adc.w	r3, r2, r3
34198912:	607b      	str	r3, [r7, #4]
34198914:	e9d7 2300 	ldrd	r2, r3, [r7]
34198918:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    ccR /= ISP_CCM_PRECISION_FACTOR;
3419891c:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34198920:	a343      	add	r3, pc, #268	@ (adr r3, 34198a30 <ISP_Algo_ApplyCConv+0x488>)
34198922:	e9d3 2300 	ldrd	r2, r3, [r3]
34198926:	f7e8 ff09 	bl	3418173c <__aeabi_ldivmod>
3419892a:	4602      	mov	r2, r0
3419892c:	460b      	mov	r3, r1
3419892e:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG /= ISP_CCM_PRECISION_FACTOR;
34198932:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34198936:	a33e      	add	r3, pc, #248	@ (adr r3, 34198a30 <ISP_Algo_ApplyCConv+0x488>)
34198938:	e9d3 2300 	ldrd	r2, r3, [r3]
3419893c:	f7e8 fefe 	bl	3418173c <__aeabi_ldivmod>
34198940:	4602      	mov	r2, r0
34198942:	460b      	mov	r3, r1
34198944:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB /= ISP_CCM_PRECISION_FACTOR;
34198948:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
3419894c:	a338      	add	r3, pc, #224	@ (adr r3, 34198a30 <ISP_Algo_ApplyCConv+0x488>)
3419894e:	e9d3 2300 	ldrd	r2, r3, [r3]
34198952:	f7e8 fef3 	bl	3418173c <__aeabi_ldivmod>
34198956:	4602      	mov	r2, r0
34198958:	460b      	mov	r3, r1
3419895a:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    /* Clamp values to 0-255 */
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3419895e:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
34198962:	2b00      	cmp	r3, #0
34198964:	db0b      	blt.n	3419897e <ISP_Algo_ApplyCConv+0x3d6>
34198966:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
3419896a:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3419896e:	f173 0100 	sbcs.w	r1, r3, #0
34198972:	db08      	blt.n	34198986 <ISP_Algo_ApplyCConv+0x3de>
34198974:	f04f 02ff 	mov.w	r2, #255	@ 0xff
34198978:	f04f 0300 	mov.w	r3, #0
3419897c:	e003      	b.n	34198986 <ISP_Algo_ApplyCConv+0x3de>
3419897e:	f04f 0200 	mov.w	r2, #0
34198982:	f04f 0300 	mov.w	r3, #0
34198986:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
3419898a:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
3419898e:	2b00      	cmp	r3, #0
34198990:	db0b      	blt.n	341989aa <ISP_Algo_ApplyCConv+0x402>
34198992:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
34198996:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3419899a:	f173 0100 	sbcs.w	r1, r3, #0
3419899e:	db08      	blt.n	341989b2 <ISP_Algo_ApplyCConv+0x40a>
341989a0:	f04f 02ff 	mov.w	r2, #255	@ 0xff
341989a4:	f04f 0300 	mov.w	r3, #0
341989a8:	e003      	b.n	341989b2 <ISP_Algo_ApplyCConv+0x40a>
341989aa:	f04f 0200 	mov.w	r2, #0
341989ae:	f04f 0300 	mov.w	r3, #0
341989b2:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
341989b6:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
341989ba:	2b00      	cmp	r3, #0
341989bc:	db0b      	blt.n	341989d6 <ISP_Algo_ApplyCConv+0x42e>
341989be:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
341989c2:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
341989c6:	f173 0100 	sbcs.w	r1, r3, #0
341989ca:	db08      	blt.n	341989de <ISP_Algo_ApplyCConv+0x436>
341989cc:	f04f 02ff 	mov.w	r2, #255	@ 0xff
341989d0:	f04f 0300 	mov.w	r3, #0
341989d4:	e003      	b.n	341989de <ISP_Algo_ApplyCConv+0x436>
341989d6:	f04f 0200 	mov.w	r2, #0
341989da:	f04f 0300 	mov.w	r3, #0
341989de:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    *outR = (uint32_t) ccR;
341989e2:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
341989e6:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
341989ea:	601a      	str	r2, [r3, #0]
    *outG = (uint32_t) ccG;
341989ec:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
341989f0:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
341989f4:	601a      	str	r2, [r3, #0]
    *outB = (uint32_t) ccB;
341989f6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
341989fa:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
341989fe:	601a      	str	r2, [r3, #0]
34198a00:	e00f      	b.n	34198a22 <ISP_Algo_ApplyCConv+0x47a>
  }
  else
  {
    *outR = inR;
34198a02:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
34198a06:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
34198a0a:	601a      	str	r2, [r3, #0]
    *outG = inG;
34198a0c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
34198a10:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
34198a14:	601a      	str	r2, [r3, #0]
    *outB = inB;
34198a16:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
34198a1a:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
34198a1e:	601a      	str	r2, [r3, #0]
  }
}
34198a20:	bf00      	nop
34198a22:	bf00      	nop
34198a24:	f507 77a0 	add.w	r7, r7, #320	@ 0x140
34198a28:	46bd      	mov	sp, r7
34198a2a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34198a2e:	bf00      	nop
34198a30:	05f5e100 	.word	0x05f5e100
34198a34:	00000000 	.word	0x00000000

34198a38 <ISP_Algo_AWB_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Init(void *hIsp, void *pAlgo)
{
34198a38:	b580      	push	{r7, lr}
34198a3a:	b084      	sub	sp, #16
34198a3c:	af00      	add	r7, sp, #0
34198a3e:	6078      	str	r0, [r7, #4]
34198a40:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34198a42:	683b      	ldr	r3, [r7, #0]
34198a44:	60fb      	str	r3, [r7, #12]

  /* Create estimator */
  pIspAWBestimator = evision_api_awb_new(log_cb);
34198a46:	480a      	ldr	r0, [pc, #40]	@ (34198a70 <ISP_Algo_AWB_Init+0x38>)
34198a48:	f7e8 f915 	bl	34180c76 <evision_api_awb_new>
34198a4c:	4603      	mov	r3, r0
34198a4e:	4a09      	ldr	r2, [pc, #36]	@ (34198a74 <ISP_Algo_AWB_Init+0x3c>)
34198a50:	6013      	str	r3, [r2, #0]
  if (pIspAWBestimator == NULL)
34198a52:	4b08      	ldr	r3, [pc, #32]	@ (34198a74 <ISP_Algo_AWB_Init+0x3c>)
34198a54:	681b      	ldr	r3, [r3, #0]
34198a56:	2b00      	cmp	r3, #0
34198a58:	d101      	bne.n	34198a5e <ISP_Algo_AWB_Init+0x26>
  {
    return ISP_ERR_ALGO;
34198a5a:	23be      	movs	r3, #190	@ 0xbe
34198a5c:	e003      	b.n	34198a66 <ISP_Algo_AWB_Init+0x2e>
  }

  /* Continue the initialization in ISP_Algo_AWB_Process() function when state is ISP_ALGO_STATE_INIT.
   * This allows to read the IQ params after an algo stop/start cycle */
  algo->state = ISP_ALGO_STATE_INIT;
34198a5e:	68fb      	ldr	r3, [r7, #12]
34198a60:	2200      	movs	r2, #0
34198a62:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
34198a64:	2300      	movs	r3, #0
}
34198a66:	4618      	mov	r0, r3
34198a68:	3710      	adds	r7, #16
34198a6a:	46bd      	mov	sp, r7
34198a6c:	bd80      	pop	{r7, pc}
34198a6e:	bf00      	nop
34198a70:	34197fc5 	.word	0x34197fc5
34198a74:	341c12fc 	.word	0x341c12fc

34198a78 <ISP_Algo_AWB_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_DeInit(void *hIsp, void *pAlgo)
{
34198a78:	b580      	push	{r7, lr}
34198a7a:	b082      	sub	sp, #8
34198a7c:	af00      	add	r7, sp, #0
34198a7e:	6078      	str	r0, [r7, #4]
34198a80:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAWBestimator != NULL)
34198a82:	4b07      	ldr	r3, [pc, #28]	@ (34198aa0 <ISP_Algo_AWB_DeInit+0x28>)
34198a84:	681b      	ldr	r3, [r3, #0]
34198a86:	2b00      	cmp	r3, #0
34198a88:	d004      	beq.n	34198a94 <ISP_Algo_AWB_DeInit+0x1c>
  {
    evision_api_awb_delete(pIspAWBestimator);
34198a8a:	4b05      	ldr	r3, [pc, #20]	@ (34198aa0 <ISP_Algo_AWB_DeInit+0x28>)
34198a8c:	681b      	ldr	r3, [r3, #0]
34198a8e:	4618      	mov	r0, r3
34198a90:	f7e8 f90c 	bl	34180cac <evision_api_awb_delete>
  }

  return ISP_OK;
34198a94:	2300      	movs	r3, #0
}
34198a96:	4618      	mov	r0, r3
34198a98:	3708      	adds	r7, #8
34198a9a:	46bd      	mov	sp, r7
34198a9c:	bd80      	pop	{r7, pc}
34198a9e:	bf00      	nop
34198aa0:	341c12fc 	.word	0x341c12fc

34198aa4 <ISP_Algo_AWB_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
34198aa4:	b480      	push	{r7}
34198aa6:	b083      	sub	sp, #12
34198aa8:	af00      	add	r7, sp, #0
34198aaa:	6078      	str	r0, [r7, #4]
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
34198aac:	687b      	ldr	r3, [r7, #4]
34198aae:	785b      	ldrb	r3, [r3, #1]
34198ab0:	2b00      	cmp	r3, #0
34198ab2:	d002      	beq.n	34198aba <ISP_Algo_AWB_StatCb+0x16>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
34198ab4:	687b      	ldr	r3, [r7, #4]
34198ab6:	2203      	movs	r2, #3
34198ab8:	705a      	strb	r2, [r3, #1]
  }

  return ISP_OK;
34198aba:	2300      	movs	r3, #0
}
34198abc:	4618      	mov	r0, r3
34198abe:	370c      	adds	r7, #12
34198ac0:	46bd      	mov	sp, r7
34198ac2:	f85d 7b04 	ldr.w	r7, [sp], #4
34198ac6:	4770      	bx	lr

34198ac8 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
34198ac8:	b580      	push	{r7, lr}
34198aca:	b0b8      	sub	sp, #224	@ 0xe0
34198acc:	af04      	add	r7, sp, #16
34198ace:	6078      	str	r0, [r7, #4]
34198ad0:	6039      	str	r1, [r7, #0]
  static evision_awb_profile_t awbProfiles[ISP_AWB_COLORTEMP_REF];
  static float colorTempThresholds[ISP_AWB_COLORTEMP_REF - 1];
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_ColorConvTypeDef ColorConvConfig;
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
34198ad2:	683b      	ldr	r3, [r7, #0]
34198ad4:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
34198ad8:	2300      	movs	r3, #0
34198ada:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
34198ade:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34198ae2:	2200      	movs	r2, #0
34198ae4:	601a      	str	r2, [r3, #0]
34198ae6:	605a      	str	r2, [r3, #4]
34198ae8:	609a      	str	r2, [r3, #8]
  double meas[3];
  static uint32_t statsHistory[3][3] = { 0 };
  static uint32_t colorTempHistory[2] = { 0 };
  static uint8_t skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_INIT;
  uint8_t stat_has_changed = false;
34198aea:	2300      	movs	r3, #0
34198aec:	f887 30bb 	strb.w	r3, [r7, #187]	@ 0xbb

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34198af0:	6878      	ldr	r0, [r7, #4]
34198af2:	f002 f8f5 	bl	3419ace0 <ISP_SVC_IQParam_Get>
34198af6:	f8c7 00b0 	str.w	r0, [r7, #176]	@ 0xb0

  if (IQParamConfig->AWBAlgo.enable == false)
34198afa:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
34198afe:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
34198b02:	2b00      	cmp	r3, #0
34198b04:	d104      	bne.n	34198b10 <ISP_Algo_AWB_Process+0x48>
  {
    enableCurrent = false;
34198b06:	4bcc      	ldr	r3, [pc, #816]	@ (34198e38 <ISP_Algo_AWB_Process+0x370>)
34198b08:	2200      	movs	r2, #0
34198b0a:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
34198b0c:	2300      	movs	r3, #0
34198b0e:	e3a6      	b.n	3419925e <ISP_Algo_AWB_Process+0x796>
  }
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
34198b10:	4bc9      	ldr	r3, [pc, #804]	@ (34198e38 <ISP_Algo_AWB_Process+0x370>)
34198b12:	781b      	ldrb	r3, [r3, #0]
34198b14:	2b00      	cmp	r3, #0
34198b16:	d005      	beq.n	34198b24 <ISP_Algo_AWB_Process+0x5c>
34198b18:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
34198b1c:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
34198b20:	2bff      	cmp	r3, #255	@ 0xff
34198b22:	d111      	bne.n	34198b48 <ISP_Algo_AWB_Process+0x80>
  {
    /* Start or resume algo : set state to INIT in order to read the IQ params */
    algo->state = ISP_ALGO_STATE_INIT;
34198b24:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34198b28:	2200      	movs	r2, #0
34198b2a:	705a      	strb	r2, [r3, #1]
    IQParamConfig->AWBAlgo.enable = true;
34198b2c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
34198b30:	2201      	movs	r2, #1
34198b32:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
    reconfigureRequest = true;
34198b36:	4bc1      	ldr	r3, [pc, #772]	@ (34198e3c <ISP_Algo_AWB_Process+0x374>)
34198b38:	2201      	movs	r2, #1
34198b3a:	701a      	strb	r2, [r3, #0]
    enableCurrent = true;
34198b3c:	4bbe      	ldr	r3, [pc, #760]	@ (34198e38 <ISP_Algo_AWB_Process+0x370>)
34198b3e:	2201      	movs	r2, #1
34198b40:	701a      	strb	r2, [r3, #0]
    skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
34198b42:	4bbf      	ldr	r3, [pc, #764]	@ (34198e40 <ISP_Algo_AWB_Process+0x378>)
34198b44:	2206      	movs	r2, #6
34198b46:	701a      	strb	r2, [r3, #0]
  }

  switch(algo->state)
34198b48:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34198b4c:	785b      	ldrb	r3, [r3, #1]
34198b4e:	2b03      	cmp	r3, #3
34198b50:	f200 837a 	bhi.w	34199248 <ISP_Algo_AWB_Process+0x780>
34198b54:	a201      	add	r2, pc, #4	@ (adr r2, 34198b5c <ISP_Algo_AWB_Process+0x94>)
34198b56:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34198b5a:	bf00      	nop
34198b5c:	34198b6d 	.word	0x34198b6d
34198b60:	34198e65 	.word	0x34198e65
34198b64:	34199259 	.word	0x34199259
34198b68:	34198e9b 	.word	0x34198e9b
  {
  case ISP_ALGO_STATE_INIT:
    profNb = 0;
34198b6c:	2300      	movs	r3, #0
34198b6e:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

    /* Reset color temperature history */
    for (i = 0; i < 2; i++)
34198b72:	2300      	movs	r3, #0
34198b74:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198b78:	e00a      	b.n	34198b90 <ISP_Algo_AWB_Process+0xc8>
    {
      colorTempHistory[i] = 0;
34198b7a:	4ab2      	ldr	r2, [pc, #712]	@ (34198e44 <ISP_Algo_AWB_Process+0x37c>)
34198b7c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198b80:	2100      	movs	r1, #0
34198b82:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (i = 0; i < 2; i++)
34198b86:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198b8a:	3301      	adds	r3, #1
34198b8c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198b90:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198b94:	2b01      	cmp	r3, #1
34198b96:	d9f0      	bls.n	34198b7a <ISP_Algo_AWB_Process+0xb2>
    }

    /* Set profiles (color temperature, gains, color conv matrix) */
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34198b98:	2300      	movs	r3, #0
34198b9a:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34198b9e:	e0cc      	b.n	34198d3a <ISP_Algo_AWB_Process+0x272>
    {
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
34198ba0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198ba4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198ba8:	3344      	adds	r3, #68	@ 0x44
34198baa:	009b      	lsls	r3, r3, #2
34198bac:	4413      	add	r3, r2
34198bae:	689b      	ldr	r3, [r3, #8]
34198bb0:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
      if (colorTemp == 0)
34198bb4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
34198bb8:	2b00      	cmp	r3, #0
34198bba:	f000 80c4 	beq.w	34198d46 <ISP_Algo_AWB_Process+0x27e>
        break;

      if (profNb > 0)
34198bbe:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198bc2:	2b00      	cmp	r3, #0
34198bc4:	d01b      	beq.n	34198bfe <ISP_Algo_AWB_Process+0x136>
      {
        /* Profile decision threshold = lowest ref. temperature + 1/4 of the distance between two reference temperatures */
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
34198bc6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198bca:	3b01      	subs	r3, #1
34198bcc:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198bd0:	3344      	adds	r3, #68	@ 0x44
34198bd2:	009b      	lsls	r3, r3, #2
34198bd4:	4413      	add	r3, r2
34198bd6:	689a      	ldr	r2, [r3, #8]
34198bd8:	4613      	mov	r3, r2
34198bda:	005b      	lsls	r3, r3, #1
34198bdc:	441a      	add	r2, r3
34198bde:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
34198be2:	4413      	add	r3, r2
34198be4:	089a      	lsrs	r2, r3, #2
34198be6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198bea:	3b01      	subs	r3, #1
34198bec:	ee07 2a90 	vmov	s15, r2
34198bf0:	eef8 7a67 	vcvt.f32.u32	s15, s15
34198bf4:	4a94      	ldr	r2, [pc, #592]	@ (34198e48 <ISP_Algo_AWB_Process+0x380>)
34198bf6:	009b      	lsls	r3, r3, #2
34198bf8:	4413      	add	r3, r2
34198bfa:	edc3 7a00 	vstr	s15, [r3]
      }

      /* Set cfa gains (RGGB) */
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
34198bfe:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198c02:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198c06:	334a      	adds	r3, #74	@ 0x4a
34198c08:	009b      	lsls	r3, r3, #2
34198c0a:	4413      	add	r3, r2
34198c0c:	685b      	ldr	r3, [r3, #4]
34198c0e:	ee07 3a90 	vmov	s15, r3
34198c12:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34198c16:	eddf 6a8d 	vldr	s13, [pc, #564]	@ 34198e4c <ISP_Algo_AWB_Process+0x384>
34198c1a:	eec7 7a26 	vdiv.f32	s15, s14, s13
34198c1e:	edc7 7a15 	vstr	s15, [r7, #84]	@ 0x54
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
34198c22:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198c26:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198c2a:	334e      	adds	r3, #78	@ 0x4e
34198c2c:	009b      	lsls	r3, r3, #2
34198c2e:	4413      	add	r3, r2
34198c30:	689b      	ldr	r3, [r3, #8]
34198c32:	ee07 3a90 	vmov	s15, r3
34198c36:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34198c3a:	eddf 6a84 	vldr	s13, [pc, #528]	@ 34198e4c <ISP_Algo_AWB_Process+0x384>
34198c3e:	eec7 7a26 	vdiv.f32	s15, s14, s13
34198c42:	edc7 7a16 	vstr	s15, [r7, #88]	@ 0x58
      cfaGains[2] = cfaGains[1];
34198c46:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34198c48:	65fb      	str	r3, [r7, #92]	@ 0x5c
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
34198c4a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198c4e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198c52:	3354      	adds	r3, #84	@ 0x54
34198c54:	009b      	lsls	r3, r3, #2
34198c56:	4413      	add	r3, r2
34198c58:	685b      	ldr	r3, [r3, #4]
34198c5a:	ee07 3a90 	vmov	s15, r3
34198c5e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34198c62:	eddf 6a7a 	vldr	s13, [pc, #488]	@ 34198e4c <ISP_Algo_AWB_Process+0x384>
34198c66:	eec7 7a26 	vdiv.f32	s15, s14, s13
34198c6a:	edc7 7a18 	vstr	s15, [r7, #96]	@ 0x60

      /* Set CCM Coeff */
      for (i = 0; i < 3; i++)
34198c6e:	2300      	movs	r3, #0
34198c70:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198c74:	e03b      	b.n	34198cee <ISP_Algo_AWB_Process+0x226>
      {
        for (j = 0; j < 3; j++)
34198c76:	2300      	movs	r3, #0
34198c78:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34198c7c:	e02e      	b.n	34198cdc <ISP_Algo_AWB_Process+0x214>
        {
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
34198c7e:	f8d7 00b0 	ldr.w	r0, [r7, #176]	@ 0xb0
34198c82:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198c86:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
34198c8a:	461a      	mov	r2, r3
34198c8c:	0052      	lsls	r2, r2, #1
34198c8e:	441a      	add	r2, r3
34198c90:	460b      	mov	r3, r1
34198c92:	00db      	lsls	r3, r3, #3
34198c94:	440b      	add	r3, r1
34198c96:	441a      	add	r2, r3
34198c98:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
34198c9c:	4413      	add	r3, r2
34198c9e:	3358      	adds	r3, #88	@ 0x58
34198ca0:	009b      	lsls	r3, r3, #2
34198ca2:	4403      	add	r3, r0
34198ca4:	689b      	ldr	r3, [r3, #8]
34198ca6:	ee07 3a90 	vmov	s15, r3
34198caa:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
34198cae:	eddf 6a67 	vldr	s13, [pc, #412]	@ 34198e4c <ISP_Algo_AWB_Process+0x384>
34198cb2:	eec7 7a26 	vdiv.f32	s15, s14, s13
34198cb6:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34198cba:	4613      	mov	r3, r2
34198cbc:	005b      	lsls	r3, r3, #1
34198cbe:	4413      	add	r3, r2
34198cc0:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
34198cc4:	4413      	add	r3, r2
34198cc6:	009b      	lsls	r3, r3, #2
34198cc8:	33d0      	adds	r3, #208	@ 0xd0
34198cca:	443b      	add	r3, r7
34198ccc:	3ba0      	subs	r3, #160	@ 0xa0
34198cce:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < 3; j++)
34198cd2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
34198cd6:	3301      	adds	r3, #1
34198cd8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34198cdc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
34198ce0:	2b02      	cmp	r3, #2
34198ce2:	d9cc      	bls.n	34198c7e <ISP_Algo_AWB_Process+0x1b6>
      for (i = 0; i < 3; i++)
34198ce4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198ce8:	3301      	adds	r3, #1
34198cea:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198cee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198cf2:	2b02      	cmp	r3, #2
34198cf4:	d9bf      	bls.n	34198c76 <ISP_Algo_AWB_Process+0x1ae>
        }
      }

      /* Set profile */
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
34198cf6:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
34198cfa:	4613      	mov	r3, r2
34198cfc:	011b      	lsls	r3, r3, #4
34198cfe:	4413      	add	r3, r2
34198d00:	009b      	lsls	r3, r3, #2
34198d02:	4a53      	ldr	r2, [pc, #332]	@ (34198e50 <ISP_Algo_AWB_Process+0x388>)
34198d04:	1898      	adds	r0, r3, r2
34198d06:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
34198d0a:	ee07 3a90 	vmov	s15, r3
34198d0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
34198d12:	f107 0324 	add.w	r3, r7, #36	@ 0x24
34198d16:	f107 0230 	add.w	r2, r7, #48	@ 0x30
34198d1a:	f107 0154 	add.w	r1, r7, #84	@ 0x54
34198d1e:	eeb0 0a67 	vmov.f32	s0, s15
34198d22:	f7e7 ffc9 	bl	34180cb8 <evision_api_awb_set_profile>
      profNb++;
34198d26:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198d2a:	3301      	adds	r3, #1
34198d2c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
34198d30:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198d34:	3301      	adds	r3, #1
34198d36:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34198d3a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34198d3e:	2b04      	cmp	r3, #4
34198d40:	f67f af2e 	bls.w	34198ba0 <ISP_Algo_AWB_Process+0xd8>
34198d44:	e000      	b.n	34198d48 <ISP_Algo_AWB_Process+0x280>
        break;
34198d46:	bf00      	nop
    }

    if (profNb == 0)
34198d48:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198d4c:	2b00      	cmp	r3, #0
34198d4e:	d101      	bne.n	34198d54 <ISP_Algo_AWB_Process+0x28c>
    {
      return ISP_ERR_WB_COLORTEMP;
34198d50:	2396      	movs	r3, #150	@ 0x96
34198d52:	e284      	b.n	3419925e <ISP_Algo_AWB_Process+0x796>
    }

    /* Register profiles */
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
34198d54:	4b3f      	ldr	r3, [pc, #252]	@ (34198e54 <ISP_Algo_AWB_Process+0x38c>)
34198d56:	6818      	ldr	r0, [r3, #0]
34198d58:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
34198d5c:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34198d60:	ee07 3a90 	vmov	s15, r3
34198d64:	eeb8 7b67 	vcvt.f64.u32	d7, s15
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], (uint16_t)profNb,
34198d68:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198d6c:	3b01      	subs	r3, #1
34198d6e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34198d72:	3344      	adds	r3, #68	@ 0x44
34198d74:	009b      	lsls	r3, r3, #2
34198d76:	4413      	add	r3, r2
34198d78:	689b      	ldr	r3, [r3, #8]
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
34198d7a:	ee06 3a90 	vmov	s13, r3
34198d7e:	eeb8 6b66 	vcvt.f64.u32	d6, s13
34198d82:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198d86:	b299      	uxth	r1, r3
34198d88:	4b31      	ldr	r3, [pc, #196]	@ (34198e50 <ISP_Algo_AWB_Process+0x388>)
34198d8a:	4a2f      	ldr	r2, [pc, #188]	@ (34198e48 <ISP_Algo_AWB_Process+0x380>)
34198d8c:	eeb0 1b46 	vmov.f64	d1, d6
34198d90:	eeb0 0b47 	vmov.f64	d0, d7
34198d94:	f7e7 ffb0 	bl	34180cf8 <evision_api_awb_init_profiles>
34198d98:	4603      	mov	r3, r0
34198d9a:	f887 30af 	strb.w	r3, [r7, #175]	@ 0xaf
                                          colorTempThresholds, awbProfiles);
    if (e_ret != EVISION_RET_SUCCESS)
34198d9e:	f997 30af 	ldrsb.w	r3, [r7, #175]	@ 0xaf
34198da2:	2b01      	cmp	r3, #1
34198da4:	d001      	beq.n	34198daa <ISP_Algo_AWB_Process+0x2e2>
    {
      return ISP_ERR_ALGO;
34198da6:	23be      	movs	r3, #190	@ 0xbe
34198da8:	e259      	b.n	3419925e <ISP_Algo_AWB_Process+0x796>
    }

    /* Configure algo */
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
34198daa:	4b2a      	ldr	r3, [pc, #168]	@ (34198e54 <ISP_Algo_AWB_Process+0x38c>)
34198dac:	6819      	ldr	r1, [r3, #0]
34198dae:	a31e      	add	r3, pc, #120	@ (adr r3, 34198e28 <ISP_Algo_AWB_Process+0x360>)
34198db0:	e9d3 2300 	ldrd	r2, r3, [r3]
34198db4:	e9c1 23a6 	strd	r2, r3, [r1, #664]	@ 0x298
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
34198db8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
34198dbc:	2b03      	cmp	r3, #3
34198dbe:	d803      	bhi.n	34198dc8 <ISP_Algo_AWB_Process+0x300>
34198dc0:	a31b      	add	r3, pc, #108	@ (adr r3, 34198e30 <ISP_Algo_AWB_Process+0x368>)
34198dc2:	e9d3 2300 	ldrd	r2, r3, [r3]
34198dc6:	e003      	b.n	34198dd0 <ISP_Algo_AWB_Process+0x308>
34198dc8:	f04f 0200 	mov.w	r2, #0
34198dcc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
34198dd0:	4920      	ldr	r1, [pc, #128]	@ (34198e54 <ISP_Algo_AWB_Process+0x38c>)
34198dd2:	6809      	ldr	r1, [r1, #0]
34198dd4:	e9c1 23a8 	strd	r2, r3, [r1, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
34198dd8:	4b1e      	ldr	r3, [pc, #120]	@ (34198e54 <ISP_Algo_AWB_Process+0x38c>)
34198dda:	681b      	ldr	r3, [r3, #0]
34198ddc:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
34198de0:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
34198de4:	4b1b      	ldr	r3, [pc, #108]	@ (34198e54 <ISP_Algo_AWB_Process+0x38c>)
34198de6:	681b      	ldr	r3, [r3, #0]
34198de8:	4a1b      	ldr	r2, [pc, #108]	@ (34198e58 <ISP_Algo_AWB_Process+0x390>)
34198dea:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34198dee:	2305      	movs	r3, #5
34198df0:	9302      	str	r3, [sp, #8]
34198df2:	2301      	movs	r3, #1
34198df4:	9301      	str	r3, [sp, #4]
34198df6:	2302      	movs	r3, #2
34198df8:	9300      	str	r3, [sp, #0]
34198dfa:	4b18      	ldr	r3, [pc, #96]	@ (34198e5c <ISP_Algo_AWB_Process+0x394>)
34198dfc:	683a      	ldr	r2, [r7, #0]
34198dfe:	4918      	ldr	r1, [pc, #96]	@ (34198e60 <ISP_Algo_AWB_Process+0x398>)
34198e00:	6878      	ldr	r0, [r7, #4]
34198e02:	f002 fad3 	bl	3419b3ac <ISP_SVC_Stats_GetNext>
34198e06:	4603      	mov	r3, r0
34198e08:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
34198e0c:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34198e10:	2b00      	cmp	r3, #0
34198e12:	d002      	beq.n	34198e1a <ISP_Algo_AWB_Process+0x352>
    {
      return ret;
34198e14:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34198e18:	e221      	b.n	3419925e <ISP_Algo_AWB_Process+0x796>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34198e1a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34198e1e:	2202      	movs	r2, #2
34198e20:	705a      	strb	r2, [r3, #1]
    break;
34198e22:	e21a      	b.n	3419925a <ISP_Algo_AWB_Process+0x792>
34198e24:	f3af 8000 	nop.w
34198e28:	9999999a 	.word	0x9999999a
34198e2c:	3ff59999 	.word	0x3ff59999
34198e30:	cccccccd 	.word	0xcccccccd
34198e34:	3ffccccc 	.word	0x3ffccccc
34198e38:	341c139c 	.word	0x341c139c
34198e3c:	341c139d 	.word	0x341c139d
34198e40:	341c00ec 	.word	0x341c00ec
34198e44:	341c13a0 	.word	0x341c13a0
34198e48:	341c13a8 	.word	0x341c13a8
34198e4c:	4cbebc20 	.word	0x4cbebc20
34198e50:	341c13b8 	.word	0x341c13b8
34198e54:	341c12fc 	.word	0x341c12fc
34198e58:	40400000 	.word	0x40400000
34198e5c:	341c150c 	.word	0x341c150c
34198e60:	34198aa5 	.word	0x34198aa5

  case ISP_ALGO_STATE_NEED_STAT:
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
34198e64:	2305      	movs	r3, #5
34198e66:	9302      	str	r3, [sp, #8]
34198e68:	2301      	movs	r3, #1
34198e6a:	9301      	str	r3, [sp, #4]
34198e6c:	2302      	movs	r3, #2
34198e6e:	9300      	str	r3, [sp, #0]
34198e70:	4b94      	ldr	r3, [pc, #592]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198e72:	683a      	ldr	r2, [r7, #0]
34198e74:	4994      	ldr	r1, [pc, #592]	@ (341990c8 <ISP_Algo_AWB_Process+0x600>)
34198e76:	6878      	ldr	r0, [r7, #4]
34198e78:	f002 fa98 	bl	3419b3ac <ISP_SVC_Stats_GetNext>
34198e7c:	4603      	mov	r3, r0
34198e7e:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
34198e82:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34198e86:	2b00      	cmp	r3, #0
34198e88:	d002      	beq.n	34198e90 <ISP_Algo_AWB_Process+0x3c8>
    {
      return ret;
34198e8a:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34198e8e:	e1e6      	b.n	3419925e <ISP_Algo_AWB_Process+0x796>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
34198e90:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34198e94:	2202      	movs	r2, #2
34198e96:	705a      	strb	r2, [r3, #1]
    break;
34198e98:	e1df      	b.n	3419925a <ISP_Algo_AWB_Process+0x792>
  case ISP_ALGO_STATE_WAITING_STAT:
    /* Do nothing */
    break;

  case ISP_ALGO_STATE_STAT_READY:
    ISP_Algo_GetUpStat(hIsp, &stats);
34198e9a:	498a      	ldr	r1, [pc, #552]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198e9c:	6878      	ldr	r0, [r7, #4]
34198e9e:	f7ff fab1 	bl	34198404 <ISP_Algo_GetUpStat>

    for (i = 0; i < 3; i++)
34198ea2:	2300      	movs	r3, #0
34198ea4:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198ea8:	e03f      	b.n	34198f2a <ISP_Algo_AWB_Process+0x462>
    {
      if ((abs(stats.up.averageR - (int32_t)statsHistory[i][0]) > 2)
34198eaa:	4b86      	ldr	r3, [pc, #536]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198eac:	781b      	ldrb	r3, [r3, #0]
34198eae:	4618      	mov	r0, r3
34198eb0:	4986      	ldr	r1, [pc, #536]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198eb2:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34198eb6:	4613      	mov	r3, r2
34198eb8:	005b      	lsls	r3, r3, #1
34198eba:	4413      	add	r3, r2
34198ebc:	009b      	lsls	r3, r3, #2
34198ebe:	440b      	add	r3, r1
34198ec0:	681b      	ldr	r3, [r3, #0]
34198ec2:	1ac3      	subs	r3, r0, r3
34198ec4:	2b00      	cmp	r3, #0
34198ec6:	bfb8      	it	lt
34198ec8:	425b      	neglt	r3, r3
34198eca:	2b02      	cmp	r3, #2
34198ecc:	dc25      	bgt.n	34198f1a <ISP_Algo_AWB_Process+0x452>
          || (abs(stats.up.averageG - (int32_t)statsHistory[i][1]) > 2)
34198ece:	4b7d      	ldr	r3, [pc, #500]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198ed0:	785b      	ldrb	r3, [r3, #1]
34198ed2:	4618      	mov	r0, r3
34198ed4:	497d      	ldr	r1, [pc, #500]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198ed6:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34198eda:	4613      	mov	r3, r2
34198edc:	005b      	lsls	r3, r3, #1
34198ede:	4413      	add	r3, r2
34198ee0:	009b      	lsls	r3, r3, #2
34198ee2:	440b      	add	r3, r1
34198ee4:	3304      	adds	r3, #4
34198ee6:	681b      	ldr	r3, [r3, #0]
34198ee8:	1ac3      	subs	r3, r0, r3
34198eea:	2b00      	cmp	r3, #0
34198eec:	bfb8      	it	lt
34198eee:	425b      	neglt	r3, r3
34198ef0:	2b02      	cmp	r3, #2
34198ef2:	dc12      	bgt.n	34198f1a <ISP_Algo_AWB_Process+0x452>
          || (abs(stats.up.averageB - (int32_t)statsHistory[i][2]) > 2))
34198ef4:	4b73      	ldr	r3, [pc, #460]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198ef6:	789b      	ldrb	r3, [r3, #2]
34198ef8:	4618      	mov	r0, r3
34198efa:	4974      	ldr	r1, [pc, #464]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198efc:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
34198f00:	4613      	mov	r3, r2
34198f02:	005b      	lsls	r3, r3, #1
34198f04:	4413      	add	r3, r2
34198f06:	009b      	lsls	r3, r3, #2
34198f08:	440b      	add	r3, r1
34198f0a:	3308      	adds	r3, #8
34198f0c:	681b      	ldr	r3, [r3, #0]
34198f0e:	1ac3      	subs	r3, r0, r3
34198f10:	2b00      	cmp	r3, #0
34198f12:	bfb8      	it	lt
34198f14:	425b      	neglt	r3, r3
34198f16:	2b02      	cmp	r3, #2
34198f18:	dd02      	ble.n	34198f20 <ISP_Algo_AWB_Process+0x458>
      {
        stat_has_changed = true;
34198f1a:	2301      	movs	r3, #1
34198f1c:	f887 30bb 	strb.w	r3, [r7, #187]	@ 0xbb
    for (i = 0; i < 3; i++)
34198f20:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198f24:	3301      	adds	r3, #1
34198f26:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34198f2a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
34198f2e:	2b02      	cmp	r3, #2
34198f30:	d9bb      	bls.n	34198eaa <ISP_Algo_AWB_Process+0x3e2>
      }
    }

    if (skip_stat_check_count || stat_has_changed || reconfigureRequest)
34198f32:	4b67      	ldr	r3, [pc, #412]	@ (341990d0 <ISP_Algo_AWB_Process+0x608>)
34198f34:	781b      	ldrb	r3, [r3, #0]
34198f36:	2b00      	cmp	r3, #0
34198f38:	d108      	bne.n	34198f4c <ISP_Algo_AWB_Process+0x484>
34198f3a:	f897 30bb 	ldrb.w	r3, [r7, #187]	@ 0xbb
34198f3e:	2b00      	cmp	r3, #0
34198f40:	d104      	bne.n	34198f4c <ISP_Algo_AWB_Process+0x484>
34198f42:	4b64      	ldr	r3, [pc, #400]	@ (341990d4 <ISP_Algo_AWB_Process+0x60c>)
34198f44:	781b      	ldrb	r3, [r3, #0]
34198f46:	2b00      	cmp	r3, #0
34198f48:	f000 812f 	beq.w	341991aa <ISP_Algo_AWB_Process+0x6e2>
    {
        statsHistory[2][0] = stats.up.averageR;
34198f4c:	4b5d      	ldr	r3, [pc, #372]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f4e:	781b      	ldrb	r3, [r3, #0]
34198f50:	461a      	mov	r2, r3
34198f52:	4b5e      	ldr	r3, [pc, #376]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198f54:	619a      	str	r2, [r3, #24]
        statsHistory[2][1] = stats.up.averageG;
34198f56:	4b5b      	ldr	r3, [pc, #364]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f58:	785b      	ldrb	r3, [r3, #1]
34198f5a:	461a      	mov	r2, r3
34198f5c:	4b5b      	ldr	r3, [pc, #364]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198f5e:	61da      	str	r2, [r3, #28]
        statsHistory[2][2] = stats.up.averageB;
34198f60:	4b58      	ldr	r3, [pc, #352]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f62:	789b      	ldrb	r3, [r3, #2]
34198f64:	461a      	mov	r2, r3
34198f66:	4b59      	ldr	r3, [pc, #356]	@ (341990cc <ISP_Algo_AWB_Process+0x604>)
34198f68:	621a      	str	r2, [r3, #32]

        /* Get stats after color conversion */
        ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
34198f6a:	4b56      	ldr	r3, [pc, #344]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f6c:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
34198f70:	4619      	mov	r1, r3
34198f72:	4b54      	ldr	r3, [pc, #336]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f74:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34198f78:	461a      	mov	r2, r3
34198f7a:	4b52      	ldr	r3, [pc, #328]	@ (341990c4 <ISP_Algo_AWB_Process+0x5fc>)
34198f7c:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34198f80:	4618      	mov	r0, r3
34198f82:	f107 0364 	add.w	r3, r7, #100	@ 0x64
34198f86:	9302      	str	r3, [sp, #8]
34198f88:	f107 0368 	add.w	r3, r7, #104	@ 0x68
34198f8c:	9301      	str	r3, [sp, #4]
34198f8e:	f107 036c 	add.w	r3, r7, #108	@ 0x6c
34198f92:	9300      	str	r3, [sp, #0]
34198f94:	4603      	mov	r3, r0
34198f96:	6878      	ldr	r0, [r7, #4]
34198f98:	f7ff fb06 	bl	341985a8 <ISP_Algo_ApplyCConv>

        /* Apply gamma */
        meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
34198f9c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34198f9e:	4619      	mov	r1, r3
34198fa0:	6878      	ldr	r0, [r7, #4]
34198fa2:	f7ff f9ed 	bl	34198380 <ISP_Algo_ApplyGammaInverse>
34198fa6:	eeb0 7b40 	vmov.f64	d7, d0
34198faa:	ed87 7b02 	vstr	d7, [r7, #8]
        meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
34198fae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34198fb0:	4619      	mov	r1, r3
34198fb2:	6878      	ldr	r0, [r7, #4]
34198fb4:	f7ff f9e4 	bl	34198380 <ISP_Algo_ApplyGammaInverse>
34198fb8:	eeb0 7b40 	vmov.f64	d7, d0
34198fbc:	ed87 7b04 	vstr	d7, [r7, #16]
        meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
34198fc0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34198fc2:	4619      	mov	r1, r3
34198fc4:	6878      	ldr	r0, [r7, #4]
34198fc6:	f7ff f9db 	bl	34198380 <ISP_Algo_ApplyGammaInverse>
34198fca:	eeb0 7b40 	vmov.f64	d7, d0
34198fce:	ed87 7b06 	vstr	d7, [r7, #24]

        /* Run algo to estimate gain and color conversion to apply */
        e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
34198fd2:	4b41      	ldr	r3, [pc, #260]	@ (341990d8 <ISP_Algo_AWB_Process+0x610>)
34198fd4:	6818      	ldr	r0, [r3, #0]
34198fd6:	f107 0308 	add.w	r3, r7, #8
34198fda:	2201      	movs	r2, #1
34198fdc:	2100      	movs	r1, #0
34198fde:	f7e8 f855 	bl	3418108c <evision_api_awb_run_average>
34198fe2:	4603      	mov	r3, r0
34198fe4:	f887 30af 	strb.w	r3, [r7, #175]	@ 0xaf
        if (e_ret == EVISION_RET_SUCCESS)
34198fe8:	f997 30af 	ldrsb.w	r3, [r7, #175]	@ 0xaf
34198fec:	2b01      	cmp	r3, #1
34198fee:	f040 80d9 	bne.w	341991a4 <ISP_Algo_AWB_Process+0x6dc>
            for (int i = 0; i < ISP_AWB_COLORTEMP_REF; i++) {
              nb_colortemp_change[i] = 0;
            }
          }
#endif
          if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
34198ff2:	4b39      	ldr	r3, [pc, #228]	@ (341990d8 <ISP_Algo_AWB_Process+0x610>)
34198ff4:	681b      	ldr	r3, [r3, #0]
34198ff6:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34198ffa:	4b38      	ldr	r3, [pc, #224]	@ (341990dc <ISP_Algo_AWB_Process+0x614>)
34198ffc:	681b      	ldr	r3, [r3, #0]
34198ffe:	ee07 3a90 	vmov	s15, r3
34199002:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34199006:	eeb4 6b47 	vcmp.f64	d6, d7
3419900a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419900e:	d104      	bne.n	3419901a <ISP_Algo_AWB_Process+0x552>
34199010:	4b30      	ldr	r3, [pc, #192]	@ (341990d4 <ISP_Algo_AWB_Process+0x60c>)
34199012:	781b      	ldrb	r3, [r3, #0]
34199014:	2b01      	cmp	r3, #1
34199016:	f040 80c8 	bne.w	341991aa <ISP_Algo_AWB_Process+0x6e2>
          {
#ifdef ALGO_AWB_DBG_LOGS
            printf("Color temperature = %"PRIu32"\r\n", (uint32_t) pIspAWBestimator->out_temp);
#endif
            if ((pIspAWBestimator->out_temp == colorTempHistory[1]) && (reconfigureRequest != true))
3419901a:	4b2f      	ldr	r3, [pc, #188]	@ (341990d8 <ISP_Algo_AWB_Process+0x610>)
3419901c:	681b      	ldr	r3, [r3, #0]
3419901e:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
34199022:	4b2f      	ldr	r3, [pc, #188]	@ (341990e0 <ISP_Algo_AWB_Process+0x618>)
34199024:	685b      	ldr	r3, [r3, #4]
34199026:	ee07 3a90 	vmov	s15, r3
3419902a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3419902e:	eeb4 6b47 	vcmp.f64	d6, d7
34199032:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34199036:	d107      	bne.n	34199048 <ISP_Algo_AWB_Process+0x580>
34199038:	4b26      	ldr	r3, [pc, #152]	@ (341990d4 <ISP_Algo_AWB_Process+0x60c>)
3419903a:	781b      	ldrb	r3, [r3, #0]
3419903c:	2b01      	cmp	r3, #1
3419903e:	d003      	beq.n	34199048 <ISP_Algo_AWB_Process+0x580>
            {
              skip_stat_check_count = 0; //oscillation detected
34199040:	4b23      	ldr	r3, [pc, #140]	@ (341990d0 <ISP_Algo_AWB_Process+0x608>)
34199042:	2200      	movs	r2, #0
34199044:	701a      	strb	r2, [r3, #0]
34199046:	e0b0      	b.n	341991aa <ISP_Algo_AWB_Process+0x6e2>
            }
            else
            {
              if (skip_stat_check_count <= ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION) skip_stat_check_count = ALGO_AWB_STAT_CHECK_SKIP_AFTER_CT_ESTIMATION;
34199048:	4b21      	ldr	r3, [pc, #132]	@ (341990d0 <ISP_Algo_AWB_Process+0x608>)
3419904a:	781b      	ldrb	r3, [r3, #0]
3419904c:	2b06      	cmp	r3, #6
3419904e:	d802      	bhi.n	34199056 <ISP_Algo_AWB_Process+0x58e>
34199050:	4b1f      	ldr	r3, [pc, #124]	@ (341990d0 <ISP_Algo_AWB_Process+0x608>)
34199052:	2206      	movs	r2, #6
34199054:	701a      	strb	r2, [r3, #0]

              /* Store meta data */
              Meta.colorTemp = (uint32_t) pIspAWBestimator->out_temp;
34199056:	4b20      	ldr	r3, [pc, #128]	@ (341990d8 <ISP_Algo_AWB_Process+0x610>)
34199058:	681b      	ldr	r3, [r3, #0]
3419905a:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3419905e:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34199062:	ee17 2a90 	vmov	r2, s15
34199066:	4b1f      	ldr	r3, [pc, #124]	@ (341990e4 <ISP_Algo_AWB_Process+0x61c>)
34199068:	611a      	str	r2, [r3, #16]

              /* Find the index profile for this referenceColorTemp */
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3419906a:	2300      	movs	r3, #0
3419906c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34199070:	e019      	b.n	341990a6 <ISP_Algo_AWB_Process+0x5de>
              {
                if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
34199072:	4b19      	ldr	r3, [pc, #100]	@ (341990d8 <ISP_Algo_AWB_Process+0x610>)
34199074:	681b      	ldr	r3, [r3, #0]
34199076:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3419907a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
3419907e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34199082:	3344      	adds	r3, #68	@ 0x44
34199084:	009b      	lsls	r3, r3, #2
34199086:	4413      	add	r3, r2
34199088:	689b      	ldr	r3, [r3, #8]
3419908a:	ee07 3a90 	vmov	s15, r3
3419908e:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34199092:	eeb4 6b47 	vcmp.f64	d6, d7
34199096:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419909a:	d009      	beq.n	341990b0 <ISP_Algo_AWB_Process+0x5e8>
              for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3419909c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
341990a0:	3301      	adds	r3, #1
341990a2:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
341990a6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
341990aa:	2b04      	cmp	r3, #4
341990ac:	d9e1      	bls.n	34199072 <ISP_Algo_AWB_Process+0x5aa>
341990ae:	e000      	b.n	341990b2 <ISP_Algo_AWB_Process+0x5ea>
                  break;
341990b0:	bf00      	nop
              }

              if (profId == ISP_AWB_COLORTEMP_REF)
341990b2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
341990b6:	2b05      	cmp	r3, #5
341990b8:	d116      	bne.n	341990e8 <ISP_Algo_AWB_Process+0x620>
              {
                /* Unknown profile */
                ret  = ISP_ERR_WB_COLORTEMP;
341990ba:	2396      	movs	r3, #150	@ 0x96
341990bc:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
341990c0:	e073      	b.n	341991aa <ISP_Algo_AWB_Process+0x6e2>
341990c2:	bf00      	nop
341990c4:	341c150c 	.word	0x341c150c
341990c8:	34198aa5 	.word	0x34198aa5
341990cc:	341c1584 	.word	0x341c1584
341990d0:	341c00ec 	.word	0x341c00ec
341990d4:	341c139d 	.word	0x341c139d
341990d8:	341c12fc 	.word	0x341c12fc
341990dc:	341c15a8 	.word	0x341c15a8
341990e0:	341c13a0 	.word	0x341c13a0
341990e4:	341c1304 	.word	0x341c1304
              }
              else
              {
                /* Apply Color Conversion */
                ColorConvConfig.enable = 1;
341990e8:	2301      	movs	r3, #1
341990ea:	f887 3080 	strb.w	r3, [r7, #128]	@ 0x80
                memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
341990ee:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
341990f2:	4613      	mov	r3, r2
341990f4:	00db      	lsls	r3, r3, #3
341990f6:	4413      	add	r3, r2
341990f8:	009b      	lsls	r3, r3, #2
341990fa:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
341990fe:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
34199102:	4413      	add	r3, r2
34199104:	f103 0108 	add.w	r1, r3, #8
34199108:	f107 0380 	add.w	r3, r7, #128	@ 0x80
3419910c:	3304      	adds	r3, #4
3419910e:	2224      	movs	r2, #36	@ 0x24
34199110:	4618      	mov	r0, r3
34199112:	f00c fa68 	bl	341a55e6 <memcpy>
                ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
34199116:	f107 0380 	add.w	r3, r7, #128	@ 0x80
3419911a:	4619      	mov	r1, r3
3419911c:	6878      	ldr	r0, [r7, #4]
3419911e:	f001 fb17 	bl	3419a750 <ISP_SVC_ISP_SetColorConv>
34199122:	4603      	mov	r3, r0
34199124:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf

                /* Apply gain */
                if (ret == ISP_OK)
34199128:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
3419912c:	2b00      	cmp	r3, #0
3419912e:	d13c      	bne.n	341991aa <ISP_Algo_AWB_Process+0x6e2>
                {
                  ISPGainConfig.enable = 1;
34199130:	2301      	movs	r3, #1
34199132:	f887 3070 	strb.w	r3, [r7, #112]	@ 0x70
                  ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
34199136:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
3419913a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3419913e:	334a      	adds	r3, #74	@ 0x4a
34199140:	009b      	lsls	r3, r3, #2
34199142:	4413      	add	r3, r2
34199144:	685b      	ldr	r3, [r3, #4]
34199146:	677b      	str	r3, [r7, #116]	@ 0x74
                  ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
34199148:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
3419914c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34199150:	334e      	adds	r3, #78	@ 0x4e
34199152:	009b      	lsls	r3, r3, #2
34199154:	4413      	add	r3, r2
34199156:	689b      	ldr	r3, [r3, #8]
34199158:	67bb      	str	r3, [r7, #120]	@ 0x78
                  ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
3419915a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
3419915e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
34199162:	3354      	adds	r3, #84	@ 0x54
34199164:	009b      	lsls	r3, r3, #2
34199166:	4413      	add	r3, r2
34199168:	685b      	ldr	r3, [r3, #4]
3419916a:	67fb      	str	r3, [r7, #124]	@ 0x7c
                  ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
3419916c:	f107 0370 	add.w	r3, r7, #112	@ 0x70
34199170:	4619      	mov	r1, r3
34199172:	6878      	ldr	r0, [r7, #4]
34199174:	f001 fa42 	bl	3419a5fc <ISP_SVC_ISP_SetGain>
34199178:	4603      	mov	r3, r0
3419917a:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
                  if (ret == ISP_OK)
3419917e:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34199182:	2b00      	cmp	r3, #0
34199184:	d111      	bne.n	341991aa <ISP_Algo_AWB_Process+0x6e2>
                  {
                    currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
34199186:	4b38      	ldr	r3, [pc, #224]	@ (34199268 <ISP_Algo_AWB_Process+0x7a0>)
34199188:	681b      	ldr	r3, [r3, #0]
3419918a:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3419918e:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34199192:	ee17 2a90 	vmov	r2, s15
34199196:	4b35      	ldr	r3, [pc, #212]	@ (3419926c <ISP_Algo_AWB_Process+0x7a4>)
34199198:	601a      	str	r2, [r3, #0]
                    current_awb_profId = profId;
3419919a:	4a35      	ldr	r2, [pc, #212]	@ (34199270 <ISP_Algo_AWB_Process+0x7a8>)
3419919c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
341991a0:	6013      	str	r3, [r2, #0]
341991a2:	e002      	b.n	341991aa <ISP_Algo_AWB_Process+0x6e2>
            }
          }
        }
        else
        {
          ret = ISP_ERR_ALGO;
341991a4:	23be      	movs	r3, #190	@ 0xbe
341991a6:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf
        }
    }

    /* Reset reconfigureRequest */
    reconfigureRequest = false;
341991aa:	4b32      	ldr	r3, [pc, #200]	@ (34199274 <ISP_Algo_AWB_Process+0x7ac>)
341991ac:	2200      	movs	r2, #0
341991ae:	701a      	strb	r2, [r3, #0]

    /* Decrease counter to limit the number of estimations before reaching convergence */
    if (skip_stat_check_count > 0) skip_stat_check_count--;
341991b0:	4b31      	ldr	r3, [pc, #196]	@ (34199278 <ISP_Algo_AWB_Process+0x7b0>)
341991b2:	781b      	ldrb	r3, [r3, #0]
341991b4:	2b00      	cmp	r3, #0
341991b6:	d005      	beq.n	341991c4 <ISP_Algo_AWB_Process+0x6fc>
341991b8:	4b2f      	ldr	r3, [pc, #188]	@ (34199278 <ISP_Algo_AWB_Process+0x7b0>)
341991ba:	781b      	ldrb	r3, [r3, #0]
341991bc:	3b01      	subs	r3, #1
341991be:	b2da      	uxtb	r2, r3
341991c0:	4b2d      	ldr	r3, [pc, #180]	@ (34199278 <ISP_Algo_AWB_Process+0x7b0>)
341991c2:	701a      	strb	r2, [r3, #0]

    /* Store history to be able to detect variations*/
    statsHistory[1][0] = statsHistory[0][0];
341991c4:	4b2d      	ldr	r3, [pc, #180]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991c6:	681b      	ldr	r3, [r3, #0]
341991c8:	4a2c      	ldr	r2, [pc, #176]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991ca:	60d3      	str	r3, [r2, #12]
    statsHistory[1][1] = statsHistory[0][1];
341991cc:	4b2b      	ldr	r3, [pc, #172]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991ce:	685b      	ldr	r3, [r3, #4]
341991d0:	4a2a      	ldr	r2, [pc, #168]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991d2:	6113      	str	r3, [r2, #16]
    statsHistory[1][2] = statsHistory[0][2];
341991d4:	4b29      	ldr	r3, [pc, #164]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991d6:	689b      	ldr	r3, [r3, #8]
341991d8:	4a28      	ldr	r2, [pc, #160]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991da:	6153      	str	r3, [r2, #20]
    statsHistory[0][0] = stats.up.averageR;
341991dc:	4b28      	ldr	r3, [pc, #160]	@ (34199280 <ISP_Algo_AWB_Process+0x7b8>)
341991de:	781b      	ldrb	r3, [r3, #0]
341991e0:	461a      	mov	r2, r3
341991e2:	4b26      	ldr	r3, [pc, #152]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991e4:	601a      	str	r2, [r3, #0]
    statsHistory[0][1] = stats.up.averageG;
341991e6:	4b26      	ldr	r3, [pc, #152]	@ (34199280 <ISP_Algo_AWB_Process+0x7b8>)
341991e8:	785b      	ldrb	r3, [r3, #1]
341991ea:	461a      	mov	r2, r3
341991ec:	4b23      	ldr	r3, [pc, #140]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991ee:	605a      	str	r2, [r3, #4]
    statsHistory[0][2] = stats.up.averageB;
341991f0:	4b23      	ldr	r3, [pc, #140]	@ (34199280 <ISP_Algo_AWB_Process+0x7b8>)
341991f2:	789b      	ldrb	r3, [r3, #2]
341991f4:	461a      	mov	r2, r3
341991f6:	4b21      	ldr	r3, [pc, #132]	@ (3419927c <ISP_Algo_AWB_Process+0x7b4>)
341991f8:	609a      	str	r2, [r3, #8]
    colorTempHistory[1] = colorTempHistory[0];
341991fa:	4b22      	ldr	r3, [pc, #136]	@ (34199284 <ISP_Algo_AWB_Process+0x7bc>)
341991fc:	681b      	ldr	r3, [r3, #0]
341991fe:	4a21      	ldr	r2, [pc, #132]	@ (34199284 <ISP_Algo_AWB_Process+0x7bc>)
34199200:	6053      	str	r3, [r2, #4]
    colorTempHistory[0] = currentColorTemp;
34199202:	4b1a      	ldr	r3, [pc, #104]	@ (3419926c <ISP_Algo_AWB_Process+0x7a4>)
34199204:	681b      	ldr	r3, [r3, #0]
34199206:	4a1f      	ldr	r2, [pc, #124]	@ (34199284 <ISP_Algo_AWB_Process+0x7bc>)
34199208:	6013      	str	r3, [r2, #0]

    /* Ask for stats */
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3419920a:	2305      	movs	r3, #5
3419920c:	9302      	str	r3, [sp, #8]
3419920e:	2301      	movs	r3, #1
34199210:	9301      	str	r3, [sp, #4]
34199212:	2302      	movs	r3, #2
34199214:	9300      	str	r3, [sp, #0]
34199216:	4b1a      	ldr	r3, [pc, #104]	@ (34199280 <ISP_Algo_AWB_Process+0x7b8>)
34199218:	683a      	ldr	r2, [r7, #0]
3419921a:	491b      	ldr	r1, [pc, #108]	@ (34199288 <ISP_Algo_AWB_Process+0x7c0>)
3419921c:	6878      	ldr	r0, [r7, #4]
3419921e:	f002 f8c5 	bl	3419b3ac <ISP_SVC_Stats_GetNext>
34199222:	4603      	mov	r3, r0
34199224:	f887 30ae 	strb.w	r3, [r7, #174]	@ 0xae
                                     ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    ret = (ret != ISP_OK) ? ret : ret_stat;
34199228:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
3419922c:	2b00      	cmp	r3, #0
3419922e:	d002      	beq.n	34199236 <ISP_Algo_AWB_Process+0x76e>
34199230:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
34199234:	e001      	b.n	3419923a <ISP_Algo_AWB_Process+0x772>
34199236:	f897 30ae 	ldrb.w	r3, [r7, #174]	@ 0xae
3419923a:	f887 30cf 	strb.w	r3, [r7, #207]	@ 0xcf

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3419923e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34199242:	2202      	movs	r2, #2
34199244:	705a      	strb	r2, [r3, #1]
    break;
34199246:	e008      	b.n	3419925a <ISP_Algo_AWB_Process+0x792>

  default:
    printf("WARNING: Unknown AWB algo state\r\n");
34199248:	4810      	ldr	r0, [pc, #64]	@ (3419928c <ISP_Algo_AWB_Process+0x7c4>)
3419924a:	f00c f821 	bl	341a5290 <puts>
    /* Reset state to ISP_ALGO_STATE_INIT */
    algo->state = ISP_ALGO_STATE_INIT;
3419924e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
34199252:	2200      	movs	r2, #0
34199254:	705a      	strb	r2, [r3, #1]
    break;
34199256:	e000      	b.n	3419925a <ISP_Algo_AWB_Process+0x792>
    break;
34199258:	bf00      	nop
  }

  return ret;
3419925a:	f897 30cf 	ldrb.w	r3, [r7, #207]	@ 0xcf
}
3419925e:	4618      	mov	r0, r3
34199260:	37d0      	adds	r7, #208	@ 0xd0
34199262:	46bd      	mov	sp, r7
34199264:	bd80      	pop	{r7, pc}
34199266:	bf00      	nop
34199268:	341c12fc 	.word	0x341c12fc
3419926c:	341c15a8 	.word	0x341c15a8
34199270:	341c1300 	.word	0x341c1300
34199274:	341c139d 	.word	0x341c139d
34199278:	341c00ec 	.word	0x341c00ec
3419927c:	341c1584 	.word	0x341c1584
34199280:	341c150c 	.word	0x341c150c
34199284:	341c13a0 	.word	0x341c13a0
34199288:	34198aa5 	.word	0x34198aa5
3419928c:	341a73c4 	.word	0x341a73c4

34199290 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
34199290:	b580      	push	{r7, lr}
34199292:	b086      	sub	sp, #24
34199294:	af00      	add	r7, sp, #0
34199296:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
34199298:	687b      	ldr	r3, [r7, #4]
3419929a:	4a15      	ldr	r2, [pc, #84]	@ (341992f0 <ISP_Algo_Init+0x60>)
3419929c:	619a      	str	r2, [r3, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3419929e:	2300      	movs	r3, #0
341992a0:	75fb      	strb	r3, [r7, #23]
341992a2:	e01c      	b.n	341992de <ISP_Algo_Init+0x4e>
  {
    algo = hIsp->algorithm[i];
341992a4:	687b      	ldr	r3, [r7, #4]
341992a6:	699a      	ldr	r2, [r3, #24]
341992a8:	7dfb      	ldrb	r3, [r7, #23]
341992aa:	009b      	lsls	r3, r3, #2
341992ac:	4413      	add	r3, r2
341992ae:	681b      	ldr	r3, [r3, #0]
341992b0:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Init != NULL))
341992b2:	693b      	ldr	r3, [r7, #16]
341992b4:	2b00      	cmp	r3, #0
341992b6:	d00f      	beq.n	341992d8 <ISP_Algo_Init+0x48>
341992b8:	693b      	ldr	r3, [r7, #16]
341992ba:	685b      	ldr	r3, [r3, #4]
341992bc:	2b00      	cmp	r3, #0
341992be:	d00b      	beq.n	341992d8 <ISP_Algo_Init+0x48>
    {
      ret = algo->Init((void*)hIsp, (void*)algo);
341992c0:	693b      	ldr	r3, [r7, #16]
341992c2:	685b      	ldr	r3, [r3, #4]
341992c4:	6939      	ldr	r1, [r7, #16]
341992c6:	6878      	ldr	r0, [r7, #4]
341992c8:	4798      	blx	r3
341992ca:	4603      	mov	r3, r0
341992cc:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
341992ce:	7bfb      	ldrb	r3, [r7, #15]
341992d0:	2b00      	cmp	r3, #0
341992d2:	d001      	beq.n	341992d8 <ISP_Algo_Init+0x48>
      {
        return ret;
341992d4:	7bfb      	ldrb	r3, [r7, #15]
341992d6:	e006      	b.n	341992e6 <ISP_Algo_Init+0x56>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
341992d8:	7dfb      	ldrb	r3, [r7, #23]
341992da:	3301      	adds	r3, #1
341992dc:	75fb      	strb	r3, [r7, #23]
341992de:	7dfb      	ldrb	r3, [r7, #23]
341992e0:	2b02      	cmp	r3, #2
341992e2:	d9df      	bls.n	341992a4 <ISP_Algo_Init+0x14>
      }
    }
  }

  return ISP_OK;
341992e4:	2300      	movs	r3, #0
}
341992e6:	4618      	mov	r0, r3
341992e8:	3718      	adds	r7, #24
341992ea:	46bd      	mov	sp, r7
341992ec:	bd80      	pop	{r7, pc}
341992ee:	bf00      	nop
341992f0:	341c00e0 	.word	0x341c00e0

341992f4 <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
341992f4:	b580      	push	{r7, lr}
341992f6:	b086      	sub	sp, #24
341992f8:	af00      	add	r7, sp, #0
341992fa:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
341992fc:	2300      	movs	r3, #0
341992fe:	75fb      	strb	r3, [r7, #23]
34199300:	e01c      	b.n	3419933c <ISP_Algo_DeInit+0x48>
  {
    algo = hIsp->algorithm[i];
34199302:	687b      	ldr	r3, [r7, #4]
34199304:	699a      	ldr	r2, [r3, #24]
34199306:	7dfb      	ldrb	r3, [r7, #23]
34199308:	009b      	lsls	r3, r3, #2
3419930a:	4413      	add	r3, r2
3419930c:	681b      	ldr	r3, [r3, #0]
3419930e:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->DeInit != NULL))
34199310:	693b      	ldr	r3, [r7, #16]
34199312:	2b00      	cmp	r3, #0
34199314:	d00f      	beq.n	34199336 <ISP_Algo_DeInit+0x42>
34199316:	693b      	ldr	r3, [r7, #16]
34199318:	689b      	ldr	r3, [r3, #8]
3419931a:	2b00      	cmp	r3, #0
3419931c:	d00b      	beq.n	34199336 <ISP_Algo_DeInit+0x42>
    {
      ret = algo->DeInit((void*)hIsp, (void*)algo);
3419931e:	693b      	ldr	r3, [r7, #16]
34199320:	689b      	ldr	r3, [r3, #8]
34199322:	6939      	ldr	r1, [r7, #16]
34199324:	6878      	ldr	r0, [r7, #4]
34199326:	4798      	blx	r3
34199328:	4603      	mov	r3, r0
3419932a:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
3419932c:	7bfb      	ldrb	r3, [r7, #15]
3419932e:	2b00      	cmp	r3, #0
34199330:	d001      	beq.n	34199336 <ISP_Algo_DeInit+0x42>
      {
        return ret;
34199332:	7bfb      	ldrb	r3, [r7, #15]
34199334:	e006      	b.n	34199344 <ISP_Algo_DeInit+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34199336:	7dfb      	ldrb	r3, [r7, #23]
34199338:	3301      	adds	r3, #1
3419933a:	75fb      	strb	r3, [r7, #23]
3419933c:	7dfb      	ldrb	r3, [r7, #23]
3419933e:	2b02      	cmp	r3, #2
34199340:	d9df      	bls.n	34199302 <ISP_Algo_DeInit+0xe>
      }
    }
  }

  return ISP_OK;
34199342:	2300      	movs	r3, #0
}
34199344:	4618      	mov	r0, r3
34199346:	3718      	adds	r7, #24
34199348:	46bd      	mov	sp, r7
3419934a:	bd80      	pop	{r7, pc}

3419934c <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
3419934c:	b580      	push	{r7, lr}
3419934e:	b086      	sub	sp, #24
34199350:	af00      	add	r7, sp, #0
34199352:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
34199354:	2300      	movs	r3, #0
34199356:	75fb      	strb	r3, [r7, #23]
34199358:	e01c      	b.n	34199394 <ISP_Algo_Process+0x48>
  {
    algo = hIsp->algorithm[i];
3419935a:	687b      	ldr	r3, [r7, #4]
3419935c:	699a      	ldr	r2, [r3, #24]
3419935e:	7dfb      	ldrb	r3, [r7, #23]
34199360:	009b      	lsls	r3, r3, #2
34199362:	4413      	add	r3, r2
34199364:	681b      	ldr	r3, [r3, #0]
34199366:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Process != NULL))
34199368:	693b      	ldr	r3, [r7, #16]
3419936a:	2b00      	cmp	r3, #0
3419936c:	d00f      	beq.n	3419938e <ISP_Algo_Process+0x42>
3419936e:	693b      	ldr	r3, [r7, #16]
34199370:	68db      	ldr	r3, [r3, #12]
34199372:	2b00      	cmp	r3, #0
34199374:	d00b      	beq.n	3419938e <ISP_Algo_Process+0x42>
    {
#ifdef ALGO_PERF_DBG_LOGS
      uint32_t tickstart = HAL_GetTick();
#endif
      ret = algo->Process((void*)hIsp, (void*)algo);
34199376:	693b      	ldr	r3, [r7, #16]
34199378:	68db      	ldr	r3, [r3, #12]
3419937a:	6939      	ldr	r1, [r7, #16]
3419937c:	6878      	ldr	r0, [r7, #4]
3419937e:	4798      	blx	r3
34199380:	4603      	mov	r3, r0
34199382:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
34199384:	7bfb      	ldrb	r3, [r7, #15]
34199386:	2b00      	cmp	r3, #0
34199388:	d001      	beq.n	3419938e <ISP_Algo_Process+0x42>
      {
        return ret;
3419938a:	7bfb      	ldrb	r3, [r7, #15]
3419938c:	e006      	b.n	3419939c <ISP_Algo_Process+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3419938e:	7dfb      	ldrb	r3, [r7, #23]
34199390:	3301      	adds	r3, #1
34199392:	75fb      	strb	r3, [r7, #23]
34199394:	7dfb      	ldrb	r3, [r7, #23]
34199396:	2b02      	cmp	r3, #2
34199398:	d9df      	bls.n	3419935a <ISP_Algo_Process+0xe>
      }
#endif
    }
  }

  return ISP_OK;
3419939a:	2300      	movs	r3, #0
}
3419939c:	4618      	mov	r0, r3
3419939e:	3718      	adds	r7, #24
341993a0:	46bd      	mov	sp, r7
341993a2:	bd80      	pop	{r7, pc}

341993a4 <ISP_Init>:
ISP_StatusTypeDef ISP_Init(ISP_HandleTypeDef *hIsp,
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
341993a4:	b5b0      	push	{r4, r5, r7, lr}
341993a6:	b086      	sub	sp, #24
341993a8:	af00      	add	r7, sp, #0
341993aa:	60f8      	str	r0, [r7, #12]
341993ac:	60b9      	str	r1, [r7, #8]
341993ae:	607a      	str	r2, [r7, #4]
341993b0:	603b      	str	r3, [r7, #0]
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
341993b2:	68fb      	ldr	r3, [r7, #12]
341993b4:	2b00      	cmp	r3, #0
341993b6:	d005      	beq.n	341993c4 <ISP_Init+0x20>
341993b8:	68bb      	ldr	r3, [r7, #8]
341993ba:	2b00      	cmp	r3, #0
341993bc:	d002      	beq.n	341993c4 <ISP_Init+0x20>
341993be:	683b      	ldr	r3, [r7, #0]
341993c0:	2b00      	cmp	r3, #0
341993c2:	d101      	bne.n	341993c8 <ISP_Init+0x24>
  {
    return ISP_ERR_EINVAL;
341993c4:	2301      	movs	r3, #1
341993c6:	e0a3      	b.n	34199510 <ISP_Init+0x16c>
  }

  memset(hIsp, 0, sizeof(*hIsp));
341993c8:	2288      	movs	r2, #136	@ 0x88
341993ca:	2100      	movs	r1, #0
341993cc:	68f8      	ldr	r0, [r7, #12]
341993ce:	f00c f88f 	bl	341a54f0 <memset>

#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_ToolCom_Init();
#endif

  hIsp->hDcmipp = hDcmipp;
341993d2:	68fb      	ldr	r3, [r7, #12]
341993d4:	68ba      	ldr	r2, [r7, #8]
341993d6:	601a      	str	r2, [r3, #0]
  hIsp->cameraInstance = CameraInstance;
341993d8:	68fb      	ldr	r3, [r7, #12]
341993da:	687a      	ldr	r2, [r7, #4]
341993dc:	605a      	str	r2, [r3, #4]
  hIsp->MainPipe_FrameCount = 0;
341993de:	68fb      	ldr	r3, [r7, #12]
341993e0:	2200      	movs	r2, #0
341993e2:	641a      	str	r2, [r3, #64]	@ 0x40
  hIsp->AncillaryPipe_FrameCount = 0;
341993e4:	68fb      	ldr	r3, [r7, #12]
341993e6:	2200      	movs	r2, #0
341993e8:	645a      	str	r2, [r3, #68]	@ 0x44
  hIsp->DumpPipe_FrameCount = 0;
341993ea:	68fb      	ldr	r3, [r7, #12]
341993ec:	2200      	movs	r2, #0
341993ee:	649a      	str	r2, [r3, #72]	@ 0x48

  hIsp->appliHelpers = *pAppliHelpers;
341993f0:	68fb      	ldr	r3, [r7, #12]
341993f2:	683a      	ldr	r2, [r7, #0]
341993f4:	f103 041c 	add.w	r4, r3, #28
341993f8:	4615      	mov	r5, r2
341993fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341993fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341993fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34199400:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34199402:	682b      	ldr	r3, [r5, #0]
34199404:	6023      	str	r3, [r4, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
34199406:	68fb      	ldr	r3, [r7, #12]
34199408:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419940a:	2b00      	cmp	r3, #0
3419940c:	d104      	bne.n	34199418 <ISP_Init+0x74>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
3419940e:	4842      	ldr	r0, [pc, #264]	@ (34199518 <ISP_Init+0x174>)
34199410:	f00b ff3e 	bl	341a5290 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34199414:	23b4      	movs	r3, #180	@ 0xb4
34199416:	e07b      	b.n	34199510 <ISP_Init+0x16c>
   }
  if (hIsp->appliHelpers.SetSensorGain == NULL)
34199418:	68fb      	ldr	r3, [r7, #12]
3419941a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419941c:	2b00      	cmp	r3, #0
3419941e:	d104      	bne.n	3419942a <ISP_Init+0x86>
  {
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
34199420:	483e      	ldr	r0, [pc, #248]	@ (3419951c <ISP_Init+0x178>)
34199422:	f00b ff35 	bl	341a5290 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
34199426:	23b4      	movs	r3, #180	@ 0xb4
34199428:	e072      	b.n	34199510 <ISP_Init+0x16c>
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
3419942a:	68fb      	ldr	r3, [r7, #12]
3419942c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419942e:	2b00      	cmp	r3, #0
34199430:	d104      	bne.n	3419943c <ISP_Init+0x98>
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
34199432:	483b      	ldr	r0, [pc, #236]	@ (34199520 <ISP_Init+0x17c>)
34199434:	f00b ff2c 	bl	341a5290 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
34199438:	23b4      	movs	r3, #180	@ 0xb4
3419943a:	e069      	b.n	34199510 <ISP_Init+0x16c>
   }
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
3419943c:	68fb      	ldr	r3, [r7, #12]
3419943e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34199440:	2b00      	cmp	r3, #0
34199442:	d104      	bne.n	3419944e <ISP_Init+0xaa>
  {
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
34199444:	4837      	ldr	r0, [pc, #220]	@ (34199524 <ISP_Init+0x180>)
34199446:	f00b ff23 	bl	341a5290 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
3419944a:	23b4      	movs	r3, #180	@ 0xb4
3419944c:	e060      	b.n	34199510 <ISP_Init+0x16c>
  }
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
3419944e:	68fb      	ldr	r3, [r7, #12]
34199450:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34199452:	2b00      	cmp	r3, #0
34199454:	d104      	bne.n	34199460 <ISP_Init+0xbc>
  {
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
34199456:	4834      	ldr	r0, [pc, #208]	@ (34199528 <ISP_Init+0x184>)
34199458:	f00b ff1a 	bl	341a5290 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
3419945c:	23b4      	movs	r3, #180	@ 0xb4
3419945e:	e057      	b.n	34199510 <ISP_Init+0x16c>
   }

  /* Initialize IQ param (read from non volatile memory) */
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
34199460:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34199462:	68f8      	ldr	r0, [r7, #12]
34199464:	f001 fc26 	bl	3419acb4 <ISP_SVC_IQParam_Init>
34199468:	4603      	mov	r3, r0
3419946a:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3419946c:	7dfb      	ldrb	r3, [r7, #23]
3419946e:	2b00      	cmp	r3, #0
34199470:	d001      	beq.n	34199476 <ISP_Init+0xd2>
  {
    return ret;
34199472:	7dfb      	ldrb	r3, [r7, #23]
34199474:	e04c      	b.n	34199510 <ISP_Init+0x16c>
  }

  /* Set decimation configuration */
  /* Get Sensor Info */
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
34199476:	68fb      	ldr	r3, [r7, #12]
34199478:	334c      	adds	r3, #76	@ 0x4c
3419947a:	4619      	mov	r1, r3
3419947c:	68f8      	ldr	r0, [r7, #12]
3419947e:	f001 fa89 	bl	3419a994 <ISP_SVC_Sensor_GetInfo>
34199482:	4603      	mov	r3, r0
34199484:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
34199486:	7dfb      	ldrb	r3, [r7, #23]
34199488:	2b00      	cmp	r3, #0
3419948a:	d001      	beq.n	34199490 <ISP_Init+0xec>
  {
    return ret;
3419948c:	7dfb      	ldrb	r3, [r7, #23]
3419948e:	e03f      	b.n	34199510 <ISP_Init+0x16c>
  }
  /* Compute the ISP decimation value according to the sensor resolution and the maximum ISP resolution */
  /* It is mandatory to ensure that RAW frame size does not exceed 2688 width prior to demosaicing */
  ISP_DecimationTypeDef decimation;
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
34199490:	68fb      	ldr	r3, [r7, #12]
34199492:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34199494:	f5b3 6f28 	cmp.w	r3, #2688	@ 0xa80
34199498:	d202      	bcs.n	341994a0 <ISP_Init+0xfc>
  {
    decimation.factor = ISP_DECIM_FACTOR_1;
3419949a:	2301      	movs	r3, #1
3419949c:	753b      	strb	r3, [r7, #20]
3419949e:	e01c      	b.n	341994da <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
341994a0:	68fb      	ldr	r3, [r7, #12]
341994a2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341994a4:	f5b3 5fa8 	cmp.w	r3, #5376	@ 0x1500
341994a8:	d202      	bcs.n	341994b0 <ISP_Init+0x10c>
  {
    decimation.factor = ISP_DECIM_FACTOR_2;
341994aa:	2302      	movs	r3, #2
341994ac:	753b      	strb	r3, [r7, #20]
341994ae:	e014      	b.n	341994da <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
341994b0:	68fb      	ldr	r3, [r7, #12]
341994b2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341994b4:	f5b3 5f28 	cmp.w	r3, #10752	@ 0x2a00
341994b8:	d202      	bcs.n	341994c0 <ISP_Init+0x11c>
  {
    decimation.factor = ISP_DECIM_FACTOR_4;
341994ba:	2304      	movs	r3, #4
341994bc:	753b      	strb	r3, [r7, #20]
341994be:	e00c      	b.n	341994da <ISP_Init+0x136>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
341994c0:	68fb      	ldr	r3, [r7, #12]
341994c2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
341994c4:	f5b3 4fa8 	cmp.w	r3, #21504	@ 0x5400
341994c8:	d202      	bcs.n	341994d0 <ISP_Init+0x12c>
  {
    decimation.factor = ISP_DECIM_FACTOR_8;
341994ca:	2308      	movs	r3, #8
341994cc:	753b      	strb	r3, [r7, #20]
341994ce:	e004      	b.n	341994da <ISP_Init+0x136>
  }
  else
  {
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
341994d0:	4816      	ldr	r0, [pc, #88]	@ (3419952c <ISP_Init+0x188>)
341994d2:	f00b fedd 	bl	341a5290 <puts>
    return ISP_ERR_DECIMATION_EINVAL;
341994d6:	231e      	movs	r3, #30
341994d8:	e01a      	b.n	34199510 <ISP_Init+0x16c>
  }
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
341994da:	f107 0314 	add.w	r3, r7, #20
341994de:	4619      	mov	r1, r3
341994e0:	68f8      	ldr	r0, [r7, #12]
341994e2:	f000 fe05 	bl	3419a0f0 <ISP_SVC_ISP_SetDecimation>
341994e6:	4603      	mov	r3, r0
341994e8:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
341994ea:	7dfb      	ldrb	r3, [r7, #23]
341994ec:	2b00      	cmp	r3, #0
341994ee:	d001      	beq.n	341994f4 <ISP_Init+0x150>
  {
    return ret;
341994f0:	7dfb      	ldrb	r3, [r7, #23]
341994f2:	e00d      	b.n	34199510 <ISP_Init+0x16c>
  }

  /* Initialize algorithms */
  ret = ISP_Algo_Init(hIsp);
341994f4:	68f8      	ldr	r0, [r7, #12]
341994f6:	f7ff fecb 	bl	34199290 <ISP_Algo_Init>
341994fa:	4603      	mov	r3, r0
341994fc:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
341994fe:	7dfb      	ldrb	r3, [r7, #23]
34199500:	2b00      	cmp	r3, #0
34199502:	d001      	beq.n	34199508 <ISP_Init+0x164>
  {
    return ret;
34199504:	7dfb      	ldrb	r3, [r7, #23]
34199506:	e003      	b.n	34199510 <ISP_Init+0x16c>
  }

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);
34199508:	68f8      	ldr	r0, [r7, #12]
3419950a:	f001 fbf7 	bl	3419acfc <ISP_SVC_Stats_Init>

  return ISP_OK;
3419950e:	2300      	movs	r3, #0
}
34199510:	4618      	mov	r0, r3
34199512:	3718      	adds	r7, #24
34199514:	46bd      	mov	sp, r7
34199516:	bdb0      	pop	{r4, r5, r7, pc}
34199518:	341a73e8 	.word	0x341a73e8
3419951c:	341a7420 	.word	0x341a7420
34199520:	341a7458 	.word	0x341a7458
34199524:	341a7490 	.word	0x341a7490
34199528:	341a74cc 	.word	0x341a74cc
3419952c:	341a7508 	.word	0x341a7508

34199530 <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
34199530:	b580      	push	{r7, lr}
34199532:	b084      	sub	sp, #16
34199534:	af00      	add	r7, sp, #0
34199536:	6078      	str	r0, [r7, #4]
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
34199538:	687b      	ldr	r3, [r7, #4]
3419953a:	2b00      	cmp	r3, #0
3419953c:	d101      	bne.n	34199542 <ISP_DeInit+0x12>
  {
    return ISP_ERR_EINVAL;
3419953e:	2301      	movs	r3, #1
34199540:	e00f      	b.n	34199562 <ISP_DeInit+0x32>
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
34199542:	6878      	ldr	r0, [r7, #4]
34199544:	f7ff fed6 	bl	341992f4 <ISP_Algo_DeInit>
34199548:	4603      	mov	r3, r0
3419954a:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3419954c:	7bfb      	ldrb	r3, [r7, #15]
3419954e:	2b00      	cmp	r3, #0
34199550:	d001      	beq.n	34199556 <ISP_DeInit+0x26>
  {
    return ret;
34199552:	7bfb      	ldrb	r3, [r7, #15]
34199554:	e005      	b.n	34199562 <ISP_DeInit+0x32>
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
34199556:	2288      	movs	r2, #136	@ 0x88
34199558:	2100      	movs	r1, #0
3419955a:	6878      	ldr	r0, [r7, #4]
3419955c:	f00b ffc8 	bl	341a54f0 <memset>

  return ISP_OK;
34199560:	2300      	movs	r3, #0
}
34199562:	4618      	mov	r0, r3
34199564:	3710      	adds	r7, #16
34199566:	46bd      	mov	sp, r7
34199568:	bd80      	pop	{r7, pc}
3419956a:	0000      	movs	r0, r0
3419956c:	0000      	movs	r0, r0
	...

34199570 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
34199570:	b580      	push	{r7, lr}
34199572:	b084      	sub	sp, #16
34199574:	af00      	add	r7, sp, #0
34199576:	6078      	str	r0, [r7, #4]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
34199578:	687b      	ldr	r3, [r7, #4]
3419957a:	2b00      	cmp	r3, #0
3419957c:	d101      	bne.n	34199582 <ISP_Start+0x12>
  {
    return ISP_ERR_EINVAL;
3419957e:	2301      	movs	r3, #1
34199580:	e0f6      	b.n	34199770 <ISP_Start+0x200>
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
34199582:	6878      	ldr	r0, [r7, #4]
34199584:	f001 fac0 	bl	3419ab08 <ISP_SVC_Misc_IsDCMIPPReady>
34199588:	4603      	mov	r3, r0
3419958a:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3419958c:	7bfb      	ldrb	r3, [r7, #15]
3419958e:	2b00      	cmp	r3, #0
34199590:	d001      	beq.n	34199596 <ISP_Start+0x26>
  {
    return ret;
34199592:	7bfb      	ldrb	r3, [r7, #15]
34199594:	e0ec      	b.n	34199770 <ISP_Start+0x200>
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
34199596:	6878      	ldr	r0, [r7, #4]
34199598:	f001 fba2 	bl	3419ace0 <ISP_SVC_IQParam_Get>
3419959c:	60b8      	str	r0, [r7, #8]

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
3419959e:	68bb      	ldr	r3, [r7, #8]
341995a0:	330c      	adds	r3, #12
341995a2:	4619      	mov	r1, r3
341995a4:	6878      	ldr	r0, [r7, #4]
341995a6:	f000 fce7 	bl	34199f78 <ISP_SVC_ISP_SetDemosaicing>
341995aa:	4603      	mov	r3, r0
341995ac:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
341995ae:	7bfb      	ldrb	r3, [r7, #15]
341995b0:	2b00      	cmp	r3, #0
341995b2:	d001      	beq.n	341995b8 <ISP_Start+0x48>
  {
    return ret;
341995b4:	7bfb      	ldrb	r3, [r7, #15]
341995b6:	e0db      	b.n	34199770 <ISP_Start+0x200>
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
341995b8:	68bb      	ldr	r3, [r7, #8]
341995ba:	4619      	mov	r1, r3
341995bc:	6878      	ldr	r0, [r7, #4]
341995be:	f000 fd53 	bl	3419a068 <ISP_SVC_ISP_SetStatRemoval>
341995c2:	4603      	mov	r3, r0
341995c4:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
341995c6:	7bfb      	ldrb	r3, [r7, #15]
341995c8:	2b00      	cmp	r3, #0
341995ca:	d001      	beq.n	341995d0 <ISP_Start+0x60>
  {
    return ret;
341995cc:	7bfb      	ldrb	r3, [r7, #15]
341995ce:	e0cf      	b.n	34199770 <ISP_Start+0x200>
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
341995d0:	68bb      	ldr	r3, [r7, #8]
341995d2:	3314      	adds	r3, #20
341995d4:	4619      	mov	r1, r3
341995d6:	6878      	ldr	r0, [r7, #4]
341995d8:	f000 fdec 	bl	3419a1b4 <ISP_SVC_ISP_SetContrast>
341995dc:	4603      	mov	r3, r0
341995de:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
341995e0:	7bfb      	ldrb	r3, [r7, #15]
341995e2:	2b00      	cmp	r3, #0
341995e4:	d001      	beq.n	341995ea <ISP_Start+0x7a>
  {
    return ret;
341995e6:	7bfb      	ldrb	r3, [r7, #15]
341995e8:	e0c2      	b.n	34199770 <ISP_Start+0x200>
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
341995ea:	68bb      	ldr	r3, [r7, #8]
341995ec:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
341995ee:	2b00      	cmp	r3, #0
341995f0:	d011      	beq.n	34199616 <ISP_Start+0xa6>
341995f2:	68bb      	ldr	r3, [r7, #8]
341995f4:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
341995f8:	2b00      	cmp	r3, #0
341995fa:	d10c      	bne.n	34199616 <ISP_Start+0xa6>
  {
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
341995fc:	68bb      	ldr	r3, [r7, #8]
341995fe:	334c      	adds	r3, #76	@ 0x4c
34199600:	4619      	mov	r1, r3
34199602:	6878      	ldr	r0, [r7, #4]
34199604:	f001 f9e8 	bl	3419a9d8 <ISP_SVC_Sensor_SetGain>
34199608:	4603      	mov	r3, r0
3419960a:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3419960c:	7bfb      	ldrb	r3, [r7, #15]
3419960e:	2b00      	cmp	r3, #0
34199610:	d001      	beq.n	34199616 <ISP_Start+0xa6>
    {
      return ret;
34199612:	7bfb      	ldrb	r3, [r7, #15]
34199614:	e0ac      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
34199616:	68bb      	ldr	r3, [r7, #8]
34199618:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3419961a:	2b00      	cmp	r3, #0
3419961c:	d011      	beq.n	34199642 <ISP_Start+0xd2>
3419961e:	68bb      	ldr	r3, [r7, #8]
34199620:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
34199624:	2b00      	cmp	r3, #0
34199626:	d10c      	bne.n	34199642 <ISP_Start+0xd2>
  {
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
34199628:	68bb      	ldr	r3, [r7, #8]
3419962a:	3350      	adds	r3, #80	@ 0x50
3419962c:	4619      	mov	r1, r3
3419962e:	6878      	ldr	r0, [r7, #4]
34199630:	f001 fa1e 	bl	3419aa70 <ISP_SVC_Sensor_SetExposure>
34199634:	4603      	mov	r3, r0
34199636:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
34199638:	7bfb      	ldrb	r3, [r7, #15]
3419963a:	2b00      	cmp	r3, #0
3419963c:	d001      	beq.n	34199642 <ISP_Start+0xd2>
    {
      return ret;
3419963e:	7bfb      	ldrb	r3, [r7, #15]
34199640:	e096      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
34199642:	68bb      	ldr	r3, [r7, #8]
34199644:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
34199648:	2b00      	cmp	r3, #0
3419964a:	d00c      	beq.n	34199666 <ISP_Start+0xf6>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
3419964c:	68bb      	ldr	r3, [r7, #8]
3419964e:	335c      	adds	r3, #92	@ 0x5c
34199650:	4619      	mov	r1, r3
34199652:	6878      	ldr	r0, [r7, #4]
34199654:	f000 feee 	bl	3419a434 <ISP_SVC_ISP_SetBadPixel>
34199658:	4603      	mov	r3, r0
3419965a:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3419965c:	7bfb      	ldrb	r3, [r7, #15]
3419965e:	2b00      	cmp	r3, #0
34199660:	d001      	beq.n	34199666 <ISP_Start+0xf6>
    {
      return ret;
34199662:	7bfb      	ldrb	r3, [r7, #15]
34199664:	e084      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
34199666:	68bb      	ldr	r3, [r7, #8]
34199668:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
3419966c:	2b00      	cmp	r3, #0
3419966e:	d00c      	beq.n	3419968a <ISP_Start+0x11a>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
34199670:	68bb      	ldr	r3, [r7, #8]
34199672:	3364      	adds	r3, #100	@ 0x64
34199674:	4619      	mov	r1, r3
34199676:	6878      	ldr	r0, [r7, #4]
34199678:	f000 ff50 	bl	3419a51c <ISP_SVC_ISP_SetBlackLevel>
3419967c:	4603      	mov	r3, r0
3419967e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
34199680:	7bfb      	ldrb	r3, [r7, #15]
34199682:	2b00      	cmp	r3, #0
34199684:	d001      	beq.n	3419968a <ISP_Start+0x11a>
    {
      return ret;
34199686:	7bfb      	ldrb	r3, [r7, #15]
34199688:	e072      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3419968a:	68bb      	ldr	r3, [r7, #8]
3419968c:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
34199690:	2b00      	cmp	r3, #0
34199692:	d012      	beq.n	341996ba <ISP_Start+0x14a>
34199694:	68bb      	ldr	r3, [r7, #8]
34199696:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
3419969a:	2b00      	cmp	r3, #0
3419969c:	d10d      	bne.n	341996ba <ISP_Start+0x14a>
  {
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
3419969e:	68bb      	ldr	r3, [r7, #8]
341996a0:	f503 7307 	add.w	r3, r3, #540	@ 0x21c
341996a4:	4619      	mov	r1, r3
341996a6:	6878      	ldr	r0, [r7, #4]
341996a8:	f000 ffa8 	bl	3419a5fc <ISP_SVC_ISP_SetGain>
341996ac:	4603      	mov	r3, r0
341996ae:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
341996b0:	7bfb      	ldrb	r3, [r7, #15]
341996b2:	2b00      	cmp	r3, #0
341996b4:	d001      	beq.n	341996ba <ISP_Start+0x14a>
    {
      return ret;
341996b6:	7bfb      	ldrb	r3, [r7, #15]
341996b8:	e05a      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
341996ba:	68bb      	ldr	r3, [r7, #8]
341996bc:	f893 322c 	ldrb.w	r3, [r3, #556]	@ 0x22c
341996c0:	2b00      	cmp	r3, #0
341996c2:	d012      	beq.n	341996ea <ISP_Start+0x17a>
341996c4:	68bb      	ldr	r3, [r7, #8]
341996c6:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
341996ca:	2b00      	cmp	r3, #0
341996cc:	d10d      	bne.n	341996ea <ISP_Start+0x17a>
  {
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
341996ce:	68bb      	ldr	r3, [r7, #8]
341996d0:	f503 730b 	add.w	r3, r3, #556	@ 0x22c
341996d4:	4619      	mov	r1, r3
341996d6:	6878      	ldr	r0, [r7, #4]
341996d8:	f001 f83a 	bl	3419a750 <ISP_SVC_ISP_SetColorConv>
341996dc:	4603      	mov	r3, r0
341996de:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
341996e0:	7bfb      	ldrb	r3, [r7, #15]
341996e2:	2b00      	cmp	r3, #0
341996e4:	d001      	beq.n	341996ea <ISP_Start+0x17a>
    {
      return ret;
341996e6:	7bfb      	ldrb	r3, [r7, #15]
341996e8:	e042      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  /* Configure statistic area if not already configured by ISP_SetStatArea() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
341996ea:	687b      	ldr	r3, [r7, #4]
341996ec:	691b      	ldr	r3, [r3, #16]
341996ee:	2b00      	cmp	r3, #0
341996f0:	d003      	beq.n	341996fa <ISP_Start+0x18a>
341996f2:	687b      	ldr	r3, [r7, #4]
341996f4:	695b      	ldr	r3, [r3, #20]
341996f6:	2b00      	cmp	r3, #0
341996f8:	d10c      	bne.n	34199714 <ISP_Start+0x1a4>
  {
    /* Configure statistic area from IQ params */
    ret = ISP_SVC_ISP_SetStatArea(hIsp, &IQParamConfig->statAreaStatic);
341996fa:	68bb      	ldr	r3, [r7, #8]
341996fc:	333c      	adds	r3, #60	@ 0x3c
341996fe:	4619      	mov	r1, r3
34199700:	6878      	ldr	r0, [r7, #4]
34199702:	f000 fe11 	bl	3419a328 <ISP_SVC_ISP_SetStatArea>
34199706:	4603      	mov	r3, r0
34199708:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3419970a:	7bfb      	ldrb	r3, [r7, #15]
3419970c:	2b00      	cmp	r3, #0
3419970e:	d001      	beq.n	34199714 <ISP_Start+0x1a4>
    {
      return ret;
34199710:	7bfb      	ldrb	r3, [r7, #15]
34199712:	e02d      	b.n	34199770 <ISP_Start+0x200>
    }
  }

  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
34199714:	68bb      	ldr	r3, [r7, #8]
34199716:	f503 7315 	add.w	r3, r3, #596	@ 0x254
3419971a:	4619      	mov	r1, r3
3419971c:	6878      	ldr	r0, [r7, #4]
3419971e:	f001 fa86 	bl	3419ac2e <ISP_SVC_ISP_SetGamma>
34199722:	4603      	mov	r3, r0
34199724:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
34199726:	7bfb      	ldrb	r3, [r7, #15]
34199728:	2b00      	cmp	r3, #0
3419972a:	d001      	beq.n	34199730 <ISP_Start+0x1c0>
  {
    return ret;
3419972c:	7bfb      	ldrb	r3, [r7, #15]
3419972e:	e01f      	b.n	34199770 <ISP_Start+0x200>
  }

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
34199730:	68bb      	ldr	r3, [r7, #8]
34199732:	f993 3069 	ldrsb.w	r3, [r3, #105]	@ 0x69
34199736:	ee07 3a90 	vmov	s15, r3
3419973a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419973e:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
34199742:	eec7 7a26 	vdiv.f32	s15, s14, s13
34199746:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419974a:	eeb0 1b47 	vmov.f64	d1, d7
3419974e:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
34199752:	f00c fed9 	bl	341a6508 <pow>
34199756:	eeb0 7b40 	vmov.f64	d7, d0
3419975a:	ed9f 6b07 	vldr	d6, [pc, #28]	@ 34199778 <ISP_Start+0x208>
3419975e:	ee27 7b06 	vmul.f64	d7, d7, d6
34199762:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34199766:	ee17 2a90 	vmov	r2, s15
3419976a:	68bb      	ldr	r3, [r7, #8]
3419976c:	66da      	str	r2, [r3, #108]	@ 0x6c

  return ISP_OK;
3419976e:	2300      	movs	r3, #0
}
34199770:	4618      	mov	r0, r3
34199772:	3710      	adds	r7, #16
34199774:	46bd      	mov	sp, r7
34199776:	bd80      	pop	{r7, pc}
34199778:	00000000 	.word	0x00000000
3419977c:	404c0000 	.word	0x404c0000

34199780 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
34199780:	b580      	push	{r7, lr}
34199782:	b084      	sub	sp, #16
34199784:	af00      	add	r7, sp, #0
34199786:	6078      	str	r0, [r7, #4]
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
34199788:	687b      	ldr	r3, [r7, #4]
3419978a:	2b00      	cmp	r3, #0
3419978c:	d101      	bne.n	34199792 <ISP_BackgroundProcess+0x12>
  {
    return ISP_ERR_EINVAL;
3419978e:	2301      	movs	r3, #1
34199790:	e014      	b.n	341997bc <ISP_BackgroundProcess+0x3c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
34199792:	6878      	ldr	r0, [r7, #4]
34199794:	f001 fda2 	bl	3419b2dc <ISP_SVC_Stats_ProcessCallbacks>
34199798:	4603      	mov	r3, r0
3419979a:	73fb      	strb	r3, [r7, #15]

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
3419979c:	6878      	ldr	r0, [r7, #4]
3419979e:	f7ff fdd5 	bl	3419934c <ISP_Algo_Process>
341997a2:	4603      	mov	r3, r0
341997a4:	73bb      	strb	r3, [r7, #14]
  if (retCmdParser != ISP_OK)
  {
    return retCmdParser;
  }
#endif
  if (retStats != ISP_OK)
341997a6:	7bfb      	ldrb	r3, [r7, #15]
341997a8:	2b00      	cmp	r3, #0
341997aa:	d001      	beq.n	341997b0 <ISP_BackgroundProcess+0x30>
  {
    return retStats;
341997ac:	7bfb      	ldrb	r3, [r7, #15]
341997ae:	e005      	b.n	341997bc <ISP_BackgroundProcess+0x3c>
  }
  else if (retAlgo != ISP_OK)
341997b0:	7bbb      	ldrb	r3, [r7, #14]
341997b2:	2b00      	cmp	r3, #0
341997b4:	d001      	beq.n	341997ba <ISP_BackgroundProcess+0x3a>
  {
    return retAlgo;
341997b6:	7bbb      	ldrb	r3, [r7, #14]
341997b8:	e000      	b.n	341997bc <ISP_BackgroundProcess+0x3c>
  }

  return ISP_OK;
341997ba:	2300      	movs	r3, #0
}
341997bc:	4618      	mov	r0, r3
341997be:	3710      	adds	r7, #16
341997c0:	46bd      	mov	sp, r7
341997c2:	bd80      	pop	{r7, pc}

341997c4 <ISP_ListWBRefModes>:
  * @param  hIsp: ISP device handle
  * @param  RefColorTemp: Array of reference color temperatures
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_ListWBRefModes(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp[])
{
341997c4:	b580      	push	{r7, lr}
341997c6:	b084      	sub	sp, #16
341997c8:	af00      	add	r7, sp, #0
341997ca:	6078      	str	r0, [r7, #4]
341997cc:	6039      	str	r1, [r7, #0]
  ISP_IQParamTypeDef *IQParamConfig;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
341997ce:	6878      	ldr	r0, [r7, #4]
341997d0:	f001 fa86 	bl	3419ace0 <ISP_SVC_IQParam_Get>
341997d4:	60f8      	str	r0, [r7, #12]

  memcpy(RefColorTemp, IQParamConfig->AWBAlgo.referenceColorTemp, sizeof(IQParamConfig->AWBAlgo.referenceColorTemp));
341997d6:	68fb      	ldr	r3, [r7, #12]
341997d8:	f503 738c 	add.w	r3, r3, #280	@ 0x118
341997dc:	2214      	movs	r2, #20
341997de:	4619      	mov	r1, r3
341997e0:	6838      	ldr	r0, [r7, #0]
341997e2:	f00b ff00 	bl	341a55e6 <memcpy>

  return ISP_OK;
341997e6:	2300      	movs	r3, #0
}
341997e8:	4618      	mov	r0, r3
341997ea:	3710      	adds	r7, #16
341997ec:	46bd      	mov	sp, r7
341997ee:	bd80      	pop	{r7, pc}

341997f0 <ISP_SetWBRefMode>:
  * @param  Automatic: 'true' if the AWB automatic mode is requested
  * @param  RefColorTemp: Reference color temperature (manual mode). Not significant if Automatic is set to 'true'
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint8_t Automatic, uint32_t RefColorTemp)
{
341997f0:	b580      	push	{r7, lr}
341997f2:	b096      	sub	sp, #88	@ 0x58
341997f4:	af00      	add	r7, sp, #0
341997f6:	60f8      	str	r0, [r7, #12]
341997f8:	460b      	mov	r3, r1
341997fa:	607a      	str	r2, [r7, #4]
341997fc:	72fb      	strb	r3, [r7, #11]
  ISP_ColorConvTypeDef ColorConv;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;
  uint32_t index;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
341997fe:	68f8      	ldr	r0, [r7, #12]
34199800:	f001 fa6e 	bl	3419ace0 <ISP_SVC_IQParam_Get>
34199804:	6538      	str	r0, [r7, #80]	@ 0x50

  if (Automatic)
34199806:	7afb      	ldrb	r3, [r7, #11]
34199808:	2b00      	cmp	r3, #0
3419980a:	d004      	beq.n	34199816 <ISP_SetWBRefMode+0x26>
  {
    /* Start the AWB algorithm */
    IQParamConfig->AWBAlgo.enable = 1;
3419980c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419980e:	2201      	movs	r2, #1
34199810:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
34199814:	e076      	b.n	34199904 <ISP_SetWBRefMode+0x114>
  }
  else
  {
    /* Check the validity of RefColorTemp */
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
34199816:	2300      	movs	r3, #0
34199818:	657b      	str	r3, [r7, #84]	@ 0x54
3419981a:	e00b      	b.n	34199834 <ISP_SetWBRefMode+0x44>
    {
      if (IQParamConfig->AWBAlgo.referenceColorTemp[index] == RefColorTemp)
3419981c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
3419981e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199820:	3344      	adds	r3, #68	@ 0x44
34199822:	009b      	lsls	r3, r3, #2
34199824:	4413      	add	r3, r2
34199826:	689b      	ldr	r3, [r3, #8]
34199828:	687a      	ldr	r2, [r7, #4]
3419982a:	429a      	cmp	r2, r3
3419982c:	d006      	beq.n	3419983c <ISP_SetWBRefMode+0x4c>
    for (index = 0; index < ISP_AWB_COLORTEMP_REF; index++)
3419982e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199830:	3301      	adds	r3, #1
34199832:	657b      	str	r3, [r7, #84]	@ 0x54
34199834:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199836:	2b04      	cmp	r3, #4
34199838:	d9f0      	bls.n	3419981c <ISP_SetWBRefMode+0x2c>
3419983a:	e000      	b.n	3419983e <ISP_SetWBRefMode+0x4e>
        break;
3419983c:	bf00      	nop
    }

    if (index >= ISP_AWB_COLORTEMP_REF)
3419983e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199840:	2b04      	cmp	r3, #4
34199842:	d901      	bls.n	34199848 <ISP_SetWBRefMode+0x58>
    {
      /* Unknown reference color temperature */
      return ISP_ERR_WB_COLORTEMP;
34199844:	2396      	movs	r3, #150	@ 0x96
34199846:	e05e      	b.n	34199906 <ISP_SetWBRefMode+0x116>
    }

    /* Stop the AWB algorithm */
    IQParamConfig->AWBAlgo.enable = 0;
34199848:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419984a:	2200      	movs	r2, #0
3419984c:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74

    /* Apply ISP RGB gains and Color Conversion */
    ISPGain.enable = 1;
34199850:	2301      	movs	r3, #1
34199852:	f887 303c 	strb.w	r3, [r7, #60]	@ 0x3c
    ISPGain.ispGainR = IQParamConfig->AWBAlgo.ispGainR[index];
34199856:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34199858:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419985a:	334a      	adds	r3, #74	@ 0x4a
3419985c:	009b      	lsls	r3, r3, #2
3419985e:	4413      	add	r3, r2
34199860:	685b      	ldr	r3, [r3, #4]
34199862:	643b      	str	r3, [r7, #64]	@ 0x40
    ISPGain.ispGainG = IQParamConfig->AWBAlgo.ispGainG[index];
34199864:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34199866:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199868:	334e      	adds	r3, #78	@ 0x4e
3419986a:	009b      	lsls	r3, r3, #2
3419986c:	4413      	add	r3, r2
3419986e:	689b      	ldr	r3, [r3, #8]
34199870:	647b      	str	r3, [r7, #68]	@ 0x44
    ISPGain.ispGainB = IQParamConfig->AWBAlgo.ispGainB[index];
34199872:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34199874:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34199876:	3354      	adds	r3, #84	@ 0x54
34199878:	009b      	lsls	r3, r3, #2
3419987a:	4413      	add	r3, r2
3419987c:	685b      	ldr	r3, [r3, #4]
3419987e:	64bb      	str	r3, [r7, #72]	@ 0x48
    ColorConv.enable = 1;
34199880:	2301      	movs	r3, #1
34199882:	753b      	strb	r3, [r7, #20]
    memcpy(ColorConv.coeff, IQParamConfig->AWBAlgo.coeff[index], sizeof(ColorConv.coeff));
34199884:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
34199886:	4613      	mov	r3, r2
34199888:	00db      	lsls	r3, r3, #3
3419988a:	4413      	add	r3, r2
3419988c:	009b      	lsls	r3, r3, #2
3419988e:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34199892:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34199894:	4413      	add	r3, r2
34199896:	f103 0108 	add.w	r1, r3, #8
3419989a:	f107 0314 	add.w	r3, r7, #20
3419989e:	3304      	adds	r3, #4
341998a0:	2224      	movs	r2, #36	@ 0x24
341998a2:	4618      	mov	r0, r3
341998a4:	f00b fe9f 	bl	341a55e6 <memcpy>

    ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGain);
341998a8:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
341998ac:	4619      	mov	r1, r3
341998ae:	68f8      	ldr	r0, [r7, #12]
341998b0:	f000 fea4 	bl	3419a5fc <ISP_SVC_ISP_SetGain>
341998b4:	4603      	mov	r3, r0
341998b6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
341998ba:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
341998be:	2b00      	cmp	r3, #0
341998c0:	d002      	beq.n	341998c8 <ISP_SetWBRefMode+0xd8>
    {
      return ret;
341998c2:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
341998c6:	e01e      	b.n	34199906 <ISP_SetWBRefMode+0x116>
    }

    ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConv);
341998c8:	f107 0314 	add.w	r3, r7, #20
341998cc:	4619      	mov	r1, r3
341998ce:	68f8      	ldr	r0, [r7, #12]
341998d0:	f000 ff3e 	bl	3419a750 <ISP_SVC_ISP_SetColorConv>
341998d4:	4603      	mov	r3, r0
341998d6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
341998da:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
341998de:	2b00      	cmp	r3, #0
341998e0:	d002      	beq.n	341998e8 <ISP_SetWBRefMode+0xf8>
    {
      return ret;
341998e2:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
341998e6:	e00e      	b.n	34199906 <ISP_SetWBRefMode+0x116>
    }

    /* Store the selected mode */
    ret = ISP_SVC_Misc_SetWBRefMode(hIsp, RefColorTemp);
341998e8:	6879      	ldr	r1, [r7, #4]
341998ea:	68f8      	ldr	r0, [r7, #12]
341998ec:	f001 f95e 	bl	3419abac <ISP_SVC_Misc_SetWBRefMode>
341998f0:	4603      	mov	r3, r0
341998f2:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    if (ret != ISP_OK)
341998f6:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
341998fa:	2b00      	cmp	r3, #0
341998fc:	d002      	beq.n	34199904 <ISP_SetWBRefMode+0x114>
    {
      return ret;
341998fe:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
34199902:	e000      	b.n	34199906 <ISP_SetWBRefMode+0x116>
    }
  }

  return ISP_OK;
34199904:	2300      	movs	r3, #0
}
34199906:	4618      	mov	r0, r3
34199908:	3758      	adds	r7, #88	@ 0x58
3419990a:	46bd      	mov	sp, r7
3419990c:	bd80      	pop	{r7, pc}

3419990e <ISP_GatherStatistics>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
3419990e:	b580      	push	{r7, lr}
34199910:	b082      	sub	sp, #8
34199912:	af00      	add	r7, sp, #0
34199914:	6078      	str	r0, [r7, #4]
  ISP_SVC_Stats_Gather(hIsp);
34199916:	6878      	ldr	r0, [r7, #4]
34199918:	f001 fa00 	bl	3419ad1c <ISP_SVC_Stats_Gather>
}
3419991c:	bf00      	nop
3419991e:	3708      	adds	r7, #8
34199920:	46bd      	mov	sp, r7
34199922:	bd80      	pop	{r7, pc}

34199924 <ISP_IncMainFrameId>:
  *         Increment the frame ID of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
34199924:	b580      	push	{r7, lr}
34199926:	b082      	sub	sp, #8
34199928:	af00      	add	r7, sp, #0
3419992a:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncMainFrameId(hIsp);
3419992c:	6878      	ldr	r0, [r7, #4]
3419992e:	f001 f903 	bl	3419ab38 <ISP_SVC_Misc_IncMainFrameId>
}
34199932:	bf00      	nop
34199934:	3708      	adds	r7, #8
34199936:	46bd      	mov	sp, r7
34199938:	bd80      	pop	{r7, pc}

3419993a <ISP_IncAncillaryFrameId>:
  *         Increment the frame ID of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
3419993a:	b580      	push	{r7, lr}
3419993c:	b082      	sub	sp, #8
3419993e:	af00      	add	r7, sp, #0
34199940:	6078      	str	r0, [r7, #4]
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
34199942:	6878      	ldr	r0, [r7, #4]
34199944:	f001 f913 	bl	3419ab6e <ISP_SVC_Misc_IncAncillaryFrameId>
}
34199948:	bf00      	nop
3419994a:	3708      	adds	r7, #8
3419994c:	46bd      	mov	sp, r7
3419994e:	bd80      	pop	{r7, pc}

34199950 <ISP_IncDumpFrameId>:
  *         Increment the frame ID of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
34199950:	b580      	push	{r7, lr}
34199952:	b082      	sub	sp, #8
34199954:	af00      	add	r7, sp, #0
34199956:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
34199958:	6878      	ldr	r0, [r7, #4]
3419995a:	f001 f917 	bl	3419ab8c <ISP_SVC_Misc_IncDumpFrameId>
}
3419995e:	bf00      	nop
34199960:	3708      	adds	r7, #8
34199962:	46bd      	mov	sp, r7
34199964:	bd80      	pop	{r7, pc}
	...

34199968 <To_Shift_Multiplier>:
/* Exported variables --------------------------------------------------------*/
extern ISP_MetaTypeDef Meta;

/* Private functions ---------------------------------------------------------*/
static void To_Shift_Multiplier(uint32_t Factor, uint8_t *pShift, uint8_t *pMultiplier)
{
34199968:	b5b0      	push	{r4, r5, r7, lr}
3419996a:	b086      	sub	sp, #24
3419996c:	af00      	add	r7, sp, #0
3419996e:	60f8      	str	r0, [r7, #12]
34199970:	60b9      	str	r1, [r7, #8]
34199972:	607a      	str	r2, [r7, #4]
  /* Convert Factor (Unit = 100000000 for "x1.0") to Multiplier (where 128 means "x1.0") */
  uint64_t Val = Factor;
34199974:	68fb      	ldr	r3, [r7, #12]
34199976:	2200      	movs	r2, #0
34199978:	461c      	mov	r4, r3
3419997a:	4615      	mov	r5, r2
3419997c:	e9c7 4504 	strd	r4, r5, [r7, #16]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
34199980:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34199984:	4610      	mov	r0, r2
34199986:	4619      	mov	r1, r3
34199988:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3419998c:	a314      	add	r3, pc, #80	@ (adr r3, 341999e0 <To_Shift_Multiplier+0x78>)
3419998e:	e9d3 2300 	ldrd	r2, r3, [r3]
34199992:	f7e7 ff23 	bl	341817dc <__aeabi_uldivmod>
34199996:	4602      	mov	r2, r0
34199998:	460b      	mov	r3, r1
3419999a:	e9c7 2304 	strd	r2, r3, [r7, #16]

  /* Get Shift + Multiplier where Multiplier < 256 */
  *pShift = 0;
3419999e:	68bb      	ldr	r3, [r7, #8]
341999a0:	2200      	movs	r2, #0
341999a2:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
341999a4:	e00b      	b.n	341999be <To_Shift_Multiplier+0x56>
  {
    Val /= 2;
341999a6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
341999aa:	ea52 035f 	orrs.w	r3, r2, pc, lsr #1
341999ae:	e9c7 2304 	strd	r2, r3, [r7, #16]
    (*pShift)++;
341999b2:	68bb      	ldr	r3, [r7, #8]
341999b4:	781b      	ldrb	r3, [r3, #0]
341999b6:	3301      	adds	r3, #1
341999b8:	b2da      	uxtb	r2, r3
341999ba:	68bb      	ldr	r3, [r7, #8]
341999bc:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
341999be:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
341999c2:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
341999c6:	f173 0300 	sbcs.w	r3, r3, #0
341999ca:	d2ec      	bcs.n	341999a6 <To_Shift_Multiplier+0x3e>
  }

  *pMultiplier = (uint8_t)Val;
341999cc:	7c3a      	ldrb	r2, [r7, #16]
341999ce:	687b      	ldr	r3, [r7, #4]
341999d0:	701a      	strb	r2, [r3, #0]
}
341999d2:	bf00      	nop
341999d4:	3718      	adds	r7, #24
341999d6:	46bd      	mov	sp, r7
341999d8:	bdb0      	pop	{r4, r5, r7, pc}
341999da:	bf00      	nop
341999dc:	f3af 8000 	nop.w
341999e0:	05f5e100 	.word	0x05f5e100
341999e4:	00000000 	.word	0x00000000

341999e8 <From_Shift_Multiplier>:

static uint32_t From_Shift_Multiplier(uint8_t Shift, uint8_t Multiplier)
{
341999e8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
341999ec:	b084      	sub	sp, #16
341999ee:	af00      	add	r7, sp, #0
341999f0:	4606      	mov	r6, r0
341999f2:	4608      	mov	r0, r1
341999f4:	4631      	mov	r1, r6
341999f6:	71f9      	strb	r1, [r7, #7]
341999f8:	4601      	mov	r1, r0
341999fa:	71b9      	strb	r1, [r7, #6]
  /* Convert Shift + Multiplier to Factor (Unit = 100000000 for "x1.0") */
  uint64_t Val = (1 << Shift);
341999fc:	79f9      	ldrb	r1, [r7, #7]
341999fe:	2001      	movs	r0, #1
34199a00:	fa00 f101 	lsl.w	r1, r0, r1
34199a04:	17c8      	asrs	r0, r1, #31
34199a06:	468a      	mov	sl, r1
34199a08:	4683      	mov	fp, r0
34199a0a:	e9c7 ab02 	strd	sl, fp, [r7, #8]
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
34199a0e:	79b9      	ldrb	r1, [r7, #6]
34199a10:	2000      	movs	r0, #0
34199a12:	4688      	mov	r8, r1
34199a14:	4681      	mov	r9, r0
34199a16:	68b9      	ldr	r1, [r7, #8]
34199a18:	fb09 f001 	mul.w	r0, r9, r1
34199a1c:	68f9      	ldr	r1, [r7, #12]
34199a1e:	fb08 f101 	mul.w	r1, r8, r1
34199a22:	4401      	add	r1, r0
34199a24:	68b8      	ldr	r0, [r7, #8]
34199a26:	fba0 2308 	umull	r2, r3, r0, r8
34199a2a:	4419      	add	r1, r3
34199a2c:	460b      	mov	r3, r1
34199a2e:	490c      	ldr	r1, [pc, #48]	@ (34199a60 <From_Shift_Multiplier+0x78>)
34199a30:	fb01 f003 	mul.w	r0, r1, r3
34199a34:	2100      	movs	r1, #0
34199a36:	fb02 f101 	mul.w	r1, r2, r1
34199a3a:	4401      	add	r1, r0
34199a3c:	4808      	ldr	r0, [pc, #32]	@ (34199a60 <From_Shift_Multiplier+0x78>)
34199a3e:	fba2 4500 	umull	r4, r5, r2, r0
34199a42:	194b      	adds	r3, r1, r5
34199a44:	461d      	mov	r5, r3
34199a46:	4622      	mov	r2, r4
34199a48:	462b      	mov	r3, r5
34199a4a:	ea52 13df 	orrs.w	r3, r2, pc, lsr #7
34199a4e:	e9c7 2302 	strd	r2, r3, [r7, #8]
  return (uint32_t) Val;
34199a52:	68bb      	ldr	r3, [r7, #8]
}
34199a54:	4618      	mov	r0, r3
34199a56:	3710      	adds	r7, #16
34199a58:	46bd      	mov	sp, r7
34199a5a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
34199a5e:	4770      	bx	lr
34199a60:	05f5e100 	.word	0x05f5e100

34199a64 <To_CConv_Reg>:

static int16_t To_CConv_Reg(int32_t Coeff)
{
34199a64:	b580      	push	{r7, lr}
34199a66:	b084      	sub	sp, #16
34199a68:	af00      	add	r7, sp, #0
34199a6a:	6078      	str	r0, [r7, #4]
  /* Convert Coefficient (Unit = 100000000 for "x1.0") to register format */
  int64_t Val = Coeff;
34199a6c:	6879      	ldr	r1, [r7, #4]
34199a6e:	17c8      	asrs	r0, r1, #31
34199a70:	460a      	mov	r2, r1
34199a72:	4603      	mov	r3, r0
34199a74:	e9c7 2302 	strd	r2, r3, [r7, #8]

  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
34199a78:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34199a7c:	4a07      	ldr	r2, [pc, #28]	@ (34199a9c <To_CConv_Reg+0x38>)
34199a7e:	f04f 0300 	mov.w	r3, #0
34199a82:	f7e7 fe5b 	bl	3418173c <__aeabi_ldivmod>
34199a86:	4602      	mov	r2, r0
34199a88:	460b      	mov	r3, r1
34199a8a:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int16_t) Val;
34199a8e:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
}
34199a92:	4618      	mov	r0, r3
34199a94:	3710      	adds	r7, #16
34199a96:	46bd      	mov	sp, r7
34199a98:	bd80      	pop	{r7, pc}
34199a9a:	bf00      	nop
34199a9c:	0005f5e1 	.word	0x0005f5e1

34199aa0 <From_CConv_Reg>:

static int32_t From_CConv_Reg(int16_t Reg)
{
34199aa0:	b4b0      	push	{r4, r5, r7}
34199aa2:	b085      	sub	sp, #20
34199aa4:	af00      	add	r7, sp, #0
34199aa6:	4601      	mov	r1, r0
34199aa8:	80f9      	strh	r1, [r7, #6]
  /* Convert from register format to Coefficient (Unit = 100000000 for "x1.0") */
  int64_t Val = Reg;
34199aaa:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
34199aae:	17c8      	asrs	r0, r1, #31
34199ab0:	460c      	mov	r4, r1
34199ab2:	4605      	mov	r5, r0
34199ab4:	e9c7 4502 	strd	r4, r5, [r7, #8]

  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
34199ab8:	68f9      	ldr	r1, [r7, #12]
34199aba:	480c      	ldr	r0, [pc, #48]	@ (34199aec <From_CConv_Reg+0x4c>)
34199abc:	fb01 f000 	mul.w	r0, r1, r0
34199ac0:	68b9      	ldr	r1, [r7, #8]
34199ac2:	2400      	movs	r4, #0
34199ac4:	fb04 f101 	mul.w	r1, r4, r1
34199ac8:	4401      	add	r1, r0
34199aca:	68b8      	ldr	r0, [r7, #8]
34199acc:	4c07      	ldr	r4, [pc, #28]	@ (34199aec <From_CConv_Reg+0x4c>)
34199ace:	fba0 2304 	umull	r2, r3, r0, r4
34199ad2:	4419      	add	r1, r3
34199ad4:	460b      	mov	r3, r1
34199ad6:	e9c7 2302 	strd	r2, r3, [r7, #8]
34199ada:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int32_t) Val;
34199ade:	68bb      	ldr	r3, [r7, #8]
}
34199ae0:	4618      	mov	r0, r3
34199ae2:	3714      	adds	r7, #20
34199ae4:	46bd      	mov	sp, r7
34199ae6:	bcb0      	pop	{r4, r5, r7}
34199ae8:	4770      	bx	lr
34199aea:	bf00      	nop
34199aec:	0005f5e1 	.word	0x0005f5e1

34199af0 <GetAvgStats>:

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
34199af0:	b480      	push	{r7}
34199af2:	b087      	sub	sp, #28
34199af4:	af00      	add	r7, sp, #0
34199af6:	60f8      	str	r0, [r7, #12]
34199af8:	607b      	str	r3, [r7, #4]
34199afa:	460b      	mov	r3, r1
34199afc:	72fb      	strb	r3, [r7, #11]
34199afe:	4613      	mov	r3, r2
34199b00:	72bb      	strb	r3, [r7, #10]
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
34199b02:	68fb      	ldr	r3, [r7, #12]
34199b04:	691b      	ldr	r3, [r3, #16]
34199b06:	68fa      	ldr	r2, [r7, #12]
34199b08:	6952      	ldr	r2, [r2, #20]
34199b0a:	fb02 f303 	mul.w	r3, r2, r3
34199b0e:	613b      	str	r3, [r7, #16]
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
34199b10:	4b18      	ldr	r3, [pc, #96]	@ (34199b74 <GetAvgStats+0x84>)
34199b12:	781b      	ldrb	r3, [r3, #0]
34199b14:	461a      	mov	r2, r3
34199b16:	4b17      	ldr	r3, [pc, #92]	@ (34199b74 <GetAvgStats+0x84>)
34199b18:	781b      	ldrb	r3, [r3, #0]
34199b1a:	fb02 f303 	mul.w	r3, r2, r3
34199b1e:	461a      	mov	r2, r3
34199b20:	693b      	ldr	r3, [r7, #16]
34199b22:	fbb3 f3f2 	udiv	r3, r3, r2
34199b26:	613b      	str	r3, [r7, #16]

  if (location == ISP_STAT_LOC_DOWN)
34199b28:	7afb      	ldrb	r3, [r7, #11]
34199b2a:	2b02      	cmp	r3, #2
34199b2c:	d102      	bne.n	34199b34 <GetAvgStats+0x44>
  {
    /* RGB format after demosaicing : 1 component per pixel */
    comp_divider = 1;
34199b2e:	2301      	movs	r3, #1
34199b30:	617b      	str	r3, [r7, #20]
34199b32:	e006      	b.n	34199b42 <GetAvgStats+0x52>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
34199b34:	7abb      	ldrb	r3, [r7, #10]
34199b36:	2b01      	cmp	r3, #1
34199b38:	d101      	bne.n	34199b3e <GetAvgStats+0x4e>
34199b3a:	2302      	movs	r3, #2
34199b3c:	e000      	b.n	34199b40 <GetAvgStats+0x50>
34199b3e:	2304      	movs	r3, #4
34199b40:	617b      	str	r3, [r7, #20]
  }

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;
34199b42:	693a      	ldr	r2, [r7, #16]
34199b44:	697b      	ldr	r3, [r7, #20]
34199b46:	fbb2 f3f3 	udiv	r3, r2, r3
34199b4a:	613b      	str	r3, [r7, #16]

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
34199b4c:	693b      	ldr	r3, [r7, #16]
34199b4e:	2b00      	cmp	r3, #0
34199b50:	d101      	bne.n	34199b56 <GetAvgStats+0x66>
  {
    return 0;
34199b52:	2300      	movs	r3, #0
34199b54:	e008      	b.n	34199b68 <GetAvgStats+0x78>
  }

  return (uint8_t)(((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix);
34199b56:	687b      	ldr	r3, [r7, #4]
34199b58:	021a      	lsls	r2, r3, #8
34199b5a:	693b      	ldr	r3, [r7, #16]
34199b5c:	085b      	lsrs	r3, r3, #1
34199b5e:	441a      	add	r2, r3
34199b60:	693b      	ldr	r3, [r7, #16]
34199b62:	fbb2 f3f3 	udiv	r3, r2, r3
34199b66:	b2db      	uxtb	r3, r3
}
34199b68:	4618      	mov	r0, r3
34199b6a:	371c      	adds	r7, #28
34199b6c:	46bd      	mov	sp, r7
34199b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
34199b72:	4770      	bx	lr
34199b74:	341c00f0 	.word	0x341c00f0

34199b78 <ReadStatHistogram>:

static void ReadStatHistogram(ISP_HandleTypeDef *hIsp, uint32_t *histogram)
{
34199b78:	b580      	push	{r7, lr}
34199b7a:	b084      	sub	sp, #16
34199b7c:	af00      	add	r7, sp, #0
34199b7e:	6078      	str	r0, [r7, #4]
34199b80:	6039      	str	r1, [r7, #0]
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34199b82:	2301      	movs	r3, #1
34199b84:	73fb      	strb	r3, [r7, #15]
34199b86:	e00f      	b.n	34199ba8 <ReadStatHistogram+0x30>
  {
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
34199b88:	687b      	ldr	r3, [r7, #4]
34199b8a:	6818      	ldr	r0, [r3, #0]
34199b8c:	7bfb      	ldrb	r3, [r7, #15]
34199b8e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
34199b92:	3b01      	subs	r3, #1
34199b94:	009b      	lsls	r3, r3, #2
34199b96:	683a      	ldr	r2, [r7, #0]
34199b98:	4413      	add	r3, r2
34199b9a:	7bfa      	ldrb	r2, [r7, #15]
34199b9c:	2101      	movs	r1, #1
34199b9e:	f7ef fac2 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint8_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
34199ba2:	7bfb      	ldrb	r3, [r7, #15]
34199ba4:	3301      	adds	r3, #1
34199ba6:	73fb      	strb	r3, [r7, #15]
34199ba8:	7bfb      	ldrb	r3, [r7, #15]
34199baa:	2b03      	cmp	r3, #3
34199bac:	d9ec      	bls.n	34199b88 <ReadStatHistogram+0x10>
  }
}
34199bae:	bf00      	nop
34199bb0:	bf00      	nop
34199bb2:	3710      	adds	r7, #16
34199bb4:	46bd      	mov	sp, r7
34199bb6:	bd80      	pop	{r7, pc}

34199bb8 <SetStatConfig>:

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
34199bb8:	b480      	push	{r7}
34199bba:	b085      	sub	sp, #20
34199bbc:	af00      	add	r7, sp, #0
34199bbe:	6078      	str	r0, [r7, #4]
34199bc0:	6039      	str	r1, [r7, #0]
  for (int i = 0; i < 3; i++)
34199bc2:	2300      	movs	r3, #0
34199bc4:	60fb      	str	r3, [r7, #12]
34199bc6:	e00e      	b.n	34199be6 <SetStatConfig+0x2e>
  {
    statConf[i] = *refConfig;
34199bc8:	68fa      	ldr	r2, [r7, #12]
34199bca:	4613      	mov	r3, r2
34199bcc:	005b      	lsls	r3, r3, #1
34199bce:	4413      	add	r3, r2
34199bd0:	009b      	lsls	r3, r3, #2
34199bd2:	461a      	mov	r2, r3
34199bd4:	687b      	ldr	r3, [r7, #4]
34199bd6:	4413      	add	r3, r2
34199bd8:	683a      	ldr	r2, [r7, #0]
34199bda:	ca07      	ldmia	r2, {r0, r1, r2}
34199bdc:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
34199be0:	68fb      	ldr	r3, [r7, #12]
34199be2:	3301      	adds	r3, #1
34199be4:	60fb      	str	r3, [r7, #12]
34199be6:	68fb      	ldr	r3, [r7, #12]
34199be8:	2b02      	cmp	r3, #2
34199bea:	dded      	ble.n	34199bc8 <SetStatConfig+0x10>
  }
}
34199bec:	bf00      	nop
34199bee:	bf00      	nop
34199bf0:	3714      	adds	r7, #20
34199bf2:	46bd      	mov	sp, r7
34199bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
34199bf8:	4770      	bx	lr
	...

34199bfc <GetNextStatStage>:

static ISP_SVC_StatEngineStage GetNextStatStage(ISP_SVC_StatEngineStage current)
{
34199bfc:	b480      	push	{r7}
34199bfe:	b085      	sub	sp, #20
34199c00:	af00      	add	r7, sp, #0
34199c02:	4603      	mov	r3, r0
34199c04:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
34199c06:	2309      	movs	r3, #9
34199c08:	73fb      	strb	r3, [r7, #15]

  /* Special mode for IQ tuning tool asking for all stats : go the the next step, no skip */
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34199c0a:	4b73      	ldr	r3, [pc, #460]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199c0c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199c10:	f003 0304 	and.w	r3, r3, #4
34199c14:	2b00      	cmp	r3, #0
34199c16:	d106      	bne.n	34199c26 <GetNextStatStage+0x2a>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34199c18:	4b6f      	ldr	r3, [pc, #444]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199c1a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199c1e:	f003 0304 	and.w	r3, r3, #4
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
34199c22:	2b00      	cmp	r3, #0
34199c24:	d00a      	beq.n	34199c3c <GetNextStatStage+0x40>
  {
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
34199c26:	79fb      	ldrb	r3, [r7, #7]
34199c28:	2b08      	cmp	r3, #8
34199c2a:	d803      	bhi.n	34199c34 <GetNextStatStage+0x38>
34199c2c:	79fb      	ldrb	r3, [r7, #7]
34199c2e:	3301      	adds	r3, #1
34199c30:	b2db      	uxtb	r3, r3
34199c32:	e000      	b.n	34199c36 <GetNextStatStage+0x3a>
34199c34:	2300      	movs	r3, #0
34199c36:	73fb      	strb	r3, [r7, #15]
    return next;
34199c38:	7bfb      	ldrb	r3, [r7, #15]
34199c3a:	e0c7      	b.n	34199dcc <GetNextStatStage+0x1d0>
   * - ISP_STAT_CFG_UP_AVG
   * - ISP_STAT_CFG_UP_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
   * - ISP_STAT_CFG_DOWN_AVG
   * - ISP_STAT_CFG_DOWN_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
  */
  switch (current)
34199c3c:	79fb      	ldrb	r3, [r7, #7]
34199c3e:	2b09      	cmp	r3, #9
34199c40:	f200 80b8 	bhi.w	34199db4 <GetNextStatStage+0x1b8>
34199c44:	a201      	add	r2, pc, #4	@ (adr r2, 34199c4c <GetNextStatStage+0x50>)
34199c46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34199c4a:	bf00      	nop
34199c4c:	34199c75 	.word	0x34199c75
34199c50:	34199db5 	.word	0x34199db5
34199c54:	34199db5 	.word	0x34199db5
34199c58:	34199db5 	.word	0x34199db5
34199c5c:	34199cc5 	.word	0x34199cc5
34199c60:	34199d15 	.word	0x34199d15
34199c64:	34199db5 	.word	0x34199db5
34199c68:	34199db5 	.word	0x34199db5
34199c6c:	34199db5 	.word	0x34199db5
34199c70:	34199d65 	.word	0x34199d65
  {
  case ISP_STAT_CFG_UP_AVG:
    /* Try Up Bins */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34199c74:	4b58      	ldr	r3, [pc, #352]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199c76:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199c7a:	f003 0302 	and.w	r3, r3, #2
34199c7e:	2b00      	cmp	r3, #0
34199c80:	d002      	beq.n	34199c88 <GetNextStatStage+0x8c>
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
34199c82:	2301      	movs	r3, #1
34199c84:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Bins : try Up Avg */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_UP_AVG;
    }
    break;
34199c86:	e099      	b.n	34199dbc <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
34199c88:	4b53      	ldr	r3, [pc, #332]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199c8a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199c8e:	f003 0301 	and.w	r3, r3, #1
34199c92:	2b00      	cmp	r3, #0
34199c94:	d002      	beq.n	34199c9c <GetNextStatStage+0xa0>
      next = ISP_STAT_CFG_DOWN_AVG;
34199c96:	2305      	movs	r3, #5
34199c98:	73fb      	strb	r3, [r7, #15]
    break;
34199c9a:	e08f      	b.n	34199dbc <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34199c9c:	4b4e      	ldr	r3, [pc, #312]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199c9e:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199ca2:	f003 0302 	and.w	r3, r3, #2
34199ca6:	2b00      	cmp	r3, #0
34199ca8:	d002      	beq.n	34199cb0 <GetNextStatStage+0xb4>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34199caa:	2306      	movs	r3, #6
34199cac:	73fb      	strb	r3, [r7, #15]
    break;
34199cae:	e085      	b.n	34199dbc <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34199cb0:	4b49      	ldr	r3, [pc, #292]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199cb2:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199cb6:	f003 0301 	and.w	r3, r3, #1
34199cba:	2b00      	cmp	r3, #0
34199cbc:	d07e      	beq.n	34199dbc <GetNextStatStage+0x1c0>
      next = ISP_STAT_CFG_UP_AVG;
34199cbe:	2300      	movs	r3, #0
34199cc0:	73fb      	strb	r3, [r7, #15]
    break;
34199cc2:	e07b      	b.n	34199dbc <GetNextStatStage+0x1c0>

  case ISP_STAT_CFG_UP_BINS_9_11:
    /* Try Down Avg */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34199cc4:	4b44      	ldr	r3, [pc, #272]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199cc6:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199cca:	f003 0301 	and.w	r3, r3, #1
34199cce:	2b00      	cmp	r3, #0
34199cd0:	d002      	beq.n	34199cd8 <GetNextStatStage+0xdc>
    {
      next = ISP_STAT_CFG_DOWN_AVG;
34199cd2:	2305      	movs	r3, #5
34199cd4:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Avg : try on Up Bins */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
    }
    break;
34199cd6:	e073      	b.n	34199dc0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34199cd8:	4b3f      	ldr	r3, [pc, #252]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199cda:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199cde:	f003 0302 	and.w	r3, r3, #2
34199ce2:	2b00      	cmp	r3, #0
34199ce4:	d002      	beq.n	34199cec <GetNextStatStage+0xf0>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34199ce6:	2306      	movs	r3, #6
34199ce8:	73fb      	strb	r3, [r7, #15]
    break;
34199cea:	e069      	b.n	34199dc0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34199cec:	4b3a      	ldr	r3, [pc, #232]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199cee:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199cf2:	f003 0301 	and.w	r3, r3, #1
34199cf6:	2b00      	cmp	r3, #0
34199cf8:	d002      	beq.n	34199d00 <GetNextStatStage+0x104>
      next = ISP_STAT_CFG_UP_AVG;
34199cfa:	2300      	movs	r3, #0
34199cfc:	73fb      	strb	r3, [r7, #15]
    break;
34199cfe:	e05f      	b.n	34199dc0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34199d00:	4b35      	ldr	r3, [pc, #212]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d02:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199d06:	f003 0302 	and.w	r3, r3, #2
34199d0a:	2b00      	cmp	r3, #0
34199d0c:	d058      	beq.n	34199dc0 <GetNextStatStage+0x1c4>
      next = ISP_STAT_CFG_UP_BINS_0_2;
34199d0e:	2301      	movs	r3, #1
34199d10:	73fb      	strb	r3, [r7, #15]
    break;
34199d12:	e055      	b.n	34199dc0 <GetNextStatStage+0x1c4>

  case ISP_STAT_CFG_DOWN_AVG:
    /* Try Down Bins */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34199d14:	4b30      	ldr	r3, [pc, #192]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d16:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199d1a:	f003 0302 	and.w	r3, r3, #2
34199d1e:	2b00      	cmp	r3, #0
34199d20:	d002      	beq.n	34199d28 <GetNextStatStage+0x12c>
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34199d22:	2306      	movs	r3, #6
34199d24:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Bins : try Down Avg */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_DOWN_AVG;
    }
    break;
34199d26:	e04d      	b.n	34199dc4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34199d28:	4b2b      	ldr	r3, [pc, #172]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d2a:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199d2e:	f003 0301 	and.w	r3, r3, #1
34199d32:	2b00      	cmp	r3, #0
34199d34:	d002      	beq.n	34199d3c <GetNextStatStage+0x140>
      next = ISP_STAT_CFG_UP_AVG;
34199d36:	2300      	movs	r3, #0
34199d38:	73fb      	strb	r3, [r7, #15]
    break;
34199d3a:	e043      	b.n	34199dc4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34199d3c:	4b26      	ldr	r3, [pc, #152]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d3e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199d42:	f003 0302 	and.w	r3, r3, #2
34199d46:	2b00      	cmp	r3, #0
34199d48:	d002      	beq.n	34199d50 <GetNextStatStage+0x154>
      next = ISP_STAT_CFG_UP_BINS_0_2;
34199d4a:	2301      	movs	r3, #1
34199d4c:	73fb      	strb	r3, [r7, #15]
    break;
34199d4e:	e039      	b.n	34199dc4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34199d50:	4b21      	ldr	r3, [pc, #132]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d52:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199d56:	f003 0301 	and.w	r3, r3, #1
34199d5a:	2b00      	cmp	r3, #0
34199d5c:	d032      	beq.n	34199dc4 <GetNextStatStage+0x1c8>
      next = ISP_STAT_CFG_DOWN_AVG;
34199d5e:	2305      	movs	r3, #5
34199d60:	73fb      	strb	r3, [r7, #15]
    break;
34199d62:	e02f      	b.n	34199dc4 <GetNextStatStage+0x1c8>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    /* Try Up Avg */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
34199d64:	4b1c      	ldr	r3, [pc, #112]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d66:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199d6a:	f003 0301 	and.w	r3, r3, #1
34199d6e:	2b00      	cmp	r3, #0
34199d70:	d002      	beq.n	34199d78 <GetNextStatStage+0x17c>
    {
      next = ISP_STAT_CFG_UP_AVG;
34199d72:	2300      	movs	r3, #0
34199d74:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Avg : try Down Bins */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
    }
    break;
34199d76:	e027      	b.n	34199dc8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
34199d78:	4b17      	ldr	r3, [pc, #92]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d7a:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199d7e:	f003 0302 	and.w	r3, r3, #2
34199d82:	2b00      	cmp	r3, #0
34199d84:	d002      	beq.n	34199d8c <GetNextStatStage+0x190>
      next = ISP_STAT_CFG_UP_BINS_0_2;
34199d86:	2301      	movs	r3, #1
34199d88:	73fb      	strb	r3, [r7, #15]
    break;
34199d8a:	e01d      	b.n	34199dc8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
34199d8c:	4b12      	ldr	r3, [pc, #72]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199d8e:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199d92:	f003 0301 	and.w	r3, r3, #1
34199d96:	2b00      	cmp	r3, #0
34199d98:	d002      	beq.n	34199da0 <GetNextStatStage+0x1a4>
      next = ISP_STAT_CFG_DOWN_AVG;
34199d9a:	2305      	movs	r3, #5
34199d9c:	73fb      	strb	r3, [r7, #15]
    break;
34199d9e:	e013      	b.n	34199dc8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
34199da0:	4b0d      	ldr	r3, [pc, #52]	@ (34199dd8 <GetNextStatStage+0x1dc>)
34199da2:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199da6:	f003 0302 	and.w	r3, r3, #2
34199daa:	2b00      	cmp	r3, #0
34199dac:	d00c      	beq.n	34199dc8 <GetNextStatStage+0x1cc>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
34199dae:	2306      	movs	r3, #6
34199db0:	73fb      	strb	r3, [r7, #15]
    break;
34199db2:	e009      	b.n	34199dc8 <GetNextStatStage+0x1cc>

  default:
    /* In the middle of the bins measurement: continue with the next bins part */
    next = (ISP_SVC_StatEngineStage) (current + 1);
34199db4:	79fb      	ldrb	r3, [r7, #7]
34199db6:	3301      	adds	r3, #1
34199db8:	73fb      	strb	r3, [r7, #15]
    break;
34199dba:	e006      	b.n	34199dca <GetNextStatStage+0x1ce>
    break;
34199dbc:	bf00      	nop
34199dbe:	e004      	b.n	34199dca <GetNextStatStage+0x1ce>
    break;
34199dc0:	bf00      	nop
34199dc2:	e002      	b.n	34199dca <GetNextStatStage+0x1ce>
    break;
34199dc4:	bf00      	nop
34199dc6:	e000      	b.n	34199dca <GetNextStatStage+0x1ce>
    break;
34199dc8:	bf00      	nop
  }

  return next;
34199dca:	7bfb      	ldrb	r3, [r7, #15]
}
34199dcc:	4618      	mov	r0, r3
34199dce:	3714      	adds	r7, #20
34199dd0:	46bd      	mov	sp, r7
34199dd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34199dd6:	4770      	bx	lr
34199dd8:	341c1808 	.word	0x341c1808

34199ddc <GetStatCycleStart>:

static ISP_SVC_StatEngineStage GetStatCycleStart(ISP_SVC_StatLocation location)
{
34199ddc:	b480      	push	{r7}
34199dde:	b085      	sub	sp, #20
34199de0:	af00      	add	r7, sp, #0
34199de2:	4603      	mov	r3, r0
34199de4:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
34199de6:	79fb      	ldrb	r3, [r7, #7]
34199de8:	2b01      	cmp	r3, #1
34199dea:	d113      	bne.n	34199e14 <GetStatCycleStart+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34199dec:	4b16      	ldr	r3, [pc, #88]	@ (34199e48 <GetStatCycleStart+0x6c>)
34199dee:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199df2:	f003 0301 	and.w	r3, r3, #1
34199df6:	2b00      	cmp	r3, #0
34199df8:	d106      	bne.n	34199e08 <GetStatCycleStart+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
34199dfa:	4b13      	ldr	r3, [pc, #76]	@ (34199e48 <GetStatCycleStart+0x6c>)
34199dfc:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199e00:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
34199e04:	2b00      	cmp	r3, #0
34199e06:	d002      	beq.n	34199e0e <GetStatCycleStart+0x32>
    {
      /* Stat up cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
34199e08:	2300      	movs	r3, #0
34199e0a:	73fb      	strb	r3, [r7, #15]
34199e0c:	e015      	b.n	34199e3a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat up cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_UP_BINS_0_2;
34199e0e:	2301      	movs	r3, #1
34199e10:	73fb      	strb	r3, [r7, #15]
34199e12:	e012      	b.n	34199e3a <GetStatCycleStart+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34199e14:	4b0c      	ldr	r3, [pc, #48]	@ (34199e48 <GetStatCycleStart+0x6c>)
34199e16:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199e1a:	f003 0301 	and.w	r3, r3, #1
34199e1e:	2b00      	cmp	r3, #0
34199e20:	d106      	bne.n	34199e30 <GetStatCycleStart+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34199e22:	4b09      	ldr	r3, [pc, #36]	@ (34199e48 <GetStatCycleStart+0x6c>)
34199e24:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199e28:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
34199e2c:	2b00      	cmp	r3, #0
34199e2e:	d002      	beq.n	34199e36 <GetStatCycleStart+0x5a>
    {
      /* Stat down cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
34199e30:	2305      	movs	r3, #5
34199e32:	73fb      	strb	r3, [r7, #15]
34199e34:	e001      	b.n	34199e3a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat down cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_0_2;
34199e36:	2306      	movs	r3, #6
34199e38:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
34199e3a:	7bfb      	ldrb	r3, [r7, #15]
}
34199e3c:	4618      	mov	r0, r3
34199e3e:	3714      	adds	r7, #20
34199e40:	46bd      	mov	sp, r7
34199e42:	f85d 7b04 	ldr.w	r7, [sp], #4
34199e46:	4770      	bx	lr
34199e48:	341c1808 	.word	0x341c1808

34199e4c <GetStatCycleEnd>:

static ISP_SVC_StatEngineStage GetStatCycleEnd(ISP_SVC_StatLocation location)
{
34199e4c:	b480      	push	{r7}
34199e4e:	b085      	sub	sp, #20
34199e50:	af00      	add	r7, sp, #0
34199e52:	4603      	mov	r3, r0
34199e54:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
34199e56:	79fb      	ldrb	r3, [r7, #7]
34199e58:	2b01      	cmp	r3, #1
34199e5a:	d113      	bne.n	34199e84 <GetStatCycleEnd+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34199e5c:	4b16      	ldr	r3, [pc, #88]	@ (34199eb8 <GetStatCycleEnd+0x6c>)
34199e5e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199e62:	f003 0302 	and.w	r3, r3, #2
34199e66:	2b00      	cmp	r3, #0
34199e68:	d106      	bne.n	34199e78 <GetStatCycleEnd+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
34199e6a:	4b13      	ldr	r3, [pc, #76]	@ (34199eb8 <GetStatCycleEnd+0x6c>)
34199e6c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
34199e70:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
34199e74:	2b00      	cmp	r3, #0
34199e76:	d002      	beq.n	34199e7e <GetStatCycleEnd+0x32>
    {
      /* Stat up cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_UP_BINS_9_11;
34199e78:	2304      	movs	r3, #4
34199e7a:	73fb      	strb	r3, [r7, #15]
34199e7c:	e015      	b.n	34199eaa <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat up cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
34199e7e:	2300      	movs	r3, #0
34199e80:	73fb      	strb	r3, [r7, #15]
34199e82:	e012      	b.n	34199eaa <GetStatCycleEnd+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
34199e84:	4b0c      	ldr	r3, [pc, #48]	@ (34199eb8 <GetStatCycleEnd+0x6c>)
34199e86:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199e8a:	f003 0302 	and.w	r3, r3, #2
34199e8e:	2b00      	cmp	r3, #0
34199e90:	d106      	bne.n	34199ea0 <GetStatCycleEnd+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
34199e92:	4b09      	ldr	r3, [pc, #36]	@ (34199eb8 <GetStatCycleEnd+0x6c>)
34199e94:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
34199e98:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
34199e9c:	2b00      	cmp	r3, #0
34199e9e:	d002      	beq.n	34199ea6 <GetStatCycleEnd+0x5a>
    {
      /* Stat down cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
34199ea0:	2309      	movs	r3, #9
34199ea2:	73fb      	strb	r3, [r7, #15]
34199ea4:	e001      	b.n	34199eaa <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat down cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
34199ea6:	2305      	movs	r3, #5
34199ea8:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
34199eaa:	7bfb      	ldrb	r3, [r7, #15]
}
34199eac:	4618      	mov	r0, r3
34199eae:	3714      	adds	r7, #20
34199eb0:	46bd      	mov	sp, r7
34199eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34199eb6:	4770      	bx	lr
34199eb8:	341c1808 	.word	0x341c1808
34199ebc:	00000000 	.word	0x00000000

34199ec0 <LuminanceFromRGB>:

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
34199ec0:	b480      	push	{r7}
34199ec2:	b083      	sub	sp, #12
34199ec4:	af00      	add	r7, sp, #0
34199ec6:	4603      	mov	r3, r0
34199ec8:	71fb      	strb	r3, [r7, #7]
34199eca:	460b      	mov	r3, r1
34199ecc:	71bb      	strb	r3, [r7, #6]
34199ece:	4613      	mov	r3, r2
34199ed0:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
34199ed2:	79fb      	ldrb	r3, [r7, #7]
34199ed4:	ee07 3a90 	vmov	s15, r3
34199ed8:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34199edc:	ed9f 6b12 	vldr	d6, [pc, #72]	@ 34199f28 <LuminanceFromRGB+0x68>
34199ee0:	ee27 6b06 	vmul.f64	d6, d7, d6
34199ee4:	79bb      	ldrb	r3, [r7, #6]
34199ee6:	ee07 3a90 	vmov	s15, r3
34199eea:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34199eee:	ed9f 5b10 	vldr	d5, [pc, #64]	@ 34199f30 <LuminanceFromRGB+0x70>
34199ef2:	ee27 7b05 	vmul.f64	d7, d7, d5
34199ef6:	ee36 6b07 	vadd.f64	d6, d6, d7
34199efa:	797b      	ldrb	r3, [r7, #5]
34199efc:	ee07 3a90 	vmov	s15, r3
34199f00:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34199f04:	ed9f 5b0c 	vldr	d5, [pc, #48]	@ 34199f38 <LuminanceFromRGB+0x78>
34199f08:	ee27 7b05 	vmul.f64	d7, d7, d5
34199f0c:	ee36 7b07 	vadd.f64	d7, d6, d7
34199f10:	eefc 7bc7 	vcvt.u32.f64	s15, d7
34199f14:	edc7 7a00 	vstr	s15, [r7]
34199f18:	783b      	ldrb	r3, [r7, #0]
34199f1a:	b2db      	uxtb	r3, r3
}
34199f1c:	4618      	mov	r0, r3
34199f1e:	370c      	adds	r7, #12
34199f20:	46bd      	mov	sp, r7
34199f22:	f85d 7b04 	ldr.w	r7, [sp], #4
34199f26:	4770      	bx	lr
34199f28:	e5604189 	.word	0xe5604189
34199f2c:	3fd322d0 	.word	0x3fd322d0
34199f30:	39581062 	.word	0x39581062
34199f34:	3fe2c8b4 	.word	0x3fe2c8b4
34199f38:	9fbe76c9 	.word	0x9fbe76c9
34199f3c:	3fbd2f1a 	.word	0x3fbd2f1a

34199f40 <LuminanceFromRGBMono>:

uint8_t LuminanceFromRGBMono(uint8_t r, uint8_t g, uint8_t b)
{
34199f40:	b480      	push	{r7}
34199f42:	b085      	sub	sp, #20
34199f44:	af00      	add	r7, sp, #0
34199f46:	4603      	mov	r3, r0
34199f48:	71fb      	strb	r3, [r7, #7]
34199f4a:	460b      	mov	r3, r1
34199f4c:	71bb      	strb	r3, [r7, #6]
34199f4e:	4613      	mov	r3, r2
34199f50:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components
   * by adding together R, G, B components for monochrome sensor */
  uint32_t lum = (uint32_t)r + g + b;
34199f52:	79fa      	ldrb	r2, [r7, #7]
34199f54:	79bb      	ldrb	r3, [r7, #6]
34199f56:	441a      	add	r2, r3
34199f58:	797b      	ldrb	r3, [r7, #5]
34199f5a:	4413      	add	r3, r2
34199f5c:	60fb      	str	r3, [r7, #12]
  return (uint8_t)((lum > 255)? 255 : lum);
34199f5e:	68fb      	ldr	r3, [r7, #12]
34199f60:	2bff      	cmp	r3, #255	@ 0xff
34199f62:	d802      	bhi.n	34199f6a <LuminanceFromRGBMono+0x2a>
34199f64:	68fb      	ldr	r3, [r7, #12]
34199f66:	b2db      	uxtb	r3, r3
34199f68:	e000      	b.n	34199f6c <LuminanceFromRGBMono+0x2c>
34199f6a:	23ff      	movs	r3, #255	@ 0xff
}
34199f6c:	4618      	mov	r0, r3
34199f6e:	3714      	adds	r7, #20
34199f70:	46bd      	mov	sp, r7
34199f72:	f85d 7b04 	ldr.w	r7, [sp], #4
34199f76:	4770      	bx	lr

34199f78 <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
34199f78:	b580      	push	{r7, lr}
34199f7a:	b088      	sub	sp, #32
34199f7c:	af00      	add	r7, sp, #0
34199f7e:	6078      	str	r0, [r7, #4]
34199f80:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
34199f82:	687b      	ldr	r3, [r7, #4]
34199f84:	2b00      	cmp	r3, #0
34199f86:	d012      	beq.n	34199fae <ISP_SVC_ISP_SetDemosaicing+0x36>
34199f88:	683b      	ldr	r3, [r7, #0]
34199f8a:	2b00      	cmp	r3, #0
34199f8c:	d00f      	beq.n	34199fae <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34199f8e:	683b      	ldr	r3, [r7, #0]
34199f90:	789b      	ldrb	r3, [r3, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
34199f92:	2b07      	cmp	r3, #7
34199f94:	d80b      	bhi.n	34199fae <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34199f96:	683b      	ldr	r3, [r7, #0]
34199f98:	78db      	ldrb	r3, [r3, #3]
34199f9a:	2b07      	cmp	r3, #7
34199f9c:	d807      	bhi.n	34199fae <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34199f9e:	683b      	ldr	r3, [r7, #0]
34199fa0:	791b      	ldrb	r3, [r3, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
34199fa2:	2b07      	cmp	r3, #7
34199fa4:	d803      	bhi.n	34199fae <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
34199fa6:	683b      	ldr	r3, [r7, #0]
34199fa8:	795b      	ldrb	r3, [r3, #5]
34199faa:	2b07      	cmp	r3, #7
34199fac:	d901      	bls.n	34199fb2 <ISP_SVC_ISP_SetDemosaicing+0x3a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
34199fae:	230a      	movs	r3, #10
34199fb0:	e056      	b.n	3419a060 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
34199fb2:	683b      	ldr	r3, [r7, #0]
34199fb4:	781b      	ldrb	r3, [r3, #0]
34199fb6:	2b00      	cmp	r3, #0
34199fb8:	d003      	beq.n	34199fc2 <ISP_SVC_ISP_SetDemosaicing+0x4a>
34199fba:	683b      	ldr	r3, [r7, #0]
34199fbc:	785b      	ldrb	r3, [r3, #1]
34199fbe:	2b04      	cmp	r3, #4
34199fc0:	d108      	bne.n	34199fd4 <ISP_SVC_ISP_SetDemosaicing+0x5c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
34199fc2:	687b      	ldr	r3, [r7, #4]
34199fc4:	681b      	ldr	r3, [r3, #0]
34199fc6:	2101      	movs	r1, #1
34199fc8:	4618      	mov	r0, r3
34199fca:	f7ee fa1d 	bl	34188408 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
34199fce:	4603      	mov	r3, r0
34199fd0:	77fb      	strb	r3, [r7, #31]
34199fd2:	e03f      	b.n	3419a054 <ISP_SVC_ISP_SetDemosaicing+0xdc>
  }
  else
  {
    switch(pConfig->type)
34199fd4:	683b      	ldr	r3, [r7, #0]
34199fd6:	785b      	ldrb	r3, [r3, #1]
34199fd8:	2b03      	cmp	r3, #3
34199fda:	d817      	bhi.n	3419a00c <ISP_SVC_ISP_SetDemosaicing+0x94>
34199fdc:	a201      	add	r2, pc, #4	@ (adr r2, 34199fe4 <ISP_SVC_ISP_SetDemosaicing+0x6c>)
34199fde:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34199fe2:	bf00      	nop
34199fe4:	34199ff5 	.word	0x34199ff5
34199fe8:	34199ffb 	.word	0x34199ffb
34199fec:	3419a001 	.word	0x3419a001
34199ff0:	3419a007 	.word	0x3419a007
    {
      case ISP_DEMOS_TYPE_RGGB:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
34199ff4:	2300      	movs	r3, #0
34199ff6:	613b      	str	r3, [r7, #16]
        break;
34199ff8:	e00b      	b.n	3419a012 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GRBG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GRBG;
34199ffa:	2302      	movs	r3, #2
34199ffc:	613b      	str	r3, [r7, #16]
        break;
34199ffe:	e008      	b.n	3419a012 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GBRG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GBRG;
3419a000:	2304      	movs	r3, #4
3419a002:	613b      	str	r3, [r7, #16]
        break;
3419a004:	e005      	b.n	3419a012 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_BGGR:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_BGGR;
3419a006:	2306      	movs	r3, #6
3419a008:	613b      	str	r3, [r7, #16]
        break;
3419a00a:	e002      	b.n	3419a012 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      default:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
3419a00c:	2300      	movs	r3, #0
3419a00e:	613b      	str	r3, [r7, #16]
        break;
3419a010:	bf00      	nop
    }

    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
3419a012:	683b      	ldr	r3, [r7, #0]
3419a014:	789b      	ldrb	r3, [r3, #2]
3419a016:	617b      	str	r3, [r7, #20]
    rawBayerCfg.VLineStrength = (uint32_t) pConfig->lineV;
3419a018:	683b      	ldr	r3, [r7, #0]
3419a01a:	78db      	ldrb	r3, [r3, #3]
3419a01c:	60bb      	str	r3, [r7, #8]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
3419a01e:	683b      	ldr	r3, [r7, #0]
3419a020:	791b      	ldrb	r3, [r3, #4]
3419a022:	60fb      	str	r3, [r7, #12]
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
3419a024:	683b      	ldr	r3, [r7, #0]
3419a026:	795b      	ldrb	r3, [r3, #5]
3419a028:	61bb      	str	r3, [r7, #24]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3419a02a:	687b      	ldr	r3, [r7, #4]
3419a02c:	681b      	ldr	r3, [r3, #0]
3419a02e:	f107 0208 	add.w	r2, r7, #8
3419a032:	2101      	movs	r1, #1
3419a034:	4618      	mov	r0, r3
3419a036:	f7ee f98b 	bl	34188350 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
3419a03a:	4603      	mov	r3, r0
3419a03c:	77fb      	strb	r3, [r7, #31]

    if (halStatus == HAL_OK)
3419a03e:	7ffb      	ldrb	r3, [r7, #31]
3419a040:	2b00      	cmp	r3, #0
3419a042:	d107      	bne.n	3419a054 <ISP_SVC_ISP_SetDemosaicing+0xdc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a044:	687b      	ldr	r3, [r7, #4]
3419a046:	681b      	ldr	r3, [r3, #0]
3419a048:	2101      	movs	r1, #1
3419a04a:	4618      	mov	r0, r3
3419a04c:	f7ee f9bc 	bl	341883c8 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
3419a050:	4603      	mov	r3, r0
3419a052:	77fb      	strb	r3, [r7, #31]
    }
  }

  if (halStatus != HAL_OK)
3419a054:	7ffb      	ldrb	r3, [r7, #31]
3419a056:	2b00      	cmp	r3, #0
3419a058:	d001      	beq.n	3419a05e <ISP_SVC_ISP_SetDemosaicing+0xe6>
  {
    return ISP_ERR_DEMOSAICING_HAL;
3419a05a:	230b      	movs	r3, #11
3419a05c:	e000      	b.n	3419a060 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  return ISP_OK;
3419a05e:	2300      	movs	r3, #0
}
3419a060:	4618      	mov	r0, r3
3419a062:	3720      	adds	r7, #32
3419a064:	46bd      	mov	sp, r7
3419a066:	bd80      	pop	{r7, pc}

3419a068 <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
3419a068:	b580      	push	{r7, lr}
3419a06a:	b084      	sub	sp, #16
3419a06c:	af00      	add	r7, sp, #0
3419a06e:	6078      	str	r0, [r7, #4]
3419a070:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a072:	687b      	ldr	r3, [r7, #4]
3419a074:	2b00      	cmp	r3, #0
3419a076:	d00c      	beq.n	3419a092 <ISP_SVC_ISP_SetStatRemoval+0x2a>
3419a078:	683b      	ldr	r3, [r7, #0]
3419a07a:	2b00      	cmp	r3, #0
3419a07c:	d009      	beq.n	3419a092 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3419a07e:	683b      	ldr	r3, [r7, #0]
3419a080:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a082:	2b07      	cmp	r3, #7
3419a084:	d805      	bhi.n	3419a092 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3419a086:	683b      	ldr	r3, [r7, #0]
3419a088:	689b      	ldr	r3, [r3, #8]
3419a08a:	f640 72fe 	movw	r2, #4094	@ 0xffe
3419a08e:	4293      	cmp	r3, r2
3419a090:	d901      	bls.n	3419a096 <ISP_SVC_ISP_SetStatRemoval+0x2e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
3419a092:	2314      	movs	r3, #20
3419a094:	e028      	b.n	3419a0e8 <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  if (pConfig->enable == 0)
3419a096:	683b      	ldr	r3, [r7, #0]
3419a098:	781b      	ldrb	r3, [r3, #0]
3419a09a:	2b00      	cmp	r3, #0
3419a09c:	d108      	bne.n	3419a0b0 <ISP_SVC_ISP_SetStatRemoval+0x48>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a09e:	687b      	ldr	r3, [r7, #4]
3419a0a0:	681b      	ldr	r3, [r3, #0]
3419a0a2:	2101      	movs	r1, #1
3419a0a4:	4618      	mov	r0, r3
3419a0a6:	f7ee fa1a 	bl	341884de <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
3419a0aa:	4603      	mov	r3, r0
3419a0ac:	73fb      	strb	r3, [r7, #15]
3419a0ae:	e015      	b.n	3419a0dc <ISP_SVC_ISP_SetStatRemoval+0x74>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
3419a0b0:	687b      	ldr	r3, [r7, #4]
3419a0b2:	6818      	ldr	r0, [r3, #0]
3419a0b4:	683b      	ldr	r3, [r7, #0]
3419a0b6:	685a      	ldr	r2, [r3, #4]
3419a0b8:	683b      	ldr	r3, [r7, #0]
3419a0ba:	689b      	ldr	r3, [r3, #8]
3419a0bc:	2101      	movs	r1, #1
3419a0be:	f7ee f9c3 	bl	34188448 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
3419a0c2:	4603      	mov	r3, r0
3419a0c4:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3419a0c6:	7bfb      	ldrb	r3, [r7, #15]
3419a0c8:	2b00      	cmp	r3, #0
3419a0ca:	d107      	bne.n	3419a0dc <ISP_SVC_ISP_SetStatRemoval+0x74>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a0cc:	687b      	ldr	r3, [r7, #4]
3419a0ce:	681b      	ldr	r3, [r3, #0]
3419a0d0:	2101      	movs	r1, #1
3419a0d2:	4618      	mov	r0, r3
3419a0d4:	f7ee f9e3 	bl	3418849e <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
3419a0d8:	4603      	mov	r3, r0
3419a0da:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3419a0dc:	7bfb      	ldrb	r3, [r7, #15]
3419a0de:	2b00      	cmp	r3, #0
3419a0e0:	d001      	beq.n	3419a0e6 <ISP_SVC_ISP_SetStatRemoval+0x7e>
  {
    return ISP_ERR_STATREMOVAL_HAL;
3419a0e2:	2315      	movs	r3, #21
3419a0e4:	e000      	b.n	3419a0e8 <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  return ISP_OK;
3419a0e6:	2300      	movs	r3, #0
}
3419a0e8:	4618      	mov	r0, r3
3419a0ea:	3710      	adds	r7, #16
3419a0ec:	46bd      	mov	sp, r7
3419a0ee:	bd80      	pop	{r7, pc}

3419a0f0 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
3419a0f0:	b580      	push	{r7, lr}
3419a0f2:	b086      	sub	sp, #24
3419a0f4:	af00      	add	r7, sp, #0
3419a0f6:	6078      	str	r0, [r7, #4]
3419a0f8:	6039      	str	r1, [r7, #0]
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;
3419a0fa:	2300      	movs	r3, #0
3419a0fc:	75fb      	strb	r3, [r7, #23]

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a0fe:	687b      	ldr	r3, [r7, #4]
3419a100:	2b00      	cmp	r3, #0
3419a102:	d002      	beq.n	3419a10a <ISP_SVC_ISP_SetDecimation+0x1a>
3419a104:	683b      	ldr	r3, [r7, #0]
3419a106:	2b00      	cmp	r3, #0
3419a108:	d101      	bne.n	3419a10e <ISP_SVC_ISP_SetDecimation+0x1e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
3419a10a:	231e      	movs	r3, #30
3419a10c:	e04b      	b.n	3419a1a6 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  switch (pConfig->factor)
3419a10e:	683b      	ldr	r3, [r7, #0]
3419a110:	781b      	ldrb	r3, [r3, #0]
3419a112:	3b01      	subs	r3, #1
3419a114:	2b07      	cmp	r3, #7
3419a116:	d827      	bhi.n	3419a168 <ISP_SVC_ISP_SetDecimation+0x78>
3419a118:	a201      	add	r2, pc, #4	@ (adr r2, 3419a120 <ISP_SVC_ISP_SetDecimation+0x30>)
3419a11a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419a11e:	bf00      	nop
3419a120:	3419a141 	.word	0x3419a141
3419a124:	3419a14b 	.word	0x3419a14b
3419a128:	3419a169 	.word	0x3419a169
3419a12c:	3419a155 	.word	0x3419a155
3419a130:	3419a169 	.word	0x3419a169
3419a134:	3419a169 	.word	0x3419a169
3419a138:	3419a169 	.word	0x3419a169
3419a13c:	3419a15f 	.word	0x3419a15f
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
3419a140:	2300      	movs	r3, #0
3419a142:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
3419a144:	2300      	movs	r3, #0
3419a146:	613b      	str	r3, [r7, #16]
    break;
3419a148:	e010      	b.n	3419a16c <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_2:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_2;
3419a14a:	2308      	movs	r3, #8
3419a14c:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_2;
3419a14e:	2302      	movs	r3, #2
3419a150:	613b      	str	r3, [r7, #16]
    break;
3419a152:	e00b      	b.n	3419a16c <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_4:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_4;
3419a154:	2310      	movs	r3, #16
3419a156:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_4;
3419a158:	2304      	movs	r3, #4
3419a15a:	613b      	str	r3, [r7, #16]
    break;
3419a15c:	e006      	b.n	3419a16c <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_8:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_8;
3419a15e:	2318      	movs	r3, #24
3419a160:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_8;
3419a162:	2306      	movs	r3, #6
3419a164:	613b      	str	r3, [r7, #16]
    break;
3419a166:	e001      	b.n	3419a16c <ISP_SVC_ISP_SetDecimation+0x7c>

  default:
    return ISP_ERR_DECIMATION_EINVAL;
3419a168:	231e      	movs	r3, #30
3419a16a:	e01c      	b.n	3419a1a6 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
3419a16c:	687b      	ldr	r3, [r7, #4]
3419a16e:	681b      	ldr	r3, [r3, #0]
3419a170:	f107 020c 	add.w	r2, r7, #12
3419a174:	2101      	movs	r1, #1
3419a176:	4618      	mov	r0, r3
3419a178:	f7ed fec3 	bl	34187f02 <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
3419a17c:	4603      	mov	r3, r0
3419a17e:	2b00      	cmp	r3, #0
3419a180:	d001      	beq.n	3419a186 <ISP_SVC_ISP_SetDecimation+0x96>
  {
    return ISP_ERR_DECIMATION_HAL;
3419a182:	231f      	movs	r3, #31
3419a184:	e00f      	b.n	3419a1a6 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3419a186:	687b      	ldr	r3, [r7, #4]
3419a188:	681b      	ldr	r3, [r3, #0]
3419a18a:	2101      	movs	r1, #1
3419a18c:	4618      	mov	r0, r3
3419a18e:	f7ed fee9 	bl	34187f64 <HAL_DCMIPP_PIPE_EnableISPDecimation>
3419a192:	4603      	mov	r3, r0
3419a194:	2b00      	cmp	r3, #0
3419a196:	d001      	beq.n	3419a19c <ISP_SVC_ISP_SetDecimation+0xac>
  {
    return ISP_ERR_DECIMATION_HAL;
3419a198:	231f      	movs	r3, #31
3419a19a:	e004      	b.n	3419a1a6 <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;
3419a19c:	683b      	ldr	r3, [r7, #0]
3419a19e:	781a      	ldrb	r2, [r3, #0]
3419a1a0:	4b03      	ldr	r3, [pc, #12]	@ (3419a1b0 <ISP_SVC_ISP_SetDecimation+0xc0>)
3419a1a2:	701a      	strb	r2, [r3, #0]

  return ret;
3419a1a4:	7dfb      	ldrb	r3, [r7, #23]
}
3419a1a6:	4618      	mov	r0, r3
3419a1a8:	3718      	adds	r7, #24
3419a1aa:	46bd      	mov	sp, r7
3419a1ac:	bd80      	pop	{r7, pc}
3419a1ae:	bf00      	nop
3419a1b0:	341c00f0 	.word	0x341c00f0

3419a1b4 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
3419a1b4:	b580      	push	{r7, lr}
3419a1b6:	b086      	sub	sp, #24
3419a1b8:	af00      	add	r7, sp, #0
3419a1ba:	6078      	str	r0, [r7, #4]
3419a1bc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a1be:	687b      	ldr	r3, [r7, #4]
3419a1c0:	2b00      	cmp	r3, #0
3419a1c2:	d02f      	beq.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
3419a1c4:	683b      	ldr	r3, [r7, #0]
3419a1c6:	2b00      	cmp	r3, #0
3419a1c8:	d02c      	beq.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1ca:	683b      	ldr	r3, [r7, #0]
3419a1cc:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a1ce:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a1d2:	d827      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1d4:	683b      	ldr	r3, [r7, #0]
3419a1d6:	689b      	ldr	r3, [r3, #8]
3419a1d8:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a1dc:	d822      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1de:	683b      	ldr	r3, [r7, #0]
3419a1e0:	68db      	ldr	r3, [r3, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1e2:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a1e6:	d81d      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1e8:	683b      	ldr	r3, [r7, #0]
3419a1ea:	691b      	ldr	r3, [r3, #16]
3419a1ec:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a1f0:	d818      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1f2:	683b      	ldr	r3, [r7, #0]
3419a1f4:	695b      	ldr	r3, [r3, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1f6:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a1fa:	d813      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a1fc:	683b      	ldr	r3, [r7, #0]
3419a1fe:	699b      	ldr	r3, [r3, #24]
3419a200:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a204:	d80e      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a206:	683b      	ldr	r3, [r7, #0]
3419a208:	69db      	ldr	r3, [r3, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a20a:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a20e:	d809      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a210:	683b      	ldr	r3, [r7, #0]
3419a212:	6a1b      	ldr	r3, [r3, #32]
3419a214:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a218:	d804      	bhi.n	3419a224 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
3419a21a:	683b      	ldr	r3, [r7, #0]
3419a21c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3419a21e:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3419a222:	d901      	bls.n	3419a228 <ISP_SVC_ISP_SetContrast+0x74>
  {
    return ISP_ERR_CONTRAST_EINVAL;
3419a224:	2328      	movs	r3, #40	@ 0x28
3419a226:	e078      	b.n	3419a31a <ISP_SVC_ISP_SetContrast+0x166>
  }

  if (pConfig->enable == 0)
3419a228:	683b      	ldr	r3, [r7, #0]
3419a22a:	781b      	ldrb	r3, [r3, #0]
3419a22c:	2b00      	cmp	r3, #0
3419a22e:	d108      	bne.n	3419a242 <ISP_SVC_ISP_SetContrast+0x8e>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a230:	687b      	ldr	r3, [r7, #4]
3419a232:	681b      	ldr	r3, [r3, #0]
3419a234:	2101      	movs	r1, #1
3419a236:	4618      	mov	r0, r3
3419a238:	f7ee fe54 	bl	34188ee4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
3419a23c:	4603      	mov	r3, r0
3419a23e:	75fb      	strb	r3, [r7, #23]
3419a240:	e065      	b.n	3419a30e <ISP_SVC_ISP_SetContrast+0x15a>
  }
  else
  {
    /* Convert coefficient unit from "percentage" to "6 bit" */
    contrast.LUM_0 = (uint8_t)((pConfig->coeff.LUM_0 * 16) / 100);
3419a242:	683b      	ldr	r3, [r7, #0]
3419a244:	685b      	ldr	r3, [r3, #4]
3419a246:	011b      	lsls	r3, r3, #4
3419a248:	4a36      	ldr	r2, [pc, #216]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a24a:	fba2 2303 	umull	r2, r3, r2, r3
3419a24e:	095b      	lsrs	r3, r3, #5
3419a250:	b2db      	uxtb	r3, r3
3419a252:	733b      	strb	r3, [r7, #12]
    contrast.LUM_32 = (uint8_t)((pConfig->coeff.LUM_32 * 16) / 100);
3419a254:	683b      	ldr	r3, [r7, #0]
3419a256:	689b      	ldr	r3, [r3, #8]
3419a258:	011b      	lsls	r3, r3, #4
3419a25a:	4a32      	ldr	r2, [pc, #200]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a25c:	fba2 2303 	umull	r2, r3, r2, r3
3419a260:	095b      	lsrs	r3, r3, #5
3419a262:	b2db      	uxtb	r3, r3
3419a264:	737b      	strb	r3, [r7, #13]
    contrast.LUM_64 = (uint8_t)((pConfig->coeff.LUM_64 * 16) / 100);
3419a266:	683b      	ldr	r3, [r7, #0]
3419a268:	68db      	ldr	r3, [r3, #12]
3419a26a:	011b      	lsls	r3, r3, #4
3419a26c:	4a2d      	ldr	r2, [pc, #180]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a26e:	fba2 2303 	umull	r2, r3, r2, r3
3419a272:	095b      	lsrs	r3, r3, #5
3419a274:	b2db      	uxtb	r3, r3
3419a276:	73bb      	strb	r3, [r7, #14]
    contrast.LUM_96 = (uint8_t)((pConfig->coeff.LUM_96 * 16) / 100);
3419a278:	683b      	ldr	r3, [r7, #0]
3419a27a:	691b      	ldr	r3, [r3, #16]
3419a27c:	011b      	lsls	r3, r3, #4
3419a27e:	4a29      	ldr	r2, [pc, #164]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a280:	fba2 2303 	umull	r2, r3, r2, r3
3419a284:	095b      	lsrs	r3, r3, #5
3419a286:	b2db      	uxtb	r3, r3
3419a288:	73fb      	strb	r3, [r7, #15]
    contrast.LUM_128 = (uint8_t)((pConfig->coeff.LUM_128 * 16) / 100);
3419a28a:	683b      	ldr	r3, [r7, #0]
3419a28c:	695b      	ldr	r3, [r3, #20]
3419a28e:	011b      	lsls	r3, r3, #4
3419a290:	4a24      	ldr	r2, [pc, #144]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a292:	fba2 2303 	umull	r2, r3, r2, r3
3419a296:	095b      	lsrs	r3, r3, #5
3419a298:	b2db      	uxtb	r3, r3
3419a29a:	743b      	strb	r3, [r7, #16]
    contrast.LUM_160 = (uint8_t)((pConfig->coeff.LUM_160 * 16) / 100);
3419a29c:	683b      	ldr	r3, [r7, #0]
3419a29e:	699b      	ldr	r3, [r3, #24]
3419a2a0:	011b      	lsls	r3, r3, #4
3419a2a2:	4a20      	ldr	r2, [pc, #128]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a2a4:	fba2 2303 	umull	r2, r3, r2, r3
3419a2a8:	095b      	lsrs	r3, r3, #5
3419a2aa:	b2db      	uxtb	r3, r3
3419a2ac:	747b      	strb	r3, [r7, #17]
    contrast.LUM_192 = (uint8_t)((pConfig->coeff.LUM_192 * 16) / 100);
3419a2ae:	683b      	ldr	r3, [r7, #0]
3419a2b0:	69db      	ldr	r3, [r3, #28]
3419a2b2:	011b      	lsls	r3, r3, #4
3419a2b4:	4a1b      	ldr	r2, [pc, #108]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a2b6:	fba2 2303 	umull	r2, r3, r2, r3
3419a2ba:	095b      	lsrs	r3, r3, #5
3419a2bc:	b2db      	uxtb	r3, r3
3419a2be:	74bb      	strb	r3, [r7, #18]
    contrast.LUM_224 = (uint8_t)((pConfig->coeff.LUM_224 * 16) / 100);
3419a2c0:	683b      	ldr	r3, [r7, #0]
3419a2c2:	6a1b      	ldr	r3, [r3, #32]
3419a2c4:	011b      	lsls	r3, r3, #4
3419a2c6:	4a17      	ldr	r2, [pc, #92]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a2c8:	fba2 2303 	umull	r2, r3, r2, r3
3419a2cc:	095b      	lsrs	r3, r3, #5
3419a2ce:	b2db      	uxtb	r3, r3
3419a2d0:	74fb      	strb	r3, [r7, #19]
    contrast.LUM_256 = (uint8_t)((pConfig->coeff.LUM_256 * 16) / 100);
3419a2d2:	683b      	ldr	r3, [r7, #0]
3419a2d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419a2d6:	011b      	lsls	r3, r3, #4
3419a2d8:	4a12      	ldr	r2, [pc, #72]	@ (3419a324 <ISP_SVC_ISP_SetContrast+0x170>)
3419a2da:	fba2 2303 	umull	r2, r3, r2, r3
3419a2de:	095b      	lsrs	r3, r3, #5
3419a2e0:	b2db      	uxtb	r3, r3
3419a2e2:	753b      	strb	r3, [r7, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
3419a2e4:	687b      	ldr	r3, [r7, #4]
3419a2e6:	681b      	ldr	r3, [r3, #0]
3419a2e8:	f107 020c 	add.w	r2, r7, #12
3419a2ec:	2101      	movs	r1, #1
3419a2ee:	4618      	mov	r0, r3
3419a2f0:	f7ee fd88 	bl	34188e04 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
3419a2f4:	4603      	mov	r3, r0
3419a2f6:	75fb      	strb	r3, [r7, #23]

    if (halStatus == HAL_OK)
3419a2f8:	7dfb      	ldrb	r3, [r7, #23]
3419a2fa:	2b00      	cmp	r3, #0
3419a2fc:	d107      	bne.n	3419a30e <ISP_SVC_ISP_SetContrast+0x15a>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a2fe:	687b      	ldr	r3, [r7, #4]
3419a300:	681b      	ldr	r3, [r3, #0]
3419a302:	2101      	movs	r1, #1
3419a304:	4618      	mov	r0, r3
3419a306:	f7ee fdcd 	bl	34188ea4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
3419a30a:	4603      	mov	r3, r0
3419a30c:	75fb      	strb	r3, [r7, #23]
    }
  }

  if (halStatus != HAL_OK)
3419a30e:	7dfb      	ldrb	r3, [r7, #23]
3419a310:	2b00      	cmp	r3, #0
3419a312:	d001      	beq.n	3419a318 <ISP_SVC_ISP_SetContrast+0x164>
  {
    return ISP_ERR_CONTRAST_HAL;
3419a314:	2329      	movs	r3, #41	@ 0x29
3419a316:	e000      	b.n	3419a31a <ISP_SVC_ISP_SetContrast+0x166>
  }

  return ISP_OK;
3419a318:	2300      	movs	r3, #0
}
3419a31a:	4618      	mov	r0, r3
3419a31c:	3718      	adds	r7, #24
3419a31e:	46bd      	mov	sp, r7
3419a320:	bd80      	pop	{r7, pc}
3419a322:	bf00      	nop
3419a324:	51eb851f 	.word	0x51eb851f

3419a328 <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
3419a328:	b590      	push	{r4, r7, lr}
3419a32a:	b089      	sub	sp, #36	@ 0x24
3419a32c:	af00      	add	r7, sp, #0
3419a32e:	6078      	str	r0, [r7, #4]
3419a330:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;
3419a332:	2300      	movs	r3, #0
3419a334:	77fb      	strb	r3, [r7, #31]

  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a336:	687b      	ldr	r3, [r7, #4]
3419a338:	2b00      	cmp	r3, #0
3419a33a:	d034      	beq.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
3419a33c:	683b      	ldr	r3, [r7, #0]
3419a33e:	2b00      	cmp	r3, #0
3419a340:	d031      	beq.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3419a342:	683b      	ldr	r3, [r7, #0]
3419a344:	681b      	ldr	r3, [r3, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a346:	f640 72fe 	movw	r2, #4094	@ 0xffe
3419a34a:	4293      	cmp	r3, r2
3419a34c:	d82b      	bhi.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3419a34e:	683b      	ldr	r3, [r7, #0]
3419a350:	685b      	ldr	r3, [r3, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3419a352:	f640 72fe 	movw	r2, #4094	@ 0xffe
3419a356:	4293      	cmp	r3, r2
3419a358:	d825      	bhi.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3419a35a:	683b      	ldr	r3, [r7, #0]
3419a35c:	689b      	ldr	r3, [r3, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3419a35e:	f640 72fe 	movw	r2, #4094	@ 0xffe
3419a362:	4293      	cmp	r3, r2
3419a364:	d81f      	bhi.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3419a366:	683b      	ldr	r3, [r7, #0]
3419a368:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3419a36a:	f640 72fe 	movw	r2, #4094	@ 0xffe
3419a36e:	4293      	cmp	r3, r2
3419a370:	d819      	bhi.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
3419a372:	683b      	ldr	r3, [r7, #0]
3419a374:	689b      	ldr	r3, [r3, #8]
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3419a376:	2b03      	cmp	r3, #3
3419a378:	d915      	bls.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3419a37a:	683b      	ldr	r3, [r7, #0]
3419a37c:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
3419a37e:	2b03      	cmp	r3, #3
3419a380:	d911      	bls.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3419a382:	683b      	ldr	r3, [r7, #0]
3419a384:	681a      	ldr	r2, [r3, #0]
3419a386:	683b      	ldr	r3, [r7, #0]
3419a388:	689b      	ldr	r3, [r3, #8]
3419a38a:	441a      	add	r2, r3
3419a38c:	687b      	ldr	r3, [r7, #4]
3419a38e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3419a390:	429a      	cmp	r2, r3
3419a392:	d808      	bhi.n	3419a3a6 <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
3419a394:	683b      	ldr	r3, [r7, #0]
3419a396:	685a      	ldr	r2, [r3, #4]
3419a398:	683b      	ldr	r3, [r7, #0]
3419a39a:	68db      	ldr	r3, [r3, #12]
3419a39c:	441a      	add	r2, r3
3419a39e:	687b      	ldr	r3, [r7, #4]
3419a3a0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3419a3a2:	429a      	cmp	r2, r3
3419a3a4:	d901      	bls.n	3419a3aa <ISP_SVC_ISP_SetStatArea+0x82>
  {
    return ISP_ERR_STATAREA_EINVAL;
3419a3a6:	2332      	movs	r3, #50	@ 0x32
3419a3a8:	e03e      	b.n	3419a428 <ISP_SVC_ISP_SetStatArea+0x100>
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
3419a3aa:	683b      	ldr	r3, [r7, #0]
3419a3ac:	681b      	ldr	r3, [r3, #0]
3419a3ae:	4a20      	ldr	r2, [pc, #128]	@ (3419a430 <ISP_SVC_ISP_SetStatArea+0x108>)
3419a3b0:	7812      	ldrb	r2, [r2, #0]
3419a3b2:	fbb3 f3f2 	udiv	r3, r3, r2
3419a3b6:	613b      	str	r3, [r7, #16]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
3419a3b8:	683b      	ldr	r3, [r7, #0]
3419a3ba:	685b      	ldr	r3, [r3, #4]
3419a3bc:	4a1c      	ldr	r2, [pc, #112]	@ (3419a430 <ISP_SVC_ISP_SetStatArea+0x108>)
3419a3be:	7812      	ldrb	r2, [r2, #0]
3419a3c0:	fbb3 f3f2 	udiv	r3, r3, r2
3419a3c4:	60fb      	str	r3, [r7, #12]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
3419a3c6:	683b      	ldr	r3, [r7, #0]
3419a3c8:	689b      	ldr	r3, [r3, #8]
3419a3ca:	4a19      	ldr	r2, [pc, #100]	@ (3419a430 <ISP_SVC_ISP_SetStatArea+0x108>)
3419a3cc:	7812      	ldrb	r2, [r2, #0]
3419a3ce:	fbb3 f3f2 	udiv	r3, r3, r2
3419a3d2:	61bb      	str	r3, [r7, #24]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
3419a3d4:	683b      	ldr	r3, [r7, #0]
3419a3d6:	68db      	ldr	r3, [r3, #12]
3419a3d8:	4a15      	ldr	r2, [pc, #84]	@ (3419a430 <ISP_SVC_ISP_SetStatArea+0x108>)
3419a3da:	7812      	ldrb	r2, [r2, #0]
3419a3dc:	fbb3 f3f2 	udiv	r3, r3, r2
3419a3e0:	617b      	str	r3, [r7, #20]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
3419a3e2:	687b      	ldr	r3, [r7, #4]
3419a3e4:	681b      	ldr	r3, [r3, #0]
3419a3e6:	f107 020c 	add.w	r2, r7, #12
3419a3ea:	2101      	movs	r1, #1
3419a3ec:	4618      	mov	r0, r3
3419a3ee:	f7ee fbec 	bl	34188bca <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
3419a3f2:	4603      	mov	r3, r0
3419a3f4:	2b00      	cmp	r3, #0
3419a3f6:	d001      	beq.n	3419a3fc <ISP_SVC_ISP_SetStatArea+0xd4>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
3419a3f8:	2333      	movs	r3, #51	@ 0x33
3419a3fa:	e015      	b.n	3419a428 <ISP_SVC_ISP_SetStatArea+0x100>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a3fc:	687b      	ldr	r3, [r7, #4]
3419a3fe:	681b      	ldr	r3, [r3, #0]
3419a400:	2101      	movs	r1, #1
3419a402:	4618      	mov	r0, r3
3419a404:	f7ee fc5c 	bl	34188cc0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
3419a408:	4603      	mov	r3, r0
3419a40a:	77bb      	strb	r3, [r7, #30]
  }

  if (halStatus != HAL_OK)
3419a40c:	7fbb      	ldrb	r3, [r7, #30]
3419a40e:	2b00      	cmp	r3, #0
3419a410:	d001      	beq.n	3419a416 <ISP_SVC_ISP_SetStatArea+0xee>
  {
    return ISP_ERR_STATAREA_HAL;
3419a412:	2333      	movs	r3, #51	@ 0x33
3419a414:	e008      	b.n	3419a428 <ISP_SVC_ISP_SetStatArea+0x100>
  }

  /* Update internal state */
  hIsp->statArea = *pConfig;
3419a416:	687b      	ldr	r3, [r7, #4]
3419a418:	683a      	ldr	r2, [r7, #0]
3419a41a:	f103 0408 	add.w	r4, r3, #8
3419a41e:	4613      	mov	r3, r2
3419a420:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
3419a422:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  return ret;
3419a426:	7ffb      	ldrb	r3, [r7, #31]
}
3419a428:	4618      	mov	r0, r3
3419a42a:	3724      	adds	r7, #36	@ 0x24
3419a42c:	46bd      	mov	sp, r7
3419a42e:	bd90      	pop	{r4, r7, pc}
3419a430:	341c00f0 	.word	0x341c00f0

3419a434 <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3419a434:	b580      	push	{r7, lr}
3419a436:	b084      	sub	sp, #16
3419a438:	af00      	add	r7, sp, #0
3419a43a:	6078      	str	r0, [r7, #4]
3419a43c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
3419a43e:	687b      	ldr	r3, [r7, #4]
3419a440:	2b00      	cmp	r3, #0
3419a442:	d006      	beq.n	3419a452 <ISP_SVC_ISP_SetBadPixel+0x1e>
3419a444:	683b      	ldr	r3, [r7, #0]
3419a446:	2b00      	cmp	r3, #0
3419a448:	d003      	beq.n	3419a452 <ISP_SVC_ISP_SetBadPixel+0x1e>
3419a44a:	683b      	ldr	r3, [r7, #0]
3419a44c:	785b      	ldrb	r3, [r3, #1]
3419a44e:	2b07      	cmp	r3, #7
3419a450:	d901      	bls.n	3419a456 <ISP_SVC_ISP_SetBadPixel+0x22>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
3419a452:	233c      	movs	r3, #60	@ 0x3c
3419a454:	e029      	b.n	3419a4aa <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  if (pConfig->enable == 0)
3419a456:	683b      	ldr	r3, [r7, #0]
3419a458:	781b      	ldrb	r3, [r3, #0]
3419a45a:	2b00      	cmp	r3, #0
3419a45c:	d108      	bne.n	3419a470 <ISP_SVC_ISP_SetBadPixel+0x3c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a45e:	687b      	ldr	r3, [r7, #4]
3419a460:	681b      	ldr	r3, [r3, #0]
3419a462:	2101      	movs	r1, #1
3419a464:	4618      	mov	r0, r3
3419a466:	f7ee f89e 	bl	341885a6 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
3419a46a:	4603      	mov	r3, r0
3419a46c:	73fb      	strb	r3, [r7, #15]
3419a46e:	e016      	b.n	3419a49e <ISP_SVC_ISP_SetBadPixel+0x6a>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
3419a470:	687b      	ldr	r3, [r7, #4]
3419a472:	6818      	ldr	r0, [r3, #0]
3419a474:	683b      	ldr	r3, [r7, #0]
3419a476:	785b      	ldrb	r3, [r3, #1]
3419a478:	461a      	mov	r2, r3
3419a47a:	2101      	movs	r1, #1
3419a47c:	f7ee f84f 	bl	3418851e <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
3419a480:	4603      	mov	r3, r0
3419a482:	73fb      	strb	r3, [r7, #15]

    if (halStatus != HAL_OK)
3419a484:	7bfb      	ldrb	r3, [r7, #15]
3419a486:	2b00      	cmp	r3, #0
3419a488:	d001      	beq.n	3419a48e <ISP_SVC_ISP_SetBadPixel+0x5a>
    {
      return ISP_ERR_BADPIXEL_HAL;
3419a48a:	233d      	movs	r3, #61	@ 0x3d
3419a48c:	e00d      	b.n	3419a4aa <ISP_SVC_ISP_SetBadPixel+0x76>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a48e:	687b      	ldr	r3, [r7, #4]
3419a490:	681b      	ldr	r3, [r3, #0]
3419a492:	2101      	movs	r1, #1
3419a494:	4618      	mov	r0, r3
3419a496:	f7ee f866 	bl	34188566 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
3419a49a:	4603      	mov	r3, r0
3419a49c:	73fb      	strb	r3, [r7, #15]
  }

  if (halStatus != HAL_OK)
3419a49e:	7bfb      	ldrb	r3, [r7, #15]
3419a4a0:	2b00      	cmp	r3, #0
3419a4a2:	d001      	beq.n	3419a4a8 <ISP_SVC_ISP_SetBadPixel+0x74>
  {
    return ISP_ERR_BADPIXEL_HAL;
3419a4a4:	233d      	movs	r3, #61	@ 0x3d
3419a4a6:	e000      	b.n	3419a4aa <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  return ISP_OK;
3419a4a8:	2300      	movs	r3, #0
}
3419a4aa:	4618      	mov	r0, r3
3419a4ac:	3710      	adds	r7, #16
3419a4ae:	46bd      	mov	sp, r7
3419a4b0:	bd80      	pop	{r7, pc}

3419a4b2 <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3419a4b2:	b580      	push	{r7, lr}
3419a4b4:	b084      	sub	sp, #16
3419a4b6:	af00      	add	r7, sp, #0
3419a4b8:	6078      	str	r0, [r7, #4]
3419a4ba:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a4bc:	687b      	ldr	r3, [r7, #4]
3419a4be:	2b00      	cmp	r3, #0
3419a4c0:	d002      	beq.n	3419a4c8 <ISP_SVC_ISP_GetBadPixel+0x16>
3419a4c2:	683b      	ldr	r3, [r7, #0]
3419a4c4:	2b00      	cmp	r3, #0
3419a4c6:	d101      	bne.n	3419a4cc <ISP_SVC_ISP_GetBadPixel+0x1a>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
3419a4c8:	233c      	movs	r3, #60	@ 0x3c
3419a4ca:	e023      	b.n	3419a514 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a4cc:	687b      	ldr	r3, [r7, #4]
3419a4ce:	681b      	ldr	r3, [r3, #0]
3419a4d0:	2101      	movs	r1, #1
3419a4d2:	4618      	mov	r0, r3
3419a4d4:	f7ee f899 	bl	3418860a <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
3419a4d8:	4603      	mov	r3, r0
3419a4da:	b2da      	uxtb	r2, r3
3419a4dc:	683b      	ldr	r3, [r7, #0]
3419a4de:	701a      	strb	r2, [r3, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a4e0:	687b      	ldr	r3, [r7, #4]
3419a4e2:	681b      	ldr	r3, [r3, #0]
3419a4e4:	2101      	movs	r1, #1
3419a4e6:	4618      	mov	r0, r3
3419a4e8:	f7ee f87d 	bl	341885e6 <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
3419a4ec:	4603      	mov	r3, r0
3419a4ee:	b2da      	uxtb	r2, r3
3419a4f0:	683b      	ldr	r3, [r7, #0]
3419a4f2:	705a      	strb	r2, [r3, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
3419a4f4:	687b      	ldr	r3, [r7, #4]
3419a4f6:	6818      	ldr	r0, [r3, #0]
3419a4f8:	683b      	ldr	r3, [r7, #0]
3419a4fa:	3304      	adds	r3, #4
3419a4fc:	461a      	mov	r2, r3
3419a4fe:	2101      	movs	r1, #1
3419a500:	f7ee f89e 	bl	34188640 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>
3419a504:	4603      	mov	r3, r0
3419a506:	73fb      	strb	r3, [r7, #15]

  if (halStatus != HAL_OK)
3419a508:	7bfb      	ldrb	r3, [r7, #15]
3419a50a:	2b00      	cmp	r3, #0
3419a50c:	d001      	beq.n	3419a512 <ISP_SVC_ISP_GetBadPixel+0x60>
  {
    return ISP_ERR_BADPIXEL_HAL;
3419a50e:	233d      	movs	r3, #61	@ 0x3d
3419a510:	e000      	b.n	3419a514 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  return ISP_OK;
3419a512:	2300      	movs	r3, #0
}
3419a514:	4618      	mov	r0, r3
3419a516:	3710      	adds	r7, #16
3419a518:	46bd      	mov	sp, r7
3419a51a:	bd80      	pop	{r7, pc}

3419a51c <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3419a51c:	b580      	push	{r7, lr}
3419a51e:	b084      	sub	sp, #16
3419a520:	af00      	add	r7, sp, #0
3419a522:	6078      	str	r0, [r7, #4]
3419a524:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a526:	687b      	ldr	r3, [r7, #4]
3419a528:	2b00      	cmp	r3, #0
3419a52a:	d002      	beq.n	3419a532 <ISP_SVC_ISP_SetBlackLevel+0x16>
3419a52c:	683b      	ldr	r3, [r7, #0]
3419a52e:	2b00      	cmp	r3, #0
3419a530:	d101      	bne.n	3419a536 <ISP_SVC_ISP_SetBlackLevel+0x1a>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
3419a532:	2346      	movs	r3, #70	@ 0x46
3419a534:	e030      	b.n	3419a598 <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  if (pConfig->enable == 0)
3419a536:	683b      	ldr	r3, [r7, #0]
3419a538:	781b      	ldrb	r3, [r3, #0]
3419a53a:	2b00      	cmp	r3, #0
3419a53c:	d108      	bne.n	3419a550 <ISP_SVC_ISP_SetBlackLevel+0x34>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a53e:	687b      	ldr	r3, [r7, #4]
3419a540:	681b      	ldr	r3, [r3, #0]
3419a542:	2101      	movs	r1, #1
3419a544:	4618      	mov	r0, r3
3419a546:	f7ee fa90 	bl	34188a6a <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
3419a54a:	4603      	mov	r3, r0
3419a54c:	73fb      	strb	r3, [r7, #15]
3419a54e:	e01d      	b.n	3419a58c <ISP_SVC_ISP_SetBlackLevel+0x70>
  }
  else
  {
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3419a550:	683b      	ldr	r3, [r7, #0]
3419a552:	785b      	ldrb	r3, [r3, #1]
3419a554:	733b      	strb	r3, [r7, #12]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
3419a556:	683b      	ldr	r3, [r7, #0]
3419a558:	789b      	ldrb	r3, [r3, #2]
3419a55a:	737b      	strb	r3, [r7, #13]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
3419a55c:	683b      	ldr	r3, [r7, #0]
3419a55e:	78db      	ldrb	r3, [r3, #3]
3419a560:	73bb      	strb	r3, [r7, #14]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3419a562:	687b      	ldr	r3, [r7, #4]
3419a564:	681b      	ldr	r3, [r3, #0]
3419a566:	f107 020c 	add.w	r2, r7, #12
3419a56a:	2101      	movs	r1, #1
3419a56c:	4618      	mov	r0, r3
3419a56e:	f7ee fa2d 	bl	341889cc <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
3419a572:	4603      	mov	r3, r0
3419a574:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3419a576:	7bfb      	ldrb	r3, [r7, #15]
3419a578:	2b00      	cmp	r3, #0
3419a57a:	d107      	bne.n	3419a58c <ISP_SVC_ISP_SetBlackLevel+0x70>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a57c:	687b      	ldr	r3, [r7, #4]
3419a57e:	681b      	ldr	r3, [r3, #0]
3419a580:	2101      	movs	r1, #1
3419a582:	4618      	mov	r0, r3
3419a584:	f7ee fa51 	bl	34188a2a <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
3419a588:	4603      	mov	r3, r0
3419a58a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3419a58c:	7bfb      	ldrb	r3, [r7, #15]
3419a58e:	2b00      	cmp	r3, #0
3419a590:	d001      	beq.n	3419a596 <ISP_SVC_ISP_SetBlackLevel+0x7a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
3419a592:	2347      	movs	r3, #71	@ 0x47
3419a594:	e000      	b.n	3419a598 <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  return ISP_OK;
3419a596:	2300      	movs	r3, #0
}
3419a598:	4618      	mov	r0, r3
3419a59a:	3710      	adds	r7, #16
3419a59c:	46bd      	mov	sp, r7
3419a59e:	bd80      	pop	{r7, pc}

3419a5a0 <ISP_SVC_ISP_GetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3419a5a0:	b580      	push	{r7, lr}
3419a5a2:	b084      	sub	sp, #16
3419a5a4:	af00      	add	r7, sp, #0
3419a5a6:	6078      	str	r0, [r7, #4]
3419a5a8:	6039      	str	r1, [r7, #0]
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a5aa:	687b      	ldr	r3, [r7, #4]
3419a5ac:	2b00      	cmp	r3, #0
3419a5ae:	d002      	beq.n	3419a5b6 <ISP_SVC_ISP_GetBlackLevel+0x16>
3419a5b0:	683b      	ldr	r3, [r7, #0]
3419a5b2:	2b00      	cmp	r3, #0
3419a5b4:	d101      	bne.n	3419a5ba <ISP_SVC_ISP_GetBlackLevel+0x1a>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
3419a5b6:	2346      	movs	r3, #70	@ 0x46
3419a5b8:	e01b      	b.n	3419a5f2 <ISP_SVC_ISP_GetBlackLevel+0x52>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a5ba:	687b      	ldr	r3, [r7, #4]
3419a5bc:	681b      	ldr	r3, [r3, #0]
3419a5be:	2101      	movs	r1, #1
3419a5c0:	4618      	mov	r0, r3
3419a5c2:	f7ee fa95 	bl	34188af0 <HAL_DCMIPP_PIPE_IsEnabledISPBlackLevelCalibration>
3419a5c6:	4603      	mov	r3, r0
3419a5c8:	b2da      	uxtb	r2, r3
3419a5ca:	683b      	ldr	r3, [r7, #0]
3419a5cc:	701a      	strb	r2, [r3, #0]

  HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3419a5ce:	687b      	ldr	r3, [r7, #4]
3419a5d0:	681b      	ldr	r3, [r3, #0]
3419a5d2:	f107 020c 	add.w	r2, r7, #12
3419a5d6:	2101      	movs	r1, #1
3419a5d8:	4618      	mov	r0, r3
3419a5da:	f7ee fa66 	bl	34188aaa <HAL_DCMIPP_PIPE_GetISPBlackLevelCalibrationConfig>

  pConfig->BLCR = blackLevelConfig.RedCompBlackLevel;
3419a5de:	7b3a      	ldrb	r2, [r7, #12]
3419a5e0:	683b      	ldr	r3, [r7, #0]
3419a5e2:	705a      	strb	r2, [r3, #1]
  pConfig->BLCG = blackLevelConfig.GreenCompBlackLevel;
3419a5e4:	7b7a      	ldrb	r2, [r7, #13]
3419a5e6:	683b      	ldr	r3, [r7, #0]
3419a5e8:	709a      	strb	r2, [r3, #2]
  pConfig->BLCB = blackLevelConfig.BlueCompBlackLevel;
3419a5ea:	7bba      	ldrb	r2, [r7, #14]
3419a5ec:	683b      	ldr	r3, [r7, #0]
3419a5ee:	70da      	strb	r2, [r3, #3]

  return ISP_OK;
3419a5f0:	2300      	movs	r3, #0
}
3419a5f2:	4618      	mov	r0, r3
3419a5f4:	3710      	adds	r7, #16
3419a5f6:	46bd      	mov	sp, r7
3419a5f8:	bd80      	pop	{r7, pc}
	...

3419a5fc <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3419a5fc:	b580      	push	{r7, lr}
3419a5fe:	b084      	sub	sp, #16
3419a600:	af00      	add	r7, sp, #0
3419a602:	6078      	str	r0, [r7, #4]
3419a604:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a606:	687b      	ldr	r3, [r7, #4]
3419a608:	2b00      	cmp	r3, #0
3419a60a:	d011      	beq.n	3419a630 <ISP_SVC_ISP_SetGain+0x34>
3419a60c:	683b      	ldr	r3, [r7, #0]
3419a60e:	2b00      	cmp	r3, #0
3419a610:	d00e      	beq.n	3419a630 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3419a612:	683b      	ldr	r3, [r7, #0]
3419a614:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3419a616:	4a2d      	ldr	r2, [pc, #180]	@ (3419a6cc <ISP_SVC_ISP_SetGain+0xd0>)
3419a618:	4293      	cmp	r3, r2
3419a61a:	d809      	bhi.n	3419a630 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3419a61c:	683b      	ldr	r3, [r7, #0]
3419a61e:	689b      	ldr	r3, [r3, #8]
3419a620:	4a2a      	ldr	r2, [pc, #168]	@ (3419a6cc <ISP_SVC_ISP_SetGain+0xd0>)
3419a622:	4293      	cmp	r3, r2
3419a624:	d804      	bhi.n	3419a630 <ISP_SVC_ISP_SetGain+0x34>
3419a626:	683b      	ldr	r3, [r7, #0]
3419a628:	68db      	ldr	r3, [r3, #12]
3419a62a:	4a28      	ldr	r2, [pc, #160]	@ (3419a6cc <ISP_SVC_ISP_SetGain+0xd0>)
3419a62c:	4293      	cmp	r3, r2
3419a62e:	d901      	bls.n	3419a634 <ISP_SVC_ISP_SetGain+0x38>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
3419a630:	2350      	movs	r3, #80	@ 0x50
3419a632:	e047      	b.n	3419a6c4 <ISP_SVC_ISP_SetGain+0xc8>
  }

  if (pConfig->enable == 0)
3419a634:	683b      	ldr	r3, [r7, #0]
3419a636:	781b      	ldrb	r3, [r3, #0]
3419a638:	2b00      	cmp	r3, #0
3419a63a:	d108      	bne.n	3419a64e <ISP_SVC_ISP_SetGain+0x52>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a63c:	687b      	ldr	r3, [r7, #4]
3419a63e:	681b      	ldr	r3, [r3, #0]
3419a640:	2101      	movs	r1, #1
3419a642:	4618      	mov	r0, r3
3419a644:	f7ee fbbe 	bl	34188dc4 <HAL_DCMIPP_PIPE_DisableISPExposure>
3419a648:	4603      	mov	r3, r0
3419a64a:	73fb      	strb	r3, [r7, #15]
3419a64c:	e034      	b.n	3419a6b8 <ISP_SVC_ISP_SetGain+0xbc>
  }
  else
  {
    To_Shift_Multiplier(pConfig->ispGainR, &exposureConfig.ShiftRed, &exposureConfig.MultiplierRed);
3419a64e:	683b      	ldr	r3, [r7, #0]
3419a650:	6858      	ldr	r0, [r3, #4]
3419a652:	f107 0308 	add.w	r3, r7, #8
3419a656:	1c5a      	adds	r2, r3, #1
3419a658:	f107 0308 	add.w	r3, r7, #8
3419a65c:	4619      	mov	r1, r3
3419a65e:	f7ff f983 	bl	34199968 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainG, &exposureConfig.ShiftGreen, &exposureConfig.MultiplierGreen);
3419a662:	683b      	ldr	r3, [r7, #0]
3419a664:	6898      	ldr	r0, [r3, #8]
3419a666:	f107 0308 	add.w	r3, r7, #8
3419a66a:	1cda      	adds	r2, r3, #3
3419a66c:	f107 0308 	add.w	r3, r7, #8
3419a670:	3302      	adds	r3, #2
3419a672:	4619      	mov	r1, r3
3419a674:	f7ff f978 	bl	34199968 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainB, &exposureConfig.ShiftBlue, &exposureConfig.MultiplierBlue);
3419a678:	683b      	ldr	r3, [r7, #0]
3419a67a:	68d8      	ldr	r0, [r3, #12]
3419a67c:	f107 0308 	add.w	r3, r7, #8
3419a680:	1d5a      	adds	r2, r3, #5
3419a682:	f107 0308 	add.w	r3, r7, #8
3419a686:	3304      	adds	r3, #4
3419a688:	4619      	mov	r1, r3
3419a68a:	f7ff f96d 	bl	34199968 <To_Shift_Multiplier>
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3419a68e:	687b      	ldr	r3, [r7, #4]
3419a690:	681b      	ldr	r3, [r3, #0]
3419a692:	f107 0208 	add.w	r2, r7, #8
3419a696:	2101      	movs	r1, #1
3419a698:	4618      	mov	r0, r3
3419a69a:	f7ee fb31 	bl	34188d00 <HAL_DCMIPP_PIPE_SetISPExposureConfig>
3419a69e:	4603      	mov	r3, r0
3419a6a0:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3419a6a2:	7bfb      	ldrb	r3, [r7, #15]
3419a6a4:	2b00      	cmp	r3, #0
3419a6a6:	d107      	bne.n	3419a6b8 <ISP_SVC_ISP_SetGain+0xbc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a6a8:	687b      	ldr	r3, [r7, #4]
3419a6aa:	681b      	ldr	r3, [r3, #0]
3419a6ac:	2101      	movs	r1, #1
3419a6ae:	4618      	mov	r0, r3
3419a6b0:	f7ee fb68 	bl	34188d84 <HAL_DCMIPP_PIPE_EnableISPExposure>
3419a6b4:	4603      	mov	r3, r0
3419a6b6:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3419a6b8:	7bfb      	ldrb	r3, [r7, #15]
3419a6ba:	2b00      	cmp	r3, #0
3419a6bc:	d001      	beq.n	3419a6c2 <ISP_SVC_ISP_SetGain+0xc6>
  {
    return ISP_ERR_ISPGAIN_HAL;
3419a6be:	2351      	movs	r3, #81	@ 0x51
3419a6c0:	e000      	b.n	3419a6c4 <ISP_SVC_ISP_SetGain+0xc8>
  }

  return ISP_OK;
3419a6c2:	2300      	movs	r3, #0
}
3419a6c4:	4618      	mov	r0, r3
3419a6c6:	3710      	adds	r7, #16
3419a6c8:	46bd      	mov	sp, r7
3419a6ca:	bd80      	pop	{r7, pc}
3419a6cc:	5f5e1000 	.word	0x5f5e1000

3419a6d0 <ISP_SVC_ISP_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3419a6d0:	b580      	push	{r7, lr}
3419a6d2:	b084      	sub	sp, #16
3419a6d4:	af00      	add	r7, sp, #0
3419a6d6:	6078      	str	r0, [r7, #4]
3419a6d8:	6039      	str	r1, [r7, #0]
  DCMIPP_ExposureConfTypeDef exposureConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a6da:	687b      	ldr	r3, [r7, #4]
3419a6dc:	2b00      	cmp	r3, #0
3419a6de:	d002      	beq.n	3419a6e6 <ISP_SVC_ISP_GetGain+0x16>
3419a6e0:	683b      	ldr	r3, [r7, #0]
3419a6e2:	2b00      	cmp	r3, #0
3419a6e4:	d101      	bne.n	3419a6ea <ISP_SVC_ISP_GetGain+0x1a>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
3419a6e6:	2350      	movs	r3, #80	@ 0x50
3419a6e8:	e02d      	b.n	3419a746 <ISP_SVC_ISP_GetGain+0x76>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a6ea:	687b      	ldr	r3, [r7, #4]
3419a6ec:	681b      	ldr	r3, [r3, #0]
3419a6ee:	2101      	movs	r1, #1
3419a6f0:	4618      	mov	r0, r3
3419a6f2:	f7ee fef0 	bl	341894d6 <HAL_DCMIPP_PIPE_IsEnabledISPExposure>
3419a6f6:	4603      	mov	r3, r0
3419a6f8:	b2da      	uxtb	r2, r3
3419a6fa:	683b      	ldr	r3, [r7, #0]
3419a6fc:	701a      	strb	r2, [r3, #0]
  HAL_DCMIPP_PIPE_GetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3419a6fe:	687b      	ldr	r3, [r7, #4]
3419a700:	681b      	ldr	r3, [r3, #0]
3419a702:	f107 0208 	add.w	r2, r7, #8
3419a706:	2101      	movs	r1, #1
3419a708:	4618      	mov	r0, r3
3419a70a:	f7ee fd4e 	bl	341891aa <HAL_DCMIPP_PIPE_GetISPExposureConfig>

  pConfig->ispGainR = From_Shift_Multiplier(exposureConfig.ShiftRed, exposureConfig.MultiplierRed);
3419a70e:	7a3b      	ldrb	r3, [r7, #8]
3419a710:	7a7a      	ldrb	r2, [r7, #9]
3419a712:	4611      	mov	r1, r2
3419a714:	4618      	mov	r0, r3
3419a716:	f7ff f967 	bl	341999e8 <From_Shift_Multiplier>
3419a71a:	4602      	mov	r2, r0
3419a71c:	683b      	ldr	r3, [r7, #0]
3419a71e:	605a      	str	r2, [r3, #4]
  pConfig->ispGainG = From_Shift_Multiplier(exposureConfig.ShiftGreen, exposureConfig.MultiplierGreen);
3419a720:	7abb      	ldrb	r3, [r7, #10]
3419a722:	7afa      	ldrb	r2, [r7, #11]
3419a724:	4611      	mov	r1, r2
3419a726:	4618      	mov	r0, r3
3419a728:	f7ff f95e 	bl	341999e8 <From_Shift_Multiplier>
3419a72c:	4602      	mov	r2, r0
3419a72e:	683b      	ldr	r3, [r7, #0]
3419a730:	609a      	str	r2, [r3, #8]
  pConfig->ispGainB = From_Shift_Multiplier(exposureConfig.ShiftBlue, exposureConfig.MultiplierBlue);
3419a732:	7b3b      	ldrb	r3, [r7, #12]
3419a734:	7b7a      	ldrb	r2, [r7, #13]
3419a736:	4611      	mov	r1, r2
3419a738:	4618      	mov	r0, r3
3419a73a:	f7ff f955 	bl	341999e8 <From_Shift_Multiplier>
3419a73e:	4602      	mov	r2, r0
3419a740:	683b      	ldr	r3, [r7, #0]
3419a742:	60da      	str	r2, [r3, #12]

  return ISP_OK;
3419a744:	2300      	movs	r3, #0
}
3419a746:	4618      	mov	r0, r3
3419a748:	3710      	adds	r7, #16
3419a74a:	46bd      	mov	sp, r7
3419a74c:	bd80      	pop	{r7, pc}
	...

3419a750 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3419a750:	b580      	push	{r7, lr}
3419a752:	b08c      	sub	sp, #48	@ 0x30
3419a754:	af00      	add	r7, sp, #0
3419a756:	6078      	str	r0, [r7, #4]
3419a758:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
3419a75a:	f107 0308 	add.w	r3, r7, #8
3419a75e:	221a      	movs	r2, #26
3419a760:	2100      	movs	r1, #0
3419a762:	4618      	mov	r0, r3
3419a764:	f00a fec4 	bl	341a54f0 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a768:	687b      	ldr	r3, [r7, #4]
3419a76a:	2b00      	cmp	r3, #0
3419a76c:	d002      	beq.n	3419a774 <ISP_SVC_ISP_SetColorConv+0x24>
3419a76e:	683b      	ldr	r3, [r7, #0]
3419a770:	2b00      	cmp	r3, #0
3419a772:	d101      	bne.n	3419a778 <ISP_SVC_ISP_SetColorConv+0x28>
  {
    return ISP_ERR_COLORCONV_EINVAL;
3419a774:	235a      	movs	r3, #90	@ 0x5a
3419a776:	e099      	b.n	3419a8ac <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  for (i = 0; i < 3; i++)
3419a778:	2300      	movs	r3, #0
3419a77a:	62bb      	str	r3, [r7, #40]	@ 0x28
3419a77c:	e027      	b.n	3419a7ce <ISP_SVC_ISP_SetColorConv+0x7e>
  {
    for (j = 0; j < 3; j++)
3419a77e:	2300      	movs	r3, #0
3419a780:	627b      	str	r3, [r7, #36]	@ 0x24
3419a782:	e01e      	b.n	3419a7c2 <ISP_SVC_ISP_SetColorConv+0x72>
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
3419a784:	6839      	ldr	r1, [r7, #0]
3419a786:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419a788:	4613      	mov	r3, r2
3419a78a:	005b      	lsls	r3, r3, #1
3419a78c:	4413      	add	r3, r2
3419a78e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419a790:	4413      	add	r3, r2
3419a792:	009b      	lsls	r3, r3, #2
3419a794:	440b      	add	r3, r1
3419a796:	685b      	ldr	r3, [r3, #4]
3419a798:	4a46      	ldr	r2, [pc, #280]	@ (3419a8b4 <ISP_SVC_ISP_SetColorConv+0x164>)
3419a79a:	4293      	cmp	r3, r2
3419a79c:	dc0c      	bgt.n	3419a7b8 <ISP_SVC_ISP_SetColorConv+0x68>
3419a79e:	6839      	ldr	r1, [r7, #0]
3419a7a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3419a7a2:	4613      	mov	r3, r2
3419a7a4:	005b      	lsls	r3, r3, #1
3419a7a6:	4413      	add	r3, r2
3419a7a8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419a7aa:	4413      	add	r3, r2
3419a7ac:	009b      	lsls	r3, r3, #2
3419a7ae:	440b      	add	r3, r1
3419a7b0:	685b      	ldr	r3, [r3, #4]
3419a7b2:	4a41      	ldr	r2, [pc, #260]	@ (3419a8b8 <ISP_SVC_ISP_SetColorConv+0x168>)
3419a7b4:	4293      	cmp	r3, r2
3419a7b6:	da01      	bge.n	3419a7bc <ISP_SVC_ISP_SetColorConv+0x6c>
      {
        return ISP_ERR_COLORCONV_EINVAL;
3419a7b8:	235a      	movs	r3, #90	@ 0x5a
3419a7ba:	e077      	b.n	3419a8ac <ISP_SVC_ISP_SetColorConv+0x15c>
    for (j = 0; j < 3; j++)
3419a7bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a7be:	3301      	adds	r3, #1
3419a7c0:	627b      	str	r3, [r7, #36]	@ 0x24
3419a7c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419a7c4:	2b02      	cmp	r3, #2
3419a7c6:	d9dd      	bls.n	3419a784 <ISP_SVC_ISP_SetColorConv+0x34>
  for (i = 0; i < 3; i++)
3419a7c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419a7ca:	3301      	adds	r3, #1
3419a7cc:	62bb      	str	r3, [r7, #40]	@ 0x28
3419a7ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419a7d0:	2b02      	cmp	r3, #2
3419a7d2:	d9d4      	bls.n	3419a77e <ISP_SVC_ISP_SetColorConv+0x2e>
      }
    }
  }

  if (pConfig->enable == 0)
3419a7d4:	683b      	ldr	r3, [r7, #0]
3419a7d6:	781b      	ldrb	r3, [r3, #0]
3419a7d8:	2b00      	cmp	r3, #0
3419a7da:	d109      	bne.n	3419a7f0 <ISP_SVC_ISP_SetColorConv+0xa0>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a7dc:	687b      	ldr	r3, [r7, #4]
3419a7de:	681b      	ldr	r3, [r3, #0]
3419a7e0:	2101      	movs	r1, #1
3419a7e2:	4618      	mov	r0, r3
3419a7e4:	f7ee f8d2 	bl	3418898c <HAL_DCMIPP_PIPE_DisableISPColorConversion>
3419a7e8:	4603      	mov	r3, r0
3419a7ea:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3419a7ee:	e056      	b.n	3419a89e <ISP_SVC_ISP_SetColorConv+0x14e>
  }
  else
  {
    colorConvConfig.RR = To_CConv_Reg(pConfig->coeff[0][0]);
3419a7f0:	683b      	ldr	r3, [r7, #0]
3419a7f2:	685b      	ldr	r3, [r3, #4]
3419a7f4:	4618      	mov	r0, r3
3419a7f6:	f7ff f935 	bl	34199a64 <To_CConv_Reg>
3419a7fa:	4603      	mov	r3, r0
3419a7fc:	817b      	strh	r3, [r7, #10]
    colorConvConfig.RG = To_CConv_Reg(pConfig->coeff[0][1]);
3419a7fe:	683b      	ldr	r3, [r7, #0]
3419a800:	689b      	ldr	r3, [r3, #8]
3419a802:	4618      	mov	r0, r3
3419a804:	f7ff f92e 	bl	34199a64 <To_CConv_Reg>
3419a808:	4603      	mov	r3, r0
3419a80a:	81bb      	strh	r3, [r7, #12]
    colorConvConfig.RB = To_CConv_Reg(pConfig->coeff[0][2]);
3419a80c:	683b      	ldr	r3, [r7, #0]
3419a80e:	68db      	ldr	r3, [r3, #12]
3419a810:	4618      	mov	r0, r3
3419a812:	f7ff f927 	bl	34199a64 <To_CConv_Reg>
3419a816:	4603      	mov	r3, r0
3419a818:	81fb      	strh	r3, [r7, #14]
    colorConvConfig.GR = To_CConv_Reg(pConfig->coeff[1][0]);
3419a81a:	683b      	ldr	r3, [r7, #0]
3419a81c:	691b      	ldr	r3, [r3, #16]
3419a81e:	4618      	mov	r0, r3
3419a820:	f7ff f920 	bl	34199a64 <To_CConv_Reg>
3419a824:	4603      	mov	r3, r0
3419a826:	827b      	strh	r3, [r7, #18]
    colorConvConfig.GG = To_CConv_Reg(pConfig->coeff[1][1]);
3419a828:	683b      	ldr	r3, [r7, #0]
3419a82a:	695b      	ldr	r3, [r3, #20]
3419a82c:	4618      	mov	r0, r3
3419a82e:	f7ff f919 	bl	34199a64 <To_CConv_Reg>
3419a832:	4603      	mov	r3, r0
3419a834:	82bb      	strh	r3, [r7, #20]
    colorConvConfig.GB = To_CConv_Reg(pConfig->coeff[1][2]);
3419a836:	683b      	ldr	r3, [r7, #0]
3419a838:	699b      	ldr	r3, [r3, #24]
3419a83a:	4618      	mov	r0, r3
3419a83c:	f7ff f912 	bl	34199a64 <To_CConv_Reg>
3419a840:	4603      	mov	r3, r0
3419a842:	82fb      	strh	r3, [r7, #22]
    colorConvConfig.BR = To_CConv_Reg(pConfig->coeff[2][0]);
3419a844:	683b      	ldr	r3, [r7, #0]
3419a846:	69db      	ldr	r3, [r3, #28]
3419a848:	4618      	mov	r0, r3
3419a84a:	f7ff f90b 	bl	34199a64 <To_CConv_Reg>
3419a84e:	4603      	mov	r3, r0
3419a850:	837b      	strh	r3, [r7, #26]
    colorConvConfig.BG = To_CConv_Reg(pConfig->coeff[2][1]);
3419a852:	683b      	ldr	r3, [r7, #0]
3419a854:	6a1b      	ldr	r3, [r3, #32]
3419a856:	4618      	mov	r0, r3
3419a858:	f7ff f904 	bl	34199a64 <To_CConv_Reg>
3419a85c:	4603      	mov	r3, r0
3419a85e:	83bb      	strh	r3, [r7, #28]
    colorConvConfig.BB = To_CConv_Reg(pConfig->coeff[2][2]);
3419a860:	683b      	ldr	r3, [r7, #0]
3419a862:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419a864:	4618      	mov	r0, r3
3419a866:	f7ff f8fd 	bl	34199a64 <To_CConv_Reg>
3419a86a:	4603      	mov	r3, r0
3419a86c:	83fb      	strh	r3, [r7, #30]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3419a86e:	687b      	ldr	r3, [r7, #4]
3419a870:	681b      	ldr	r3, [r3, #0]
3419a872:	f107 0208 	add.w	r2, r7, #8
3419a876:	2101      	movs	r1, #1
3419a878:	4618      	mov	r0, r3
3419a87a:	f7ed ff05 	bl	34188688 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
3419a87e:	4603      	mov	r3, r0
3419a880:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    if (halStatus == HAL_OK)
3419a884:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
3419a888:	2b00      	cmp	r3, #0
3419a88a:	d108      	bne.n	3419a89e <ISP_SVC_ISP_SetColorConv+0x14e>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a88c:	687b      	ldr	r3, [r7, #4]
3419a88e:	681b      	ldr	r3, [r3, #0]
3419a890:	2101      	movs	r1, #1
3419a892:	4618      	mov	r0, r3
3419a894:	f7ee f85a 	bl	3418894c <HAL_DCMIPP_PIPE_EnableISPColorConversion>
3419a898:	4603      	mov	r3, r0
3419a89a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }
  }

  if (halStatus != HAL_OK)
3419a89e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
3419a8a2:	2b00      	cmp	r3, #0
3419a8a4:	d001      	beq.n	3419a8aa <ISP_SVC_ISP_SetColorConv+0x15a>
  {
    return ISP_ERR_COLORCONV_HAL;
3419a8a6:	235b      	movs	r3, #91	@ 0x5b
3419a8a8:	e000      	b.n	3419a8ac <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  return ISP_OK;
3419a8aa:	2300      	movs	r3, #0
}
3419a8ac:	4618      	mov	r0, r3
3419a8ae:	3730      	adds	r7, #48	@ 0x30
3419a8b0:	46bd      	mov	sp, r7
3419a8b2:	bd80      	pop	{r7, pc}
3419a8b4:	17c841c0 	.word	0x17c841c0
3419a8b8:	e837be40 	.word	0xe837be40

3419a8bc <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3419a8bc:	b580      	push	{r7, lr}
3419a8be:	b08a      	sub	sp, #40	@ 0x28
3419a8c0:	af00      	add	r7, sp, #0
3419a8c2:	6078      	str	r0, [r7, #4]
3419a8c4:	6039      	str	r1, [r7, #0]
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a8c6:	687b      	ldr	r3, [r7, #4]
3419a8c8:	2b00      	cmp	r3, #0
3419a8ca:	d002      	beq.n	3419a8d2 <ISP_SVC_ISP_GetColorConv+0x16>
3419a8cc:	683b      	ldr	r3, [r7, #0]
3419a8ce:	2b00      	cmp	r3, #0
3419a8d0:	d101      	bne.n	3419a8d6 <ISP_SVC_ISP_GetColorConv+0x1a>
  {
    return ISP_ERR_COLORCONV_EINVAL;
3419a8d2:	235a      	movs	r3, #90	@ 0x5a
3419a8d4:	e05a      	b.n	3419a98c <ISP_SVC_ISP_GetColorConv+0xd0>
  }

  pConfig->enable = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3419a8d6:	687b      	ldr	r3, [r7, #4]
3419a8d8:	681b      	ldr	r3, [r3, #0]
3419a8da:	2101      	movs	r1, #1
3419a8dc:	4618      	mov	r0, r3
3419a8de:	f7ee fe15 	bl	3418950c <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
3419a8e2:	4603      	mov	r3, r0
3419a8e4:	b2da      	uxtb	r2, r3
3419a8e6:	683b      	ldr	r3, [r7, #0]
3419a8e8:	701a      	strb	r2, [r3, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3419a8ea:	687b      	ldr	r3, [r7, #4]
3419a8ec:	681b      	ldr	r3, [r3, #0]
3419a8ee:	f107 020c 	add.w	r2, r7, #12
3419a8f2:	2101      	movs	r1, #1
3419a8f4:	4618      	mov	r0, r3
3419a8f6:	f7ee fc98 	bl	3418922a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>

  pConfig->coeff[0][0] = From_CConv_Reg(colorConvConfig.RR);
3419a8fa:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3419a8fe:	4618      	mov	r0, r3
3419a900:	f7ff f8ce 	bl	34199aa0 <From_CConv_Reg>
3419a904:	4602      	mov	r2, r0
3419a906:	683b      	ldr	r3, [r7, #0]
3419a908:	605a      	str	r2, [r3, #4]
  pConfig->coeff[0][1] = From_CConv_Reg(colorConvConfig.RG);
3419a90a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
3419a90e:	4618      	mov	r0, r3
3419a910:	f7ff f8c6 	bl	34199aa0 <From_CConv_Reg>
3419a914:	4602      	mov	r2, r0
3419a916:	683b      	ldr	r3, [r7, #0]
3419a918:	609a      	str	r2, [r3, #8]
  pConfig->coeff[0][2] = From_CConv_Reg(colorConvConfig.RB);
3419a91a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
3419a91e:	4618      	mov	r0, r3
3419a920:	f7ff f8be 	bl	34199aa0 <From_CConv_Reg>
3419a924:	4602      	mov	r2, r0
3419a926:	683b      	ldr	r3, [r7, #0]
3419a928:	60da      	str	r2, [r3, #12]
  pConfig->coeff[1][0] = From_CConv_Reg(colorConvConfig.GR);
3419a92a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3419a92e:	4618      	mov	r0, r3
3419a930:	f7ff f8b6 	bl	34199aa0 <From_CConv_Reg>
3419a934:	4602      	mov	r2, r0
3419a936:	683b      	ldr	r3, [r7, #0]
3419a938:	611a      	str	r2, [r3, #16]
  pConfig->coeff[1][1] = From_CConv_Reg(colorConvConfig.GG);
3419a93a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
3419a93e:	4618      	mov	r0, r3
3419a940:	f7ff f8ae 	bl	34199aa0 <From_CConv_Reg>
3419a944:	4602      	mov	r2, r0
3419a946:	683b      	ldr	r3, [r7, #0]
3419a948:	615a      	str	r2, [r3, #20]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
3419a94a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
3419a94e:	4618      	mov	r0, r3
3419a950:	f7ff f8a6 	bl	34199aa0 <From_CConv_Reg>
3419a954:	4602      	mov	r2, r0
3419a956:	683b      	ldr	r3, [r7, #0]
3419a958:	619a      	str	r2, [r3, #24]
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
3419a95a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
3419a95e:	4618      	mov	r0, r3
3419a960:	f7ff f89e 	bl	34199aa0 <From_CConv_Reg>
3419a964:	4602      	mov	r2, r0
3419a966:	683b      	ldr	r3, [r7, #0]
3419a968:	61da      	str	r2, [r3, #28]
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
3419a96a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
3419a96e:	4618      	mov	r0, r3
3419a970:	f7ff f896 	bl	34199aa0 <From_CConv_Reg>
3419a974:	4602      	mov	r2, r0
3419a976:	683b      	ldr	r3, [r7, #0]
3419a978:	621a      	str	r2, [r3, #32]
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);
3419a97a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
3419a97e:	4618      	mov	r0, r3
3419a980:	f7ff f88e 	bl	34199aa0 <From_CConv_Reg>
3419a984:	4602      	mov	r2, r0
3419a986:	683b      	ldr	r3, [r7, #0]
3419a988:	625a      	str	r2, [r3, #36]	@ 0x24

  return ISP_OK;
3419a98a:	2300      	movs	r3, #0
}
3419a98c:	4618      	mov	r0, r3
3419a98e:	3728      	adds	r7, #40	@ 0x28
3419a990:	46bd      	mov	sp, r7
3419a992:	bd80      	pop	{r7, pc}

3419a994 <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
3419a994:	b580      	push	{r7, lr}
3419a996:	b082      	sub	sp, #8
3419a998:	af00      	add	r7, sp, #0
3419a99a:	6078      	str	r0, [r7, #4]
3419a99c:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a99e:	687b      	ldr	r3, [r7, #4]
3419a9a0:	2b00      	cmp	r3, #0
3419a9a2:	d002      	beq.n	3419a9aa <ISP_SVC_Sensor_GetInfo+0x16>
3419a9a4:	683b      	ldr	r3, [r7, #0]
3419a9a6:	2b00      	cmp	r3, #0
3419a9a8:	d101      	bne.n	3419a9ae <ISP_SVC_Sensor_GetInfo+0x1a>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
3419a9aa:	236e      	movs	r3, #110	@ 0x6e
3419a9ac:	e010      	b.n	3419a9d0 <ISP_SVC_Sensor_GetInfo+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
3419a9ae:	687b      	ldr	r3, [r7, #4]
3419a9b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419a9b2:	2b00      	cmp	r3, #0
3419a9b4:	d00b      	beq.n	3419a9ce <ISP_SVC_Sensor_GetInfo+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
3419a9b6:	687b      	ldr	r3, [r7, #4]
3419a9b8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3419a9ba:	687a      	ldr	r2, [r7, #4]
3419a9bc:	6852      	ldr	r2, [r2, #4]
3419a9be:	6839      	ldr	r1, [r7, #0]
3419a9c0:	4610      	mov	r0, r2
3419a9c2:	4798      	blx	r3
3419a9c4:	4603      	mov	r3, r0
3419a9c6:	2b00      	cmp	r3, #0
3419a9c8:	d001      	beq.n	3419a9ce <ISP_SVC_Sensor_GetInfo+0x3a>
    {
      return ISP_ERR_SENSORINFO;
3419a9ca:	236f      	movs	r3, #111	@ 0x6f
3419a9cc:	e000      	b.n	3419a9d0 <ISP_SVC_Sensor_GetInfo+0x3c>
    }
  }

  return ISP_OK;
3419a9ce:	2300      	movs	r3, #0
}
3419a9d0:	4618      	mov	r0, r3
3419a9d2:	3708      	adds	r7, #8
3419a9d4:	46bd      	mov	sp, r7
3419a9d6:	bd80      	pop	{r7, pc}

3419a9d8 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3419a9d8:	b580      	push	{r7, lr}
3419a9da:	b082      	sub	sp, #8
3419a9dc:	af00      	add	r7, sp, #0
3419a9de:	6078      	str	r0, [r7, #4]
3419a9e0:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419a9e2:	687b      	ldr	r3, [r7, #4]
3419a9e4:	2b00      	cmp	r3, #0
3419a9e6:	d002      	beq.n	3419a9ee <ISP_SVC_Sensor_SetGain+0x16>
3419a9e8:	683b      	ldr	r3, [r7, #0]
3419a9ea:	2b00      	cmp	r3, #0
3419a9ec:	d101      	bne.n	3419a9f2 <ISP_SVC_Sensor_SetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
3419a9ee:	2378      	movs	r3, #120	@ 0x78
3419a9f0:	e015      	b.n	3419aa1e <ISP_SVC_Sensor_SetGain+0x46>
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
3419a9f2:	687b      	ldr	r3, [r7, #4]
3419a9f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419a9f6:	2b00      	cmp	r3, #0
3419a9f8:	d00c      	beq.n	3419aa14 <ISP_SVC_Sensor_SetGain+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, (int32_t)pConfig->gain) != 0)
3419a9fa:	687b      	ldr	r3, [r7, #4]
3419a9fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3419a9fe:	687a      	ldr	r2, [r7, #4]
3419aa00:	6850      	ldr	r0, [r2, #4]
3419aa02:	683a      	ldr	r2, [r7, #0]
3419aa04:	6812      	ldr	r2, [r2, #0]
3419aa06:	4611      	mov	r1, r2
3419aa08:	4798      	blx	r3
3419aa0a:	4603      	mov	r3, r0
3419aa0c:	2b00      	cmp	r3, #0
3419aa0e:	d001      	beq.n	3419aa14 <ISP_SVC_Sensor_SetGain+0x3c>
    {
      return ISP_ERR_SENSORGAIN;
3419aa10:	2379      	movs	r3, #121	@ 0x79
3419aa12:	e004      	b.n	3419aa1e <ISP_SVC_Sensor_SetGain+0x46>
    }
  }

  Meta.gain = pConfig->gain;
3419aa14:	683b      	ldr	r3, [r7, #0]
3419aa16:	681b      	ldr	r3, [r3, #0]
3419aa18:	4a03      	ldr	r2, [pc, #12]	@ (3419aa28 <ISP_SVC_Sensor_SetGain+0x50>)
3419aa1a:	6093      	str	r3, [r2, #8]

  return ISP_OK;
3419aa1c:	2300      	movs	r3, #0
}
3419aa1e:	4618      	mov	r0, r3
3419aa20:	3708      	adds	r7, #8
3419aa22:	46bd      	mov	sp, r7
3419aa24:	bd80      	pop	{r7, pc}
3419aa26:	bf00      	nop
3419aa28:	341c1304 	.word	0x341c1304

3419aa2c <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3419aa2c:	b580      	push	{r7, lr}
3419aa2e:	b082      	sub	sp, #8
3419aa30:	af00      	add	r7, sp, #0
3419aa32:	6078      	str	r0, [r7, #4]
3419aa34:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419aa36:	687b      	ldr	r3, [r7, #4]
3419aa38:	2b00      	cmp	r3, #0
3419aa3a:	d002      	beq.n	3419aa42 <ISP_SVC_Sensor_GetGain+0x16>
3419aa3c:	683b      	ldr	r3, [r7, #0]
3419aa3e:	2b00      	cmp	r3, #0
3419aa40:	d101      	bne.n	3419aa46 <ISP_SVC_Sensor_GetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
3419aa42:	2378      	movs	r3, #120	@ 0x78
3419aa44:	e010      	b.n	3419aa68 <ISP_SVC_Sensor_GetGain+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
3419aa46:	687b      	ldr	r3, [r7, #4]
3419aa48:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419aa4a:	2b00      	cmp	r3, #0
3419aa4c:	d00b      	beq.n	3419aa66 <ISP_SVC_Sensor_GetGain+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
3419aa4e:	687b      	ldr	r3, [r7, #4]
3419aa50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3419aa52:	687a      	ldr	r2, [r7, #4]
3419aa54:	6852      	ldr	r2, [r2, #4]
3419aa56:	6839      	ldr	r1, [r7, #0]
3419aa58:	4610      	mov	r0, r2
3419aa5a:	4798      	blx	r3
3419aa5c:	4603      	mov	r3, r0
3419aa5e:	2b00      	cmp	r3, #0
3419aa60:	d001      	beq.n	3419aa66 <ISP_SVC_Sensor_GetGain+0x3a>
    {
      return ISP_ERR_SENSORGAIN;
3419aa62:	2379      	movs	r3, #121	@ 0x79
3419aa64:	e000      	b.n	3419aa68 <ISP_SVC_Sensor_GetGain+0x3c>
    }
  }

  return ISP_OK;
3419aa66:	2300      	movs	r3, #0
}
3419aa68:	4618      	mov	r0, r3
3419aa6a:	3708      	adds	r7, #8
3419aa6c:	46bd      	mov	sp, r7
3419aa6e:	bd80      	pop	{r7, pc}

3419aa70 <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3419aa70:	b580      	push	{r7, lr}
3419aa72:	b082      	sub	sp, #8
3419aa74:	af00      	add	r7, sp, #0
3419aa76:	6078      	str	r0, [r7, #4]
3419aa78:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419aa7a:	687b      	ldr	r3, [r7, #4]
3419aa7c:	2b00      	cmp	r3, #0
3419aa7e:	d002      	beq.n	3419aa86 <ISP_SVC_Sensor_SetExposure+0x16>
3419aa80:	683b      	ldr	r3, [r7, #0]
3419aa82:	2b00      	cmp	r3, #0
3419aa84:	d101      	bne.n	3419aa8a <ISP_SVC_Sensor_SetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3419aa86:	2382      	movs	r3, #130	@ 0x82
3419aa88:	e015      	b.n	3419aab6 <ISP_SVC_Sensor_SetExposure+0x46>
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
3419aa8a:	687b      	ldr	r3, [r7, #4]
3419aa8c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3419aa8e:	2b00      	cmp	r3, #0
3419aa90:	d00c      	beq.n	3419aaac <ISP_SVC_Sensor_SetExposure+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, (int32_t)pConfig->exposure) != 0)
3419aa92:	687b      	ldr	r3, [r7, #4]
3419aa94:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3419aa96:	687a      	ldr	r2, [r7, #4]
3419aa98:	6850      	ldr	r0, [r2, #4]
3419aa9a:	683a      	ldr	r2, [r7, #0]
3419aa9c:	6812      	ldr	r2, [r2, #0]
3419aa9e:	4611      	mov	r1, r2
3419aaa0:	4798      	blx	r3
3419aaa2:	4603      	mov	r3, r0
3419aaa4:	2b00      	cmp	r3, #0
3419aaa6:	d001      	beq.n	3419aaac <ISP_SVC_Sensor_SetExposure+0x3c>
    {
      return ISP_ERR_SENSOREXPOSURE;
3419aaa8:	2383      	movs	r3, #131	@ 0x83
3419aaaa:	e004      	b.n	3419aab6 <ISP_SVC_Sensor_SetExposure+0x46>
    }
  }

  Meta.exposure = pConfig->exposure;
3419aaac:	683b      	ldr	r3, [r7, #0]
3419aaae:	681b      	ldr	r3, [r3, #0]
3419aab0:	4a03      	ldr	r2, [pc, #12]	@ (3419aac0 <ISP_SVC_Sensor_SetExposure+0x50>)
3419aab2:	60d3      	str	r3, [r2, #12]

  return ISP_OK;
3419aab4:	2300      	movs	r3, #0
}
3419aab6:	4618      	mov	r0, r3
3419aab8:	3708      	adds	r7, #8
3419aaba:	46bd      	mov	sp, r7
3419aabc:	bd80      	pop	{r7, pc}
3419aabe:	bf00      	nop
3419aac0:	341c1304 	.word	0x341c1304

3419aac4 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3419aac4:	b580      	push	{r7, lr}
3419aac6:	b082      	sub	sp, #8
3419aac8:	af00      	add	r7, sp, #0
3419aaca:	6078      	str	r0, [r7, #4]
3419aacc:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3419aace:	687b      	ldr	r3, [r7, #4]
3419aad0:	2b00      	cmp	r3, #0
3419aad2:	d002      	beq.n	3419aada <ISP_SVC_Sensor_GetExposure+0x16>
3419aad4:	683b      	ldr	r3, [r7, #0]
3419aad6:	2b00      	cmp	r3, #0
3419aad8:	d101      	bne.n	3419aade <ISP_SVC_Sensor_GetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3419aada:	2382      	movs	r3, #130	@ 0x82
3419aadc:	e010      	b.n	3419ab00 <ISP_SVC_Sensor_GetExposure+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
3419aade:	687b      	ldr	r3, [r7, #4]
3419aae0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419aae2:	2b00      	cmp	r3, #0
3419aae4:	d00b      	beq.n	3419aafe <ISP_SVC_Sensor_GetExposure+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
3419aae6:	687b      	ldr	r3, [r7, #4]
3419aae8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3419aaea:	687a      	ldr	r2, [r7, #4]
3419aaec:	6852      	ldr	r2, [r2, #4]
3419aaee:	6839      	ldr	r1, [r7, #0]
3419aaf0:	4610      	mov	r0, r2
3419aaf2:	4798      	blx	r3
3419aaf4:	4603      	mov	r3, r0
3419aaf6:	2b00      	cmp	r3, #0
3419aaf8:	d001      	beq.n	3419aafe <ISP_SVC_Sensor_GetExposure+0x3a>
    {
      return ISP_ERR_SENSOREXPOSURE;
3419aafa:	2383      	movs	r3, #131	@ 0x83
3419aafc:	e000      	b.n	3419ab00 <ISP_SVC_Sensor_GetExposure+0x3c>
    }
  }

  return ISP_OK;
3419aafe:	2300      	movs	r3, #0
}
3419ab00:	4618      	mov	r0, r3
3419ab02:	3708      	adds	r7, #8
3419ab04:	46bd      	mov	sp, r7
3419ab06:	bd80      	pop	{r7, pc}

3419ab08 <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
3419ab08:	b580      	push	{r7, lr}
3419ab0a:	b082      	sub	sp, #8
3419ab0c:	af00      	add	r7, sp, #0
3419ab0e:	6078      	str	r0, [r7, #4]
  /* Check handle validity */
  if (hIsp == NULL)
3419ab10:	687b      	ldr	r3, [r7, #4]
3419ab12:	2b00      	cmp	r3, #0
3419ab14:	d101      	bne.n	3419ab1a <ISP_SVC_Misc_IsDCMIPPReady+0x12>
  {
    return ISP_ERR_EINVAL;
3419ab16:	2301      	movs	r3, #1
3419ab18:	e00a      	b.n	3419ab30 <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
3419ab1a:	687b      	ldr	r3, [r7, #4]
3419ab1c:	681b      	ldr	r3, [r3, #0]
3419ab1e:	4618      	mov	r0, r3
3419ab20:	f7ee fd0f 	bl	34189542 <HAL_DCMIPP_GetState>
3419ab24:	4603      	mov	r3, r0
3419ab26:	2b02      	cmp	r3, #2
3419ab28:	d001      	beq.n	3419ab2e <ISP_SVC_Misc_IsDCMIPPReady+0x26>
  {
    return ISP_ERR_DCMIPP_STATE;
3419ab2a:	238c      	movs	r3, #140	@ 0x8c
3419ab2c:	e000      	b.n	3419ab30 <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  return ISP_OK;
3419ab2e:	2300      	movs	r3, #0
}
3419ab30:	4618      	mov	r0, r3
3419ab32:	3708      	adds	r7, #8
3419ab34:	46bd      	mov	sp, r7
3419ab36:	bd80      	pop	{r7, pc}

3419ab38 <ISP_SVC_Misc_IncMainFrameId>:
  *         Increment the id of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
3419ab38:	b480      	push	{r7}
3419ab3a:	b083      	sub	sp, #12
3419ab3c:	af00      	add	r7, sp, #0
3419ab3e:	6078      	str	r0, [r7, #4]
  hIsp->MainPipe_FrameCount++;
3419ab40:	687b      	ldr	r3, [r7, #4]
3419ab42:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419ab44:	1c5a      	adds	r2, r3, #1
3419ab46:	687b      	ldr	r3, [r7, #4]
3419ab48:	641a      	str	r2, [r3, #64]	@ 0x40
}
3419ab4a:	bf00      	nop
3419ab4c:	370c      	adds	r7, #12
3419ab4e:	46bd      	mov	sp, r7
3419ab50:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ab54:	4770      	bx	lr

3419ab56 <ISP_SVC_Misc_GetMainFrameId>:
  *         Return the id of the last frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
3419ab56:	b480      	push	{r7}
3419ab58:	b083      	sub	sp, #12
3419ab5a:	af00      	add	r7, sp, #0
3419ab5c:	6078      	str	r0, [r7, #4]
  return hIsp->MainPipe_FrameCount;
3419ab5e:	687b      	ldr	r3, [r7, #4]
3419ab60:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
3419ab62:	4618      	mov	r0, r3
3419ab64:	370c      	adds	r7, #12
3419ab66:	46bd      	mov	sp, r7
3419ab68:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ab6c:	4770      	bx	lr

3419ab6e <ISP_SVC_Misc_IncAncillaryFrameId>:
  *         Increment the id of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
3419ab6e:	b480      	push	{r7}
3419ab70:	b083      	sub	sp, #12
3419ab72:	af00      	add	r7, sp, #0
3419ab74:	6078      	str	r0, [r7, #4]
  hIsp->AncillaryPipe_FrameCount++;
3419ab76:	687b      	ldr	r3, [r7, #4]
3419ab78:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419ab7a:	1c5a      	adds	r2, r3, #1
3419ab7c:	687b      	ldr	r3, [r7, #4]
3419ab7e:	645a      	str	r2, [r3, #68]	@ 0x44
}
3419ab80:	bf00      	nop
3419ab82:	370c      	adds	r7, #12
3419ab84:	46bd      	mov	sp, r7
3419ab86:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ab8a:	4770      	bx	lr

3419ab8c <ISP_SVC_Misc_IncDumpFrameId>:
  *         Increment the id of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
3419ab8c:	b480      	push	{r7}
3419ab8e:	b083      	sub	sp, #12
3419ab90:	af00      	add	r7, sp, #0
3419ab92:	6078      	str	r0, [r7, #4]
  hIsp->DumpPipe_FrameCount++;
3419ab94:	687b      	ldr	r3, [r7, #4]
3419ab96:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419ab98:	1c5a      	adds	r2, r3, #1
3419ab9a:	687b      	ldr	r3, [r7, #4]
3419ab9c:	649a      	str	r2, [r3, #72]	@ 0x48
}
3419ab9e:	bf00      	nop
3419aba0:	370c      	adds	r7, #12
3419aba2:	46bd      	mov	sp, r7
3419aba4:	f85d 7b04 	ldr.w	r7, [sp], #4
3419aba8:	4770      	bx	lr
	...

3419abac <ISP_SVC_Misc_SetWBRefMode>:
  * @param  hIsp: ISP device handle
  * @param  RefColorTemp: reference color temperature
  * @retval Operation status
  */
ISP_StatusTypeDef ISP_SVC_Misc_SetWBRefMode(ISP_HandleTypeDef *hIsp, uint32_t RefColorTemp)
{
3419abac:	b480      	push	{r7}
3419abae:	b083      	sub	sp, #12
3419abb0:	af00      	add	r7, sp, #0
3419abb2:	6078      	str	r0, [r7, #4]
3419abb4:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ISP_ManualWBRefColorTemp = RefColorTemp;
3419abb6:	4a05      	ldr	r2, [pc, #20]	@ (3419abcc <ISP_SVC_Misc_SetWBRefMode+0x20>)
3419abb8:	683b      	ldr	r3, [r7, #0]
3419abba:	6013      	str	r3, [r2, #0]

  return ISP_OK;
3419abbc:	2300      	movs	r3, #0
}
3419abbe:	4618      	mov	r0, r3
3419abc0:	370c      	adds	r7, #12
3419abc2:	46bd      	mov	sp, r7
3419abc4:	f85d 7b04 	ldr.w	r7, [sp], #4
3419abc8:	4770      	bx	lr
3419abca:	bf00      	nop
3419abcc:	341c15ac 	.word	0x341c15ac

3419abd0 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
3419abd0:	b580      	push	{r7, lr}
3419abd2:	b084      	sub	sp, #16
3419abd4:	af00      	add	r7, sp, #0
3419abd6:	6078      	str	r0, [r7, #4]
3419abd8:	6039      	str	r1, [r7, #0]
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
3419abda:	687b      	ldr	r3, [r7, #4]
3419abdc:	2b00      	cmp	r3, #0
3419abde:	d101      	bne.n	3419abe4 <ISP_SVC_Misc_IsGammaEnabled+0x14>
  {
    return ISP_ERR_EINVAL;
3419abe0:	2301      	movs	r3, #1
3419abe2:	e020      	b.n	3419ac26 <ISP_SVC_Misc_IsGammaEnabled+0x56>
  }

  switch(Pipe)
3419abe4:	683b      	ldr	r3, [r7, #0]
3419abe6:	2b01      	cmp	r3, #1
3419abe8:	d003      	beq.n	3419abf2 <ISP_SVC_Misc_IsGammaEnabled+0x22>
3419abea:	683b      	ldr	r3, [r7, #0]
3419abec:	2b02      	cmp	r3, #2
3419abee:	d009      	beq.n	3419ac04 <ISP_SVC_Misc_IsGammaEnabled+0x34>
3419abf0:	e011      	b.n	3419ac16 <ISP_SVC_Misc_IsGammaEnabled+0x46>
  {
  case 1:
    ret = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3419abf2:	687b      	ldr	r3, [r7, #4]
3419abf4:	681b      	ldr	r3, [r3, #0]
3419abf6:	2101      	movs	r1, #1
3419abf8:	4618      	mov	r0, r3
3419abfa:	f7ed fb7f 	bl	341882fc <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3419abfe:	4603      	mov	r3, r0
3419ac00:	73fb      	strb	r3, [r7, #15]
    break;
3419ac02:	e00a      	b.n	3419ac1a <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  case 2:
    ret = (uint8_t) HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
3419ac04:	687b      	ldr	r3, [r7, #4]
3419ac06:	681b      	ldr	r3, [r3, #0]
3419ac08:	2102      	movs	r1, #2
3419ac0a:	4618      	mov	r0, r3
3419ac0c:	f7ed fb76 	bl	341882fc <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3419ac10:	4603      	mov	r3, r0
3419ac12:	73fb      	strb	r3, [r7, #15]
    break;
3419ac14:	e001      	b.n	3419ac1a <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  default:
    ret = 0; /*  No gamma on pipe 0 */
3419ac16:	2300      	movs	r3, #0
3419ac18:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
3419ac1a:	7bfb      	ldrb	r3, [r7, #15]
3419ac1c:	2b00      	cmp	r3, #0
3419ac1e:	bf14      	ite	ne
3419ac20:	2301      	movne	r3, #1
3419ac22:	2300      	moveq	r3, #0
3419ac24:	b2db      	uxtb	r3, r3
}
3419ac26:	4618      	mov	r0, r3
3419ac28:	3710      	adds	r7, #16
3419ac2a:	46bd      	mov	sp, r7
3419ac2c:	bd80      	pop	{r7, pc}

3419ac2e <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
3419ac2e:	b580      	push	{r7, lr}
3419ac30:	b082      	sub	sp, #8
3419ac32:	af00      	add	r7, sp, #0
3419ac34:	6078      	str	r0, [r7, #4]
3419ac36:	6039      	str	r1, [r7, #0]
  if ((hIsp == NULL) || (pConfig == NULL))
3419ac38:	687b      	ldr	r3, [r7, #4]
3419ac3a:	2b00      	cmp	r3, #0
3419ac3c:	d002      	beq.n	3419ac44 <ISP_SVC_ISP_SetGamma+0x16>
3419ac3e:	683b      	ldr	r3, [r7, #0]
3419ac40:	2b00      	cmp	r3, #0
3419ac42:	d101      	bne.n	3419ac48 <ISP_SVC_ISP_SetGamma+0x1a>
  {
    return ISP_ERR_DCMIPP_GAMMA;
3419ac44:	2395      	movs	r3, #149	@ 0x95
3419ac46:	e030      	b.n	3419acaa <ISP_SVC_ISP_SetGamma+0x7c>
  }

  if (pConfig->enable == 0)
3419ac48:	683b      	ldr	r3, [r7, #0]
3419ac4a:	781b      	ldrb	r3, [r3, #0]
3419ac4c:	2b00      	cmp	r3, #0
3419ac4e:	d115      	bne.n	3419ac7c <ISP_SVC_ISP_SetGamma+0x4e>
  {
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3419ac50:	687b      	ldr	r3, [r7, #4]
3419ac52:	681b      	ldr	r3, [r3, #0]
3419ac54:	2101      	movs	r1, #1
3419ac56:	4618      	mov	r0, r3
3419ac58:	f7ed fb21 	bl	3418829e <HAL_DCMIPP_PIPE_DisableGammaConversion>
3419ac5c:	4603      	mov	r3, r0
3419ac5e:	2b00      	cmp	r3, #0
3419ac60:	d001      	beq.n	3419ac66 <ISP_SVC_ISP_SetGamma+0x38>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3419ac62:	2395      	movs	r3, #149	@ 0x95
3419ac64:	e021      	b.n	3419acaa <ISP_SVC_ISP_SetGamma+0x7c>
    }
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3419ac66:	687b      	ldr	r3, [r7, #4]
3419ac68:	681b      	ldr	r3, [r3, #0]
3419ac6a:	2102      	movs	r1, #2
3419ac6c:	4618      	mov	r0, r3
3419ac6e:	f7ed fb16 	bl	3418829e <HAL_DCMIPP_PIPE_DisableGammaConversion>
3419ac72:	4603      	mov	r3, r0
3419ac74:	2b00      	cmp	r3, #0
3419ac76:	d017      	beq.n	3419aca8 <ISP_SVC_ISP_SetGamma+0x7a>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3419ac78:	2395      	movs	r3, #149	@ 0x95
3419ac7a:	e016      	b.n	3419acaa <ISP_SVC_ISP_SetGamma+0x7c>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3419ac7c:	687b      	ldr	r3, [r7, #4]
3419ac7e:	681b      	ldr	r3, [r3, #0]
3419ac80:	2101      	movs	r1, #1
3419ac82:	4618      	mov	r0, r3
3419ac84:	f7ed fadc 	bl	34188240 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3419ac88:	4603      	mov	r3, r0
3419ac8a:	2b00      	cmp	r3, #0
3419ac8c:	d001      	beq.n	3419ac92 <ISP_SVC_ISP_SetGamma+0x64>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3419ac8e:	2395      	movs	r3, #149	@ 0x95
3419ac90:	e00b      	b.n	3419acaa <ISP_SVC_ISP_SetGamma+0x7c>
    }
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3419ac92:	687b      	ldr	r3, [r7, #4]
3419ac94:	681b      	ldr	r3, [r3, #0]
3419ac96:	2102      	movs	r1, #2
3419ac98:	4618      	mov	r0, r3
3419ac9a:	f7ed fad1 	bl	34188240 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3419ac9e:	4603      	mov	r3, r0
3419aca0:	2b00      	cmp	r3, #0
3419aca2:	d001      	beq.n	3419aca8 <ISP_SVC_ISP_SetGamma+0x7a>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3419aca4:	2395      	movs	r3, #149	@ 0x95
3419aca6:	e000      	b.n	3419acaa <ISP_SVC_ISP_SetGamma+0x7c>
    }
  }

  return ISP_OK;
3419aca8:	2300      	movs	r3, #0
}
3419acaa:	4618      	mov	r0, r3
3419acac:	3708      	adds	r7, #8
3419acae:	46bd      	mov	sp, r7
3419acb0:	bd80      	pop	{r7, pc}
	...

3419acb4 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
3419acb4:	b580      	push	{r7, lr}
3419acb6:	b082      	sub	sp, #8
3419acb8:	af00      	add	r7, sp, #0
3419acba:	6078      	str	r0, [r7, #4]
3419acbc:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
3419acbe:	4a07      	ldr	r2, [pc, #28]	@ (3419acdc <ISP_SVC_IQParam_Init+0x28>)
3419acc0:	683b      	ldr	r3, [r7, #0]
3419acc2:	4610      	mov	r0, r2
3419acc4:	4619      	mov	r1, r3
3419acc6:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419acca:	461a      	mov	r2, r3
3419accc:	f00a fc8b 	bl	341a55e6 <memcpy>
  return ISP_OK;
3419acd0:	2300      	movs	r3, #0
}
3419acd2:	4618      	mov	r0, r3
3419acd4:	3708      	adds	r7, #8
3419acd6:	46bd      	mov	sp, r7
3419acd8:	bd80      	pop	{r7, pc}
3419acda:	bf00      	nop
3419acdc:	341c15b0 	.word	0x341c15b0

3419ace0 <ISP_SVC_IQParam_Get>:
  *         Get the pointer to the IQ parameters cache
  * @param  hIsp: ISP device handle
  * @retval Pointer to the IQ Param config
  */
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
3419ace0:	b480      	push	{r7}
3419ace2:	b083      	sub	sp, #12
3419ace4:	af00      	add	r7, sp, #0
3419ace6:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
3419ace8:	4b03      	ldr	r3, [pc, #12]	@ (3419acf8 <ISP_SVC_IQParam_Get+0x18>)
}
3419acea:	4618      	mov	r0, r3
3419acec:	370c      	adds	r7, #12
3419acee:	46bd      	mov	sp, r7
3419acf0:	f85d 7b04 	ldr.w	r7, [sp], #4
3419acf4:	4770      	bx	lr
3419acf6:	bf00      	nop
3419acf8:	341c15b0 	.word	0x341c15b0

3419acfc <ISP_SVC_Stats_Init>:
  *         Initialize the statistic engine
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
3419acfc:	b580      	push	{r7, lr}
3419acfe:	b082      	sub	sp, #8
3419ad00:	af00      	add	r7, sp, #0
3419ad02:	6078      	str	r0, [r7, #4]
  UNUSED(hIsp);
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
3419ad04:	f44f 72b0 	mov.w	r2, #352	@ 0x160
3419ad08:	2100      	movs	r1, #0
3419ad0a:	4803      	ldr	r0, [pc, #12]	@ (3419ad18 <ISP_SVC_Stats_Init+0x1c>)
3419ad0c:	f00a fbf0 	bl	341a54f0 <memset>
}
3419ad10:	bf00      	nop
3419ad12:	3708      	adds	r7, #8
3419ad14:	46bd      	mov	sp, r7
3419ad16:	bd80      	pop	{r7, pc}
3419ad18:	341c1808 	.word	0x341c1808

3419ad1c <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
3419ad1c:	b5b0      	push	{r4, r5, r7, lr}
3419ad1e:	b092      	sub	sp, #72	@ 0x48
3419ad20:	af00      	add	r7, sp, #0
3419ad22:	6078      	str	r0, [r7, #4]
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t avgR, avgG, avgB, frameId;
  uint8_t i;

  /* Check handle validity */
  if (hIsp == NULL)
3419ad24:	687b      	ldr	r3, [r7, #4]
3419ad26:	2b00      	cmp	r3, #0
3419ad28:	d103      	bne.n	3419ad32 <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
3419ad2a:	48bf      	ldr	r0, [pc, #764]	@ (3419b028 <ISP_SVC_Stats_Gather+0x30c>)
3419ad2c:	f00a fab0 	bl	341a5290 <puts>
    return;
3419ad30:	e2bc      	b.n	3419b2ac <ISP_SVC_Stats_Gather+0x590>
  }

  if (hIsp->hDcmipp == NULL)
3419ad32:	687b      	ldr	r3, [r7, #4]
3419ad34:	681b      	ldr	r3, [r3, #0]
3419ad36:	2b00      	cmp	r3, #0
3419ad38:	f000 82b7 	beq.w	3419b2aa <ISP_SVC_Stats_Gather+0x58e>
  }

  /* Read the stats according to the configuration applied 2 VSYNC (shadow register + stat computation)
   * stages earlier.
   */
  ongoing = &ISP_SVC_StatEngine.ongoing;
3419ad3c:	4bbb      	ldr	r3, [pc, #748]	@ (3419b02c <ISP_SVC_Stats_Gather+0x310>)
3419ad3e:	643b      	str	r3, [r7, #64]	@ 0x40
  switch(stagePrevious2)
3419ad40:	4bbb      	ldr	r3, [pc, #748]	@ (3419b030 <ISP_SVC_Stats_Gather+0x314>)
3419ad42:	781b      	ldrb	r3, [r3, #0]
3419ad44:	2b09      	cmp	r3, #9
3419ad46:	f200 80fd 	bhi.w	3419af44 <ISP_SVC_Stats_Gather+0x228>
3419ad4a:	a201      	add	r2, pc, #4	@ (adr r2, 3419ad50 <ISP_SVC_Stats_Gather+0x34>)
3419ad4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419ad50:	3419ad79 	.word	0x3419ad79
3419ad54:	3419ae01 	.word	0x3419ae01
3419ad58:	3419ae0f 	.word	0x3419ae0f
3419ad5c:	3419ae1d 	.word	0x3419ae1d
3419ad60:	3419ae2b 	.word	0x3419ae2b
3419ad64:	3419ae39 	.word	0x3419ae39
3419ad68:	3419af0d 	.word	0x3419af0d
3419ad6c:	3419af1b 	.word	0x3419af1b
3419ad70:	3419af29 	.word	0x3419af29
3419ad74:	3419af37 	.word	0x3419af37
  {
  case ISP_STAT_CFG_UP_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3419ad78:	687b      	ldr	r3, [r7, #4]
3419ad7a:	6818      	ldr	r0, [r3, #0]
3419ad7c:	f107 0310 	add.w	r3, r7, #16
3419ad80:	2201      	movs	r2, #1
3419ad82:	2101      	movs	r1, #1
3419ad84:	f7ee f9cf 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3419ad88:	687b      	ldr	r3, [r7, #4]
3419ad8a:	6818      	ldr	r0, [r3, #0]
3419ad8c:	f107 030c 	add.w	r3, r7, #12
3419ad90:	2202      	movs	r2, #2
3419ad92:	2101      	movs	r1, #1
3419ad94:	f7ee f9c7 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3419ad98:	687b      	ldr	r3, [r7, #4]
3419ad9a:	6818      	ldr	r0, [r3, #0]
3419ad9c:	f107 0308 	add.w	r3, r7, #8
3419ada0:	2203      	movs	r2, #3
3419ada2:	2101      	movs	r1, #1
3419ada4:	f7ee f9bf 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
3419ada8:	693b      	ldr	r3, [r7, #16]
3419adaa:	2200      	movs	r2, #0
3419adac:	2101      	movs	r1, #1
3419adae:	6878      	ldr	r0, [r7, #4]
3419adb0:	f7fe fe9e 	bl	34199af0 <GetAvgStats>
3419adb4:	4603      	mov	r3, r0
3419adb6:	461a      	mov	r2, r3
3419adb8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419adba:	701a      	strb	r2, [r3, #0]
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3419adbc:	68fb      	ldr	r3, [r7, #12]
3419adbe:	2201      	movs	r2, #1
3419adc0:	2101      	movs	r1, #1
3419adc2:	6878      	ldr	r0, [r7, #4]
3419adc4:	f7fe fe94 	bl	34199af0 <GetAvgStats>
3419adc8:	4603      	mov	r3, r0
3419adca:	461a      	mov	r2, r3
3419adcc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419adce:	705a      	strb	r2, [r3, #1]
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
3419add0:	68bb      	ldr	r3, [r7, #8]
3419add2:	2202      	movs	r2, #2
3419add4:	2101      	movs	r1, #1
3419add6:	6878      	ldr	r0, [r7, #4]
3419add8:	f7fe fe8a 	bl	34199af0 <GetAvgStats>
3419addc:	4603      	mov	r3, r0
3419adde:	461a      	mov	r2, r3
3419ade0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ade2:	709a      	strb	r2, [r3, #2]
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
3419ade4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ade6:	7818      	ldrb	r0, [r3, #0]
3419ade8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419adea:	7859      	ldrb	r1, [r3, #1]
3419adec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419adee:	789b      	ldrb	r3, [r3, #2]
3419adf0:	461a      	mov	r2, r3
3419adf2:	f7ff f865 	bl	34199ec0 <LuminanceFromRGB>
3419adf6:	4603      	mov	r3, r0
3419adf8:	461a      	mov	r2, r3
3419adfa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419adfc:	70da      	strb	r2, [r3, #3]
    break;
3419adfe:	e0a2      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
3419ae00:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae02:	3304      	adds	r3, #4
3419ae04:	4619      	mov	r1, r3
3419ae06:	6878      	ldr	r0, [r7, #4]
3419ae08:	f7fe feb6 	bl	34199b78 <ReadStatHistogram>
    break;
3419ae0c:	e09b      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
3419ae0e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae10:	3310      	adds	r3, #16
3419ae12:	4619      	mov	r1, r3
3419ae14:	6878      	ldr	r0, [r7, #4]
3419ae16:	f7fe feaf 	bl	34199b78 <ReadStatHistogram>
    break;
3419ae1a:	e094      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
3419ae1c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae1e:	331c      	adds	r3, #28
3419ae20:	4619      	mov	r1, r3
3419ae22:	6878      	ldr	r0, [r7, #4]
3419ae24:	f7fe fea8 	bl	34199b78 <ReadStatHistogram>
    break;
3419ae28:	e08d      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
3419ae2a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae2c:	3328      	adds	r3, #40	@ 0x28
3419ae2e:	4619      	mov	r1, r3
3419ae30:	6878      	ldr	r0, [r7, #4]
3419ae32:	f7fe fea1 	bl	34199b78 <ReadStatHistogram>
    break;
3419ae36:	e086      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3419ae38:	687b      	ldr	r3, [r7, #4]
3419ae3a:	6818      	ldr	r0, [r3, #0]
3419ae3c:	f107 0310 	add.w	r3, r7, #16
3419ae40:	2201      	movs	r2, #1
3419ae42:	2101      	movs	r1, #1
3419ae44:	f7ee f96f 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3419ae48:	687b      	ldr	r3, [r7, #4]
3419ae4a:	6818      	ldr	r0, [r3, #0]
3419ae4c:	f107 030c 	add.w	r3, r7, #12
3419ae50:	2202      	movs	r2, #2
3419ae52:	2101      	movs	r1, #1
3419ae54:	f7ee f967 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3419ae58:	687b      	ldr	r3, [r7, #4]
3419ae5a:	6818      	ldr	r0, [r3, #0]
3419ae5c:	f107 0308 	add.w	r3, r7, #8
3419ae60:	2203      	movs	r2, #3
3419ae62:	2101      	movs	r1, #1
3419ae64:	f7ee f95f 	bl	34189126 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
3419ae68:	693b      	ldr	r3, [r7, #16]
3419ae6a:	2200      	movs	r2, #0
3419ae6c:	2102      	movs	r1, #2
3419ae6e:	6878      	ldr	r0, [r7, #4]
3419ae70:	f7fe fe3e 	bl	34199af0 <GetAvgStats>
3419ae74:	4603      	mov	r3, r0
3419ae76:	461a      	mov	r2, r3
3419ae78:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae7a:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3419ae7e:	68fb      	ldr	r3, [r7, #12]
3419ae80:	2201      	movs	r2, #1
3419ae82:	2102      	movs	r1, #2
3419ae84:	6878      	ldr	r0, [r7, #4]
3419ae86:	f7fe fe33 	bl	34199af0 <GetAvgStats>
3419ae8a:	4603      	mov	r3, r0
3419ae8c:	461a      	mov	r2, r3
3419ae8e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419ae90:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3419ae94:	68bb      	ldr	r3, [r7, #8]
3419ae96:	2202      	movs	r2, #2
3419ae98:	2102      	movs	r1, #2
3419ae9a:	6878      	ldr	r0, [r7, #4]
3419ae9c:	f7fe fe28 	bl	34199af0 <GetAvgStats>
3419aea0:	4603      	mov	r3, r0
3419aea2:	461a      	mov	r2, r3
3419aea4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aea6:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
    IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3419aeaa:	6878      	ldr	r0, [r7, #4]
3419aeac:	f7ff ff18 	bl	3419ace0 <ISP_SVC_IQParam_Get>
3419aeb0:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
3419aeb2:	687b      	ldr	r3, [r7, #4]
3419aeb4:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
3419aeb8:	2b04      	cmp	r3, #4
3419aeba:	d003      	beq.n	3419aec4 <ISP_SVC_Stats_Gather+0x1a8>
3419aebc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419aebe:	7b1b      	ldrb	r3, [r3, #12]
3419aec0:	2b00      	cmp	r3, #0
3419aec2:	d111      	bne.n	3419aee8 <ISP_SVC_Stats_Gather+0x1cc>
    {
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3419aec4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aec6:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
3419aeca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aecc:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
3419aed0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aed2:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3419aed6:	461a      	mov	r2, r3
3419aed8:	f7ff f832 	bl	34199f40 <LuminanceFromRGBMono>
3419aedc:	4603      	mov	r3, r0
3419aede:	461a      	mov	r2, r3
3419aee0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aee2:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    }
    else
    {
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
    }
    break;
3419aee6:	e02e      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3419aee8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aeea:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
3419aeee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aef0:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
3419aef4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419aef6:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3419aefa:	461a      	mov	r2, r3
3419aefc:	f7fe ffe0 	bl	34199ec0 <LuminanceFromRGB>
3419af00:	4603      	mov	r3, r0
3419af02:	461a      	mov	r2, r3
3419af04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419af06:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    break;
3419af0a:	e01c      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
3419af0c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419af0e:	3338      	adds	r3, #56	@ 0x38
3419af10:	4619      	mov	r1, r3
3419af12:	6878      	ldr	r0, [r7, #4]
3419af14:	f7fe fe30 	bl	34199b78 <ReadStatHistogram>
    break;
3419af18:	e015      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
3419af1a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419af1c:	3344      	adds	r3, #68	@ 0x44
3419af1e:	4619      	mov	r1, r3
3419af20:	6878      	ldr	r0, [r7, #4]
3419af22:	f7fe fe29 	bl	34199b78 <ReadStatHistogram>
    break;
3419af26:	e00e      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
3419af28:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419af2a:	3350      	adds	r3, #80	@ 0x50
3419af2c:	4619      	mov	r1, r3
3419af2e:	6878      	ldr	r0, [r7, #4]
3419af30:	f7fe fe22 	bl	34199b78 <ReadStatHistogram>
    break;
3419af34:	e007      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
3419af36:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419af38:	335c      	adds	r3, #92	@ 0x5c
3419af3a:	4619      	mov	r1, r3
3419af3c:	6878      	ldr	r0, [r7, #4]
3419af3e:	f7fe fe1b 	bl	34199b78 <ReadStatHistogram>
    break;
3419af42:	e000      	b.n	3419af46 <ISP_SVC_Stats_Gather+0x22a>

  default:
    /* No Read */
    break;
3419af44:	bf00      	nop
  }

  /* Configure stat for a new stage */
  switch(ISP_SVC_StatEngine.stage)
3419af46:	4b3b      	ldr	r3, [pc, #236]	@ (3419b034 <ISP_SVC_Stats_Gather+0x318>)
3419af48:	781b      	ldrb	r3, [r3, #0]
3419af4a:	2b09      	cmp	r3, #9
3419af4c:	f200 80c9 	bhi.w	3419b0e2 <ISP_SVC_Stats_Gather+0x3c6>
3419af50:	a201      	add	r2, pc, #4	@ (adr r2, 3419af58 <ISP_SVC_Stats_Gather+0x23c>)
3419af52:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419af56:	bf00      	nop
3419af58:	3419af81 	.word	0x3419af81
3419af5c:	3419afe7 	.word	0x3419afe7
3419af60:	3419aff5 	.word	0x3419aff5
3419af64:	3419b003 	.word	0x3419b003
3419af68:	3419b011 	.word	0x3419b011
3419af6c:	3419b01f 	.word	0x3419b01f
3419af70:	3419b0ab 	.word	0x3419b0ab
3419af74:	3419b0b9 	.word	0x3419b0b9
3419af78:	3419b0c7 	.word	0x3419b0c7
3419af7c:	3419b0d5 	.word	0x3419b0d5
  {
  case ISP_STAT_CFG_UP_AVG:
    for (i = 0; i < 3; i++)
3419af80:	2300      	movs	r3, #0
3419af82:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419af86:	e029      	b.n	3419afdc <ISP_SVC_Stats_Gather+0x2c0>
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3419af88:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419af8c:	4613      	mov	r3, r2
3419af8e:	005b      	lsls	r3, r3, #1
3419af90:	4413      	add	r3, r2
3419af92:	009b      	lsls	r3, r3, #2
3419af94:	3348      	adds	r3, #72	@ 0x48
3419af96:	443b      	add	r3, r7
3419af98:	3b34      	subs	r3, #52	@ 0x34
3419af9a:	2200      	movs	r2, #0
3419af9c:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBUp[i];
3419af9e:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419afa2:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419afa6:	4924      	ldr	r1, [pc, #144]	@ (3419b038 <ISP_SVC_Stats_Gather+0x31c>)
3419afa8:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
3419afac:	4613      	mov	r3, r2
3419afae:	005b      	lsls	r3, r3, #1
3419afb0:	4413      	add	r3, r2
3419afb2:	009b      	lsls	r3, r3, #2
3419afb4:	3348      	adds	r3, #72	@ 0x48
3419afb6:	443b      	add	r3, r7
3419afb8:	3b30      	subs	r3, #48	@ 0x30
3419afba:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3419afbc:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419afc0:	4613      	mov	r3, r2
3419afc2:	005b      	lsls	r3, r3, #1
3419afc4:	4413      	add	r3, r2
3419afc6:	009b      	lsls	r3, r3, #2
3419afc8:	3348      	adds	r3, #72	@ 0x48
3419afca:	443b      	add	r3, r7
3419afcc:	3b2c      	subs	r3, #44	@ 0x2c
3419afce:	2200      	movs	r2, #0
3419afd0:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
3419afd2:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419afd6:	3301      	adds	r3, #1
3419afd8:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419afdc:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419afe0:	2b02      	cmp	r3, #2
3419afe2:	d9d1      	bls.n	3419af88 <ISP_SVC_Stats_Gather+0x26c>
    }
    break;
3419afe4:	e07e      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_0_2:
    SetStatConfig(statConf, &statConfUpBins_0_2);
3419afe6:	f107 0314 	add.w	r3, r7, #20
3419afea:	4914      	ldr	r1, [pc, #80]	@ (3419b03c <ISP_SVC_Stats_Gather+0x320>)
3419afec:	4618      	mov	r0, r3
3419afee:	f7fe fde3 	bl	34199bb8 <SetStatConfig>
    break;
3419aff2:	e077      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_3_5:
    SetStatConfig(statConf, &statConfUpBins_3_5);
3419aff4:	f107 0314 	add.w	r3, r7, #20
3419aff8:	4911      	ldr	r1, [pc, #68]	@ (3419b040 <ISP_SVC_Stats_Gather+0x324>)
3419affa:	4618      	mov	r0, r3
3419affc:	f7fe fddc 	bl	34199bb8 <SetStatConfig>
    break;
3419b000:	e070      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_6_8:
    SetStatConfig(statConf, &statConfUpBins_6_8);
3419b002:	f107 0314 	add.w	r3, r7, #20
3419b006:	490f      	ldr	r1, [pc, #60]	@ (3419b044 <ISP_SVC_Stats_Gather+0x328>)
3419b008:	4618      	mov	r0, r3
3419b00a:	f7fe fdd5 	bl	34199bb8 <SetStatConfig>
    break;
3419b00e:	e069      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_UP_BINS_9_11:
    SetStatConfig(statConf, &statConfUpBins_9_11);
3419b010:	f107 0314 	add.w	r3, r7, #20
3419b014:	490c      	ldr	r1, [pc, #48]	@ (3419b048 <ISP_SVC_Stats_Gather+0x32c>)
3419b016:	4618      	mov	r0, r3
3419b018:	f7fe fdce 	bl	34199bb8 <SetStatConfig>
    break;
3419b01c:	e062      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_AVG:
    for (i = 0; i < 3; i++)
3419b01e:	2300      	movs	r3, #0
3419b020:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419b024:	e03c      	b.n	3419b0a0 <ISP_SVC_Stats_Gather+0x384>
3419b026:	bf00      	nop
3419b028:	341a7590 	.word	0x341a7590
3419b02c:	341c1884 	.word	0x341c1884
3419b030:	341c00f1 	.word	0x341c00f1
3419b034:	341c1808 	.word	0x341c1808
3419b038:	341a7efc 	.word	0x341a7efc
3419b03c:	341a7f14 	.word	0x341a7f14
3419b040:	341a7f20 	.word	0x341a7f20
3419b044:	341a7f2c 	.word	0x341a7f2c
3419b048:	341a7f38 	.word	0x341a7f38
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3419b04c:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419b050:	4613      	mov	r3, r2
3419b052:	005b      	lsls	r3, r3, #1
3419b054:	4413      	add	r3, r2
3419b056:	009b      	lsls	r3, r3, #2
3419b058:	3348      	adds	r3, #72	@ 0x48
3419b05a:	443b      	add	r3, r7
3419b05c:	3b34      	subs	r3, #52	@ 0x34
3419b05e:	2200      	movs	r2, #0
3419b060:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBDown[i];
3419b062:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b066:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419b06a:	4992      	ldr	r1, [pc, #584]	@ (3419b2b4 <ISP_SVC_Stats_Gather+0x598>)
3419b06c:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
3419b070:	4613      	mov	r3, r2
3419b072:	005b      	lsls	r3, r3, #1
3419b074:	4413      	add	r3, r2
3419b076:	009b      	lsls	r3, r3, #2
3419b078:	3348      	adds	r3, #72	@ 0x48
3419b07a:	443b      	add	r3, r7
3419b07c:	3b30      	subs	r3, #48	@ 0x30
3419b07e:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3419b080:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419b084:	4613      	mov	r3, r2
3419b086:	005b      	lsls	r3, r3, #1
3419b088:	4413      	add	r3, r2
3419b08a:	009b      	lsls	r3, r3, #2
3419b08c:	3348      	adds	r3, #72	@ 0x48
3419b08e:	443b      	add	r3, r7
3419b090:	3b2c      	subs	r3, #44	@ 0x2c
3419b092:	2200      	movs	r2, #0
3419b094:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
3419b096:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b09a:	3301      	adds	r3, #1
3419b09c:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419b0a0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b0a4:	2b02      	cmp	r3, #2
3419b0a6:	d9d1      	bls.n	3419b04c <ISP_SVC_Stats_Gather+0x330>
    }
    break;
3419b0a8:	e01c      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    SetStatConfig(statConf, &statConfDownBins_0_2);
3419b0aa:	f107 0314 	add.w	r3, r7, #20
3419b0ae:	4982      	ldr	r1, [pc, #520]	@ (3419b2b8 <ISP_SVC_Stats_Gather+0x59c>)
3419b0b0:	4618      	mov	r0, r3
3419b0b2:	f7fe fd81 	bl	34199bb8 <SetStatConfig>
    break;
3419b0b6:	e015      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    SetStatConfig(statConf, &statConfDownBins_3_5);
3419b0b8:	f107 0314 	add.w	r3, r7, #20
3419b0bc:	497f      	ldr	r1, [pc, #508]	@ (3419b2bc <ISP_SVC_Stats_Gather+0x5a0>)
3419b0be:	4618      	mov	r0, r3
3419b0c0:	f7fe fd7a 	bl	34199bb8 <SetStatConfig>
    break;
3419b0c4:	e00e      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    SetStatConfig(statConf, &statConfDownBins_6_8);
3419b0c6:	f107 0314 	add.w	r3, r7, #20
3419b0ca:	497d      	ldr	r1, [pc, #500]	@ (3419b2c0 <ISP_SVC_Stats_Gather+0x5a4>)
3419b0cc:	4618      	mov	r0, r3
3419b0ce:	f7fe fd73 	bl	34199bb8 <SetStatConfig>
    break;
3419b0d2:	e007      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    SetStatConfig(statConf, &statConfDownBins_9_11);
3419b0d4:	f107 0314 	add.w	r3, r7, #20
3419b0d8:	497a      	ldr	r1, [pc, #488]	@ (3419b2c4 <ISP_SVC_Stats_Gather+0x5a8>)
3419b0da:	4618      	mov	r0, r3
3419b0dc:	f7fe fd6c 	bl	34199bb8 <SetStatConfig>
    break;
3419b0e0:	e000      	b.n	3419b0e4 <ISP_SVC_Stats_Gather+0x3c8>

  default:
    /* Configure Unchanged */
    break;
3419b0e2:	bf00      	nop
  }

  /* Apply configuration (for an output result available 2 VSYNC later) */
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3419b0e4:	2301      	movs	r3, #1
3419b0e6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419b0ea:	e02b      	b.n	3419b144 <ISP_SVC_Stats_Gather+0x428>
  {
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
3419b0ec:	687b      	ldr	r3, [r7, #4]
3419b0ee:	6818      	ldr	r0, [r3, #0]
3419b0f0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b0f4:	1e5a      	subs	r2, r3, #1
3419b0f6:	f107 0114 	add.w	r1, r7, #20
3419b0fa:	4613      	mov	r3, r2
3419b0fc:	005b      	lsls	r3, r3, #1
3419b0fe:	4413      	add	r3, r2
3419b100:	009b      	lsls	r3, r3, #2
3419b102:	440b      	add	r3, r1
3419b104:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419b108:	2101      	movs	r1, #1
3419b10a:	f7ed fd0c 	bl	34188b26 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
3419b10e:	4603      	mov	r3, r0
3419b110:	2b00      	cmp	r3, #0
3419b112:	d003      	beq.n	3419b11c <ISP_SVC_Stats_Gather+0x400>
    {
      printf("ERROR: can't set Statistic Extraction config\r\n");
3419b114:	486c      	ldr	r0, [pc, #432]	@ (3419b2c8 <ISP_SVC_Stats_Gather+0x5ac>)
3419b116:	f00a f8bb 	bl	341a5290 <puts>
      return;
3419b11a:	e0c7      	b.n	3419b2ac <ISP_SVC_Stats_Gather+0x590>
    }

    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
3419b11c:	687b      	ldr	r3, [r7, #4]
3419b11e:	681b      	ldr	r3, [r3, #0]
3419b120:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
3419b124:	2101      	movs	r1, #1
3419b126:	4618      	mov	r0, r3
3419b128:	f7ed fd8b 	bl	34188c42 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
3419b12c:	4603      	mov	r3, r0
3419b12e:	2b00      	cmp	r3, #0
3419b130:	d003      	beq.n	3419b13a <ISP_SVC_Stats_Gather+0x41e>
    {
      printf("ERROR: can't enable Statistic Extraction config\r\n");
3419b132:	4866      	ldr	r0, [pc, #408]	@ (3419b2cc <ISP_SVC_Stats_Gather+0x5b0>)
3419b134:	f00a f8ac 	bl	341a5290 <puts>
      return;
3419b138:	e0b8      	b.n	3419b2ac <ISP_SVC_Stats_Gather+0x590>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3419b13a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b13e:	3301      	adds	r3, #1
3419b140:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
3419b144:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
3419b148:	2b03      	cmp	r3, #3
3419b14a:	d9cf      	bls.n	3419b0ec <ISP_SVC_Stats_Gather+0x3d0>
    }
  }

  /* Cycle start / end */
  frameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
3419b14c:	6878      	ldr	r0, [r7, #4]
3419b14e:	f7ff fd02 	bl	3419ab56 <ISP_SVC_Misc_GetMainFrameId>
3419b152:	63b8      	str	r0, [r7, #56]	@ 0x38

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3419b154:	2001      	movs	r0, #1
3419b156:	f7fe fe41 	bl	34199ddc <GetStatCycleStart>
3419b15a:	4603      	mov	r3, r0
3419b15c:	461a      	mov	r2, r3
3419b15e:	4b5c      	ldr	r3, [pc, #368]	@ (3419b2d0 <ISP_SVC_Stats_Gather+0x5b4>)
3419b160:	781b      	ldrb	r3, [r3, #0]
3419b162:	429a      	cmp	r2, r3
3419b164:	d102      	bne.n	3419b16c <ISP_SVC_Stats_Gather+0x450>
  {
    ongoing->upFrameIdStart = frameId;
3419b166:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b168:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b16a:	669a      	str	r2, [r3, #104]	@ 0x68
  }

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
3419b16c:	2002      	movs	r0, #2
3419b16e:	f7fe fe35 	bl	34199ddc <GetStatCycleStart>
3419b172:	4603      	mov	r3, r0
3419b174:	461a      	mov	r2, r3
3419b176:	4b56      	ldr	r3, [pc, #344]	@ (3419b2d0 <ISP_SVC_Stats_Gather+0x5b4>)
3419b178:	781b      	ldrb	r3, [r3, #0]
3419b17a:	429a      	cmp	r2, r3
3419b17c:	d102      	bne.n	3419b184 <ISP_SVC_Stats_Gather+0x468>
  {
    ongoing->downFrameIdStart = frameId;
3419b17e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b180:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b182:	671a      	str	r2, [r3, #112]	@ 0x70
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
3419b184:	2001      	movs	r0, #1
3419b186:	f7fe fe61 	bl	34199e4c <GetStatCycleEnd>
3419b18a:	4603      	mov	r3, r0
3419b18c:	461a      	mov	r2, r3
3419b18e:	4b50      	ldr	r3, [pc, #320]	@ (3419b2d0 <ISP_SVC_Stats_Gather+0x5b4>)
3419b190:	781b      	ldrb	r3, [r3, #0]
3419b192:	429a      	cmp	r2, r3
3419b194:	d122      	bne.n	3419b1dc <ISP_SVC_Stats_Gather+0x4c0>
3419b196:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b198:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419b19a:	2b00      	cmp	r3, #0
3419b19c:	d01e      	beq.n	3419b1dc <ISP_SVC_Stats_Gather+0x4c0>
  {
    /* Last measure of the up cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.up = ongoing->up;
3419b19e:	4b4d      	ldr	r3, [pc, #308]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b1a0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3419b1a2:	1d1c      	adds	r4, r3, #4
3419b1a4:	4615      	mov	r5, r2
3419b1a6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b1a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b1aa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b1ac:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b1ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b1b0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b1b2:	682b      	ldr	r3, [r5, #0]
3419b1b4:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.upFrameIdEnd = frameId;
3419b1b6:	4a47      	ldr	r2, [pc, #284]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b1b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b1ba:	6713      	str	r3, [r2, #112]	@ 0x70
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
3419b1bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1be:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419b1c0:	4a44      	ldr	r2, [pc, #272]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b1c2:	66d3      	str	r3, [r2, #108]	@ 0x6c

    memset(&ongoing->up, 0, sizeof(ongoing->up));
3419b1c4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1c6:	2234      	movs	r2, #52	@ 0x34
3419b1c8:	2100      	movs	r1, #0
3419b1ca:	4618      	mov	r0, r3
3419b1cc:	f00a f990 	bl	341a54f0 <memset>
    ongoing->upFrameIdStart = 0;
3419b1d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1d2:	2200      	movs	r2, #0
3419b1d4:	669a      	str	r2, [r3, #104]	@ 0x68
    ongoing->upFrameIdEnd = 0;
3419b1d6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1d8:	2200      	movs	r2, #0
3419b1da:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
3419b1dc:	2002      	movs	r0, #2
3419b1de:	f7fe fe35 	bl	34199e4c <GetStatCycleEnd>
3419b1e2:	4603      	mov	r3, r0
3419b1e4:	461a      	mov	r2, r3
3419b1e6:	4b3a      	ldr	r3, [pc, #232]	@ (3419b2d0 <ISP_SVC_Stats_Gather+0x5b4>)
3419b1e8:	781b      	ldrb	r3, [r3, #0]
3419b1ea:	429a      	cmp	r2, r3
3419b1ec:	d125      	bne.n	3419b23a <ISP_SVC_Stats_Gather+0x51e>
3419b1ee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1f0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419b1f2:	2b00      	cmp	r3, #0
3419b1f4:	d021      	beq.n	3419b23a <ISP_SVC_Stats_Gather+0x51e>
  {
    /* Last measure of the down cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.down = ongoing->down;
3419b1f6:	4a37      	ldr	r2, [pc, #220]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b1f8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b1fa:	f102 0438 	add.w	r4, r2, #56	@ 0x38
3419b1fe:	f103 0534 	add.w	r5, r3, #52	@ 0x34
3419b202:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b204:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b206:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b208:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b20a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b20c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b20e:	682b      	ldr	r3, [r5, #0]
3419b210:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.downFrameIdEnd = frameId;
3419b212:	4a30      	ldr	r2, [pc, #192]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b214:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3419b216:	6793      	str	r3, [r2, #120]	@ 0x78
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
3419b218:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b21a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419b21c:	4a2d      	ldr	r2, [pc, #180]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b21e:	6753      	str	r3, [r2, #116]	@ 0x74

    memset(&ongoing->down, 0, sizeof(ongoing->down));
3419b220:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b222:	3334      	adds	r3, #52	@ 0x34
3419b224:	2234      	movs	r2, #52	@ 0x34
3419b226:	2100      	movs	r1, #0
3419b228:	4618      	mov	r0, r3
3419b22a:	f00a f961 	bl	341a54f0 <memset>
    ongoing->downFrameIdStart = 0;
3419b22e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b230:	2200      	movs	r2, #0
3419b232:	671a      	str	r2, [r3, #112]	@ 0x70
    ongoing->downFrameIdEnd = 0;
3419b234:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3419b236:	2200      	movs	r2, #0
3419b238:	675a      	str	r2, [r3, #116]	@ 0x74
  }

  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3419b23a:	4b26      	ldr	r3, [pc, #152]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b23c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3419b240:	f003 0304 	and.w	r3, r3, #4
3419b244:	2b00      	cmp	r3, #0
3419b246:	d106      	bne.n	3419b256 <ISP_SVC_Stats_Gather+0x53a>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
3419b248:	4b22      	ldr	r3, [pc, #136]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b24a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419b24e:	f003 0304 	and.w	r3, r3, #4
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3419b252:	2b00      	cmp	r3, #0
3419b254:	d017      	beq.n	3419b286 <ISP_SVC_Stats_Gather+0x56a>
      (frameId > ISP_SVC_StatEngine.requestAllCounter))
3419b256:	4b1f      	ldr	r3, [pc, #124]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b258:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
3419b25c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3419b25e:	429a      	cmp	r2, r3
3419b260:	d911      	bls.n	3419b286 <ISP_SVC_Stats_Gather+0x56a>
  {
    /* Stop the special temporary mode "request all stats" when its delay expires */
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3419b262:	4b1c      	ldr	r3, [pc, #112]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b264:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3419b268:	f023 0304 	bic.w	r3, r3, #4
3419b26c:	b2da      	uxtb	r2, r3
3419b26e:	4b19      	ldr	r3, [pc, #100]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b270:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
3419b274:	4b17      	ldr	r3, [pc, #92]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b276:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3419b27a:	f023 0304 	bic.w	r3, r3, #4
3419b27e:	b2da      	uxtb	r2, r3
3419b280:	4b14      	ldr	r3, [pc, #80]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b282:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
3419b286:	4b14      	ldr	r3, [pc, #80]	@ (3419b2d8 <ISP_SVC_Stats_Gather+0x5bc>)
3419b288:	781a      	ldrb	r2, [r3, #0]
3419b28a:	4b11      	ldr	r3, [pc, #68]	@ (3419b2d0 <ISP_SVC_Stats_Gather+0x5b4>)
3419b28c:	701a      	strb	r2, [r3, #0]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
3419b28e:	4b11      	ldr	r3, [pc, #68]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b290:	781a      	ldrb	r2, [r3, #0]
3419b292:	4b11      	ldr	r3, [pc, #68]	@ (3419b2d8 <ISP_SVC_Stats_Gather+0x5bc>)
3419b294:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
3419b296:	4b0f      	ldr	r3, [pc, #60]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b298:	781b      	ldrb	r3, [r3, #0]
3419b29a:	4618      	mov	r0, r3
3419b29c:	f7fe fcae 	bl	34199bfc <GetNextStatStage>
3419b2a0:	4603      	mov	r3, r0
3419b2a2:	461a      	mov	r2, r3
3419b2a4:	4b0b      	ldr	r3, [pc, #44]	@ (3419b2d4 <ISP_SVC_Stats_Gather+0x5b8>)
3419b2a6:	701a      	strb	r2, [r3, #0]
3419b2a8:	e000      	b.n	3419b2ac <ISP_SVC_Stats_Gather+0x590>
    return;
3419b2aa:	bf00      	nop
}
3419b2ac:	3748      	adds	r7, #72	@ 0x48
3419b2ae:	46bd      	mov	sp, r7
3419b2b0:	bdb0      	pop	{r4, r5, r7, pc}
3419b2b2:	bf00      	nop
3419b2b4:	341a7f08 	.word	0x341a7f08
3419b2b8:	341a7f44 	.word	0x341a7f44
3419b2bc:	341a7f50 	.word	0x341a7f50
3419b2c0:	341a7f5c 	.word	0x341a7f5c
3419b2c4:	341a7f68 	.word	0x341a7f68
3419b2c8:	341a75ac 	.word	0x341a75ac
3419b2cc:	341a75dc 	.word	0x341a75dc
3419b2d0:	341c00f1 	.word	0x341c00f1
3419b2d4:	341c1808 	.word	0x341c1808
3419b2d8:	341c00f2 	.word	0x341c00f2

3419b2dc <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
3419b2dc:	b580      	push	{r7, lr}
3419b2de:	b088      	sub	sp, #32
3419b2e0:	af00      	add	r7, sp, #0
3419b2e2:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
3419b2e4:	2300      	movs	r3, #0
3419b2e6:	77fb      	strb	r3, [r7, #31]

  pLastStat = &ISP_SVC_StatEngine.last;
3419b2e8:	4b2e      	ldr	r3, [pc, #184]	@ (3419b3a4 <ISP_SVC_Stats_ProcessCallbacks+0xc8>)
3419b2ea:	617b      	str	r3, [r7, #20]

  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419b2ec:	2300      	movs	r3, #0
3419b2ee:	61bb      	str	r3, [r7, #24]
3419b2f0:	e04f      	b.n	3419b392 <ISP_SVC_Stats_ProcessCallbacks+0xb6>
  {
    client = &ISP_SVC_StatEngine.client[i];
3419b2f2:	69ba      	ldr	r2, [r7, #24]
3419b2f4:	4613      	mov	r3, r2
3419b2f6:	009b      	lsls	r3, r3, #2
3419b2f8:	4413      	add	r3, r2
3419b2fa:	009b      	lsls	r3, r3, #2
3419b2fc:	33f0      	adds	r3, #240	@ 0xf0
3419b2fe:	4a2a      	ldr	r2, [pc, #168]	@ (3419b3a8 <ISP_SVC_Stats_ProcessCallbacks+0xcc>)
3419b300:	4413      	add	r3, r2
3419b302:	3304      	adds	r3, #4
3419b304:	613b      	str	r3, [r7, #16]

    if (client->callback == NULL)
3419b306:	693b      	ldr	r3, [r7, #16]
3419b308:	681b      	ldr	r3, [r3, #0]
3419b30a:	2b00      	cmp	r3, #0
3419b30c:	d03d      	beq.n	3419b38a <ISP_SVC_Stats_ProcessCallbacks+0xae>
      continue;

    /* Check if stats are available for a client, comparing the location and the specified frameId */
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3419b30e:	693b      	ldr	r3, [r7, #16]
3419b310:	7c1b      	ldrb	r3, [r3, #16]
3419b312:	2b02      	cmp	r3, #2
3419b314:	d105      	bne.n	3419b322 <ISP_SVC_Stats_ProcessCallbacks+0x46>
3419b316:	693b      	ldr	r3, [r7, #16]
3419b318:	68da      	ldr	r2, [r3, #12]
3419b31a:	697b      	ldr	r3, [r7, #20]
3419b31c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419b31e:	429a      	cmp	r2, r3
3419b320:	d919      	bls.n	3419b356 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3419b322:	693b      	ldr	r3, [r7, #16]
3419b324:	7c1b      	ldrb	r3, [r3, #16]
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3419b326:	2b01      	cmp	r3, #1
3419b328:	d105      	bne.n	3419b336 <ISP_SVC_Stats_ProcessCallbacks+0x5a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3419b32a:	693b      	ldr	r3, [r7, #16]
3419b32c:	68da      	ldr	r2, [r3, #12]
3419b32e:	697b      	ldr	r3, [r7, #20]
3419b330:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419b332:	429a      	cmp	r2, r3
3419b334:	d90f      	bls.n	3419b356 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
3419b336:	693b      	ldr	r3, [r7, #16]
3419b338:	7c1b      	ldrb	r3, [r3, #16]
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
3419b33a:	2b03      	cmp	r3, #3
3419b33c:	d126      	bne.n	3419b38c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
3419b33e:	693b      	ldr	r3, [r7, #16]
3419b340:	68da      	ldr	r2, [r3, #12]
3419b342:	697b      	ldr	r3, [r7, #20]
3419b344:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3419b346:	429a      	cmp	r2, r3
3419b348:	d820      	bhi.n	3419b38c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
3419b34a:	693b      	ldr	r3, [r7, #16]
3419b34c:	68da      	ldr	r2, [r3, #12]
3419b34e:	697b      	ldr	r3, [r7, #20]
3419b350:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419b352:	429a      	cmp	r2, r3
3419b354:	d81a      	bhi.n	3419b38c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
    {
      /* Copy the stats into the client buffer */
      *(client->pStats) = *pLastStat;
3419b356:	693b      	ldr	r3, [r7, #16]
3419b358:	689a      	ldr	r2, [r3, #8]
3419b35a:	697b      	ldr	r3, [r7, #20]
3419b35c:	4610      	mov	r0, r2
3419b35e:	4619      	mov	r1, r3
3419b360:	2378      	movs	r3, #120	@ 0x78
3419b362:	461a      	mov	r2, r3
3419b364:	f00a f93f 	bl	341a55e6 <memcpy>

      /* Call its callback */
      retcb = client->callback(client->pAlgo);
3419b368:	693b      	ldr	r3, [r7, #16]
3419b36a:	681b      	ldr	r3, [r3, #0]
3419b36c:	693a      	ldr	r2, [r7, #16]
3419b36e:	6852      	ldr	r2, [r2, #4]
3419b370:	4610      	mov	r0, r2
3419b372:	4798      	blx	r3
3419b374:	4603      	mov	r3, r0
3419b376:	73fb      	strb	r3, [r7, #15]
      if (retcb != ISP_OK)
3419b378:	7bfb      	ldrb	r3, [r7, #15]
3419b37a:	2b00      	cmp	r3, #0
3419b37c:	d001      	beq.n	3419b382 <ISP_SVC_Stats_ProcessCallbacks+0xa6>
      {
        ret = retcb;
3419b37e:	7bfb      	ldrb	r3, [r7, #15]
3419b380:	77fb      	strb	r3, [r7, #31]
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
3419b382:	693b      	ldr	r3, [r7, #16]
3419b384:	2200      	movs	r2, #0
3419b386:	601a      	str	r2, [r3, #0]
3419b388:	e000      	b.n	3419b38c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
      continue;
3419b38a:	bf00      	nop
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419b38c:	69bb      	ldr	r3, [r7, #24]
3419b38e:	3301      	adds	r3, #1
3419b390:	61bb      	str	r3, [r7, #24]
3419b392:	69bb      	ldr	r3, [r7, #24]
3419b394:	2b04      	cmp	r3, #4
3419b396:	d9ac      	bls.n	3419b2f2 <ISP_SVC_Stats_ProcessCallbacks+0x16>
    }
  }

  return ret;
3419b398:	7ffb      	ldrb	r3, [r7, #31]
}
3419b39a:	4618      	mov	r0, r3
3419b39c:	3720      	adds	r7, #32
3419b39e:	46bd      	mov	sp, r7
3419b3a0:	bd80      	pop	{r7, pc}
3419b3a2:	bf00      	nop
3419b3a4:	341c180c 	.word	0x341c180c
3419b3a8:	341c1808 	.word	0x341c1808

3419b3ac <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
3419b3ac:	b580      	push	{r7, lr}
3419b3ae:	b086      	sub	sp, #24
3419b3b0:	af00      	add	r7, sp, #0
3419b3b2:	60f8      	str	r0, [r7, #12]
3419b3b4:	60b9      	str	r1, [r7, #8]
3419b3b6:	607a      	str	r2, [r7, #4]
3419b3b8:	603b      	str	r3, [r7, #0]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
3419b3ba:	68fb      	ldr	r3, [r7, #12]
3419b3bc:	2b00      	cmp	r3, #0
3419b3be:	d002      	beq.n	3419b3c6 <ISP_SVC_Stats_GetNext+0x1a>
3419b3c0:	683b      	ldr	r3, [r7, #0]
3419b3c2:	2b00      	cmp	r3, #0
3419b3c4:	d101      	bne.n	3419b3ca <ISP_SVC_Stats_GetNext+0x1e>
  {
    return ISP_ERR_EINVAL;
3419b3c6:	2301      	movs	r3, #1
3419b3c8:	e08f      	b.n	3419b4ea <ISP_SVC_Stats_GetNext+0x13e>
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
3419b3ca:	68f8      	ldr	r0, [r7, #12]
3419b3cc:	f7ff fbc3 	bl	3419ab56 <ISP_SVC_Misc_GetMainFrameId>
3419b3d0:	4602      	mov	r2, r0
3419b3d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419b3d4:	4413      	add	r3, r2
3419b3d6:	613b      	str	r3, [r7, #16]

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419b3d8:	2300      	movs	r3, #0
3419b3da:	617b      	str	r3, [r7, #20]
3419b3dc:	e00d      	b.n	3419b3fa <ISP_SVC_Stats_GetNext+0x4e>
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
3419b3de:	4945      	ldr	r1, [pc, #276]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b3e0:	697a      	ldr	r2, [r7, #20]
3419b3e2:	4613      	mov	r3, r2
3419b3e4:	009b      	lsls	r3, r3, #2
3419b3e6:	4413      	add	r3, r2
3419b3e8:	009b      	lsls	r3, r3, #2
3419b3ea:	440b      	add	r3, r1
3419b3ec:	33f4      	adds	r3, #244	@ 0xf4
3419b3ee:	681b      	ldr	r3, [r3, #0]
3419b3f0:	2b00      	cmp	r3, #0
3419b3f2:	d006      	beq.n	3419b402 <ISP_SVC_Stats_GetNext+0x56>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3419b3f4:	697b      	ldr	r3, [r7, #20]
3419b3f6:	3301      	adds	r3, #1
3419b3f8:	617b      	str	r3, [r7, #20]
3419b3fa:	697b      	ldr	r3, [r7, #20]
3419b3fc:	2b04      	cmp	r3, #4
3419b3fe:	d9ee      	bls.n	3419b3de <ISP_SVC_Stats_GetNext+0x32>
3419b400:	e000      	b.n	3419b404 <ISP_SVC_Stats_GetNext+0x58>
      break;
3419b402:	bf00      	nop
  }

  if (i == ISP_SVC_STAT_MAX_CB)
3419b404:	697b      	ldr	r3, [r7, #20]
3419b406:	2b05      	cmp	r3, #5
3419b408:	d101      	bne.n	3419b40e <ISP_SVC_Stats_GetNext+0x62>
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
3419b40a:	23ac      	movs	r3, #172	@ 0xac
3419b40c:	e06d      	b.n	3419b4ea <ISP_SVC_Stats_GetNext+0x13e>
  }

  /* Add this requested stat to the list of requested stats */
  if (location & ISP_STAT_LOC_UP)
3419b40e:	f897 3020 	ldrb.w	r3, [r7, #32]
3419b412:	f003 0301 	and.w	r3, r3, #1
3419b416:	2b00      	cmp	r3, #0
3419b418:	d009      	beq.n	3419b42e <ISP_SVC_Stats_GetNext+0x82>
  {
    ISP_SVC_StatEngine.upRequest |= type;
3419b41a:	4b36      	ldr	r3, [pc, #216]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b41c:	f893 2158 	ldrb.w	r2, [r3, #344]	@ 0x158
3419b420:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419b424:	4313      	orrs	r3, r2
3419b426:	b2da      	uxtb	r2, r3
3419b428:	4b32      	ldr	r3, [pc, #200]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b42a:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
  }
  if (location & ISP_STAT_LOC_DOWN)
3419b42e:	f897 3020 	ldrb.w	r3, [r7, #32]
3419b432:	f003 0302 	and.w	r3, r3, #2
3419b436:	2b00      	cmp	r3, #0
3419b438:	d009      	beq.n	3419b44e <ISP_SVC_Stats_GetNext+0xa2>
  {
    ISP_SVC_StatEngine.downRequest |= type;
3419b43a:	4b2e      	ldr	r3, [pc, #184]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b43c:	f893 2159 	ldrb.w	r2, [r3, #345]	@ 0x159
3419b440:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419b444:	4313      	orrs	r3, r2
3419b446:	b2da      	uxtb	r2, r3
3419b448:	4b2a      	ldr	r3, [pc, #168]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b44a:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  if (type == ISP_STAT_TYPE_ALL_TMP)
3419b44e:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3419b452:	2b04      	cmp	r3, #4
3419b454:	d107      	bne.n	3419b466 <ISP_SVC_Stats_GetNext+0xba>
  {
    /* Special case: request all stats for a short time (3 cycle) */
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
3419b456:	68f8      	ldr	r0, [r7, #12]
3419b458:	f7ff fb7d 	bl	3419ab56 <ISP_SVC_Misc_GetMainFrameId>
3419b45c:	4603      	mov	r3, r0
3419b45e:	331e      	adds	r3, #30
3419b460:	4a24      	ldr	r2, [pc, #144]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b462:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  }

  /* Register client */
  ISP_SVC_StatEngine.client[i].callback = callback;
3419b466:	4923      	ldr	r1, [pc, #140]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b468:	697a      	ldr	r2, [r7, #20]
3419b46a:	4613      	mov	r3, r2
3419b46c:	009b      	lsls	r3, r3, #2
3419b46e:	4413      	add	r3, r2
3419b470:	009b      	lsls	r3, r3, #2
3419b472:	440b      	add	r3, r1
3419b474:	33f4      	adds	r3, #244	@ 0xf4
3419b476:	68ba      	ldr	r2, [r7, #8]
3419b478:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
3419b47a:	491e      	ldr	r1, [pc, #120]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b47c:	697a      	ldr	r2, [r7, #20]
3419b47e:	4613      	mov	r3, r2
3419b480:	009b      	lsls	r3, r3, #2
3419b482:	4413      	add	r3, r2
3419b484:	009b      	lsls	r3, r3, #2
3419b486:	440b      	add	r3, r1
3419b488:	33f8      	adds	r3, #248	@ 0xf8
3419b48a:	687a      	ldr	r2, [r7, #4]
3419b48c:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pStats = pStats;
3419b48e:	4919      	ldr	r1, [pc, #100]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b490:	697a      	ldr	r2, [r7, #20]
3419b492:	4613      	mov	r3, r2
3419b494:	009b      	lsls	r3, r3, #2
3419b496:	4413      	add	r3, r2
3419b498:	009b      	lsls	r3, r3, #2
3419b49a:	440b      	add	r3, r1
3419b49c:	33fc      	adds	r3, #252	@ 0xfc
3419b49e:	683a      	ldr	r2, [r7, #0]
3419b4a0:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].location = location;
3419b4a2:	4914      	ldr	r1, [pc, #80]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b4a4:	697a      	ldr	r2, [r7, #20]
3419b4a6:	4613      	mov	r3, r2
3419b4a8:	009b      	lsls	r3, r3, #2
3419b4aa:	4413      	add	r3, r2
3419b4ac:	009b      	lsls	r3, r3, #2
3419b4ae:	440b      	add	r3, r1
3419b4b0:	f503 7382 	add.w	r3, r3, #260	@ 0x104
3419b4b4:	f897 2020 	ldrb.w	r2, [r7, #32]
3419b4b8:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].type = type;
3419b4ba:	490e      	ldr	r1, [pc, #56]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b4bc:	697a      	ldr	r2, [r7, #20]
3419b4be:	4613      	mov	r3, r2
3419b4c0:	009b      	lsls	r3, r3, #2
3419b4c2:	4413      	add	r3, r2
3419b4c4:	009b      	lsls	r3, r3, #2
3419b4c6:	440b      	add	r3, r1
3419b4c8:	f203 1305 	addw	r3, r3, #261	@ 0x105
3419b4cc:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
3419b4d0:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
3419b4d2:	4908      	ldr	r1, [pc, #32]	@ (3419b4f4 <ISP_SVC_Stats_GetNext+0x148>)
3419b4d4:	697a      	ldr	r2, [r7, #20]
3419b4d6:	4613      	mov	r3, r2
3419b4d8:	009b      	lsls	r3, r3, #2
3419b4da:	4413      	add	r3, r2
3419b4dc:	009b      	lsls	r3, r3, #2
3419b4de:	440b      	add	r3, r1
3419b4e0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3419b4e4:	693a      	ldr	r2, [r7, #16]
3419b4e6:	601a      	str	r2, [r3, #0]

  return ISP_OK;
3419b4e8:	2300      	movs	r3, #0
}
3419b4ea:	4618      	mov	r0, r3
3419b4ec:	3718      	adds	r7, #24
3419b4ee:	46bd      	mov	sp, r7
3419b4f0:	bd80      	pop	{r7, pc}
3419b4f2:	bf00      	nop
3419b4f4:	341c1808 	.word	0x341c1808

3419b4f8 <LL_AHB4_GRP1_EnableClock>:
{
3419b4f8:	b480      	push	{r7}
3419b4fa:	b085      	sub	sp, #20
3419b4fc:	af00      	add	r7, sp, #0
3419b4fe:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3419b500:	4a07      	ldr	r2, [pc, #28]	@ (3419b520 <LL_AHB4_GRP1_EnableClock+0x28>)
3419b502:	687b      	ldr	r3, [r7, #4]
3419b504:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3419b508:	4b05      	ldr	r3, [pc, #20]	@ (3419b520 <LL_AHB4_GRP1_EnableClock+0x28>)
3419b50a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3419b50e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3419b510:	68fb      	ldr	r3, [r7, #12]
}
3419b512:	bf00      	nop
3419b514:	3714      	adds	r7, #20
3419b516:	46bd      	mov	sp, r7
3419b518:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b51c:	4770      	bx	lr
3419b51e:	bf00      	nop
3419b520:	56028000 	.word	0x56028000

3419b524 <CMW_CAMERA_SetPipeConfig>:
{
    return &hcamera_dcmipp;
}

int32_t CMW_CAMERA_SetPipeConfig(uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3419b524:	b580      	push	{r7, lr}
3419b526:	b084      	sub	sp, #16
3419b528:	af00      	add	r7, sp, #0
3419b52a:	60f8      	str	r0, [r7, #12]
3419b52c:	60b9      	str	r1, [r7, #8]
3419b52e:	607a      	str	r2, [r7, #4]
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
3419b530:	687b      	ldr	r3, [r7, #4]
3419b532:	68ba      	ldr	r2, [r7, #8]
3419b534:	68f9      	ldr	r1, [r7, #12]
3419b536:	4804      	ldr	r0, [pc, #16]	@ (3419b548 <CMW_CAMERA_SetPipeConfig+0x24>)
3419b538:	f000 fd5a 	bl	3419bff0 <CMW_CAMERA_SetPipe>
3419b53c:	4603      	mov	r3, r0
}
3419b53e:	4618      	mov	r0, r3
3419b540:	3710      	adds	r7, #16
3419b542:	46bd      	mov	sp, r7
3419b544:	bd80      	pop	{r7, pc}
3419b546:	bf00      	nop
3419b548:	341c19c4 	.word	0x341c19c4

3419b54c <CMW_CAMERA_Probe_Sensor>:
  * @param  initValues  Initialization values for the sensor
  * @param  sensorName  Camera sensor name
  * @retval CMW status
  */
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
{
3419b54c:	b580      	push	{r7, lr}
3419b54e:	b084      	sub	sp, #16
3419b550:	af00      	add	r7, sp, #0
3419b552:	6078      	str	r0, [r7, #4]
3419b554:	6039      	str	r1, [r7, #0]
  int ret;
#if defined(USE_VD55G1_SENSOR)
  ret = CMW_CAMERA_VD55G1_Init(initValues);
3419b556:	6878      	ldr	r0, [r7, #4]
3419b558:	f000 fa8c 	bl	3419ba74 <CMW_CAMERA_VD55G1_Init>
3419b55c:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419b55e:	68fb      	ldr	r3, [r7, #12]
3419b560:	2b00      	cmp	r3, #0
3419b562:	d104      	bne.n	3419b56e <CMW_CAMERA_Probe_Sensor+0x22>
  {
    *sensorName = CMW_VD55G1_Sensor;
3419b564:	683b      	ldr	r3, [r7, #0]
3419b566:	2203      	movs	r2, #3
3419b568:	701a      	strb	r2, [r3, #0]
    return ret;
3419b56a:	68fb      	ldr	r3, [r7, #12]
3419b56c:	e019      	b.n	3419b5a2 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
#if defined(USE_VD66GY_SENSOR)
  ret = CMW_CAMERA_VD66GY_Init(initValues);
3419b56e:	6878      	ldr	r0, [r7, #4]
3419b570:	f000 fb46 	bl	3419bc00 <CMW_CAMERA_VD66GY_Init>
3419b574:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419b576:	68fb      	ldr	r3, [r7, #12]
3419b578:	2b00      	cmp	r3, #0
3419b57a:	d104      	bne.n	3419b586 <CMW_CAMERA_Probe_Sensor+0x3a>
  {
    *sensorName = CMW_VD66GY_Sensor;
3419b57c:	683b      	ldr	r3, [r7, #0]
3419b57e:	2201      	movs	r2, #1
3419b580:	701a      	strb	r2, [r3, #0]
    return ret;
3419b582:	68fb      	ldr	r3, [r7, #12]
3419b584:	e00d      	b.n	3419b5a2 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
#if defined(USE_IMX335_SENSOR)
  ret = CMW_CAMERA_IMX335_Init(initValues);
3419b586:	6878      	ldr	r0, [r7, #4]
3419b588:	f000 fc26 	bl	3419bdd8 <CMW_CAMERA_IMX335_Init>
3419b58c:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3419b58e:	68fb      	ldr	r3, [r7, #12]
3419b590:	2b00      	cmp	r3, #0
3419b592:	d104      	bne.n	3419b59e <CMW_CAMERA_Probe_Sensor+0x52>
  {
    *sensorName = CMW_IMX335_Sensor;
3419b594:	683b      	ldr	r3, [r7, #0]
3419b596:	2202      	movs	r2, #2
3419b598:	701a      	strb	r2, [r3, #0]
    return ret;
3419b59a:	68fb      	ldr	r3, [r7, #12]
3419b59c:	e001      	b.n	3419b5a2 <CMW_CAMERA_Probe_Sensor+0x56>
  }
#endif
  else
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419b59e:	f06f 0306 	mvn.w	r3, #6
  }
}
3419b5a2:	4618      	mov	r0, r3
3419b5a4:	3710      	adds	r7, #16
3419b5a6:	46bd      	mov	sp, r7
3419b5a8:	bd80      	pop	{r7, pc}
	...

3419b5ac <CMW_CAMERA_Init>:
  * @param  initConf  Mandatory: General camera config
  * @param  sensor_config  Optional: Sensor specific configuration
  * @retval CMW status
  */
int32_t CMW_CAMERA_Init(CMW_CameraInit_t *initConf, CMW_Sensor_Config_t *sensor_config)
{
3419b5ac:	b5b0      	push	{r4, r5, r7, lr}
3419b5ae:	b098      	sub	sp, #96	@ 0x60
3419b5b0:	af00      	add	r7, sp, #0
3419b5b2:	6078      	str	r0, [r7, #4]
3419b5b4:	6039      	str	r1, [r7, #0]
  int32_t ret = CMW_ERROR_NONE;
3419b5b6:	2300      	movs	r3, #0
3419b5b8:	65fb      	str	r3, [r7, #92]	@ 0x5c
  CMW_Sensor_Init_t initValues = {0};
3419b5ba:	f107 0344 	add.w	r3, r7, #68	@ 0x44
3419b5be:	2200      	movs	r2, #0
3419b5c0:	601a      	str	r2, [r3, #0]
3419b5c2:	605a      	str	r2, [r3, #4]
3419b5c4:	609a      	str	r2, [r3, #8]
3419b5c6:	60da      	str	r2, [r3, #12]
3419b5c8:	611a      	str	r2, [r3, #16]
3419b5ca:	615a      	str	r2, [r3, #20]
  ISP_SensorInfoTypeDef info = {0};
3419b5cc:	f107 0308 	add.w	r3, r7, #8
3419b5d0:	223c      	movs	r2, #60	@ 0x3c
3419b5d2:	2100      	movs	r1, #0
3419b5d4:	4618      	mov	r0, r3
3419b5d6:	f009 ff8b 	bl	341a54f0 <memset>

  initValues.width = initConf->width;
3419b5da:	687b      	ldr	r3, [r7, #4]
3419b5dc:	681b      	ldr	r3, [r3, #0]
3419b5de:	647b      	str	r3, [r7, #68]	@ 0x44
  initValues.height = initConf->height;
3419b5e0:	687b      	ldr	r3, [r7, #4]
3419b5e2:	685b      	ldr	r3, [r3, #4]
3419b5e4:	64bb      	str	r3, [r7, #72]	@ 0x48
  initValues.fps = initConf->fps;
3419b5e6:	687b      	ldr	r3, [r7, #4]
3419b5e8:	689b      	ldr	r3, [r3, #8]
3419b5ea:	64fb      	str	r3, [r7, #76]	@ 0x4c
  initValues.pixel_format = initConf->pixel_format;
3419b5ec:	687b      	ldr	r3, [r7, #4]
3419b5ee:	68db      	ldr	r3, [r3, #12]
3419b5f0:	653b      	str	r3, [r7, #80]	@ 0x50
  initValues.mirrorFlip = initConf->mirror_flip;
3419b5f2:	687b      	ldr	r3, [r7, #4]
3419b5f4:	695b      	ldr	r3, [r3, #20]
3419b5f6:	657b      	str	r3, [r7, #84]	@ 0x54

  if ((sensor_config != NULL) && (sensor_config->selected_sensor != CMW_NOTKNOWN_Sensor))
3419b5f8:	683b      	ldr	r3, [r7, #0]
3419b5fa:	2b00      	cmp	r3, #0
3419b5fc:	d00b      	beq.n	3419b616 <CMW_CAMERA_Init+0x6a>
3419b5fe:	683b      	ldr	r3, [r7, #0]
3419b600:	781b      	ldrb	r3, [r3, #0]
3419b602:	2b00      	cmp	r3, #0
3419b604:	d007      	beq.n	3419b616 <CMW_CAMERA_Init+0x6a>
  {
    connected_sensor = sensor_config->selected_sensor; // Assume The sensor is the one selected by the application. Check during probe
3419b606:	683b      	ldr	r3, [r7, #0]
3419b608:	781a      	ldrb	r2, [r3, #0]
3419b60a:	4b3a      	ldr	r3, [pc, #232]	@ (3419b6f4 <CMW_CAMERA_Init+0x148>)
3419b60c:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = (void *) &sensor_config->config;
3419b60e:	683b      	ldr	r3, [r7, #0]
3419b610:	3304      	adds	r3, #4
3419b612:	65bb      	str	r3, [r7, #88]	@ 0x58
3419b614:	e004      	b.n	3419b620 <CMW_CAMERA_Init+0x74>
  }
  else
  {
    connected_sensor = CMW_NOTKNOWN_Sensor;
3419b616:	4b37      	ldr	r3, [pc, #220]	@ (3419b6f4 <CMW_CAMERA_Init+0x148>)
3419b618:	2200      	movs	r2, #0
3419b61a:	701a      	strb	r2, [r3, #0]
    initValues.sensor_config = NULL;
3419b61c:	2300      	movs	r3, #0
3419b61e:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Set DCMIPP instance */
  hcamera_dcmipp.Instance = DCMIPP;
3419b620:	4b35      	ldr	r3, [pc, #212]	@ (3419b6f8 <CMW_CAMERA_Init+0x14c>)
3419b622:	4a36      	ldr	r2, [pc, #216]	@ (3419b6fc <CMW_CAMERA_Init+0x150>)
3419b624:	601a      	str	r2, [r3, #0]

  /* Configure DCMIPP clock */
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
3419b626:	4834      	ldr	r0, [pc, #208]	@ (3419b6f8 <CMW_CAMERA_Init+0x14c>)
3419b628:	f000 f8ae 	bl	3419b788 <MX_DCMIPP_ClockConfig>
3419b62c:	4603      	mov	r3, r0
3419b62e:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3419b630:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b632:	2b00      	cmp	r3, #0
3419b634:	d002      	beq.n	3419b63c <CMW_CAMERA_Init+0x90>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419b636:	f06f 0303 	mvn.w	r3, #3
3419b63a:	e056      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }
  /* Enable DCMIPP clock */
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
3419b63c:	482e      	ldr	r0, [pc, #184]	@ (3419b6f8 <CMW_CAMERA_Init+0x14c>)
3419b63e:	f7eb f90f 	bl	34186860 <HAL_DCMIPP_Init>
3419b642:	4603      	mov	r3, r0
3419b644:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3419b646:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b648:	2b00      	cmp	r3, #0
3419b64a:	d002      	beq.n	3419b652 <CMW_CAMERA_Init+0xa6>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419b64c:	f06f 0303 	mvn.w	r3, #3
3419b650:	e04b      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }

  CMW_CAMERA_EnableGPIOs();
3419b652:	f000 f949 	bl	3419b8e8 <CMW_CAMERA_EnableGPIOs>

  ret = CMW_CAMERA_Probe_Sensor(&initValues, &connected_sensor);
3419b656:	f107 0344 	add.w	r3, r7, #68	@ 0x44
3419b65a:	4926      	ldr	r1, [pc, #152]	@ (3419b6f4 <CMW_CAMERA_Init+0x148>)
3419b65c:	4618      	mov	r0, r3
3419b65e:	f7ff ff75 	bl	3419b54c <CMW_CAMERA_Probe_Sensor>
3419b662:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret != CMW_ERROR_NONE)
3419b664:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b666:	2b00      	cmp	r3, #0
3419b668:	d002      	beq.n	3419b670 <CMW_CAMERA_Init+0xc4>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419b66a:	f06f 0306 	mvn.w	r3, #6
3419b66e:	e03c      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }

  /* Configure exposure and gain for a more suitable quality */
  ret = CMW_CAMERA_GetSensorInfo(&info);
3419b670:	f107 0308 	add.w	r3, r7, #8
3419b674:	4618      	mov	r0, r3
3419b676:	f000 f903 	bl	3419b880 <CMW_CAMERA_GetSensorInfo>
3419b67a:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419b67c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b67e:	f113 0f05 	cmn.w	r3, #5
3419b682:	d102      	bne.n	3419b68a <CMW_CAMERA_Init+0xde>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419b684:	f06f 0306 	mvn.w	r3, #6
3419b688:	e02f      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
3419b68a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3419b68c:	4618      	mov	r0, r3
3419b68e:	f000 f8bf 	bl	3419b810 <CMW_CAMERA_SetExposure>
3419b692:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419b694:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b696:	f113 0f05 	cmn.w	r3, #5
3419b69a:	d102      	bne.n	3419b6a2 <CMW_CAMERA_Init+0xf6>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419b69c:	f06f 0306 	mvn.w	r3, #6
3419b6a0:	e023      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }
  ret = CMW_CAMERA_SetGain(info.gain_min);
3419b6a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3419b6a4:	4618      	mov	r0, r3
3419b6a6:	f000 f87b 	bl	3419b7a0 <CMW_CAMERA_SetGain>
3419b6aa:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3419b6ac:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419b6ae:	f113 0f05 	cmn.w	r3, #5
3419b6b2:	d102      	bne.n	3419b6ba <CMW_CAMERA_Init+0x10e>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3419b6b4:	f06f 0306 	mvn.w	r3, #6
3419b6b8:	e017      	b.n	3419b6ea <CMW_CAMERA_Init+0x13e>
  }

  /* Write back the initValue width and height that might be changed */
  initConf->width = initValues.width;
3419b6ba:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419b6bc:	687b      	ldr	r3, [r7, #4]
3419b6be:	601a      	str	r2, [r3, #0]
  initConf->height = initValues.height ;
3419b6c0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3419b6c2:	687b      	ldr	r3, [r7, #4]
3419b6c4:	605a      	str	r2, [r3, #4]
  camera_conf = *initConf;
3419b6c6:	4a0e      	ldr	r2, [pc, #56]	@ (3419b700 <CMW_CAMERA_Init+0x154>)
3419b6c8:	687b      	ldr	r3, [r7, #4]
3419b6ca:	4614      	mov	r4, r2
3419b6cc:	461d      	mov	r5, r3
3419b6ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419b6d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419b6d2:	e895 0003 	ldmia.w	r5, {r0, r1}
3419b6d6:	e884 0003 	stmia.w	r4, {r0, r1}

  is_camera_init++;
3419b6da:	4b0a      	ldr	r3, [pc, #40]	@ (3419b704 <CMW_CAMERA_Init+0x158>)
3419b6dc:	681b      	ldr	r3, [r3, #0]
3419b6de:	3301      	adds	r3, #1
3419b6e0:	4a08      	ldr	r2, [pc, #32]	@ (3419b704 <CMW_CAMERA_Init+0x158>)
3419b6e2:	6013      	str	r3, [r2, #0]
  /* CMW status */
  ret = CMW_ERROR_NONE;
3419b6e4:	2300      	movs	r3, #0
3419b6e6:	65fb      	str	r3, [r7, #92]	@ 0x5c
  return ret;
3419b6e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
3419b6ea:	4618      	mov	r0, r3
3419b6ec:	3760      	adds	r7, #96	@ 0x60
3419b6ee:	46bd      	mov	sp, r7
3419b6f0:	bdb0      	pop	{r4, r5, r7, pc}
3419b6f2:	bf00      	nop
3419b6f4:	341c1980 	.word	0x341c1980
3419b6f8:	341c19c4 	.word	0x341c19c4
3419b6fc:	58002000 	.word	0x58002000
3419b700:	341c1968 	.word	0x341c1968
3419b704:	341c1b78 	.word	0x341c1b78

3419b708 <CMW_CAMERA_Start>:
  * @param  pbuff pointer to the camera output buffer
  * @param  mode  CMW_MODE_CONTINUOUS or CMW_MODE_SNAPSHOT
  * @retval CMW status
  */
int32_t CMW_CAMERA_Start(uint32_t pipe, uint8_t *pbuff, uint32_t mode)
{
3419b708:	b580      	push	{r7, lr}
3419b70a:	b088      	sub	sp, #32
3419b70c:	af02      	add	r7, sp, #8
3419b70e:	60f8      	str	r0, [r7, #12]
3419b710:	60b9      	str	r1, [r7, #8]
3419b712:	607a      	str	r2, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419b714:	2300      	movs	r3, #0
3419b716:	617b      	str	r3, [r7, #20]

  if (pipe >= DCMIPP_NUM_OF_PIPES)
3419b718:	68fb      	ldr	r3, [r7, #12]
3419b71a:	2b02      	cmp	r3, #2
3419b71c:	d902      	bls.n	3419b724 <CMW_CAMERA_Start+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3419b71e:	f06f 0301 	mvn.w	r3, #1
3419b722:	e025      	b.n	3419b770 <CMW_CAMERA_Start+0x68>
  }

  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
3419b724:	68ba      	ldr	r2, [r7, #8]
3419b726:	687b      	ldr	r3, [r7, #4]
3419b728:	9300      	str	r3, [sp, #0]
3419b72a:	4613      	mov	r3, r2
3419b72c:	2200      	movs	r2, #0
3419b72e:	68f9      	ldr	r1, [r7, #12]
3419b730:	4811      	ldr	r0, [pc, #68]	@ (3419b778 <CMW_CAMERA_Start+0x70>)
3419b732:	f7eb fb4b 	bl	34186dcc <HAL_DCMIPP_CSI_PIPE_Start>
3419b736:	4603      	mov	r3, r0
3419b738:	617b      	str	r3, [r7, #20]
  if (ret != HAL_OK)
3419b73a:	697b      	ldr	r3, [r7, #20]
3419b73c:	2b00      	cmp	r3, #0
3419b73e:	d002      	beq.n	3419b746 <CMW_CAMERA_Start+0x3e>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419b740:	f06f 0303 	mvn.w	r3, #3
3419b744:	e014      	b.n	3419b770 <CMW_CAMERA_Start+0x68>
  }

  if (!is_camera_started)
3419b746:	4b0d      	ldr	r3, [pc, #52]	@ (3419b77c <CMW_CAMERA_Start+0x74>)
3419b748:	681b      	ldr	r3, [r3, #0]
3419b74a:	2b00      	cmp	r3, #0
3419b74c:	d10f      	bne.n	3419b76e <CMW_CAMERA_Start+0x66>
  {
    ret = Camera_Drv.Start(&camera_bsp);
3419b74e:	4b0c      	ldr	r3, [pc, #48]	@ (3419b780 <CMW_CAMERA_Start+0x78>)
3419b750:	689b      	ldr	r3, [r3, #8]
3419b752:	480c      	ldr	r0, [pc, #48]	@ (3419b784 <CMW_CAMERA_Start+0x7c>)
3419b754:	4798      	blx	r3
3419b756:	6178      	str	r0, [r7, #20]
    if (ret != CMW_ERROR_NONE)
3419b758:	697b      	ldr	r3, [r7, #20]
3419b75a:	2b00      	cmp	r3, #0
3419b75c:	d002      	beq.n	3419b764 <CMW_CAMERA_Start+0x5c>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419b75e:	f06f 0304 	mvn.w	r3, #4
3419b762:	e005      	b.n	3419b770 <CMW_CAMERA_Start+0x68>
    }
    is_camera_started++;
3419b764:	4b05      	ldr	r3, [pc, #20]	@ (3419b77c <CMW_CAMERA_Start+0x74>)
3419b766:	681b      	ldr	r3, [r3, #0]
3419b768:	3301      	adds	r3, #1
3419b76a:	4a04      	ldr	r2, [pc, #16]	@ (3419b77c <CMW_CAMERA_Start+0x74>)
3419b76c:	6013      	str	r3, [r2, #0]
  }

  /* Return CMW status */
  return ret;
3419b76e:	697b      	ldr	r3, [r7, #20]
}
3419b770:	4618      	mov	r0, r3
3419b772:	3718      	adds	r7, #24
3419b774:	46bd      	mov	sp, r7
3419b776:	bd80      	pop	{r7, pc}
3419b778:	341c19c4 	.word	0x341c19c4
3419b77c:	341c1b7c 	.word	0x341c1b7c
3419b780:	341c19d0 	.word	0x341c19d0
3419b784:	341c1a38 	.word	0x341c1a38

3419b788 <MX_DCMIPP_ClockConfig>:
  * @param  hdcmipp  DCMIPP Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_DCMIPP_ClockConfig(DCMIPP_HandleTypeDef *hdcmipp)
{
3419b788:	b480      	push	{r7}
3419b78a:	b083      	sub	sp, #12
3419b78c:	af00      	add	r7, sp, #0
3419b78e:	6078      	str	r0, [r7, #4]
  UNUSED(hdcmipp);

  return HAL_OK;
3419b790:	2300      	movs	r3, #0
}
3419b792:	4618      	mov	r0, r3
3419b794:	370c      	adds	r7, #12
3419b796:	46bd      	mov	sp, r7
3419b798:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b79c:	4770      	bx	lr
	...

3419b7a0 <CMW_CAMERA_SetGain>:
  * @brief  Set the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_SetGain(int32_t Gain)
{
3419b7a0:	b580      	push	{r7, lr}
3419b7a2:	b084      	sub	sp, #16
3419b7a4:	af00      	add	r7, sp, #0
3419b7a6:	6078      	str	r0, [r7, #4]
  int ret;
  if(Camera_Drv.SetGain == NULL)
3419b7a8:	4b0d      	ldr	r3, [pc, #52]	@ (3419b7e0 <CMW_CAMERA_SetGain+0x40>)
3419b7aa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419b7ac:	2b00      	cmp	r3, #0
3419b7ae:	d102      	bne.n	3419b7b6 <CMW_CAMERA_SetGain+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419b7b0:	f06f 030a 	mvn.w	r3, #10
3419b7b4:	e00f      	b.n	3419b7d6 <CMW_CAMERA_SetGain+0x36>
  }

  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
3419b7b6:	4b0a      	ldr	r3, [pc, #40]	@ (3419b7e0 <CMW_CAMERA_SetGain+0x40>)
3419b7b8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3419b7ba:	6879      	ldr	r1, [r7, #4]
3419b7bc:	4809      	ldr	r0, [pc, #36]	@ (3419b7e4 <CMW_CAMERA_SetGain+0x44>)
3419b7be:	4798      	blx	r3
3419b7c0:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419b7c2:	68fb      	ldr	r3, [r7, #12]
3419b7c4:	2b00      	cmp	r3, #0
3419b7c6:	d002      	beq.n	3419b7ce <CMW_CAMERA_SetGain+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b7c8:	f06f 0304 	mvn.w	r3, #4
3419b7cc:	e003      	b.n	3419b7d6 <CMW_CAMERA_SetGain+0x36>
  }

  Camera_Ctx.Gain = Gain;
3419b7ce:	4a06      	ldr	r2, [pc, #24]	@ (3419b7e8 <CMW_CAMERA_SetGain+0x48>)
3419b7d0:	687b      	ldr	r3, [r7, #4]
3419b7d2:	6213      	str	r3, [r2, #32]
  return CMW_ERROR_NONE;
3419b7d4:	2300      	movs	r3, #0
}
3419b7d6:	4618      	mov	r0, r3
3419b7d8:	3710      	adds	r7, #16
3419b7da:	46bd      	mov	sp, r7
3419b7dc:	bd80      	pop	{r7, pc}
3419b7de:	bf00      	nop
3419b7e0:	341c19d0 	.word	0x341c19d0
3419b7e4:	341c1a38 	.word	0x341c1a38
3419b7e8:	341c1984 	.word	0x341c1984

3419b7ec <CMW_CAMERA_GetGain>:
  * @brief  Get the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
3419b7ec:	b480      	push	{r7}
3419b7ee:	b083      	sub	sp, #12
3419b7f0:	af00      	add	r7, sp, #0
3419b7f2:	6078      	str	r0, [r7, #4]
  *Gain = Camera_Ctx.Gain;
3419b7f4:	4b05      	ldr	r3, [pc, #20]	@ (3419b80c <CMW_CAMERA_GetGain+0x20>)
3419b7f6:	6a1a      	ldr	r2, [r3, #32]
3419b7f8:	687b      	ldr	r3, [r7, #4]
3419b7fa:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3419b7fc:	2300      	movs	r3, #0
}
3419b7fe:	4618      	mov	r0, r3
3419b800:	370c      	adds	r7, #12
3419b802:	46bd      	mov	sp, r7
3419b804:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b808:	4770      	bx	lr
3419b80a:	bf00      	nop
3419b80c:	341c1984 	.word	0x341c1984

3419b810 <CMW_CAMERA_SetExposure>:
  * @brief  Set the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_SetExposure(int32_t exposure)
{
3419b810:	b580      	push	{r7, lr}
3419b812:	b084      	sub	sp, #16
3419b814:	af00      	add	r7, sp, #0
3419b816:	6078      	str	r0, [r7, #4]
  int ret;

  if(Camera_Drv.SetExposure == NULL)
3419b818:	4b0d      	ldr	r3, [pc, #52]	@ (3419b850 <CMW_CAMERA_SetExposure+0x40>)
3419b81a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419b81c:	2b00      	cmp	r3, #0
3419b81e:	d102      	bne.n	3419b826 <CMW_CAMERA_SetExposure+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419b820:	f06f 030a 	mvn.w	r3, #10
3419b824:	e00f      	b.n	3419b846 <CMW_CAMERA_SetExposure+0x36>
  }

  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
3419b826:	4b0a      	ldr	r3, [pc, #40]	@ (3419b850 <CMW_CAMERA_SetExposure+0x40>)
3419b828:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3419b82a:	6879      	ldr	r1, [r7, #4]
3419b82c:	4809      	ldr	r0, [pc, #36]	@ (3419b854 <CMW_CAMERA_SetExposure+0x44>)
3419b82e:	4798      	blx	r3
3419b830:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419b832:	68fb      	ldr	r3, [r7, #12]
3419b834:	2b00      	cmp	r3, #0
3419b836:	d002      	beq.n	3419b83e <CMW_CAMERA_SetExposure+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b838:	f06f 0304 	mvn.w	r3, #4
3419b83c:	e003      	b.n	3419b846 <CMW_CAMERA_SetExposure+0x36>
  }

  Camera_Ctx.Exposure = exposure;
3419b83e:	4a06      	ldr	r2, [pc, #24]	@ (3419b858 <CMW_CAMERA_SetExposure+0x48>)
3419b840:	687b      	ldr	r3, [r7, #4]
3419b842:	6253      	str	r3, [r2, #36]	@ 0x24
  return CMW_ERROR_NONE;
3419b844:	2300      	movs	r3, #0
}
3419b846:	4618      	mov	r0, r3
3419b848:	3710      	adds	r7, #16
3419b84a:	46bd      	mov	sp, r7
3419b84c:	bd80      	pop	{r7, pc}
3419b84e:	bf00      	nop
3419b850:	341c19d0 	.word	0x341c19d0
3419b854:	341c1a38 	.word	0x341c1a38
3419b858:	341c1984 	.word	0x341c1984

3419b85c <CMW_CAMERA_GetExposure>:
  * @brief  Get the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_GetExposure(int32_t *exposure)
{
3419b85c:	b480      	push	{r7}
3419b85e:	b083      	sub	sp, #12
3419b860:	af00      	add	r7, sp, #0
3419b862:	6078      	str	r0, [r7, #4]
  *exposure = Camera_Ctx.Exposure;
3419b864:	4b05      	ldr	r3, [pc, #20]	@ (3419b87c <CMW_CAMERA_GetExposure+0x20>)
3419b866:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3419b868:	687b      	ldr	r3, [r7, #4]
3419b86a:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3419b86c:	2300      	movs	r3, #0
}
3419b86e:	4618      	mov	r0, r3
3419b870:	370c      	adds	r7, #12
3419b872:	46bd      	mov	sp, r7
3419b874:	f85d 7b04 	ldr.w	r7, [sp], #4
3419b878:	4770      	bx	lr
3419b87a:	bf00      	nop
3419b87c:	341c1984 	.word	0x341c1984

3419b880 <CMW_CAMERA_GetSensorInfo>:
  * @note   This function should be called after the init. This to get Capabilities
  *         from the camera sensor
  * @retval Component status
  */
int32_t CMW_CAMERA_GetSensorInfo(ISP_SensorInfoTypeDef *info)
{
3419b880:	b580      	push	{r7, lr}
3419b882:	b084      	sub	sp, #16
3419b884:	af00      	add	r7, sp, #0
3419b886:	6078      	str	r0, [r7, #4]

  int32_t ret;

  if(Camera_Drv.GetSensorInfo == NULL)
3419b888:	4b0b      	ldr	r3, [pc, #44]	@ (3419b8b8 <CMW_CAMERA_GetSensorInfo+0x38>)
3419b88a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419b88c:	2b00      	cmp	r3, #0
3419b88e:	d102      	bne.n	3419b896 <CMW_CAMERA_GetSensorInfo+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3419b890:	f06f 030a 	mvn.w	r3, #10
3419b894:	e00c      	b.n	3419b8b0 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
3419b896:	4b08      	ldr	r3, [pc, #32]	@ (3419b8b8 <CMW_CAMERA_GetSensorInfo+0x38>)
3419b898:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419b89a:	6879      	ldr	r1, [r7, #4]
3419b89c:	4807      	ldr	r0, [pc, #28]	@ (3419b8bc <CMW_CAMERA_GetSensorInfo+0x3c>)
3419b89e:	4798      	blx	r3
3419b8a0:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419b8a2:	68fb      	ldr	r3, [r7, #12]
3419b8a4:	2b00      	cmp	r3, #0
3419b8a6:	d002      	beq.n	3419b8ae <CMW_CAMERA_GetSensorInfo+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419b8a8:	f06f 0304 	mvn.w	r3, #4
3419b8ac:	e000      	b.n	3419b8b0 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  return CMW_ERROR_NONE;
3419b8ae:	2300      	movs	r3, #0
}
3419b8b0:	4618      	mov	r0, r3
3419b8b2:	3710      	adds	r7, #16
3419b8b4:	46bd      	mov	sp, r7
3419b8b6:	bd80      	pop	{r7, pc}
3419b8b8:	341c19d0 	.word	0x341c19d0
3419b8bc:	341c1a38 	.word	0x341c1a38

3419b8c0 <CMW_CAMERA_Run>:



int32_t CMW_CAMERA_Run()
{
3419b8c0:	b580      	push	{r7, lr}
3419b8c2:	af00      	add	r7, sp, #0
  if(Camera_Drv.Run != NULL)
3419b8c4:	4b06      	ldr	r3, [pc, #24]	@ (3419b8e0 <CMW_CAMERA_Run+0x20>)
3419b8c6:	68db      	ldr	r3, [r3, #12]
3419b8c8:	2b00      	cmp	r3, #0
3419b8ca:	d005      	beq.n	3419b8d8 <CMW_CAMERA_Run+0x18>
  {
      return Camera_Drv.Run(&camera_bsp);
3419b8cc:	4b04      	ldr	r3, [pc, #16]	@ (3419b8e0 <CMW_CAMERA_Run+0x20>)
3419b8ce:	68db      	ldr	r3, [r3, #12]
3419b8d0:	4804      	ldr	r0, [pc, #16]	@ (3419b8e4 <CMW_CAMERA_Run+0x24>)
3419b8d2:	4798      	blx	r3
3419b8d4:	4603      	mov	r3, r0
3419b8d6:	e000      	b.n	3419b8da <CMW_CAMERA_Run+0x1a>
  }
  return CMW_ERROR_NONE;
3419b8d8:	2300      	movs	r3, #0
}
3419b8da:	4618      	mov	r0, r3
3419b8dc:	bd80      	pop	{r7, pc}
3419b8de:	bf00      	nop
3419b8e0:	341c19d0 	.word	0x341c19d0
3419b8e4:	341c1a38 	.word	0x341c1a38

3419b8e8 <CMW_CAMERA_EnableGPIOs>:
/**
  * @brief  CAMERA hardware reset
  * @retval CMW status
  */
static void CMW_CAMERA_EnableGPIOs(void)
{
3419b8e8:	b580      	push	{r7, lr}
3419b8ea:	b086      	sub	sp, #24
3419b8ec:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef gpio_init_structure = {0};
3419b8ee:	1d3b      	adds	r3, r7, #4
3419b8f0:	2200      	movs	r2, #0
3419b8f2:	601a      	str	r2, [r3, #0]
3419b8f4:	605a      	str	r2, [r3, #4]
3419b8f6:	609a      	str	r2, [r3, #8]
3419b8f8:	60da      	str	r2, [r3, #12]
3419b8fa:	611a      	str	r2, [r3, #16]

  /* Enable GPIO clocks */
  EN_CAM_GPIO_ENABLE_VDDIO();
  EN_CAM_GPIO_CLK_ENABLE();
3419b8fc:	2008      	movs	r0, #8
3419b8fe:	f7ff fdfb 	bl	3419b4f8 <LL_AHB4_GRP1_EnableClock>
  NRST_CAM_GPIO_ENABLE_VDDIO();
3419b902:	f7f1 f811 	bl	3418c928 <HAL_PWREx_EnableVddIO4>
  NRST_CAM_GPIO_CLK_ENABLE();
3419b906:	2004      	movs	r0, #4
3419b908:	f7ff fdf6 	bl	3419b4f8 <LL_AHB4_GRP1_EnableClock>

  gpio_init_structure.Pin       = EN_CAM_PIN;
3419b90c:	2304      	movs	r3, #4
3419b90e:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3419b910:	2300      	movs	r3, #0
3419b912:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3419b914:	2301      	movs	r3, #1
3419b916:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3419b918:	2303      	movs	r3, #3
3419b91a:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3419b91c:	1d3b      	adds	r3, r7, #4
3419b91e:	4619      	mov	r1, r3
3419b920:	480a      	ldr	r0, [pc, #40]	@ (3419b94c <CMW_CAMERA_EnableGPIOs+0x64>)
3419b922:	f7ee fc0b 	bl	3418a13c <HAL_GPIO_Init>

  gpio_init_structure.Pin       = NRST_CAM_PIN;
3419b926:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419b92a:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3419b92c:	2300      	movs	r3, #0
3419b92e:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3419b930:	2301      	movs	r3, #1
3419b932:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3419b934:	2303      	movs	r3, #3
3419b936:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3419b938:	1d3b      	adds	r3, r7, #4
3419b93a:	4619      	mov	r1, r3
3419b93c:	4804      	ldr	r0, [pc, #16]	@ (3419b950 <CMW_CAMERA_EnableGPIOs+0x68>)
3419b93e:	f7ee fbfd 	bl	3418a13c <HAL_GPIO_Init>
}
3419b942:	bf00      	nop
3419b944:	3718      	adds	r7, #24
3419b946:	46bd      	mov	sp, r7
3419b948:	bd80      	pop	{r7, pc}
3419b94a:	bf00      	nop
3419b94c:	56020c00 	.word	0x56020c00
3419b950:	56020800 	.word	0x56020800

3419b954 <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, GPIO_PIN_RESET);

}

static void CMW_CAMERA_ShutdownPin(int value)
{
3419b954:	b580      	push	{r7, lr}
3419b956:	b082      	sub	sp, #8
3419b958:	af00      	add	r7, sp, #0
3419b95a:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3419b95c:	687b      	ldr	r3, [r7, #4]
3419b95e:	2b00      	cmp	r3, #0
3419b960:	bf14      	ite	ne
3419b962:	2301      	movne	r3, #1
3419b964:	2300      	moveq	r3, #0
3419b966:	b2db      	uxtb	r3, r3
3419b968:	461a      	mov	r2, r3
3419b96a:	f44f 7180 	mov.w	r1, #256	@ 0x100
3419b96e:	4803      	ldr	r0, [pc, #12]	@ (3419b97c <CMW_CAMERA_ShutdownPin+0x28>)
3419b970:	f7ee fed6 	bl	3418a720 <HAL_GPIO_WritePin>
}
3419b974:	bf00      	nop
3419b976:	3708      	adds	r7, #8
3419b978:	46bd      	mov	sp, r7
3419b97a:	bd80      	pop	{r7, pc}
3419b97c:	56020800 	.word	0x56020800

3419b980 <CMW_CAMERA_EnablePin>:

static void CMW_CAMERA_EnablePin(int value)
{
3419b980:	b580      	push	{r7, lr}
3419b982:	b082      	sub	sp, #8
3419b984:	af00      	add	r7, sp, #0
3419b986:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3419b988:	687b      	ldr	r3, [r7, #4]
3419b98a:	2b00      	cmp	r3, #0
3419b98c:	bf14      	ite	ne
3419b98e:	2301      	movne	r3, #1
3419b990:	2300      	moveq	r3, #0
3419b992:	b2db      	uxtb	r3, r3
3419b994:	461a      	mov	r2, r3
3419b996:	2104      	movs	r1, #4
3419b998:	4803      	ldr	r0, [pc, #12]	@ (3419b9a8 <CMW_CAMERA_EnablePin+0x28>)
3419b99a:	f7ee fec1 	bl	3418a720 <HAL_GPIO_WritePin>
}
3419b99e:	bf00      	nop
3419b9a0:	3708      	adds	r7, #8
3419b9a2:	46bd      	mov	sp, r7
3419b9a4:	bd80      	pop	{r7, pc}
3419b9a6:	bf00      	nop
3419b9a8:	56020c00 	.word	0x56020c00

3419b9ac <CB_ISP_SetSensorGain>:

#if defined(USE_VD66GY_SENSOR) || defined(USE_IMX335_SENSOR)
static ISP_StatusTypeDef CB_ISP_SetSensorGain(uint32_t camera_instance, int32_t gain)
{
3419b9ac:	b580      	push	{r7, lr}
3419b9ae:	b082      	sub	sp, #8
3419b9b0:	af00      	add	r7, sp, #0
3419b9b2:	6078      	str	r0, [r7, #4]
3419b9b4:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
3419b9b6:	6838      	ldr	r0, [r7, #0]
3419b9b8:	f7ff fef2 	bl	3419b7a0 <CMW_CAMERA_SetGain>
3419b9bc:	4603      	mov	r3, r0
3419b9be:	2b00      	cmp	r3, #0
3419b9c0:	d001      	beq.n	3419b9c6 <CB_ISP_SetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3419b9c2:	2379      	movs	r3, #121	@ 0x79
3419b9c4:	e000      	b.n	3419b9c8 <CB_ISP_SetSensorGain+0x1c>

  return ISP_OK;
3419b9c6:	2300      	movs	r3, #0
}
3419b9c8:	4618      	mov	r0, r3
3419b9ca:	3708      	adds	r7, #8
3419b9cc:	46bd      	mov	sp, r7
3419b9ce:	bd80      	pop	{r7, pc}

3419b9d0 <CB_ISP_GetSensorGain>:

static ISP_StatusTypeDef CB_ISP_GetSensorGain(uint32_t camera_instance, int32_t *gain)
{
3419b9d0:	b580      	push	{r7, lr}
3419b9d2:	b082      	sub	sp, #8
3419b9d4:	af00      	add	r7, sp, #0
3419b9d6:	6078      	str	r0, [r7, #4]
3419b9d8:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
3419b9da:	6838      	ldr	r0, [r7, #0]
3419b9dc:	f7ff ff06 	bl	3419b7ec <CMW_CAMERA_GetGain>
3419b9e0:	4603      	mov	r3, r0
3419b9e2:	2b00      	cmp	r3, #0
3419b9e4:	d001      	beq.n	3419b9ea <CB_ISP_GetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3419b9e6:	2379      	movs	r3, #121	@ 0x79
3419b9e8:	e000      	b.n	3419b9ec <CB_ISP_GetSensorGain+0x1c>

  return ISP_OK;
3419b9ea:	2300      	movs	r3, #0
}
3419b9ec:	4618      	mov	r0, r3
3419b9ee:	3708      	adds	r7, #8
3419b9f0:	46bd      	mov	sp, r7
3419b9f2:	bd80      	pop	{r7, pc}

3419b9f4 <CB_ISP_SetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_SetSensorExposure(uint32_t camera_instance, int32_t exposure)
{
3419b9f4:	b580      	push	{r7, lr}
3419b9f6:	b082      	sub	sp, #8
3419b9f8:	af00      	add	r7, sp, #0
3419b9fa:	6078      	str	r0, [r7, #4]
3419b9fc:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3419b9fe:	6838      	ldr	r0, [r7, #0]
3419ba00:	f7ff ff06 	bl	3419b810 <CMW_CAMERA_SetExposure>
3419ba04:	4603      	mov	r3, r0
3419ba06:	2b00      	cmp	r3, #0
3419ba08:	d001      	beq.n	3419ba0e <CB_ISP_SetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3419ba0a:	2383      	movs	r3, #131	@ 0x83
3419ba0c:	e000      	b.n	3419ba10 <CB_ISP_SetSensorExposure+0x1c>

  return ISP_OK;
3419ba0e:	2300      	movs	r3, #0
}
3419ba10:	4618      	mov	r0, r3
3419ba12:	3708      	adds	r7, #8
3419ba14:	46bd      	mov	sp, r7
3419ba16:	bd80      	pop	{r7, pc}

3419ba18 <CB_ISP_GetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_GetSensorExposure(uint32_t camera_instance, int32_t *exposure)
{
3419ba18:	b580      	push	{r7, lr}
3419ba1a:	b082      	sub	sp, #8
3419ba1c:	af00      	add	r7, sp, #0
3419ba1e:	6078      	str	r0, [r7, #4]
3419ba20:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
3419ba22:	6838      	ldr	r0, [r7, #0]
3419ba24:	f7ff ff1a 	bl	3419b85c <CMW_CAMERA_GetExposure>
3419ba28:	4603      	mov	r3, r0
3419ba2a:	2b00      	cmp	r3, #0
3419ba2c:	d001      	beq.n	3419ba32 <CB_ISP_GetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3419ba2e:	2383      	movs	r3, #131	@ 0x83
3419ba30:	e000      	b.n	3419ba34 <CB_ISP_GetSensorExposure+0x1c>

  return ISP_OK;
3419ba32:	2300      	movs	r3, #0
}
3419ba34:	4618      	mov	r0, r3
3419ba36:	3708      	adds	r7, #8
3419ba38:	46bd      	mov	sp, r7
3419ba3a:	bd80      	pop	{r7, pc}

3419ba3c <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
3419ba3c:	b580      	push	{r7, lr}
3419ba3e:	b082      	sub	sp, #8
3419ba40:	af00      	add	r7, sp, #0
3419ba42:	6078      	str	r0, [r7, #4]
3419ba44:	6039      	str	r1, [r7, #0]
  if(Camera_Drv.GetSensorInfo != NULL)
3419ba46:	4b09      	ldr	r3, [pc, #36]	@ (3419ba6c <CB_ISP_GetSensorInfo+0x30>)
3419ba48:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419ba4a:	2b00      	cmp	r3, #0
3419ba4c:	d009      	beq.n	3419ba62 <CB_ISP_GetSensorInfo+0x26>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
3419ba4e:	4b07      	ldr	r3, [pc, #28]	@ (3419ba6c <CB_ISP_GetSensorInfo+0x30>)
3419ba50:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419ba52:	6839      	ldr	r1, [r7, #0]
3419ba54:	4806      	ldr	r0, [pc, #24]	@ (3419ba70 <CB_ISP_GetSensorInfo+0x34>)
3419ba56:	4798      	blx	r3
3419ba58:	4603      	mov	r3, r0
3419ba5a:	2b00      	cmp	r3, #0
3419ba5c:	d001      	beq.n	3419ba62 <CB_ISP_GetSensorInfo+0x26>
      return ISP_ERR_SENSOREXPOSURE;
3419ba5e:	2383      	movs	r3, #131	@ 0x83
3419ba60:	e000      	b.n	3419ba64 <CB_ISP_GetSensorInfo+0x28>
  }
  return ISP_OK;
3419ba62:	2300      	movs	r3, #0
}
3419ba64:	4618      	mov	r0, r3
3419ba66:	3708      	adds	r7, #8
3419ba68:	46bd      	mov	sp, r7
3419ba6a:	bd80      	pop	{r7, pc}
3419ba6c:	341c19d0 	.word	0x341c19d0
3419ba70:	341c1a38 	.word	0x341c1a38

3419ba74 <CMW_CAMERA_VD55G1_Init>:
#endif

#if defined(USE_VD55G1_SENSOR)
static int32_t CMW_CAMERA_VD55G1_Init( CMW_Sensor_Init_t *initSensors_params)
{
3419ba74:	b580      	push	{r7, lr}
3419ba76:	b09a      	sub	sp, #104	@ 0x68
3419ba78:	af00      	add	r7, sp, #0
3419ba7a:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419ba7c:	2300      	movs	r3, #0
3419ba7e:	663b      	str	r3, [r7, #96]	@ 0x60
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419ba80:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419ba84:	2200      	movs	r2, #0
3419ba86:	601a      	str	r2, [r3, #0]
3419ba88:	605a      	str	r2, [r3, #4]
3419ba8a:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419ba8c:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419ba90:	2200      	movs	r2, #0
3419ba92:	601a      	str	r2, [r3, #0]
3419ba94:	605a      	str	r2, [r3, #4]
3419ba96:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419ba98:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419ba9c:	2100      	movs	r1, #0
3419ba9e:	484d      	ldr	r0, [pc, #308]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419baa0:	f009 fd26 	bl	341a54f0 <memset>
  camera_bsp.vd55g1_bsp.Address     = CAMERA_VD55G1_ADDRESS;
3419baa4:	4b4b      	ldr	r3, [pc, #300]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419baa6:	2220      	movs	r2, #32
3419baa8:	801a      	strh	r2, [r3, #0]
  camera_bsp.vd55g1_bsp.Init        = CMW_I2C_INIT;
3419baaa:	4b4a      	ldr	r3, [pc, #296]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419baac:	4a4a      	ldr	r2, [pc, #296]	@ (3419bbd8 <CMW_CAMERA_VD55G1_Init+0x164>)
3419baae:	671a      	str	r2, [r3, #112]	@ 0x70
  camera_bsp.vd55g1_bsp.DeInit      = CMW_I2C_DEINIT;
3419bab0:	4b48      	ldr	r3, [pc, #288]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bab2:	4a4a      	ldr	r2, [pc, #296]	@ (3419bbdc <CMW_CAMERA_VD55G1_Init+0x168>)
3419bab4:	675a      	str	r2, [r3, #116]	@ 0x74
  camera_bsp.vd55g1_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419bab6:	4b47      	ldr	r3, [pc, #284]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bab8:	4a49      	ldr	r2, [pc, #292]	@ (3419bbe0 <CMW_CAMERA_VD55G1_Init+0x16c>)
3419baba:	679a      	str	r2, [r3, #120]	@ 0x78
  camera_bsp.vd55g1_bsp.ReadReg     = CMW_I2C_READREG16;
3419babc:	4b45      	ldr	r3, [pc, #276]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419babe:	4a49      	ldr	r2, [pc, #292]	@ (3419bbe4 <CMW_CAMERA_VD55G1_Init+0x170>)
3419bac0:	67da      	str	r2, [r3, #124]	@ 0x7c
  camera_bsp.vd55g1_bsp.Delay       = HAL_Delay;
3419bac2:	4b44      	ldr	r3, [pc, #272]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bac4:	4a48      	ldr	r2, [pc, #288]	@ (3419bbe8 <CMW_CAMERA_VD55G1_Init+0x174>)
3419bac6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  camera_bsp.vd55g1_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419baca:	4b42      	ldr	r3, [pc, #264]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bacc:	4a47      	ldr	r2, [pc, #284]	@ (3419bbec <CMW_CAMERA_VD55G1_Init+0x178>)
3419bace:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  camera_bsp.vd55g1_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419bad2:	4b40      	ldr	r3, [pc, #256]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bad4:	4a46      	ldr	r2, [pc, #280]	@ (3419bbf0 <CMW_CAMERA_VD55G1_Init+0x17c>)
3419bad6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

  ret = CMW_VD55G1_Probe(&camera_bsp.vd55g1_bsp, &Camera_Drv);
3419bada:	4946      	ldr	r1, [pc, #280]	@ (3419bbf4 <CMW_CAMERA_VD55G1_Init+0x180>)
3419badc:	483d      	ldr	r0, [pc, #244]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bade:	f001 fce9 	bl	3419d4b4 <CMW_VD55G1_Probe>
3419bae2:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419bae4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bae6:	2b00      	cmp	r3, #0
3419bae8:	d002      	beq.n	3419baf0 <CMW_CAMERA_VD55G1_Init+0x7c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419baea:	f06f 0304 	mvn.w	r3, #4
3419baee:	e06c      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  }

  if ((connected_sensor != CMW_VD55G1_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419baf0:	4b41      	ldr	r3, [pc, #260]	@ (3419bbf8 <CMW_CAMERA_VD55G1_Init+0x184>)
3419baf2:	781b      	ldrb	r3, [r3, #0]
3419baf4:	2b03      	cmp	r3, #3
3419baf6:	d006      	beq.n	3419bb06 <CMW_CAMERA_VD55G1_Init+0x92>
3419baf8:	4b3f      	ldr	r3, [pc, #252]	@ (3419bbf8 <CMW_CAMERA_VD55G1_Init+0x184>)
3419bafa:	781b      	ldrb	r3, [r3, #0]
3419bafc:	2b00      	cmp	r3, #0
3419bafe:	d002      	beq.n	3419bb06 <CMW_CAMERA_VD55G1_Init+0x92>
  {
    /* If the selected sensor in the application side has selected a different sensors than VD55G1 */
    return CMW_ERROR_COMPONENT_FAILURE;
3419bb00:	f06f 0304 	mvn.w	r3, #4
3419bb04:	e061      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419bb06:	687b      	ldr	r3, [r7, #4]
3419bb08:	681b      	ldr	r3, [r3, #0]
3419bb0a:	2b00      	cmp	r3, #0
3419bb0c:	d003      	beq.n	3419bb16 <CMW_CAMERA_VD55G1_Init+0xa2>
3419bb0e:	687b      	ldr	r3, [r7, #4]
3419bb10:	685b      	ldr	r3, [r3, #4]
3419bb12:	2b00      	cmp	r3, #0
3419bb14:	d10c      	bne.n	3419bb30 <CMW_CAMERA_VD55G1_Init+0xbc>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419bb16:	4b37      	ldr	r3, [pc, #220]	@ (3419bbf4 <CMW_CAMERA_VD55G1_Init+0x180>)
3419bb18:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419bb1a:	f107 020c 	add.w	r2, r7, #12
3419bb1e:	4611      	mov	r1, r2
3419bb20:	482c      	ldr	r0, [pc, #176]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bb22:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419bb24:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419bb26:	687b      	ldr	r3, [r7, #4]
3419bb28:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419bb2a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419bb2c:	687b      	ldr	r3, [r7, #4]
3419bb2e:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419bb30:	4b30      	ldr	r3, [pc, #192]	@ (3419bbf4 <CMW_CAMERA_VD55G1_Init+0x180>)
3419bb32:	681b      	ldr	r3, [r3, #0]
3419bb34:	6879      	ldr	r1, [r7, #4]
3419bb36:	4827      	ldr	r0, [pc, #156]	@ (3419bbd4 <CMW_CAMERA_VD55G1_Init+0x160>)
3419bb38:	4798      	blx	r3
3419bb3a:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419bb3c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bb3e:	2b00      	cmp	r3, #0
3419bb40:	d002      	beq.n	3419bb48 <CMW_CAMERA_VD55G1_Init+0xd4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419bb42:	f06f 0304 	mvn.w	r3, #4
3419bb46:	e040      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
3419bb48:	f44f 7380 	mov.w	r3, #256	@ 0x100
3419bb4c:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419bb4e:	2301      	movs	r3, #1
3419bb50:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3419bb52:	231c      	movs	r3, #28
3419bb54:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419bb56:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419bb5a:	4619      	mov	r1, r3
3419bb5c:	4827      	ldr	r0, [pc, #156]	@ (3419bbfc <CMW_CAMERA_VD55G1_Init+0x188>)
3419bb5e:	f7ea fead 	bl	341868bc <HAL_DCMIPP_CSI_SetConfig>
3419bb62:	4603      	mov	r3, r0
3419bb64:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419bb66:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bb68:	2b00      	cmp	r3, #0
3419bb6a:	d002      	beq.n	3419bb72 <CMW_CAMERA_VD55G1_Init+0xfe>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bb6c:	f06f 0303 	mvn.w	r3, #3
3419bb70:	e02b      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3419bb72:	2202      	movs	r2, #2
3419bb74:	2100      	movs	r1, #0
3419bb76:	4821      	ldr	r0, [pc, #132]	@ (3419bbfc <CMW_CAMERA_VD55G1_Init+0x188>)
3419bb78:	f7eb f8a4 	bl	34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>
3419bb7c:	4603      	mov	r3, r0
3419bb7e:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419bb80:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bb82:	2b00      	cmp	r3, #0
3419bb84:	d002      	beq.n	3419bb8c <CMW_CAMERA_VD55G1_Init+0x118>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bb86:	f06f 0303 	mvn.w	r3, #3
3419bb8a:	e01e      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419bb8c:	2300      	movs	r3, #0
3419bb8e:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
3419bb90:	232a      	movs	r3, #42	@ 0x2a
3419bb92:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419bb94:	2300      	movs	r3, #0
3419bb96:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bb98:	2300      	movs	r3, #0
3419bb9a:	667b      	str	r3, [r7, #100]	@ 0x64
3419bb9c:	e011      	b.n	3419bbc2 <CMW_CAMERA_VD55G1_Init+0x14e>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419bb9e:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419bba2:	461a      	mov	r2, r3
3419bba4:	6e79      	ldr	r1, [r7, #100]	@ 0x64
3419bba6:	4815      	ldr	r0, [pc, #84]	@ (3419bbfc <CMW_CAMERA_VD55G1_Init+0x188>)
3419bba8:	f7ea ffec 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419bbac:	4603      	mov	r3, r0
3419bbae:	663b      	str	r3, [r7, #96]	@ 0x60
    if (ret != HAL_OK)
3419bbb0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bbb2:	2b00      	cmp	r3, #0
3419bbb4:	d002      	beq.n	3419bbbc <CMW_CAMERA_VD55G1_Init+0x148>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419bbb6:	f06f 0303 	mvn.w	r3, #3
3419bbba:	e006      	b.n	3419bbca <CMW_CAMERA_VD55G1_Init+0x156>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bbbc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bbbe:	3301      	adds	r3, #1
3419bbc0:	667b      	str	r3, [r7, #100]	@ 0x64
3419bbc2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bbc4:	2b02      	cmp	r3, #2
3419bbc6:	d9ea      	bls.n	3419bb9e <CMW_CAMERA_VD55G1_Init+0x12a>
    }
  }

  return CMW_ERROR_NONE;
3419bbc8:	2300      	movs	r3, #0
}
3419bbca:	4618      	mov	r0, r3
3419bbcc:	3768      	adds	r7, #104	@ 0x68
3419bbce:	46bd      	mov	sp, r7
3419bbd0:	bd80      	pop	{r7, pc}
3419bbd2:	bf00      	nop
3419bbd4:	341c1a38 	.word	0x341c1a38
3419bbd8:	34183bc9 	.word	0x34183bc9
3419bbdc:	34183c3d 	.word	0x34183c3d
3419bbe0:	34183d09 	.word	0x34183d09
3419bbe4:	34183d65 	.word	0x34183d65
3419bbe8:	34186529 	.word	0x34186529
3419bbec:	3419b955 	.word	0x3419b955
3419bbf0:	3419b981 	.word	0x3419b981
3419bbf4:	341c19d0 	.word	0x341c19d0
3419bbf8:	341c1980 	.word	0x341c1980
3419bbfc:	341c19c4 	.word	0x341c19c4

3419bc00 <CMW_CAMERA_VD66GY_Init>:
#endif

#if defined(USE_VD66GY_SENSOR)
static int32_t CMW_CAMERA_VD66GY_Init( CMW_Sensor_Init_t *initSensors_params)
{
3419bc00:	b580      	push	{r7, lr}
3419bc02:	b09a      	sub	sp, #104	@ 0x68
3419bc04:	af00      	add	r7, sp, #0
3419bc06:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419bc08:	2300      	movs	r3, #0
3419bc0a:	663b      	str	r3, [r7, #96]	@ 0x60
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419bc0c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419bc10:	2200      	movs	r2, #0
3419bc12:	601a      	str	r2, [r3, #0]
3419bc14:	605a      	str	r2, [r3, #4]
3419bc16:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419bc18:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419bc1c:	2200      	movs	r2, #0
3419bc1e:	601a      	str	r2, [r3, #0]
3419bc20:	605a      	str	r2, [r3, #4]
3419bc22:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419bc24:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419bc28:	2100      	movs	r1, #0
3419bc2a:	485b      	ldr	r0, [pc, #364]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc2c:	f009 fc60 	bl	341a54f0 <memset>
  camera_bsp.vd66gy_bsp.Address     = CAMERA_VD66GY_ADDRESS;
3419bc30:	4b59      	ldr	r3, [pc, #356]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc32:	2220      	movs	r2, #32
3419bc34:	801a      	strh	r2, [r3, #0]
  camera_bsp.vd66gy_bsp.Init        = CMW_I2C_INIT;
3419bc36:	4b58      	ldr	r3, [pc, #352]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc38:	4a58      	ldr	r2, [pc, #352]	@ (3419bd9c <CMW_CAMERA_VD66GY_Init+0x19c>)
3419bc3a:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
  camera_bsp.vd66gy_bsp.DeInit      = CMW_I2C_DEINIT;
3419bc3e:	4b56      	ldr	r3, [pc, #344]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc40:	4a57      	ldr	r2, [pc, #348]	@ (3419bda0 <CMW_CAMERA_VD66GY_Init+0x1a0>)
3419bc42:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
  camera_bsp.vd66gy_bsp.ReadReg     = CMW_I2C_READREG16;
3419bc46:	4b54      	ldr	r3, [pc, #336]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc48:	4a56      	ldr	r2, [pc, #344]	@ (3419bda4 <CMW_CAMERA_VD66GY_Init+0x1a4>)
3419bc4a:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
  camera_bsp.vd66gy_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419bc4e:	4b52      	ldr	r3, [pc, #328]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc50:	4a55      	ldr	r2, [pc, #340]	@ (3419bda8 <CMW_CAMERA_VD66GY_Init+0x1a8>)
3419bc52:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
  camera_bsp.vd66gy_bsp.Delay       = HAL_Delay;
3419bc56:	4b50      	ldr	r3, [pc, #320]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc58:	4a54      	ldr	r2, [pc, #336]	@ (3419bdac <CMW_CAMERA_VD66GY_Init+0x1ac>)
3419bc5a:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
  camera_bsp.vd66gy_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419bc5e:	4b4e      	ldr	r3, [pc, #312]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc60:	4a53      	ldr	r2, [pc, #332]	@ (3419bdb0 <CMW_CAMERA_VD66GY_Init+0x1b0>)
3419bc62:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
  camera_bsp.vd66gy_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419bc66:	4b4c      	ldr	r3, [pc, #304]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc68:	4a52      	ldr	r2, [pc, #328]	@ (3419bdb4 <CMW_CAMERA_VD66GY_Init+0x1b4>)
3419bc6a:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
  camera_bsp.vd66gy_bsp.hdcmipp     = &hcamera_dcmipp;
3419bc6e:	4b4a      	ldr	r3, [pc, #296]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc70:	4a51      	ldr	r2, [pc, #324]	@ (3419bdb8 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419bc72:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3419bc76:	4b48      	ldr	r3, [pc, #288]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc78:	4a50      	ldr	r2, [pc, #320]	@ (3419bdbc <CMW_CAMERA_VD66GY_Init+0x1bc>)
3419bc7a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3419bc7e:	4b46      	ldr	r3, [pc, #280]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc80:	4a4f      	ldr	r2, [pc, #316]	@ (3419bdc0 <CMW_CAMERA_VD66GY_Init+0x1c0>)
3419bc82:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
  camera_bsp.vd66gy_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3419bc86:	4b44      	ldr	r3, [pc, #272]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc88:	4a4e      	ldr	r2, [pc, #312]	@ (3419bdc4 <CMW_CAMERA_VD66GY_Init+0x1c4>)
3419bc8a:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3419bc8e:	4b42      	ldr	r3, [pc, #264]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc90:	4a4d      	ldr	r2, [pc, #308]	@ (3419bdc8 <CMW_CAMERA_VD66GY_Init+0x1c8>)
3419bc92:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
  camera_bsp.vd66gy_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3419bc96:	4b40      	ldr	r3, [pc, #256]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bc98:	4a4c      	ldr	r2, [pc, #304]	@ (3419bdcc <CMW_CAMERA_VD66GY_Init+0x1cc>)
3419bc9a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

  ret = CMW_VD66GY_Probe(&camera_bsp.vd66gy_bsp, &Camera_Drv);
3419bc9e:	494c      	ldr	r1, [pc, #304]	@ (3419bdd0 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419bca0:	483d      	ldr	r0, [pc, #244]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bca2:	f002 fb5d 	bl	3419e360 <CMW_VD66GY_Probe>
3419bca6:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419bca8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bcaa:	2b00      	cmp	r3, #0
3419bcac:	d002      	beq.n	3419bcb4 <CMW_CAMERA_VD66GY_Init+0xb4>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419bcae:	f06f 0304 	mvn.w	r3, #4
3419bcb2:	e06c      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  if ((connected_sensor != CMW_VD66GY_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419bcb4:	4b47      	ldr	r3, [pc, #284]	@ (3419bdd4 <CMW_CAMERA_VD66GY_Init+0x1d4>)
3419bcb6:	781b      	ldrb	r3, [r3, #0]
3419bcb8:	2b01      	cmp	r3, #1
3419bcba:	d006      	beq.n	3419bcca <CMW_CAMERA_VD66GY_Init+0xca>
3419bcbc:	4b45      	ldr	r3, [pc, #276]	@ (3419bdd4 <CMW_CAMERA_VD66GY_Init+0x1d4>)
3419bcbe:	781b      	ldrb	r3, [r3, #0]
3419bcc0:	2b00      	cmp	r3, #0
3419bcc2:	d002      	beq.n	3419bcca <CMW_CAMERA_VD66GY_Init+0xca>
  {
    /* If the selected sensor in the application side has selected a different sensors than VD66GY */
    return CMW_ERROR_COMPONENT_FAILURE;
3419bcc4:	f06f 0304 	mvn.w	r3, #4
3419bcc8:	e061      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419bcca:	687b      	ldr	r3, [r7, #4]
3419bccc:	681b      	ldr	r3, [r3, #0]
3419bcce:	2b00      	cmp	r3, #0
3419bcd0:	d003      	beq.n	3419bcda <CMW_CAMERA_VD66GY_Init+0xda>
3419bcd2:	687b      	ldr	r3, [r7, #4]
3419bcd4:	685b      	ldr	r3, [r3, #4]
3419bcd6:	2b00      	cmp	r3, #0
3419bcd8:	d10c      	bne.n	3419bcf4 <CMW_CAMERA_VD66GY_Init+0xf4>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419bcda:	4b3d      	ldr	r3, [pc, #244]	@ (3419bdd0 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419bcdc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419bcde:	f107 020c 	add.w	r2, r7, #12
3419bce2:	4611      	mov	r1, r2
3419bce4:	482c      	ldr	r0, [pc, #176]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bce6:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419bce8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419bcea:	687b      	ldr	r3, [r7, #4]
3419bcec:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419bcee:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419bcf0:	687b      	ldr	r3, [r7, #4]
3419bcf2:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419bcf4:	4b36      	ldr	r3, [pc, #216]	@ (3419bdd0 <CMW_CAMERA_VD66GY_Init+0x1d0>)
3419bcf6:	681b      	ldr	r3, [r3, #0]
3419bcf8:	6879      	ldr	r1, [r7, #4]
3419bcfa:	4827      	ldr	r0, [pc, #156]	@ (3419bd98 <CMW_CAMERA_VD66GY_Init+0x198>)
3419bcfc:	4798      	blx	r3
3419bcfe:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret != CMW_ERROR_NONE)
3419bd00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bd02:	2b00      	cmp	r3, #0
3419bd04:	d002      	beq.n	3419bd0c <CMW_CAMERA_VD66GY_Init+0x10c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419bd06:	f06f 0304 	mvn.w	r3, #4
3419bd0a:	e040      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
3419bd0c:	f44f 7300 	mov.w	r3, #512	@ 0x200
3419bd10:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419bd12:	2301      	movs	r3, #1
3419bd14:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_800;
3419bd16:	231c      	movs	r3, #28
3419bd18:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419bd1a:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419bd1e:	4619      	mov	r1, r3
3419bd20:	4825      	ldr	r0, [pc, #148]	@ (3419bdb8 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419bd22:	f7ea fdcb 	bl	341868bc <HAL_DCMIPP_CSI_SetConfig>
3419bd26:	4603      	mov	r3, r0
3419bd28:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419bd2a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bd2c:	2b00      	cmp	r3, #0
3419bd2e:	d002      	beq.n	3419bd36 <CMW_CAMERA_VD66GY_Init+0x136>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bd30:	f06f 0303 	mvn.w	r3, #3
3419bd34:	e02b      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP8);
3419bd36:	2202      	movs	r2, #2
3419bd38:	2100      	movs	r1, #0
3419bd3a:	481f      	ldr	r0, [pc, #124]	@ (3419bdb8 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419bd3c:	f7ea ffc2 	bl	34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>
3419bd40:	4603      	mov	r3, r0
3419bd42:	663b      	str	r3, [r7, #96]	@ 0x60
  if (ret != HAL_OK)
3419bd44:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bd46:	2b00      	cmp	r3, #0
3419bd48:	d002      	beq.n	3419bd50 <CMW_CAMERA_VD66GY_Init+0x150>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bd4a:	f06f 0303 	mvn.w	r3, #3
3419bd4e:	e01e      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419bd50:	2300      	movs	r3, #0
3419bd52:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW8;
3419bd54:	232a      	movs	r3, #42	@ 0x2a
3419bd56:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419bd58:	2300      	movs	r3, #0
3419bd5a:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bd5c:	2300      	movs	r3, #0
3419bd5e:	667b      	str	r3, [r7, #100]	@ 0x64
3419bd60:	e011      	b.n	3419bd86 <CMW_CAMERA_VD66GY_Init+0x186>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419bd62:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419bd66:	461a      	mov	r2, r3
3419bd68:	6e79      	ldr	r1, [r7, #100]	@ 0x64
3419bd6a:	4813      	ldr	r0, [pc, #76]	@ (3419bdb8 <CMW_CAMERA_VD66GY_Init+0x1b8>)
3419bd6c:	f7ea ff0a 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419bd70:	4603      	mov	r3, r0
3419bd72:	663b      	str	r3, [r7, #96]	@ 0x60
    if (ret != HAL_OK)
3419bd74:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bd76:	2b00      	cmp	r3, #0
3419bd78:	d002      	beq.n	3419bd80 <CMW_CAMERA_VD66GY_Init+0x180>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419bd7a:	f06f 0303 	mvn.w	r3, #3
3419bd7e:	e006      	b.n	3419bd8e <CMW_CAMERA_VD66GY_Init+0x18e>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bd80:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bd82:	3301      	adds	r3, #1
3419bd84:	667b      	str	r3, [r7, #100]	@ 0x64
3419bd86:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bd88:	2b02      	cmp	r3, #2
3419bd8a:	d9ea      	bls.n	3419bd62 <CMW_CAMERA_VD66GY_Init+0x162>
    }
  }

  return CMW_ERROR_NONE;
3419bd8c:	2300      	movs	r3, #0
}
3419bd8e:	4618      	mov	r0, r3
3419bd90:	3768      	adds	r7, #104	@ 0x68
3419bd92:	46bd      	mov	sp, r7
3419bd94:	bd80      	pop	{r7, pc}
3419bd96:	bf00      	nop
3419bd98:	341c1a38 	.word	0x341c1a38
3419bd9c:	34183bc9 	.word	0x34183bc9
3419bda0:	34183c3d 	.word	0x34183c3d
3419bda4:	34183d65 	.word	0x34183d65
3419bda8:	34183d09 	.word	0x34183d09
3419bdac:	34186529 	.word	0x34186529
3419bdb0:	3419b955 	.word	0x3419b955
3419bdb4:	3419b981 	.word	0x3419b981
3419bdb8:	341c19c4 	.word	0x341c19c4
3419bdbc:	3419b9ad 	.word	0x3419b9ad
3419bdc0:	3419b9d1 	.word	0x3419b9d1
3419bdc4:	3419b9f5 	.word	0x3419b9f5
3419bdc8:	3419ba19 	.word	0x3419ba19
3419bdcc:	3419ba3d 	.word	0x3419ba3d
3419bdd0:	341c19d0 	.word	0x341c19d0
3419bdd4:	341c1980 	.word	0x341c1980

3419bdd8 <CMW_CAMERA_IMX335_Init>:
#endif

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init(CMW_Sensor_Init_t *initSensors_params)
{
3419bdd8:	b580      	push	{r7, lr}
3419bdda:	b09a      	sub	sp, #104	@ 0x68
3419bddc:	af00      	add	r7, sp, #0
3419bdde:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3419bde0:	2300      	movs	r3, #0
3419bde2:	667b      	str	r3, [r7, #100]	@ 0x64
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3419bde4:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419bde8:	2200      	movs	r2, #0
3419bdea:	601a      	str	r2, [r3, #0]
3419bdec:	605a      	str	r2, [r3, #4]
3419bdee:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3419bdf0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419bdf4:	2200      	movs	r2, #0
3419bdf6:	601a      	str	r2, [r3, #0]
3419bdf8:	605a      	str	r2, [r3, #4]
3419bdfa:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3419bdfc:	f44f 72a0 	mov.w	r2, #320	@ 0x140
3419be00:	2100      	movs	r1, #0
3419be02:	486a      	ldr	r0, [pc, #424]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be04:	f009 fb74 	bl	341a54f0 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
3419be08:	4b68      	ldr	r3, [pc, #416]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be0a:	2234      	movs	r2, #52	@ 0x34
3419be0c:	801a      	strh	r2, [r3, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
3419be0e:	4b67      	ldr	r3, [pc, #412]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be10:	4a67      	ldr	r2, [pc, #412]	@ (3419bfb0 <CMW_CAMERA_IMX335_Init+0x1d8>)
3419be12:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
3419be16:	4b65      	ldr	r3, [pc, #404]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be18:	4a66      	ldr	r2, [pc, #408]	@ (3419bfb4 <CMW_CAMERA_IMX335_Init+0x1dc>)
3419be1a:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
3419be1e:	4b63      	ldr	r3, [pc, #396]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be20:	4a65      	ldr	r2, [pc, #404]	@ (3419bfb8 <CMW_CAMERA_IMX335_Init+0x1e0>)
3419be22:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3419be26:	4b61      	ldr	r3, [pc, #388]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be28:	4a64      	ldr	r2, [pc, #400]	@ (3419bfbc <CMW_CAMERA_IMX335_Init+0x1e4>)
3419be2a:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
3419be2e:	4b5f      	ldr	r3, [pc, #380]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be30:	4a63      	ldr	r2, [pc, #396]	@ (3419bfc0 <CMW_CAMERA_IMX335_Init+0x1e8>)
3419be32:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
3419be36:	4b5d      	ldr	r3, [pc, #372]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be38:	4a62      	ldr	r2, [pc, #392]	@ (3419bfc4 <CMW_CAMERA_IMX335_Init+0x1ec>)
3419be3a:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3419be3e:	4b5b      	ldr	r3, [pc, #364]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be40:	4a61      	ldr	r2, [pc, #388]	@ (3419bfc8 <CMW_CAMERA_IMX335_Init+0x1f0>)
3419be42:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3419be46:	4b59      	ldr	r3, [pc, #356]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be48:	4a60      	ldr	r2, [pc, #384]	@ (3419bfcc <CMW_CAMERA_IMX335_Init+0x1f4>)
3419be4a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
3419be4e:	4b57      	ldr	r3, [pc, #348]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be50:	4a5f      	ldr	r2, [pc, #380]	@ (3419bfd0 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419be52:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3419be56:	4b55      	ldr	r3, [pc, #340]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be58:	4a5e      	ldr	r2, [pc, #376]	@ (3419bfd4 <CMW_CAMERA_IMX335_Init+0x1fc>)
3419be5a:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3419be5e:	4b53      	ldr	r3, [pc, #332]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be60:	4a5d      	ldr	r2, [pc, #372]	@ (3419bfd8 <CMW_CAMERA_IMX335_Init+0x200>)
3419be62:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3419be66:	4b51      	ldr	r3, [pc, #324]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be68:	4a5c      	ldr	r2, [pc, #368]	@ (3419bfdc <CMW_CAMERA_IMX335_Init+0x204>)
3419be6a:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3419be6e:	4b4f      	ldr	r3, [pc, #316]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be70:	4a5b      	ldr	r2, [pc, #364]	@ (3419bfe0 <CMW_CAMERA_IMX335_Init+0x208>)
3419be72:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3419be76:	4b4d      	ldr	r3, [pc, #308]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be78:	4a5a      	ldr	r2, [pc, #360]	@ (3419bfe4 <CMW_CAMERA_IMX335_Init+0x20c>)
3419be7a:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3419be7e:	495a      	ldr	r1, [pc, #360]	@ (3419bfe8 <CMW_CAMERA_IMX335_Init+0x210>)
3419be80:	484a      	ldr	r0, [pc, #296]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419be82:	f000 fed3 	bl	3419cc2c <CMW_IMX335_Probe>
3419be86:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419be88:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419be8a:	2b00      	cmp	r3, #0
3419be8c:	d002      	beq.n	3419be94 <CMW_CAMERA_IMX335_Init+0xbc>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419be8e:	f06f 0304 	mvn.w	r3, #4
3419be92:	e086      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  if ((connected_sensor != CMW_IMX335_Sensor) && (connected_sensor != CMW_NOTKNOWN_Sensor))
3419be94:	4b55      	ldr	r3, [pc, #340]	@ (3419bfec <CMW_CAMERA_IMX335_Init+0x214>)
3419be96:	781b      	ldrb	r3, [r3, #0]
3419be98:	2b02      	cmp	r3, #2
3419be9a:	d006      	beq.n	3419beaa <CMW_CAMERA_IMX335_Init+0xd2>
3419be9c:	4b53      	ldr	r3, [pc, #332]	@ (3419bfec <CMW_CAMERA_IMX335_Init+0x214>)
3419be9e:	781b      	ldrb	r3, [r3, #0]
3419bea0:	2b00      	cmp	r3, #0
3419bea2:	d002      	beq.n	3419beaa <CMW_CAMERA_IMX335_Init+0xd2>
  {
    /* If the selected sensor in the application side has selected a different sensors than IMX335 */
    return CMW_ERROR_COMPONENT_FAILURE;
3419bea4:	f06f 0304 	mvn.w	r3, #4
3419bea8:	e07b      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3419beaa:	687b      	ldr	r3, [r7, #4]
3419beac:	681b      	ldr	r3, [r3, #0]
3419beae:	2b00      	cmp	r3, #0
3419beb0:	d003      	beq.n	3419beba <CMW_CAMERA_IMX335_Init+0xe2>
3419beb2:	687b      	ldr	r3, [r7, #4]
3419beb4:	685b      	ldr	r3, [r3, #4]
3419beb6:	2b00      	cmp	r3, #0
3419beb8:	d10c      	bne.n	3419bed4 <CMW_CAMERA_IMX335_Init+0xfc>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3419beba:	4b4b      	ldr	r3, [pc, #300]	@ (3419bfe8 <CMW_CAMERA_IMX335_Init+0x210>)
3419bebc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3419bebe:	f107 020c 	add.w	r2, r7, #12
3419bec2:	4611      	mov	r1, r2
3419bec4:	4839      	ldr	r0, [pc, #228]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419bec6:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3419bec8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3419beca:	687b      	ldr	r3, [r7, #4]
3419becc:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3419bece:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3419bed0:	687b      	ldr	r3, [r7, #4]
3419bed2:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3419bed4:	4b44      	ldr	r3, [pc, #272]	@ (3419bfe8 <CMW_CAMERA_IMX335_Init+0x210>)
3419bed6:	681b      	ldr	r3, [r3, #0]
3419bed8:	6879      	ldr	r1, [r7, #4]
3419beda:	4834      	ldr	r0, [pc, #208]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419bedc:	4798      	blx	r3
3419bede:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419bee0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bee2:	2b00      	cmp	r3, #0
3419bee4:	d002      	beq.n	3419beec <CMW_CAMERA_IMX335_Init+0x114>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419bee6:	f06f 0304 	mvn.w	r3, #4
3419beea:	e05a      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_24MHZ);
3419beec:	4b3e      	ldr	r3, [pc, #248]	@ (3419bfe8 <CMW_CAMERA_IMX335_Init+0x210>)
3419beee:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3419bef0:	2102      	movs	r1, #2
3419bef2:	482e      	ldr	r0, [pc, #184]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419bef4:	4798      	blx	r3
3419bef6:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419bef8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419befa:	2b00      	cmp	r3, #0
3419befc:	d002      	beq.n	3419bf04 <CMW_CAMERA_IMX335_Init+0x12c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419befe:	f06f 0304 	mvn.w	r3, #4
3419bf02:	e04e      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = Camera_Drv.SetFramerate(&camera_bsp, initSensors_params->fps);
3419bf04:	4b38      	ldr	r3, [pc, #224]	@ (3419bfe8 <CMW_CAMERA_IMX335_Init+0x210>)
3419bf06:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3419bf08:	687a      	ldr	r2, [r7, #4]
3419bf0a:	6892      	ldr	r2, [r2, #8]
3419bf0c:	4611      	mov	r1, r2
3419bf0e:	4827      	ldr	r0, [pc, #156]	@ (3419bfac <CMW_CAMERA_IMX335_Init+0x1d4>)
3419bf10:	4798      	blx	r3
3419bf12:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3419bf14:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bf16:	2b00      	cmp	r3, #0
3419bf18:	d002      	beq.n	3419bf20 <CMW_CAMERA_IMX335_Init+0x148>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419bf1a:	f06f 0304 	mvn.w	r3, #4
3419bf1e:	e040      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
3419bf20:	f44f 7300 	mov.w	r3, #512	@ 0x200
3419bf24:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3419bf26:	2301      	movs	r3, #1
3419bf28:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3419bf2a:	232c      	movs	r3, #44	@ 0x2c
3419bf2c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3419bf2e:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3419bf32:	4619      	mov	r1, r3
3419bf34:	4826      	ldr	r0, [pc, #152]	@ (3419bfd0 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419bf36:	f7ea fcc1 	bl	341868bc <HAL_DCMIPP_CSI_SetConfig>
3419bf3a:	4603      	mov	r3, r0
3419bf3c:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3419bf3e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bf40:	2b00      	cmp	r3, #0
3419bf42:	d002      	beq.n	3419bf4a <CMW_CAMERA_IMX335_Init+0x172>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bf44:	f06f 0303 	mvn.w	r3, #3
3419bf48:	e02b      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
3419bf4a:	2203      	movs	r2, #3
3419bf4c:	2100      	movs	r1, #0
3419bf4e:	4820      	ldr	r0, [pc, #128]	@ (3419bfd0 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419bf50:	f7ea feb8 	bl	34186cc4 <HAL_DCMIPP_CSI_SetVCConfig>
3419bf54:	4603      	mov	r3, r0
3419bf56:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3419bf58:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bf5a:	2b00      	cmp	r3, #0
3419bf5c:	d002      	beq.n	3419bf64 <CMW_CAMERA_IMX335_Init+0x18c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419bf5e:	f06f 0303 	mvn.w	r3, #3
3419bf62:	e01e      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3419bf64:	2300      	movs	r3, #0
3419bf66:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3419bf68:	232b      	movs	r3, #43	@ 0x2b
3419bf6a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3419bf6c:	2300      	movs	r3, #0
3419bf6e:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bf70:	2300      	movs	r3, #0
3419bf72:	663b      	str	r3, [r7, #96]	@ 0x60
3419bf74:	e011      	b.n	3419bf9a <CMW_CAMERA_IMX335_Init+0x1c2>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3419bf76:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3419bf7a:	461a      	mov	r2, r3
3419bf7c:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3419bf7e:	4814      	ldr	r0, [pc, #80]	@ (3419bfd0 <CMW_CAMERA_IMX335_Init+0x1f8>)
3419bf80:	f7ea fe00 	bl	34186b84 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3419bf84:	4603      	mov	r3, r0
3419bf86:	667b      	str	r3, [r7, #100]	@ 0x64
    if (ret != HAL_OK)
3419bf88:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419bf8a:	2b00      	cmp	r3, #0
3419bf8c:	d002      	beq.n	3419bf94 <CMW_CAMERA_IMX335_Init+0x1bc>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3419bf8e:	f06f 0303 	mvn.w	r3, #3
3419bf92:	e006      	b.n	3419bfa2 <CMW_CAMERA_IMX335_Init+0x1ca>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3419bf94:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bf96:	3301      	adds	r3, #1
3419bf98:	663b      	str	r3, [r7, #96]	@ 0x60
3419bf9a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419bf9c:	2b02      	cmp	r3, #2
3419bf9e:	d9ea      	bls.n	3419bf76 <CMW_CAMERA_IMX335_Init+0x19e>
    }
  }


  return ret;
3419bfa0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
3419bfa2:	4618      	mov	r0, r3
3419bfa4:	3768      	adds	r7, #104	@ 0x68
3419bfa6:	46bd      	mov	sp, r7
3419bfa8:	bd80      	pop	{r7, pc}
3419bfaa:	bf00      	nop
3419bfac:	341c1a38 	.word	0x341c1a38
3419bfb0:	34183bc9 	.word	0x34183bc9
3419bfb4:	34183c3d 	.word	0x34183c3d
3419bfb8:	34183d65 	.word	0x34183d65
3419bfbc:	34183d09 	.word	0x34183d09
3419bfc0:	34183f1d 	.word	0x34183f1d
3419bfc4:	34186529 	.word	0x34186529
3419bfc8:	3419b955 	.word	0x3419b955
3419bfcc:	3419b981 	.word	0x3419b981
3419bfd0:	341c19c4 	.word	0x341c19c4
3419bfd4:	3419b9ad 	.word	0x3419b9ad
3419bfd8:	3419b9d1 	.word	0x3419b9d1
3419bfdc:	3419b9f5 	.word	0x3419b9f5
3419bfe0:	3419ba19 	.word	0x3419ba19
3419bfe4:	3419ba3d 	.word	0x3419ba3d
3419bfe8:	341c19d0 	.word	0x341c19d0
3419bfec:	341c1980 	.word	0x341c1980

3419bff0 <CMW_CAMERA_SetPipe>:
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3419bff0:	b580      	push	{r7, lr}
3419bff2:	b098      	sub	sp, #96	@ 0x60
3419bff4:	af02      	add	r7, sp, #8
3419bff6:	60f8      	str	r0, [r7, #12]
3419bff8:	60b9      	str	r1, [r7, #8]
3419bffa:	607a      	str	r2, [r7, #4]
3419bffc:	603b      	str	r3, [r7, #0]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3419bffe:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419c002:	2200      	movs	r2, #0
3419c004:	601a      	str	r2, [r3, #0]
3419c006:	605a      	str	r2, [r3, #4]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3419c008:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419c00c:	2200      	movs	r2, #0
3419c00e:	601a      	str	r2, [r3, #0]
3419c010:	605a      	str	r2, [r3, #4]
3419c012:	609a      	str	r2, [r3, #8]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3419c014:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419c018:	2200      	movs	r2, #0
3419c01a:	601a      	str	r2, [r3, #0]
3419c01c:	605a      	str	r2, [r3, #4]
3419c01e:	609a      	str	r2, [r3, #8]
3419c020:	60da      	str	r2, [r3, #12]
3419c022:	611a      	str	r2, [r3, #16]
3419c024:	615a      	str	r2, [r3, #20]
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3419c026:	f107 0314 	add.w	r3, r7, #20
3419c02a:	2200      	movs	r2, #0
3419c02c:	601a      	str	r2, [r3, #0]
3419c02e:	605a      	str	r2, [r3, #4]
3419c030:	609a      	str	r2, [r3, #8]
3419c032:	60da      	str	r2, [r3, #12]
3419c034:	611a      	str	r2, [r3, #16]
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
3419c036:	68bb      	ldr	r3, [r7, #8]
3419c038:	2b00      	cmp	r3, #0
3419c03a:	d112      	bne.n	3419c062 <CMW_CAMERA_SetPipe+0x72>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3419c03c:	2300      	movs	r3, #0
3419c03e:	643b      	str	r3, [r7, #64]	@ 0x40
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3419c040:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419c044:	461a      	mov	r2, r3
3419c046:	68b9      	ldr	r1, [r7, #8]
3419c048:	68f8      	ldr	r0, [r7, #12]
3419c04a:	f7ea fe7d 	bl	34186d48 <HAL_DCMIPP_PIPE_SetConfig>
3419c04e:	4603      	mov	r3, r0
3419c050:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c052:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c054:	2b00      	cmp	r3, #0
3419c056:	d002      	beq.n	3419c05e <CMW_CAMERA_SetPipe+0x6e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c058:	f06f 0304 	mvn.w	r3, #4
3419c05c:	e11e      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }

    return HAL_OK;
3419c05e:	2300      	movs	r3, #0
3419c060:	e11c      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
3419c062:	4b90      	ldr	r3, [pc, #576]	@ (3419c2a4 <CMW_CAMERA_SetPipe+0x2b4>)
3419c064:	6818      	ldr	r0, [r3, #0]
3419c066:	4b8f      	ldr	r3, [pc, #572]	@ (3419c2a4 <CMW_CAMERA_SetPipe+0x2b4>)
3419c068:	6859      	ldr	r1, [r3, #4]
3419c06a:	f107 0214 	add.w	r2, r7, #20
3419c06e:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419c072:	9301      	str	r3, [sp, #4]
3419c074:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419c078:	9300      	str	r3, [sp, #0]
3419c07a:	4613      	mov	r3, r2
3419c07c:	687a      	ldr	r2, [r7, #4]
3419c07e:	f000 f917 	bl	3419c2b0 <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
3419c082:	69fb      	ldr	r3, [r7, #28]
3419c084:	2b00      	cmp	r3, #0
3419c086:	d102      	bne.n	3419c08e <CMW_CAMERA_SetPipe+0x9e>
3419c088:	6a3b      	ldr	r3, [r7, #32]
3419c08a:	2b00      	cmp	r3, #0
3419c08c:	d01a      	beq.n	3419c0c4 <CMW_CAMERA_SetPipe+0xd4>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
3419c08e:	f107 0314 	add.w	r3, r7, #20
3419c092:	461a      	mov	r2, r3
3419c094:	68b9      	ldr	r1, [r7, #8]
3419c096:	68f8      	ldr	r0, [r7, #12]
3419c098:	f7eb fdf0 	bl	34187c7c <HAL_DCMIPP_PIPE_SetCropConfig>
3419c09c:	4603      	mov	r3, r0
3419c09e:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c0a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c0a2:	2b00      	cmp	r3, #0
3419c0a4:	d002      	beq.n	3419c0ac <CMW_CAMERA_SetPipe+0xbc>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c0a6:	f06f 0304 	mvn.w	r3, #4
3419c0aa:	e0f7      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
3419c0ac:	68b9      	ldr	r1, [r7, #8]
3419c0ae:	68f8      	ldr	r0, [r7, #12]
3419c0b0:	f7eb fe8c 	bl	34187dcc <HAL_DCMIPP_PIPE_EnableCrop>
3419c0b4:	4603      	mov	r3, r0
3419c0b6:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c0b8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c0ba:	2b00      	cmp	r3, #0
3419c0bc:	d00e      	beq.n	3419c0dc <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c0be:	f06f 0304 	mvn.w	r3, #4
3419c0c2:	e0eb      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
3419c0c4:	68b9      	ldr	r1, [r7, #8]
3419c0c6:	68f8      	ldr	r0, [r7, #12]
3419c0c8:	f7eb fede 	bl	34187e88 <HAL_DCMIPP_PIPE_DisableCrop>
3419c0cc:	4603      	mov	r3, r0
3419c0ce:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c0d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c0d2:	2b00      	cmp	r3, #0
3419c0d4:	d002      	beq.n	3419c0dc <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c0d6:	f06f 0304 	mvn.w	r3, #4
3419c0da:	e0df      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
3419c0dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419c0de:	2b00      	cmp	r3, #0
3419c0e0:	d102      	bne.n	3419c0e8 <CMW_CAMERA_SetPipe+0xf8>
3419c0e2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419c0e4:	2b00      	cmp	r3, #0
3419c0e6:	d01a      	beq.n	3419c11e <CMW_CAMERA_SetPipe+0x12e>
  {
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
3419c0e8:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3419c0ec:	461a      	mov	r2, r3
3419c0ee:	68b9      	ldr	r1, [r7, #8]
3419c0f0:	68f8      	ldr	r0, [r7, #12]
3419c0f2:	f7eb ff57 	bl	34187fa4 <HAL_DCMIPP_PIPE_SetDecimationConfig>
3419c0f6:	4603      	mov	r3, r0
3419c0f8:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c0fa:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c0fc:	2b00      	cmp	r3, #0
3419c0fe:	d002      	beq.n	3419c106 <CMW_CAMERA_SetPipe+0x116>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c100:	f06f 0304 	mvn.w	r3, #4
3419c104:	e0ca      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
3419c106:	68b9      	ldr	r1, [r7, #8]
3419c108:	68f8      	ldr	r0, [r7, #12]
3419c10a:	f7eb ff8e 	bl	3418802a <HAL_DCMIPP_PIPE_EnableDecimation>
3419c10e:	4603      	mov	r3, r0
3419c110:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c112:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c114:	2b00      	cmp	r3, #0
3419c116:	d00e      	beq.n	3419c136 <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c118:	f06f 0304 	mvn.w	r3, #4
3419c11c:	e0be      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
3419c11e:	68b9      	ldr	r1, [r7, #8]
3419c120:	68f8      	ldr	r0, [r7, #12]
3419c122:	f7eb ffb1 	bl	34188088 <HAL_DCMIPP_PIPE_DisableDecimation>
3419c126:	4603      	mov	r3, r0
3419c128:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c12a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c12c:	2b00      	cmp	r3, #0
3419c12e:	d002      	beq.n	3419c136 <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c130:	f06f 0304 	mvn.w	r3, #4
3419c134:	e0b2      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
3419c136:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3419c13a:	461a      	mov	r2, r3
3419c13c:	68b9      	ldr	r1, [r7, #8]
3419c13e:	68f8      	ldr	r0, [r7, #12]
3419c140:	f7eb ffd1 	bl	341880e6 <HAL_DCMIPP_PIPE_SetDownsizeConfig>
3419c144:	4603      	mov	r3, r0
3419c146:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3419c148:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c14a:	2b00      	cmp	r3, #0
3419c14c:	d002      	beq.n	3419c154 <CMW_CAMERA_SetPipe+0x164>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c14e:	f06f 0304 	mvn.w	r3, #4
3419c152:	e0a3      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
3419c154:	68b9      	ldr	r1, [r7, #8]
3419c156:	68f8      	ldr	r0, [r7, #12]
3419c158:	f7ec f843 	bl	341881e2 <HAL_DCMIPP_PIPE_EnableDownsize>
3419c15c:	4603      	mov	r3, r0
3419c15e:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3419c160:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c162:	2b00      	cmp	r3, #0
3419c164:	d002      	beq.n	3419c16c <CMW_CAMERA_SetPipe+0x17c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c166:	f06f 0304 	mvn.w	r3, #4
3419c16a:	e097      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
  }

  if (p_conf->enable_swap)
3419c16c:	687b      	ldr	r3, [r7, #4]
3419c16e:	691b      	ldr	r3, [r3, #16]
3419c170:	2b00      	cmp	r3, #0
3419c172:	d00b      	beq.n	3419c18c <CMW_CAMERA_SetPipe+0x19c>
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3419c174:	68b9      	ldr	r1, [r7, #8]
3419c176:	68f8      	ldr	r0, [r7, #12]
3419c178:	f7ec ff40 	bl	34188ffc <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
3419c17c:	4603      	mov	r3, r0
3419c17e:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c180:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c182:	2b00      	cmp	r3, #0
3419c184:	d00e      	beq.n	3419c1a4 <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c186:	f06f 0304 	mvn.w	r3, #4
3419c18a:	e087      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
3419c18c:	68b9      	ldr	r1, [r7, #8]
3419c18e:	68f8      	ldr	r0, [r7, #12]
3419c190:	f7ec ff68 	bl	34189064 <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
3419c194:	4603      	mov	r3, r0
3419c196:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c198:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c19a:	2b00      	cmp	r3, #0
3419c19c:	d002      	beq.n	3419c1a4 <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c19e:	f06f 0304 	mvn.w	r3, #4
3419c1a2:	e07b      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
3419c1a4:	687b      	ldr	r3, [r7, #4]
3419c1a6:	695b      	ldr	r3, [r3, #20]
3419c1a8:	2b00      	cmp	r3, #0
3419c1aa:	db1b      	blt.n	3419c1e4 <CMW_CAMERA_SetPipe+0x1f4>
  {
    if (p_conf->enable_gamma_conversion)
3419c1ac:	687b      	ldr	r3, [r7, #4]
3419c1ae:	695b      	ldr	r3, [r3, #20]
3419c1b0:	2b00      	cmp	r3, #0
3419c1b2:	d00b      	beq.n	3419c1cc <CMW_CAMERA_SetPipe+0x1dc>
    {
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
3419c1b4:	68b9      	ldr	r1, [r7, #8]
3419c1b6:	68f8      	ldr	r0, [r7, #12]
3419c1b8:	f7ec f842 	bl	34188240 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3419c1bc:	4603      	mov	r3, r0
3419c1be:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419c1c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c1c2:	2b00      	cmp	r3, #0
3419c1c4:	d00e      	beq.n	3419c1e4 <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419c1c6:	f06f 0304 	mvn.w	r3, #4
3419c1ca:	e067      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
    else
    {
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
3419c1cc:	68b9      	ldr	r1, [r7, #8]
3419c1ce:	68f8      	ldr	r0, [r7, #12]
3419c1d0:	f7ec f865 	bl	3418829e <HAL_DCMIPP_PIPE_DisableGammaConversion>
3419c1d4:	4603      	mov	r3, r0
3419c1d6:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419c1d8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c1da:	2b00      	cmp	r3, #0
3419c1dc:	d002      	beq.n	3419c1e4 <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419c1de:	f06f 0304 	mvn.w	r3, #4
3419c1e2:	e05b      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
3419c1e4:	68bb      	ldr	r3, [r7, #8]
3419c1e6:	2b02      	cmp	r3, #2
3419c1e8:	d114      	bne.n	3419c214 <CMW_CAMERA_SetPipe+0x224>
  {
    if (!is_pipe1_2_shared)
3419c1ea:	4b2f      	ldr	r3, [pc, #188]	@ (3419c2a8 <CMW_CAMERA_SetPipe+0x2b8>)
3419c1ec:	681b      	ldr	r3, [r3, #0]
3419c1ee:	2b00      	cmp	r3, #0
3419c1f0:	d110      	bne.n	3419c214 <CMW_CAMERA_SetPipe+0x224>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
3419c1f2:	68b9      	ldr	r1, [r7, #8]
3419c1f4:	68f8      	ldr	r0, [r7, #12]
3419c1f6:	f7ec ff69 	bl	341890cc <HAL_DCMIPP_PIPE_CSI_EnableShare>
3419c1fa:	4603      	mov	r3, r0
3419c1fc:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3419c1fe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c200:	2b00      	cmp	r3, #0
3419c202:	d002      	beq.n	3419c20a <CMW_CAMERA_SetPipe+0x21a>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3419c204:	f06f 0304 	mvn.w	r3, #4
3419c208:	e048      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
      }
      is_pipe1_2_shared++;
3419c20a:	4b27      	ldr	r3, [pc, #156]	@ (3419c2a8 <CMW_CAMERA_SetPipe+0x2b8>)
3419c20c:	681b      	ldr	r3, [r3, #0]
3419c20e:	3301      	adds	r3, #1
3419c210:	4a25      	ldr	r2, [pc, #148]	@ (3419c2a8 <CMW_CAMERA_SetPipe+0x2b8>)
3419c212:	6013      	str	r3, [r2, #0]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3419c214:	2300      	movs	r3, #0
3419c216:	643b      	str	r3, [r7, #64]	@ 0x40
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3419c218:	687b      	ldr	r3, [r7, #4]
3419c21a:	681b      	ldr	r3, [r3, #0]
3419c21c:	687a      	ldr	r2, [r7, #4]
3419c21e:	68d2      	ldr	r2, [r2, #12]
3419c220:	fb02 f303 	mul.w	r3, r2, r3
3419c224:	647b      	str	r3, [r7, #68]	@ 0x44
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3419c226:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419c228:	330f      	adds	r3, #15
3419c22a:	f023 030f 	bic.w	r3, r3, #15
3419c22e:	647b      	str	r3, [r7, #68]	@ 0x44
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3419c230:	687b      	ldr	r3, [r7, #4]
3419c232:	689b      	ldr	r3, [r3, #8]
3419c234:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3419c236:	4a1d      	ldr	r2, [pc, #116]	@ (3419c2ac <CMW_CAMERA_SetPipe+0x2bc>)
3419c238:	68bb      	ldr	r3, [r7, #8]
3419c23a:	4413      	add	r3, r2
3419c23c:	3305      	adds	r3, #5
3419c23e:	781b      	ldrb	r3, [r3, #0]
3419c240:	b2db      	uxtb	r3, r3
3419c242:	2b00      	cmp	r3, #0
3419c244:	d10e      	bne.n	3419c264 <CMW_CAMERA_SetPipe+0x274>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3419c246:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3419c24a:	461a      	mov	r2, r3
3419c24c:	68b9      	ldr	r1, [r7, #8]
3419c24e:	68f8      	ldr	r0, [r7, #12]
3419c250:	f7ea fd7a 	bl	34186d48 <HAL_DCMIPP_PIPE_SetConfig>
3419c254:	4603      	mov	r3, r0
3419c256:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3419c258:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419c25a:	2b00      	cmp	r3, #0
3419c25c:	d01a      	beq.n	3419c294 <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c25e:	f06f 0304 	mvn.w	r3, #4
3419c262:	e01b      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
3419c264:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3419c266:	461a      	mov	r2, r3
3419c268:	68b9      	ldr	r1, [r7, #8]
3419c26a:	68f8      	ldr	r0, [r7, #12]
3419c26c:	f7ec fe92 	bl	34188f94 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
3419c270:	4603      	mov	r3, r0
3419c272:	2b00      	cmp	r3, #0
3419c274:	d002      	beq.n	3419c27c <CMW_CAMERA_SetPipe+0x28c>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c276:	f06f 0304 	mvn.w	r3, #4
3419c27a:	e00f      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3419c27c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3419c27e:	461a      	mov	r2, r3
3419c280:	68b9      	ldr	r1, [r7, #8]
3419c282:	68f8      	ldr	r0, [r7, #12]
3419c284:	f7ec fe4e 	bl	34188f24 <HAL_DCMIPP_PIPE_SetPitch>
3419c288:	4603      	mov	r3, r0
3419c28a:	2b00      	cmp	r3, #0
3419c28c:	d002      	beq.n	3419c294 <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3419c28e:	f06f 0304 	mvn.w	r3, #4
3419c292:	e003      	b.n	3419c29c <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
3419c294:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3419c296:	683b      	ldr	r3, [r7, #0]
3419c298:	601a      	str	r2, [r3, #0]

  return HAL_OK;
3419c29a:	2300      	movs	r3, #0
}
3419c29c:	4618      	mov	r0, r3
3419c29e:	3758      	adds	r7, #88	@ 0x58
3419c2a0:	46bd      	mov	sp, r7
3419c2a2:	bd80      	pop	{r7, pc}
3419c2a4:	341c1968 	.word	0x341c1968
3419c2a8:	341c1b80 	.word	0x341c1b80
3419c2ac:	341c19c4 	.word	0x341c19c4

3419c2b0 <CMW_UTILS_GetPipeConfig>:
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down);

void CMW_UTILS_GetPipeConfig(uint32_t cam_width, uint32_t cam_height, CMW_DCMIPP_Conf_t *p_conf,
                             DCMIPP_CropConfTypeDef *crop, DCMIPP_DecimationConfTypeDef *dec,
                             DCMIPP_DownsizeTypeDef *down)
{
3419c2b0:	b580      	push	{r7, lr}
3419c2b2:	b088      	sub	sp, #32
3419c2b4:	af02      	add	r7, sp, #8
3419c2b6:	60f8      	str	r0, [r7, #12]
3419c2b8:	60b9      	str	r1, [r7, #8]
3419c2ba:	607a      	str	r2, [r7, #4]
3419c2bc:	603b      	str	r3, [r7, #0]
  float ratio_height = 0;
3419c2be:	f04f 0300 	mov.w	r3, #0
3419c2c2:	617b      	str	r3, [r7, #20]
  float ratio_width = 0;
3419c2c4:	f04f 0300 	mov.w	r3, #0
3419c2c8:	613b      	str	r3, [r7, #16]

  if (p_conf->mode == CMW_Aspect_ratio_crop)
3419c2ca:	687b      	ldr	r3, [r7, #4]
3419c2cc:	699b      	ldr	r3, [r3, #24]
3419c2ce:	2b00      	cmp	r3, #0
3419c2d0:	d12b      	bne.n	3419c32a <CMW_UTILS_GetPipeConfig+0x7a>
  {
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
3419c2d2:	687b      	ldr	r3, [r7, #4]
3419c2d4:	681a      	ldr	r2, [r3, #0]
3419c2d6:	687b      	ldr	r3, [r7, #4]
3419c2d8:	6859      	ldr	r1, [r3, #4]
3419c2da:	683b      	ldr	r3, [r7, #0]
3419c2dc:	9300      	str	r3, [sp, #0]
3419c2de:	460b      	mov	r3, r1
3419c2e0:	68b9      	ldr	r1, [r7, #8]
3419c2e2:	68f8      	ldr	r0, [r7, #12]
3419c2e4:	f000 f88e 	bl	3419c404 <CMW_UTILS_get_crop_config>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3419c2e8:	683b      	ldr	r3, [r7, #0]
3419c2ea:	68db      	ldr	r3, [r3, #12]
3419c2ec:	ee07 3a90 	vmov	s15, r3
3419c2f0:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c2f4:	687b      	ldr	r3, [r7, #4]
3419c2f6:	681b      	ldr	r3, [r3, #0]
3419c2f8:	ee07 3a90 	vmov	s15, r3
3419c2fc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c300:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c304:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3419c308:	683b      	ldr	r3, [r7, #0]
3419c30a:	689b      	ldr	r3, [r3, #8]
3419c30c:	ee07 3a90 	vmov	s15, r3
3419c310:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c314:	687b      	ldr	r3, [r7, #4]
3419c316:	685b      	ldr	r3, [r3, #4]
3419c318:	ee07 3a90 	vmov	s15, r3
3419c31c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c320:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c324:	edc7 7a05 	vstr	s15, [r7, #20]
3419c328:	e05e      	b.n	3419c3e8 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
3419c32a:	687b      	ldr	r3, [r7, #4]
3419c32c:	699b      	ldr	r3, [r3, #24]
3419c32e:	2b01      	cmp	r3, #1
3419c330:	d11e      	bne.n	3419c370 <CMW_UTILS_GetPipeConfig+0xc0>
  {
    ratio_width = (float)cam_width / p_conf->output_width;
3419c332:	68fb      	ldr	r3, [r7, #12]
3419c334:	ee07 3a90 	vmov	s15, r3
3419c338:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c33c:	687b      	ldr	r3, [r7, #4]
3419c33e:	681b      	ldr	r3, [r3, #0]
3419c340:	ee07 3a90 	vmov	s15, r3
3419c344:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c348:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c34c:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)cam_height / p_conf->output_height;
3419c350:	68bb      	ldr	r3, [r7, #8]
3419c352:	ee07 3a90 	vmov	s15, r3
3419c356:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c35a:	687b      	ldr	r3, [r7, #4]
3419c35c:	685b      	ldr	r3, [r3, #4]
3419c35e:	ee07 3a90 	vmov	s15, r3
3419c362:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c366:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c36a:	edc7 7a05 	vstr	s15, [r7, #20]
3419c36e:	e03b      	b.n	3419c3e8 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
3419c370:	687b      	ldr	r3, [r7, #4]
3419c372:	699b      	ldr	r3, [r3, #24]
3419c374:	2b02      	cmp	r3, #2
3419c376:	d111      	bne.n	3419c39c <CMW_UTILS_GetPipeConfig+0xec>
  {
    ratio_height = (float) cam_height / p_conf->output_height;
3419c378:	68bb      	ldr	r3, [r7, #8]
3419c37a:	ee07 3a90 	vmov	s15, r3
3419c37e:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c382:	687b      	ldr	r3, [r7, #4]
3419c384:	685b      	ldr	r3, [r3, #4]
3419c386:	ee07 3a90 	vmov	s15, r3
3419c38a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c38e:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c392:	edc7 7a05 	vstr	s15, [r7, #20]
    ratio_width = (float) ratio_height;
3419c396:	697b      	ldr	r3, [r7, #20]
3419c398:	613b      	str	r3, [r7, #16]
3419c39a:	e025      	b.n	3419c3e8 <CMW_UTILS_GetPipeConfig+0x138>
  }
  else
  {
    CMW_UTILS_get_crop_config_from_manual(&p_conf->manual_conf, crop);
3419c39c:	687b      	ldr	r3, [r7, #4]
3419c39e:	331c      	adds	r3, #28
3419c3a0:	6839      	ldr	r1, [r7, #0]
3419c3a2:	4618      	mov	r0, r3
3419c3a4:	f000 f8f0 	bl	3419c588 <CMW_UTILS_get_crop_config_from_manual>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3419c3a8:	683b      	ldr	r3, [r7, #0]
3419c3aa:	68db      	ldr	r3, [r3, #12]
3419c3ac:	ee07 3a90 	vmov	s15, r3
3419c3b0:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c3b4:	687b      	ldr	r3, [r7, #4]
3419c3b6:	681b      	ldr	r3, [r3, #0]
3419c3b8:	ee07 3a90 	vmov	s15, r3
3419c3bc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c3c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c3c4:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3419c3c8:	683b      	ldr	r3, [r7, #0]
3419c3ca:	689b      	ldr	r3, [r3, #8]
3419c3cc:	ee07 3a90 	vmov	s15, r3
3419c3d0:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c3d4:	687b      	ldr	r3, [r7, #4]
3419c3d6:	685b      	ldr	r3, [r3, #4]
3419c3d8:	ee07 3a90 	vmov	s15, r3
3419c3dc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c3e0:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c3e4:	edc7 7a05 	vstr	s15, [r7, #20]
  }

  CMW_UTILS_get_scale_configs(p_conf, ratio_width, ratio_height, dec, down);
3419c3e8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3419c3ea:	6a39      	ldr	r1, [r7, #32]
3419c3ec:	edd7 0a05 	vldr	s1, [r7, #20]
3419c3f0:	ed97 0a04 	vldr	s0, [r7, #16]
3419c3f4:	6878      	ldr	r0, [r7, #4]
3419c3f6:	f000 f98f 	bl	3419c718 <CMW_UTILS_get_scale_configs>
}
3419c3fa:	bf00      	nop
3419c3fc:	3718      	adds	r7, #24
3419c3fe:	46bd      	mov	sp, r7
3419c400:	bd80      	pop	{r7, pc}
	...

3419c404 <CMW_UTILS_get_crop_config>:

static void CMW_UTILS_get_crop_config(uint32_t cam_width, uint32_t cam_height, uint32_t pipe_width, uint32_t pipe_height, DCMIPP_CropConfTypeDef *crop)
{
3419c404:	b580      	push	{r7, lr}
3419c406:	b088      	sub	sp, #32
3419c408:	af00      	add	r7, sp, #0
3419c40a:	60f8      	str	r0, [r7, #12]
3419c40c:	60b9      	str	r1, [r7, #8]
3419c40e:	607a      	str	r2, [r7, #4]
3419c410:	603b      	str	r3, [r7, #0]
  const float ratio_width = (float)cam_width / pipe_width ;
3419c412:	68fb      	ldr	r3, [r7, #12]
3419c414:	ee07 3a90 	vmov	s15, r3
3419c418:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c41c:	687b      	ldr	r3, [r7, #4]
3419c41e:	ee07 3a90 	vmov	s15, r3
3419c422:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c426:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c42a:	edc7 7a07 	vstr	s15, [r7, #28]
  const float ratio_height = (float)cam_height / pipe_height;
3419c42e:	68bb      	ldr	r3, [r7, #8]
3419c430:	ee07 3a90 	vmov	s15, r3
3419c434:	eef8 6a67 	vcvt.f32.u32	s13, s15
3419c438:	683b      	ldr	r3, [r7, #0]
3419c43a:	ee07 3a90 	vmov	s15, r3
3419c43e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c442:	eec6 7a87 	vdiv.f32	s15, s13, s14
3419c446:	edc7 7a06 	vstr	s15, [r7, #24]
  const float ratio = MIN(ratio_width, ratio_height);
3419c44a:	ed97 7a07 	vldr	s14, [r7, #28]
3419c44e:	edd7 7a06 	vldr	s15, [r7, #24]
3419c452:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419c456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c45a:	d501      	bpl.n	3419c460 <CMW_UTILS_get_crop_config+0x5c>
3419c45c:	69fb      	ldr	r3, [r7, #28]
3419c45e:	e000      	b.n	3419c462 <CMW_UTILS_get_crop_config+0x5e>
3419c460:	69bb      	ldr	r3, [r7, #24]
3419c462:	617b      	str	r3, [r7, #20]

  assert(ratio >= 1);
3419c464:	edd7 7a05 	vldr	s15, [r7, #20]
3419c468:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3419c46c:	eef4 7ac7 	vcmpe.f32	s15, s14
3419c470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c474:	da05      	bge.n	3419c482 <CMW_UTILS_get_crop_config+0x7e>
3419c476:	4b3f      	ldr	r3, [pc, #252]	@ (3419c574 <CMW_UTILS_get_crop_config+0x170>)
3419c478:	4a3f      	ldr	r2, [pc, #252]	@ (3419c578 <CMW_UTILS_get_crop_config+0x174>)
3419c47a:	214f      	movs	r1, #79	@ 0x4f
3419c47c:	483f      	ldr	r0, [pc, #252]	@ (3419c57c <CMW_UTILS_get_crop_config+0x178>)
3419c47e:	f008 fdad 	bl	341a4fdc <__assert_func>
  assert(ratio < 64);
3419c482:	edd7 7a05 	vldr	s15, [r7, #20]
3419c486:	ed9f 7a3e 	vldr	s14, [pc, #248]	@ 3419c580 <CMW_UTILS_get_crop_config+0x17c>
3419c48a:	eef4 7ac7 	vcmpe.f32	s15, s14
3419c48e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c492:	d405      	bmi.n	3419c4a0 <CMW_UTILS_get_crop_config+0x9c>
3419c494:	4b3b      	ldr	r3, [pc, #236]	@ (3419c584 <CMW_UTILS_get_crop_config+0x180>)
3419c496:	4a38      	ldr	r2, [pc, #224]	@ (3419c578 <CMW_UTILS_get_crop_config+0x174>)
3419c498:	2150      	movs	r1, #80	@ 0x50
3419c49a:	4838      	ldr	r0, [pc, #224]	@ (3419c57c <CMW_UTILS_get_crop_config+0x178>)
3419c49c:	f008 fd9e 	bl	341a4fdc <__assert_func>

  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3419c4a0:	687b      	ldr	r3, [r7, #4]
3419c4a2:	ee07 3a90 	vmov	s15, r3
3419c4a6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c4aa:	edd7 7a05 	vldr	s15, [r7, #20]
3419c4ae:	ee27 7a27 	vmul.f32	s14, s14, s15
3419c4b2:	68fb      	ldr	r3, [r7, #12]
3419c4b4:	ee07 3a90 	vmov	s15, r3
3419c4b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419c4bc:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419c4c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c4c4:	d50b      	bpl.n	3419c4de <CMW_UTILS_get_crop_config+0xda>
3419c4c6:	687b      	ldr	r3, [r7, #4]
3419c4c8:	ee07 3a90 	vmov	s15, r3
3419c4cc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c4d0:	edd7 7a05 	vldr	s15, [r7, #20]
3419c4d4:	ee67 7a27 	vmul.f32	s15, s14, s15
3419c4d8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c4dc:	e006      	b.n	3419c4ec <CMW_UTILS_get_crop_config+0xe8>
3419c4de:	68fb      	ldr	r3, [r7, #12]
3419c4e0:	ee07 3a90 	vmov	s15, r3
3419c4e4:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419c4e8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c4ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c4ee:	edc3 7a03 	vstr	s15, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3419c4f2:	683b      	ldr	r3, [r7, #0]
3419c4f4:	ee07 3a90 	vmov	s15, r3
3419c4f8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c4fc:	edd7 7a05 	vldr	s15, [r7, #20]
3419c500:	ee27 7a27 	vmul.f32	s14, s14, s15
3419c504:	68bb      	ldr	r3, [r7, #8]
3419c506:	ee07 3a90 	vmov	s15, r3
3419c50a:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419c50e:	eeb4 7ae7 	vcmpe.f32	s14, s15
3419c512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c516:	d50b      	bpl.n	3419c530 <CMW_UTILS_get_crop_config+0x12c>
3419c518:	683b      	ldr	r3, [r7, #0]
3419c51a:	ee07 3a90 	vmov	s15, r3
3419c51e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419c522:	edd7 7a05 	vldr	s15, [r7, #20]
3419c526:	ee67 7a27 	vmul.f32	s15, s14, s15
3419c52a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c52e:	e006      	b.n	3419c53e <CMW_UTILS_get_crop_config+0x13a>
3419c530:	68bb      	ldr	r3, [r7, #8]
3419c532:	ee07 3a90 	vmov	s15, r3
3419c536:	eef8 7a67 	vcvt.f32.u32	s15, s15
3419c53a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c53e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c540:	edc3 7a02 	vstr	s15, [r3, #8]
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
3419c544:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c546:	68db      	ldr	r3, [r3, #12]
3419c548:	68fa      	ldr	r2, [r7, #12]
3419c54a:	1ad3      	subs	r3, r2, r3
3419c54c:	3301      	adds	r3, #1
3419c54e:	085a      	lsrs	r2, r3, #1
3419c550:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c552:	605a      	str	r2, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3419c554:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c556:	689b      	ldr	r3, [r3, #8]
3419c558:	68ba      	ldr	r2, [r7, #8]
3419c55a:	1ad3      	subs	r3, r2, r3
3419c55c:	3301      	adds	r3, #1
3419c55e:	085a      	lsrs	r2, r3, #1
3419c560:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c562:	601a      	str	r2, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
3419c564:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3419c566:	2200      	movs	r2, #0
3419c568:	611a      	str	r2, [r3, #16]
}
3419c56a:	bf00      	nop
3419c56c:	3720      	adds	r7, #32
3419c56e:	46bd      	mov	sp, r7
3419c570:	bd80      	pop	{r7, pc}
3419c572:	bf00      	nop
3419c574:	341a7610 	.word	0x341a7610
3419c578:	341a7f74 	.word	0x341a7f74
3419c57c:	341a761c 	.word	0x341a761c
3419c580:	42800000 	.word	0x42800000
3419c584:	341a764c 	.word	0x341a764c

3419c588 <CMW_UTILS_get_crop_config_from_manual>:

static void CMW_UTILS_get_crop_config_from_manual(CMW_Manual_roi_area_t *roi, DCMIPP_CropConfTypeDef *crop)
{
3419c588:	b480      	push	{r7}
3419c58a:	b083      	sub	sp, #12
3419c58c:	af00      	add	r7, sp, #0
3419c58e:	6078      	str	r0, [r7, #4]
3419c590:	6039      	str	r1, [r7, #0]
  crop->HSize = roi->width;
3419c592:	687b      	ldr	r3, [r7, #4]
3419c594:	681a      	ldr	r2, [r3, #0]
3419c596:	683b      	ldr	r3, [r7, #0]
3419c598:	60da      	str	r2, [r3, #12]
  crop->VSize = roi->height;
3419c59a:	687b      	ldr	r3, [r7, #4]
3419c59c:	685a      	ldr	r2, [r3, #4]
3419c59e:	683b      	ldr	r3, [r7, #0]
3419c5a0:	609a      	str	r2, [r3, #8]
  crop->HStart = roi->offset_x;
3419c5a2:	687b      	ldr	r3, [r7, #4]
3419c5a4:	689a      	ldr	r2, [r3, #8]
3419c5a6:	683b      	ldr	r3, [r7, #0]
3419c5a8:	605a      	str	r2, [r3, #4]
  crop->VStart = roi->offset_y;
3419c5aa:	687b      	ldr	r3, [r7, #4]
3419c5ac:	68da      	ldr	r2, [r3, #12]
3419c5ae:	683b      	ldr	r3, [r7, #0]
3419c5b0:	601a      	str	r2, [r3, #0]
}
3419c5b2:	bf00      	nop
3419c5b4:	370c      	adds	r7, #12
3419c5b6:	46bd      	mov	sp, r7
3419c5b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c5bc:	4770      	bx	lr
	...

3419c5c0 <CMW_UTILS_get_down_config>:

static void CMW_UTILS_get_down_config(float ratio_width, float ratio_height, int width, int height, DCMIPP_DownsizeTypeDef *down)
{
3419c5c0:	b480      	push	{r7}
3419c5c2:	b087      	sub	sp, #28
3419c5c4:	af00      	add	r7, sp, #0
3419c5c6:	ed87 0a05 	vstr	s0, [r7, #20]
3419c5ca:	edc7 0a04 	vstr	s1, [r7, #16]
3419c5ce:	60f8      	str	r0, [r7, #12]
3419c5d0:	60b9      	str	r1, [r7, #8]
3419c5d2:	607a      	str	r2, [r7, #4]
  down->HRatio = (uint32_t) (8192 * ratio_width);
3419c5d4:	edd7 7a05 	vldr	s15, [r7, #20]
3419c5d8:	ed9f 7a17 	vldr	s14, [pc, #92]	@ 3419c638 <CMW_UTILS_get_down_config+0x78>
3419c5dc:	ee67 7a87 	vmul.f32	s15, s15, s14
3419c5e0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c5e4:	ee17 2a90 	vmov	r2, s15
3419c5e8:	687b      	ldr	r3, [r7, #4]
3419c5ea:	60da      	str	r2, [r3, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
3419c5ec:	edd7 7a04 	vldr	s15, [r7, #16]
3419c5f0:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 3419c638 <CMW_UTILS_get_down_config+0x78>
3419c5f4:	ee67 7a87 	vmul.f32	s15, s15, s14
3419c5f8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419c5fc:	ee17 2a90 	vmov	r2, s15
3419c600:	687b      	ldr	r3, [r7, #4]
3419c602:	609a      	str	r2, [r3, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3419c604:	687b      	ldr	r3, [r7, #4]
3419c606:	68db      	ldr	r3, [r3, #12]
3419c608:	4a0c      	ldr	r2, [pc, #48]	@ (3419c63c <CMW_UTILS_get_down_config+0x7c>)
3419c60a:	fbb2 f2f3 	udiv	r2, r2, r3
3419c60e:	687b      	ldr	r3, [r7, #4]
3419c610:	615a      	str	r2, [r3, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
3419c612:	687b      	ldr	r3, [r7, #4]
3419c614:	689b      	ldr	r3, [r3, #8]
3419c616:	4a09      	ldr	r2, [pc, #36]	@ (3419c63c <CMW_UTILS_get_down_config+0x7c>)
3419c618:	fbb2 f2f3 	udiv	r2, r2, r3
3419c61c:	687b      	ldr	r3, [r7, #4]
3419c61e:	611a      	str	r2, [r3, #16]
  down->HSize = width;
3419c620:	68fa      	ldr	r2, [r7, #12]
3419c622:	687b      	ldr	r3, [r7, #4]
3419c624:	605a      	str	r2, [r3, #4]
  down->VSize = height;
3419c626:	68ba      	ldr	r2, [r7, #8]
3419c628:	687b      	ldr	r3, [r7, #4]
3419c62a:	601a      	str	r2, [r3, #0]
}
3419c62c:	bf00      	nop
3419c62e:	371c      	adds	r7, #28
3419c630:	46bd      	mov	sp, r7
3419c632:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c636:	4770      	bx	lr
3419c638:	46000000 	.word	0x46000000
3419c63c:	007fffff 	.word	0x007fffff

3419c640 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>:

static uint32_t CMW_UTILS_get_dec_ratio_from_decimal_ratio(int dec_ratio, int is_vertical)
{
3419c640:	b580      	push	{r7, lr}
3419c642:	b082      	sub	sp, #8
3419c644:	af00      	add	r7, sp, #0
3419c646:	6078      	str	r0, [r7, #4]
3419c648:	6039      	str	r1, [r7, #0]
  switch (dec_ratio) {
3419c64a:	687b      	ldr	r3, [r7, #4]
3419c64c:	3b01      	subs	r3, #1
3419c64e:	2b07      	cmp	r3, #7
3419c650:	d829      	bhi.n	3419c6a6 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x66>
3419c652:	a201      	add	r2, pc, #4	@ (adr r2, 3419c658 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x18>)
3419c654:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419c658:	3419c679 	.word	0x3419c679
3419c65c:	3419c67d 	.word	0x3419c67d
3419c660:	3419c6a7 	.word	0x3419c6a7
3419c664:	3419c68b 	.word	0x3419c68b
3419c668:	3419c6a7 	.word	0x3419c6a7
3419c66c:	3419c6a7 	.word	0x3419c6a7
3419c670:	3419c6a7 	.word	0x3419c6a7
3419c674:	3419c699 	.word	0x3419c699
  case 1:
    return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
3419c678:	2300      	movs	r3, #0
3419c67a:	e01a      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 2:
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
3419c67c:	683b      	ldr	r3, [r7, #0]
3419c67e:	2b00      	cmp	r3, #0
3419c680:	d001      	beq.n	3419c686 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x46>
3419c682:	2308      	movs	r3, #8
3419c684:	e015      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419c686:	2302      	movs	r3, #2
3419c688:	e013      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 4:
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
3419c68a:	683b      	ldr	r3, [r7, #0]
3419c68c:	2b00      	cmp	r3, #0
3419c68e:	d001      	beq.n	3419c694 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x54>
3419c690:	2310      	movs	r3, #16
3419c692:	e00e      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419c694:	2304      	movs	r3, #4
3419c696:	e00c      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 8:
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
3419c698:	683b      	ldr	r3, [r7, #0]
3419c69a:	2b00      	cmp	r3, #0
3419c69c:	d001      	beq.n	3419c6a2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x62>
3419c69e:	2318      	movs	r3, #24
3419c6a0:	e007      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3419c6a2:	2306      	movs	r3, #6
3419c6a4:	e005      	b.n	3419c6b2 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  default:
    assert(0);
3419c6a6:	4b05      	ldr	r3, [pc, #20]	@ (3419c6bc <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x7c>)
3419c6a8:	4a05      	ldr	r2, [pc, #20]	@ (3419c6c0 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x80>)
3419c6aa:	2177      	movs	r1, #119	@ 0x77
3419c6ac:	4805      	ldr	r0, [pc, #20]	@ (3419c6c4 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x84>)
3419c6ae:	f008 fc95 	bl	341a4fdc <__assert_func>
  }

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}
3419c6b2:	4618      	mov	r0, r3
3419c6b4:	3708      	adds	r7, #8
3419c6b6:	46bd      	mov	sp, r7
3419c6b8:	bd80      	pop	{r7, pc}
3419c6ba:	bf00      	nop
3419c6bc:	341a7658 	.word	0x341a7658
3419c6c0:	341a7f90 	.word	0x341a7f90
3419c6c4:	341a761c 	.word	0x341a761c

3419c6c8 <CMW_UTILS_get_dec_ratio_and_update>:

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
3419c6c8:	b580      	push	{r7, lr}
3419c6ca:	b084      	sub	sp, #16
3419c6cc:	af00      	add	r7, sp, #0
3419c6ce:	6078      	str	r0, [r7, #4]
3419c6d0:	6039      	str	r1, [r7, #0]
  int dec_ratio = 1;
3419c6d2:	2301      	movs	r3, #1
3419c6d4:	60fb      	str	r3, [r7, #12]

  while (*ratio >= 8) {
3419c6d6:	e00c      	b.n	3419c6f2 <CMW_UTILS_get_dec_ratio_and_update+0x2a>
    dec_ratio *= 2;
3419c6d8:	68fb      	ldr	r3, [r7, #12]
3419c6da:	005b      	lsls	r3, r3, #1
3419c6dc:	60fb      	str	r3, [r7, #12]
    *ratio /= 2;
3419c6de:	687b      	ldr	r3, [r7, #4]
3419c6e0:	ed93 7a00 	vldr	s14, [r3]
3419c6e4:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3419c6e8:	eec7 7a26 	vdiv.f32	s15, s14, s13
3419c6ec:	687b      	ldr	r3, [r7, #4]
3419c6ee:	edc3 7a00 	vstr	s15, [r3]
  while (*ratio >= 8) {
3419c6f2:	687b      	ldr	r3, [r7, #4]
3419c6f4:	edd3 7a00 	vldr	s15, [r3]
3419c6f8:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
3419c6fc:	eef4 7ac7 	vcmpe.f32	s15, s14
3419c700:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3419c704:	dae8      	bge.n	3419c6d8 <CMW_UTILS_get_dec_ratio_and_update+0x10>
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
3419c706:	6839      	ldr	r1, [r7, #0]
3419c708:	68f8      	ldr	r0, [r7, #12]
3419c70a:	f7ff ff99 	bl	3419c640 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>
3419c70e:	4603      	mov	r3, r0
}
3419c710:	4618      	mov	r0, r3
3419c712:	3710      	adds	r7, #16
3419c714:	46bd      	mov	sp, r7
3419c716:	bd80      	pop	{r7, pc}

3419c718 <CMW_UTILS_get_scale_configs>:

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
3419c718:	b580      	push	{r7, lr}
3419c71a:	b086      	sub	sp, #24
3419c71c:	af00      	add	r7, sp, #0
3419c71e:	6178      	str	r0, [r7, #20]
3419c720:	ed87 0a04 	vstr	s0, [r7, #16]
3419c724:	edc7 0a03 	vstr	s1, [r7, #12]
3419c728:	60b9      	str	r1, [r7, #8]
3419c72a:	607a      	str	r2, [r7, #4]
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
3419c72c:	f107 0310 	add.w	r3, r7, #16
3419c730:	2100      	movs	r1, #0
3419c732:	4618      	mov	r0, r3
3419c734:	f7ff ffc8 	bl	3419c6c8 <CMW_UTILS_get_dec_ratio_and_update>
3419c738:	4602      	mov	r2, r0
3419c73a:	68bb      	ldr	r3, [r7, #8]
3419c73c:	605a      	str	r2, [r3, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3419c73e:	f107 030c 	add.w	r3, r7, #12
3419c742:	2101      	movs	r1, #1
3419c744:	4618      	mov	r0, r3
3419c746:	f7ff ffbf 	bl	3419c6c8 <CMW_UTILS_get_dec_ratio_and_update>
3419c74a:	4602      	mov	r2, r0
3419c74c:	68bb      	ldr	r3, [r7, #8]
3419c74e:	601a      	str	r2, [r3, #0]
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
3419c750:	edd7 7a04 	vldr	s15, [r7, #16]
3419c754:	ed97 7a03 	vldr	s14, [r7, #12]
3419c758:	697b      	ldr	r3, [r7, #20]
3419c75a:	681b      	ldr	r3, [r3, #0]
3419c75c:	4618      	mov	r0, r3
3419c75e:	697b      	ldr	r3, [r7, #20]
3419c760:	685b      	ldr	r3, [r3, #4]
3419c762:	687a      	ldr	r2, [r7, #4]
3419c764:	4619      	mov	r1, r3
3419c766:	eef0 0a47 	vmov.f32	s1, s14
3419c76a:	eeb0 0a67 	vmov.f32	s0, s15
3419c76e:	f7ff ff27 	bl	3419c5c0 <CMW_UTILS_get_down_config>
}
3419c772:	bf00      	nop
3419c774:	3718      	adds	r7, #24
3419c776:	46bd      	mov	sp, r7
3419c778:	bd80      	pop	{r7, pc}

3419c77a <CMW_IMX335_GetResType>:

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))


static int CMW_IMX335_GetResType(uint32_t width, uint32_t height, uint32_t*res)
{
3419c77a:	b480      	push	{r7}
3419c77c:	b085      	sub	sp, #20
3419c77e:	af00      	add	r7, sp, #0
3419c780:	60f8      	str	r0, [r7, #12]
3419c782:	60b9      	str	r1, [r7, #8]
3419c784:	607a      	str	r2, [r7, #4]
  if (width == 2592 && height == 1944)
3419c786:	68fb      	ldr	r3, [r7, #12]
3419c788:	f5b3 6f22 	cmp.w	r3, #2592	@ 0xa20
3419c78c:	d108      	bne.n	3419c7a0 <CMW_IMX335_GetResType+0x26>
3419c78e:	68bb      	ldr	r3, [r7, #8]
3419c790:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
3419c794:	d104      	bne.n	3419c7a0 <CMW_IMX335_GetResType+0x26>
  {
    *res = IMX335_R2592_1944;
3419c796:	687b      	ldr	r3, [r7, #4]
3419c798:	2206      	movs	r2, #6
3419c79a:	601a      	str	r2, [r3, #0]
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
  }
  return 0;
3419c79c:	2300      	movs	r3, #0
3419c79e:	e001      	b.n	3419c7a4 <CMW_IMX335_GetResType+0x2a>
    return CMW_ERROR_WRONG_PARAM;
3419c7a0:	f06f 0301 	mvn.w	r3, #1
}
3419c7a4:	4618      	mov	r0, r3
3419c7a6:	3714      	adds	r7, #20
3419c7a8:	46bd      	mov	sp, r7
3419c7aa:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c7ae:	4770      	bx	lr

3419c7b0 <CMW_IMX335_getMirrorFlipConfig>:

static int32_t CMW_IMX335_getMirrorFlipConfig(uint32_t Config)
{
3419c7b0:	b480      	push	{r7}
3419c7b2:	b085      	sub	sp, #20
3419c7b4:	af00      	add	r7, sp, #0
3419c7b6:	6078      	str	r0, [r7, #4]
  int32_t ret;

  switch (Config)
3419c7b8:	687b      	ldr	r3, [r7, #4]
3419c7ba:	2b02      	cmp	r3, #2
3419c7bc:	d00f      	beq.n	3419c7de <CMW_IMX335_getMirrorFlipConfig+0x2e>
3419c7be:	687b      	ldr	r3, [r7, #4]
3419c7c0:	2b02      	cmp	r3, #2
3419c7c2:	d80f      	bhi.n	3419c7e4 <CMW_IMX335_getMirrorFlipConfig+0x34>
3419c7c4:	687b      	ldr	r3, [r7, #4]
3419c7c6:	2b00      	cmp	r3, #0
3419c7c8:	d003      	beq.n	3419c7d2 <CMW_IMX335_getMirrorFlipConfig+0x22>
3419c7ca:	687b      	ldr	r3, [r7, #4]
3419c7cc:	2b01      	cmp	r3, #1
3419c7ce:	d003      	beq.n	3419c7d8 <CMW_IMX335_getMirrorFlipConfig+0x28>
3419c7d0:	e008      	b.n	3419c7e4 <CMW_IMX335_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = IMX335_MIRROR_FLIP_NONE;
3419c7d2:	2300      	movs	r3, #0
3419c7d4:	60fb      	str	r3, [r7, #12]
      break;
3419c7d6:	e008      	b.n	3419c7ea <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = IMX335_FLIP;
3419c7d8:	2301      	movs	r3, #1
3419c7da:	60fb      	str	r3, [r7, #12]
      break;
3419c7dc:	e005      	b.n	3419c7ea <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = IMX335_MIRROR;
3419c7de:	2302      	movs	r3, #2
3419c7e0:	60fb      	str	r3, [r7, #12]
      break;
3419c7e2:	e002      	b.n	3419c7ea <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = IMX335_MIRROR_FLIP;
3419c7e4:	2303      	movs	r3, #3
3419c7e6:	60fb      	str	r3, [r7, #12]
      break;
3419c7e8:	bf00      	nop
  }

  return ret;
3419c7ea:	68fb      	ldr	r3, [r7, #12]
}
3419c7ec:	4618      	mov	r0, r3
3419c7ee:	3714      	adds	r7, #20
3419c7f0:	46bd      	mov	sp, r7
3419c7f2:	f85d 7b04 	ldr.w	r7, [sp], #4
3419c7f6:	4770      	bx	lr

3419c7f8 <CMW_IMX335_DeInit>:

static int32_t CMW_IMX335_DeInit(void *io_ctx)
{
3419c7f8:	b580      	push	{r7, lr}
3419c7fa:	b084      	sub	sp, #16
3419c7fc:	af00      	add	r7, sp, #0
3419c7fe:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419c800:	2300      	movs	r3, #0
3419c802:	60fb      	str	r3, [r7, #12]
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419c804:	687b      	ldr	r3, [r7, #4]
3419c806:	3330      	adds	r3, #48	@ 0x30
3419c808:	4618      	mov	r0, r3
3419c80a:	f7fc fe91 	bl	34199530 <ISP_DeInit>
3419c80e:	4603      	mov	r3, r0
3419c810:	60fb      	str	r3, [r7, #12]
  if (ret)
3419c812:	68fb      	ldr	r3, [r7, #12]
3419c814:	2b00      	cmp	r3, #0
3419c816:	d002      	beq.n	3419c81e <CMW_IMX335_DeInit+0x26>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c818:	f06f 0304 	mvn.w	r3, #4
3419c81c:	e00c      	b.n	3419c838 <CMW_IMX335_DeInit+0x40>
  }

  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3419c81e:	687b      	ldr	r3, [r7, #4]
3419c820:	3308      	adds	r3, #8
3419c822:	4618      	mov	r0, r3
3419c824:	f001 ff62 	bl	3419e6ec <IMX335_DeInit>
3419c828:	60f8      	str	r0, [r7, #12]
  if (ret)
3419c82a:	68fb      	ldr	r3, [r7, #12]
3419c82c:	2b00      	cmp	r3, #0
3419c82e:	d002      	beq.n	3419c836 <CMW_IMX335_DeInit+0x3e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419c830:	f06f 0304 	mvn.w	r3, #4
3419c834:	e000      	b.n	3419c838 <CMW_IMX335_DeInit+0x40>
  }
  return ret;
3419c836:	68fb      	ldr	r3, [r7, #12]
}
3419c838:	4618      	mov	r0, r3
3419c83a:	3710      	adds	r7, #16
3419c83c:	46bd      	mov	sp, r7
3419c83e:	bd80      	pop	{r7, pc}

3419c840 <CMW_IMX335_ReadID>:

static int32_t CMW_IMX335_ReadID(void *io_ctx, uint32_t *Id)
{
3419c840:	b580      	push	{r7, lr}
3419c842:	b082      	sub	sp, #8
3419c844:	af00      	add	r7, sp, #0
3419c846:	6078      	str	r0, [r7, #4]
3419c848:	6039      	str	r1, [r7, #0]
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
3419c84a:	687b      	ldr	r3, [r7, #4]
3419c84c:	3308      	adds	r3, #8
3419c84e:	6839      	ldr	r1, [r7, #0]
3419c850:	4618      	mov	r0, r3
3419c852:	f001 ff5f 	bl	3419e714 <IMX335_ReadID>
3419c856:	4603      	mov	r3, r0
}
3419c858:	4618      	mov	r0, r3
3419c85a:	3708      	adds	r7, #8
3419c85c:	46bd      	mov	sp, r7
3419c85e:	bd80      	pop	{r7, pc}

3419c860 <CMW_IMX335_SetGain>:

static int32_t CMW_IMX335_SetGain(void *io_ctx, int32_t gain)
{
3419c860:	b580      	push	{r7, lr}
3419c862:	b082      	sub	sp, #8
3419c864:	af00      	add	r7, sp, #0
3419c866:	6078      	str	r0, [r7, #4]
3419c868:	6039      	str	r1, [r7, #0]
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
3419c86a:	687b      	ldr	r3, [r7, #4]
3419c86c:	3308      	adds	r3, #8
3419c86e:	6839      	ldr	r1, [r7, #0]
3419c870:	4618      	mov	r0, r3
3419c872:	f001 ff73 	bl	3419e75c <IMX335_SetGain>
3419c876:	4603      	mov	r3, r0
}
3419c878:	4618      	mov	r0, r3
3419c87a:	3708      	adds	r7, #8
3419c87c:	46bd      	mov	sp, r7
3419c87e:	bd80      	pop	{r7, pc}

3419c880 <CMW_IMX335_SetExposure>:

static int32_t CMW_IMX335_SetExposure(void *io_ctx, int32_t exposure)
{
3419c880:	b580      	push	{r7, lr}
3419c882:	b082      	sub	sp, #8
3419c884:	af00      	add	r7, sp, #0
3419c886:	6078      	str	r0, [r7, #4]
3419c888:	6039      	str	r1, [r7, #0]
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
3419c88a:	687b      	ldr	r3, [r7, #4]
3419c88c:	3308      	adds	r3, #8
3419c88e:	6839      	ldr	r1, [r7, #0]
3419c890:	4618      	mov	r0, r3
3419c892:	f001 ffbb 	bl	3419e80c <IMX335_SetExposure>
3419c896:	4603      	mov	r3, r0
}
3419c898:	4618      	mov	r0, r3
3419c89a:	3708      	adds	r7, #8
3419c89c:	46bd      	mov	sp, r7
3419c89e:	bd80      	pop	{r7, pc}

3419c8a0 <CMW_IMX335_SetWBRefMode>:
  * @param  Automatic automatic mode enable/disable
  * @param  RefColorTemp color temperature if automatic mode is disabled
  * @retval Component status
  */
int32_t CMW_IMX335_SetWBRefMode(void *io_ctx, uint8_t Automatic, uint32_t RefColorTemp)
{
3419c8a0:	b580      	push	{r7, lr}
3419c8a2:	b086      	sub	sp, #24
3419c8a4:	af00      	add	r7, sp, #0
3419c8a6:	60f8      	str	r0, [r7, #12]
3419c8a8:	460b      	mov	r3, r1
3419c8aa:	607a      	str	r2, [r7, #4]
3419c8ac:	72fb      	strb	r3, [r7, #11]
  int ret = CMW_ERROR_NONE;
3419c8ae:	2300      	movs	r3, #0
3419c8b0:	617b      	str	r3, [r7, #20]

  ret = ISP_SetWBRefMode(&((CMW_IMX335_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
3419c8b2:	68fb      	ldr	r3, [r7, #12]
3419c8b4:	3330      	adds	r3, #48	@ 0x30
3419c8b6:	7af9      	ldrb	r1, [r7, #11]
3419c8b8:	687a      	ldr	r2, [r7, #4]
3419c8ba:	4618      	mov	r0, r3
3419c8bc:	f7fc ff98 	bl	341997f0 <ISP_SetWBRefMode>
3419c8c0:	4603      	mov	r3, r0
3419c8c2:	617b      	str	r3, [r7, #20]
  if (ret)
3419c8c4:	697b      	ldr	r3, [r7, #20]
3419c8c6:	2b00      	cmp	r3, #0
3419c8c8:	d002      	beq.n	3419c8d0 <CMW_IMX335_SetWBRefMode+0x30>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c8ca:	f06f 0303 	mvn.w	r3, #3
3419c8ce:	e000      	b.n	3419c8d2 <CMW_IMX335_SetWBRefMode+0x32>
  }

  return CMW_ERROR_NONE;
3419c8d0:	2300      	movs	r3, #0
}
3419c8d2:	4618      	mov	r0, r3
3419c8d4:	3718      	adds	r7, #24
3419c8d6:	46bd      	mov	sp, r7
3419c8d8:	bd80      	pop	{r7, pc}

3419c8da <CMW_IMX335_ListWBRefModes>:
  * @param  io_ctx  pointer to component object
  * @param  RefColorTemp color temperature list
  * @retval Component status
  */
int32_t CMW_IMX335_ListWBRefModes(void *io_ctx, uint32_t RefColorTemp[])
{
3419c8da:	b580      	push	{r7, lr}
3419c8dc:	b084      	sub	sp, #16
3419c8de:	af00      	add	r7, sp, #0
3419c8e0:	6078      	str	r0, [r7, #4]
3419c8e2:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419c8e4:	2300      	movs	r3, #0
3419c8e6:	60fb      	str	r3, [r7, #12]

  ret = ISP_ListWBRefModes(&((CMW_IMX335_t *)io_ctx)->hIsp, RefColorTemp);
3419c8e8:	687b      	ldr	r3, [r7, #4]
3419c8ea:	3330      	adds	r3, #48	@ 0x30
3419c8ec:	6839      	ldr	r1, [r7, #0]
3419c8ee:	4618      	mov	r0, r3
3419c8f0:	f7fc ff68 	bl	341997c4 <ISP_ListWBRefModes>
3419c8f4:	4603      	mov	r3, r0
3419c8f6:	60fb      	str	r3, [r7, #12]
  if (ret)
3419c8f8:	68fb      	ldr	r3, [r7, #12]
3419c8fa:	2b00      	cmp	r3, #0
3419c8fc:	d002      	beq.n	3419c904 <CMW_IMX335_ListWBRefModes+0x2a>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419c8fe:	f06f 0303 	mvn.w	r3, #3
3419c902:	e000      	b.n	3419c906 <CMW_IMX335_ListWBRefModes+0x2c>
  }

  return CMW_ERROR_NONE;
3419c904:	2300      	movs	r3, #0
}
3419c906:	4618      	mov	r0, r3
3419c908:	3710      	adds	r7, #16
3419c90a:	46bd      	mov	sp, r7
3419c90c:	bd80      	pop	{r7, pc}

3419c90e <CMW_IMX335_SetFrequency>:

static int32_t CMW_IMX335_SetFrequency(void *io_ctx, int32_t frequency)
{
3419c90e:	b580      	push	{r7, lr}
3419c910:	b082      	sub	sp, #8
3419c912:	af00      	add	r7, sp, #0
3419c914:	6078      	str	r0, [r7, #4]
3419c916:	6039      	str	r1, [r7, #0]
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
3419c918:	687b      	ldr	r3, [r7, #4]
3419c91a:	3308      	adds	r3, #8
3419c91c:	6839      	ldr	r1, [r7, #0]
3419c91e:	4618      	mov	r0, r3
3419c920:	f001 ffe6 	bl	3419e8f0 <IMX335_SetFrequency>
3419c924:	4603      	mov	r3, r0
}
3419c926:	4618      	mov	r0, r3
3419c928:	3708      	adds	r7, #8
3419c92a:	46bd      	mov	sp, r7
3419c92c:	bd80      	pop	{r7, pc}
	...

3419c930 <CMW_IMX335_SetFramerate>:

static int32_t CMW_IMX335_SetFramerate(void *io_ctx, int32_t framerate)
{
3419c930:	b5b0      	push	{r4, r5, r7, lr}
3419c932:	b088      	sub	sp, #32
3419c934:	af00      	add	r7, sp, #0
3419c936:	6078      	str	r0, [r7, #4]
3419c938:	6039      	str	r1, [r7, #0]
  const int32_t available_imx335_fps[] = {10, 15, 20, 25, 30};
3419c93a:	4b14      	ldr	r3, [pc, #80]	@ (3419c98c <CMW_IMX335_SetFramerate+0x5c>)
3419c93c:	f107 0408 	add.w	r4, r7, #8
3419c940:	461d      	mov	r5, r3
3419c942:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3419c944:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3419c946:	682b      	ldr	r3, [r5, #0]
3419c948:	6023      	str	r3, [r4, #0]

  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
3419c94a:	2300      	movs	r3, #0
3419c94c:	61fb      	str	r3, [r7, #28]
3419c94e:	e013      	b.n	3419c978 <CMW_IMX335_SetFramerate+0x48>
    if (framerate == available_imx335_fps[i])
3419c950:	69fb      	ldr	r3, [r7, #28]
3419c952:	009b      	lsls	r3, r3, #2
3419c954:	3320      	adds	r3, #32
3419c956:	443b      	add	r3, r7
3419c958:	f853 3c18 	ldr.w	r3, [r3, #-24]
3419c95c:	683a      	ldr	r2, [r7, #0]
3419c95e:	429a      	cmp	r2, r3
3419c960:	d107      	bne.n	3419c972 <CMW_IMX335_SetFramerate+0x42>
      return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
3419c962:	687b      	ldr	r3, [r7, #4]
3419c964:	3308      	adds	r3, #8
3419c966:	6839      	ldr	r1, [r7, #0]
3419c968:	4618      	mov	r0, r3
3419c96a:	f002 f82b 	bl	3419e9c4 <IMX335_SetFramerate>
3419c96e:	4603      	mov	r3, r0
3419c970:	e007      	b.n	3419c982 <CMW_IMX335_SetFramerate+0x52>
  for (int i = 0; i < ARRAY_SIZE(available_imx335_fps); i++)
3419c972:	69fb      	ldr	r3, [r7, #28]
3419c974:	3301      	adds	r3, #1
3419c976:	61fb      	str	r3, [r7, #28]
3419c978:	69fb      	ldr	r3, [r7, #28]
3419c97a:	2b04      	cmp	r3, #4
3419c97c:	d9e8      	bls.n	3419c950 <CMW_IMX335_SetFramerate+0x20>

  return CMW_ERROR_WRONG_PARAM;
3419c97e:	f06f 0301 	mvn.w	r3, #1
}
3419c982:	4618      	mov	r0, r3
3419c984:	3720      	adds	r7, #32
3419c986:	46bd      	mov	sp, r7
3419c988:	bdb0      	pop	{r4, r5, r7, pc}
3419c98a:	bf00      	nop
3419c98c:	341a765c 	.word	0x341a765c

3419c990 <CMW_IMX335_SetMirrorFlip>:

static int32_t CMW_IMX335_SetMirrorFlip(void *io_ctx, uint32_t config)
{
3419c990:	b580      	push	{r7, lr}
3419c992:	b084      	sub	sp, #16
3419c994:	af00      	add	r7, sp, #0
3419c996:	6078      	str	r0, [r7, #4]
3419c998:	6039      	str	r1, [r7, #0]
  int32_t mirrorFlip = CMW_IMX335_getMirrorFlipConfig(config);
3419c99a:	6838      	ldr	r0, [r7, #0]
3419c99c:	f7ff ff08 	bl	3419c7b0 <CMW_IMX335_getMirrorFlipConfig>
3419c9a0:	60f8      	str	r0, [r7, #12]
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
3419c9a2:	687b      	ldr	r3, [r7, #4]
3419c9a4:	3308      	adds	r3, #8
3419c9a6:	68fa      	ldr	r2, [r7, #12]
3419c9a8:	4611      	mov	r1, r2
3419c9aa:	4618      	mov	r0, r3
3419c9ac:	f002 f88c 	bl	3419eac8 <IMX335_MirrorFlipConfig>
3419c9b0:	4603      	mov	r3, r0
}
3419c9b2:	4618      	mov	r0, r3
3419c9b4:	3710      	adds	r7, #16
3419c9b6:	46bd      	mov	sp, r7
3419c9b8:	bd80      	pop	{r7, pc}
	...

3419c9bc <CMW_IMX335_GetSensorInfo>:

static int32_t CMW_IMX335_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419c9bc:	b480      	push	{r7}
3419c9be:	b083      	sub	sp, #12
3419c9c0:	af00      	add	r7, sp, #0
3419c9c2:	6078      	str	r0, [r7, #4]
3419c9c4:	6039      	str	r1, [r7, #0]
  if ((io_ctx ==  NULL) || (info == NULL))
3419c9c6:	687b      	ldr	r3, [r7, #4]
3419c9c8:	2b00      	cmp	r3, #0
3419c9ca:	d002      	beq.n	3419c9d2 <CMW_IMX335_GetSensorInfo+0x16>
3419c9cc:	683b      	ldr	r3, [r7, #0]
3419c9ce:	2b00      	cmp	r3, #0
3419c9d0:	d102      	bne.n	3419c9d8 <CMW_IMX335_GetSensorInfo+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3419c9d2:	f06f 0301 	mvn.w	r3, #1
3419c9d6:	e025      	b.n	3419ca24 <CMW_IMX335_GetSensorInfo+0x68>
  }

  if (sizeof(info->name) >= strlen(IMX335_NAME) + 1)
  {
    strcpy(info->name, IMX335_NAME);
3419c9d8:	683b      	ldr	r3, [r7, #0]
3419c9da:	4a15      	ldr	r2, [pc, #84]	@ (3419ca30 <CMW_IMX335_GetSensorInfo+0x74>)
3419c9dc:	6810      	ldr	r0, [r2, #0]
3419c9de:	6018      	str	r0, [r3, #0]
3419c9e0:	8891      	ldrh	r1, [r2, #4]
3419c9e2:	7992      	ldrb	r2, [r2, #6]
3419c9e4:	8099      	strh	r1, [r3, #4]
3419c9e6:	719a      	strb	r2, [r3, #6]
  else
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  info->bayer_pattern = IMX335_BAYER_PATTERN;
3419c9e8:	683b      	ldr	r3, [r7, #0]
3419c9ea:	2200      	movs	r2, #0
3419c9ec:	f883 2020 	strb.w	r2, [r3, #32]
  info->color_depth = IMX335_COLOR_DEPTH;
3419c9f0:	683b      	ldr	r3, [r7, #0]
3419c9f2:	220a      	movs	r2, #10
3419c9f4:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
  info->width = IMX335_WIDTH;
3419c9f8:	683b      	ldr	r3, [r7, #0]
3419c9fa:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
3419c9fe:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = IMX335_HEIGHT;
3419ca00:	683b      	ldr	r3, [r7, #0]
3419ca02:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
3419ca06:	629a      	str	r2, [r3, #40]	@ 0x28
  info->gain_min = IMX335_GAIN_MIN;
3419ca08:	683b      	ldr	r3, [r7, #0]
3419ca0a:	2200      	movs	r2, #0
3419ca0c:	62da      	str	r2, [r3, #44]	@ 0x2c
  info->gain_max = IMX335_GAIN_MAX;
3419ca0e:	683b      	ldr	r3, [r7, #0]
3419ca10:	4a08      	ldr	r2, [pc, #32]	@ (3419ca34 <CMW_IMX335_GetSensorInfo+0x78>)
3419ca12:	631a      	str	r2, [r3, #48]	@ 0x30
  info->exposure_min = IMX335_EXPOSURE_MIN;
3419ca14:	683b      	ldr	r3, [r7, #0]
3419ca16:	2208      	movs	r2, #8
3419ca18:	635a      	str	r2, [r3, #52]	@ 0x34
  info->exposure_max = IMX335_EXPOSURE_MAX;
3419ca1a:	683b      	ldr	r3, [r7, #0]
3419ca1c:	f248 12f2 	movw	r2, #33266	@ 0x81f2
3419ca20:	639a      	str	r2, [r3, #56]	@ 0x38

  return CMW_ERROR_NONE;
3419ca22:	2300      	movs	r3, #0
}
3419ca24:	4618      	mov	r0, r3
3419ca26:	370c      	adds	r7, #12
3419ca28:	46bd      	mov	sp, r7
3419ca2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ca2e:	4770      	bx	lr
3419ca30:	341a7670 	.word	0x341a7670
3419ca34:	00011940 	.word	0x00011940

3419ca38 <CMW_IMX335_SetTestPattern>:

static int32_t CMW_IMX335_SetTestPattern(void *io_ctx, int32_t mode)
{
3419ca38:	b580      	push	{r7, lr}
3419ca3a:	b082      	sub	sp, #8
3419ca3c:	af00      	add	r7, sp, #0
3419ca3e:	6078      	str	r0, [r7, #4]
3419ca40:	6039      	str	r1, [r7, #0]
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
3419ca42:	687b      	ldr	r3, [r7, #4]
3419ca44:	3308      	adds	r3, #8
3419ca46:	6839      	ldr	r1, [r7, #0]
3419ca48:	4618      	mov	r0, r3
3419ca4a:	f002 f87b 	bl	3419eb44 <IMX335_SetTestPattern>
3419ca4e:	4603      	mov	r3, r0
}
3419ca50:	4618      	mov	r0, r3
3419ca52:	3708      	adds	r7, #8
3419ca54:	46bd      	mov	sp, r7
3419ca56:	bd80      	pop	{r7, pc}

3419ca58 <CMW_IMX335_Init>:

static int32_t CMW_IMX335_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419ca58:	b580      	push	{r7, lr}
3419ca5a:	b084      	sub	sp, #16
3419ca5c:	af00      	add	r7, sp, #0
3419ca5e:	6078      	str	r0, [r7, #4]
3419ca60:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419ca62:	2300      	movs	r3, #0
3419ca64:	60fb      	str	r3, [r7, #12]
  uint32_t resolution;

  ret = CMW_IMX335_GetResType(initSensor->width, initSensor->height, &resolution);
3419ca66:	683b      	ldr	r3, [r7, #0]
3419ca68:	6818      	ldr	r0, [r3, #0]
3419ca6a:	683b      	ldr	r3, [r7, #0]
3419ca6c:	685b      	ldr	r3, [r3, #4]
3419ca6e:	f107 0208 	add.w	r2, r7, #8
3419ca72:	4619      	mov	r1, r3
3419ca74:	f7ff fe81 	bl	3419c77a <CMW_IMX335_GetResType>
3419ca78:	60f8      	str	r0, [r7, #12]
  if (ret)
3419ca7a:	68fb      	ldr	r3, [r7, #12]
3419ca7c:	2b00      	cmp	r3, #0
3419ca7e:	d002      	beq.n	3419ca86 <CMW_IMX335_Init+0x2e>
  {
    return CMW_ERROR_WRONG_PARAM;
3419ca80:	f06f 0301 	mvn.w	r3, #1
3419ca84:	e01d      	b.n	3419cac2 <CMW_IMX335_Init+0x6a>
  }

  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
3419ca86:	683b      	ldr	r3, [r7, #0]
3419ca88:	691b      	ldr	r3, [r3, #16]
3419ca8a:	4619      	mov	r1, r3
3419ca8c:	6878      	ldr	r0, [r7, #4]
3419ca8e:	f7ff ff7f 	bl	3419c990 <CMW_IMX335_SetMirrorFlip>
3419ca92:	60f8      	str	r0, [r7, #12]
  if (ret)
3419ca94:	68fb      	ldr	r3, [r7, #12]
3419ca96:	2b00      	cmp	r3, #0
3419ca98:	d002      	beq.n	3419caa0 <CMW_IMX335_Init+0x48>
  {
    return CMW_ERROR_WRONG_PARAM;
3419ca9a:	f06f 0301 	mvn.w	r3, #1
3419ca9e:	e010      	b.n	3419cac2 <CMW_IMX335_Init+0x6a>
  }

  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
3419caa0:	687b      	ldr	r3, [r7, #4]
3419caa2:	f103 0008 	add.w	r0, r3, #8
3419caa6:	68b9      	ldr	r1, [r7, #8]
3419caa8:	683b      	ldr	r3, [r7, #0]
3419caaa:	68db      	ldr	r3, [r3, #12]
3419caac:	461a      	mov	r2, r3
3419caae:	f001 fdbd 	bl	3419e62c <IMX335_Init>
3419cab2:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419cab4:	68fb      	ldr	r3, [r7, #12]
3419cab6:	2b00      	cmp	r3, #0
3419cab8:	d002      	beq.n	3419cac0 <CMW_IMX335_Init+0x68>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419caba:	f06f 0304 	mvn.w	r3, #4
3419cabe:	e000      	b.n	3419cac2 <CMW_IMX335_Init+0x6a>
  }

  return CMW_ERROR_NONE;
3419cac0:	2300      	movs	r3, #0
}
3419cac2:	4618      	mov	r0, r3
3419cac4:	3710      	adds	r7, #16
3419cac6:	46bd      	mov	sp, r7
3419cac8:	bd80      	pop	{r7, pc}
	...

3419cacc <CMW_IMX335_Start>:

static int32_t CMW_IMX335_Start(void *io_ctx)
{
3419cacc:	b580      	push	{r7, lr}
3419cace:	b086      	sub	sp, #24
3419cad0:	af02      	add	r7, sp, #8
3419cad2:	6078      	str	r0, [r7, #4]
  int ret;
  /* Statistic area is provided with null value so that it force the ISP Library to get the statistic
   * area information from the tuning file.
   */
  (void) ISP_IQParamCacheInit; /* unused */
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_IMX335);
3419cad4:	687b      	ldr	r3, [r7, #4]
3419cad6:	f103 0030 	add.w	r0, r3, #48	@ 0x30
3419cada:	687b      	ldr	r3, [r7, #4]
3419cadc:	f8d3 10dc 	ldr.w	r1, [r3, #220]	@ 0xdc
3419cae0:	687b      	ldr	r3, [r7, #4]
3419cae2:	33b8      	adds	r3, #184	@ 0xb8
3419cae4:	4a11      	ldr	r2, [pc, #68]	@ (3419cb2c <CMW_IMX335_Start+0x60>)
3419cae6:	9200      	str	r2, [sp, #0]
3419cae8:	2200      	movs	r2, #0
3419caea:	f7fc fc5b 	bl	341993a4 <ISP_Init>
3419caee:	4603      	mov	r3, r0
3419caf0:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419caf2:	68fb      	ldr	r3, [r7, #12]
3419caf4:	2b00      	cmp	r3, #0
3419caf6:	d002      	beq.n	3419cafe <CMW_IMX335_Start+0x32>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419caf8:	f06f 0304 	mvn.w	r3, #4
3419cafc:	e012      	b.n	3419cb24 <CMW_IMX335_Start+0x58>
  }

  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cafe:	687b      	ldr	r3, [r7, #4]
3419cb00:	3330      	adds	r3, #48	@ 0x30
3419cb02:	4618      	mov	r0, r3
3419cb04:	f7fc fd34 	bl	34199570 <ISP_Start>
3419cb08:	4603      	mov	r3, r0
3419cb0a:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419cb0c:	68fb      	ldr	r3, [r7, #12]
3419cb0e:	2b00      	cmp	r3, #0
3419cb10:	d002      	beq.n	3419cb18 <CMW_IMX335_Start+0x4c>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419cb12:	f06f 0303 	mvn.w	r3, #3
3419cb16:	e005      	b.n	3419cb24 <CMW_IMX335_Start+0x58>
  }
#endif
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3419cb18:	687b      	ldr	r3, [r7, #4]
3419cb1a:	3308      	adds	r3, #8
3419cb1c:	4618      	mov	r0, r3
3419cb1e:	f001 fdc3 	bl	3419e6a8 <IMX335_Start>
3419cb22:	4603      	mov	r3, r0
}
3419cb24:	4618      	mov	r0, r3
3419cb26:	3710      	adds	r7, #16
3419cb28:	46bd      	mov	sp, r7
3419cb2a:	bd80      	pop	{r7, pc}
3419cb2c:	341a7fbc 	.word	0x341a7fbc

3419cb30 <CMW_IMX335_Run>:

static int32_t CMW_IMX335_Run(void *io_ctx)
{
3419cb30:	b580      	push	{r7, lr}
3419cb32:	b084      	sub	sp, #16
3419cb34:	af00      	add	r7, sp, #0
3419cb36:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cb38:	687b      	ldr	r3, [r7, #4]
3419cb3a:	3330      	adds	r3, #48	@ 0x30
3419cb3c:	4618      	mov	r0, r3
3419cb3e:	f7fc fe1f 	bl	34199780 <ISP_BackgroundProcess>
3419cb42:	4603      	mov	r3, r0
3419cb44:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419cb46:	68fb      	ldr	r3, [r7, #12]
3419cb48:	2b00      	cmp	r3, #0
3419cb4a:	d002      	beq.n	3419cb52 <CMW_IMX335_Run+0x22>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419cb4c:	f06f 0303 	mvn.w	r3, #3
3419cb50:	e000      	b.n	3419cb54 <CMW_IMX335_Run+0x24>
  }
#endif
  return CMW_ERROR_NONE;
3419cb52:	2300      	movs	r3, #0
}
3419cb54:	4618      	mov	r0, r3
3419cb56:	3710      	adds	r7, #16
3419cb58:	46bd      	mov	sp, r7
3419cb5a:	bd80      	pop	{r7, pc}

3419cb5c <CMW_IMX335_PowerOn>:

static void CMW_IMX335_PowerOn(CMW_IMX335_t *io_ctx)
{
3419cb5c:	b580      	push	{r7, lr}
3419cb5e:	b082      	sub	sp, #8
3419cb60:	af00      	add	r7, sp, #0
3419cb62:	6078      	str	r0, [r7, #4]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419cb64:	687b      	ldr	r3, [r7, #4]
3419cb66:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419cb6a:	2000      	movs	r0, #0
3419cb6c:	4798      	blx	r3
  io_ctx->Delay(100);
3419cb6e:	687b      	ldr	r3, [r7, #4]
3419cb70:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419cb74:	2064      	movs	r0, #100	@ 0x64
3419cb76:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
3419cb78:	687b      	ldr	r3, [r7, #4]
3419cb7a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419cb7e:	2000      	movs	r0, #0
3419cb80:	4798      	blx	r3
  io_ctx->Delay(100);
3419cb82:	687b      	ldr	r3, [r7, #4]
3419cb84:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419cb88:	2064      	movs	r0, #100	@ 0x64
3419cb8a:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419cb8c:	687b      	ldr	r3, [r7, #4]
3419cb8e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3419cb92:	2001      	movs	r0, #1
3419cb94:	4798      	blx	r3
  io_ctx->Delay(100);
3419cb96:	687b      	ldr	r3, [r7, #4]
3419cb98:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419cb9c:	2064      	movs	r0, #100	@ 0x64
3419cb9e:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
3419cba0:	687b      	ldr	r3, [r7, #4]
3419cba2:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3419cba6:	2001      	movs	r0, #1
3419cba8:	4798      	blx	r3
  io_ctx->Delay(100);
3419cbaa:	687b      	ldr	r3, [r7, #4]
3419cbac:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3419cbb0:	2064      	movs	r0, #100	@ 0x64
3419cbb2:	4798      	blx	r3
}
3419cbb4:	bf00      	nop
3419cbb6:	3708      	adds	r7, #8
3419cbb8:	46bd      	mov	sp, r7
3419cbba:	bd80      	pop	{r7, pc}

3419cbbc <CMW_IMX335_VsyncEventCallback>:

static void CMW_IMX335_VsyncEventCallback(void *io_ctx, uint32_t pipe)
{
3419cbbc:	b580      	push	{r7, lr}
3419cbbe:	b082      	sub	sp, #8
3419cbc0:	af00      	add	r7, sp, #0
3419cbc2:	6078      	str	r0, [r7, #4]
3419cbc4:	6039      	str	r1, [r7, #0]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Update the ISP frame counter and call its statistics handler */
  switch (pipe)
3419cbc6:	683b      	ldr	r3, [r7, #0]
3419cbc8:	2b02      	cmp	r3, #2
3419cbca:	d01a      	beq.n	3419cc02 <CMW_IMX335_VsyncEventCallback+0x46>
3419cbcc:	683b      	ldr	r3, [r7, #0]
3419cbce:	2b02      	cmp	r3, #2
3419cbd0:	d81d      	bhi.n	3419cc0e <CMW_IMX335_VsyncEventCallback+0x52>
3419cbd2:	683b      	ldr	r3, [r7, #0]
3419cbd4:	2b00      	cmp	r3, #0
3419cbd6:	d003      	beq.n	3419cbe0 <CMW_IMX335_VsyncEventCallback+0x24>
3419cbd8:	683b      	ldr	r3, [r7, #0]
3419cbda:	2b01      	cmp	r3, #1
3419cbdc:	d006      	beq.n	3419cbec <CMW_IMX335_VsyncEventCallback+0x30>
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
      break;
  }
#endif
}
3419cbde:	e016      	b.n	3419cc0e <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cbe0:	687b      	ldr	r3, [r7, #4]
3419cbe2:	3330      	adds	r3, #48	@ 0x30
3419cbe4:	4618      	mov	r0, r3
3419cbe6:	f7fc feb3 	bl	34199950 <ISP_IncDumpFrameId>
      break;
3419cbea:	e010      	b.n	3419cc0e <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cbec:	687b      	ldr	r3, [r7, #4]
3419cbee:	3330      	adds	r3, #48	@ 0x30
3419cbf0:	4618      	mov	r0, r3
3419cbf2:	f7fc fe97 	bl	34199924 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cbf6:	687b      	ldr	r3, [r7, #4]
3419cbf8:	3330      	adds	r3, #48	@ 0x30
3419cbfa:	4618      	mov	r0, r3
3419cbfc:	f7fc fe87 	bl	3419990e <ISP_GatherStatistics>
      break;
3419cc00:	e005      	b.n	3419cc0e <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3419cc02:	687b      	ldr	r3, [r7, #4]
3419cc04:	3330      	adds	r3, #48	@ 0x30
3419cc06:	4618      	mov	r0, r3
3419cc08:	f7fc fe97 	bl	3419993a <ISP_IncAncillaryFrameId>
      break;
3419cc0c:	bf00      	nop
}
3419cc0e:	bf00      	nop
3419cc10:	3708      	adds	r7, #8
3419cc12:	46bd      	mov	sp, r7
3419cc14:	bd80      	pop	{r7, pc}

3419cc16 <CMW_IMX335_FrameEventCallback>:

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
3419cc16:	b480      	push	{r7}
3419cc18:	b083      	sub	sp, #12
3419cc1a:	af00      	add	r7, sp, #0
3419cc1c:	6078      	str	r0, [r7, #4]
3419cc1e:	6039      	str	r1, [r7, #0]
}
3419cc20:	bf00      	nop
3419cc22:	370c      	adds	r7, #12
3419cc24:	46bd      	mov	sp, r7
3419cc26:	f85d 7b04 	ldr.w	r7, [sp], #4
3419cc2a:	4770      	bx	lr

3419cc2c <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
3419cc2c:	b580      	push	{r7, lr}
3419cc2e:	b084      	sub	sp, #16
3419cc30:	af00      	add	r7, sp, #0
3419cc32:	6078      	str	r0, [r7, #4]
3419cc34:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419cc36:	2300      	movs	r3, #0
3419cc38:	60fb      	str	r3, [r7, #12]
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3419cc3a:	687b      	ldr	r3, [r7, #4]
3419cc3c:	881a      	ldrh	r2, [r3, #0]
3419cc3e:	687b      	ldr	r3, [r7, #4]
3419cc40:	821a      	strh	r2, [r3, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3419cc42:	687b      	ldr	r3, [r7, #4]
3419cc44:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
3419cc48:	687b      	ldr	r3, [r7, #4]
3419cc4a:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
3419cc4c:	687b      	ldr	r3, [r7, #4]
3419cc4e:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3419cc52:	687b      	ldr	r3, [r7, #4]
3419cc54:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
3419cc56:	687b      	ldr	r3, [r7, #4]
3419cc58:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3419cc5c:	687b      	ldr	r3, [r7, #4]
3419cc5e:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
3419cc60:	687b      	ldr	r3, [r7, #4]
3419cc62:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3419cc66:	687b      	ldr	r3, [r7, #4]
3419cc68:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
3419cc6a:	687b      	ldr	r3, [r7, #4]
3419cc6c:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3419cc70:	687b      	ldr	r3, [r7, #4]
3419cc72:	615a      	str	r2, [r3, #20]

  CMW_IMX335_PowerOn(io_ctx);
3419cc74:	6878      	ldr	r0, [r7, #4]
3419cc76:	f7ff ff71 	bl	3419cb5c <CMW_IMX335_PowerOn>

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3419cc7a:	687b      	ldr	r3, [r7, #4]
3419cc7c:	f103 0208 	add.w	r2, r3, #8
3419cc80:	687b      	ldr	r3, [r7, #4]
3419cc82:	3308      	adds	r3, #8
3419cc84:	4619      	mov	r1, r3
3419cc86:	4610      	mov	r0, r2
3419cc88:	f001 fc8e 	bl	3419e5a8 <IMX335_RegisterBusIO>
3419cc8c:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419cc8e:	68fb      	ldr	r3, [r7, #12]
3419cc90:	2b00      	cmp	r3, #0
3419cc92:	d002      	beq.n	3419cc9a <CMW_IMX335_Probe+0x6e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419cc94:	f06f 0304 	mvn.w	r3, #4
3419cc98:	e04a      	b.n	3419cd30 <CMW_IMX335_Probe+0x104>
  }

  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
3419cc9a:	687b      	ldr	r3, [r7, #4]
3419cc9c:	3308      	adds	r3, #8
3419cc9e:	f107 0208 	add.w	r2, r7, #8
3419cca2:	4611      	mov	r1, r2
3419cca4:	4618      	mov	r0, r3
3419cca6:	f001 fd35 	bl	3419e714 <IMX335_ReadID>
3419ccaa:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419ccac:	68fb      	ldr	r3, [r7, #12]
3419ccae:	2b00      	cmp	r3, #0
3419ccb0:	d002      	beq.n	3419ccb8 <CMW_IMX335_Probe+0x8c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419ccb2:	f06f 0304 	mvn.w	r3, #4
3419ccb6:	e03b      	b.n	3419cd30 <CMW_IMX335_Probe+0x104>
  }
  if (id != IMX335_CHIP_ID)
3419ccb8:	68bb      	ldr	r3, [r7, #8]
3419ccba:	2b00      	cmp	r3, #0
3419ccbc:	d002      	beq.n	3419ccc4 <CMW_IMX335_Probe+0x98>
  {
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3419ccbe:	f06f 0306 	mvn.w	r3, #6
3419ccc2:	60fb      	str	r3, [r7, #12]
  }

  memset(imx335_if, 0, sizeof(*imx335_if));
3419ccc4:	2268      	movs	r2, #104	@ 0x68
3419ccc6:	2100      	movs	r1, #0
3419ccc8:	6838      	ldr	r0, [r7, #0]
3419ccca:	f008 fc11 	bl	341a54f0 <memset>
  imx335_if->Init = CMW_IMX335_Init;
3419ccce:	683b      	ldr	r3, [r7, #0]
3419ccd0:	4a19      	ldr	r2, [pc, #100]	@ (3419cd38 <CMW_IMX335_Probe+0x10c>)
3419ccd2:	601a      	str	r2, [r3, #0]
  imx335_if->Start = CMW_IMX335_Start;
3419ccd4:	683b      	ldr	r3, [r7, #0]
3419ccd6:	4a19      	ldr	r2, [pc, #100]	@ (3419cd3c <CMW_IMX335_Probe+0x110>)
3419ccd8:	609a      	str	r2, [r3, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
3419ccda:	683b      	ldr	r3, [r7, #0]
3419ccdc:	4a18      	ldr	r2, [pc, #96]	@ (3419cd40 <CMW_IMX335_Probe+0x114>)
3419ccde:	605a      	str	r2, [r3, #4]
  imx335_if->Run = CMW_IMX335_Run;
3419cce0:	683b      	ldr	r3, [r7, #0]
3419cce2:	4a18      	ldr	r2, [pc, #96]	@ (3419cd44 <CMW_IMX335_Probe+0x118>)
3419cce4:	60da      	str	r2, [r3, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
3419cce6:	683b      	ldr	r3, [r7, #0]
3419cce8:	4a17      	ldr	r2, [pc, #92]	@ (3419cd48 <CMW_IMX335_Probe+0x11c>)
3419ccea:	611a      	str	r2, [r3, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
3419ccec:	683b      	ldr	r3, [r7, #0]
3419ccee:	4a17      	ldr	r2, [pc, #92]	@ (3419cd4c <CMW_IMX335_Probe+0x120>)
3419ccf0:	615a      	str	r2, [r3, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
3419ccf2:	683b      	ldr	r3, [r7, #0]
3419ccf4:	4a16      	ldr	r2, [pc, #88]	@ (3419cd50 <CMW_IMX335_Probe+0x124>)
3419ccf6:	61da      	str	r2, [r3, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
3419ccf8:	683b      	ldr	r3, [r7, #0]
3419ccfa:	4a16      	ldr	r2, [pc, #88]	@ (3419cd54 <CMW_IMX335_Probe+0x128>)
3419ccfc:	649a      	str	r2, [r3, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
3419ccfe:	683b      	ldr	r3, [r7, #0]
3419cd00:	4a15      	ldr	r2, [pc, #84]	@ (3419cd58 <CMW_IMX335_Probe+0x12c>)
3419cd02:	64da      	str	r2, [r3, #76]	@ 0x4c
  imx335_if->SetWBRefMode = CMW_IMX335_SetWBRefMode;
3419cd04:	683b      	ldr	r3, [r7, #0]
3419cd06:	4a15      	ldr	r2, [pc, #84]	@ (3419cd5c <CMW_IMX335_Probe+0x130>)
3419cd08:	655a      	str	r2, [r3, #84]	@ 0x54
  imx335_if->ListWBRefModes = CMW_IMX335_ListWBRefModes;
3419cd0a:	683b      	ldr	r3, [r7, #0]
3419cd0c:	4a14      	ldr	r2, [pc, #80]	@ (3419cd60 <CMW_IMX335_Probe+0x134>)
3419cd0e:	659a      	str	r2, [r3, #88]	@ 0x58
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
3419cd10:	683b      	ldr	r3, [r7, #0]
3419cd12:	4a14      	ldr	r2, [pc, #80]	@ (3419cd64 <CMW_IMX335_Probe+0x138>)
3419cd14:	641a      	str	r2, [r3, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
3419cd16:	683b      	ldr	r3, [r7, #0]
3419cd18:	4a13      	ldr	r2, [pc, #76]	@ (3419cd68 <CMW_IMX335_Probe+0x13c>)
3419cd1a:	645a      	str	r2, [r3, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
3419cd1c:	683b      	ldr	r3, [r7, #0]
3419cd1e:	4a13      	ldr	r2, [pc, #76]	@ (3419cd6c <CMW_IMX335_Probe+0x140>)
3419cd20:	62da      	str	r2, [r3, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
3419cd22:	683b      	ldr	r3, [r7, #0]
3419cd24:	4a12      	ldr	r2, [pc, #72]	@ (3419cd70 <CMW_IMX335_Probe+0x144>)
3419cd26:	661a      	str	r2, [r3, #96]	@ 0x60
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
3419cd28:	683b      	ldr	r3, [r7, #0]
3419cd2a:	4a12      	ldr	r2, [pc, #72]	@ (3419cd74 <CMW_IMX335_Probe+0x148>)
3419cd2c:	665a      	str	r2, [r3, #100]	@ 0x64
  return ret;
3419cd2e:	68fb      	ldr	r3, [r7, #12]
}
3419cd30:	4618      	mov	r0, r3
3419cd32:	3710      	adds	r7, #16
3419cd34:	46bd      	mov	sp, r7
3419cd36:	bd80      	pop	{r7, pc}
3419cd38:	3419ca59 	.word	0x3419ca59
3419cd3c:	3419cacd 	.word	0x3419cacd
3419cd40:	3419c7f9 	.word	0x3419c7f9
3419cd44:	3419cb31 	.word	0x3419cb31
3419cd48:	3419cbbd 	.word	0x3419cbbd
3419cd4c:	3419cc17 	.word	0x3419cc17
3419cd50:	3419c841 	.word	0x3419c841
3419cd54:	3419c861 	.word	0x3419c861
3419cd58:	3419c881 	.word	0x3419c881
3419cd5c:	3419c8a1 	.word	0x3419c8a1
3419cd60:	3419c8db 	.word	0x3419c8db
3419cd64:	3419c90f 	.word	0x3419c90f
3419cd68:	3419c931 	.word	0x3419c931
3419cd6c:	3419c991 	.word	0x3419c991
3419cd70:	3419c9bd 	.word	0x3419c9bd
3419cd74:	3419ca39 	.word	0x3419ca39

3419cd78 <CMW_VD55G1_Read8>:
#define MIN(a, b)       ((a) < (b) ?  (a) : (b))

#define VD55G1_REG_MODEL_ID                           0x0000

static int CMW_VD55G1_Read8(CMW_VD55G1_t *pObj, uint16_t addr, uint8_t *value)
{
3419cd78:	b590      	push	{r4, r7, lr}
3419cd7a:	b085      	sub	sp, #20
3419cd7c:	af00      	add	r7, sp, #0
3419cd7e:	60f8      	str	r0, [r7, #12]
3419cd80:	460b      	mov	r3, r1
3419cd82:	607a      	str	r2, [r7, #4]
3419cd84:	817b      	strh	r3, [r7, #10]
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3419cd86:	68fb      	ldr	r3, [r7, #12]
3419cd88:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419cd8a:	68fb      	ldr	r3, [r7, #12]
3419cd8c:	8818      	ldrh	r0, [r3, #0]
3419cd8e:	8979      	ldrh	r1, [r7, #10]
3419cd90:	2301      	movs	r3, #1
3419cd92:	687a      	ldr	r2, [r7, #4]
3419cd94:	47a0      	blx	r4
3419cd96:	4603      	mov	r3, r0
}
3419cd98:	4618      	mov	r0, r3
3419cd9a:	3714      	adds	r7, #20
3419cd9c:	46bd      	mov	sp, r7
3419cd9e:	bd90      	pop	{r4, r7, pc}

3419cda0 <CMW_VD55G1_Read16>:

static int CMW_VD55G1_Read16(CMW_VD55G1_t *pObj, uint16_t addr, uint16_t *value)
{
3419cda0:	b590      	push	{r4, r7, lr}
3419cda2:	b087      	sub	sp, #28
3419cda4:	af00      	add	r7, sp, #0
3419cda6:	60f8      	str	r0, [r7, #12]
3419cda8:	460b      	mov	r3, r1
3419cdaa:	607a      	str	r2, [r7, #4]
3419cdac:	817b      	strh	r3, [r7, #10]
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3419cdae:	68fb      	ldr	r3, [r7, #12]
3419cdb0:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419cdb2:	68fb      	ldr	r3, [r7, #12]
3419cdb4:	8818      	ldrh	r0, [r3, #0]
3419cdb6:	f107 0210 	add.w	r2, r7, #16
3419cdba:	8979      	ldrh	r1, [r7, #10]
3419cdbc:	2302      	movs	r3, #2
3419cdbe:	47a0      	blx	r4
3419cdc0:	6178      	str	r0, [r7, #20]
  if (ret)
3419cdc2:	697b      	ldr	r3, [r7, #20]
3419cdc4:	2b00      	cmp	r3, #0
3419cdc6:	d001      	beq.n	3419cdcc <CMW_VD55G1_Read16+0x2c>
    return ret;
3419cdc8:	697b      	ldr	r3, [r7, #20]
3419cdca:	e00b      	b.n	3419cde4 <CMW_VD55G1_Read16+0x44>

  *value = (data[1] << 8) | data[0];
3419cdcc:	7c7b      	ldrb	r3, [r7, #17]
3419cdce:	b21b      	sxth	r3, r3
3419cdd0:	021b      	lsls	r3, r3, #8
3419cdd2:	b21a      	sxth	r2, r3
3419cdd4:	7c3b      	ldrb	r3, [r7, #16]
3419cdd6:	b21b      	sxth	r3, r3
3419cdd8:	4313      	orrs	r3, r2
3419cdda:	b21b      	sxth	r3, r3
3419cddc:	b29a      	uxth	r2, r3
3419cdde:	687b      	ldr	r3, [r7, #4]
3419cde0:	801a      	strh	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419cde2:	2300      	movs	r3, #0
}
3419cde4:	4618      	mov	r0, r3
3419cde6:	371c      	adds	r7, #28
3419cde8:	46bd      	mov	sp, r7
3419cdea:	bd90      	pop	{r4, r7, pc}

3419cdec <CMW_VD55G1_Read32>:

static int CMW_VD55G1_Read32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t *value)
{
3419cdec:	b590      	push	{r4, r7, lr}
3419cdee:	b087      	sub	sp, #28
3419cdf0:	af00      	add	r7, sp, #0
3419cdf2:	60f8      	str	r0, [r7, #12]
3419cdf4:	460b      	mov	r3, r1
3419cdf6:	607a      	str	r2, [r7, #4]
3419cdf8:	817b      	strh	r3, [r7, #10]
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3419cdfa:	68fb      	ldr	r3, [r7, #12]
3419cdfc:	6fdc      	ldr	r4, [r3, #124]	@ 0x7c
3419cdfe:	68fb      	ldr	r3, [r7, #12]
3419ce00:	8818      	ldrh	r0, [r3, #0]
3419ce02:	f107 0210 	add.w	r2, r7, #16
3419ce06:	8979      	ldrh	r1, [r7, #10]
3419ce08:	2304      	movs	r3, #4
3419ce0a:	47a0      	blx	r4
3419ce0c:	6178      	str	r0, [r7, #20]
  if (ret)
3419ce0e:	697b      	ldr	r3, [r7, #20]
3419ce10:	2b00      	cmp	r3, #0
3419ce12:	d001      	beq.n	3419ce18 <CMW_VD55G1_Read32+0x2c>
    return ret;
3419ce14:	697b      	ldr	r3, [r7, #20]
3419ce16:	e00d      	b.n	3419ce34 <CMW_VD55G1_Read32+0x48>

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
3419ce18:	7cfb      	ldrb	r3, [r7, #19]
3419ce1a:	061a      	lsls	r2, r3, #24
3419ce1c:	7cbb      	ldrb	r3, [r7, #18]
3419ce1e:	041b      	lsls	r3, r3, #16
3419ce20:	431a      	orrs	r2, r3
3419ce22:	7c7b      	ldrb	r3, [r7, #17]
3419ce24:	021b      	lsls	r3, r3, #8
3419ce26:	4313      	orrs	r3, r2
3419ce28:	7c3a      	ldrb	r2, [r7, #16]
3419ce2a:	4313      	orrs	r3, r2
3419ce2c:	461a      	mov	r2, r3
3419ce2e:	687b      	ldr	r3, [r7, #4]
3419ce30:	601a      	str	r2, [r3, #0]

  return 0;
3419ce32:	2300      	movs	r3, #0
}
3419ce34:	4618      	mov	r0, r3
3419ce36:	371c      	adds	r7, #28
3419ce38:	46bd      	mov	sp, r7
3419ce3a:	bd90      	pop	{r4, r7, pc}

3419ce3c <CMW_VD55G1_Write8>:

static int CMW_VD55G1_Write8(CMW_VD55G1_t *pObj, uint16_t addr, uint8_t value)
{
3419ce3c:	b590      	push	{r4, r7, lr}
3419ce3e:	b083      	sub	sp, #12
3419ce40:	af00      	add	r7, sp, #0
3419ce42:	6078      	str	r0, [r7, #4]
3419ce44:	460b      	mov	r3, r1
3419ce46:	807b      	strh	r3, [r7, #2]
3419ce48:	4613      	mov	r3, r2
3419ce4a:	707b      	strb	r3, [r7, #1]
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3419ce4c:	687b      	ldr	r3, [r7, #4]
3419ce4e:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419ce50:	687b      	ldr	r3, [r7, #4]
3419ce52:	8818      	ldrh	r0, [r3, #0]
3419ce54:	1c7a      	adds	r2, r7, #1
3419ce56:	8879      	ldrh	r1, [r7, #2]
3419ce58:	2301      	movs	r3, #1
3419ce5a:	47a0      	blx	r4
3419ce5c:	4603      	mov	r3, r0
}
3419ce5e:	4618      	mov	r0, r3
3419ce60:	370c      	adds	r7, #12
3419ce62:	46bd      	mov	sp, r7
3419ce64:	bd90      	pop	{r4, r7, pc}

3419ce66 <CMW_VD55G1_Write16>:

static int CMW_VD55G1_Write16(CMW_VD55G1_t *pObj, uint16_t addr, uint16_t value)
{
3419ce66:	b590      	push	{r4, r7, lr}
3419ce68:	b083      	sub	sp, #12
3419ce6a:	af00      	add	r7, sp, #0
3419ce6c:	6078      	str	r0, [r7, #4]
3419ce6e:	460b      	mov	r3, r1
3419ce70:	807b      	strh	r3, [r7, #2]
3419ce72:	4613      	mov	r3, r2
3419ce74:	803b      	strh	r3, [r7, #0]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
3419ce76:	687b      	ldr	r3, [r7, #4]
3419ce78:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419ce7a:	687b      	ldr	r3, [r7, #4]
3419ce7c:	8818      	ldrh	r0, [r3, #0]
3419ce7e:	463a      	mov	r2, r7
3419ce80:	8879      	ldrh	r1, [r7, #2]
3419ce82:	2302      	movs	r3, #2
3419ce84:	47a0      	blx	r4
3419ce86:	4603      	mov	r3, r0
}
3419ce88:	4618      	mov	r0, r3
3419ce8a:	370c      	adds	r7, #12
3419ce8c:	46bd      	mov	sp, r7
3419ce8e:	bd90      	pop	{r4, r7, pc}

3419ce90 <CMW_VD55G1_Write32>:

static int CMW_VD55G1_Write32(CMW_VD55G1_t *pObj, uint16_t addr, uint32_t value)
{
3419ce90:	b590      	push	{r4, r7, lr}
3419ce92:	b085      	sub	sp, #20
3419ce94:	af00      	add	r7, sp, #0
3419ce96:	60f8      	str	r0, [r7, #12]
3419ce98:	460b      	mov	r3, r1
3419ce9a:	607a      	str	r2, [r7, #4]
3419ce9c:	817b      	strh	r3, [r7, #10]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3419ce9e:	68fb      	ldr	r3, [r7, #12]
3419cea0:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419cea2:	68fb      	ldr	r3, [r7, #12]
3419cea4:	8818      	ldrh	r0, [r3, #0]
3419cea6:	1d3a      	adds	r2, r7, #4
3419cea8:	8979      	ldrh	r1, [r7, #10]
3419ceaa:	2304      	movs	r3, #4
3419ceac:	47a0      	blx	r4
3419ceae:	4603      	mov	r3, r0
}
3419ceb0:	4618      	mov	r0, r3
3419ceb2:	3714      	adds	r7, #20
3419ceb4:	46bd      	mov	sp, r7
3419ceb6:	bd90      	pop	{r4, r7, pc}

3419ceb8 <VD55G1_ShutdownPin>:

static void VD55G1_ShutdownPin(struct VD55G1_Ctx *ctx, int value)
{
3419ceb8:	b580      	push	{r7, lr}
3419ceba:	b084      	sub	sp, #16
3419cebc:	af00      	add	r7, sp, #0
3419cebe:	6078      	str	r0, [r7, #4]
3419cec0:	6039      	str	r1, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cec2:	687b      	ldr	r3, [r7, #4]
3419cec4:	3b04      	subs	r3, #4
3419cec6:	60fb      	str	r3, [r7, #12]

  p_ctx->ShutdownPin(value);
3419cec8:	68fb      	ldr	r3, [r7, #12]
3419ceca:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419cece:	6838      	ldr	r0, [r7, #0]
3419ced0:	4798      	blx	r3
}
3419ced2:	bf00      	nop
3419ced4:	3710      	adds	r7, #16
3419ced6:	46bd      	mov	sp, r7
3419ced8:	bd80      	pop	{r7, pc}

3419ceda <VD55G1_Read8>:

static int VD55G1_Read8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *value)
{
3419ceda:	b580      	push	{r7, lr}
3419cedc:	b086      	sub	sp, #24
3419cede:	af00      	add	r7, sp, #0
3419cee0:	60f8      	str	r0, [r7, #12]
3419cee2:	460b      	mov	r3, r1
3419cee4:	607a      	str	r2, [r7, #4]
3419cee6:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cee8:	68fb      	ldr	r3, [r7, #12]
3419ceea:	3b04      	subs	r3, #4
3419ceec:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read8(p_ctx, addr, value);
3419ceee:	897b      	ldrh	r3, [r7, #10]
3419cef0:	687a      	ldr	r2, [r7, #4]
3419cef2:	4619      	mov	r1, r3
3419cef4:	6978      	ldr	r0, [r7, #20]
3419cef6:	f7ff ff3f 	bl	3419cd78 <CMW_VD55G1_Read8>
3419cefa:	4603      	mov	r3, r0
}
3419cefc:	4618      	mov	r0, r3
3419cefe:	3718      	adds	r7, #24
3419cf00:	46bd      	mov	sp, r7
3419cf02:	bd80      	pop	{r7, pc}

3419cf04 <VD55G1_Read16>:

static int VD55G1_Read16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t *value)
{
3419cf04:	b580      	push	{r7, lr}
3419cf06:	b086      	sub	sp, #24
3419cf08:	af00      	add	r7, sp, #0
3419cf0a:	60f8      	str	r0, [r7, #12]
3419cf0c:	460b      	mov	r3, r1
3419cf0e:	607a      	str	r2, [r7, #4]
3419cf10:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cf12:	68fb      	ldr	r3, [r7, #12]
3419cf14:	3b04      	subs	r3, #4
3419cf16:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read16(p_ctx, addr, value);
3419cf18:	897b      	ldrh	r3, [r7, #10]
3419cf1a:	687a      	ldr	r2, [r7, #4]
3419cf1c:	4619      	mov	r1, r3
3419cf1e:	6978      	ldr	r0, [r7, #20]
3419cf20:	f7ff ff3e 	bl	3419cda0 <CMW_VD55G1_Read16>
3419cf24:	4603      	mov	r3, r0
}
3419cf26:	4618      	mov	r0, r3
3419cf28:	3718      	adds	r7, #24
3419cf2a:	46bd      	mov	sp, r7
3419cf2c:	bd80      	pop	{r7, pc}

3419cf2e <VD55G1_Read32>:

static int VD55G1_Read32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t *value)
{
3419cf2e:	b580      	push	{r7, lr}
3419cf30:	b086      	sub	sp, #24
3419cf32:	af00      	add	r7, sp, #0
3419cf34:	60f8      	str	r0, [r7, #12]
3419cf36:	460b      	mov	r3, r1
3419cf38:	607a      	str	r2, [r7, #4]
3419cf3a:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cf3c:	68fb      	ldr	r3, [r7, #12]
3419cf3e:	3b04      	subs	r3, #4
3419cf40:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Read32(p_ctx, addr, value);
3419cf42:	897b      	ldrh	r3, [r7, #10]
3419cf44:	687a      	ldr	r2, [r7, #4]
3419cf46:	4619      	mov	r1, r3
3419cf48:	6978      	ldr	r0, [r7, #20]
3419cf4a:	f7ff ff4f 	bl	3419cdec <CMW_VD55G1_Read32>
3419cf4e:	4603      	mov	r3, r0
}
3419cf50:	4618      	mov	r0, r3
3419cf52:	3718      	adds	r7, #24
3419cf54:	46bd      	mov	sp, r7
3419cf56:	bd80      	pop	{r7, pc}

3419cf58 <VD55G1_Write8>:

static int VD55G1_Write8(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t value)
{
3419cf58:	b580      	push	{r7, lr}
3419cf5a:	b084      	sub	sp, #16
3419cf5c:	af00      	add	r7, sp, #0
3419cf5e:	6078      	str	r0, [r7, #4]
3419cf60:	460b      	mov	r3, r1
3419cf62:	807b      	strh	r3, [r7, #2]
3419cf64:	4613      	mov	r3, r2
3419cf66:	707b      	strb	r3, [r7, #1]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cf68:	687b      	ldr	r3, [r7, #4]
3419cf6a:	3b04      	subs	r3, #4
3419cf6c:	60fb      	str	r3, [r7, #12]

  return CMW_VD55G1_Write8(p_ctx, addr, value);
3419cf6e:	787a      	ldrb	r2, [r7, #1]
3419cf70:	887b      	ldrh	r3, [r7, #2]
3419cf72:	4619      	mov	r1, r3
3419cf74:	68f8      	ldr	r0, [r7, #12]
3419cf76:	f7ff ff61 	bl	3419ce3c <CMW_VD55G1_Write8>
3419cf7a:	4603      	mov	r3, r0
}
3419cf7c:	4618      	mov	r0, r3
3419cf7e:	3710      	adds	r7, #16
3419cf80:	46bd      	mov	sp, r7
3419cf82:	bd80      	pop	{r7, pc}

3419cf84 <VD55G1_Write16>:

static int VD55G1_Write16(struct VD55G1_Ctx *ctx, uint16_t addr, uint16_t value)
{
3419cf84:	b580      	push	{r7, lr}
3419cf86:	b084      	sub	sp, #16
3419cf88:	af00      	add	r7, sp, #0
3419cf8a:	6078      	str	r0, [r7, #4]
3419cf8c:	460b      	mov	r3, r1
3419cf8e:	807b      	strh	r3, [r7, #2]
3419cf90:	4613      	mov	r3, r2
3419cf92:	803b      	strh	r3, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cf94:	687b      	ldr	r3, [r7, #4]
3419cf96:	3b04      	subs	r3, #4
3419cf98:	60fb      	str	r3, [r7, #12]

  return CMW_VD55G1_Write16(p_ctx, addr, value);
3419cf9a:	883a      	ldrh	r2, [r7, #0]
3419cf9c:	887b      	ldrh	r3, [r7, #2]
3419cf9e:	4619      	mov	r1, r3
3419cfa0:	68f8      	ldr	r0, [r7, #12]
3419cfa2:	f7ff ff60 	bl	3419ce66 <CMW_VD55G1_Write16>
3419cfa6:	4603      	mov	r3, r0
}
3419cfa8:	4618      	mov	r0, r3
3419cfaa:	3710      	adds	r7, #16
3419cfac:	46bd      	mov	sp, r7
3419cfae:	bd80      	pop	{r7, pc}

3419cfb0 <VD55G1_Write32>:

static int VD55G1_Write32(struct VD55G1_Ctx *ctx, uint16_t addr, uint32_t value)
{
3419cfb0:	b580      	push	{r7, lr}
3419cfb2:	b086      	sub	sp, #24
3419cfb4:	af00      	add	r7, sp, #0
3419cfb6:	60f8      	str	r0, [r7, #12]
3419cfb8:	460b      	mov	r3, r1
3419cfba:	607a      	str	r2, [r7, #4]
3419cfbc:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cfbe:	68fb      	ldr	r3, [r7, #12]
3419cfc0:	3b04      	subs	r3, #4
3419cfc2:	617b      	str	r3, [r7, #20]

  return CMW_VD55G1_Write32(p_ctx, addr, value);
3419cfc4:	897b      	ldrh	r3, [r7, #10]
3419cfc6:	687a      	ldr	r2, [r7, #4]
3419cfc8:	4619      	mov	r1, r3
3419cfca:	6978      	ldr	r0, [r7, #20]
3419cfcc:	f7ff ff60 	bl	3419ce90 <CMW_VD55G1_Write32>
3419cfd0:	4603      	mov	r3, r0
}
3419cfd2:	4618      	mov	r0, r3
3419cfd4:	3718      	adds	r7, #24
3419cfd6:	46bd      	mov	sp, r7
3419cfd8:	bd80      	pop	{r7, pc}

3419cfda <VD55G1_WriteArray>:

static int VD55G1_WriteArray(struct VD55G1_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
3419cfda:	b590      	push	{r4, r7, lr}
3419cfdc:	b089      	sub	sp, #36	@ 0x24
3419cfde:	af00      	add	r7, sp, #0
3419cfe0:	60f8      	str	r0, [r7, #12]
3419cfe2:	607a      	str	r2, [r7, #4]
3419cfe4:	603b      	str	r3, [r7, #0]
3419cfe6:	460b      	mov	r3, r1
3419cfe8:	817b      	strh	r3, [r7, #10]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419cfea:	68fb      	ldr	r3, [r7, #12]
3419cfec:	3b04      	subs	r3, #4
3419cfee:	61fb      	str	r3, [r7, #28]
  const unsigned int chunk_size = 128;
3419cff0:	2380      	movs	r3, #128	@ 0x80
3419cff2:	61bb      	str	r3, [r7, #24]
  uint16_t sz;
  int ret;

  while (data_len) {
3419cff4:	e01f      	b.n	3419d036 <VD55G1_WriteArray+0x5c>
    sz = MIN(data_len, chunk_size);
3419cff6:	683a      	ldr	r2, [r7, #0]
3419cff8:	69bb      	ldr	r3, [r7, #24]
3419cffa:	4293      	cmp	r3, r2
3419cffc:	bf28      	it	cs
3419cffe:	4613      	movcs	r3, r2
3419d000:	82fb      	strh	r3, [r7, #22]
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
3419d002:	69fb      	ldr	r3, [r7, #28]
3419d004:	6f9c      	ldr	r4, [r3, #120]	@ 0x78
3419d006:	69fb      	ldr	r3, [r7, #28]
3419d008:	8818      	ldrh	r0, [r3, #0]
3419d00a:	8afb      	ldrh	r3, [r7, #22]
3419d00c:	8979      	ldrh	r1, [r7, #10]
3419d00e:	687a      	ldr	r2, [r7, #4]
3419d010:	47a0      	blx	r4
3419d012:	6138      	str	r0, [r7, #16]
    if (ret)
3419d014:	693b      	ldr	r3, [r7, #16]
3419d016:	2b00      	cmp	r3, #0
3419d018:	d001      	beq.n	3419d01e <VD55G1_WriteArray+0x44>
      return ret;
3419d01a:	693b      	ldr	r3, [r7, #16]
3419d01c:	e00f      	b.n	3419d03e <VD55G1_WriteArray+0x64>
    data_len -= sz;
3419d01e:	8afb      	ldrh	r3, [r7, #22]
3419d020:	683a      	ldr	r2, [r7, #0]
3419d022:	1ad3      	subs	r3, r2, r3
3419d024:	603b      	str	r3, [r7, #0]
    addr += sz;
3419d026:	897a      	ldrh	r2, [r7, #10]
3419d028:	8afb      	ldrh	r3, [r7, #22]
3419d02a:	4413      	add	r3, r2
3419d02c:	817b      	strh	r3, [r7, #10]
    data += sz;
3419d02e:	8afb      	ldrh	r3, [r7, #22]
3419d030:	687a      	ldr	r2, [r7, #4]
3419d032:	4413      	add	r3, r2
3419d034:	607b      	str	r3, [r7, #4]
  while (data_len) {
3419d036:	683b      	ldr	r3, [r7, #0]
3419d038:	2b00      	cmp	r3, #0
3419d03a:	d1dc      	bne.n	3419cff6 <VD55G1_WriteArray+0x1c>
  }

  return 0;
3419d03c:	2300      	movs	r3, #0
}
3419d03e:	4618      	mov	r0, r3
3419d040:	3724      	adds	r7, #36	@ 0x24
3419d042:	46bd      	mov	sp, r7
3419d044:	bd90      	pop	{r4, r7, pc}

3419d046 <VD55G1_Delay>:

static void VD55G1_Delay(struct VD55G1_Ctx *ctx, uint32_t delay_in_ms)
{
3419d046:	b580      	push	{r7, lr}
3419d048:	b084      	sub	sp, #16
3419d04a:	af00      	add	r7, sp, #0
3419d04c:	6078      	str	r0, [r7, #4]
3419d04e:	6039      	str	r1, [r7, #0]
  CMW_VD55G1_t *p_ctx = container_of(ctx, CMW_VD55G1_t, ctx_driver);
3419d050:	687b      	ldr	r3, [r7, #4]
3419d052:	3b04      	subs	r3, #4
3419d054:	60fb      	str	r3, [r7, #12]

  p_ctx->Delay(delay_in_ms);
3419d056:	68fb      	ldr	r3, [r7, #12]
3419d058:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419d05c:	6838      	ldr	r0, [r7, #0]
3419d05e:	4798      	blx	r3
}
3419d060:	bf00      	nop
3419d062:	3710      	adds	r7, #16
3419d064:	46bd      	mov	sp, r7
3419d066:	bd80      	pop	{r7, pc}

3419d068 <VD55G1_Log>:

static void VD55G1_Log(struct VD55G1_Ctx *ctx, int lvl, const char *format, va_list ap)
{
3419d068:	b480      	push	{r7}
3419d06a:	b085      	sub	sp, #20
3419d06c:	af00      	add	r7, sp, #0
3419d06e:	60f8      	str	r0, [r7, #12]
3419d070:	60b9      	str	r1, [r7, #8]
3419d072:	607a      	str	r2, [r7, #4]
3419d074:	603b      	str	r3, [r7, #0]
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3419d076:	bf00      	nop
3419d078:	3714      	adds	r7, #20
3419d07a:	46bd      	mov	sp, r7
3419d07c:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d080:	4770      	bx	lr

3419d082 <CMW_VD55G1_GetSensorInfo>:
  * @param  pObj  pointer to component object
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
static int32_t CMW_VD55G1_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419d082:	b480      	push	{r7}
3419d084:	b083      	sub	sp, #12
3419d086:	af00      	add	r7, sp, #0
3419d088:	6078      	str	r0, [r7, #4]
3419d08a:	6039      	str	r1, [r7, #0]
  if ((io_ctx ==  NULL) || (info == NULL))
3419d08c:	687b      	ldr	r3, [r7, #4]
3419d08e:	2b00      	cmp	r3, #0
3419d090:	d002      	beq.n	3419d098 <CMW_VD55G1_GetSensorInfo+0x16>
3419d092:	683b      	ldr	r3, [r7, #0]
3419d094:	2b00      	cmp	r3, #0
3419d096:	d102      	bne.n	3419d09e <CMW_VD55G1_GetSensorInfo+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3419d098:	f06f 0301 	mvn.w	r3, #1
3419d09c:	e008      	b.n	3419d0b0 <CMW_VD55G1_GetSensorInfo+0x2e>
  }

  /* Return the default full resolution */
  info->width = VD55G1_MAX_WIDTH;
3419d09e:	683b      	ldr	r3, [r7, #0]
3419d0a0:	f44f 7249 	mov.w	r2, #804	@ 0x324
3419d0a4:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = VD55G1_MAX_HEIGHT;
3419d0a6:	683b      	ldr	r3, [r7, #0]
3419d0a8:	f44f 7230 	mov.w	r2, #704	@ 0x2c0
3419d0ac:	629a      	str	r2, [r3, #40]	@ 0x28

  return CMW_ERROR_NONE;
3419d0ae:	2300      	movs	r3, #0
}
3419d0b0:	4618      	mov	r0, r3
3419d0b2:	370c      	adds	r7, #12
3419d0b4:	46bd      	mov	sp, r7
3419d0b6:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d0ba:	4770      	bx	lr

3419d0bc <CMW_VD55G1_GetResType>:

static int CMW_VD55G1_GetResType(uint32_t width, uint32_t height, VD55G1_Res_t *res)
{
3419d0bc:	b480      	push	{r7}
3419d0be:	b085      	sub	sp, #20
3419d0c0:	af00      	add	r7, sp, #0
3419d0c2:	60f8      	str	r0, [r7, #12]
3419d0c4:	60b9      	str	r1, [r7, #8]
3419d0c6:	607a      	str	r2, [r7, #4]
  if (width == 320 && height == 240)
3419d0c8:	68fb      	ldr	r3, [r7, #12]
3419d0ca:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
3419d0ce:	d106      	bne.n	3419d0de <CMW_VD55G1_GetResType+0x22>
3419d0d0:	68bb      	ldr	r3, [r7, #8]
3419d0d2:	2bf0      	cmp	r3, #240	@ 0xf0
3419d0d4:	d103      	bne.n	3419d0de <CMW_VD55G1_GetResType+0x22>
  {
    *res = VD55G1_RES_QVGA_320_240;
3419d0d6:	687b      	ldr	r3, [r7, #4]
3419d0d8:	2200      	movs	r2, #0
3419d0da:	701a      	strb	r2, [r3, #0]
3419d0dc:	e026      	b.n	3419d12c <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 640 && height == 480)
3419d0de:	68fb      	ldr	r3, [r7, #12]
3419d0e0:	f5b3 7f20 	cmp.w	r3, #640	@ 0x280
3419d0e4:	d107      	bne.n	3419d0f6 <CMW_VD55G1_GetResType+0x3a>
3419d0e6:	68bb      	ldr	r3, [r7, #8]
3419d0e8:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3419d0ec:	d103      	bne.n	3419d0f6 <CMW_VD55G1_GetResType+0x3a>
  {
    *res = VD55G1_RES_VGA_640_480;
3419d0ee:	687b      	ldr	r3, [r7, #4]
3419d0f0:	2201      	movs	r2, #1
3419d0f2:	701a      	strb	r2, [r3, #0]
3419d0f4:	e01a      	b.n	3419d12c <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 800 && height == 600)
3419d0f6:	68fb      	ldr	r3, [r7, #12]
3419d0f8:	f5b3 7f48 	cmp.w	r3, #800	@ 0x320
3419d0fc:	d107      	bne.n	3419d10e <CMW_VD55G1_GetResType+0x52>
3419d0fe:	68bb      	ldr	r3, [r7, #8]
3419d100:	f5b3 7f16 	cmp.w	r3, #600	@ 0x258
3419d104:	d103      	bne.n	3419d10e <CMW_VD55G1_GetResType+0x52>
  {
    *res = VD55G1_RES_SXGA_800_600;
3419d106:	687b      	ldr	r3, [r7, #4]
3419d108:	2202      	movs	r2, #2
3419d10a:	701a      	strb	r2, [r3, #0]
3419d10c:	e00e      	b.n	3419d12c <CMW_VD55G1_GetResType+0x70>
  }
  else if (width == 804 && height == 704)
3419d10e:	68fb      	ldr	r3, [r7, #12]
3419d110:	f5b3 7f49 	cmp.w	r3, #804	@ 0x324
3419d114:	d107      	bne.n	3419d126 <CMW_VD55G1_GetResType+0x6a>
3419d116:	68bb      	ldr	r3, [r7, #8]
3419d118:	f5b3 7f30 	cmp.w	r3, #704	@ 0x2c0
3419d11c:	d103      	bne.n	3419d126 <CMW_VD55G1_GetResType+0x6a>
  {
      *res = VD55G1_RES_FULL_804_704;
3419d11e:	687b      	ldr	r3, [r7, #4]
3419d120:	2203      	movs	r2, #3
3419d122:	701a      	strb	r2, [r3, #0]
3419d124:	e002      	b.n	3419d12c <CMW_VD55G1_GetResType+0x70>
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
3419d126:	f06f 0301 	mvn.w	r3, #1
3419d12a:	e000      	b.n	3419d12e <CMW_VD55G1_GetResType+0x72>
  }
  return 0;
3419d12c:	2300      	movs	r3, #0
}
3419d12e:	4618      	mov	r0, r3
3419d130:	3714      	adds	r7, #20
3419d132:	46bd      	mov	sp, r7
3419d134:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d138:	4770      	bx	lr

3419d13a <CMW_VD55G1_getMirrorFlipConfig>:

static VD55G1_MirrorFlip_t CMW_VD55G1_getMirrorFlipConfig(int32_t Config)
{
3419d13a:	b480      	push	{r7}
3419d13c:	b085      	sub	sp, #20
3419d13e:	af00      	add	r7, sp, #0
3419d140:	6078      	str	r0, [r7, #4]
  VD55G1_MirrorFlip_t ret;

  switch (Config)
3419d142:	687b      	ldr	r3, [r7, #4]
3419d144:	2b02      	cmp	r3, #2
3419d146:	d00f      	beq.n	3419d168 <CMW_VD55G1_getMirrorFlipConfig+0x2e>
3419d148:	687b      	ldr	r3, [r7, #4]
3419d14a:	2b02      	cmp	r3, #2
3419d14c:	dc0f      	bgt.n	3419d16e <CMW_VD55G1_getMirrorFlipConfig+0x34>
3419d14e:	687b      	ldr	r3, [r7, #4]
3419d150:	2b00      	cmp	r3, #0
3419d152:	d003      	beq.n	3419d15c <CMW_VD55G1_getMirrorFlipConfig+0x22>
3419d154:	687b      	ldr	r3, [r7, #4]
3419d156:	2b01      	cmp	r3, #1
3419d158:	d003      	beq.n	3419d162 <CMW_VD55G1_getMirrorFlipConfig+0x28>
3419d15a:	e008      	b.n	3419d16e <CMW_VD55G1_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_MIRROR_FLIP_NONE;
3419d15c:	2300      	movs	r3, #0
3419d15e:	73fb      	strb	r3, [r7, #15]
      break;
3419d160:	e008      	b.n	3419d174 <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD55G1_FLIP;
3419d162:	2301      	movs	r3, #1
3419d164:	73fb      	strb	r3, [r7, #15]
      break;
3419d166:	e005      	b.n	3419d174 <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_MIRROR;
3419d168:	2302      	movs	r3, #2
3419d16a:	73fb      	strb	r3, [r7, #15]
      break;
3419d16c:	e002      	b.n	3419d174 <CMW_VD55G1_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = VD55G1_MIRROR_FLIP;
3419d16e:	2303      	movs	r3, #3
3419d170:	73fb      	strb	r3, [r7, #15]
      break;
3419d172:	bf00      	nop
  }

  return ret;
3419d174:	7bfb      	ldrb	r3, [r7, #15]
}
3419d176:	4618      	mov	r0, r3
3419d178:	3714      	adds	r7, #20
3419d17a:	46bd      	mov	sp, r7
3419d17c:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d180:	4770      	bx	lr
	...

3419d184 <CMW_VD55G1_Init>:

static int32_t CMW_VD55G1_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419d184:	b580      	push	{r7, lr}
3419d186:	b096      	sub	sp, #88	@ 0x58
3419d188:	af00      	add	r7, sp, #0
3419d18a:	6078      	str	r0, [r7, #4]
3419d18c:	6039      	str	r1, [r7, #0]
  VD55G1_Config_t config = { 0 };
3419d18e:	f107 0318 	add.w	r3, r7, #24
3419d192:	2234      	movs	r2, #52	@ 0x34
3419d194:	2100      	movs	r1, #0
3419d196:	4618      	mov	r0, r3
3419d198:	f008 f9aa 	bl	341a54f0 <memset>
  int ret;
  int i;

  assert(initSensor != NULL);
3419d19c:	683b      	ldr	r3, [r7, #0]
3419d19e:	2b00      	cmp	r3, #0
3419d1a0:	d105      	bne.n	3419d1ae <CMW_VD55G1_Init+0x2a>
3419d1a2:	4b39      	ldr	r3, [pc, #228]	@ (3419d288 <CMW_VD55G1_Init+0x104>)
3419d1a4:	4a39      	ldr	r2, [pc, #228]	@ (3419d28c <CMW_VD55G1_Init+0x108>)
3419d1a6:	21f8      	movs	r1, #248	@ 0xf8
3419d1a8:	4839      	ldr	r0, [pc, #228]	@ (3419d290 <CMW_VD55G1_Init+0x10c>)
3419d1aa:	f007 ff17 	bl	341a4fdc <__assert_func>

  if (((CMW_VD55G1_t *)io_ctx)->IsInitialized)
3419d1ae:	687b      	ldr	r3, [r7, #4]
3419d1b0:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
3419d1b4:	2b00      	cmp	r3, #0
3419d1b6:	d001      	beq.n	3419d1bc <CMW_VD55G1_Init+0x38>
  {
    return CMW_ERROR_NONE;
3419d1b8:	2300      	movs	r3, #0
3419d1ba:	e061      	b.n	3419d280 <CMW_VD55G1_Init+0xfc>
  }

  config.frame_rate = initSensor->fps;
3419d1bc:	683b      	ldr	r3, [r7, #0]
3419d1be:	689b      	ldr	r3, [r3, #8]
3419d1c0:	623b      	str	r3, [r7, #32]
  ret = CMW_VD55G1_GetResType(initSensor->width, initSensor->height, &config.resolution);
3419d1c2:	683b      	ldr	r3, [r7, #0]
3419d1c4:	6818      	ldr	r0, [r3, #0]
3419d1c6:	683b      	ldr	r3, [r7, #0]
3419d1c8:	6859      	ldr	r1, [r3, #4]
3419d1ca:	f107 0318 	add.w	r3, r7, #24
3419d1ce:	3304      	adds	r3, #4
3419d1d0:	461a      	mov	r2, r3
3419d1d2:	f7ff ff73 	bl	3419d0bc <CMW_VD55G1_GetResType>
3419d1d6:	6538      	str	r0, [r7, #80]	@ 0x50
  if (ret)
3419d1d8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419d1da:	2b00      	cmp	r3, #0
3419d1dc:	d002      	beq.n	3419d1e4 <CMW_VD55G1_Init+0x60>
  {
    return CMW_ERROR_WRONG_PARAM;
3419d1de:	f06f 0301 	mvn.w	r3, #1
3419d1e2:	e04d      	b.n	3419d280 <CMW_VD55G1_Init+0xfc>
  }

  CMW_VD55G1_config_t default_sensor_config;
  CMW_VD55G1_config_t *sensor_config;

  CMW_VD55G1_SetDefaultSensorValues(&default_sensor_config);
3419d1e4:	f107 0308 	add.w	r3, r7, #8
3419d1e8:	4618      	mov	r0, r3
3419d1ea:	f000 f853 	bl	3419d294 <CMW_VD55G1_SetDefaultSensorValues>
  sensor_config = initSensor->sensor_config ? (CMW_VD55G1_config_t*)(initSensor->sensor_config) : &default_sensor_config;
3419d1ee:	683b      	ldr	r3, [r7, #0]
3419d1f0:	695b      	ldr	r3, [r3, #20]
3419d1f2:	2b00      	cmp	r3, #0
3419d1f4:	d002      	beq.n	3419d1fc <CMW_VD55G1_Init+0x78>
3419d1f6:	683b      	ldr	r3, [r7, #0]
3419d1f8:	695b      	ldr	r3, [r3, #20]
3419d1fa:	e001      	b.n	3419d200 <CMW_VD55G1_Init+0x7c>
3419d1fc:	f107 0308 	add.w	r3, r7, #8
3419d200:	64fb      	str	r3, [r7, #76]	@ 0x4c

  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3419d202:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419d204:	681b      	ldr	r3, [r3, #0]
3419d206:	61bb      	str	r3, [r7, #24]
  config.out_itf.data_rate_in_mps = sensor_config->csiconfig.data_rate_in_mps;
3419d208:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419d20a:	685b      	ldr	r3, [r3, #4]
3419d20c:	62bb      	str	r3, [r7, #40]	@ 0x28
  config.out_itf.clock_lane_swap_enable =sensor_config->csiconfig.clock_lane_swap_enable;
3419d20e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419d210:	689b      	ldr	r3, [r3, #8]
3419d212:	62fb      	str	r3, [r7, #44]	@ 0x2c
  config.out_itf.data_lane_swap_enable = sensor_config->csiconfig.data_lane_swap_enable;
3419d214:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3419d216:	68db      	ldr	r3, [r3, #12]
3419d218:	633b      	str	r3, [r7, #48]	@ 0x30

  config.flip_mirror_mode = CMW_VD55G1_getMirrorFlipConfig(initSensor->mirrorFlip);
3419d21a:	683b      	ldr	r3, [r7, #0]
3419d21c:	691b      	ldr	r3, [r3, #16]
3419d21e:	4618      	mov	r0, r3
3419d220:	f7ff ff8b 	bl	3419d13a <CMW_VD55G1_getMirrorFlipConfig>
3419d224:	4603      	mov	r3, r0
3419d226:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  config.patgen = VD55G1_PATGEN_DISABLE;
3419d22a:	2300      	movs	r3, #0
3419d22c:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  config.flicker = VD55G1_FLICKER_FREE_NONE;
3419d230:	2300      	movs	r3, #0
3419d232:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  config.awu.is_enable = 0;
3419d236:	2300      	movs	r3, #0
3419d238:	637b      	str	r3, [r7, #52]	@ 0x34

  for (i = 0; i < VD55G1_GPIO_NB; i++)
3419d23a:	2300      	movs	r3, #0
3419d23c:	657b      	str	r3, [r7, #84]	@ 0x54
3419d23e:	e008      	b.n	3419d252 <CMW_VD55G1_Init+0xce>
  {
    config.gpio_ctrl[i] = VD55G1_GPIO_GPIO_IN;
3419d240:	f107 0248 	add.w	r2, r7, #72	@ 0x48
3419d244:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419d246:	4413      	add	r3, r2
3419d248:	2201      	movs	r2, #1
3419d24a:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < VD55G1_GPIO_NB; i++)
3419d24c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419d24e:	3301      	adds	r3, #1
3419d250:	657b      	str	r3, [r7, #84]	@ 0x54
3419d252:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3419d254:	2b03      	cmp	r3, #3
3419d256:	ddf3      	ble.n	3419d240 <CMW_VD55G1_Init+0xbc>
  }

  ret = VD55G1_Init(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, &config);
3419d258:	687b      	ldr	r3, [r7, #4]
3419d25a:	3304      	adds	r3, #4
3419d25c:	f107 0218 	add.w	r2, r7, #24
3419d260:	4611      	mov	r1, r2
3419d262:	4618      	mov	r0, r3
3419d264:	f003 f850 	bl	341a0308 <VD55G1_Init>
3419d268:	6538      	str	r0, [r7, #80]	@ 0x50
  if (ret)
3419d26a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3419d26c:	2b00      	cmp	r3, #0
3419d26e:	d002      	beq.n	3419d276 <CMW_VD55G1_Init+0xf2>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419d270:	f06f 0303 	mvn.w	r3, #3
3419d274:	e004      	b.n	3419d280 <CMW_VD55G1_Init+0xfc>
  }

  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 1;
3419d276:	687b      	ldr	r3, [r7, #4]
3419d278:	2201      	movs	r2, #1
3419d27a:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  return CMW_ERROR_NONE;
3419d27e:	2300      	movs	r3, #0
}
3419d280:	4618      	mov	r0, r3
3419d282:	3758      	adds	r7, #88	@ 0x58
3419d284:	46bd      	mov	sp, r7
3419d286:	bd80      	pop	{r7, pc}
3419d288:	341a7678 	.word	0x341a7678
3419d28c:	341a8214 	.word	0x341a8214
3419d290:	341a768c 	.word	0x341a768c

3419d294 <CMW_VD55G1_SetDefaultSensorValues>:

void CMW_VD55G1_SetDefaultSensorValues( CMW_VD55G1_config_t *vd55g1_config)
{
3419d294:	b580      	push	{r7, lr}
3419d296:	b082      	sub	sp, #8
3419d298:	af00      	add	r7, sp, #0
3419d29a:	6078      	str	r0, [r7, #4]
  assert(vd55g1_config != NULL);
3419d29c:	687b      	ldr	r3, [r7, #4]
3419d29e:	2b00      	cmp	r3, #0
3419d2a0:	d106      	bne.n	3419d2b0 <CMW_VD55G1_SetDefaultSensorValues+0x1c>
3419d2a2:	4b0b      	ldr	r3, [pc, #44]	@ (3419d2d0 <CMW_VD55G1_SetDefaultSensorValues+0x3c>)
3419d2a4:	4a0b      	ldr	r2, [pc, #44]	@ (3419d2d4 <CMW_VD55G1_SetDefaultSensorValues+0x40>)
3419d2a6:	f240 1127 	movw	r1, #295	@ 0x127
3419d2aa:	480b      	ldr	r0, [pc, #44]	@ (3419d2d8 <CMW_VD55G1_SetDefaultSensorValues+0x44>)
3419d2ac:	f007 fe96 	bl	341a4fdc <__assert_func>

  vd55g1_config->ext_clock_freq_in_hz = CAMERA_VD55G1_FREQ_IN_HZ; // Default clock frequency
3419d2b0:	687b      	ldr	r3, [r7, #4]
3419d2b2:	4a0a      	ldr	r2, [pc, #40]	@ (3419d2dc <CMW_VD55G1_SetDefaultSensorValues+0x48>)
3419d2b4:	601a      	str	r2, [r3, #0]
  vd55g1_config->csiconfig.data_rate_in_mps = VD55G1_DEFAULT_DATARATE;
3419d2b6:	687b      	ldr	r3, [r7, #4]
3419d2b8:	4a09      	ldr	r2, [pc, #36]	@ (3419d2e0 <CMW_VD55G1_SetDefaultSensorValues+0x4c>)
3419d2ba:	605a      	str	r2, [r3, #4]
  vd55g1_config->csiconfig.clock_lane_swap_enable = 1;
3419d2bc:	687b      	ldr	r3, [r7, #4]
3419d2be:	2201      	movs	r2, #1
3419d2c0:	609a      	str	r2, [r3, #8]
  vd55g1_config->csiconfig.data_lane_swap_enable = 1;
3419d2c2:	687b      	ldr	r3, [r7, #4]
3419d2c4:	2201      	movs	r2, #1
3419d2c6:	60da      	str	r2, [r3, #12]
}
3419d2c8:	bf00      	nop
3419d2ca:	3708      	adds	r7, #8
3419d2cc:	46bd      	mov	sp, r7
3419d2ce:	bd80      	pop	{r7, pc}
3419d2d0:	341a76c4 	.word	0x341a76c4
3419d2d4:	341a8224 	.word	0x341a8224
3419d2d8:	341a768c 	.word	0x341a768c
3419d2dc:	00b71b00 	.word	0x00b71b00
3419d2e0:	2fec1100 	.word	0x2fec1100

3419d2e4 <CMW_VD55G1_Start>:

static int32_t CMW_VD55G1_Start(void *io_ctx)
{
3419d2e4:	b580      	push	{r7, lr}
3419d2e6:	b084      	sub	sp, #16
3419d2e8:	af00      	add	r7, sp, #0
3419d2ea:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419d2ec:	2300      	movs	r3, #0
3419d2ee:	60fb      	str	r3, [r7, #12]
  ret = VD55G1_Start(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419d2f0:	687b      	ldr	r3, [r7, #4]
3419d2f2:	3304      	adds	r3, #4
3419d2f4:	4618      	mov	r0, r3
3419d2f6:	f003 f898 	bl	341a042a <VD55G1_Start>
3419d2fa:	60f8      	str	r0, [r7, #12]
  if (ret) {
3419d2fc:	68fb      	ldr	r3, [r7, #12]
3419d2fe:	2b00      	cmp	r3, #0
3419d300:	d007      	beq.n	3419d312 <CMW_VD55G1_Start+0x2e>
    VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419d302:	687b      	ldr	r3, [r7, #4]
3419d304:	3304      	adds	r3, #4
3419d306:	4618      	mov	r0, r3
3419d308:	f003 f872 	bl	341a03f0 <VD55G1_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419d30c:	f06f 0303 	mvn.w	r3, #3
3419d310:	e000      	b.n	3419d314 <CMW_VD55G1_Start+0x30>
  }
  return CMW_ERROR_NONE;
3419d312:	2300      	movs	r3, #0
}
3419d314:	4618      	mov	r0, r3
3419d316:	3710      	adds	r7, #16
3419d318:	46bd      	mov	sp, r7
3419d31a:	bd80      	pop	{r7, pc}

3419d31c <CMW_VD55G1_Stop>:

static int32_t CMW_VD55G1_Stop(void *io_ctx)
{
3419d31c:	b580      	push	{r7, lr}
3419d31e:	b084      	sub	sp, #16
3419d320:	af00      	add	r7, sp, #0
3419d322:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419d324:	2300      	movs	r3, #0
3419d326:	60fb      	str	r3, [r7, #12]

  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419d328:	687b      	ldr	r3, [r7, #4]
3419d32a:	3304      	adds	r3, #4
3419d32c:	4618      	mov	r0, r3
3419d32e:	f003 f89d 	bl	341a046c <VD55G1_Stop>
3419d332:	60f8      	str	r0, [r7, #12]
  if (ret)
3419d334:	68fb      	ldr	r3, [r7, #12]
3419d336:	2b00      	cmp	r3, #0
3419d338:	d002      	beq.n	3419d340 <CMW_VD55G1_Stop+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419d33a:	f06f 0303 	mvn.w	r3, #3
3419d33e:	e000      	b.n	3419d342 <CMW_VD55G1_Stop+0x26>
  }
  return CMW_ERROR_NONE;
3419d340:	2300      	movs	r3, #0
}
3419d342:	4618      	mov	r0, r3
3419d344:	3710      	adds	r7, #16
3419d346:	46bd      	mov	sp, r7
3419d348:	bd80      	pop	{r7, pc}

3419d34a <CMW_VD55G1_DeInit>:

static int32_t CMW_VD55G1_DeInit(void *io_ctx)
{
3419d34a:	b580      	push	{r7, lr}
3419d34c:	b084      	sub	sp, #16
3419d34e:	af00      	add	r7, sp, #0
3419d350:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419d352:	2300      	movs	r3, #0
3419d354:	60fb      	str	r3, [r7, #12]

  ret = VD55G1_Stop(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419d356:	687b      	ldr	r3, [r7, #4]
3419d358:	3304      	adds	r3, #4
3419d35a:	4618      	mov	r0, r3
3419d35c:	f003 f886 	bl	341a046c <VD55G1_Stop>
3419d360:	60f8      	str	r0, [r7, #12]
  if (ret)
3419d362:	68fb      	ldr	r3, [r7, #12]
3419d364:	2b00      	cmp	r3, #0
3419d366:	d002      	beq.n	3419d36e <CMW_VD55G1_DeInit+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419d368:	f06f 0303 	mvn.w	r3, #3
3419d36c:	e010      	b.n	3419d390 <CMW_VD55G1_DeInit+0x46>
  }

  ret = VD55G1_DeInit(&((CMW_VD55G1_t *)io_ctx)->ctx_driver);
3419d36e:	687b      	ldr	r3, [r7, #4]
3419d370:	3304      	adds	r3, #4
3419d372:	4618      	mov	r0, r3
3419d374:	f003 f83c 	bl	341a03f0 <VD55G1_DeInit>
3419d378:	60f8      	str	r0, [r7, #12]
  if (ret)
3419d37a:	68fb      	ldr	r3, [r7, #12]
3419d37c:	2b00      	cmp	r3, #0
3419d37e:	d002      	beq.n	3419d386 <CMW_VD55G1_DeInit+0x3c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419d380:	f06f 0303 	mvn.w	r3, #3
3419d384:	e004      	b.n	3419d390 <CMW_VD55G1_DeInit+0x46>
  }

  ((CMW_VD55G1_t *)io_ctx)->IsInitialized = 0;
3419d386:	687b      	ldr	r3, [r7, #4]
3419d388:	2200      	movs	r2, #0
3419d38a:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  return CMW_ERROR_NONE;
3419d38e:	2300      	movs	r3, #0
}
3419d390:	4618      	mov	r0, r3
3419d392:	3710      	adds	r7, #16
3419d394:	46bd      	mov	sp, r7
3419d396:	bd80      	pop	{r7, pc}

3419d398 <CMW_VD55G1_MirrorFlipConfig>:

static int32_t CMW_VD55G1_MirrorFlipConfig(void *io_ctx, uint32_t Config)
{
3419d398:	b580      	push	{r7, lr}
3419d39a:	b084      	sub	sp, #16
3419d39c:	af00      	add	r7, sp, #0
3419d39e:	6078      	str	r0, [r7, #4]
3419d3a0:	6039      	str	r1, [r7, #0]
  int32_t ret = CMW_ERROR_NONE;
3419d3a2:	2300      	movs	r3, #0
3419d3a4:	60fb      	str	r3, [r7, #12]

  switch (Config) {
3419d3a6:	683b      	ldr	r3, [r7, #0]
3419d3a8:	2b03      	cmp	r3, #3
3419d3aa:	d82b      	bhi.n	3419d404 <CMW_VD55G1_MirrorFlipConfig+0x6c>
3419d3ac:	a201      	add	r2, pc, #4	@ (adr r2, 3419d3b4 <CMW_VD55G1_MirrorFlipConfig+0x1c>)
3419d3ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419d3b2:	bf00      	nop
3419d3b4:	3419d3c5 	.word	0x3419d3c5
3419d3b8:	3419d3d5 	.word	0x3419d3d5
3419d3bc:	3419d3e5 	.word	0x3419d3e5
3419d3c0:	3419d3f5 	.word	0x3419d3f5
    case CMW_MIRRORFLIP_NONE:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP_NONE);
3419d3c4:	687b      	ldr	r3, [r7, #4]
3419d3c6:	3304      	adds	r3, #4
3419d3c8:	2100      	movs	r1, #0
3419d3ca:	4618      	mov	r0, r3
3419d3cc:	f003 f866 	bl	341a049c <VD55G1_SetFlipMirrorMode>
3419d3d0:	60f8      	str	r0, [r7, #12]
      break;
3419d3d2:	e01a      	b.n	3419d40a <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_FLIP);
3419d3d4:	687b      	ldr	r3, [r7, #4]
3419d3d6:	3304      	adds	r3, #4
3419d3d8:	2101      	movs	r1, #1
3419d3da:	4618      	mov	r0, r3
3419d3dc:	f003 f85e 	bl	341a049c <VD55G1_SetFlipMirrorMode>
3419d3e0:	60f8      	str	r0, [r7, #12]
      break;
3419d3e2:	e012      	b.n	3419d40a <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR);
3419d3e4:	687b      	ldr	r3, [r7, #4]
3419d3e6:	3304      	adds	r3, #4
3419d3e8:	2102      	movs	r1, #2
3419d3ea:	4618      	mov	r0, r3
3419d3ec:	f003 f856 	bl	341a049c <VD55G1_SetFlipMirrorMode>
3419d3f0:	60f8      	str	r0, [r7, #12]
      break;
3419d3f2:	e00a      	b.n	3419d40a <CMW_VD55G1_MirrorFlipConfig+0x72>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
      ret = VD55G1_SetFlipMirrorMode(&((CMW_VD55G1_t *)io_ctx)->ctx_driver, VD55G1_MIRROR_FLIP);
3419d3f4:	687b      	ldr	r3, [r7, #4]
3419d3f6:	3304      	adds	r3, #4
3419d3f8:	2103      	movs	r1, #3
3419d3fa:	4618      	mov	r0, r3
3419d3fc:	f003 f84e 	bl	341a049c <VD55G1_SetFlipMirrorMode>
3419d400:	60f8      	str	r0, [r7, #12]
      break;
3419d402:	e002      	b.n	3419d40a <CMW_VD55G1_MirrorFlipConfig+0x72>
    default:
      ret = CMW_ERROR_PERIPH_FAILURE;
3419d404:	f06f 0303 	mvn.w	r3, #3
3419d408:	60fb      	str	r3, [r7, #12]
  }

  return ret;
3419d40a:	68fb      	ldr	r3, [r7, #12]
}
3419d40c:	4618      	mov	r0, r3
3419d40e:	3710      	adds	r7, #16
3419d410:	46bd      	mov	sp, r7
3419d412:	bd80      	pop	{r7, pc}

3419d414 <VD55G1_RegisterBusIO>:

static int32_t VD55G1_RegisterBusIO(CMW_VD55G1_t *io_ctx)
{
3419d414:	b580      	push	{r7, lr}
3419d416:	b084      	sub	sp, #16
3419d418:	af00      	add	r7, sp, #0
3419d41a:	6078      	str	r0, [r7, #4]
  int ret;

  if (!io_ctx)
3419d41c:	687b      	ldr	r3, [r7, #4]
3419d41e:	2b00      	cmp	r3, #0
3419d420:	d102      	bne.n	3419d428 <VD55G1_RegisterBusIO+0x14>
    return CMW_ERROR_COMPONENT_FAILURE;
3419d422:	f06f 0304 	mvn.w	r3, #4
3419d426:	e00b      	b.n	3419d440 <VD55G1_RegisterBusIO+0x2c>

  if (!io_ctx->Init)
3419d428:	687b      	ldr	r3, [r7, #4]
3419d42a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419d42c:	2b00      	cmp	r3, #0
3419d42e:	d102      	bne.n	3419d436 <VD55G1_RegisterBusIO+0x22>
    return CMW_ERROR_COMPONENT_FAILURE;
3419d430:	f06f 0304 	mvn.w	r3, #4
3419d434:	e004      	b.n	3419d440 <VD55G1_RegisterBusIO+0x2c>

  ret = io_ctx->Init();
3419d436:	687b      	ldr	r3, [r7, #4]
3419d438:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3419d43a:	4798      	blx	r3
3419d43c:	60f8      	str	r0, [r7, #12]
//  ret = BSP_ERROR_NONE;
  return ret;
3419d43e:	68fb      	ldr	r3, [r7, #12]
}
3419d440:	4618      	mov	r0, r3
3419d442:	3710      	adds	r7, #16
3419d444:	46bd      	mov	sp, r7
3419d446:	bd80      	pop	{r7, pc}

3419d448 <VD55G1_ReadID>:

static int32_t VD55G1_ReadID(CMW_VD55G1_t *io_ctx, uint32_t *Id)
{
3419d448:	b580      	push	{r7, lr}
3419d44a:	b084      	sub	sp, #16
3419d44c:	af00      	add	r7, sp, #0
3419d44e:	6078      	str	r0, [r7, #4]
3419d450:	6039      	str	r1, [r7, #0]
  uint32_t reg32;
  int32_t ret;

  ret = CMW_VD55G1_Read32(io_ctx, VD55G1_REG_MODEL_ID, &reg32);
3419d452:	f107 0308 	add.w	r3, r7, #8
3419d456:	461a      	mov	r2, r3
3419d458:	2100      	movs	r1, #0
3419d45a:	6878      	ldr	r0, [r7, #4]
3419d45c:	f7ff fcc6 	bl	3419cdec <CMW_VD55G1_Read32>
3419d460:	60f8      	str	r0, [r7, #12]
  if (ret)
3419d462:	68fb      	ldr	r3, [r7, #12]
3419d464:	2b00      	cmp	r3, #0
3419d466:	d001      	beq.n	3419d46c <VD55G1_ReadID+0x24>
    return ret;
3419d468:	68fb      	ldr	r3, [r7, #12]
3419d46a:	e003      	b.n	3419d474 <VD55G1_ReadID+0x2c>

  *Id = reg32;
3419d46c:	68ba      	ldr	r2, [r7, #8]
3419d46e:	683b      	ldr	r3, [r7, #0]
3419d470:	601a      	str	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419d472:	2300      	movs	r3, #0
}
3419d474:	4618      	mov	r0, r3
3419d476:	3710      	adds	r7, #16
3419d478:	46bd      	mov	sp, r7
3419d47a:	bd80      	pop	{r7, pc}

3419d47c <CMW_VD55G1_PowerOn>:

static void CMW_VD55G1_PowerOn(CMW_VD55G1_t *io_ctx)
{
3419d47c:	b580      	push	{r7, lr}
3419d47e:	b082      	sub	sp, #8
3419d480:	af00      	add	r7, sp, #0
3419d482:	6078      	str	r0, [r7, #4]
  /* Camera sensor Power-On sequence */
  /* Assert the camera  NRST pins */
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419d484:	687b      	ldr	r3, [r7, #4]
3419d486:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419d48a:	2000      	movs	r0, #0
3419d48c:	4798      	blx	r3
  io_ctx->Delay(200); /* NRST signals asserted during 200ms */
3419d48e:	687b      	ldr	r3, [r7, #4]
3419d490:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419d494:	20c8      	movs	r0, #200	@ 0xc8
3419d496:	4798      	blx	r3
  /* De-assert the camera STANDBY pin (active high) */
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419d498:	687b      	ldr	r3, [r7, #4]
3419d49a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3419d49e:	2001      	movs	r0, #1
3419d4a0:	4798      	blx	r3
  io_ctx->Delay(20); /* NRST de-asserted during 20ms */
3419d4a2:	687b      	ldr	r3, [r7, #4]
3419d4a4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3419d4a8:	2014      	movs	r0, #20
3419d4aa:	4798      	blx	r3
}
3419d4ac:	bf00      	nop
3419d4ae:	3708      	adds	r7, #8
3419d4b0:	46bd      	mov	sp, r7
3419d4b2:	bd80      	pop	{r7, pc}

3419d4b4 <CMW_VD55G1_Probe>:

int CMW_VD55G1_Probe(CMW_VD55G1_t *io_ctx, CMW_Sensor_if_t *vd55g1_if)
{
3419d4b4:	b580      	push	{r7, lr}
3419d4b6:	b084      	sub	sp, #16
3419d4b8:	af00      	add	r7, sp, #0
3419d4ba:	6078      	str	r0, [r7, #4]
3419d4bc:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419d4be:	2300      	movs	r3, #0
3419d4c0:	60fb      	str	r3, [r7, #12]
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD55G1_ShutdownPin;
3419d4c2:	687b      	ldr	r3, [r7, #4]
3419d4c4:	4a2c      	ldr	r2, [pc, #176]	@ (3419d578 <CMW_VD55G1_Probe+0xc4>)
3419d4c6:	605a      	str	r2, [r3, #4]
  io_ctx->ctx_driver.read8 = VD55G1_Read8;
3419d4c8:	687b      	ldr	r3, [r7, #4]
3419d4ca:	4a2c      	ldr	r2, [pc, #176]	@ (3419d57c <CMW_VD55G1_Probe+0xc8>)
3419d4cc:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.read16 = VD55G1_Read16;
3419d4ce:	687b      	ldr	r3, [r7, #4]
3419d4d0:	4a2b      	ldr	r2, [pc, #172]	@ (3419d580 <CMW_VD55G1_Probe+0xcc>)
3419d4d2:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.read32 = VD55G1_Read32;
3419d4d4:	687b      	ldr	r3, [r7, #4]
3419d4d6:	4a2b      	ldr	r2, [pc, #172]	@ (3419d584 <CMW_VD55G1_Probe+0xd0>)
3419d4d8:	611a      	str	r2, [r3, #16]
  io_ctx->ctx_driver.write8 = VD55G1_Write8;
3419d4da:	687b      	ldr	r3, [r7, #4]
3419d4dc:	4a2a      	ldr	r2, [pc, #168]	@ (3419d588 <CMW_VD55G1_Probe+0xd4>)
3419d4de:	615a      	str	r2, [r3, #20]
  io_ctx->ctx_driver.write16 = VD55G1_Write16;
3419d4e0:	687b      	ldr	r3, [r7, #4]
3419d4e2:	4a2a      	ldr	r2, [pc, #168]	@ (3419d58c <CMW_VD55G1_Probe+0xd8>)
3419d4e4:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.write32 = VD55G1_Write32;
3419d4e6:	687b      	ldr	r3, [r7, #4]
3419d4e8:	4a29      	ldr	r2, [pc, #164]	@ (3419d590 <CMW_VD55G1_Probe+0xdc>)
3419d4ea:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.write_array = VD55G1_WriteArray;
3419d4ec:	687b      	ldr	r3, [r7, #4]
3419d4ee:	4a29      	ldr	r2, [pc, #164]	@ (3419d594 <CMW_VD55G1_Probe+0xe0>)
3419d4f0:	621a      	str	r2, [r3, #32]
  io_ctx->ctx_driver.delay = VD55G1_Delay;
3419d4f2:	687b      	ldr	r3, [r7, #4]
3419d4f4:	4a28      	ldr	r2, [pc, #160]	@ (3419d598 <CMW_VD55G1_Probe+0xe4>)
3419d4f6:	625a      	str	r2, [r3, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD55G1_Log;
3419d4f8:	687b      	ldr	r3, [r7, #4]
3419d4fa:	4a28      	ldr	r2, [pc, #160]	@ (3419d59c <CMW_VD55G1_Probe+0xe8>)
3419d4fc:	629a      	str	r2, [r3, #40]	@ 0x28

  CMW_VD55G1_PowerOn(io_ctx);
3419d4fe:	6878      	ldr	r0, [r7, #4]
3419d500:	f7ff ffbc 	bl	3419d47c <CMW_VD55G1_PowerOn>

  ret = VD55G1_RegisterBusIO(io_ctx);
3419d504:	6878      	ldr	r0, [r7, #4]
3419d506:	f7ff ff85 	bl	3419d414 <VD55G1_RegisterBusIO>
3419d50a:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419d50c:	68fb      	ldr	r3, [r7, #12]
3419d50e:	2b00      	cmp	r3, #0
3419d510:	d002      	beq.n	3419d518 <CMW_VD55G1_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419d512:	f06f 0304 	mvn.w	r3, #4
3419d516:	e02b      	b.n	3419d570 <CMW_VD55G1_Probe+0xbc>
  }

  ret = VD55G1_ReadID(io_ctx, &id);
3419d518:	f107 0308 	add.w	r3, r7, #8
3419d51c:	4619      	mov	r1, r3
3419d51e:	6878      	ldr	r0, [r7, #4]
3419d520:	f7ff ff92 	bl	3419d448 <VD55G1_ReadID>
3419d524:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419d526:	68fb      	ldr	r3, [r7, #12]
3419d528:	2b00      	cmp	r3, #0
3419d52a:	d002      	beq.n	3419d532 <CMW_VD55G1_Probe+0x7e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419d52c:	f06f 0304 	mvn.w	r3, #4
3419d530:	e01e      	b.n	3419d570 <CMW_VD55G1_Probe+0xbc>
  }
  if (id != VD55G1_CHIP_ID)
3419d532:	68bb      	ldr	r3, [r7, #8]
3419d534:	4a1a      	ldr	r2, [pc, #104]	@ (3419d5a0 <CMW_VD55G1_Probe+0xec>)
3419d536:	4293      	cmp	r3, r2
3419d538:	d002      	beq.n	3419d540 <CMW_VD55G1_Probe+0x8c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419d53a:	f06f 0304 	mvn.w	r3, #4
3419d53e:	e017      	b.n	3419d570 <CMW_VD55G1_Probe+0xbc>
  }

  memset(vd55g1_if, 0, sizeof(*vd55g1_if));
3419d540:	2268      	movs	r2, #104	@ 0x68
3419d542:	2100      	movs	r1, #0
3419d544:	6838      	ldr	r0, [r7, #0]
3419d546:	f007 ffd3 	bl	341a54f0 <memset>
  vd55g1_if->Init = CMW_VD55G1_Init;
3419d54a:	683b      	ldr	r3, [r7, #0]
3419d54c:	4a15      	ldr	r2, [pc, #84]	@ (3419d5a4 <CMW_VD55G1_Probe+0xf0>)
3419d54e:	601a      	str	r2, [r3, #0]
  vd55g1_if->DeInit = CMW_VD55G1_DeInit;
3419d550:	683b      	ldr	r3, [r7, #0]
3419d552:	4a15      	ldr	r2, [pc, #84]	@ (3419d5a8 <CMW_VD55G1_Probe+0xf4>)
3419d554:	605a      	str	r2, [r3, #4]
  vd55g1_if->Start = CMW_VD55G1_Start;
3419d556:	683b      	ldr	r3, [r7, #0]
3419d558:	4a14      	ldr	r2, [pc, #80]	@ (3419d5ac <CMW_VD55G1_Probe+0xf8>)
3419d55a:	609a      	str	r2, [r3, #8]
  vd55g1_if->Stop = CMW_VD55G1_Stop;
3419d55c:	683b      	ldr	r3, [r7, #0]
3419d55e:	4a14      	ldr	r2, [pc, #80]	@ (3419d5b0 <CMW_VD55G1_Probe+0xfc>)
3419d560:	619a      	str	r2, [r3, #24]
  vd55g1_if->SetMirrorFlip = CMW_VD55G1_MirrorFlipConfig;
3419d562:	683b      	ldr	r3, [r7, #0]
3419d564:	4a13      	ldr	r2, [pc, #76]	@ (3419d5b4 <CMW_VD55G1_Probe+0x100>)
3419d566:	62da      	str	r2, [r3, #44]	@ 0x2c
  vd55g1_if->GetSensorInfo = CMW_VD55G1_GetSensorInfo;
3419d568:	683b      	ldr	r3, [r7, #0]
3419d56a:	4a13      	ldr	r2, [pc, #76]	@ (3419d5b8 <CMW_VD55G1_Probe+0x104>)
3419d56c:	661a      	str	r2, [r3, #96]	@ 0x60
  return ret;
3419d56e:	68fb      	ldr	r3, [r7, #12]
}
3419d570:	4618      	mov	r0, r3
3419d572:	3710      	adds	r7, #16
3419d574:	46bd      	mov	sp, r7
3419d576:	bd80      	pop	{r7, pc}
3419d578:	3419ceb9 	.word	0x3419ceb9
3419d57c:	3419cedb 	.word	0x3419cedb
3419d580:	3419cf05 	.word	0x3419cf05
3419d584:	3419cf2f 	.word	0x3419cf2f
3419d588:	3419cf59 	.word	0x3419cf59
3419d58c:	3419cf85 	.word	0x3419cf85
3419d590:	3419cfb1 	.word	0x3419cfb1
3419d594:	3419cfdb 	.word	0x3419cfdb
3419d598:	3419d047 	.word	0x3419d047
3419d59c:	3419d069 	.word	0x3419d069
3419d5a0:	53354731 	.word	0x53354731
3419d5a4:	3419d185 	.word	0x3419d185
3419d5a8:	3419d34b 	.word	0x3419d34b
3419d5ac:	3419d2e5 	.word	0x3419d2e5
3419d5b0:	3419d31d 	.word	0x3419d31d
3419d5b4:	3419d399 	.word	0x3419d399
3419d5b8:	3419d083 	.word	0x3419d083

3419d5bc <CMW_VD66GY_Read8>:
#define LINEAR_TO_MDECIBEL(linearValue)     (1000 * (20.0 * log10(linearValue)))
#define FLOAT_TO_FP58(x)                    (((uint16_t)(x) << 8) | ((uint16_t)((x - (uint16_t)(x)) * 256.0f) & 0xFF))
#define FP58_TO_FLOAT(fp)                   (((fp) >> 8) + ((fp) & 0xFF) / 256.0f)

static int CMW_VD66GY_Read8(CMW_VD66GY_t *pObj, uint16_t addr, uint8_t *value)
{
3419d5bc:	b590      	push	{r4, r7, lr}
3419d5be:	b085      	sub	sp, #20
3419d5c0:	af00      	add	r7, sp, #0
3419d5c2:	60f8      	str	r0, [r7, #12]
3419d5c4:	460b      	mov	r3, r1
3419d5c6:	607a      	str	r2, [r7, #4]
3419d5c8:	817b      	strh	r3, [r7, #10]
  return pObj->ReadReg(pObj->Address, addr, value, 1);
3419d5ca:	68fb      	ldr	r3, [r7, #12]
3419d5cc:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419d5d0:	68fb      	ldr	r3, [r7, #12]
3419d5d2:	8818      	ldrh	r0, [r3, #0]
3419d5d4:	8979      	ldrh	r1, [r7, #10]
3419d5d6:	2301      	movs	r3, #1
3419d5d8:	687a      	ldr	r2, [r7, #4]
3419d5da:	47a0      	blx	r4
3419d5dc:	4603      	mov	r3, r0
}
3419d5de:	4618      	mov	r0, r3
3419d5e0:	3714      	adds	r7, #20
3419d5e2:	46bd      	mov	sp, r7
3419d5e4:	bd90      	pop	{r4, r7, pc}

3419d5e6 <CMW_VD66GY_Read16>:

static int CMW_VD66GY_Read16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t *value)
{
3419d5e6:	b590      	push	{r4, r7, lr}
3419d5e8:	b087      	sub	sp, #28
3419d5ea:	af00      	add	r7, sp, #0
3419d5ec:	60f8      	str	r0, [r7, #12]
3419d5ee:	460b      	mov	r3, r1
3419d5f0:	607a      	str	r2, [r7, #4]
3419d5f2:	817b      	strh	r3, [r7, #10]
  uint8_t data[2];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 2);
3419d5f4:	68fb      	ldr	r3, [r7, #12]
3419d5f6:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419d5fa:	68fb      	ldr	r3, [r7, #12]
3419d5fc:	8818      	ldrh	r0, [r3, #0]
3419d5fe:	f107 0210 	add.w	r2, r7, #16
3419d602:	8979      	ldrh	r1, [r7, #10]
3419d604:	2302      	movs	r3, #2
3419d606:	47a0      	blx	r4
3419d608:	6178      	str	r0, [r7, #20]
  if (ret)
3419d60a:	697b      	ldr	r3, [r7, #20]
3419d60c:	2b00      	cmp	r3, #0
3419d60e:	d001      	beq.n	3419d614 <CMW_VD66GY_Read16+0x2e>
    return ret;
3419d610:	697b      	ldr	r3, [r7, #20]
3419d612:	e00b      	b.n	3419d62c <CMW_VD66GY_Read16+0x46>

  *value = (data[1] << 8) | data[0];
3419d614:	7c7b      	ldrb	r3, [r7, #17]
3419d616:	b21b      	sxth	r3, r3
3419d618:	021b      	lsls	r3, r3, #8
3419d61a:	b21a      	sxth	r2, r3
3419d61c:	7c3b      	ldrb	r3, [r7, #16]
3419d61e:	b21b      	sxth	r3, r3
3419d620:	4313      	orrs	r3, r2
3419d622:	b21b      	sxth	r3, r3
3419d624:	b29a      	uxth	r2, r3
3419d626:	687b      	ldr	r3, [r7, #4]
3419d628:	801a      	strh	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419d62a:	2300      	movs	r3, #0
}
3419d62c:	4618      	mov	r0, r3
3419d62e:	371c      	adds	r7, #28
3419d630:	46bd      	mov	sp, r7
3419d632:	bd90      	pop	{r4, r7, pc}

3419d634 <CMW_VD66GY_Read32>:

static int CMW_VD66GY_Read32(CMW_VD66GY_t *pObj, uint16_t addr, uint32_t *value)
{
3419d634:	b590      	push	{r4, r7, lr}
3419d636:	b087      	sub	sp, #28
3419d638:	af00      	add	r7, sp, #0
3419d63a:	60f8      	str	r0, [r7, #12]
3419d63c:	460b      	mov	r3, r1
3419d63e:	607a      	str	r2, [r7, #4]
3419d640:	817b      	strh	r3, [r7, #10]
  uint8_t data[4];
  int ret;

  ret = pObj->ReadReg(pObj->Address, addr, data, 4);
3419d642:	68fb      	ldr	r3, [r7, #12]
3419d644:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
3419d648:	68fb      	ldr	r3, [r7, #12]
3419d64a:	8818      	ldrh	r0, [r3, #0]
3419d64c:	f107 0210 	add.w	r2, r7, #16
3419d650:	8979      	ldrh	r1, [r7, #10]
3419d652:	2304      	movs	r3, #4
3419d654:	47a0      	blx	r4
3419d656:	6178      	str	r0, [r7, #20]
  if (ret)
3419d658:	697b      	ldr	r3, [r7, #20]
3419d65a:	2b00      	cmp	r3, #0
3419d65c:	d001      	beq.n	3419d662 <CMW_VD66GY_Read32+0x2e>
    return ret;
3419d65e:	697b      	ldr	r3, [r7, #20]
3419d660:	e00d      	b.n	3419d67e <CMW_VD66GY_Read32+0x4a>

  *value = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];
3419d662:	7cfb      	ldrb	r3, [r7, #19]
3419d664:	061a      	lsls	r2, r3, #24
3419d666:	7cbb      	ldrb	r3, [r7, #18]
3419d668:	041b      	lsls	r3, r3, #16
3419d66a:	431a      	orrs	r2, r3
3419d66c:	7c7b      	ldrb	r3, [r7, #17]
3419d66e:	021b      	lsls	r3, r3, #8
3419d670:	4313      	orrs	r3, r2
3419d672:	7c3a      	ldrb	r2, [r7, #16]
3419d674:	4313      	orrs	r3, r2
3419d676:	461a      	mov	r2, r3
3419d678:	687b      	ldr	r3, [r7, #4]
3419d67a:	601a      	str	r2, [r3, #0]

  return 0;
3419d67c:	2300      	movs	r3, #0
}
3419d67e:	4618      	mov	r0, r3
3419d680:	371c      	adds	r7, #28
3419d682:	46bd      	mov	sp, r7
3419d684:	bd90      	pop	{r4, r7, pc}

3419d686 <CMW_VD66GY_Write8>:

static int CMW_VD66GY_Write8(CMW_VD66GY_t *pObj, uint16_t addr, uint8_t value)
{
3419d686:	b590      	push	{r4, r7, lr}
3419d688:	b083      	sub	sp, #12
3419d68a:	af00      	add	r7, sp, #0
3419d68c:	6078      	str	r0, [r7, #4]
3419d68e:	460b      	mov	r3, r1
3419d690:	807b      	strh	r3, [r7, #2]
3419d692:	4613      	mov	r3, r2
3419d694:	707b      	strb	r3, [r7, #1]
  return pObj->WriteReg(pObj->Address, addr, &value, 1);
3419d696:	687b      	ldr	r3, [r7, #4]
3419d698:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419d69c:	687b      	ldr	r3, [r7, #4]
3419d69e:	8818      	ldrh	r0, [r3, #0]
3419d6a0:	1c7a      	adds	r2, r7, #1
3419d6a2:	8879      	ldrh	r1, [r7, #2]
3419d6a4:	2301      	movs	r3, #1
3419d6a6:	47a0      	blx	r4
3419d6a8:	4603      	mov	r3, r0
}
3419d6aa:	4618      	mov	r0, r3
3419d6ac:	370c      	adds	r7, #12
3419d6ae:	46bd      	mov	sp, r7
3419d6b0:	bd90      	pop	{r4, r7, pc}

3419d6b2 <CMW_VD66GY_Write16>:

static int CMW_VD66GY_Write16(CMW_VD66GY_t *pObj, uint16_t addr, uint16_t value)
{
3419d6b2:	b590      	push	{r4, r7, lr}
3419d6b4:	b083      	sub	sp, #12
3419d6b6:	af00      	add	r7, sp, #0
3419d6b8:	6078      	str	r0, [r7, #4]
3419d6ba:	460b      	mov	r3, r1
3419d6bc:	807b      	strh	r3, [r7, #2]
3419d6be:	4613      	mov	r3, r2
3419d6c0:	803b      	strh	r3, [r7, #0]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 2);
3419d6c2:	687b      	ldr	r3, [r7, #4]
3419d6c4:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419d6c8:	687b      	ldr	r3, [r7, #4]
3419d6ca:	8818      	ldrh	r0, [r3, #0]
3419d6cc:	463a      	mov	r2, r7
3419d6ce:	8879      	ldrh	r1, [r7, #2]
3419d6d0:	2302      	movs	r3, #2
3419d6d2:	47a0      	blx	r4
3419d6d4:	4603      	mov	r3, r0
}
3419d6d6:	4618      	mov	r0, r3
3419d6d8:	370c      	adds	r7, #12
3419d6da:	46bd      	mov	sp, r7
3419d6dc:	bd90      	pop	{r4, r7, pc}

3419d6de <CMW_VD66GY_Write32>:

static int CMW_VD66GY_Write32(CMW_VD66GY_t *pObj, uint16_t addr, uint32_t value)
{
3419d6de:	b590      	push	{r4, r7, lr}
3419d6e0:	b085      	sub	sp, #20
3419d6e2:	af00      	add	r7, sp, #0
3419d6e4:	60f8      	str	r0, [r7, #12]
3419d6e6:	460b      	mov	r3, r1
3419d6e8:	607a      	str	r2, [r7, #4]
3419d6ea:	817b      	strh	r3, [r7, #10]
  return pObj->WriteReg(pObj->Address, addr, (uint8_t *) &value, 4);
3419d6ec:	68fb      	ldr	r3, [r7, #12]
3419d6ee:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419d6f2:	68fb      	ldr	r3, [r7, #12]
3419d6f4:	8818      	ldrh	r0, [r3, #0]
3419d6f6:	1d3a      	adds	r2, r7, #4
3419d6f8:	8979      	ldrh	r1, [r7, #10]
3419d6fa:	2304      	movs	r3, #4
3419d6fc:	47a0      	blx	r4
3419d6fe:	4603      	mov	r3, r0
}
3419d700:	4618      	mov	r0, r3
3419d702:	3714      	adds	r7, #20
3419d704:	46bd      	mov	sp, r7
3419d706:	bd90      	pop	{r4, r7, pc}

3419d708 <VD6G_ShutdownPin>:

static void VD6G_ShutdownPin(struct VD6G_Ctx *ctx, int value)
{
3419d708:	b580      	push	{r7, lr}
3419d70a:	b084      	sub	sp, #16
3419d70c:	af00      	add	r7, sp, #0
3419d70e:	6078      	str	r0, [r7, #4]
3419d710:	6039      	str	r1, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d712:	687b      	ldr	r3, [r7, #4]
3419d714:	3b04      	subs	r3, #4
3419d716:	60fb      	str	r3, [r7, #12]

  p_ctx->ShutdownPin(value);
3419d718:	68fb      	ldr	r3, [r7, #12]
3419d71a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419d71e:	6838      	ldr	r0, [r7, #0]
3419d720:	4798      	blx	r3
}
3419d722:	bf00      	nop
3419d724:	3710      	adds	r7, #16
3419d726:	46bd      	mov	sp, r7
3419d728:	bd80      	pop	{r7, pc}

3419d72a <VD6G_Read8>:

static int VD6G_Read8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *value)
{
3419d72a:	b580      	push	{r7, lr}
3419d72c:	b086      	sub	sp, #24
3419d72e:	af00      	add	r7, sp, #0
3419d730:	60f8      	str	r0, [r7, #12]
3419d732:	460b      	mov	r3, r1
3419d734:	607a      	str	r2, [r7, #4]
3419d736:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d738:	68fb      	ldr	r3, [r7, #12]
3419d73a:	3b04      	subs	r3, #4
3419d73c:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read8(p_ctx, addr, value);
3419d73e:	897b      	ldrh	r3, [r7, #10]
3419d740:	687a      	ldr	r2, [r7, #4]
3419d742:	4619      	mov	r1, r3
3419d744:	6978      	ldr	r0, [r7, #20]
3419d746:	f7ff ff39 	bl	3419d5bc <CMW_VD66GY_Read8>
3419d74a:	4603      	mov	r3, r0
}
3419d74c:	4618      	mov	r0, r3
3419d74e:	3718      	adds	r7, #24
3419d750:	46bd      	mov	sp, r7
3419d752:	bd80      	pop	{r7, pc}

3419d754 <VD6G_Read16>:

static int VD6G_Read16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t *value)
{
3419d754:	b580      	push	{r7, lr}
3419d756:	b086      	sub	sp, #24
3419d758:	af00      	add	r7, sp, #0
3419d75a:	60f8      	str	r0, [r7, #12]
3419d75c:	460b      	mov	r3, r1
3419d75e:	607a      	str	r2, [r7, #4]
3419d760:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d762:	68fb      	ldr	r3, [r7, #12]
3419d764:	3b04      	subs	r3, #4
3419d766:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read16(p_ctx, addr, value);
3419d768:	897b      	ldrh	r3, [r7, #10]
3419d76a:	687a      	ldr	r2, [r7, #4]
3419d76c:	4619      	mov	r1, r3
3419d76e:	6978      	ldr	r0, [r7, #20]
3419d770:	f7ff ff39 	bl	3419d5e6 <CMW_VD66GY_Read16>
3419d774:	4603      	mov	r3, r0
}
3419d776:	4618      	mov	r0, r3
3419d778:	3718      	adds	r7, #24
3419d77a:	46bd      	mov	sp, r7
3419d77c:	bd80      	pop	{r7, pc}

3419d77e <VD6G_Read32>:

static int VD6G_Read32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t *value)
{
3419d77e:	b580      	push	{r7, lr}
3419d780:	b086      	sub	sp, #24
3419d782:	af00      	add	r7, sp, #0
3419d784:	60f8      	str	r0, [r7, #12]
3419d786:	460b      	mov	r3, r1
3419d788:	607a      	str	r2, [r7, #4]
3419d78a:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d78c:	68fb      	ldr	r3, [r7, #12]
3419d78e:	3b04      	subs	r3, #4
3419d790:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Read32(p_ctx, addr, value);
3419d792:	897b      	ldrh	r3, [r7, #10]
3419d794:	687a      	ldr	r2, [r7, #4]
3419d796:	4619      	mov	r1, r3
3419d798:	6978      	ldr	r0, [r7, #20]
3419d79a:	f7ff ff4b 	bl	3419d634 <CMW_VD66GY_Read32>
3419d79e:	4603      	mov	r3, r0
}
3419d7a0:	4618      	mov	r0, r3
3419d7a2:	3718      	adds	r7, #24
3419d7a4:	46bd      	mov	sp, r7
3419d7a6:	bd80      	pop	{r7, pc}

3419d7a8 <VD6G_Write8>:

static int VD6G_Write8(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t value)
{
3419d7a8:	b580      	push	{r7, lr}
3419d7aa:	b084      	sub	sp, #16
3419d7ac:	af00      	add	r7, sp, #0
3419d7ae:	6078      	str	r0, [r7, #4]
3419d7b0:	460b      	mov	r3, r1
3419d7b2:	807b      	strh	r3, [r7, #2]
3419d7b4:	4613      	mov	r3, r2
3419d7b6:	707b      	strb	r3, [r7, #1]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d7b8:	687b      	ldr	r3, [r7, #4]
3419d7ba:	3b04      	subs	r3, #4
3419d7bc:	60fb      	str	r3, [r7, #12]

  return CMW_VD66GY_Write8(p_ctx, addr, value);
3419d7be:	787a      	ldrb	r2, [r7, #1]
3419d7c0:	887b      	ldrh	r3, [r7, #2]
3419d7c2:	4619      	mov	r1, r3
3419d7c4:	68f8      	ldr	r0, [r7, #12]
3419d7c6:	f7ff ff5e 	bl	3419d686 <CMW_VD66GY_Write8>
3419d7ca:	4603      	mov	r3, r0
}
3419d7cc:	4618      	mov	r0, r3
3419d7ce:	3710      	adds	r7, #16
3419d7d0:	46bd      	mov	sp, r7
3419d7d2:	bd80      	pop	{r7, pc}

3419d7d4 <VD6G_Write16>:

static int VD6G_Write16(struct VD6G_Ctx *ctx, uint16_t addr, uint16_t value)
{
3419d7d4:	b580      	push	{r7, lr}
3419d7d6:	b084      	sub	sp, #16
3419d7d8:	af00      	add	r7, sp, #0
3419d7da:	6078      	str	r0, [r7, #4]
3419d7dc:	460b      	mov	r3, r1
3419d7de:	807b      	strh	r3, [r7, #2]
3419d7e0:	4613      	mov	r3, r2
3419d7e2:	803b      	strh	r3, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d7e4:	687b      	ldr	r3, [r7, #4]
3419d7e6:	3b04      	subs	r3, #4
3419d7e8:	60fb      	str	r3, [r7, #12]

  return CMW_VD66GY_Write16(p_ctx, addr, value);
3419d7ea:	883a      	ldrh	r2, [r7, #0]
3419d7ec:	887b      	ldrh	r3, [r7, #2]
3419d7ee:	4619      	mov	r1, r3
3419d7f0:	68f8      	ldr	r0, [r7, #12]
3419d7f2:	f7ff ff5e 	bl	3419d6b2 <CMW_VD66GY_Write16>
3419d7f6:	4603      	mov	r3, r0
}
3419d7f8:	4618      	mov	r0, r3
3419d7fa:	3710      	adds	r7, #16
3419d7fc:	46bd      	mov	sp, r7
3419d7fe:	bd80      	pop	{r7, pc}

3419d800 <VD6G_Write32>:

static int VD6G_Write32(struct VD6G_Ctx *ctx, uint16_t addr, uint32_t value)
{
3419d800:	b580      	push	{r7, lr}
3419d802:	b086      	sub	sp, #24
3419d804:	af00      	add	r7, sp, #0
3419d806:	60f8      	str	r0, [r7, #12]
3419d808:	460b      	mov	r3, r1
3419d80a:	607a      	str	r2, [r7, #4]
3419d80c:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d80e:	68fb      	ldr	r3, [r7, #12]
3419d810:	3b04      	subs	r3, #4
3419d812:	617b      	str	r3, [r7, #20]

  return CMW_VD66GY_Write32(p_ctx, addr, value);
3419d814:	897b      	ldrh	r3, [r7, #10]
3419d816:	687a      	ldr	r2, [r7, #4]
3419d818:	4619      	mov	r1, r3
3419d81a:	6978      	ldr	r0, [r7, #20]
3419d81c:	f7ff ff5f 	bl	3419d6de <CMW_VD66GY_Write32>
3419d820:	4603      	mov	r3, r0
}
3419d822:	4618      	mov	r0, r3
3419d824:	3718      	adds	r7, #24
3419d826:	46bd      	mov	sp, r7
3419d828:	bd80      	pop	{r7, pc}

3419d82a <VD6G_WriteArray>:

static int VD6G_WriteArray(struct VD6G_Ctx *ctx, uint16_t addr, uint8_t *data, int data_len)
{
3419d82a:	b590      	push	{r4, r7, lr}
3419d82c:	b089      	sub	sp, #36	@ 0x24
3419d82e:	af00      	add	r7, sp, #0
3419d830:	60f8      	str	r0, [r7, #12]
3419d832:	607a      	str	r2, [r7, #4]
3419d834:	603b      	str	r3, [r7, #0]
3419d836:	460b      	mov	r3, r1
3419d838:	817b      	strh	r3, [r7, #10]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d83a:	68fb      	ldr	r3, [r7, #12]
3419d83c:	3b04      	subs	r3, #4
3419d83e:	61fb      	str	r3, [r7, #28]
  const unsigned int chunk_size = 128;
3419d840:	2380      	movs	r3, #128	@ 0x80
3419d842:	61bb      	str	r3, [r7, #24]
  uint16_t sz;
  int ret;

  while (data_len) {
3419d844:	e020      	b.n	3419d888 <VD6G_WriteArray+0x5e>
    sz = MIN(data_len, chunk_size);
3419d846:	683a      	ldr	r2, [r7, #0]
3419d848:	69bb      	ldr	r3, [r7, #24]
3419d84a:	4293      	cmp	r3, r2
3419d84c:	bf28      	it	cs
3419d84e:	4613      	movcs	r3, r2
3419d850:	82fb      	strh	r3, [r7, #22]
    ret = p_ctx->WriteReg(p_ctx->Address, addr, data, sz);
3419d852:	69fb      	ldr	r3, [r7, #28]
3419d854:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
3419d858:	69fb      	ldr	r3, [r7, #28]
3419d85a:	8818      	ldrh	r0, [r3, #0]
3419d85c:	8afb      	ldrh	r3, [r7, #22]
3419d85e:	8979      	ldrh	r1, [r7, #10]
3419d860:	687a      	ldr	r2, [r7, #4]
3419d862:	47a0      	blx	r4
3419d864:	6138      	str	r0, [r7, #16]
    if (ret)
3419d866:	693b      	ldr	r3, [r7, #16]
3419d868:	2b00      	cmp	r3, #0
3419d86a:	d001      	beq.n	3419d870 <VD6G_WriteArray+0x46>
      return ret;
3419d86c:	693b      	ldr	r3, [r7, #16]
3419d86e:	e00f      	b.n	3419d890 <VD6G_WriteArray+0x66>
    data_len -= sz;
3419d870:	8afb      	ldrh	r3, [r7, #22]
3419d872:	683a      	ldr	r2, [r7, #0]
3419d874:	1ad3      	subs	r3, r2, r3
3419d876:	603b      	str	r3, [r7, #0]
    addr += sz;
3419d878:	897a      	ldrh	r2, [r7, #10]
3419d87a:	8afb      	ldrh	r3, [r7, #22]
3419d87c:	4413      	add	r3, r2
3419d87e:	817b      	strh	r3, [r7, #10]
    data += sz;
3419d880:	8afb      	ldrh	r3, [r7, #22]
3419d882:	687a      	ldr	r2, [r7, #4]
3419d884:	4413      	add	r3, r2
3419d886:	607b      	str	r3, [r7, #4]
  while (data_len) {
3419d888:	683b      	ldr	r3, [r7, #0]
3419d88a:	2b00      	cmp	r3, #0
3419d88c:	d1db      	bne.n	3419d846 <VD6G_WriteArray+0x1c>
  }

  return 0;
3419d88e:	2300      	movs	r3, #0
}
3419d890:	4618      	mov	r0, r3
3419d892:	3724      	adds	r7, #36	@ 0x24
3419d894:	46bd      	mov	sp, r7
3419d896:	bd90      	pop	{r4, r7, pc}

3419d898 <VD6G_Delay>:

static void VD6G_Delay(struct VD6G_Ctx *ctx, uint32_t delay_in_ms)
{
3419d898:	b580      	push	{r7, lr}
3419d89a:	b084      	sub	sp, #16
3419d89c:	af00      	add	r7, sp, #0
3419d89e:	6078      	str	r0, [r7, #4]
3419d8a0:	6039      	str	r1, [r7, #0]
  CMW_VD66GY_t *p_ctx = container_of(ctx, CMW_VD66GY_t, ctx_driver);
3419d8a2:	687b      	ldr	r3, [r7, #4]
3419d8a4:	3b04      	subs	r3, #4
3419d8a6:	60fb      	str	r3, [r7, #12]

  p_ctx->Delay(delay_in_ms);
3419d8a8:	68fb      	ldr	r3, [r7, #12]
3419d8aa:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
3419d8ae:	6838      	ldr	r0, [r7, #0]
3419d8b0:	4798      	blx	r3
}
3419d8b2:	bf00      	nop
3419d8b4:	3710      	adds	r7, #16
3419d8b6:	46bd      	mov	sp, r7
3419d8b8:	bd80      	pop	{r7, pc}

3419d8ba <VD6G_Log>:

static void VD6G_Log(struct VD6G_Ctx *ctx, int lvl, const char *format, va_list ap)
{
3419d8ba:	b480      	push	{r7}
3419d8bc:	b085      	sub	sp, #20
3419d8be:	af00      	add	r7, sp, #0
3419d8c0:	60f8      	str	r0, [r7, #12]
3419d8c2:	60b9      	str	r1, [r7, #8]
3419d8c4:	607a      	str	r2, [r7, #4]
3419d8c6:	603b      	str	r3, [r7, #0]
  if (lvl > current_lvl)
    return ;

  vprintf(format, ap);
#endif
}
3419d8c8:	bf00      	nop
3419d8ca:	3714      	adds	r7, #20
3419d8cc:	46bd      	mov	sp, r7
3419d8ce:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d8d2:	4770      	bx	lr

3419d8d4 <CMW_VD66GY_GetResType>:

static int CMW_VD66GY_GetResType(uint32_t width, uint32_t height, VD6G_Res_t *res)
{
3419d8d4:	b480      	push	{r7}
3419d8d6:	b085      	sub	sp, #20
3419d8d8:	af00      	add	r7, sp, #0
3419d8da:	60f8      	str	r0, [r7, #12]
3419d8dc:	60b9      	str	r1, [r7, #8]
3419d8de:	607a      	str	r2, [r7, #4]
  if (width == 320 && height == 240)
3419d8e0:	68fb      	ldr	r3, [r7, #12]
3419d8e2:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
3419d8e6:	d106      	bne.n	3419d8f6 <CMW_VD66GY_GetResType+0x22>
3419d8e8:	68bb      	ldr	r3, [r7, #8]
3419d8ea:	2bf0      	cmp	r3, #240	@ 0xf0
3419d8ec:	d103      	bne.n	3419d8f6 <CMW_VD66GY_GetResType+0x22>
  {
    *res = VD6G_RES_QVGA_320_240;
3419d8ee:	687b      	ldr	r3, [r7, #4]
3419d8f0:	2200      	movs	r2, #0
3419d8f2:	701a      	strb	r2, [r3, #0]
3419d8f4:	e033      	b.n	3419d95e <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 640 && height == 480)
3419d8f6:	68fb      	ldr	r3, [r7, #12]
3419d8f8:	f5b3 7f20 	cmp.w	r3, #640	@ 0x280
3419d8fc:	d107      	bne.n	3419d90e <CMW_VD66GY_GetResType+0x3a>
3419d8fe:	68bb      	ldr	r3, [r7, #8]
3419d900:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3419d904:	d103      	bne.n	3419d90e <CMW_VD66GY_GetResType+0x3a>
  {
    *res = VD6G_RES_VGA_640_480;
3419d906:	687b      	ldr	r3, [r7, #4]
3419d908:	2201      	movs	r2, #1
3419d90a:	701a      	strb	r2, [r3, #0]
3419d90c:	e027      	b.n	3419d95e <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1024 && height == 768)
3419d90e:	68fb      	ldr	r3, [r7, #12]
3419d910:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3419d914:	d107      	bne.n	3419d926 <CMW_VD66GY_GetResType+0x52>
3419d916:	68bb      	ldr	r3, [r7, #8]
3419d918:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3419d91c:	d103      	bne.n	3419d926 <CMW_VD66GY_GetResType+0x52>
  {
    *res = VD6G_RES_XGA_1024_768;
3419d91e:	687b      	ldr	r3, [r7, #4]
3419d920:	2203      	movs	r2, #3
3419d922:	701a      	strb	r2, [r3, #0]
3419d924:	e01b      	b.n	3419d95e <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1120 && height == 720)
3419d926:	68fb      	ldr	r3, [r7, #12]
3419d928:	f5b3 6f8c 	cmp.w	r3, #1120	@ 0x460
3419d92c:	d107      	bne.n	3419d93e <CMW_VD66GY_GetResType+0x6a>
3419d92e:	68bb      	ldr	r3, [r7, #8]
3419d930:	f5b3 7f34 	cmp.w	r3, #720	@ 0x2d0
3419d934:	d103      	bne.n	3419d93e <CMW_VD66GY_GetResType+0x6a>
  {
    *res = VD6G_RES_PORTRAIT_1120_720;
3419d936:	687b      	ldr	r3, [r7, #4]
3419d938:	2207      	movs	r2, #7
3419d93a:	701a      	strb	r2, [r3, #0]
3419d93c:	e00f      	b.n	3419d95e <CMW_VD66GY_GetResType+0x8a>
  }
  else if (width == 1120 && height == 1364)
3419d93e:	68fb      	ldr	r3, [r7, #12]
3419d940:	f5b3 6f8c 	cmp.w	r3, #1120	@ 0x460
3419d944:	d108      	bne.n	3419d958 <CMW_VD66GY_GetResType+0x84>
3419d946:	68bb      	ldr	r3, [r7, #8]
3419d948:	f240 5254 	movw	r2, #1364	@ 0x554
3419d94c:	4293      	cmp	r3, r2
3419d94e:	d103      	bne.n	3419d958 <CMW_VD66GY_GetResType+0x84>
  {
    *res = VD6G_RES_FULL_1120_1364;
3419d950:	687b      	ldr	r3, [r7, #4]
3419d952:	2208      	movs	r2, #8
3419d954:	701a      	strb	r2, [r3, #0]
3419d956:	e002      	b.n	3419d95e <CMW_VD66GY_GetResType+0x8a>
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
3419d958:	f06f 0301 	mvn.w	r3, #1
3419d95c:	e000      	b.n	3419d960 <CMW_VD66GY_GetResType+0x8c>
  }
  return 0;
3419d95e:	2300      	movs	r3, #0
}
3419d960:	4618      	mov	r0, r3
3419d962:	3714      	adds	r7, #20
3419d964:	46bd      	mov	sp, r7
3419d966:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d96a:	4770      	bx	lr

3419d96c <CMW_VD66GY_getMirrorFlipConfig>:

static VD6G_MirrorFlip_t CMW_VD66GY_getMirrorFlipConfig(uint32_t Config)
{
3419d96c:	b480      	push	{r7}
3419d96e:	b085      	sub	sp, #20
3419d970:	af00      	add	r7, sp, #0
3419d972:	6078      	str	r0, [r7, #4]
  VD6G_MirrorFlip_t ret;

  switch (Config)
3419d974:	687b      	ldr	r3, [r7, #4]
3419d976:	2b02      	cmp	r3, #2
3419d978:	d00f      	beq.n	3419d99a <CMW_VD66GY_getMirrorFlipConfig+0x2e>
3419d97a:	687b      	ldr	r3, [r7, #4]
3419d97c:	2b02      	cmp	r3, #2
3419d97e:	d80f      	bhi.n	3419d9a0 <CMW_VD66GY_getMirrorFlipConfig+0x34>
3419d980:	687b      	ldr	r3, [r7, #4]
3419d982:	2b00      	cmp	r3, #0
3419d984:	d003      	beq.n	3419d98e <CMW_VD66GY_getMirrorFlipConfig+0x22>
3419d986:	687b      	ldr	r3, [r7, #4]
3419d988:	2b01      	cmp	r3, #1
3419d98a:	d003      	beq.n	3419d994 <CMW_VD66GY_getMirrorFlipConfig+0x28>
3419d98c:	e008      	b.n	3419d9a0 <CMW_VD66GY_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = VD6G_MIRROR_FLIP_NONE;
3419d98e:	2300      	movs	r3, #0
3419d990:	73fb      	strb	r3, [r7, #15]
      break;
3419d992:	e008      	b.n	3419d9a6 <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = VD6G_FLIP;
3419d994:	2301      	movs	r3, #1
3419d996:	73fb      	strb	r3, [r7, #15]
      break;
3419d998:	e005      	b.n	3419d9a6 <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = VD6G_MIRROR;
3419d99a:	2302      	movs	r3, #2
3419d99c:	73fb      	strb	r3, [r7, #15]
      break;
3419d99e:	e002      	b.n	3419d9a6 <CMW_VD66GY_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = VD6G_MIRROR_FLIP;
3419d9a0:	2303      	movs	r3, #3
3419d9a2:	73fb      	strb	r3, [r7, #15]
      break;
3419d9a4:	bf00      	nop
  }

  return ret;
3419d9a6:	7bfb      	ldrb	r3, [r7, #15]
}
3419d9a8:	4618      	mov	r0, r3
3419d9aa:	3714      	adds	r7, #20
3419d9ac:	46bd      	mov	sp, r7
3419d9ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3419d9b2:	4770      	bx	lr

3419d9b4 <CMW_VD66GY_Init>:

static int32_t CMW_VD66GY_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3419d9b4:	b580      	push	{r7, lr}
3419d9b6:	b09a      	sub	sp, #104	@ 0x68
3419d9b8:	af00      	add	r7, sp, #0
3419d9ba:	6078      	str	r0, [r7, #4]
3419d9bc:	6039      	str	r1, [r7, #0]
  VD6G_Config_t config = { 0 };
3419d9be:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419d9c2:	2238      	movs	r2, #56	@ 0x38
3419d9c4:	2100      	movs	r1, #0
3419d9c6:	4618      	mov	r0, r3
3419d9c8:	f007 fd92 	bl	341a54f0 <memset>
  int ret;
  int i;

  assert(initSensor != NULL);
3419d9cc:	683b      	ldr	r3, [r7, #0]
3419d9ce:	2b00      	cmp	r3, #0
3419d9d0:	d105      	bne.n	3419d9de <CMW_VD66GY_Init+0x2a>
3419d9d2:	4b43      	ldr	r3, [pc, #268]	@ (3419dae0 <CMW_VD66GY_Init+0x12c>)
3419d9d4:	4a43      	ldr	r2, [pc, #268]	@ (3419dae4 <CMW_VD66GY_Init+0x130>)
3419d9d6:	21ee      	movs	r1, #238	@ 0xee
3419d9d8:	4843      	ldr	r0, [pc, #268]	@ (3419dae8 <CMW_VD66GY_Init+0x134>)
3419d9da:	f007 faff 	bl	341a4fdc <__assert_func>

  if (((CMW_VD66GY_t *)io_ctx)->IsInitialized)
3419d9de:	687b      	ldr	r3, [r7, #4]
3419d9e0:	f893 311c 	ldrb.w	r3, [r3, #284]	@ 0x11c
3419d9e4:	2b00      	cmp	r3, #0
3419d9e6:	d001      	beq.n	3419d9ec <CMW_VD66GY_Init+0x38>
  {
    return CMW_ERROR_NONE;
3419d9e8:	2300      	movs	r3, #0
3419d9ea:	e075      	b.n	3419dad8 <CMW_VD66GY_Init+0x124>
  }

  config.frame_rate = initSensor->fps;
3419d9ec:	683b      	ldr	r3, [r7, #0]
3419d9ee:	689b      	ldr	r3, [r3, #8]
3419d9f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  ret = CMW_VD66GY_GetResType(initSensor->width, initSensor->height, &config.resolution);
3419d9f2:	683b      	ldr	r3, [r7, #0]
3419d9f4:	6818      	ldr	r0, [r3, #0]
3419d9f6:	683b      	ldr	r3, [r7, #0]
3419d9f8:	6859      	ldr	r1, [r3, #4]
3419d9fa:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419d9fe:	3304      	adds	r3, #4
3419da00:	461a      	mov	r2, r3
3419da02:	f7ff ff67 	bl	3419d8d4 <CMW_VD66GY_GetResType>
3419da06:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret)
3419da08:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419da0a:	2b00      	cmp	r3, #0
3419da0c:	d002      	beq.n	3419da14 <CMW_VD66GY_Init+0x60>
  {
    return CMW_ERROR_WRONG_PARAM;
3419da0e:	f06f 0301 	mvn.w	r3, #1
3419da12:	e061      	b.n	3419dad8 <CMW_VD66GY_Init+0x124>
  }

  CMW_VD66GY_config_t default_sensor_config;
  CMW_VD66GY_config_t *sensor_config;

  CMW_VD66GY_SetDefaultSensorValues(&default_sensor_config);
3419da14:	f107 0308 	add.w	r3, r7, #8
3419da18:	4618      	mov	r0, r3
3419da1a:	f000 f867 	bl	3419daec <CMW_VD66GY_SetDefaultSensorValues>
  sensor_config = initSensor->sensor_config ? (CMW_VD66GY_config_t*)(initSensor->sensor_config) : &default_sensor_config;
3419da1e:	683b      	ldr	r3, [r7, #0]
3419da20:	695b      	ldr	r3, [r3, #20]
3419da22:	2b00      	cmp	r3, #0
3419da24:	d002      	beq.n	3419da2c <CMW_VD66GY_Init+0x78>
3419da26:	683b      	ldr	r3, [r7, #0]
3419da28:	695b      	ldr	r3, [r3, #20]
3419da2a:	e001      	b.n	3419da30 <CMW_VD66GY_Init+0x7c>
3419da2c:	f107 0308 	add.w	r3, r7, #8
3419da30:	65fb      	str	r3, [r7, #92]	@ 0x5c

  config.ext_clock_freq_in_hz = sensor_config->ext_clock_freq_in_hz;
3419da32:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da34:	681b      	ldr	r3, [r3, #0]
3419da36:	627b      	str	r3, [r7, #36]	@ 0x24
  config.line_len = sensor_config->line_len;
3419da38:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da3a:	685b      	ldr	r3, [r3, #4]
3419da3c:	637b      	str	r3, [r7, #52]	@ 0x34
  config.out_itf.datalane_nb = sensor_config->csiconfig.datalane_nb;
3419da3e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da40:	689b      	ldr	r3, [r3, #8]
3419da42:	63fb      	str	r3, [r7, #60]	@ 0x3c
  config.out_itf.clock_lane_swap_enable = sensor_config->csiconfig.clock_lane_swap_enable;
3419da44:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da46:	68db      	ldr	r3, [r3, #12]
3419da48:	643b      	str	r3, [r7, #64]	@ 0x40
  config.out_itf.data_lane0_swap_enable = sensor_config->csiconfig.data_lane0_swap_enable;
3419da4a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da4c:	691b      	ldr	r3, [r3, #16]
3419da4e:	647b      	str	r3, [r7, #68]	@ 0x44
  config.out_itf.data_lane1_swap_enable = sensor_config->csiconfig.data_lane1_swap_enable;
3419da50:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da52:	695b      	ldr	r3, [r3, #20]
3419da54:	64bb      	str	r3, [r7, #72]	@ 0x48
  config.out_itf.data_lanes_mapping_swap_enable = sensor_config->csiconfig.data_lanes_mapping_swap_enable;
3419da56:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3419da58:	699b      	ldr	r3, [r3, #24]
3419da5a:	64fb      	str	r3, [r7, #76]	@ 0x4c

  config.flip_mirror_mode = CMW_VD66GY_getMirrorFlipConfig(initSensor->mirrorFlip);
3419da5c:	683b      	ldr	r3, [r7, #0]
3419da5e:	691b      	ldr	r3, [r3, #16]
3419da60:	4618      	mov	r0, r3
3419da62:	f7ff ff83 	bl	3419d96c <CMW_VD66GY_getMirrorFlipConfig>
3419da66:	4603      	mov	r3, r0
3419da68:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  config.patgen = VD6G_PATGEN_DISABLE;
3419da6c:	2300      	movs	r3, #0
3419da6e:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  config.flicker = VD6G_FLICKER_FREE_NONE;
3419da72:	2300      	movs	r3, #0
3419da74:	f887 3039 	strb.w	r3, [r7, #57]	@ 0x39

  for (i = 0; i < VD6G_GPIO_NB; i++)
3419da78:	2300      	movs	r3, #0
3419da7a:	667b      	str	r3, [r7, #100]	@ 0x64
3419da7c:	e008      	b.n	3419da90 <CMW_VD66GY_Init+0xdc>
  {
    config.gpio_ctrl[i] = VD6G_GPIO_GPIO_IN;
3419da7e:	f107 0250 	add.w	r2, r7, #80	@ 0x50
3419da82:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419da84:	4413      	add	r3, r2
3419da86:	2201      	movs	r2, #1
3419da88:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < VD6G_GPIO_NB; i++)
3419da8a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419da8c:	3301      	adds	r3, #1
3419da8e:	667b      	str	r3, [r7, #100]	@ 0x64
3419da90:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3419da92:	2b07      	cmp	r3, #7
3419da94:	ddf3      	ble.n	3419da7e <CMW_VD66GY_Init+0xca>
  }

  ret = VD6G_Init(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &config);
3419da96:	687b      	ldr	r3, [r7, #4]
3419da98:	3304      	adds	r3, #4
3419da9a:	f107 0224 	add.w	r2, r7, #36	@ 0x24
3419da9e:	4611      	mov	r1, r2
3419daa0:	4618      	mov	r0, r3
3419daa2:	f004 f973 	bl	341a1d8c <VD6G_Init>
3419daa6:	6638      	str	r0, [r7, #96]	@ 0x60
  if (ret)
3419daa8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3419daaa:	2b00      	cmp	r3, #0
3419daac:	d002      	beq.n	3419dab4 <CMW_VD66GY_Init+0x100>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419daae:	f06f 0303 	mvn.w	r3, #3
3419dab2:	e011      	b.n	3419dad8 <CMW_VD66GY_Init+0x124>
  }

  if (((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer == VD6G_BAYER_NONE)
3419dab4:	687b      	ldr	r3, [r7, #4]
3419dab6:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
3419daba:	2b00      	cmp	r3, #0
3419dabc:	d107      	bne.n	3419dace <CMW_VD66GY_Init+0x11a>
  {
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419dabe:	687b      	ldr	r3, [r7, #4]
3419dac0:	3304      	adds	r3, #4
3419dac2:	4618      	mov	r0, r3
3419dac4:	f004 f9ee 	bl	341a1ea4 <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419dac8:	f06f 0303 	mvn.w	r3, #3
3419dacc:	e004      	b.n	3419dad8 <CMW_VD66GY_Init+0x124>
  }

  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 1;
3419dace:	687b      	ldr	r3, [r7, #4]
3419dad0:	2201      	movs	r2, #1
3419dad2:	f883 211c 	strb.w	r2, [r3, #284]	@ 0x11c
  return CMW_ERROR_NONE;
3419dad6:	2300      	movs	r3, #0
}
3419dad8:	4618      	mov	r0, r3
3419dada:	3768      	adds	r7, #104	@ 0x68
3419dadc:	46bd      	mov	sp, r7
3419dade:	bd80      	pop	{r7, pc}
3419dae0:	341a76dc 	.word	0x341a76dc
3419dae4:	341a84a0 	.word	0x341a84a0
3419dae8:	341a76f0 	.word	0x341a76f0

3419daec <CMW_VD66GY_SetDefaultSensorValues>:

void CMW_VD66GY_SetDefaultSensorValues(CMW_VD66GY_config_t *vd66gy_config)
{
3419daec:	b580      	push	{r7, lr}
3419daee:	b082      	sub	sp, #8
3419daf0:	af00      	add	r7, sp, #0
3419daf2:	6078      	str	r0, [r7, #4]
  assert(vd66gy_config != NULL);
3419daf4:	687b      	ldr	r3, [r7, #4]
3419daf6:	2b00      	cmp	r3, #0
3419daf8:	d106      	bne.n	3419db08 <CMW_VD66GY_SetDefaultSensorValues+0x1c>
3419dafa:	4b10      	ldr	r3, [pc, #64]	@ (3419db3c <CMW_VD66GY_SetDefaultSensorValues+0x50>)
3419dafc:	4a10      	ldr	r2, [pc, #64]	@ (3419db40 <CMW_VD66GY_SetDefaultSensorValues+0x54>)
3419dafe:	f240 1125 	movw	r1, #293	@ 0x125
3419db02:	4810      	ldr	r0, [pc, #64]	@ (3419db44 <CMW_VD66GY_SetDefaultSensorValues+0x58>)
3419db04:	f007 fa6a 	bl	341a4fdc <__assert_func>

  vd66gy_config->ext_clock_freq_in_hz = CAMERA_VD66GY_FREQ_IN_HZ; // Default clock frequency
3419db08:	687b      	ldr	r3, [r7, #4]
3419db0a:	4a0f      	ldr	r2, [pc, #60]	@ (3419db48 <CMW_VD66GY_SetDefaultSensorValues+0x5c>)
3419db0c:	601a      	str	r2, [r3, #0]
  vd66gy_config->line_len = 0; // Default line length
3419db0e:	687b      	ldr	r3, [r7, #4]
3419db10:	2200      	movs	r2, #0
3419db12:	605a      	str	r2, [r3, #4]
  vd66gy_config->csiconfig.datalane_nb = 2;
3419db14:	687b      	ldr	r3, [r7, #4]
3419db16:	2202      	movs	r2, #2
3419db18:	609a      	str	r2, [r3, #8]
  vd66gy_config->csiconfig.clock_lane_swap_enable = 1;
3419db1a:	687b      	ldr	r3, [r7, #4]
3419db1c:	2201      	movs	r2, #1
3419db1e:	60da      	str	r2, [r3, #12]
  vd66gy_config->csiconfig.data_lane0_swap_enable = 1;
3419db20:	687b      	ldr	r3, [r7, #4]
3419db22:	2201      	movs	r2, #1
3419db24:	611a      	str	r2, [r3, #16]
  vd66gy_config->csiconfig.data_lane1_swap_enable = 1;
3419db26:	687b      	ldr	r3, [r7, #4]
3419db28:	2201      	movs	r2, #1
3419db2a:	615a      	str	r2, [r3, #20]
  vd66gy_config->csiconfig.data_lanes_mapping_swap_enable = 0;
3419db2c:	687b      	ldr	r3, [r7, #4]
3419db2e:	2200      	movs	r2, #0
3419db30:	619a      	str	r2, [r3, #24]
}
3419db32:	bf00      	nop
3419db34:	3708      	adds	r7, #8
3419db36:	46bd      	mov	sp, r7
3419db38:	bd80      	pop	{r7, pc}
3419db3a:	bf00      	nop
3419db3c:	341a7728 	.word	0x341a7728
3419db40:	341a84b0 	.word	0x341a84b0
3419db44:	341a76f0 	.word	0x341a76f0
3419db48:	00b71b00 	.word	0x00b71b00

3419db4c <CMW_VD66GY_Start>:

static int32_t CMW_VD66GY_Start(void *io_ctx)
{
3419db4c:	b580      	push	{r7, lr}
3419db4e:	b086      	sub	sp, #24
3419db50:	af02      	add	r7, sp, #8
3419db52:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419db54:	2300      	movs	r3, #0
3419db56:	60fb      	str	r3, [r7, #12]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Statistic area is provided with null value so that it force the ISP Library to get the statistic
   * area information from the tuning file.
   */
  (void) ISP_IQParamCacheInit; /* unused */
  ret = ISP_Init(&((CMW_VD66GY_t *)io_ctx)->hIsp, ((CMW_VD66GY_t *)io_ctx)->hdcmipp, 0, &((CMW_VD66GY_t *)io_ctx)->appliHelpers, &ISP_IQParamCacheInit_VD66GY);
3419db58:	687b      	ldr	r3, [r7, #4]
3419db5a:	f103 006c 	add.w	r0, r3, #108	@ 0x6c
3419db5e:	687b      	ldr	r3, [r7, #4]
3419db60:	f8d3 1118 	ldr.w	r1, [r3, #280]	@ 0x118
3419db64:	687b      	ldr	r3, [r7, #4]
3419db66:	33f4      	adds	r3, #244	@ 0xf4
3419db68:	4a17      	ldr	r2, [pc, #92]	@ (3419dbc8 <CMW_VD66GY_Start+0x7c>)
3419db6a:	9200      	str	r2, [sp, #0]
3419db6c:	2200      	movs	r2, #0
3419db6e:	f7fb fc19 	bl	341993a4 <ISP_Init>
3419db72:	4603      	mov	r3, r0
3419db74:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419db76:	68fb      	ldr	r3, [r7, #12]
3419db78:	2b00      	cmp	r3, #0
3419db7a:	d002      	beq.n	3419db82 <CMW_VD66GY_Start+0x36>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419db7c:	f06f 0304 	mvn.w	r3, #4
3419db80:	e01e      	b.n	3419dbc0 <CMW_VD66GY_Start+0x74>
  }

  ret = ISP_Start(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419db82:	687b      	ldr	r3, [r7, #4]
3419db84:	336c      	adds	r3, #108	@ 0x6c
3419db86:	4618      	mov	r0, r3
3419db88:	f7fb fcf2 	bl	34199570 <ISP_Start>
3419db8c:	4603      	mov	r3, r0
3419db8e:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419db90:	68fb      	ldr	r3, [r7, #12]
3419db92:	2b00      	cmp	r3, #0
3419db94:	d002      	beq.n	3419db9c <CMW_VD66GY_Start+0x50>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419db96:	f06f 0303 	mvn.w	r3, #3
3419db9a:	e011      	b.n	3419dbc0 <CMW_VD66GY_Start+0x74>
  }
#endif
  ret = VD6G_Start(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419db9c:	687b      	ldr	r3, [r7, #4]
3419db9e:	3304      	adds	r3, #4
3419dba0:	4618      	mov	r0, r3
3419dba2:	f004 f99c 	bl	341a1ede <VD6G_Start>
3419dba6:	60f8      	str	r0, [r7, #12]
  if (ret) {
3419dba8:	68fb      	ldr	r3, [r7, #12]
3419dbaa:	2b00      	cmp	r3, #0
3419dbac:	d007      	beq.n	3419dbbe <CMW_VD66GY_Start+0x72>
    VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419dbae:	687b      	ldr	r3, [r7, #4]
3419dbb0:	3304      	adds	r3, #4
3419dbb2:	4618      	mov	r0, r3
3419dbb4:	f004 f976 	bl	341a1ea4 <VD6G_DeInit>
    return CMW_ERROR_PERIPH_FAILURE;
3419dbb8:	f06f 0303 	mvn.w	r3, #3
3419dbbc:	e000      	b.n	3419dbc0 <CMW_VD66GY_Start+0x74>
  }
  return CMW_ERROR_NONE;
3419dbbe:	2300      	movs	r3, #0
}
3419dbc0:	4618      	mov	r0, r3
3419dbc2:	3710      	adds	r7, #16
3419dbc4:	46bd      	mov	sp, r7
3419dbc6:	bd80      	pop	{r7, pc}
3419dbc8:	341a8248 	.word	0x341a8248

3419dbcc <CMW_VD66GY_Run>:

static int32_t CMW_VD66GY_Run(void *io_ctx)
{
3419dbcc:	b580      	push	{r7, lr}
3419dbce:	b084      	sub	sp, #16
3419dbd0:	af00      	add	r7, sp, #0
3419dbd2:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  ret = ISP_BackgroundProcess(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419dbd4:	687b      	ldr	r3, [r7, #4]
3419dbd6:	336c      	adds	r3, #108	@ 0x6c
3419dbd8:	4618      	mov	r0, r3
3419dbda:	f7fb fdd1 	bl	34199780 <ISP_BackgroundProcess>
3419dbde:	4603      	mov	r3, r0
3419dbe0:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3419dbe2:	68fb      	ldr	r3, [r7, #12]
3419dbe4:	2b00      	cmp	r3, #0
3419dbe6:	d002      	beq.n	3419dbee <CMW_VD66GY_Run+0x22>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3419dbe8:	f06f 0303 	mvn.w	r3, #3
3419dbec:	e000      	b.n	3419dbf0 <CMW_VD66GY_Run+0x24>
  }
#endif
  return CMW_ERROR_NONE;
3419dbee:	2300      	movs	r3, #0
}
3419dbf0:	4618      	mov	r0, r3
3419dbf2:	3710      	adds	r7, #16
3419dbf4:	46bd      	mov	sp, r7
3419dbf6:	bd80      	pop	{r7, pc}

3419dbf8 <CMW_VD66GY_Stop>:

static int32_t CMW_VD66GY_Stop(void *io_ctx)
{
3419dbf8:	b580      	push	{r7, lr}
3419dbfa:	b084      	sub	sp, #16
3419dbfc:	af00      	add	r7, sp, #0
3419dbfe:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419dc00:	2300      	movs	r3, #0
3419dc02:	60fb      	str	r3, [r7, #12]

  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419dc04:	687b      	ldr	r3, [r7, #4]
3419dc06:	3304      	adds	r3, #4
3419dc08:	4618      	mov	r0, r3
3419dc0a:	f004 f989 	bl	341a1f20 <VD6G_Stop>
3419dc0e:	60f8      	str	r0, [r7, #12]
  if (ret)
3419dc10:	68fb      	ldr	r3, [r7, #12]
3419dc12:	2b00      	cmp	r3, #0
3419dc14:	d002      	beq.n	3419dc1c <CMW_VD66GY_Stop+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419dc16:	f06f 0303 	mvn.w	r3, #3
3419dc1a:	e000      	b.n	3419dc1e <CMW_VD66GY_Stop+0x26>
  }
  return CMW_ERROR_NONE;
3419dc1c:	2300      	movs	r3, #0
}
3419dc1e:	4618      	mov	r0, r3
3419dc20:	3710      	adds	r7, #16
3419dc22:	46bd      	mov	sp, r7
3419dc24:	bd80      	pop	{r7, pc}

3419dc26 <CMW_VD66GY_DeInit>:

static int32_t CMW_VD66GY_DeInit(void *io_ctx)
{
3419dc26:	b580      	push	{r7, lr}
3419dc28:	b084      	sub	sp, #16
3419dc2a:	af00      	add	r7, sp, #0
3419dc2c:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3419dc2e:	2300      	movs	r3, #0
3419dc30:	60fb      	str	r3, [r7, #12]

  ret = VD6G_Stop(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419dc32:	687b      	ldr	r3, [r7, #4]
3419dc34:	3304      	adds	r3, #4
3419dc36:	4618      	mov	r0, r3
3419dc38:	f004 f972 	bl	341a1f20 <VD6G_Stop>
3419dc3c:	60f8      	str	r0, [r7, #12]
  if (ret)
3419dc3e:	68fb      	ldr	r3, [r7, #12]
3419dc40:	2b00      	cmp	r3, #0
3419dc42:	d002      	beq.n	3419dc4a <CMW_VD66GY_DeInit+0x24>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419dc44:	f06f 0303 	mvn.w	r3, #3
3419dc48:	e010      	b.n	3419dc6c <CMW_VD66GY_DeInit+0x46>
  }

  ret = VD6G_DeInit(&((CMW_VD66GY_t *)io_ctx)->ctx_driver);
3419dc4a:	687b      	ldr	r3, [r7, #4]
3419dc4c:	3304      	adds	r3, #4
3419dc4e:	4618      	mov	r0, r3
3419dc50:	f004 f928 	bl	341a1ea4 <VD6G_DeInit>
3419dc54:	60f8      	str	r0, [r7, #12]
  if (ret)
3419dc56:	68fb      	ldr	r3, [r7, #12]
3419dc58:	2b00      	cmp	r3, #0
3419dc5a:	d002      	beq.n	3419dc62 <CMW_VD66GY_DeInit+0x3c>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419dc5c:	f06f 0303 	mvn.w	r3, #3
3419dc60:	e004      	b.n	3419dc6c <CMW_VD66GY_DeInit+0x46>
  }

  ((CMW_VD66GY_t *)io_ctx)->IsInitialized = 0;
3419dc62:	687b      	ldr	r3, [r7, #4]
3419dc64:	2200      	movs	r2, #0
3419dc66:	f883 211c 	strb.w	r2, [r3, #284]	@ 0x11c
  return CMW_ERROR_NONE;
3419dc6a:	2300      	movs	r3, #0
}
3419dc6c:	4618      	mov	r0, r3
3419dc6e:	3710      	adds	r7, #16
3419dc70:	46bd      	mov	sp, r7
3419dc72:	bd80      	pop	{r7, pc}
3419dc74:	0000      	movs	r0, r0
	...

3419dc78 <CMW_VD66GY_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t CMW_VD66GY_SetGain(void *io_ctx, int32_t gain)
{
3419dc78:	b580      	push	{r7, lr}
3419dc7a:	b08e      	sub	sp, #56	@ 0x38
3419dc7c:	af00      	add	r7, sp, #0
3419dc7e:	6078      	str	r0, [r7, #4]
3419dc80:	6039      	str	r1, [r7, #0]
  uint16_t dgain_regmin, dgain_regmax;
  uint32_t again_min_mdB, again_max_mdB;
  uint32_t dgain_min_mdB, dgain_max_mdB;
  double analog_linear_gain, digital_linear_gain;

  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3419dc82:	687b      	ldr	r3, [r7, #4]
3419dc84:	3304      	adds	r3, #4
3419dc86:	f107 0212 	add.w	r2, r7, #18
3419dc8a:	f107 0113 	add.w	r1, r7, #19
3419dc8e:	4618      	mov	r0, r3
3419dc90:	f004 f97c 	bl	341a1f8c <VD6G_GetAnalogGainRegRange>
3419dc94:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419dc96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419dc98:	2b00      	cmp	r3, #0
3419dc9a:	d001      	beq.n	3419dca0 <CMW_VD66GY_SetGain+0x28>
    return ret;
3419dc9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419dc9e:	e14b      	b.n	3419df38 <CMW_VD66GY_SetGain+0x2c0>

  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
3419dca0:	687b      	ldr	r3, [r7, #4]
3419dca2:	3304      	adds	r3, #4
3419dca4:	f107 020e 	add.w	r2, r7, #14
3419dca8:	f107 0110 	add.w	r1, r7, #16
3419dcac:	4618      	mov	r0, r3
3419dcae:	f004 fa21 	bl	341a20f4 <VD6G_GetDigitalGainRegRange>
3419dcb2:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419dcb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419dcb6:	2b00      	cmp	r3, #0
3419dcb8:	d001      	beq.n	3419dcbe <CMW_VD66GY_SetGain+0x46>
    return ret;
3419dcba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419dcbc:	e13c      	b.n	3419df38 <CMW_VD66GY_SetGain+0x2c0>

  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3419dcbe:	7cfb      	ldrb	r3, [r7, #19]
3419dcc0:	f1c3 0320 	rsb	r3, r3, #32
3419dcc4:	2220      	movs	r2, #32
3419dcc6:	fb92 f3f3 	sdiv	r3, r2, r3
3419dcca:	ee07 3a90 	vmov	s15, r3
3419dcce:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419dcd2:	eeb0 0b47 	vmov.f64	d0, d7
3419dcd6:	f008 fb87 	bl	341a63e8 <log10>
3419dcda:	eeb0 7b40 	vmov.f64	d7, d0
3419dcde:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419dce2:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dce6:	ed9f 6b96 	vldr	d6, [pc, #600]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419dcea:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dcee:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419dcf2:	ee17 3a90 	vmov	r3, s15
3419dcf6:	623b      	str	r3, [r7, #32]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3419dcf8:	7cbb      	ldrb	r3, [r7, #18]
3419dcfa:	f1c3 0320 	rsb	r3, r3, #32
3419dcfe:	2220      	movs	r2, #32
3419dd00:	fb92 f3f3 	sdiv	r3, r2, r3
3419dd04:	ee07 3a90 	vmov	s15, r3
3419dd08:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419dd0c:	eeb0 0b47 	vmov.f64	d0, d7
3419dd10:	f008 fb6a 	bl	341a63e8 <log10>
3419dd14:	eeb0 7b40 	vmov.f64	d7, d0
3419dd18:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419dd1c:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dd20:	ed9f 6b87 	vldr	d6, [pc, #540]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419dd24:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dd28:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419dd2c:	ee17 3a90 	vmov	r3, s15
3419dd30:	61fb      	str	r3, [r7, #28]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3419dd32:	8a3b      	ldrh	r3, [r7, #16]
3419dd34:	0a1b      	lsrs	r3, r3, #8
3419dd36:	b29b      	uxth	r3, r3
3419dd38:	ee07 3a90 	vmov	s15, r3
3419dd3c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419dd40:	8a3b      	ldrh	r3, [r7, #16]
3419dd42:	b2db      	uxtb	r3, r3
3419dd44:	ee07 3a90 	vmov	s15, r3
3419dd48:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419dd4c:	ed9f 6a82 	vldr	s12, [pc, #520]	@ 3419df58 <CMW_VD66GY_SetGain+0x2e0>
3419dd50:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419dd54:	ee77 7a27 	vadd.f32	s15, s14, s15
3419dd58:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419dd5c:	eeb0 0b47 	vmov.f64	d0, d7
3419dd60:	f008 fb42 	bl	341a63e8 <log10>
3419dd64:	eeb0 7b40 	vmov.f64	d7, d0
3419dd68:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419dd6c:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dd70:	ed9f 6b73 	vldr	d6, [pc, #460]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419dd74:	ee27 7b06 	vmul.f64	d7, d7, d6
3419dd78:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419dd7c:	ee17 3a90 	vmov	r3, s15
3419dd80:	61bb      	str	r3, [r7, #24]
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3419dd82:	89fb      	ldrh	r3, [r7, #14]
3419dd84:	0a1b      	lsrs	r3, r3, #8
3419dd86:	b29b      	uxth	r3, r3
3419dd88:	ee07 3a90 	vmov	s15, r3
3419dd8c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419dd90:	89fb      	ldrh	r3, [r7, #14]
3419dd92:	b2db      	uxtb	r3, r3
3419dd94:	ee07 3a90 	vmov	s15, r3
3419dd98:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419dd9c:	ed9f 6a6e 	vldr	s12, [pc, #440]	@ 3419df58 <CMW_VD66GY_SetGain+0x2e0>
3419dda0:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419dda4:	ee77 7a27 	vadd.f32	s15, s14, s15
3419dda8:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419ddac:	eeb0 0b47 	vmov.f64	d0, d7
3419ddb0:	f008 fb1a 	bl	341a63e8 <log10>
3419ddb4:	eeb0 7b40 	vmov.f64	d7, d0
3419ddb8:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419ddbc:	ee27 7b06 	vmul.f64	d7, d7, d6
3419ddc0:	ed9f 6b5f 	vldr	d6, [pc, #380]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419ddc4:	ee27 7b06 	vmul.f64	d7, d7, d6
3419ddc8:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419ddcc:	ee17 3a90 	vmov	r3, s15
3419ddd0:	617b      	str	r3, [r7, #20]

  if ((gain < dgain_min_mdB + again_min_mdB)
3419ddd2:	69ba      	ldr	r2, [r7, #24]
3419ddd4:	6a3b      	ldr	r3, [r7, #32]
3419ddd6:	441a      	add	r2, r3
3419ddd8:	683b      	ldr	r3, [r7, #0]
3419ddda:	429a      	cmp	r2, r3
3419dddc:	d805      	bhi.n	3419ddea <CMW_VD66GY_SetGain+0x172>
      || (gain > dgain_max_mdB + again_max_mdB))
3419ddde:	697a      	ldr	r2, [r7, #20]
3419dde0:	69fb      	ldr	r3, [r7, #28]
3419dde2:	441a      	add	r2, r3
3419dde4:	683b      	ldr	r3, [r7, #0]
3419dde6:	429a      	cmp	r2, r3
3419dde8:	d202      	bcs.n	3419ddf0 <CMW_VD66GY_SetGain+0x178>
    return -1;
3419ddea:	f04f 33ff 	mov.w	r3, #4294967295
3419ddee:	e0a3      	b.n	3419df38 <CMW_VD66GY_SetGain+0x2c0>

  if (gain <= again_max_mdB)
3419ddf0:	683b      	ldr	r3, [r7, #0]
3419ddf2:	69fa      	ldr	r2, [r7, #28]
3419ddf4:	429a      	cmp	r2, r3
3419ddf6:	d32c      	bcc.n	3419de52 <CMW_VD66GY_SetGain+0x1da>
  {
    /* Use analog gain only and set digital gain to its minimum */
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - dgain_min_mdB));
3419ddf8:	683a      	ldr	r2, [r7, #0]
3419ddfa:	69bb      	ldr	r3, [r7, #24]
3419ddfc:	1ad3      	subs	r3, r2, r3
3419ddfe:	ee07 3a90 	vmov	s15, r3
3419de02:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419de06:	ed9f 5b4e 	vldr	d5, [pc, #312]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419de0a:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419de0e:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419de12:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419de16:	eeb0 1b46 	vmov.f64	d1, d6
3419de1a:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419de1e:	f008 fb73 	bl	341a6508 <pow>
3419de22:	ed87 0b0c 	vstr	d0, [r7, #48]	@ 0x30
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)dgain_min_mdB);
3419de26:	69bb      	ldr	r3, [r7, #24]
3419de28:	ee07 3a90 	vmov	s15, r3
3419de2c:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419de30:	ed9f 5b43 	vldr	d5, [pc, #268]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419de34:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419de38:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419de3c:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419de40:	eeb0 1b46 	vmov.f64	d1, d6
3419de44:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419de48:	f008 fb5e 	bl	341a6508 <pow>
3419de4c:	ed87 0b0a 	vstr	d0, [r7, #40]	@ 0x28
3419de50:	e02b      	b.n	3419deaa <CMW_VD66GY_SetGain+0x232>
  }
  else
  {
    /* For higher gain values, add digital gain */
    analog_linear_gain = MDECIBEL_TO_LINEAR((double)again_max_mdB);
3419de52:	69fb      	ldr	r3, [r7, #28]
3419de54:	ee07 3a90 	vmov	s15, r3
3419de58:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419de5c:	ed9f 5b38 	vldr	d5, [pc, #224]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419de60:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419de64:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419de68:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419de6c:	eeb0 1b46 	vmov.f64	d1, d6
3419de70:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419de74:	f008 fb48 	bl	341a6508 <pow>
3419de78:	ed87 0b0c 	vstr	d0, [r7, #48]	@ 0x30
    digital_linear_gain = MDECIBEL_TO_LINEAR((double)(gain - again_max_mdB));
3419de7c:	683a      	ldr	r2, [r7, #0]
3419de7e:	69fb      	ldr	r3, [r7, #28]
3419de80:	1ad3      	subs	r3, r2, r3
3419de82:	ee07 3a90 	vmov	s15, r3
3419de86:	eeb8 6b67 	vcvt.f64.u32	d6, s15
3419de8a:	ed9f 5b2d 	vldr	d5, [pc, #180]	@ 3419df40 <CMW_VD66GY_SetGain+0x2c8>
3419de8e:	ee86 7b05 	vdiv.f64	d7, d6, d5
3419de92:	eeb3 5b04 	vmov.f64	d5, #52	@ 0x41a00000  20.0
3419de96:	ee87 6b05 	vdiv.f64	d6, d7, d5
3419de9a:	eeb0 1b46 	vmov.f64	d1, d6
3419de9e:	eeb2 0b04 	vmov.f64	d0, #36	@ 0x41200000  10.0
3419dea2:	f008 fb31 	bl	341a6508 <pow>
3419dea6:	ed87 0b0a 	vstr	d0, [r7, #40]	@ 0x28
  }

  ret = VD6G_SetAnalogGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, (int) (32 - (32 / analog_linear_gain)));
3419deaa:	687b      	ldr	r3, [r7, #4]
3419deac:	3304      	adds	r3, #4
3419deae:	ed9f 5b26 	vldr	d5, [pc, #152]	@ 3419df48 <CMW_VD66GY_SetGain+0x2d0>
3419deb2:	ed97 6b0c 	vldr	d6, [r7, #48]	@ 0x30
3419deb6:	ee85 7b06 	vdiv.f64	d7, d5, d6
3419deba:	ed9f 6b23 	vldr	d6, [pc, #140]	@ 3419df48 <CMW_VD66GY_SetGain+0x2d0>
3419debe:	ee36 7b47 	vsub.f64	d7, d6, d7
3419dec2:	eefd 7bc7 	vcvt.s32.f64	s15, d7
3419dec6:	ee17 1a90 	vmov	r1, s15
3419deca:	4618      	mov	r0, r3
3419decc:	f004 f8c2 	bl	341a2054 <VD6G_SetAnalogGain>
3419ded0:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419ded2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419ded4:	2b00      	cmp	r3, #0
3419ded6:	d001      	beq.n	3419dedc <CMW_VD66GY_SetGain+0x264>
    return ret;
3419ded8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419deda:	e02d      	b.n	3419df38 <CMW_VD66GY_SetGain+0x2c0>

  ret = VD6G_SetDigitalGain(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, FLOAT_TO_FP58(digital_linear_gain));
3419dedc:	687b      	ldr	r3, [r7, #4]
3419dede:	1d18      	adds	r0, r3, #4
3419dee0:	ed97 7b0a 	vldr	d7, [r7, #40]	@ 0x28
3419dee4:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419dee8:	ee17 3990 	vmov.f16	r3, s15
3419deec:	b29b      	uxth	r3, r3
3419deee:	021a      	lsls	r2, r3, #8
3419def0:	ed97 7b0a 	vldr	d7, [r7, #40]	@ 0x28
3419def4:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419def8:	ee17 3990 	vmov.f16	r3, s15
3419defc:	b29b      	uxth	r3, r3
3419defe:	ee07 3a90 	vmov	s15, r3
3419df02:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419df06:	ed97 6b0a 	vldr	d6, [r7, #40]	@ 0x28
3419df0a:	ee36 7b47 	vsub.f64	d7, d6, d7
3419df0e:	ed9f 6b10 	vldr	d6, [pc, #64]	@ 3419df50 <CMW_VD66GY_SetGain+0x2d8>
3419df12:	ee27 7b06 	vmul.f64	d7, d7, d6
3419df16:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419df1a:	ee17 3990 	vmov.f16	r3, s15
3419df1e:	b29b      	uxth	r3, r3
3419df20:	b2db      	uxtb	r3, r3
3419df22:	4313      	orrs	r3, r2
3419df24:	4619      	mov	r1, r3
3419df26:	f004 f93b 	bl	341a21a0 <VD6G_SetDigitalGain>
3419df2a:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419df2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419df2e:	2b00      	cmp	r3, #0
3419df30:	d001      	beq.n	3419df36 <CMW_VD66GY_SetGain+0x2be>
    return ret;
3419df32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419df34:	e000      	b.n	3419df38 <CMW_VD66GY_SetGain+0x2c0>

  return 0;
3419df36:	2300      	movs	r3, #0
}
3419df38:	4618      	mov	r0, r3
3419df3a:	3738      	adds	r7, #56	@ 0x38
3419df3c:	46bd      	mov	sp, r7
3419df3e:	bd80      	pop	{r7, pc}
3419df40:	00000000 	.word	0x00000000
3419df44:	408f4000 	.word	0x408f4000
3419df48:	00000000 	.word	0x00000000
3419df4c:	40400000 	.word	0x40400000
3419df50:	00000000 	.word	0x00000000
3419df54:	40700000 	.word	0x40700000
3419df58:	43800000 	.word	0x43800000

3419df5c <CMW_VD66GY_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t CMW_VD66GY_SetExposure(void *io_ctx, int32_t exposure)
{
3419df5c:	b580      	push	{r7, lr}
3419df5e:	b082      	sub	sp, #8
3419df60:	af00      	add	r7, sp, #0
3419df62:	6078      	str	r0, [r7, #4]
3419df64:	6039      	str	r1, [r7, #0]
  return VD6G_SetExposureTime(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, exposure);
3419df66:	687b      	ldr	r3, [r7, #4]
3419df68:	3304      	adds	r3, #4
3419df6a:	6839      	ldr	r1, [r7, #0]
3419df6c:	4618      	mov	r0, r3
3419df6e:	f004 fa45 	bl	341a23fc <VD6G_SetExposureTime>
3419df72:	4603      	mov	r3, r0
}
3419df74:	4618      	mov	r0, r3
3419df76:	3708      	adds	r7, #8
3419df78:	46bd      	mov	sp, r7
3419df7a:	bd80      	pop	{r7, pc}

3419df7c <CMW_VD66GY_SetExposureMode>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure mode
  * @retval Component status
  */
int32_t CMW_VD66GY_SetExposureMode(void *io_ctx, int32_t mode)
{
3419df7c:	b580      	push	{r7, lr}
3419df7e:	b084      	sub	sp, #16
3419df80:	af00      	add	r7, sp, #0
3419df82:	6078      	str	r0, [r7, #4]
3419df84:	6039      	str	r1, [r7, #0]
  int ret = -1;
3419df86:	f04f 33ff 	mov.w	r3, #4294967295
3419df8a:	60fb      	str	r3, [r7, #12]

  switch (mode)
3419df8c:	683b      	ldr	r3, [r7, #0]
3419df8e:	2b01      	cmp	r3, #1
3419df90:	d00a      	beq.n	3419dfa8 <CMW_VD66GY_SetExposureMode+0x2c>
3419df92:	683b      	ldr	r3, [r7, #0]
3419df94:	2b02      	cmp	r3, #2
3419df96:	d10f      	bne.n	3419dfb8 <CMW_VD66GY_SetExposureMode+0x3c>
  {
    case CMW_EXPOSUREMODE_MANUAL:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_MANUAL);
3419df98:	687b      	ldr	r3, [r7, #4]
3419df9a:	3304      	adds	r3, #4
3419df9c:	2102      	movs	r1, #2
3419df9e:	4618      	mov	r0, r3
3419dfa0:	f003 ffd6 	bl	341a1f50 <VD6G_SetExposureMode>
3419dfa4:	60f8      	str	r0, [r7, #12]
      break;
3419dfa6:	e00f      	b.n	3419dfc8 <CMW_VD66GY_SetExposureMode+0x4c>
    case CMW_EXPOSUREMODE_AUTOFREEZE:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_FREEZE_AEALGO);
3419dfa8:	687b      	ldr	r3, [r7, #4]
3419dfaa:	3304      	adds	r3, #4
3419dfac:	2101      	movs	r1, #1
3419dfae:	4618      	mov	r0, r3
3419dfb0:	f003 ffce 	bl	341a1f50 <VD6G_SetExposureMode>
3419dfb4:	60f8      	str	r0, [r7, #12]
      break;
3419dfb6:	e007      	b.n	3419dfc8 <CMW_VD66GY_SetExposureMode+0x4c>
    case CMW_EXPOSUREMODE_AUTO:
    default:
      ret = VD6G_SetExposureMode(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, VD6G_EXPOSURE_AUTO);
3419dfb8:	687b      	ldr	r3, [r7, #4]
3419dfba:	3304      	adds	r3, #4
3419dfbc:	2100      	movs	r1, #0
3419dfbe:	4618      	mov	r0, r3
3419dfc0:	f003 ffc6 	bl	341a1f50 <VD6G_SetExposureMode>
3419dfc4:	60f8      	str	r0, [r7, #12]
      break;
3419dfc6:	bf00      	nop
  }

  return (ret == 0) ? CMW_ERROR_NONE : CMW_ERROR_UNKNOWN_FAILURE;
3419dfc8:	68fb      	ldr	r3, [r7, #12]
3419dfca:	2b00      	cmp	r3, #0
3419dfcc:	d101      	bne.n	3419dfd2 <CMW_VD66GY_SetExposureMode+0x56>
3419dfce:	2300      	movs	r3, #0
3419dfd0:	e001      	b.n	3419dfd6 <CMW_VD66GY_SetExposureMode+0x5a>
3419dfd2:	f06f 0305 	mvn.w	r3, #5
}
3419dfd6:	4618      	mov	r0, r3
3419dfd8:	3710      	adds	r7, #16
3419dfda:	46bd      	mov	sp, r7
3419dfdc:	bd80      	pop	{r7, pc}

3419dfde <CMW_VD66GY_SetWBRefMode>:
  * @param  Automatic automatic mode enable/disable
  * @param  RefColorTemp color temperature if automatic mode is disabled
  * @retval Component status
  */
int32_t CMW_VD66GY_SetWBRefMode(void *io_ctx, uint8_t Automatic, uint32_t RefColorTemp)
{
3419dfde:	b580      	push	{r7, lr}
3419dfe0:	b086      	sub	sp, #24
3419dfe2:	af00      	add	r7, sp, #0
3419dfe4:	60f8      	str	r0, [r7, #12]
3419dfe6:	460b      	mov	r3, r1
3419dfe8:	607a      	str	r2, [r7, #4]
3419dfea:	72fb      	strb	r3, [r7, #11]
  int ret = CMW_ERROR_NONE;
3419dfec:	2300      	movs	r3, #0
3419dfee:	617b      	str	r3, [r7, #20]

  ret = ISP_SetWBRefMode(&((CMW_VD66GY_t *)io_ctx)->hIsp, Automatic, RefColorTemp);
3419dff0:	68fb      	ldr	r3, [r7, #12]
3419dff2:	336c      	adds	r3, #108	@ 0x6c
3419dff4:	7af9      	ldrb	r1, [r7, #11]
3419dff6:	687a      	ldr	r2, [r7, #4]
3419dff8:	4618      	mov	r0, r3
3419dffa:	f7fb fbf9 	bl	341997f0 <ISP_SetWBRefMode>
3419dffe:	4603      	mov	r3, r0
3419e000:	617b      	str	r3, [r7, #20]
  if (ret)
3419e002:	697b      	ldr	r3, [r7, #20]
3419e004:	2b00      	cmp	r3, #0
3419e006:	d002      	beq.n	3419e00e <CMW_VD66GY_SetWBRefMode+0x30>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419e008:	f06f 0303 	mvn.w	r3, #3
3419e00c:	e000      	b.n	3419e010 <CMW_VD66GY_SetWBRefMode+0x32>
  }

  return CMW_ERROR_NONE;
3419e00e:	2300      	movs	r3, #0
}
3419e010:	4618      	mov	r0, r3
3419e012:	3718      	adds	r7, #24
3419e014:	46bd      	mov	sp, r7
3419e016:	bd80      	pop	{r7, pc}

3419e018 <CMW_VD66GY_ListWBRefModes>:
  * @param  io_ctx  pointer to component object
  * @param  RefColorTemp color temperature list
  * @retval Component status
  */
int32_t CMW_VD66GY_ListWBRefModes(void *io_ctx, uint32_t RefColorTemp[])
{
3419e018:	b580      	push	{r7, lr}
3419e01a:	b084      	sub	sp, #16
3419e01c:	af00      	add	r7, sp, #0
3419e01e:	6078      	str	r0, [r7, #4]
3419e020:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419e022:	2300      	movs	r3, #0
3419e024:	60fb      	str	r3, [r7, #12]

  ret = ISP_ListWBRefModes(&((CMW_VD66GY_t *)io_ctx)->hIsp, RefColorTemp);
3419e026:	687b      	ldr	r3, [r7, #4]
3419e028:	336c      	adds	r3, #108	@ 0x6c
3419e02a:	6839      	ldr	r1, [r7, #0]
3419e02c:	4618      	mov	r0, r3
3419e02e:	f7fb fbc9 	bl	341997c4 <ISP_ListWBRefModes>
3419e032:	4603      	mov	r3, r0
3419e034:	60fb      	str	r3, [r7, #12]
  if (ret)
3419e036:	68fb      	ldr	r3, [r7, #12]
3419e038:	2b00      	cmp	r3, #0
3419e03a:	d002      	beq.n	3419e042 <CMW_VD66GY_ListWBRefModes+0x2a>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3419e03c:	f06f 0303 	mvn.w	r3, #3
3419e040:	e000      	b.n	3419e044 <CMW_VD66GY_ListWBRefModes+0x2c>
  }

  return CMW_ERROR_NONE;
3419e042:	2300      	movs	r3, #0
}
3419e044:	4618      	mov	r0, r3
3419e046:	3710      	adds	r7, #16
3419e048:	46bd      	mov	sp, r7
3419e04a:	bd80      	pop	{r7, pc}
3419e04c:	0000      	movs	r0, r0
	...

3419e050 <CMW_VD66GY_GetSensorInfo>:
  * @param  pObj  pointer to component object
  * @param  pInfo pointer to sensor info structure
  * @retval Component status
  */
int32_t CMW_VD66GY_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3419e050:	b580      	push	{r7, lr}
3419e052:	b08a      	sub	sp, #40	@ 0x28
3419e054:	af00      	add	r7, sp, #0
3419e056:	6078      	str	r0, [r7, #4]
3419e058:	6039      	str	r1, [r7, #0]
  uint32_t again_min_mdB, again_max_mdB;
  uint32_t dgain_min_mdB, dgain_max_mdB;

  int ret;

  if ((!io_ctx) || (info == NULL))
3419e05a:	687b      	ldr	r3, [r7, #4]
3419e05c:	2b00      	cmp	r3, #0
3419e05e:	d002      	beq.n	3419e066 <CMW_VD66GY_GetSensorInfo+0x16>
3419e060:	683b      	ldr	r3, [r7, #0]
3419e062:	2b00      	cmp	r3, #0
3419e064:	d102      	bne.n	3419e06c <CMW_VD66GY_GetSensorInfo+0x1c>
    return CMW_ERROR_WRONG_PARAM;
3419e066:	f06f 0301 	mvn.w	r3, #1
3419e06a:	e0de      	b.n	3419e22a <CMW_VD66GY_GetSensorInfo+0x1da>

  /* Get sensor name */
  if (sizeof(info->name) >= strlen(VD66GY_NAME) + 1)
  {
    strcpy(info->name, VD66GY_NAME);
3419e06c:	683b      	ldr	r3, [r7, #0]
3419e06e:	4a74      	ldr	r2, [pc, #464]	@ (3419e240 <CMW_VD66GY_GetSensorInfo+0x1f0>)
3419e070:	6810      	ldr	r0, [r2, #0]
3419e072:	6018      	str	r0, [r3, #0]
3419e074:	8891      	ldrh	r1, [r2, #4]
3419e076:	7992      	ldrb	r2, [r2, #6]
3419e078:	8099      	strh	r1, [r3, #4]
3419e07a:	719a      	strb	r2, [r3, #6]
  {
    return CMW_ERROR_WRONG_PARAM;
  }

  /* Get isp bayer pattern info */
  info->bayer_pattern = ((CMW_VD66GY_t *)io_ctx)->ctx_driver.bayer - 1;
3419e07c:	687b      	ldr	r3, [r7, #4]
3419e07e:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
3419e082:	3b01      	subs	r3, #1
3419e084:	b2da      	uxtb	r2, r3
3419e086:	683b      	ldr	r3, [r7, #0]
3419e088:	f883 2020 	strb.w	r2, [r3, #32]

  /* Get color depth */
  info->color_depth = VD6G_COLOR_DEPTH_RAW8;
3419e08c:	683b      	ldr	r3, [r7, #0]
3419e08e:	2208      	movs	r2, #8
3419e090:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  /* Get resolution info */
  info->width = VD6G_MAX_WIDTH;
3419e094:	683b      	ldr	r3, [r7, #0]
3419e096:	f44f 628c 	mov.w	r2, #1120	@ 0x460
3419e09a:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = VD6G_MAX_HEIGHT;
3419e09c:	683b      	ldr	r3, [r7, #0]
3419e09e:	f240 5254 	movw	r2, #1364	@ 0x554
3419e0a2:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Get gain range */
  ret = VD6G_GetAnalogGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &again_regmin, &again_regmax);
3419e0a4:	687b      	ldr	r3, [r7, #4]
3419e0a6:	3304      	adds	r3, #4
3419e0a8:	f107 0212 	add.w	r2, r7, #18
3419e0ac:	f107 0113 	add.w	r1, r7, #19
3419e0b0:	4618      	mov	r0, r3
3419e0b2:	f003 ff6b 	bl	341a1f8c <VD6G_GetAnalogGainRegRange>
3419e0b6:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419e0b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e0ba:	2b00      	cmp	r3, #0
3419e0bc:	d001      	beq.n	3419e0c2 <CMW_VD66GY_GetSensorInfo+0x72>
    return ret;
3419e0be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e0c0:	e0b3      	b.n	3419e22a <CMW_VD66GY_GetSensorInfo+0x1da>

  ret = VD6G_GetDigitalGainRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &dgain_regmin, &dgain_regmax);
3419e0c2:	687b      	ldr	r3, [r7, #4]
3419e0c4:	3304      	adds	r3, #4
3419e0c6:	f107 020e 	add.w	r2, r7, #14
3419e0ca:	f107 0110 	add.w	r1, r7, #16
3419e0ce:	4618      	mov	r0, r3
3419e0d0:	f004 f810 	bl	341a20f4 <VD6G_GetDigitalGainRegRange>
3419e0d4:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419e0d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e0d8:	2b00      	cmp	r3, #0
3419e0da:	d001      	beq.n	3419e0e0 <CMW_VD66GY_GetSensorInfo+0x90>
    return ret;
3419e0dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e0de:	e0a4      	b.n	3419e22a <CMW_VD66GY_GetSensorInfo+0x1da>

  again_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmin));
3419e0e0:	7cfb      	ldrb	r3, [r7, #19]
3419e0e2:	f1c3 0320 	rsb	r3, r3, #32
3419e0e6:	2220      	movs	r2, #32
3419e0e8:	fb92 f3f3 	sdiv	r3, r2, r3
3419e0ec:	ee07 3a90 	vmov	s15, r3
3419e0f0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419e0f4:	eeb0 0b47 	vmov.f64	d0, d7
3419e0f8:	f008 f976 	bl	341a63e8 <log10>
3419e0fc:	eeb0 7b40 	vmov.f64	d7, d0
3419e100:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419e104:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e108:	ed9f 6b4b 	vldr	d6, [pc, #300]	@ 3419e238 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419e10c:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e110:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419e114:	ee17 3a90 	vmov	r3, s15
3419e118:	623b      	str	r3, [r7, #32]
  again_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(32 / (32 - again_regmax));
3419e11a:	7cbb      	ldrb	r3, [r7, #18]
3419e11c:	f1c3 0320 	rsb	r3, r3, #32
3419e120:	2220      	movs	r2, #32
3419e122:	fb92 f3f3 	sdiv	r3, r2, r3
3419e126:	ee07 3a90 	vmov	s15, r3
3419e12a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3419e12e:	eeb0 0b47 	vmov.f64	d0, d7
3419e132:	f008 f959 	bl	341a63e8 <log10>
3419e136:	eeb0 7b40 	vmov.f64	d7, d0
3419e13a:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419e13e:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e142:	ed9f 6b3d 	vldr	d6, [pc, #244]	@ 3419e238 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419e146:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e14a:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419e14e:	ee17 3a90 	vmov	r3, s15
3419e152:	61fb      	str	r3, [r7, #28]
  dgain_min_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmin));
3419e154:	8a3b      	ldrh	r3, [r7, #16]
3419e156:	0a1b      	lsrs	r3, r3, #8
3419e158:	b29b      	uxth	r3, r3
3419e15a:	ee07 3a90 	vmov	s15, r3
3419e15e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419e162:	8a3b      	ldrh	r3, [r7, #16]
3419e164:	b2db      	uxtb	r3, r3
3419e166:	ee07 3a90 	vmov	s15, r3
3419e16a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419e16e:	ed9f 6a35 	vldr	s12, [pc, #212]	@ 3419e244 <CMW_VD66GY_GetSensorInfo+0x1f4>
3419e172:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419e176:	ee77 7a27 	vadd.f32	s15, s14, s15
3419e17a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419e17e:	eeb0 0b47 	vmov.f64	d0, d7
3419e182:	f008 f931 	bl	341a63e8 <log10>
3419e186:	eeb0 7b40 	vmov.f64	d7, d0
3419e18a:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419e18e:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e192:	ed9f 6b29 	vldr	d6, [pc, #164]	@ 3419e238 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419e196:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e19a:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419e19e:	ee17 3a90 	vmov	r3, s15
3419e1a2:	61bb      	str	r3, [r7, #24]
  dgain_max_mdB = (uint32_t) LINEAR_TO_MDECIBEL(FP58_TO_FLOAT(dgain_regmax));
3419e1a4:	89fb      	ldrh	r3, [r7, #14]
3419e1a6:	0a1b      	lsrs	r3, r3, #8
3419e1a8:	b29b      	uxth	r3, r3
3419e1aa:	ee07 3a90 	vmov	s15, r3
3419e1ae:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3419e1b2:	89fb      	ldrh	r3, [r7, #14]
3419e1b4:	b2db      	uxtb	r3, r3
3419e1b6:	ee07 3a90 	vmov	s15, r3
3419e1ba:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419e1be:	ed9f 6a21 	vldr	s12, [pc, #132]	@ 3419e244 <CMW_VD66GY_GetSensorInfo+0x1f4>
3419e1c2:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419e1c6:	ee77 7a27 	vadd.f32	s15, s14, s15
3419e1ca:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3419e1ce:	eeb0 0b47 	vmov.f64	d0, d7
3419e1d2:	f008 f909 	bl	341a63e8 <log10>
3419e1d6:	eeb0 7b40 	vmov.f64	d7, d0
3419e1da:	eeb3 6b04 	vmov.f64	d6, #52	@ 0x41a00000  20.0
3419e1de:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e1e2:	ed9f 6b15 	vldr	d6, [pc, #84]	@ 3419e238 <CMW_VD66GY_GetSensorInfo+0x1e8>
3419e1e6:	ee27 7b06 	vmul.f64	d7, d7, d6
3419e1ea:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3419e1ee:	ee17 3a90 	vmov	r3, s15
3419e1f2:	617b      	str	r3, [r7, #20]

  info->gain_min = again_min_mdB + dgain_min_mdB;
3419e1f4:	6a3a      	ldr	r2, [r7, #32]
3419e1f6:	69bb      	ldr	r3, [r7, #24]
3419e1f8:	441a      	add	r2, r3
3419e1fa:	683b      	ldr	r3, [r7, #0]
3419e1fc:	62da      	str	r2, [r3, #44]	@ 0x2c
  info->gain_max = again_max_mdB + dgain_max_mdB;
3419e1fe:	69fa      	ldr	r2, [r7, #28]
3419e200:	697b      	ldr	r3, [r7, #20]
3419e202:	441a      	add	r2, r3
3419e204:	683b      	ldr	r3, [r7, #0]
3419e206:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Get exposure range */
  ret = VD6G_GetExposureRegRange(&((CMW_VD66GY_t *)io_ctx)->ctx_driver, &info->exposure_min, &info->exposure_max);
3419e208:	687b      	ldr	r3, [r7, #4]
3419e20a:	1d18      	adds	r0, r3, #4
3419e20c:	683b      	ldr	r3, [r7, #0]
3419e20e:	f103 0134 	add.w	r1, r3, #52	@ 0x34
3419e212:	683b      	ldr	r3, [r7, #0]
3419e214:	3338      	adds	r3, #56	@ 0x38
3419e216:	461a      	mov	r2, r3
3419e218:	f004 f872 	bl	341a2300 <VD6G_GetExposureRegRange>
3419e21c:	6278      	str	r0, [r7, #36]	@ 0x24
  if (ret)
3419e21e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e220:	2b00      	cmp	r3, #0
3419e222:	d001      	beq.n	3419e228 <CMW_VD66GY_GetSensorInfo+0x1d8>
    return ret;
3419e224:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419e226:	e000      	b.n	3419e22a <CMW_VD66GY_GetSensorInfo+0x1da>

  return CMW_ERROR_NONE;
3419e228:	2300      	movs	r3, #0
}
3419e22a:	4618      	mov	r0, r3
3419e22c:	3728      	adds	r7, #40	@ 0x28
3419e22e:	46bd      	mov	sp, r7
3419e230:	bd80      	pop	{r7, pc}
3419e232:	bf00      	nop
3419e234:	f3af 8000 	nop.w
3419e238:	00000000 	.word	0x00000000
3419e23c:	408f4000 	.word	0x408f4000
3419e240:	341a7740 	.word	0x341a7740
3419e244:	43800000 	.word	0x43800000

3419e248 <CMW_VD66GY_VsyncEventCallback>:

static void CMW_VD66GY_VsyncEventCallback(void *io_ctx, uint32_t pipe)
{
3419e248:	b580      	push	{r7, lr}
3419e24a:	b082      	sub	sp, #8
3419e24c:	af00      	add	r7, sp, #0
3419e24e:	6078      	str	r0, [r7, #4]
3419e250:	6039      	str	r1, [r7, #0]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Update the ISP frame counter and call its statistics handler */
  switch (pipe)
3419e252:	683b      	ldr	r3, [r7, #0]
3419e254:	2b02      	cmp	r3, #2
3419e256:	d01a      	beq.n	3419e28e <CMW_VD66GY_VsyncEventCallback+0x46>
3419e258:	683b      	ldr	r3, [r7, #0]
3419e25a:	2b02      	cmp	r3, #2
3419e25c:	d81d      	bhi.n	3419e29a <CMW_VD66GY_VsyncEventCallback+0x52>
3419e25e:	683b      	ldr	r3, [r7, #0]
3419e260:	2b00      	cmp	r3, #0
3419e262:	d003      	beq.n	3419e26c <CMW_VD66GY_VsyncEventCallback+0x24>
3419e264:	683b      	ldr	r3, [r7, #0]
3419e266:	2b01      	cmp	r3, #1
3419e268:	d006      	beq.n	3419e278 <CMW_VD66GY_VsyncEventCallback+0x30>
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
      break;
  }
#endif
}
3419e26a:	e016      	b.n	3419e29a <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncDumpFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419e26c:	687b      	ldr	r3, [r7, #4]
3419e26e:	336c      	adds	r3, #108	@ 0x6c
3419e270:	4618      	mov	r0, r3
3419e272:	f7fb fb6d 	bl	34199950 <ISP_IncDumpFrameId>
      break;
3419e276:	e010      	b.n	3419e29a <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncMainFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419e278:	687b      	ldr	r3, [r7, #4]
3419e27a:	336c      	adds	r3, #108	@ 0x6c
3419e27c:	4618      	mov	r0, r3
3419e27e:	f7fb fb51 	bl	34199924 <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419e282:	687b      	ldr	r3, [r7, #4]
3419e284:	336c      	adds	r3, #108	@ 0x6c
3419e286:	4618      	mov	r0, r3
3419e288:	f7fb fb41 	bl	3419990e <ISP_GatherStatistics>
      break;
3419e28c:	e005      	b.n	3419e29a <CMW_VD66GY_VsyncEventCallback+0x52>
      ISP_IncAncillaryFrameId(&((CMW_VD66GY_t *)io_ctx)->hIsp);
3419e28e:	687b      	ldr	r3, [r7, #4]
3419e290:	336c      	adds	r3, #108	@ 0x6c
3419e292:	4618      	mov	r0, r3
3419e294:	f7fb fb51 	bl	3419993a <ISP_IncAncillaryFrameId>
      break;
3419e298:	bf00      	nop
}
3419e29a:	bf00      	nop
3419e29c:	3708      	adds	r7, #8
3419e29e:	46bd      	mov	sp, r7
3419e2a0:	bd80      	pop	{r7, pc}

3419e2a2 <CMW_VD66GY_FrameEventCallback>:

static void CMW_VD66GY_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
3419e2a2:	b480      	push	{r7}
3419e2a4:	b083      	sub	sp, #12
3419e2a6:	af00      	add	r7, sp, #0
3419e2a8:	6078      	str	r0, [r7, #4]
3419e2aa:	6039      	str	r1, [r7, #0]
}
3419e2ac:	bf00      	nop
3419e2ae:	370c      	adds	r7, #12
3419e2b0:	46bd      	mov	sp, r7
3419e2b2:	f85d 7b04 	ldr.w	r7, [sp], #4
3419e2b6:	4770      	bx	lr

3419e2b8 <VD66GY_RegisterBusIO>:

int32_t VD66GY_RegisterBusIO(CMW_VD66GY_t *io_ctx)
{
3419e2b8:	b580      	push	{r7, lr}
3419e2ba:	b084      	sub	sp, #16
3419e2bc:	af00      	add	r7, sp, #0
3419e2be:	6078      	str	r0, [r7, #4]
  int ret;

  if (!io_ctx)
3419e2c0:	687b      	ldr	r3, [r7, #4]
3419e2c2:	2b00      	cmp	r3, #0
3419e2c4:	d102      	bne.n	3419e2cc <VD66GY_RegisterBusIO+0x14>
    return CMW_ERROR_COMPONENT_FAILURE;
3419e2c6:	f06f 0304 	mvn.w	r3, #4
3419e2ca:	e00d      	b.n	3419e2e8 <VD66GY_RegisterBusIO+0x30>

  if (!io_ctx->Init)
3419e2cc:	687b      	ldr	r3, [r7, #4]
3419e2ce:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3419e2d2:	2b00      	cmp	r3, #0
3419e2d4:	d102      	bne.n	3419e2dc <VD66GY_RegisterBusIO+0x24>
    return CMW_ERROR_COMPONENT_FAILURE;
3419e2d6:	f06f 0304 	mvn.w	r3, #4
3419e2da:	e005      	b.n	3419e2e8 <VD66GY_RegisterBusIO+0x30>

  ret = io_ctx->Init();
3419e2dc:	687b      	ldr	r3, [r7, #4]
3419e2de:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
3419e2e2:	4798      	blx	r3
3419e2e4:	60f8      	str	r0, [r7, #12]

  return ret;
3419e2e6:	68fb      	ldr	r3, [r7, #12]
}
3419e2e8:	4618      	mov	r0, r3
3419e2ea:	3710      	adds	r7, #16
3419e2ec:	46bd      	mov	sp, r7
3419e2ee:	bd80      	pop	{r7, pc}

3419e2f0 <VD66GY_ReadID>:

int32_t VD66GY_ReadID(CMW_VD66GY_t *io_ctx, uint32_t *Id)
{
3419e2f0:	b580      	push	{r7, lr}
3419e2f2:	b084      	sub	sp, #16
3419e2f4:	af00      	add	r7, sp, #0
3419e2f6:	6078      	str	r0, [r7, #4]
3419e2f8:	6039      	str	r1, [r7, #0]
  uint16_t reg16;
  int32_t ret;

  ret = CMW_VD66GY_Read16(io_ctx, VD66GY_REG_MODEL_ID, &reg16);
3419e2fa:	f107 030a 	add.w	r3, r7, #10
3419e2fe:	461a      	mov	r2, r3
3419e300:	2100      	movs	r1, #0
3419e302:	6878      	ldr	r0, [r7, #4]
3419e304:	f7ff f96f 	bl	3419d5e6 <CMW_VD66GY_Read16>
3419e308:	60f8      	str	r0, [r7, #12]
  if (ret)
3419e30a:	68fb      	ldr	r3, [r7, #12]
3419e30c:	2b00      	cmp	r3, #0
3419e30e:	d001      	beq.n	3419e314 <VD66GY_ReadID+0x24>
    return ret;
3419e310:	68fb      	ldr	r3, [r7, #12]
3419e312:	e004      	b.n	3419e31e <VD66GY_ReadID+0x2e>

  *Id = reg16;
3419e314:	897b      	ldrh	r3, [r7, #10]
3419e316:	461a      	mov	r2, r3
3419e318:	683b      	ldr	r3, [r7, #0]
3419e31a:	601a      	str	r2, [r3, #0]

  return CMW_ERROR_NONE;
3419e31c:	2300      	movs	r3, #0
}
3419e31e:	4618      	mov	r0, r3
3419e320:	3710      	adds	r7, #16
3419e322:	46bd      	mov	sp, r7
3419e324:	bd80      	pop	{r7, pc}

3419e326 <CMW_VD66GY_PowerOn>:

static void CMW_VD66GY_PowerOn(CMW_VD66GY_t *io_ctx)
{
3419e326:	b580      	push	{r7, lr}
3419e328:	b082      	sub	sp, #8
3419e32a:	af00      	add	r7, sp, #0
3419e32c:	6078      	str	r0, [r7, #4]
  /* Camera sensor Power-On sequence */
  /* Assert the camera  NRST pins */
  io_ctx->EnablePin(1);
3419e32e:	687b      	ldr	r3, [r7, #4]
3419e330:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3419e334:	2001      	movs	r0, #1
3419e336:	4798      	blx	r3
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3419e338:	687b      	ldr	r3, [r7, #4]
3419e33a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419e33e:	2000      	movs	r0, #0
3419e340:	4798      	blx	r3
  HAL_Delay(200);   /* NRST signals asserted during 200ms */
3419e342:	20c8      	movs	r0, #200	@ 0xc8
3419e344:	f7e8 f8f0 	bl	34186528 <HAL_Delay>
  /* De-assert the camera STANDBY pin (active high) */
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3419e348:	687b      	ldr	r3, [r7, #4]
3419e34a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3419e34e:	2001      	movs	r0, #1
3419e350:	4798      	blx	r3
  HAL_Delay(20);     /* NRST de-asserted during 20ms */
3419e352:	2014      	movs	r0, #20
3419e354:	f7e8 f8e8 	bl	34186528 <HAL_Delay>
}
3419e358:	bf00      	nop
3419e35a:	3708      	adds	r7, #8
3419e35c:	46bd      	mov	sp, r7
3419e35e:	bd80      	pop	{r7, pc}

3419e360 <CMW_VD66GY_Probe>:

int CMW_VD66GY_Probe(CMW_VD66GY_t *io_ctx, CMW_Sensor_if_t *vd6g_if)
{
3419e360:	b580      	push	{r7, lr}
3419e362:	b084      	sub	sp, #16
3419e364:	af00      	add	r7, sp, #0
3419e366:	6078      	str	r0, [r7, #4]
3419e368:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3419e36a:	2300      	movs	r3, #0
3419e36c:	60fb      	str	r3, [r7, #12]
  uint32_t id;

  io_ctx->ctx_driver.shutdown_pin = VD6G_ShutdownPin;
3419e36e:	687b      	ldr	r3, [r7, #4]
3419e370:	4a37      	ldr	r2, [pc, #220]	@ (3419e450 <CMW_VD66GY_Probe+0xf0>)
3419e372:	605a      	str	r2, [r3, #4]
  io_ctx->ctx_driver.read8 = VD6G_Read8;
3419e374:	687b      	ldr	r3, [r7, #4]
3419e376:	4a37      	ldr	r2, [pc, #220]	@ (3419e454 <CMW_VD66GY_Probe+0xf4>)
3419e378:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.read16 = VD6G_Read16;
3419e37a:	687b      	ldr	r3, [r7, #4]
3419e37c:	4a36      	ldr	r2, [pc, #216]	@ (3419e458 <CMW_VD66GY_Probe+0xf8>)
3419e37e:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.read32 = VD6G_Read32;
3419e380:	687b      	ldr	r3, [r7, #4]
3419e382:	4a36      	ldr	r2, [pc, #216]	@ (3419e45c <CMW_VD66GY_Probe+0xfc>)
3419e384:	611a      	str	r2, [r3, #16]
  io_ctx->ctx_driver.write8 = VD6G_Write8;
3419e386:	687b      	ldr	r3, [r7, #4]
3419e388:	4a35      	ldr	r2, [pc, #212]	@ (3419e460 <CMW_VD66GY_Probe+0x100>)
3419e38a:	615a      	str	r2, [r3, #20]
  io_ctx->ctx_driver.write16 = VD6G_Write16;
3419e38c:	687b      	ldr	r3, [r7, #4]
3419e38e:	4a35      	ldr	r2, [pc, #212]	@ (3419e464 <CMW_VD66GY_Probe+0x104>)
3419e390:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.write32 = VD6G_Write32;
3419e392:	687b      	ldr	r3, [r7, #4]
3419e394:	4a34      	ldr	r2, [pc, #208]	@ (3419e468 <CMW_VD66GY_Probe+0x108>)
3419e396:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.write_array = VD6G_WriteArray;
3419e398:	687b      	ldr	r3, [r7, #4]
3419e39a:	4a34      	ldr	r2, [pc, #208]	@ (3419e46c <CMW_VD66GY_Probe+0x10c>)
3419e39c:	621a      	str	r2, [r3, #32]
  io_ctx->ctx_driver.delay = VD6G_Delay;
3419e39e:	687b      	ldr	r3, [r7, #4]
3419e3a0:	4a33      	ldr	r2, [pc, #204]	@ (3419e470 <CMW_VD66GY_Probe+0x110>)
3419e3a2:	625a      	str	r2, [r3, #36]	@ 0x24
  io_ctx->ctx_driver.log = VD6G_Log;
3419e3a4:	687b      	ldr	r3, [r7, #4]
3419e3a6:	4a33      	ldr	r2, [pc, #204]	@ (3419e474 <CMW_VD66GY_Probe+0x114>)
3419e3a8:	629a      	str	r2, [r3, #40]	@ 0x28

  CMW_VD66GY_PowerOn(io_ctx);
3419e3aa:	6878      	ldr	r0, [r7, #4]
3419e3ac:	f7ff ffbb 	bl	3419e326 <CMW_VD66GY_PowerOn>

  ret = VD66GY_RegisterBusIO(io_ctx);
3419e3b0:	6878      	ldr	r0, [r7, #4]
3419e3b2:	f7ff ff81 	bl	3419e2b8 <VD66GY_RegisterBusIO>
3419e3b6:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419e3b8:	68fb      	ldr	r3, [r7, #12]
3419e3ba:	2b00      	cmp	r3, #0
3419e3bc:	d002      	beq.n	3419e3c4 <CMW_VD66GY_Probe+0x64>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419e3be:	f06f 0304 	mvn.w	r3, #4
3419e3c2:	e041      	b.n	3419e448 <CMW_VD66GY_Probe+0xe8>
  }

  ret = VD66GY_ReadID(io_ctx, &id);
3419e3c4:	f107 0308 	add.w	r3, r7, #8
3419e3c8:	4619      	mov	r1, r3
3419e3ca:	6878      	ldr	r0, [r7, #4]
3419e3cc:	f7ff ff90 	bl	3419e2f0 <VD66GY_ReadID>
3419e3d0:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3419e3d2:	68fb      	ldr	r3, [r7, #12]
3419e3d4:	2b00      	cmp	r3, #0
3419e3d6:	d002      	beq.n	3419e3de <CMW_VD66GY_Probe+0x7e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419e3d8:	f06f 0304 	mvn.w	r3, #4
3419e3dc:	e034      	b.n	3419e448 <CMW_VD66GY_Probe+0xe8>
  }
  if (id != VD66GY_CHIP_ID)
3419e3de:	68bb      	ldr	r3, [r7, #8]
3419e3e0:	f245 6203 	movw	r2, #22019	@ 0x5603
3419e3e4:	4293      	cmp	r3, r2
3419e3e6:	d002      	beq.n	3419e3ee <CMW_VD66GY_Probe+0x8e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3419e3e8:	f06f 0304 	mvn.w	r3, #4
3419e3ec:	e02c      	b.n	3419e448 <CMW_VD66GY_Probe+0xe8>
  }

  memset(vd6g_if, 0, sizeof(*vd6g_if));
3419e3ee:	2268      	movs	r2, #104	@ 0x68
3419e3f0:	2100      	movs	r1, #0
3419e3f2:	6838      	ldr	r0, [r7, #0]
3419e3f4:	f007 f87c 	bl	341a54f0 <memset>
  vd6g_if->Init = CMW_VD66GY_Init;
3419e3f8:	683b      	ldr	r3, [r7, #0]
3419e3fa:	4a1f      	ldr	r2, [pc, #124]	@ (3419e478 <CMW_VD66GY_Probe+0x118>)
3419e3fc:	601a      	str	r2, [r3, #0]
  vd6g_if->DeInit = CMW_VD66GY_DeInit;
3419e3fe:	683b      	ldr	r3, [r7, #0]
3419e400:	4a1e      	ldr	r2, [pc, #120]	@ (3419e47c <CMW_VD66GY_Probe+0x11c>)
3419e402:	605a      	str	r2, [r3, #4]
  vd6g_if->Run = CMW_VD66GY_Run;
3419e404:	683b      	ldr	r3, [r7, #0]
3419e406:	4a1e      	ldr	r2, [pc, #120]	@ (3419e480 <CMW_VD66GY_Probe+0x120>)
3419e408:	60da      	str	r2, [r3, #12]
  vd6g_if->VsyncEventCallback = CMW_VD66GY_VsyncEventCallback;
3419e40a:	683b      	ldr	r3, [r7, #0]
3419e40c:	4a1d      	ldr	r2, [pc, #116]	@ (3419e484 <CMW_VD66GY_Probe+0x124>)
3419e40e:	611a      	str	r2, [r3, #16]
  vd6g_if->FrameEventCallback = CMW_VD66GY_FrameEventCallback;
3419e410:	683b      	ldr	r3, [r7, #0]
3419e412:	4a1d      	ldr	r2, [pc, #116]	@ (3419e488 <CMW_VD66GY_Probe+0x128>)
3419e414:	615a      	str	r2, [r3, #20]
  vd6g_if->Start = CMW_VD66GY_Start;
3419e416:	683b      	ldr	r3, [r7, #0]
3419e418:	4a1c      	ldr	r2, [pc, #112]	@ (3419e48c <CMW_VD66GY_Probe+0x12c>)
3419e41a:	609a      	str	r2, [r3, #8]
  vd6g_if->Stop = CMW_VD66GY_Stop;
3419e41c:	683b      	ldr	r3, [r7, #0]
3419e41e:	4a1c      	ldr	r2, [pc, #112]	@ (3419e490 <CMW_VD66GY_Probe+0x130>)
3419e420:	619a      	str	r2, [r3, #24]
  vd6g_if->SetGain = CMW_VD66GY_SetGain;
3419e422:	683b      	ldr	r3, [r7, #0]
3419e424:	4a1b      	ldr	r2, [pc, #108]	@ (3419e494 <CMW_VD66GY_Probe+0x134>)
3419e426:	649a      	str	r2, [r3, #72]	@ 0x48
  vd6g_if->SetExposure = CMW_VD66GY_SetExposure;
3419e428:	683b      	ldr	r3, [r7, #0]
3419e42a:	4a1b      	ldr	r2, [pc, #108]	@ (3419e498 <CMW_VD66GY_Probe+0x138>)
3419e42c:	64da      	str	r2, [r3, #76]	@ 0x4c
  vd6g_if->SetExposureMode = CMW_VD66GY_SetExposureMode;
3419e42e:	683b      	ldr	r3, [r7, #0]
3419e430:	4a1a      	ldr	r2, [pc, #104]	@ (3419e49c <CMW_VD66GY_Probe+0x13c>)
3419e432:	651a      	str	r2, [r3, #80]	@ 0x50
  vd6g_if->SetWBRefMode = CMW_VD66GY_SetWBRefMode;
3419e434:	683b      	ldr	r3, [r7, #0]
3419e436:	4a1a      	ldr	r2, [pc, #104]	@ (3419e4a0 <CMW_VD66GY_Probe+0x140>)
3419e438:	655a      	str	r2, [r3, #84]	@ 0x54
  vd6g_if->ListWBRefModes = CMW_VD66GY_ListWBRefModes;
3419e43a:	683b      	ldr	r3, [r7, #0]
3419e43c:	4a19      	ldr	r2, [pc, #100]	@ (3419e4a4 <CMW_VD66GY_Probe+0x144>)
3419e43e:	659a      	str	r2, [r3, #88]	@ 0x58
  vd6g_if->GetSensorInfo = CMW_VD66GY_GetSensorInfo;
3419e440:	683b      	ldr	r3, [r7, #0]
3419e442:	4a19      	ldr	r2, [pc, #100]	@ (3419e4a8 <CMW_VD66GY_Probe+0x148>)
3419e444:	661a      	str	r2, [r3, #96]	@ 0x60
  return ret;
3419e446:	68fb      	ldr	r3, [r7, #12]
}
3419e448:	4618      	mov	r0, r3
3419e44a:	3710      	adds	r7, #16
3419e44c:	46bd      	mov	sp, r7
3419e44e:	bd80      	pop	{r7, pc}
3419e450:	3419d709 	.word	0x3419d709
3419e454:	3419d72b 	.word	0x3419d72b
3419e458:	3419d755 	.word	0x3419d755
3419e45c:	3419d77f 	.word	0x3419d77f
3419e460:	3419d7a9 	.word	0x3419d7a9
3419e464:	3419d7d5 	.word	0x3419d7d5
3419e468:	3419d801 	.word	0x3419d801
3419e46c:	3419d82b 	.word	0x3419d82b
3419e470:	3419d899 	.word	0x3419d899
3419e474:	3419d8bb 	.word	0x3419d8bb
3419e478:	3419d9b5 	.word	0x3419d9b5
3419e47c:	3419dc27 	.word	0x3419dc27
3419e480:	3419dbcd 	.word	0x3419dbcd
3419e484:	3419e249 	.word	0x3419e249
3419e488:	3419e2a3 	.word	0x3419e2a3
3419e48c:	3419db4d 	.word	0x3419db4d
3419e490:	3419dbf9 	.word	0x3419dbf9
3419e494:	3419dc79 	.word	0x3419dc79
3419e498:	3419df5d 	.word	0x3419df5d
3419e49c:	3419df7d 	.word	0x3419df7d
3419e4a0:	3419dfdf 	.word	0x3419dfdf
3419e4a4:	3419e019 	.word	0x3419e019
3419e4a8:	3419e051 	.word	0x3419e051

3419e4ac <IMX335_WriteTable>:

/** @defgroup IMX335_Private_Functions Private Functions
  * @{
  */
static int32_t IMX335_WriteTable(IMX335_Object_t *pObj, const struct regval *regs, uint32_t size)
{
3419e4ac:	b580      	push	{r7, lr}
3419e4ae:	b086      	sub	sp, #24
3419e4b0:	af00      	add	r7, sp, #0
3419e4b2:	60f8      	str	r0, [r7, #12]
3419e4b4:	60b9      	str	r1, [r7, #8]
3419e4b6:	607a      	str	r2, [r7, #4]
  uint32_t index;
  int32_t ret = IMX335_OK;
3419e4b8:	2300      	movs	r3, #0
3419e4ba:	613b      	str	r3, [r7, #16]

  /* Set registers */
  for(index=0; index<size ; index++)
3419e4bc:	2300      	movs	r3, #0
3419e4be:	617b      	str	r3, [r7, #20]
3419e4c0:	e01c      	b.n	3419e4fc <IMX335_WriteTable+0x50>
  {
    if(ret != IMX335_ERROR)
3419e4c2:	693b      	ldr	r3, [r7, #16]
3419e4c4:	f1b3 3fff 	cmp.w	r3, #4294967295
3419e4c8:	d015      	beq.n	3419e4f6 <IMX335_WriteTable+0x4a>
    {
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
3419e4ca:	68fb      	ldr	r3, [r7, #12]
3419e4cc:	f103 0018 	add.w	r0, r3, #24
3419e4d0:	697b      	ldr	r3, [r7, #20]
3419e4d2:	009b      	lsls	r3, r3, #2
3419e4d4:	68ba      	ldr	r2, [r7, #8]
3419e4d6:	4413      	add	r3, r2
3419e4d8:	8819      	ldrh	r1, [r3, #0]
3419e4da:	697b      	ldr	r3, [r7, #20]
3419e4dc:	009b      	lsls	r3, r3, #2
3419e4de:	68ba      	ldr	r2, [r7, #8]
3419e4e0:	4413      	add	r3, r2
3419e4e2:	1c9a      	adds	r2, r3, #2
3419e4e4:	2301      	movs	r3, #1
3419e4e6:	f000 fb80 	bl	3419ebea <imx335_write_reg>
3419e4ea:	4603      	mov	r3, r0
3419e4ec:	2b00      	cmp	r3, #0
3419e4ee:	d002      	beq.n	3419e4f6 <IMX335_WriteTable+0x4a>
      {
        ret = IMX335_ERROR;
3419e4f0:	f04f 33ff 	mov.w	r3, #4294967295
3419e4f4:	613b      	str	r3, [r7, #16]
  for(index=0; index<size ; index++)
3419e4f6:	697b      	ldr	r3, [r7, #20]
3419e4f8:	3301      	adds	r3, #1
3419e4fa:	617b      	str	r3, [r7, #20]
3419e4fc:	697a      	ldr	r2, [r7, #20]
3419e4fe:	687b      	ldr	r3, [r7, #4]
3419e500:	429a      	cmp	r2, r3
3419e502:	d3de      	bcc.n	3419e4c2 <IMX335_WriteTable+0x16>
      }
    }
  }
  return ret;
3419e504:	693b      	ldr	r3, [r7, #16]
}
3419e506:	4618      	mov	r0, r3
3419e508:	3718      	adds	r7, #24
3419e50a:	46bd      	mov	sp, r7
3419e50c:	bd80      	pop	{r7, pc}

3419e50e <IMX335_Delay>:
  * @param pObj   pointer to component object
  * @param Delay  specifies the delay time length, in milliseconds
  * @retval IMX335_OK
  */
static int32_t IMX335_Delay(IMX335_Object_t *pObj, uint32_t Delay)
{
3419e50e:	b580      	push	{r7, lr}
3419e510:	b084      	sub	sp, #16
3419e512:	af00      	add	r7, sp, #0
3419e514:	6078      	str	r0, [r7, #4]
3419e516:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  tickstart = pObj->IO.GetTick();
3419e518:	687b      	ldr	r3, [r7, #4]
3419e51a:	695b      	ldr	r3, [r3, #20]
3419e51c:	4798      	blx	r3
3419e51e:	4603      	mov	r3, r0
3419e520:	60fb      	str	r3, [r7, #12]
  while((pObj->IO.GetTick() - tickstart) < Delay)
3419e522:	bf00      	nop
3419e524:	687b      	ldr	r3, [r7, #4]
3419e526:	695b      	ldr	r3, [r3, #20]
3419e528:	4798      	blx	r3
3419e52a:	4603      	mov	r3, r0
3419e52c:	461a      	mov	r2, r3
3419e52e:	68fb      	ldr	r3, [r7, #12]
3419e530:	1ad3      	subs	r3, r2, r3
3419e532:	683a      	ldr	r2, [r7, #0]
3419e534:	429a      	cmp	r2, r3
3419e536:	d8f5      	bhi.n	3419e524 <IMX335_Delay+0x16>
  {
  }
  return IMX335_OK;
3419e538:	2300      	movs	r3, #0
}
3419e53a:	4618      	mov	r0, r3
3419e53c:	3710      	adds	r7, #16
3419e53e:	46bd      	mov	sp, r7
3419e540:	bd80      	pop	{r7, pc}

3419e542 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3419e542:	b590      	push	{r4, r7, lr}
3419e544:	b087      	sub	sp, #28
3419e546:	af00      	add	r7, sp, #0
3419e548:	60f8      	str	r0, [r7, #12]
3419e54a:	607a      	str	r2, [r7, #4]
3419e54c:	461a      	mov	r2, r3
3419e54e:	460b      	mov	r3, r1
3419e550:	817b      	strh	r3, [r7, #10]
3419e552:	4613      	mov	r3, r2
3419e554:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3419e556:	68fb      	ldr	r3, [r7, #12]
3419e558:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
3419e55a:	697b      	ldr	r3, [r7, #20]
3419e55c:	691c      	ldr	r4, [r3, #16]
3419e55e:	697b      	ldr	r3, [r7, #20]
3419e560:	8918      	ldrh	r0, [r3, #8]
3419e562:	893b      	ldrh	r3, [r7, #8]
3419e564:	8979      	ldrh	r1, [r7, #10]
3419e566:	687a      	ldr	r2, [r7, #4]
3419e568:	47a0      	blx	r4
3419e56a:	4603      	mov	r3, r0
}
3419e56c:	4618      	mov	r0, r3
3419e56e:	371c      	adds	r7, #28
3419e570:	46bd      	mov	sp, r7
3419e572:	bd90      	pop	{r4, r7, pc}

3419e574 <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3419e574:	b590      	push	{r4, r7, lr}
3419e576:	b087      	sub	sp, #28
3419e578:	af00      	add	r7, sp, #0
3419e57a:	60f8      	str	r0, [r7, #12]
3419e57c:	607a      	str	r2, [r7, #4]
3419e57e:	461a      	mov	r2, r3
3419e580:	460b      	mov	r3, r1
3419e582:	817b      	strh	r3, [r7, #10]
3419e584:	4613      	mov	r3, r2
3419e586:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3419e588:	68fb      	ldr	r3, [r7, #12]
3419e58a:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3419e58c:	697b      	ldr	r3, [r7, #20]
3419e58e:	68dc      	ldr	r4, [r3, #12]
3419e590:	697b      	ldr	r3, [r7, #20]
3419e592:	8918      	ldrh	r0, [r3, #8]
3419e594:	893b      	ldrh	r3, [r7, #8]
3419e596:	8979      	ldrh	r1, [r7, #10]
3419e598:	687a      	ldr	r2, [r7, #4]
3419e59a:	47a0      	blx	r4
3419e59c:	4603      	mov	r3, r0
}
3419e59e:	4618      	mov	r0, r3
3419e5a0:	371c      	adds	r7, #28
3419e5a2:	46bd      	mov	sp, r7
3419e5a4:	bd90      	pop	{r4, r7, pc}
	...

3419e5a8 <IMX335_RegisterBusIO>:
  * @brief  Register component IO bus
  * @param  Component object pointer
  * @retval Component status
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
3419e5a8:	b580      	push	{r7, lr}
3419e5aa:	b084      	sub	sp, #16
3419e5ac:	af00      	add	r7, sp, #0
3419e5ae:	6078      	str	r0, [r7, #4]
3419e5b0:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
3419e5b2:	687b      	ldr	r3, [r7, #4]
3419e5b4:	2b00      	cmp	r3, #0
3419e5b6:	d103      	bne.n	3419e5c0 <IMX335_RegisterBusIO+0x18>
  {
    ret = IMX335_ERROR;
3419e5b8:	f04f 33ff 	mov.w	r3, #4294967295
3419e5bc:	60fb      	str	r3, [r7, #12]
3419e5be:	e02c      	b.n	3419e61a <IMX335_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
3419e5c0:	683b      	ldr	r3, [r7, #0]
3419e5c2:	681a      	ldr	r2, [r3, #0]
3419e5c4:	687b      	ldr	r3, [r7, #4]
3419e5c6:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
3419e5c8:	683b      	ldr	r3, [r7, #0]
3419e5ca:	685a      	ldr	r2, [r3, #4]
3419e5cc:	687b      	ldr	r3, [r7, #4]
3419e5ce:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
3419e5d0:	683b      	ldr	r3, [r7, #0]
3419e5d2:	891a      	ldrh	r2, [r3, #8]
3419e5d4:	687b      	ldr	r3, [r7, #4]
3419e5d6:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
3419e5d8:	683b      	ldr	r3, [r7, #0]
3419e5da:	68da      	ldr	r2, [r3, #12]
3419e5dc:	687b      	ldr	r3, [r7, #4]
3419e5de:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
3419e5e0:	683b      	ldr	r3, [r7, #0]
3419e5e2:	691a      	ldr	r2, [r3, #16]
3419e5e4:	687b      	ldr	r3, [r7, #4]
3419e5e6:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
3419e5e8:	683b      	ldr	r3, [r7, #0]
3419e5ea:	695a      	ldr	r2, [r3, #20]
3419e5ec:	687b      	ldr	r3, [r7, #4]
3419e5ee:	615a      	str	r2, [r3, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
3419e5f0:	687b      	ldr	r3, [r7, #4]
3419e5f2:	4a0c      	ldr	r2, [pc, #48]	@ (3419e624 <IMX335_RegisterBusIO+0x7c>)
3419e5f4:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
3419e5f6:	687b      	ldr	r3, [r7, #4]
3419e5f8:	4a0b      	ldr	r2, [pc, #44]	@ (3419e628 <IMX335_RegisterBusIO+0x80>)
3419e5fa:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
3419e5fc:	687b      	ldr	r3, [r7, #4]
3419e5fe:	687a      	ldr	r2, [r7, #4]
3419e600:	621a      	str	r2, [r3, #32]

    if(pObj->IO.Init != NULL)
3419e602:	687b      	ldr	r3, [r7, #4]
3419e604:	681b      	ldr	r3, [r3, #0]
3419e606:	2b00      	cmp	r3, #0
3419e608:	d004      	beq.n	3419e614 <IMX335_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
3419e60a:	687b      	ldr	r3, [r7, #4]
3419e60c:	681b      	ldr	r3, [r3, #0]
3419e60e:	4798      	blx	r3
3419e610:	60f8      	str	r0, [r7, #12]
3419e612:	e002      	b.n	3419e61a <IMX335_RegisterBusIO+0x72>
    }
    else
    {
      ret = IMX335_ERROR;
3419e614:	f04f 33ff 	mov.w	r3, #4294967295
3419e618:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
3419e61a:	68fb      	ldr	r3, [r7, #12]
}
3419e61c:	4618      	mov	r0, r3
3419e61e:	3710      	adds	r7, #16
3419e620:	46bd      	mov	sp, r7
3419e622:	bd80      	pop	{r7, pc}
3419e624:	3419e543 	.word	0x3419e543
3419e628:	3419e575 	.word	0x3419e575

3419e62c <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
3419e62c:	b580      	push	{r7, lr}
3419e62e:	b086      	sub	sp, #24
3419e630:	af00      	add	r7, sp, #0
3419e632:	60f8      	str	r0, [r7, #12]
3419e634:	60b9      	str	r1, [r7, #8]
3419e636:	607a      	str	r2, [r7, #4]
  int32_t ret = IMX335_OK;
3419e638:	2300      	movs	r3, #0
3419e63a:	617b      	str	r3, [r7, #20]

  if(pObj->IsInitialized == 0U)
3419e63c:	68fb      	ldr	r3, [r7, #12]
3419e63e:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3419e642:	2b00      	cmp	r3, #0
3419e644:	d126      	bne.n	3419e694 <IMX335_Init+0x68>
  {
    switch (Resolution)
3419e646:	68bb      	ldr	r3, [r7, #8]
3419e648:	2b06      	cmp	r3, #6
3419e64a:	d10b      	bne.n	3419e664 <IMX335_Init+0x38>
    {
      case IMX335_R2592_1944:
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
3419e64c:	2254      	movs	r2, #84	@ 0x54
3419e64e:	4914      	ldr	r1, [pc, #80]	@ (3419e6a0 <IMX335_Init+0x74>)
3419e650:	68f8      	ldr	r0, [r7, #12]
3419e652:	f7ff ff2b 	bl	3419e4ac <IMX335_WriteTable>
3419e656:	4603      	mov	r3, r0
3419e658:	2b00      	cmp	r3, #0
3419e65a:	d007      	beq.n	3419e66c <IMX335_Init+0x40>
        {
          ret = IMX335_ERROR;
3419e65c:	f04f 33ff 	mov.w	r3, #4294967295
3419e660:	617b      	str	r3, [r7, #20]
        }
        break;
3419e662:	e003      	b.n	3419e66c <IMX335_Init+0x40>
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
3419e664:	f04f 33ff 	mov.w	r3, #4294967295
3419e668:	617b      	str	r3, [r7, #20]
3419e66a:	e000      	b.n	3419e66e <IMX335_Init+0x42>
        break;
3419e66c:	bf00      	nop
    }

    if(!ret)
3419e66e:	697b      	ldr	r3, [r7, #20]
3419e670:	2b00      	cmp	r3, #0
3419e672:	d10f      	bne.n	3419e694 <IMX335_Init+0x68>
    {
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
3419e674:	2205      	movs	r2, #5
3419e676:	490b      	ldr	r1, [pc, #44]	@ (3419e6a4 <IMX335_Init+0x78>)
3419e678:	68f8      	ldr	r0, [r7, #12]
3419e67a:	f7ff ff17 	bl	3419e4ac <IMX335_WriteTable>
3419e67e:	4603      	mov	r3, r0
3419e680:	2b00      	cmp	r3, #0
3419e682:	d003      	beq.n	3419e68c <IMX335_Init+0x60>
      {
        ret = IMX335_ERROR;
3419e684:	f04f 33ff 	mov.w	r3, #4294967295
3419e688:	617b      	str	r3, [r7, #20]
3419e68a:	e003      	b.n	3419e694 <IMX335_Init+0x68>
      }
      else
      {
        pObj->IsInitialized = 1U;
3419e68c:	68fb      	ldr	r3, [r7, #12]
3419e68e:	2201      	movs	r2, #1
3419e690:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
      }
    }
  }

  return ret;
3419e694:	697b      	ldr	r3, [r7, #20]
}
3419e696:	4618      	mov	r0, r3
3419e698:	3718      	adds	r7, #24
3419e69a:	46bd      	mov	sp, r7
3419e69c:	bd80      	pop	{r7, pc}
3419e69e:	bf00      	nop
3419e6a0:	341a84d4 	.word	0x341a84d4
3419e6a4:	341a8624 	.word	0x341a8624

3419e6a8 <IMX335_Start>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
3419e6a8:	b580      	push	{r7, lr}
3419e6aa:	b084      	sub	sp, #16
3419e6ac:	af00      	add	r7, sp, #0
3419e6ae:	6078      	str	r0, [r7, #4]
  uint8_t tmp;
  int32_t ret = IMX335_OK;
3419e6b0:	2300      	movs	r3, #0
3419e6b2:	60fb      	str	r3, [r7, #12]
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
3419e6b4:	2300      	movs	r3, #0
3419e6b6:	72fb      	strb	r3, [r7, #11]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
3419e6b8:	687b      	ldr	r3, [r7, #4]
3419e6ba:	f103 0018 	add.w	r0, r3, #24
3419e6be:	f107 020b 	add.w	r2, r7, #11
3419e6c2:	2301      	movs	r3, #1
3419e6c4:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
3419e6c8:	f000 fa8f 	bl	3419ebea <imx335_write_reg>
3419e6cc:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3419e6ce:	68fb      	ldr	r3, [r7, #12]
3419e6d0:	2b00      	cmp	r3, #0
3419e6d2:	d002      	beq.n	3419e6da <IMX335_Start+0x32>
  {
    return IMX335_ERROR;
3419e6d4:	f04f 33ff 	mov.w	r3, #4294967295
3419e6d8:	e004      	b.n	3419e6e4 <IMX335_Start+0x3c>
  }
  IMX335_Delay(pObj, 20);
3419e6da:	2114      	movs	r1, #20
3419e6dc:	6878      	ldr	r0, [r7, #4]
3419e6de:	f7ff ff16 	bl	3419e50e <IMX335_Delay>
  return ret;
3419e6e2:	68fb      	ldr	r3, [r7, #12]
}
3419e6e4:	4618      	mov	r0, r3
3419e6e6:	3710      	adds	r7, #16
3419e6e8:	46bd      	mov	sp, r7
3419e6ea:	bd80      	pop	{r7, pc}

3419e6ec <IMX335_DeInit>:
  * @brief  De-initializes the camera sensor.
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
3419e6ec:	b480      	push	{r7}
3419e6ee:	b083      	sub	sp, #12
3419e6f0:	af00      	add	r7, sp, #0
3419e6f2:	6078      	str	r0, [r7, #4]
  if(pObj->IsInitialized == 1U)
3419e6f4:	687b      	ldr	r3, [r7, #4]
3419e6f6:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3419e6fa:	2b01      	cmp	r3, #1
3419e6fc:	d103      	bne.n	3419e706 <IMX335_DeInit+0x1a>
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
3419e6fe:	687b      	ldr	r3, [r7, #4]
3419e700:	2200      	movs	r2, #0
3419e702:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  }

  return IMX335_OK;
3419e706:	2300      	movs	r3, #0
}
3419e708:	4618      	mov	r0, r3
3419e70a:	370c      	adds	r7, #12
3419e70c:	46bd      	mov	sp, r7
3419e70e:	f85d 7b04 	ldr.w	r7, [sp], #4
3419e712:	4770      	bx	lr

3419e714 <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
3419e714:	b580      	push	{r7, lr}
3419e716:	b084      	sub	sp, #16
3419e718:	af00      	add	r7, sp, #0
3419e71a:	6078      	str	r0, [r7, #4]
3419e71c:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
3419e71e:	687b      	ldr	r3, [r7, #4]
3419e720:	681b      	ldr	r3, [r3, #0]
3419e722:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
3419e724:	687b      	ldr	r3, [r7, #4]
3419e726:	f103 0018 	add.w	r0, r3, #24
3419e72a:	f107 020b 	add.w	r2, r7, #11
3419e72e:	2301      	movs	r3, #1
3419e730:	f643 1112 	movw	r1, #14610	@ 0x3912
3419e734:	f000 fa42 	bl	3419ebbc <imx335_read_reg>
3419e738:	4603      	mov	r3, r0
3419e73a:	2b00      	cmp	r3, #0
3419e73c:	d003      	beq.n	3419e746 <IMX335_ReadID+0x32>
  {
    ret = IMX335_ERROR;
3419e73e:	f04f 33ff 	mov.w	r3, #4294967295
3419e742:	60fb      	str	r3, [r7, #12]
3419e744:	e005      	b.n	3419e752 <IMX335_ReadID+0x3e>
  }
  else
  {
    *Id = tmp;
3419e746:	7afb      	ldrb	r3, [r7, #11]
3419e748:	461a      	mov	r2, r3
3419e74a:	683b      	ldr	r3, [r7, #0]
3419e74c:	601a      	str	r2, [r3, #0]
    ret = IMX335_OK;
3419e74e:	2300      	movs	r3, #0
3419e750:	60fb      	str	r3, [r7, #12]
  }

  /* Component status */
  return ret;
3419e752:	68fb      	ldr	r3, [r7, #12]
}
3419e754:	4618      	mov	r0, r3
3419e756:	3710      	adds	r7, #16
3419e758:	46bd      	mov	sp, r7
3419e75a:	bd80      	pop	{r7, pc}

3419e75c <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
3419e75c:	b580      	push	{r7, lr}
3419e75e:	b084      	sub	sp, #16
3419e760:	af00      	add	r7, sp, #0
3419e762:	6078      	str	r0, [r7, #4]
3419e764:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419e766:	2300      	movs	r3, #0
3419e768:	60fb      	str	r3, [r7, #12]
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
3419e76a:	683b      	ldr	r3, [r7, #0]
3419e76c:	4a25      	ldr	r2, [pc, #148]	@ (3419e804 <IMX335_SetGain+0xa8>)
3419e76e:	4293      	cmp	r3, r2
3419e770:	dc02      	bgt.n	3419e778 <IMX335_SetGain+0x1c>
3419e772:	683b      	ldr	r3, [r7, #0]
3419e774:	2b00      	cmp	r3, #0
3419e776:	da03      	bge.n	3419e780 <IMX335_SetGain+0x24>
  {
    ret = IMX335_ERROR;
3419e778:	f04f 33ff 	mov.w	r3, #4294967295
3419e77c:	60fb      	str	r3, [r7, #12]
3419e77e:	e03c      	b.n	3419e7fa <IMX335_SetGain+0x9e>
  }
  else
  {
    /* Convert to IMX335 gain unit (0.3 dB = 300 mdB) */
    gain /= IMX335_GAIN_UNIT_MDB;
3419e780:	683b      	ldr	r3, [r7, #0]
3419e782:	4a21      	ldr	r2, [pc, #132]	@ (3419e808 <IMX335_SetGain+0xac>)
3419e784:	fb82 1203 	smull	r1, r2, r2, r3
3419e788:	1152      	asrs	r2, r2, #5
3419e78a:	17db      	asrs	r3, r3, #31
3419e78c:	1ad3      	subs	r3, r2, r3
3419e78e:	603b      	str	r3, [r7, #0]

    hold = 1;
3419e790:	2301      	movs	r3, #1
3419e792:	72fb      	strb	r3, [r7, #11]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419e794:	687b      	ldr	r3, [r7, #4]
3419e796:	f103 0018 	add.w	r0, r3, #24
3419e79a:	f107 020b 	add.w	r2, r7, #11
3419e79e:	2301      	movs	r3, #1
3419e7a0:	f243 0101 	movw	r1, #12289	@ 0x3001
3419e7a4:	f000 fa21 	bl	3419ebea <imx335_write_reg>
3419e7a8:	4603      	mov	r3, r0
3419e7aa:	2b00      	cmp	r3, #0
3419e7ac:	d003      	beq.n	3419e7b6 <IMX335_SetGain+0x5a>
    {
      ret = IMX335_ERROR;
3419e7ae:	f04f 33ff 	mov.w	r3, #4294967295
3419e7b2:	60fb      	str	r3, [r7, #12]
3419e7b4:	e021      	b.n	3419e7fa <IMX335_SetGain+0x9e>
    }
    else
    {
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
3419e7b6:	687b      	ldr	r3, [r7, #4]
3419e7b8:	f103 0018 	add.w	r0, r3, #24
3419e7bc:	463a      	mov	r2, r7
3419e7be:	2302      	movs	r3, #2
3419e7c0:	f243 01e8 	movw	r1, #12520	@ 0x30e8
3419e7c4:	f000 fa11 	bl	3419ebea <imx335_write_reg>
3419e7c8:	4603      	mov	r3, r0
3419e7ca:	2b00      	cmp	r3, #0
3419e7cc:	d003      	beq.n	3419e7d6 <IMX335_SetGain+0x7a>
      {
        ret = IMX335_ERROR;
3419e7ce:	f04f 33ff 	mov.w	r3, #4294967295
3419e7d2:	60fb      	str	r3, [r7, #12]
3419e7d4:	e011      	b.n	3419e7fa <IMX335_SetGain+0x9e>
      }
      else
      {
        hold = 0;
3419e7d6:	2300      	movs	r3, #0
3419e7d8:	72fb      	strb	r3, [r7, #11]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419e7da:	687b      	ldr	r3, [r7, #4]
3419e7dc:	f103 0018 	add.w	r0, r3, #24
3419e7e0:	f107 020b 	add.w	r2, r7, #11
3419e7e4:	2301      	movs	r3, #1
3419e7e6:	f243 0101 	movw	r1, #12289	@ 0x3001
3419e7ea:	f000 f9fe 	bl	3419ebea <imx335_write_reg>
3419e7ee:	4603      	mov	r3, r0
3419e7f0:	2b00      	cmp	r3, #0
3419e7f2:	d002      	beq.n	3419e7fa <IMX335_SetGain+0x9e>
        {
          ret = IMX335_ERROR;
3419e7f4:	f04f 33ff 	mov.w	r3, #4294967295
3419e7f8:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

return ret;
3419e7fa:	68fb      	ldr	r3, [r7, #12]
}
3419e7fc:	4618      	mov	r0, r3
3419e7fe:	3710      	adds	r7, #16
3419e800:	46bd      	mov	sp, r7
3419e802:	bd80      	pop	{r7, pc}
3419e804:	00011940 	.word	0x00011940
3419e808:	1b4e81b5 	.word	0x1b4e81b5

3419e80c <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
3419e80c:	b580      	push	{r7, lr}
3419e80e:	b086      	sub	sp, #24
3419e810:	af00      	add	r7, sp, #0
3419e812:	6078      	str	r0, [r7, #4]
3419e814:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419e816:	2300      	movs	r3, #0
3419e818:	617b      	str	r3, [r7, #20]
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
3419e81a:	687b      	ldr	r3, [r7, #4]
3419e81c:	f103 0018 	add.w	r0, r3, #24
3419e820:	f107 0210 	add.w	r2, r7, #16
3419e824:	2304      	movs	r3, #4
3419e826:	f243 0130 	movw	r1, #12336	@ 0x3030
3419e82a:	f000 f9c7 	bl	3419ebbc <imx335_read_reg>
3419e82e:	4603      	mov	r3, r0
3419e830:	2b00      	cmp	r3, #0
3419e832:	d003      	beq.n	3419e83c <IMX335_SetExposure+0x30>
  {
    ret = IMX335_ERROR;
3419e834:	f04f 33ff 	mov.w	r3, #4294967295
3419e838:	617b      	str	r3, [r7, #20]
3419e83a:	e051      	b.n	3419e8e0 <IMX335_SetExposure+0xd4>
  }
  else
  {
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
3419e83c:	693b      	ldr	r3, [r7, #16]
3419e83e:	ee07 3a90 	vmov	s15, r3
3419e842:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3419e846:	683b      	ldr	r3, [r7, #0]
3419e848:	ee07 3a90 	vmov	s15, r3
3419e84c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3419e850:	ed9f 6a26 	vldr	s12, [pc, #152]	@ 3419e8ec <IMX335_SetExposure+0xe0>
3419e854:	eec6 7a86 	vdiv.f32	s15, s13, s12
3419e858:	ee77 7a67 	vsub.f32	s15, s14, s15
3419e85c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3419e860:	ee17 3a90 	vmov	r3, s15
3419e864:	60fb      	str	r3, [r7, #12]

    if (shutter < IMX335_SHUTTER_MIN)
3419e866:	68fb      	ldr	r3, [r7, #12]
3419e868:	2b08      	cmp	r3, #8
3419e86a:	d803      	bhi.n	3419e874 <IMX335_SetExposure+0x68>
    {
      ret = IMX335_ERROR;
3419e86c:	f04f 33ff 	mov.w	r3, #4294967295
3419e870:	617b      	str	r3, [r7, #20]
3419e872:	e035      	b.n	3419e8e0 <IMX335_SetExposure+0xd4>
    }
    else
    {
      hold = 1;
3419e874:	2301      	movs	r3, #1
3419e876:	72fb      	strb	r3, [r7, #11]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419e878:	687b      	ldr	r3, [r7, #4]
3419e87a:	f103 0018 	add.w	r0, r3, #24
3419e87e:	f107 020b 	add.w	r2, r7, #11
3419e882:	2301      	movs	r3, #1
3419e884:	f243 0101 	movw	r1, #12289	@ 0x3001
3419e888:	f000 f9af 	bl	3419ebea <imx335_write_reg>
3419e88c:	4603      	mov	r3, r0
3419e88e:	2b00      	cmp	r3, #0
3419e890:	d003      	beq.n	3419e89a <IMX335_SetExposure+0x8e>
      {
        ret = IMX335_ERROR;
3419e892:	f04f 33ff 	mov.w	r3, #4294967295
3419e896:	617b      	str	r3, [r7, #20]
3419e898:	e022      	b.n	3419e8e0 <IMX335_SetExposure+0xd4>
      }
      else
      {
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
3419e89a:	687b      	ldr	r3, [r7, #4]
3419e89c:	f103 0018 	add.w	r0, r3, #24
3419e8a0:	f107 020c 	add.w	r2, r7, #12
3419e8a4:	2303      	movs	r3, #3
3419e8a6:	f243 0158 	movw	r1, #12376	@ 0x3058
3419e8aa:	f000 f99e 	bl	3419ebea <imx335_write_reg>
3419e8ae:	4603      	mov	r3, r0
3419e8b0:	2b00      	cmp	r3, #0
3419e8b2:	d003      	beq.n	3419e8bc <IMX335_SetExposure+0xb0>
        {
          ret = IMX335_ERROR;
3419e8b4:	f04f 33ff 	mov.w	r3, #4294967295
3419e8b8:	617b      	str	r3, [r7, #20]
3419e8ba:	e011      	b.n	3419e8e0 <IMX335_SetExposure+0xd4>
        }
        else
        {
          hold = 0;
3419e8bc:	2300      	movs	r3, #0
3419e8be:	72fb      	strb	r3, [r7, #11]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3419e8c0:	687b      	ldr	r3, [r7, #4]
3419e8c2:	f103 0018 	add.w	r0, r3, #24
3419e8c6:	f107 020b 	add.w	r2, r7, #11
3419e8ca:	2301      	movs	r3, #1
3419e8cc:	f243 0101 	movw	r1, #12289	@ 0x3001
3419e8d0:	f000 f98b 	bl	3419ebea <imx335_write_reg>
3419e8d4:	4603      	mov	r3, r0
3419e8d6:	2b00      	cmp	r3, #0
3419e8d8:	d002      	beq.n	3419e8e0 <IMX335_SetExposure+0xd4>
          {
            ret = IMX335_ERROR;
3419e8da:	f04f 33ff 	mov.w	r3, #4294967295
3419e8de:	617b      	str	r3, [r7, #20]
        }
      }
    }
  }

  return ret;
3419e8e0:	697b      	ldr	r3, [r7, #20]
}
3419e8e2:	4618      	mov	r0, r3
3419e8e4:	3718      	adds	r7, #24
3419e8e6:	46bd      	mov	sp, r7
3419e8e8:	bd80      	pop	{r7, pc}
3419e8ea:	bf00      	nop
3419e8ec:	40ed097c 	.word	0x40ed097c

3419e8f0 <IMX335_SetFrequency>:
  * @param  pObj  pointer to component object
  * @param  frequency in Mhz
  * @retval Component status
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
3419e8f0:	b580      	push	{r7, lr}
3419e8f2:	b084      	sub	sp, #16
3419e8f4:	af00      	add	r7, sp, #0
3419e8f6:	6078      	str	r0, [r7, #4]
3419e8f8:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3419e8fa:	2300      	movs	r3, #0
3419e8fc:	60fb      	str	r3, [r7, #12]

  switch (frequency)
3419e8fe:	683b      	ldr	r3, [r7, #0]
3419e900:	3b01      	subs	r3, #1
3419e902:	2b03      	cmp	r3, #3
3419e904:	d83a      	bhi.n	3419e97c <IMX335_SetFrequency+0x8c>
3419e906:	a201      	add	r2, pc, #4	@ (adr r2, 3419e90c <IMX335_SetFrequency+0x1c>)
3419e908:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419e90c:	3419e965 	.word	0x3419e965
3419e910:	3419e94d 	.word	0x3419e94d
3419e914:	3419e935 	.word	0x3419e935
3419e918:	3419e91d 	.word	0x3419e91d
  {
    case IMX335_INCK_74MHZ:
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
3419e91c:	2207      	movs	r2, #7
3419e91e:	4924      	ldr	r1, [pc, #144]	@ (3419e9b0 <IMX335_SetFrequency+0xc0>)
3419e920:	6878      	ldr	r0, [r7, #4]
3419e922:	f7ff fdc3 	bl	3419e4ac <IMX335_WriteTable>
3419e926:	4603      	mov	r3, r0
3419e928:	2b00      	cmp	r3, #0
3419e92a:	d033      	beq.n	3419e994 <IMX335_SetFrequency+0xa4>
      {
        ret = IMX335_ERROR;
3419e92c:	f04f 33ff 	mov.w	r3, #4294967295
3419e930:	60fb      	str	r3, [r7, #12]
      }
      break;
3419e932:	e02f      	b.n	3419e994 <IMX335_SetFrequency+0xa4>
    case IMX335_INCK_27MHZ:
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
3419e934:	2207      	movs	r2, #7
3419e936:	491f      	ldr	r1, [pc, #124]	@ (3419e9b4 <IMX335_SetFrequency+0xc4>)
3419e938:	6878      	ldr	r0, [r7, #4]
3419e93a:	f7ff fdb7 	bl	3419e4ac <IMX335_WriteTable>
3419e93e:	4603      	mov	r3, r0
3419e940:	2b00      	cmp	r3, #0
3419e942:	d029      	beq.n	3419e998 <IMX335_SetFrequency+0xa8>
      {
        ret = IMX335_ERROR;
3419e944:	f04f 33ff 	mov.w	r3, #4294967295
3419e948:	60fb      	str	r3, [r7, #12]
      }
      break;
3419e94a:	e025      	b.n	3419e998 <IMX335_SetFrequency+0xa8>
    case IMX335_INCK_24MHZ:
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
3419e94c:	2207      	movs	r2, #7
3419e94e:	491a      	ldr	r1, [pc, #104]	@ (3419e9b8 <IMX335_SetFrequency+0xc8>)
3419e950:	6878      	ldr	r0, [r7, #4]
3419e952:	f7ff fdab 	bl	3419e4ac <IMX335_WriteTable>
3419e956:	4603      	mov	r3, r0
3419e958:	2b00      	cmp	r3, #0
3419e95a:	d01f      	beq.n	3419e99c <IMX335_SetFrequency+0xac>
      {
        ret = IMX335_ERROR;
3419e95c:	f04f 33ff 	mov.w	r3, #4294967295
3419e960:	60fb      	str	r3, [r7, #12]
      }
      break;
3419e962:	e01b      	b.n	3419e99c <IMX335_SetFrequency+0xac>
    case IMX335_INCK_18MHZ:
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
3419e964:	2207      	movs	r2, #7
3419e966:	4915      	ldr	r1, [pc, #84]	@ (3419e9bc <IMX335_SetFrequency+0xcc>)
3419e968:	6878      	ldr	r0, [r7, #4]
3419e96a:	f7ff fd9f 	bl	3419e4ac <IMX335_WriteTable>
3419e96e:	4603      	mov	r3, r0
3419e970:	2b00      	cmp	r3, #0
3419e972:	d015      	beq.n	3419e9a0 <IMX335_SetFrequency+0xb0>
      {
        ret = IMX335_ERROR;
3419e974:	f04f 33ff 	mov.w	r3, #4294967295
3419e978:	60fb      	str	r3, [r7, #12]
      }
      break;
3419e97a:	e011      	b.n	3419e9a0 <IMX335_SetFrequency+0xb0>
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3419e97c:	2207      	movs	r2, #7
3419e97e:	4910      	ldr	r1, [pc, #64]	@ (3419e9c0 <IMX335_SetFrequency+0xd0>)
3419e980:	6878      	ldr	r0, [r7, #4]
3419e982:	f7ff fd93 	bl	3419e4ac <IMX335_WriteTable>
3419e986:	4603      	mov	r3, r0
3419e988:	2b00      	cmp	r3, #0
3419e98a:	d00b      	beq.n	3419e9a4 <IMX335_SetFrequency+0xb4>
      {
        ret = IMX335_ERROR;
3419e98c:	f04f 33ff 	mov.w	r3, #4294967295
3419e990:	60fb      	str	r3, [r7, #12]
      }
      break;
3419e992:	e007      	b.n	3419e9a4 <IMX335_SetFrequency+0xb4>
      break;
3419e994:	bf00      	nop
3419e996:	e006      	b.n	3419e9a6 <IMX335_SetFrequency+0xb6>
      break;
3419e998:	bf00      	nop
3419e99a:	e004      	b.n	3419e9a6 <IMX335_SetFrequency+0xb6>
      break;
3419e99c:	bf00      	nop
3419e99e:	e002      	b.n	3419e9a6 <IMX335_SetFrequency+0xb6>
      break;
3419e9a0:	bf00      	nop
3419e9a2:	e000      	b.n	3419e9a6 <IMX335_SetFrequency+0xb6>
      break;
3419e9a4:	bf00      	nop
  };

  return ret;
3419e9a6:	68fb      	ldr	r3, [r7, #12]
}
3419e9a8:	4618      	mov	r0, r3
3419e9aa:	3710      	adds	r7, #16
3419e9ac:	46bd      	mov	sp, r7
3419e9ae:	bd80      	pop	{r7, pc}
3419e9b0:	341a8638 	.word	0x341a8638
3419e9b4:	341a8654 	.word	0x341a8654
3419e9b8:	341a8670 	.word	0x341a8670
3419e9bc:	341a868c 	.word	0x341a868c
3419e9c0:	341a86a8 	.word	0x341a86a8

3419e9c4 <IMX335_SetFramerate>:
  * @param  pObj  pointer to component object
  * @param  framerate 10, 15, 20, 25 or 30fps
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
3419e9c4:	b580      	push	{r7, lr}
3419e9c6:	b084      	sub	sp, #16
3419e9c8:	af00      	add	r7, sp, #0
3419e9ca:	6078      	str	r0, [r7, #4]
3419e9cc:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3419e9ce:	2300      	movs	r3, #0
3419e9d0:	60fb      	str	r3, [r7, #12]
  switch (framerate)
3419e9d2:	683b      	ldr	r3, [r7, #0]
3419e9d4:	3b0a      	subs	r3, #10
3419e9d6:	2b0f      	cmp	r3, #15
3419e9d8:	d852      	bhi.n	3419ea80 <IMX335_SetFramerate+0xbc>
3419e9da:	a201      	add	r2, pc, #4	@ (adr r2, 3419e9e0 <IMX335_SetFramerate+0x1c>)
3419e9dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419e9e0:	3419ea21 	.word	0x3419ea21
3419e9e4:	3419ea81 	.word	0x3419ea81
3419e9e8:	3419ea81 	.word	0x3419ea81
3419e9ec:	3419ea81 	.word	0x3419ea81
3419e9f0:	3419ea81 	.word	0x3419ea81
3419e9f4:	3419ea39 	.word	0x3419ea39
3419e9f8:	3419ea81 	.word	0x3419ea81
3419e9fc:	3419ea81 	.word	0x3419ea81
3419ea00:	3419ea81 	.word	0x3419ea81
3419ea04:	3419ea81 	.word	0x3419ea81
3419ea08:	3419ea51 	.word	0x3419ea51
3419ea0c:	3419ea81 	.word	0x3419ea81
3419ea10:	3419ea81 	.word	0x3419ea81
3419ea14:	3419ea81 	.word	0x3419ea81
3419ea18:	3419ea81 	.word	0x3419ea81
3419ea1c:	3419ea69 	.word	0x3419ea69
  {
    case 10:
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
3419ea20:	2202      	movs	r2, #2
3419ea22:	4924      	ldr	r1, [pc, #144]	@ (3419eab4 <IMX335_SetFramerate+0xf0>)
3419ea24:	6878      	ldr	r0, [r7, #4]
3419ea26:	f7ff fd41 	bl	3419e4ac <IMX335_WriteTable>
3419ea2a:	4603      	mov	r3, r0
3419ea2c:	2b00      	cmp	r3, #0
3419ea2e:	d033      	beq.n	3419ea98 <IMX335_SetFramerate+0xd4>
      {
        ret = IMX335_ERROR;
3419ea30:	f04f 33ff 	mov.w	r3, #4294967295
3419ea34:	60fb      	str	r3, [r7, #12]
      }
      break;
3419ea36:	e02f      	b.n	3419ea98 <IMX335_SetFramerate+0xd4>
    case 15:
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
3419ea38:	2202      	movs	r2, #2
3419ea3a:	491f      	ldr	r1, [pc, #124]	@ (3419eab8 <IMX335_SetFramerate+0xf4>)
3419ea3c:	6878      	ldr	r0, [r7, #4]
3419ea3e:	f7ff fd35 	bl	3419e4ac <IMX335_WriteTable>
3419ea42:	4603      	mov	r3, r0
3419ea44:	2b00      	cmp	r3, #0
3419ea46:	d029      	beq.n	3419ea9c <IMX335_SetFramerate+0xd8>
      {
        ret = IMX335_ERROR;
3419ea48:	f04f 33ff 	mov.w	r3, #4294967295
3419ea4c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419ea4e:	e025      	b.n	3419ea9c <IMX335_SetFramerate+0xd8>
    case 20:
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
3419ea50:	2202      	movs	r2, #2
3419ea52:	491a      	ldr	r1, [pc, #104]	@ (3419eabc <IMX335_SetFramerate+0xf8>)
3419ea54:	6878      	ldr	r0, [r7, #4]
3419ea56:	f7ff fd29 	bl	3419e4ac <IMX335_WriteTable>
3419ea5a:	4603      	mov	r3, r0
3419ea5c:	2b00      	cmp	r3, #0
3419ea5e:	d01f      	beq.n	3419eaa0 <IMX335_SetFramerate+0xdc>
      {
       ret = IMX335_ERROR;
3419ea60:	f04f 33ff 	mov.w	r3, #4294967295
3419ea64:	60fb      	str	r3, [r7, #12]
      }
      break;
3419ea66:	e01b      	b.n	3419eaa0 <IMX335_SetFramerate+0xdc>
    case 25:
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
3419ea68:	2202      	movs	r2, #2
3419ea6a:	4915      	ldr	r1, [pc, #84]	@ (3419eac0 <IMX335_SetFramerate+0xfc>)
3419ea6c:	6878      	ldr	r0, [r7, #4]
3419ea6e:	f7ff fd1d 	bl	3419e4ac <IMX335_WriteTable>
3419ea72:	4603      	mov	r3, r0
3419ea74:	2b00      	cmp	r3, #0
3419ea76:	d015      	beq.n	3419eaa4 <IMX335_SetFramerate+0xe0>
      {
        ret = IMX335_ERROR;
3419ea78:	f04f 33ff 	mov.w	r3, #4294967295
3419ea7c:	60fb      	str	r3, [r7, #12]
      }
      break;
3419ea7e:	e011      	b.n	3419eaa4 <IMX335_SetFramerate+0xe0>
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
3419ea80:	2202      	movs	r2, #2
3419ea82:	4910      	ldr	r1, [pc, #64]	@ (3419eac4 <IMX335_SetFramerate+0x100>)
3419ea84:	6878      	ldr	r0, [r7, #4]
3419ea86:	f7ff fd11 	bl	3419e4ac <IMX335_WriteTable>
3419ea8a:	4603      	mov	r3, r0
3419ea8c:	2b00      	cmp	r3, #0
3419ea8e:	d00b      	beq.n	3419eaa8 <IMX335_SetFramerate+0xe4>
      {
        ret = IMX335_ERROR;
3419ea90:	f04f 33ff 	mov.w	r3, #4294967295
3419ea94:	60fb      	str	r3, [r7, #12]
      }
      break;
3419ea96:	e007      	b.n	3419eaa8 <IMX335_SetFramerate+0xe4>
      break;
3419ea98:	bf00      	nop
3419ea9a:	e006      	b.n	3419eaaa <IMX335_SetFramerate+0xe6>
      break;
3419ea9c:	bf00      	nop
3419ea9e:	e004      	b.n	3419eaaa <IMX335_SetFramerate+0xe6>
      break;
3419eaa0:	bf00      	nop
3419eaa2:	e002      	b.n	3419eaaa <IMX335_SetFramerate+0xe6>
      break;
3419eaa4:	bf00      	nop
3419eaa6:	e000      	b.n	3419eaaa <IMX335_SetFramerate+0xe6>
      break;
3419eaa8:	bf00      	nop
  };

  return ret;
3419eaaa:	68fb      	ldr	r3, [r7, #12]
}
3419eaac:	4618      	mov	r0, r3
3419eaae:	3710      	adds	r7, #16
3419eab0:	46bd      	mov	sp, r7
3419eab2:	bd80      	pop	{r7, pc}
3419eab4:	341a86c4 	.word	0x341a86c4
3419eab8:	341a86cc 	.word	0x341a86cc
3419eabc:	341a86d4 	.word	0x341a86d4
3419eac0:	341a86dc 	.word	0x341a86dc
3419eac4:	341a86e4 	.word	0x341a86e4

3419eac8 <IMX335_MirrorFlipConfig>:
  * @param  pObj  pointer to component object
  * @param  Config To configure mirror, flip, both or none
  * @retval Component status
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
3419eac8:	b580      	push	{r7, lr}
3419eaca:	b084      	sub	sp, #16
3419eacc:	af00      	add	r7, sp, #0
3419eace:	6078      	str	r0, [r7, #4]
3419ead0:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419ead2:	2300      	movs	r3, #0
3419ead4:	60fb      	str	r3, [r7, #12]

  switch (Config)
3419ead6:	683b      	ldr	r3, [r7, #0]
3419ead8:	2b03      	cmp	r3, #3
3419eada:	d017      	beq.n	3419eb0c <IMX335_MirrorFlipConfig+0x44>
3419eadc:	683b      	ldr	r3, [r7, #0]
3419eade:	2b03      	cmp	r3, #3
3419eae0:	d81b      	bhi.n	3419eb1a <IMX335_MirrorFlipConfig+0x52>
3419eae2:	683b      	ldr	r3, [r7, #0]
3419eae4:	2b01      	cmp	r3, #1
3419eae6:	d003      	beq.n	3419eaf0 <IMX335_MirrorFlipConfig+0x28>
3419eae8:	683b      	ldr	r3, [r7, #0]
3419eaea:	2b02      	cmp	r3, #2
3419eaec:	d007      	beq.n	3419eafe <IMX335_MirrorFlipConfig+0x36>
3419eaee:	e014      	b.n	3419eb1a <IMX335_MirrorFlipConfig+0x52>
  {
    case IMX335_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
3419eaf0:	220a      	movs	r2, #10
3419eaf2:	4910      	ldr	r1, [pc, #64]	@ (3419eb34 <IMX335_MirrorFlipConfig+0x6c>)
3419eaf4:	6878      	ldr	r0, [r7, #4]
3419eaf6:	f7ff fcd9 	bl	3419e4ac <IMX335_WriteTable>
3419eafa:	60f8      	str	r0, [r7, #12]
      break;
3419eafc:	e014      	b.n	3419eb28 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
3419eafe:	220a      	movs	r2, #10
3419eb00:	490d      	ldr	r1, [pc, #52]	@ (3419eb38 <IMX335_MirrorFlipConfig+0x70>)
3419eb02:	6878      	ldr	r0, [r7, #4]
3419eb04:	f7ff fcd2 	bl	3419e4ac <IMX335_WriteTable>
3419eb08:	60f8      	str	r0, [r7, #12]
      break;
3419eb0a:	e00d      	b.n	3419eb28 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
3419eb0c:	220a      	movs	r2, #10
3419eb0e:	490b      	ldr	r1, [pc, #44]	@ (3419eb3c <IMX335_MirrorFlipConfig+0x74>)
3419eb10:	6878      	ldr	r0, [r7, #4]
3419eb12:	f7ff fccb 	bl	3419e4ac <IMX335_WriteTable>
3419eb16:	60f8      	str	r0, [r7, #12]
      break;
3419eb18:	e006      	b.n	3419eb28 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3419eb1a:	220a      	movs	r2, #10
3419eb1c:	4908      	ldr	r1, [pc, #32]	@ (3419eb40 <IMX335_MirrorFlipConfig+0x78>)
3419eb1e:	6878      	ldr	r0, [r7, #4]
3419eb20:	f7ff fcc4 	bl	3419e4ac <IMX335_WriteTable>
3419eb24:	60f8      	str	r0, [r7, #12]
      break;
3419eb26:	bf00      	nop
  }
  return ret;
3419eb28:	68fb      	ldr	r3, [r7, #12]
}
3419eb2a:	4618      	mov	r0, r3
3419eb2c:	3710      	adds	r7, #16
3419eb2e:	46bd      	mov	sp, r7
3419eb30:	bd80      	pop	{r7, pc}
3419eb32:	bf00      	nop
3419eb34:	341a8714 	.word	0x341a8714
3419eb38:	341a873c 	.word	0x341a873c
3419eb3c:	341a8764 	.word	0x341a8764
3419eb40:	341a86ec 	.word	0x341a86ec

3419eb44 <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
3419eb44:	b580      	push	{r7, lr}
3419eb46:	b084      	sub	sp, #16
3419eb48:	af00      	add	r7, sp, #0
3419eb4a:	6078      	str	r0, [r7, #4]
3419eb4c:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3419eb4e:	2300      	movs	r3, #0
3419eb50:	60fb      	str	r3, [r7, #12]
  uint8_t val;

  if (mode >= 0)
3419eb52:	683b      	ldr	r3, [r7, #0]
3419eb54:	2b00      	cmp	r3, #0
3419eb56:	db1d      	blt.n	3419eb94 <IMX335_SetTestPattern+0x50>
  {
    /* Enable Test Pattern #mode */
    val = mode;
3419eb58:	683b      	ldr	r3, [r7, #0]
3419eb5a:	b2db      	uxtb	r3, r3
3419eb5c:	72fb      	strb	r3, [r7, #11]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
3419eb5e:	687b      	ldr	r3, [r7, #4]
3419eb60:	f103 0018 	add.w	r0, r3, #24
3419eb64:	f107 020b 	add.w	r2, r7, #11
3419eb68:	2301      	movs	r3, #1
3419eb6a:	f243 219e 	movw	r1, #12958	@ 0x329e
3419eb6e:	f000 f83c 	bl	3419ebea <imx335_write_reg>
3419eb72:	4603      	mov	r3, r0
3419eb74:	2b00      	cmp	r3, #0
3419eb76:	d002      	beq.n	3419eb7e <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
3419eb78:	f04f 33ff 	mov.w	r3, #4294967295
3419eb7c:	e016      	b.n	3419ebac <IMX335_SetTestPattern+0x68>
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
3419eb7e:	2207      	movs	r2, #7
3419eb80:	490c      	ldr	r1, [pc, #48]	@ (3419ebb4 <IMX335_SetTestPattern+0x70>)
3419eb82:	6878      	ldr	r0, [r7, #4]
3419eb84:	f7ff fc92 	bl	3419e4ac <IMX335_WriteTable>
3419eb88:	4603      	mov	r3, r0
3419eb8a:	2b00      	cmp	r3, #0
3419eb8c:	d00d      	beq.n	3419ebaa <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3419eb8e:	f04f 33ff 	mov.w	r3, #4294967295
3419eb92:	e00b      	b.n	3419ebac <IMX335_SetTestPattern+0x68>
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
3419eb94:	2207      	movs	r2, #7
3419eb96:	4908      	ldr	r1, [pc, #32]	@ (3419ebb8 <IMX335_SetTestPattern+0x74>)
3419eb98:	6878      	ldr	r0, [r7, #4]
3419eb9a:	f7ff fc87 	bl	3419e4ac <IMX335_WriteTable>
3419eb9e:	4603      	mov	r3, r0
3419eba0:	2b00      	cmp	r3, #0
3419eba2:	d002      	beq.n	3419ebaa <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3419eba4:	f04f 33ff 	mov.w	r3, #4294967295
3419eba8:	e000      	b.n	3419ebac <IMX335_SetTestPattern+0x68>
    }
  }

  return ret;
3419ebaa:	68fb      	ldr	r3, [r7, #12]
}
3419ebac:	4618      	mov	r0, r3
3419ebae:	3710      	adds	r7, #16
3419ebb0:	46bd      	mov	sp, r7
3419ebb2:	bd80      	pop	{r7, pc}
3419ebb4:	341a878c 	.word	0x341a878c
3419ebb8:	341a87a8 	.word	0x341a87a8

3419ebbc <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
3419ebbc:	b590      	push	{r4, r7, lr}
3419ebbe:	b085      	sub	sp, #20
3419ebc0:	af00      	add	r7, sp, #0
3419ebc2:	60f8      	str	r0, [r7, #12]
3419ebc4:	607a      	str	r2, [r7, #4]
3419ebc6:	461a      	mov	r2, r3
3419ebc8:	460b      	mov	r3, r1
3419ebca:	817b      	strh	r3, [r7, #10]
3419ebcc:	4613      	mov	r3, r2
3419ebce:	813b      	strh	r3, [r7, #8]
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
3419ebd0:	68fb      	ldr	r3, [r7, #12]
3419ebd2:	685c      	ldr	r4, [r3, #4]
3419ebd4:	68fb      	ldr	r3, [r7, #12]
3419ebd6:	6898      	ldr	r0, [r3, #8]
3419ebd8:	893b      	ldrh	r3, [r7, #8]
3419ebda:	8979      	ldrh	r1, [r7, #10]
3419ebdc:	687a      	ldr	r2, [r7, #4]
3419ebde:	47a0      	blx	r4
3419ebe0:	4603      	mov	r3, r0
}
3419ebe2:	4618      	mov	r0, r3
3419ebe4:	3714      	adds	r7, #20
3419ebe6:	46bd      	mov	sp, r7
3419ebe8:	bd90      	pop	{r4, r7, pc}

3419ebea <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
3419ebea:	b590      	push	{r4, r7, lr}
3419ebec:	b085      	sub	sp, #20
3419ebee:	af00      	add	r7, sp, #0
3419ebf0:	60f8      	str	r0, [r7, #12]
3419ebf2:	607a      	str	r2, [r7, #4]
3419ebf4:	461a      	mov	r2, r3
3419ebf6:	460b      	mov	r3, r1
3419ebf8:	817b      	strh	r3, [r7, #10]
3419ebfa:	4613      	mov	r3, r2
3419ebfc:	813b      	strh	r3, [r7, #8]
  return ctx->WriteReg(ctx->handle, reg, data, length);
3419ebfe:	68fb      	ldr	r3, [r7, #12]
3419ec00:	681c      	ldr	r4, [r3, #0]
3419ec02:	68fb      	ldr	r3, [r7, #12]
3419ec04:	6898      	ldr	r0, [r3, #8]
3419ec06:	893b      	ldrh	r3, [r7, #8]
3419ec08:	8979      	ldrh	r1, [r7, #10]
3419ec0a:	687a      	ldr	r2, [r7, #4]
3419ec0c:	47a0      	blx	r4
3419ec0e:	4603      	mov	r3, r0
}
3419ec10:	4618      	mov	r0, r3
3419ec12:	3714      	adds	r7, #20
3419ec14:	46bd      	mov	sp, r7
3419ec16:	bd90      	pop	{r4, r7, pc}

3419ec18 <VD55G1_Resolution2Mode>:
  if (_ret_) display_error(_ctx_); \
  if (_ret_) return _ret_; \
} while(0)

static const struct vd55g1_mode *VD55G1_Resolution2Mode(VD55G1_Res_t resolution)
{
3419ec18:	b480      	push	{r7}
3419ec1a:	b083      	sub	sp, #12
3419ec1c:	af00      	add	r7, sp, #0
3419ec1e:	4603      	mov	r3, r0
3419ec20:	71fb      	strb	r3, [r7, #7]
  switch (resolution) {
3419ec22:	79fb      	ldrb	r3, [r7, #7]
3419ec24:	2b03      	cmp	r3, #3
3419ec26:	d813      	bhi.n	3419ec50 <VD55G1_Resolution2Mode+0x38>
3419ec28:	a201      	add	r2, pc, #4	@ (adr r2, 3419ec30 <VD55G1_Resolution2Mode+0x18>)
3419ec2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419ec2e:	bf00      	nop
3419ec30:	3419ec41 	.word	0x3419ec41
3419ec34:	3419ec45 	.word	0x3419ec45
3419ec38:	3419ec49 	.word	0x3419ec49
3419ec3c:	3419ec4d 	.word	0x3419ec4d
  case VD55G1_RES_QVGA_320_240:
    return &vd55g1_supported_modes[3];
3419ec40:	4b07      	ldr	r3, [pc, #28]	@ (3419ec60 <VD55G1_Resolution2Mode+0x48>)
3419ec42:	e006      	b.n	3419ec52 <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_VGA_640_480:
    return &vd55g1_supported_modes[2];
3419ec44:	4b07      	ldr	r3, [pc, #28]	@ (3419ec64 <VD55G1_Resolution2Mode+0x4c>)
3419ec46:	e004      	b.n	3419ec52 <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_SXGA_800_600:
    return &vd55g1_supported_modes[1];
3419ec48:	4b07      	ldr	r3, [pc, #28]	@ (3419ec68 <VD55G1_Resolution2Mode+0x50>)
3419ec4a:	e002      	b.n	3419ec52 <VD55G1_Resolution2Mode+0x3a>
    break;
  case VD55G1_RES_FULL_804_704:
    return &vd55g1_supported_modes[0];
3419ec4c:	4b07      	ldr	r3, [pc, #28]	@ (3419ec6c <VD55G1_Resolution2Mode+0x54>)
3419ec4e:	e000      	b.n	3419ec52 <VD55G1_Resolution2Mode+0x3a>
    break;
  default:
    return NULL;
3419ec50:	2300      	movs	r3, #0
  }
}
3419ec52:	4618      	mov	r0, r3
3419ec54:	370c      	adds	r7, #12
3419ec56:	46bd      	mov	sp, r7
3419ec58:	f85d 7b04 	ldr.w	r7, [sp], #4
3419ec5c:	4770      	bx	lr
3419ec5e:	bf00      	nop
3419ec60:	341a9ec4 	.word	0x341a9ec4
3419ec64:	341a9ea8 	.word	0x341a9ea8
3419ec68:	341a9e8c 	.word	0x341a9e8c
3419ec6c:	341a9e70 	.word	0x341a9e70

3419ec70 <VD55G1_log_impl>:

static void VD55G1_log_impl(VD55G1_Ctx_t *ctx, int lvl, const char *format, ...)
{
3419ec70:	b40c      	push	{r2, r3}
3419ec72:	b590      	push	{r4, r7, lr}
3419ec74:	b085      	sub	sp, #20
3419ec76:	af00      	add	r7, sp, #0
3419ec78:	6078      	str	r0, [r7, #4]
3419ec7a:	6039      	str	r1, [r7, #0]
  va_list ap;

  if (!ctx->log)
3419ec7c:	687b      	ldr	r3, [r7, #4]
3419ec7e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3419ec80:	2b00      	cmp	r3, #0
3419ec82:	d00a      	beq.n	3419ec9a <VD55G1_log_impl+0x2a>
    return ;

  va_start(ap, format);
3419ec84:	f107 0324 	add.w	r3, r7, #36	@ 0x24
3419ec88:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, lvl, format, ap);
3419ec8a:	687b      	ldr	r3, [r7, #4]
3419ec8c:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
3419ec8e:	68fb      	ldr	r3, [r7, #12]
3419ec90:	6a3a      	ldr	r2, [r7, #32]
3419ec92:	6839      	ldr	r1, [r7, #0]
3419ec94:	6878      	ldr	r0, [r7, #4]
3419ec96:	47a0      	blx	r4
3419ec98:	e000      	b.n	3419ec9c <VD55G1_log_impl+0x2c>
    return ;
3419ec9a:	bf00      	nop
  va_end(ap);
}
3419ec9c:	3714      	adds	r7, #20
3419ec9e:	46bd      	mov	sp, r7
3419eca0:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
3419eca4:	b002      	add	sp, #8
3419eca6:	4770      	bx	lr

3419eca8 <display_error>:
#define VD55G1_error(_ctx_, _fmt_, ...) do { \
  VD55G1_log_impl(_ctx_, VD55G1_LVL_ERROR, "VD55G1_ERR-%d : " _fmt_, __LINE__, ##__VA_ARGS__); \
} while(0)

static void display_error(VD55G1_Ctx_t *ctx)
{
3419eca8:	b580      	push	{r7, lr}
3419ecaa:	b086      	sub	sp, #24
3419ecac:	af02      	add	r7, sp, #8
3419ecae:	6078      	str	r0, [r7, #4]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD55G1_ERROR_CODE, &reg16);
3419ecb0:	687b      	ldr	r3, [r7, #4]
3419ecb2:	689b      	ldr	r3, [r3, #8]
3419ecb4:	f107 020a 	add.w	r2, r7, #10
3419ecb8:	2110      	movs	r1, #16
3419ecba:	6878      	ldr	r0, [r7, #4]
3419ecbc:	4798      	blx	r3
3419ecbe:	60f8      	str	r0, [r7, #12]
  assert(ret == 0);
3419ecc0:	68fb      	ldr	r3, [r7, #12]
3419ecc2:	2b00      	cmp	r3, #0
3419ecc4:	d005      	beq.n	3419ecd2 <display_error+0x2a>
3419ecc6:	4b09      	ldr	r3, [pc, #36]	@ (3419ecec <display_error+0x44>)
3419ecc8:	4a09      	ldr	r2, [pc, #36]	@ (3419ecf0 <display_error+0x48>)
3419ecca:	21fc      	movs	r1, #252	@ 0xfc
3419eccc:	4809      	ldr	r0, [pc, #36]	@ (3419ecf4 <display_error+0x4c>)
3419ecce:	f006 f985 	bl	341a4fdc <__assert_func>
  VD55G1_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
3419ecd2:	897b      	ldrh	r3, [r7, #10]
3419ecd4:	9300      	str	r3, [sp, #0]
3419ecd6:	23fd      	movs	r3, #253	@ 0xfd
3419ecd8:	4a07      	ldr	r2, [pc, #28]	@ (3419ecf8 <display_error+0x50>)
3419ecda:	2100      	movs	r1, #0
3419ecdc:	6878      	ldr	r0, [r7, #4]
3419ecde:	f7ff ffc7 	bl	3419ec70 <VD55G1_log_impl>
}
3419ece2:	bf00      	nop
3419ece4:	3710      	adds	r7, #16
3419ece6:	46bd      	mov	sp, r7
3419ece8:	bd80      	pop	{r7, pc}
3419ecea:	bf00      	nop
3419ecec:	341a7748 	.word	0x341a7748
3419ecf0:	341a9ee0 	.word	0x341a9ee0
3419ecf4:	341a7754 	.word	0x341a7754
3419ecf8:	341a7790 	.word	0x341a7790

3419ecfc <VD55G1_PollReg8>:

  return 0;
}

static int VD55G1_PollReg8(VD55G1_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
3419ecfc:	b580      	push	{r7, lr}
3419ecfe:	b08a      	sub	sp, #40	@ 0x28
3419ed00:	af02      	add	r7, sp, #8
3419ed02:	6078      	str	r0, [r7, #4]
3419ed04:	460b      	mov	r3, r1
3419ed06:	807b      	strh	r3, [r7, #2]
3419ed08:	4613      	mov	r3, r2
3419ed0a:	707b      	strb	r3, [r7, #1]
  const unsigned int loop_delay_ms = 10;
3419ed0c:	230a      	movs	r3, #10
3419ed0e:	61bb      	str	r3, [r7, #24]
  const unsigned int timeout_ms = 500;
3419ed10:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
3419ed14:	617b      	str	r3, [r7, #20]
  int loop_nb = timeout_ms / loop_delay_ms;
3419ed16:	697a      	ldr	r2, [r7, #20]
3419ed18:	69bb      	ldr	r3, [r7, #24]
3419ed1a:	fbb2 f3f3 	udiv	r3, r2, r3
3419ed1e:	61fb      	str	r3, [r7, #28]
  uint8_t val;
  int ret;

  while (--loop_nb) {
3419ed20:	e017      	b.n	3419ed52 <VD55G1_PollReg8+0x56>
    ret = ctx->read8(ctx, addr, &val);
3419ed22:	687b      	ldr	r3, [r7, #4]
3419ed24:	685b      	ldr	r3, [r3, #4]
3419ed26:	f107 020f 	add.w	r2, r7, #15
3419ed2a:	8879      	ldrh	r1, [r7, #2]
3419ed2c:	6878      	ldr	r0, [r7, #4]
3419ed2e:	4798      	blx	r3
3419ed30:	6138      	str	r0, [r7, #16]
    if (ret < 0)
3419ed32:	693b      	ldr	r3, [r7, #16]
3419ed34:	2b00      	cmp	r3, #0
3419ed36:	da01      	bge.n	3419ed3c <VD55G1_PollReg8+0x40>
      return ret;
3419ed38:	693b      	ldr	r3, [r7, #16]
3419ed3a:	e01d      	b.n	3419ed78 <VD55G1_PollReg8+0x7c>
    if (val == poll_val)
3419ed3c:	7bfb      	ldrb	r3, [r7, #15]
3419ed3e:	787a      	ldrb	r2, [r7, #1]
3419ed40:	429a      	cmp	r2, r3
3419ed42:	d101      	bne.n	3419ed48 <VD55G1_PollReg8+0x4c>
      return 0;
3419ed44:	2300      	movs	r3, #0
3419ed46:	e017      	b.n	3419ed78 <VD55G1_PollReg8+0x7c>
    ctx->delay(ctx, loop_delay_ms);
3419ed48:	687b      	ldr	r3, [r7, #4]
3419ed4a:	6a1b      	ldr	r3, [r3, #32]
3419ed4c:	69b9      	ldr	r1, [r7, #24]
3419ed4e:	6878      	ldr	r0, [r7, #4]
3419ed50:	4798      	blx	r3
  while (--loop_nb) {
3419ed52:	69fb      	ldr	r3, [r7, #28]
3419ed54:	3b01      	subs	r3, #1
3419ed56:	61fb      	str	r3, [r7, #28]
3419ed58:	69fb      	ldr	r3, [r7, #28]
3419ed5a:	2b00      	cmp	r3, #0
3419ed5c:	d1e1      	bne.n	3419ed22 <VD55G1_PollReg8+0x26>
  }

  VD55G1_dbg(ctx, 0, "current state %d\n", val);
3419ed5e:	7bfb      	ldrb	r3, [r7, #15]
3419ed60:	9301      	str	r3, [sp, #4]
3419ed62:	f240 132b 	movw	r3, #299	@ 0x12b
3419ed66:	9300      	str	r3, [sp, #0]
3419ed68:	2300      	movs	r3, #0
3419ed6a:	4a05      	ldr	r2, [pc, #20]	@ (3419ed80 <VD55G1_PollReg8+0x84>)
3419ed6c:	2103      	movs	r1, #3
3419ed6e:	6878      	ldr	r0, [r7, #4]
3419ed70:	f7ff ff7e 	bl	3419ec70 <VD55G1_log_impl>

  return -1;
3419ed74:	f04f 33ff 	mov.w	r3, #4294967295
}
3419ed78:	4618      	mov	r0, r3
3419ed7a:	3720      	adds	r7, #32
3419ed7c:	46bd      	mov	sp, r7
3419ed7e:	bd80      	pop	{r7, pc}
3419ed80:	341a77e0 	.word	0x341a77e0

3419ed84 <VD55G1_IsStreaming>:

static int VD55G1_IsStreaming(VD55G1_Ctx_t *ctx)
{
3419ed84:	b580      	push	{r7, lr}
3419ed86:	b084      	sub	sp, #16
3419ed88:	af00      	add	r7, sp, #0
3419ed8a:	6078      	str	r0, [r7, #4]
  uint8_t state;
  int ret;

  ret = ctx->read8(ctx, VD55G1_REG_SYSTEM_FSM, &state);
3419ed8c:	687b      	ldr	r3, [r7, #4]
3419ed8e:	685b      	ldr	r3, [r3, #4]
3419ed90:	f107 020b 	add.w	r2, r7, #11
3419ed94:	211c      	movs	r1, #28
3419ed96:	6878      	ldr	r0, [r7, #4]
3419ed98:	4798      	blx	r3
3419ed9a:	60f8      	str	r0, [r7, #12]
  if (ret)
3419ed9c:	68fb      	ldr	r3, [r7, #12]
3419ed9e:	2b00      	cmp	r3, #0
3419eda0:	d001      	beq.n	3419eda6 <VD55G1_IsStreaming+0x22>
    return ret;
3419eda2:	68fb      	ldr	r3, [r7, #12]
3419eda4:	e005      	b.n	3419edb2 <VD55G1_IsStreaming+0x2e>

  return state == VD55G1_SYSTEM_FSM_STREAMING;
3419eda6:	7afb      	ldrb	r3, [r7, #11]
3419eda8:	2b03      	cmp	r3, #3
3419edaa:	bf0c      	ite	eq
3419edac:	2301      	moveq	r3, #1
3419edae:	2300      	movne	r3, #0
3419edb0:	b2db      	uxtb	r3, r3
}
3419edb2:	4618      	mov	r0, r3
3419edb4:	3710      	adds	r7, #16
3419edb6:	46bd      	mov	sp, r7
3419edb8:	bd80      	pop	{r7, pc}
	...

3419edbc <VD55G1_WaitState>:

static int VD55G1_WaitState(VD55G1_Ctx_t *ctx, int state)
{
3419edbc:	b580      	push	{r7, lr}
3419edbe:	b086      	sub	sp, #24
3419edc0:	af02      	add	r7, sp, #8
3419edc2:	6078      	str	r0, [r7, #4]
3419edc4:	6039      	str	r1, [r7, #0]
  int ret = VD55G1_PollReg8(ctx, VD55G1_REG_SYSTEM_FSM, state);
3419edc6:	683b      	ldr	r3, [r7, #0]
3419edc8:	b2db      	uxtb	r3, r3
3419edca:	461a      	mov	r2, r3
3419edcc:	211c      	movs	r1, #28
3419edce:	6878      	ldr	r0, [r7, #4]
3419edd0:	f7ff ff94 	bl	3419ecfc <VD55G1_PollReg8>
3419edd4:	60f8      	str	r0, [r7, #12]

  if (ret)
3419edd6:	68fb      	ldr	r3, [r7, #12]
3419edd8:	2b00      	cmp	r3, #0
3419edda:	d009      	beq.n	3419edf0 <VD55G1_WaitState+0x34>
    VD55G1_warn(ctx, "Unable to reach state %d\n", state);
3419eddc:	683b      	ldr	r3, [r7, #0]
3419edde:	9300      	str	r3, [sp, #0]
3419ede0:	f240 1341 	movw	r3, #321	@ 0x141
3419ede4:	4a0a      	ldr	r2, [pc, #40]	@ (3419ee10 <VD55G1_WaitState+0x54>)
3419ede6:	2101      	movs	r1, #1
3419ede8:	6878      	ldr	r0, [r7, #4]
3419edea:	f7ff ff41 	bl	3419ec70 <VD55G1_log_impl>
3419edee:	e00a      	b.n	3419ee06 <VD55G1_WaitState+0x4a>
  else
    VD55G1_dbg(ctx, 0, "reach state %d\n", state);
3419edf0:	683b      	ldr	r3, [r7, #0]
3419edf2:	9301      	str	r3, [sp, #4]
3419edf4:	f240 1343 	movw	r3, #323	@ 0x143
3419edf8:	9300      	str	r3, [sp, #0]
3419edfa:	2300      	movs	r3, #0
3419edfc:	4a05      	ldr	r2, [pc, #20]	@ (3419ee14 <VD55G1_WaitState+0x58>)
3419edfe:	2103      	movs	r1, #3
3419ee00:	6878      	ldr	r0, [r7, #4]
3419ee02:	f7ff ff35 	bl	3419ec70 <VD55G1_log_impl>

  return ret;
3419ee06:	68fb      	ldr	r3, [r7, #12]
}
3419ee08:	4618      	mov	r0, r3
3419ee0a:	3710      	adds	r7, #16
3419ee0c:	46bd      	mov	sp, r7
3419ee0e:	bd80      	pop	{r7, pc}
3419ee10:	341a7804 	.word	0x341a7804
3419ee14:	341a7830 	.word	0x341a7830

3419ee18 <VD55G1_CheckModelId>:

static int VD55G1_CheckModelId(VD55G1_Ctx_t *ctx)
{
3419ee18:	b580      	push	{r7, lr}
3419ee1a:	b08a      	sub	sp, #40	@ 0x28
3419ee1c:	af04      	add	r7, sp, #16
3419ee1e:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419ee20:	687b      	ldr	r3, [r7, #4]
3419ee22:	3328      	adds	r3, #40	@ 0x28
3419ee24:	617b      	str	r3, [r7, #20]
  uint32_t reg32;
  uint16_t reg16;
  int ret;

  ret = ctx->read32(ctx, VD55G1_REG_MODEL_ID, &reg32);
3419ee26:	687b      	ldr	r3, [r7, #4]
3419ee28:	68db      	ldr	r3, [r3, #12]
3419ee2a:	f107 020c 	add.w	r2, r7, #12
3419ee2e:	2100      	movs	r1, #0
3419ee30:	6878      	ldr	r0, [r7, #4]
3419ee32:	4798      	blx	r3
3419ee34:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419ee36:	693b      	ldr	r3, [r7, #16]
3419ee38:	2b00      	cmp	r3, #0
3419ee3a:	d00d      	beq.n	3419ee58 <VD55G1_CheckModelId+0x40>
3419ee3c:	693b      	ldr	r3, [r7, #16]
3419ee3e:	9302      	str	r3, [sp, #8]
3419ee40:	f44f 73a8 	mov.w	r3, #336	@ 0x150
3419ee44:	9301      	str	r3, [sp, #4]
3419ee46:	4b5a      	ldr	r3, [pc, #360]	@ (3419efb0 <VD55G1_CheckModelId+0x198>)
3419ee48:	9300      	str	r3, [sp, #0]
3419ee4a:	f44f 73a8 	mov.w	r3, #336	@ 0x150
3419ee4e:	4a59      	ldr	r2, [pc, #356]	@ (3419efb4 <VD55G1_CheckModelId+0x19c>)
3419ee50:	2100      	movs	r1, #0
3419ee52:	6878      	ldr	r0, [r7, #4]
3419ee54:	f7ff ff0c 	bl	3419ec70 <VD55G1_log_impl>
3419ee58:	693b      	ldr	r3, [r7, #16]
3419ee5a:	2b00      	cmp	r3, #0
3419ee5c:	d002      	beq.n	3419ee64 <VD55G1_CheckModelId+0x4c>
3419ee5e:	6878      	ldr	r0, [r7, #4]
3419ee60:	f7ff ff22 	bl	3419eca8 <display_error>
3419ee64:	693b      	ldr	r3, [r7, #16]
3419ee66:	2b00      	cmp	r3, #0
3419ee68:	d001      	beq.n	3419ee6e <VD55G1_CheckModelId+0x56>
3419ee6a:	693b      	ldr	r3, [r7, #16]
3419ee6c:	e09b      	b.n	3419efa6 <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "model_id = 0x%04x\n", reg32);
3419ee6e:	68fb      	ldr	r3, [r7, #12]
3419ee70:	9301      	str	r3, [sp, #4]
3419ee72:	f240 1351 	movw	r3, #337	@ 0x151
3419ee76:	9300      	str	r3, [sp, #0]
3419ee78:	2300      	movs	r3, #0
3419ee7a:	4a4f      	ldr	r2, [pc, #316]	@ (3419efb8 <VD55G1_CheckModelId+0x1a0>)
3419ee7c:	2103      	movs	r1, #3
3419ee7e:	6878      	ldr	r0, [r7, #4]
3419ee80:	f7ff fef6 	bl	3419ec70 <VD55G1_log_impl>
  if (reg32 != VD55G1_MODEL_ID) {
3419ee84:	68fb      	ldr	r3, [r7, #12]
3419ee86:	4a4d      	ldr	r2, [pc, #308]	@ (3419efbc <VD55G1_CheckModelId+0x1a4>)
3419ee88:	4293      	cmp	r3, r2
3419ee8a:	d00d      	beq.n	3419eea8 <VD55G1_CheckModelId+0x90>
    VD55G1_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD55G1_MODEL_ID, reg32);
3419ee8c:	68fb      	ldr	r3, [r7, #12]
3419ee8e:	9301      	str	r3, [sp, #4]
3419ee90:	4b4a      	ldr	r3, [pc, #296]	@ (3419efbc <VD55G1_CheckModelId+0x1a4>)
3419ee92:	9300      	str	r3, [sp, #0]
3419ee94:	f240 1353 	movw	r3, #339	@ 0x153
3419ee98:	4a49      	ldr	r2, [pc, #292]	@ (3419efc0 <VD55G1_CheckModelId+0x1a8>)
3419ee9a:	2100      	movs	r1, #0
3419ee9c:	6878      	ldr	r0, [r7, #4]
3419ee9e:	f7ff fee7 	bl	3419ec70 <VD55G1_log_impl>
    return -1;
3419eea2:	f04f 33ff 	mov.w	r3, #4294967295
3419eea6:	e07e      	b.n	3419efa6 <VD55G1_CheckModelId+0x18e>
  }

  ret = ctx->read16(ctx, VD55G1_REG_REVISION, &reg16);
3419eea8:	687b      	ldr	r3, [r7, #4]
3419eeaa:	689b      	ldr	r3, [r3, #8]
3419eeac:	f107 020a 	add.w	r2, r7, #10
3419eeb0:	2104      	movs	r1, #4
3419eeb2:	6878      	ldr	r0, [r7, #4]
3419eeb4:	4798      	blx	r3
3419eeb6:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419eeb8:	693b      	ldr	r3, [r7, #16]
3419eeba:	2b00      	cmp	r3, #0
3419eebc:	d00d      	beq.n	3419eeda <VD55G1_CheckModelId+0xc2>
3419eebe:	693b      	ldr	r3, [r7, #16]
3419eec0:	9302      	str	r3, [sp, #8]
3419eec2:	f44f 73ac 	mov.w	r3, #344	@ 0x158
3419eec6:	9301      	str	r3, [sp, #4]
3419eec8:	4b39      	ldr	r3, [pc, #228]	@ (3419efb0 <VD55G1_CheckModelId+0x198>)
3419eeca:	9300      	str	r3, [sp, #0]
3419eecc:	f44f 73ac 	mov.w	r3, #344	@ 0x158
3419eed0:	4a38      	ldr	r2, [pc, #224]	@ (3419efb4 <VD55G1_CheckModelId+0x19c>)
3419eed2:	2100      	movs	r1, #0
3419eed4:	6878      	ldr	r0, [r7, #4]
3419eed6:	f7ff fecb 	bl	3419ec70 <VD55G1_log_impl>
3419eeda:	693b      	ldr	r3, [r7, #16]
3419eedc:	2b00      	cmp	r3, #0
3419eede:	d002      	beq.n	3419eee6 <VD55G1_CheckModelId+0xce>
3419eee0:	6878      	ldr	r0, [r7, #4]
3419eee2:	f7ff fee1 	bl	3419eca8 <display_error>
3419eee6:	693b      	ldr	r3, [r7, #16]
3419eee8:	2b00      	cmp	r3, #0
3419eeea:	d001      	beq.n	3419eef0 <VD55G1_CheckModelId+0xd8>
3419eeec:	693b      	ldr	r3, [r7, #16]
3419eeee:	e05a      	b.n	3419efa6 <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
3419eef0:	897b      	ldrh	r3, [r7, #10]
3419eef2:	9301      	str	r3, [sp, #4]
3419eef4:	f240 1359 	movw	r3, #345	@ 0x159
3419eef8:	9300      	str	r3, [sp, #0]
3419eefa:	2300      	movs	r3, #0
3419eefc:	4a31      	ldr	r2, [pc, #196]	@ (3419efc4 <VD55G1_CheckModelId+0x1ac>)
3419eefe:	2103      	movs	r1, #3
3419ef00:	6878      	ldr	r0, [r7, #4]
3419ef02:	f7ff feb5 	bl	3419ec70 <VD55G1_log_impl>
  switch (reg16) {
3419ef06:	897b      	ldrh	r3, [r7, #10]
3419ef08:	f241 0210 	movw	r2, #4112	@ 0x1010
3419ef0c:	4293      	cmp	r3, r2
3419ef0e:	d004      	beq.n	3419ef1a <VD55G1_CheckModelId+0x102>
3419ef10:	f242 0220 	movw	r2, #8224	@ 0x2020
3419ef14:	4293      	cmp	r3, r2
3419ef16:	d005      	beq.n	3419ef24 <VD55G1_CheckModelId+0x10c>
3419ef18:	e009      	b.n	3419ef2e <VD55G1_CheckModelId+0x116>
  case VD55G1_REVISION_CUT_1:
    drv_ctx->cut_version = VD55G1_REVISION_CUT_1;
3419ef1a:	697b      	ldr	r3, [r7, #20]
3419ef1c:	f241 0210 	movw	r2, #4112	@ 0x1010
3419ef20:	605a      	str	r2, [r3, #4]
    break;
3419ef22:	e010      	b.n	3419ef46 <VD55G1_CheckModelId+0x12e>
  case VD55G1_REVISION_CUT_2:
    drv_ctx->cut_version = VD55G1_REVISION_CUT_2;
3419ef24:	697b      	ldr	r3, [r7, #20]
3419ef26:	f242 0220 	movw	r2, #8224	@ 0x2020
3419ef2a:	605a      	str	r2, [r3, #4]
    break;
3419ef2c:	e00b      	b.n	3419ef46 <VD55G1_CheckModelId+0x12e>
  default:
    VD55G1_error(ctx, "Unsupported revision0x%04x\n", reg16);
3419ef2e:	897b      	ldrh	r3, [r7, #10]
3419ef30:	9300      	str	r3, [sp, #0]
3419ef32:	f44f 73b1 	mov.w	r3, #354	@ 0x162
3419ef36:	4a24      	ldr	r2, [pc, #144]	@ (3419efc8 <VD55G1_CheckModelId+0x1b0>)
3419ef38:	2100      	movs	r1, #0
3419ef3a:	6878      	ldr	r0, [r7, #4]
3419ef3c:	f7ff fe98 	bl	3419ec70 <VD55G1_log_impl>
    return -1;
3419ef40:	f04f 33ff 	mov.w	r3, #4294967295
3419ef44:	e02f      	b.n	3419efa6 <VD55G1_CheckModelId+0x18e>
  }

  ret = ctx->read32(ctx, VD55G1_REG_ROM_REVISION, &reg32);
3419ef46:	687b      	ldr	r3, [r7, #4]
3419ef48:	68db      	ldr	r3, [r3, #12]
3419ef4a:	f107 020c 	add.w	r2, r7, #12
3419ef4e:	2108      	movs	r1, #8
3419ef50:	6878      	ldr	r0, [r7, #4]
3419ef52:	4798      	blx	r3
3419ef54:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419ef56:	693b      	ldr	r3, [r7, #16]
3419ef58:	2b00      	cmp	r3, #0
3419ef5a:	d00d      	beq.n	3419ef78 <VD55G1_CheckModelId+0x160>
3419ef5c:	693b      	ldr	r3, [r7, #16]
3419ef5e:	9302      	str	r3, [sp, #8]
3419ef60:	f240 1367 	movw	r3, #359	@ 0x167
3419ef64:	9301      	str	r3, [sp, #4]
3419ef66:	4b12      	ldr	r3, [pc, #72]	@ (3419efb0 <VD55G1_CheckModelId+0x198>)
3419ef68:	9300      	str	r3, [sp, #0]
3419ef6a:	f240 1367 	movw	r3, #359	@ 0x167
3419ef6e:	4a11      	ldr	r2, [pc, #68]	@ (3419efb4 <VD55G1_CheckModelId+0x19c>)
3419ef70:	2100      	movs	r1, #0
3419ef72:	6878      	ldr	r0, [r7, #4]
3419ef74:	f7ff fe7c 	bl	3419ec70 <VD55G1_log_impl>
3419ef78:	693b      	ldr	r3, [r7, #16]
3419ef7a:	2b00      	cmp	r3, #0
3419ef7c:	d002      	beq.n	3419ef84 <VD55G1_CheckModelId+0x16c>
3419ef7e:	6878      	ldr	r0, [r7, #4]
3419ef80:	f7ff fe92 	bl	3419eca8 <display_error>
3419ef84:	693b      	ldr	r3, [r7, #16]
3419ef86:	2b00      	cmp	r3, #0
3419ef88:	d001      	beq.n	3419ef8e <VD55G1_CheckModelId+0x176>
3419ef8a:	693b      	ldr	r3, [r7, #16]
3419ef8c:	e00b      	b.n	3419efa6 <VD55G1_CheckModelId+0x18e>
  VD55G1_dbg(ctx, 0, "rom = 0x%04x\n", reg32);
3419ef8e:	68fb      	ldr	r3, [r7, #12]
3419ef90:	9301      	str	r3, [sp, #4]
3419ef92:	f44f 73b4 	mov.w	r3, #360	@ 0x168
3419ef96:	9300      	str	r3, [sp, #0]
3419ef98:	2300      	movs	r3, #0
3419ef9a:	4a0c      	ldr	r2, [pc, #48]	@ (3419efcc <VD55G1_CheckModelId+0x1b4>)
3419ef9c:	2103      	movs	r1, #3
3419ef9e:	6878      	ldr	r0, [r7, #4]
3419efa0:	f7ff fe66 	bl	3419ec70 <VD55G1_log_impl>

  return 0;
3419efa4:	2300      	movs	r3, #0
}
3419efa6:	4618      	mov	r0, r3
3419efa8:	3718      	adds	r7, #24
3419efaa:	46bd      	mov	sp, r7
3419efac:	bd80      	pop	{r7, pc}
3419efae:	bf00      	nop
3419efb0:	341a9ef0 	.word	0x341a9ef0
3419efb4:	341a77b8 	.word	0x341a77b8
3419efb8:	341a7854 	.word	0x341a7854
3419efbc:	53354731 	.word	0x53354731
3419efc0:	341a7878 	.word	0x341a7878
3419efc4:	341a78b4 	.word	0x341a78b4
3419efc8:	341a78d8 	.word	0x341a78d8
3419efcc:	341a7904 	.word	0x341a7904

3419efd0 <VD55G1_ApplyPatchCommon>:

static int VD55G1_ApplyPatchCommon(VD55G1_Ctx_t *ctx, uint8_t *patch_array, int patch_len, uint8_t patch_major,
                                   uint8_t patch_minor)
{
3419efd0:	b590      	push	{r4, r7, lr}
3419efd2:	b08b      	sub	sp, #44	@ 0x2c
3419efd4:	af04      	add	r7, sp, #16
3419efd6:	60f8      	str	r0, [r7, #12]
3419efd8:	60b9      	str	r1, [r7, #8]
3419efda:	607a      	str	r2, [r7, #4]
3419efdc:	70fb      	strb	r3, [r7, #3]
  uint16_t reg16;
  int ret;

  ret = ctx->write_array(ctx, VD55G1_REG_FWPATCH_START_ADDR, patch_array, patch_len);
3419efde:	68fb      	ldr	r3, [r7, #12]
3419efe0:	69dc      	ldr	r4, [r3, #28]
3419efe2:	687b      	ldr	r3, [r7, #4]
3419efe4:	68ba      	ldr	r2, [r7, #8]
3419efe6:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
3419efea:	68f8      	ldr	r0, [r7, #12]
3419efec:	47a0      	blx	r4
3419efee:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419eff0:	697b      	ldr	r3, [r7, #20]
3419eff2:	2b00      	cmp	r3, #0
3419eff4:	d00d      	beq.n	3419f012 <VD55G1_ApplyPatchCommon+0x42>
3419eff6:	697b      	ldr	r3, [r7, #20]
3419eff8:	9302      	str	r3, [sp, #8]
3419effa:	f44f 73ba 	mov.w	r3, #372	@ 0x174
3419effe:	9301      	str	r3, [sp, #4]
3419f000:	4b72      	ldr	r3, [pc, #456]	@ (3419f1cc <VD55G1_ApplyPatchCommon+0x1fc>)
3419f002:	9300      	str	r3, [sp, #0]
3419f004:	f44f 73ba 	mov.w	r3, #372	@ 0x174
3419f008:	4a71      	ldr	r2, [pc, #452]	@ (3419f1d0 <VD55G1_ApplyPatchCommon+0x200>)
3419f00a:	2100      	movs	r1, #0
3419f00c:	68f8      	ldr	r0, [r7, #12]
3419f00e:	f7ff fe2f 	bl	3419ec70 <VD55G1_log_impl>
3419f012:	697b      	ldr	r3, [r7, #20]
3419f014:	2b00      	cmp	r3, #0
3419f016:	d002      	beq.n	3419f01e <VD55G1_ApplyPatchCommon+0x4e>
3419f018:	68f8      	ldr	r0, [r7, #12]
3419f01a:	f7ff fe45 	bl	3419eca8 <display_error>
3419f01e:	697b      	ldr	r3, [r7, #20]
3419f020:	2b00      	cmp	r3, #0
3419f022:	d001      	beq.n	3419f028 <VD55G1_ApplyPatchCommon+0x58>
3419f024:	697b      	ldr	r3, [r7, #20]
3419f026:	e0cd      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>

  ret = ctx->write8(ctx, VD55G1_REG_BOOT, VD55G1_BOOT_PATCH_AND_BOOT);
3419f028:	68fb      	ldr	r3, [r7, #12]
3419f02a:	691b      	ldr	r3, [r3, #16]
3419f02c:	2202      	movs	r2, #2
3419f02e:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f032:	68f8      	ldr	r0, [r7, #12]
3419f034:	4798      	blx	r3
3419f036:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419f038:	697b      	ldr	r3, [r7, #20]
3419f03a:	2b00      	cmp	r3, #0
3419f03c:	d00d      	beq.n	3419f05a <VD55G1_ApplyPatchCommon+0x8a>
3419f03e:	697b      	ldr	r3, [r7, #20]
3419f040:	9302      	str	r3, [sp, #8]
3419f042:	f240 1377 	movw	r3, #375	@ 0x177
3419f046:	9301      	str	r3, [sp, #4]
3419f048:	4b60      	ldr	r3, [pc, #384]	@ (3419f1cc <VD55G1_ApplyPatchCommon+0x1fc>)
3419f04a:	9300      	str	r3, [sp, #0]
3419f04c:	f240 1377 	movw	r3, #375	@ 0x177
3419f050:	4a5f      	ldr	r2, [pc, #380]	@ (3419f1d0 <VD55G1_ApplyPatchCommon+0x200>)
3419f052:	2100      	movs	r1, #0
3419f054:	68f8      	ldr	r0, [r7, #12]
3419f056:	f7ff fe0b 	bl	3419ec70 <VD55G1_log_impl>
3419f05a:	697b      	ldr	r3, [r7, #20]
3419f05c:	2b00      	cmp	r3, #0
3419f05e:	d002      	beq.n	3419f066 <VD55G1_ApplyPatchCommon+0x96>
3419f060:	68f8      	ldr	r0, [r7, #12]
3419f062:	f7ff fe21 	bl	3419eca8 <display_error>
3419f066:	697b      	ldr	r3, [r7, #20]
3419f068:	2b00      	cmp	r3, #0
3419f06a:	d001      	beq.n	3419f070 <VD55G1_ApplyPatchCommon+0xa0>
3419f06c:	697b      	ldr	r3, [r7, #20]
3419f06e:	e0a9      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_BOOT, VD55G1_CMD_ACK);
3419f070:	2200      	movs	r2, #0
3419f072:	f44f 7100 	mov.w	r1, #512	@ 0x200
3419f076:	68f8      	ldr	r0, [r7, #12]
3419f078:	f7ff fe40 	bl	3419ecfc <VD55G1_PollReg8>
3419f07c:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419f07e:	697b      	ldr	r3, [r7, #20]
3419f080:	2b00      	cmp	r3, #0
3419f082:	d00d      	beq.n	3419f0a0 <VD55G1_ApplyPatchCommon+0xd0>
3419f084:	697b      	ldr	r3, [r7, #20]
3419f086:	9302      	str	r3, [sp, #8]
3419f088:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3419f08c:	9301      	str	r3, [sp, #4]
3419f08e:	4b4f      	ldr	r3, [pc, #316]	@ (3419f1cc <VD55G1_ApplyPatchCommon+0x1fc>)
3419f090:	9300      	str	r3, [sp, #0]
3419f092:	f44f 73bd 	mov.w	r3, #378	@ 0x17a
3419f096:	4a4e      	ldr	r2, [pc, #312]	@ (3419f1d0 <VD55G1_ApplyPatchCommon+0x200>)
3419f098:	2100      	movs	r1, #0
3419f09a:	68f8      	ldr	r0, [r7, #12]
3419f09c:	f7ff fde8 	bl	3419ec70 <VD55G1_log_impl>
3419f0a0:	697b      	ldr	r3, [r7, #20]
3419f0a2:	2b00      	cmp	r3, #0
3419f0a4:	d002      	beq.n	3419f0ac <VD55G1_ApplyPatchCommon+0xdc>
3419f0a6:	68f8      	ldr	r0, [r7, #12]
3419f0a8:	f7ff fdfe 	bl	3419eca8 <display_error>
3419f0ac:	697b      	ldr	r3, [r7, #20]
3419f0ae:	2b00      	cmp	r3, #0
3419f0b0:	d001      	beq.n	3419f0b6 <VD55G1_ApplyPatchCommon+0xe6>
3419f0b2:	697b      	ldr	r3, [r7, #20]
3419f0b4:	e086      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>

  ret = ctx->read16(ctx, VD55G1_REG_FWPATCH_REVISION, &reg16);
3419f0b6:	68fb      	ldr	r3, [r7, #12]
3419f0b8:	689b      	ldr	r3, [r3, #8]
3419f0ba:	f107 0212 	add.w	r2, r7, #18
3419f0be:	2112      	movs	r1, #18
3419f0c0:	68f8      	ldr	r0, [r7, #12]
3419f0c2:	4798      	blx	r3
3419f0c4:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419f0c6:	697b      	ldr	r3, [r7, #20]
3419f0c8:	2b00      	cmp	r3, #0
3419f0ca:	d00d      	beq.n	3419f0e8 <VD55G1_ApplyPatchCommon+0x118>
3419f0cc:	697b      	ldr	r3, [r7, #20]
3419f0ce:	9302      	str	r3, [sp, #8]
3419f0d0:	f240 137d 	movw	r3, #381	@ 0x17d
3419f0d4:	9301      	str	r3, [sp, #4]
3419f0d6:	4b3d      	ldr	r3, [pc, #244]	@ (3419f1cc <VD55G1_ApplyPatchCommon+0x1fc>)
3419f0d8:	9300      	str	r3, [sp, #0]
3419f0da:	f240 137d 	movw	r3, #381	@ 0x17d
3419f0de:	4a3c      	ldr	r2, [pc, #240]	@ (3419f1d0 <VD55G1_ApplyPatchCommon+0x200>)
3419f0e0:	2100      	movs	r1, #0
3419f0e2:	68f8      	ldr	r0, [r7, #12]
3419f0e4:	f7ff fdc4 	bl	3419ec70 <VD55G1_log_impl>
3419f0e8:	697b      	ldr	r3, [r7, #20]
3419f0ea:	2b00      	cmp	r3, #0
3419f0ec:	d002      	beq.n	3419f0f4 <VD55G1_ApplyPatchCommon+0x124>
3419f0ee:	68f8      	ldr	r0, [r7, #12]
3419f0f0:	f7ff fdda 	bl	3419eca8 <display_error>
3419f0f4:	697b      	ldr	r3, [r7, #20]
3419f0f6:	2b00      	cmp	r3, #0
3419f0f8:	d001      	beq.n	3419f0fe <VD55G1_ApplyPatchCommon+0x12e>
3419f0fa:	697b      	ldr	r3, [r7, #20]
3419f0fc:	e062      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>
  VD55G1_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
3419f0fe:	8a7b      	ldrh	r3, [r7, #18]
3419f100:	9301      	str	r3, [sp, #4]
3419f102:	f44f 73bf 	mov.w	r3, #382	@ 0x17e
3419f106:	9300      	str	r3, [sp, #0]
3419f108:	2300      	movs	r3, #0
3419f10a:	4a32      	ldr	r2, [pc, #200]	@ (3419f1d4 <VD55G1_ApplyPatchCommon+0x204>)
3419f10c:	2103      	movs	r1, #3
3419f10e:	68f8      	ldr	r0, [r7, #12]
3419f110:	f7ff fdae 	bl	3419ec70 <VD55G1_log_impl>

  if (reg16 != (patch_major << 8) + patch_minor) {
3419f114:	8a7b      	ldrh	r3, [r7, #18]
3419f116:	4619      	mov	r1, r3
3419f118:	78fb      	ldrb	r3, [r7, #3]
3419f11a:	021a      	lsls	r2, r3, #8
3419f11c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
3419f120:	4413      	add	r3, r2
3419f122:	4299      	cmp	r1, r3
3419f124:	d016      	beq.n	3419f154 <VD55G1_ApplyPatchCommon+0x184>
    VD55G1_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor, reg16 >> 8, reg16 & 0xff);
3419f126:	78fb      	ldrb	r3, [r7, #3]
3419f128:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
3419f12c:	8a79      	ldrh	r1, [r7, #18]
3419f12e:	0a09      	lsrs	r1, r1, #8
3419f130:	b289      	uxth	r1, r1
3419f132:	4608      	mov	r0, r1
3419f134:	8a79      	ldrh	r1, [r7, #18]
3419f136:	b2c9      	uxtb	r1, r1
3419f138:	9103      	str	r1, [sp, #12]
3419f13a:	9002      	str	r0, [sp, #8]
3419f13c:	9201      	str	r2, [sp, #4]
3419f13e:	9300      	str	r3, [sp, #0]
3419f140:	f240 1381 	movw	r3, #385	@ 0x181
3419f144:	4a24      	ldr	r2, [pc, #144]	@ (3419f1d8 <VD55G1_ApplyPatchCommon+0x208>)
3419f146:	2100      	movs	r1, #0
3419f148:	68f8      	ldr	r0, [r7, #12]
3419f14a:	f7ff fd91 	bl	3419ec70 <VD55G1_log_impl>
    return -1;
3419f14e:	f04f 33ff 	mov.w	r3, #4294967295
3419f152:	e037      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>
  }
  VD55G1_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
3419f154:	8a7b      	ldrh	r3, [r7, #18]
3419f156:	0a1b      	lsrs	r3, r3, #8
3419f158:	b29b      	uxth	r3, r3
3419f15a:	461a      	mov	r2, r3
3419f15c:	8a7b      	ldrh	r3, [r7, #18]
3419f15e:	b2db      	uxtb	r3, r3
3419f160:	9301      	str	r3, [sp, #4]
3419f162:	9200      	str	r2, [sp, #0]
3419f164:	f44f 73c2 	mov.w	r3, #388	@ 0x184
3419f168:	4a1c      	ldr	r2, [pc, #112]	@ (3419f1dc <VD55G1_ApplyPatchCommon+0x20c>)
3419f16a:	2102      	movs	r1, #2
3419f16c:	68f8      	ldr	r0, [r7, #12]
3419f16e:	f7ff fd7f 	bl	3419ec70 <VD55G1_log_impl>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
3419f172:	2102      	movs	r1, #2
3419f174:	68f8      	ldr	r0, [r7, #12]
3419f176:	f7ff fe21 	bl	3419edbc <VD55G1_WaitState>
3419f17a:	6178      	str	r0, [r7, #20]
  VD55G1_TraceError(ctx, ret);
3419f17c:	697b      	ldr	r3, [r7, #20]
3419f17e:	2b00      	cmp	r3, #0
3419f180:	d00d      	beq.n	3419f19e <VD55G1_ApplyPatchCommon+0x1ce>
3419f182:	697b      	ldr	r3, [r7, #20]
3419f184:	9302      	str	r3, [sp, #8]
3419f186:	f240 1387 	movw	r3, #391	@ 0x187
3419f18a:	9301      	str	r3, [sp, #4]
3419f18c:	4b0f      	ldr	r3, [pc, #60]	@ (3419f1cc <VD55G1_ApplyPatchCommon+0x1fc>)
3419f18e:	9300      	str	r3, [sp, #0]
3419f190:	f240 1387 	movw	r3, #391	@ 0x187
3419f194:	4a0e      	ldr	r2, [pc, #56]	@ (3419f1d0 <VD55G1_ApplyPatchCommon+0x200>)
3419f196:	2100      	movs	r1, #0
3419f198:	68f8      	ldr	r0, [r7, #12]
3419f19a:	f7ff fd69 	bl	3419ec70 <VD55G1_log_impl>
3419f19e:	697b      	ldr	r3, [r7, #20]
3419f1a0:	2b00      	cmp	r3, #0
3419f1a2:	d002      	beq.n	3419f1aa <VD55G1_ApplyPatchCommon+0x1da>
3419f1a4:	68f8      	ldr	r0, [r7, #12]
3419f1a6:	f7ff fd7f 	bl	3419eca8 <display_error>
3419f1aa:	697b      	ldr	r3, [r7, #20]
3419f1ac:	2b00      	cmp	r3, #0
3419f1ae:	d001      	beq.n	3419f1b4 <VD55G1_ApplyPatchCommon+0x1e4>
3419f1b0:	697b      	ldr	r3, [r7, #20]
3419f1b2:	e007      	b.n	3419f1c4 <VD55G1_ApplyPatchCommon+0x1f4>

  VD55G1_notice(ctx, "sensor boot successfully\n");
3419f1b4:	f240 1389 	movw	r3, #393	@ 0x189
3419f1b8:	4a09      	ldr	r2, [pc, #36]	@ (3419f1e0 <VD55G1_ApplyPatchCommon+0x210>)
3419f1ba:	2102      	movs	r1, #2
3419f1bc:	68f8      	ldr	r0, [r7, #12]
3419f1be:	f7ff fd57 	bl	3419ec70 <VD55G1_log_impl>

  return 0;
3419f1c2:	2300      	movs	r3, #0
}
3419f1c4:	4618      	mov	r0, r3
3419f1c6:	371c      	adds	r7, #28
3419f1c8:	46bd      	mov	sp, r7
3419f1ca:	bd90      	pop	{r4, r7, pc}
3419f1cc:	341a9f04 	.word	0x341a9f04
3419f1d0:	341a77b8 	.word	0x341a77b8
3419f1d4:	341a7924 	.word	0x341a7924
3419f1d8:	341a7948 	.word	0x341a7948
3419f1dc:	341a7984 	.word	0x341a7984
3419f1e0:	341a79ac 	.word	0x341a79ac

3419f1e4 <VD55G1_ApplyPatch>:

static int VD55G1_ApplyPatch(VD55G1_Ctx_t *ctx)
{
3419f1e4:	b580      	push	{r7, lr}
3419f1e6:	b086      	sub	sp, #24
3419f1e8:	af02      	add	r7, sp, #8
3419f1ea:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f1ec:	687b      	ldr	r3, [r7, #4]
3419f1ee:	3328      	adds	r3, #40	@ 0x28
3419f1f0:	60fb      	str	r3, [r7, #12]

  switch (drv_ctx->cut_version) {
3419f1f2:	68fb      	ldr	r3, [r7, #12]
3419f1f4:	685b      	ldr	r3, [r3, #4]
3419f1f6:	f241 0210 	movw	r2, #4112	@ 0x1010
3419f1fa:	4293      	cmp	r3, r2
3419f1fc:	d004      	beq.n	3419f208 <VD55G1_ApplyPatch+0x24>
3419f1fe:	f242 0220 	movw	r2, #8224	@ 0x2020
3419f202:	4293      	cmp	r3, r2
3419f204:	d00b      	beq.n	3419f21e <VD55G1_ApplyPatch+0x3a>
3419f206:	e015      	b.n	3419f234 <VD55G1_ApplyPatch+0x50>
  case VD55G1_REVISION_CUT_1:
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_1, sizeof(patch_array_cut_1),
3419f208:	2316      	movs	r3, #22
3419f20a:	9300      	str	r3, [sp, #0]
3419f20c:	2301      	movs	r3, #1
3419f20e:	f241 22e4 	movw	r2, #4836	@ 0x12e4
3419f212:	490e      	ldr	r1, [pc, #56]	@ (3419f24c <VD55G1_ApplyPatch+0x68>)
3419f214:	6878      	ldr	r0, [r7, #4]
3419f216:	f7ff fedb 	bl	3419efd0 <VD55G1_ApplyPatchCommon>
3419f21a:	4603      	mov	r3, r0
3419f21c:	e011      	b.n	3419f242 <VD55G1_ApplyPatch+0x5e>
                                   VD55G1_FWPATCH_REVISION_MAJOR_CUT_1, VD55G1_FWPATCH_REVISION_MINOR_CUT_1);
  case VD55G1_REVISION_CUT_2:
    return VD55G1_ApplyPatchCommon(ctx, (uint8_t *) patch_array_cut_2, sizeof(patch_array_cut_2),
3419f21e:	2302      	movs	r3, #2
3419f220:	9300      	str	r3, [sp, #0]
3419f222:	2302      	movs	r3, #2
3419f224:	f44f 7272 	mov.w	r2, #968	@ 0x3c8
3419f228:	4909      	ldr	r1, [pc, #36]	@ (3419f250 <VD55G1_ApplyPatch+0x6c>)
3419f22a:	6878      	ldr	r0, [r7, #4]
3419f22c:	f7ff fed0 	bl	3419efd0 <VD55G1_ApplyPatchCommon>
3419f230:	4603      	mov	r3, r0
3419f232:	e006      	b.n	3419f242 <VD55G1_ApplyPatch+0x5e>
                                   VD55G1_FWPATCH_REVISION_MAJOR_CUT_2, VD55G1_FWPATCH_REVISION_MINOR_CUT_2);
  default:
    assert(0);
3419f234:	4b07      	ldr	r3, [pc, #28]	@ (3419f254 <VD55G1_ApplyPatch+0x70>)
3419f236:	4a08      	ldr	r2, [pc, #32]	@ (3419f258 <VD55G1_ApplyPatch+0x74>)
3419f238:	f44f 71cd 	mov.w	r1, #410	@ 0x19a
3419f23c:	4807      	ldr	r0, [pc, #28]	@ (3419f25c <VD55G1_ApplyPatch+0x78>)
3419f23e:	f005 fecd 	bl	341a4fdc <__assert_func>
  }

  return -1;
}
3419f242:	4618      	mov	r0, r3
3419f244:	3710      	adds	r7, #16
3419f246:	46bd      	mov	sp, r7
3419f248:	bd80      	pop	{r7, pc}
3419f24a:	bf00      	nop
3419f24c:	341a87c4 	.word	0x341a87c4
3419f250:	341a9aa8 	.word	0x341a9aa8
3419f254:	341a79d8 	.word	0x341a79d8
3419f258:	341a9f1c 	.word	0x341a9f1c
3419f25c:	341a7754 	.word	0x341a7754

3419f260 <VD55G1_Gpios>:

static int VD55G1_Gpios(VD55G1_Ctx_t *ctx)
 {
3419f260:	b580      	push	{r7, lr}
3419f262:	b08a      	sub	sp, #40	@ 0x28
3419f264:	af04      	add	r7, sp, #16
3419f266:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f268:	687b      	ldr	r3, [r7, #4]
3419f26a:	3328      	adds	r3, #40	@ 0x28
3419f26c:	613b      	str	r3, [r7, #16]
  int ret;
  int i;

  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3419f26e:	2300      	movs	r3, #0
3419f270:	617b      	str	r3, [r7, #20]
3419f272:	e02e      	b.n	3419f2d2 <VD55G1_Gpios+0x72>
  {
    ret = ctx->write8(ctx, VD55G1_REG_GPIO_x(i), drv_ctx->config_save.gpio_ctrl[i]);
3419f274:	687b      	ldr	r3, [r7, #4]
3419f276:	691b      	ldr	r3, [r3, #16]
3419f278:	697a      	ldr	r2, [r7, #20]
3419f27a:	b292      	uxth	r2, r2
3419f27c:	f202 521d 	addw	r2, r2, #1309	@ 0x51d
3419f280:	b290      	uxth	r0, r2
3419f282:	6939      	ldr	r1, [r7, #16]
3419f284:	697a      	ldr	r2, [r7, #20]
3419f286:	440a      	add	r2, r1
3419f288:	323c      	adds	r2, #60	@ 0x3c
3419f28a:	7812      	ldrb	r2, [r2, #0]
3419f28c:	4601      	mov	r1, r0
3419f28e:	6878      	ldr	r0, [r7, #4]
3419f290:	4798      	blx	r3
3419f292:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419f294:	68fb      	ldr	r3, [r7, #12]
3419f296:	2b00      	cmp	r3, #0
3419f298:	d00d      	beq.n	3419f2b6 <VD55G1_Gpios+0x56>
3419f29a:	68fb      	ldr	r3, [r7, #12]
3419f29c:	9302      	str	r3, [sp, #8]
3419f29e:	f240 13a9 	movw	r3, #425	@ 0x1a9
3419f2a2:	9301      	str	r3, [sp, #4]
3419f2a4:	4b0f      	ldr	r3, [pc, #60]	@ (3419f2e4 <VD55G1_Gpios+0x84>)
3419f2a6:	9300      	str	r3, [sp, #0]
3419f2a8:	f240 13a9 	movw	r3, #425	@ 0x1a9
3419f2ac:	4a0e      	ldr	r2, [pc, #56]	@ (3419f2e8 <VD55G1_Gpios+0x88>)
3419f2ae:	2100      	movs	r1, #0
3419f2b0:	6878      	ldr	r0, [r7, #4]
3419f2b2:	f7ff fcdd 	bl	3419ec70 <VD55G1_log_impl>
3419f2b6:	68fb      	ldr	r3, [r7, #12]
3419f2b8:	2b00      	cmp	r3, #0
3419f2ba:	d002      	beq.n	3419f2c2 <VD55G1_Gpios+0x62>
3419f2bc:	6878      	ldr	r0, [r7, #4]
3419f2be:	f7ff fcf3 	bl	3419eca8 <display_error>
3419f2c2:	68fb      	ldr	r3, [r7, #12]
3419f2c4:	2b00      	cmp	r3, #0
3419f2c6:	d001      	beq.n	3419f2cc <VD55G1_Gpios+0x6c>
3419f2c8:	68fb      	ldr	r3, [r7, #12]
3419f2ca:	e006      	b.n	3419f2da <VD55G1_Gpios+0x7a>
  for (i = 0 ; i < VD55G1_GPIO_NB; i++)
3419f2cc:	697b      	ldr	r3, [r7, #20]
3419f2ce:	3301      	adds	r3, #1
3419f2d0:	617b      	str	r3, [r7, #20]
3419f2d2:	697b      	ldr	r3, [r7, #20]
3419f2d4:	2b03      	cmp	r3, #3
3419f2d6:	ddcd      	ble.n	3419f274 <VD55G1_Gpios+0x14>
  }

  return 0;
3419f2d8:	2300      	movs	r3, #0
}
3419f2da:	4618      	mov	r0, r3
3419f2dc:	3718      	adds	r7, #24
3419f2de:	46bd      	mov	sp, r7
3419f2e0:	bd80      	pop	{r7, pc}
3419f2e2:	bf00      	nop
3419f2e4:	341a9f30 	.word	0x341a9f30
3419f2e8:	341a77b8 	.word	0x341a77b8

3419f2ec <VD55G1_Boot>:

static int VD55G1_Boot(VD55G1_Ctx_t *ctx)
{
3419f2ec:	b580      	push	{r7, lr}
3419f2ee:	b084      	sub	sp, #16
3419f2f0:	af00      	add	r7, sp, #0
3419f2f2:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_READY_TO_BOOT);
3419f2f4:	2101      	movs	r1, #1
3419f2f6:	6878      	ldr	r0, [r7, #4]
3419f2f8:	f7ff fd60 	bl	3419edbc <VD55G1_WaitState>
3419f2fc:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f2fe:	68fb      	ldr	r3, [r7, #12]
3419f300:	2b00      	cmp	r3, #0
3419f302:	d001      	beq.n	3419f308 <VD55G1_Boot+0x1c>
    return ret;
3419f304:	68fb      	ldr	r3, [r7, #12]
3419f306:	e01b      	b.n	3419f340 <VD55G1_Boot+0x54>

  ret = VD55G1_CheckModelId(ctx);
3419f308:	6878      	ldr	r0, [r7, #4]
3419f30a:	f7ff fd85 	bl	3419ee18 <VD55G1_CheckModelId>
3419f30e:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f310:	68fb      	ldr	r3, [r7, #12]
3419f312:	2b00      	cmp	r3, #0
3419f314:	d001      	beq.n	3419f31a <VD55G1_Boot+0x2e>
    return ret;
3419f316:	68fb      	ldr	r3, [r7, #12]
3419f318:	e012      	b.n	3419f340 <VD55G1_Boot+0x54>

  ret = VD55G1_ApplyPatch(ctx);
3419f31a:	6878      	ldr	r0, [r7, #4]
3419f31c:	f7ff ff62 	bl	3419f1e4 <VD55G1_ApplyPatch>
3419f320:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f322:	68fb      	ldr	r3, [r7, #12]
3419f324:	2b00      	cmp	r3, #0
3419f326:	d001      	beq.n	3419f32c <VD55G1_Boot+0x40>
    return ret;
3419f328:	68fb      	ldr	r3, [r7, #12]
3419f32a:	e009      	b.n	3419f340 <VD55G1_Boot+0x54>

  ret = VD55G1_Gpios(ctx);
3419f32c:	6878      	ldr	r0, [r7, #4]
3419f32e:	f7ff ff97 	bl	3419f260 <VD55G1_Gpios>
3419f332:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f334:	68fb      	ldr	r3, [r7, #12]
3419f336:	2b00      	cmp	r3, #0
3419f338:	d001      	beq.n	3419f33e <VD55G1_Boot+0x52>
    return ret;
3419f33a:	68fb      	ldr	r3, [r7, #12]
3419f33c:	e000      	b.n	3419f340 <VD55G1_Boot+0x54>

  return 0;
3419f33e:	2300      	movs	r3, #0
}
3419f340:	4618      	mov	r0, r3
3419f342:	3710      	adds	r7, #16
3419f344:	46bd      	mov	sp, r7
3419f346:	bd80      	pop	{r7, pc}

3419f348 <VD55G1_GetSystemClock>:

static uint32_t VD55G1_GetSystemClock(VD55G1_Ctx_t *ctx)
{
3419f348:	b580      	push	{r7, lr}
3419f34a:	b084      	sub	sp, #16
3419f34c:	af00      	add	r7, sp, #0
3419f34e:	6078      	str	r0, [r7, #4]
  uint32_t mipi_data_rate;
  int ret;

  ret = ctx->read32(ctx, VD55G1_REG_MIPI_DATA_RATE, &mipi_data_rate);
3419f350:	687b      	ldr	r3, [r7, #4]
3419f352:	68db      	ldr	r3, [r3, #12]
3419f354:	f107 0208 	add.w	r2, r7, #8
3419f358:	f44f 7109 	mov.w	r1, #548	@ 0x224
3419f35c:	6878      	ldr	r0, [r7, #4]
3419f35e:	4798      	blx	r3
3419f360:	60f8      	str	r0, [r7, #12]
  if (ret)
3419f362:	68fb      	ldr	r3, [r7, #12]
3419f364:	2b00      	cmp	r3, #0
3419f366:	d001      	beq.n	3419f36c <VD55G1_GetSystemClock+0x24>
    return 0;
3419f368:	2300      	movs	r3, #0
3419f36a:	e020      	b.n	3419f3ae <VD55G1_GetSystemClock+0x66>

  if (mipi_data_rate <= 1200000000 && mipi_data_rate > 600000000)
3419f36c:	68bb      	ldr	r3, [r7, #8]
3419f36e:	4a12      	ldr	r2, [pc, #72]	@ (3419f3b8 <VD55G1_GetSystemClock+0x70>)
3419f370:	4293      	cmp	r3, r2
3419f372:	d805      	bhi.n	3419f380 <VD55G1_GetSystemClock+0x38>
3419f374:	68bb      	ldr	r3, [r7, #8]
3419f376:	4a11      	ldr	r2, [pc, #68]	@ (3419f3bc <VD55G1_GetSystemClock+0x74>)
3419f378:	4293      	cmp	r3, r2
3419f37a:	d901      	bls.n	3419f380 <VD55G1_GetSystemClock+0x38>
    return mipi_data_rate;
3419f37c:	68bb      	ldr	r3, [r7, #8]
3419f37e:	e016      	b.n	3419f3ae <VD55G1_GetSystemClock+0x66>
  else if (mipi_data_rate <= 600000000 && mipi_data_rate > 300000000)
3419f380:	68bb      	ldr	r3, [r7, #8]
3419f382:	4a0e      	ldr	r2, [pc, #56]	@ (3419f3bc <VD55G1_GetSystemClock+0x74>)
3419f384:	4293      	cmp	r3, r2
3419f386:	d806      	bhi.n	3419f396 <VD55G1_GetSystemClock+0x4e>
3419f388:	68bb      	ldr	r3, [r7, #8]
3419f38a:	4a0d      	ldr	r2, [pc, #52]	@ (3419f3c0 <VD55G1_GetSystemClock+0x78>)
3419f38c:	4293      	cmp	r3, r2
3419f38e:	d902      	bls.n	3419f396 <VD55G1_GetSystemClock+0x4e>
    return mipi_data_rate * 2;
3419f390:	68bb      	ldr	r3, [r7, #8]
3419f392:	005b      	lsls	r3, r3, #1
3419f394:	e00b      	b.n	3419f3ae <VD55G1_GetSystemClock+0x66>
  else if (mipi_data_rate <= 300000000 && mipi_data_rate >= 250000000)
3419f396:	68bb      	ldr	r3, [r7, #8]
3419f398:	4a09      	ldr	r2, [pc, #36]	@ (3419f3c0 <VD55G1_GetSystemClock+0x78>)
3419f39a:	4293      	cmp	r3, r2
3419f39c:	d806      	bhi.n	3419f3ac <VD55G1_GetSystemClock+0x64>
3419f39e:	68bb      	ldr	r3, [r7, #8]
3419f3a0:	4a08      	ldr	r2, [pc, #32]	@ (3419f3c4 <VD55G1_GetSystemClock+0x7c>)
3419f3a2:	4293      	cmp	r3, r2
3419f3a4:	d902      	bls.n	3419f3ac <VD55G1_GetSystemClock+0x64>
    return mipi_data_rate * 4;
3419f3a6:	68bb      	ldr	r3, [r7, #8]
3419f3a8:	009b      	lsls	r3, r3, #2
3419f3aa:	e000      	b.n	3419f3ae <VD55G1_GetSystemClock+0x66>

  return 0;
3419f3ac:	2300      	movs	r3, #0
}
3419f3ae:	4618      	mov	r0, r3
3419f3b0:	3710      	adds	r7, #16
3419f3b2:	46bd      	mov	sp, r7
3419f3b4:	bd80      	pop	{r7, pc}
3419f3b6:	bf00      	nop
3419f3b8:	47868c00 	.word	0x47868c00
3419f3bc:	23c34600 	.word	0x23c34600
3419f3c0:	11e1a300 	.word	0x11e1a300
3419f3c4:	0ee6b27f 	.word	0x0ee6b27f

3419f3c8 <VD55G1_GetPixelClock>:

static uint32_t VD55G1_GetPixelClock(VD55G1_Ctx_t *ctx)
{
3419f3c8:	b580      	push	{r7, lr}
3419f3ca:	b084      	sub	sp, #16
3419f3cc:	af00      	add	r7, sp, #0
3419f3ce:	6078      	str	r0, [r7, #4]
  uint32_t system_clk;

  system_clk = VD55G1_GetSystemClock(ctx);
3419f3d0:	6878      	ldr	r0, [r7, #4]
3419f3d2:	f7ff ffb9 	bl	3419f348 <VD55G1_GetSystemClock>
3419f3d6:	60f8      	str	r0, [r7, #12]
  if (!system_clk)
3419f3d8:	68fb      	ldr	r3, [r7, #12]
3419f3da:	2b00      	cmp	r3, #0
3419f3dc:	d101      	bne.n	3419f3e2 <VD55G1_GetPixelClock+0x1a>
    return 0;
3419f3de:	2300      	movs	r3, #0
3419f3e0:	e027      	b.n	3419f432 <VD55G1_GetPixelClock+0x6a>

  if (system_clk <= 1200000000 && system_clk > 900000000)
3419f3e2:	68fb      	ldr	r3, [r7, #12]
3419f3e4:	4a15      	ldr	r2, [pc, #84]	@ (3419f43c <VD55G1_GetPixelClock+0x74>)
3419f3e6:	4293      	cmp	r3, r2
3419f3e8:	d806      	bhi.n	3419f3f8 <VD55G1_GetPixelClock+0x30>
3419f3ea:	68fb      	ldr	r3, [r7, #12]
3419f3ec:	4a14      	ldr	r2, [pc, #80]	@ (3419f440 <VD55G1_GetPixelClock+0x78>)
3419f3ee:	4293      	cmp	r3, r2
3419f3f0:	d902      	bls.n	3419f3f8 <VD55G1_GetPixelClock+0x30>
    return system_clk / 8;
3419f3f2:	68fb      	ldr	r3, [r7, #12]
3419f3f4:	08db      	lsrs	r3, r3, #3
3419f3f6:	e01c      	b.n	3419f432 <VD55G1_GetPixelClock+0x6a>
  else if (system_clk <= 900000000 && system_clk > 780000000)
3419f3f8:	68fb      	ldr	r3, [r7, #12]
3419f3fa:	4a11      	ldr	r2, [pc, #68]	@ (3419f440 <VD55G1_GetPixelClock+0x78>)
3419f3fc:	4293      	cmp	r3, r2
3419f3fe:	d809      	bhi.n	3419f414 <VD55G1_GetPixelClock+0x4c>
3419f400:	68fb      	ldr	r3, [r7, #12]
3419f402:	4a10      	ldr	r2, [pc, #64]	@ (3419f444 <VD55G1_GetPixelClock+0x7c>)
3419f404:	4293      	cmp	r3, r2
3419f406:	d905      	bls.n	3419f414 <VD55G1_GetPixelClock+0x4c>
    return system_clk / 6;
3419f408:	68fb      	ldr	r3, [r7, #12]
3419f40a:	4a0f      	ldr	r2, [pc, #60]	@ (3419f448 <VD55G1_GetPixelClock+0x80>)
3419f40c:	fba2 2303 	umull	r2, r3, r2, r3
3419f410:	089b      	lsrs	r3, r3, #2
3419f412:	e00e      	b.n	3419f432 <VD55G1_GetPixelClock+0x6a>
  else if (system_clk <= 780000000 && system_clk >= 600000000)
3419f414:	68fb      	ldr	r3, [r7, #12]
3419f416:	4a0b      	ldr	r2, [pc, #44]	@ (3419f444 <VD55G1_GetPixelClock+0x7c>)
3419f418:	4293      	cmp	r3, r2
3419f41a:	d809      	bhi.n	3419f430 <VD55G1_GetPixelClock+0x68>
3419f41c:	68fb      	ldr	r3, [r7, #12]
3419f41e:	4a0b      	ldr	r2, [pc, #44]	@ (3419f44c <VD55G1_GetPixelClock+0x84>)
3419f420:	4293      	cmp	r3, r2
3419f422:	d905      	bls.n	3419f430 <VD55G1_GetPixelClock+0x68>
    return system_clk / 5;
3419f424:	68fb      	ldr	r3, [r7, #12]
3419f426:	4a0a      	ldr	r2, [pc, #40]	@ (3419f450 <VD55G1_GetPixelClock+0x88>)
3419f428:	fba2 2303 	umull	r2, r3, r2, r3
3419f42c:	089b      	lsrs	r3, r3, #2
3419f42e:	e000      	b.n	3419f432 <VD55G1_GetPixelClock+0x6a>

  return 0;
3419f430:	2300      	movs	r3, #0
}
3419f432:	4618      	mov	r0, r3
3419f434:	3710      	adds	r7, #16
3419f436:	46bd      	mov	sp, r7
3419f438:	bd80      	pop	{r7, pc}
3419f43a:	bf00      	nop
3419f43c:	47868c00 	.word	0x47868c00
3419f440:	35a4e900 	.word	0x35a4e900
3419f444:	2e7ddb00 	.word	0x2e7ddb00
3419f448:	aaaaaaab 	.word	0xaaaaaaab
3419f44c:	23c345ff 	.word	0x23c345ff
3419f450:	cccccccd 	.word	0xcccccccd

3419f454 <VD55G1_SetupClocks>:

static int VD55G1_SetupClocks(VD55G1_Ctx_t *ctx)
{
3419f454:	b580      	push	{r7, lr}
3419f456:	b088      	sub	sp, #32
3419f458:	af04      	add	r7, sp, #16
3419f45a:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f45c:	687b      	ldr	r3, [r7, #4]
3419f45e:	3328      	adds	r3, #40	@ 0x28
3419f460:	60fb      	str	r3, [r7, #12]
  int ret;

  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
3419f462:	68fb      	ldr	r3, [r7, #12]
3419f464:	69db      	ldr	r3, [r3, #28]
3419f466:	4a33      	ldr	r2, [pc, #204]	@ (3419f534 <VD55G1_SetupClocks+0xe0>)
3419f468:	4293      	cmp	r3, r2
3419f46a:	dd04      	ble.n	3419f476 <VD55G1_SetupClocks+0x22>
      drv_ctx->config_save.out_itf.data_rate_in_mps > VD55G1_MAX_DATARATE)
3419f46c:	68fb      	ldr	r3, [r7, #12]
3419f46e:	69db      	ldr	r3, [r3, #28]
  if (drv_ctx->config_save.out_itf.data_rate_in_mps < VD55G1_MIN_DATARATE ||
3419f470:	4a31      	ldr	r2, [pc, #196]	@ (3419f538 <VD55G1_SetupClocks+0xe4>)
3419f472:	4293      	cmp	r3, r2
3419f474:	dd02      	ble.n	3419f47c <VD55G1_SetupClocks+0x28>
    return -1;
3419f476:	f04f 33ff 	mov.w	r3, #4294967295
3419f47a:	e057      	b.n	3419f52c <VD55G1_SetupClocks+0xd8>

  ret = ctx->write32(ctx, VD55G1_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
3419f47c:	687b      	ldr	r3, [r7, #4]
3419f47e:	699b      	ldr	r3, [r3, #24]
3419f480:	68fa      	ldr	r2, [r7, #12]
3419f482:	68d2      	ldr	r2, [r2, #12]
3419f484:	f44f 7108 	mov.w	r1, #544	@ 0x220
3419f488:	6878      	ldr	r0, [r7, #4]
3419f48a:	4798      	blx	r3
3419f48c:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419f48e:	68bb      	ldr	r3, [r7, #8]
3419f490:	2b00      	cmp	r3, #0
3419f492:	d00d      	beq.n	3419f4b0 <VD55G1_SetupClocks+0x5c>
3419f494:	68bb      	ldr	r3, [r7, #8]
3419f496:	9302      	str	r3, [sp, #8]
3419f498:	f240 13f5 	movw	r3, #501	@ 0x1f5
3419f49c:	9301      	str	r3, [sp, #4]
3419f49e:	4b27      	ldr	r3, [pc, #156]	@ (3419f53c <VD55G1_SetupClocks+0xe8>)
3419f4a0:	9300      	str	r3, [sp, #0]
3419f4a2:	f240 13f5 	movw	r3, #501	@ 0x1f5
3419f4a6:	4a26      	ldr	r2, [pc, #152]	@ (3419f540 <VD55G1_SetupClocks+0xec>)
3419f4a8:	2100      	movs	r1, #0
3419f4aa:	6878      	ldr	r0, [r7, #4]
3419f4ac:	f7ff fbe0 	bl	3419ec70 <VD55G1_log_impl>
3419f4b0:	68bb      	ldr	r3, [r7, #8]
3419f4b2:	2b00      	cmp	r3, #0
3419f4b4:	d002      	beq.n	3419f4bc <VD55G1_SetupClocks+0x68>
3419f4b6:	6878      	ldr	r0, [r7, #4]
3419f4b8:	f7ff fbf6 	bl	3419eca8 <display_error>
3419f4bc:	68bb      	ldr	r3, [r7, #8]
3419f4be:	2b00      	cmp	r3, #0
3419f4c0:	d001      	beq.n	3419f4c6 <VD55G1_SetupClocks+0x72>
3419f4c2:	68bb      	ldr	r3, [r7, #8]
3419f4c4:	e032      	b.n	3419f52c <VD55G1_SetupClocks+0xd8>

  ret = ctx->write32(ctx, VD55G1_REG_MIPI_DATA_RATE, drv_ctx->config_save.out_itf.data_rate_in_mps);
3419f4c6:	687b      	ldr	r3, [r7, #4]
3419f4c8:	699b      	ldr	r3, [r3, #24]
3419f4ca:	68fa      	ldr	r2, [r7, #12]
3419f4cc:	69d2      	ldr	r2, [r2, #28]
3419f4ce:	f44f 7109 	mov.w	r1, #548	@ 0x224
3419f4d2:	6878      	ldr	r0, [r7, #4]
3419f4d4:	4798      	blx	r3
3419f4d6:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419f4d8:	68bb      	ldr	r3, [r7, #8]
3419f4da:	2b00      	cmp	r3, #0
3419f4dc:	d00d      	beq.n	3419f4fa <VD55G1_SetupClocks+0xa6>
3419f4de:	68bb      	ldr	r3, [r7, #8]
3419f4e0:	9302      	str	r3, [sp, #8]
3419f4e2:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
3419f4e6:	9301      	str	r3, [sp, #4]
3419f4e8:	4b14      	ldr	r3, [pc, #80]	@ (3419f53c <VD55G1_SetupClocks+0xe8>)
3419f4ea:	9300      	str	r3, [sp, #0]
3419f4ec:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
3419f4f0:	4a13      	ldr	r2, [pc, #76]	@ (3419f540 <VD55G1_SetupClocks+0xec>)
3419f4f2:	2100      	movs	r1, #0
3419f4f4:	6878      	ldr	r0, [r7, #4]
3419f4f6:	f7ff fbbb 	bl	3419ec70 <VD55G1_log_impl>
3419f4fa:	68bb      	ldr	r3, [r7, #8]
3419f4fc:	2b00      	cmp	r3, #0
3419f4fe:	d002      	beq.n	3419f506 <VD55G1_SetupClocks+0xb2>
3419f500:	6878      	ldr	r0, [r7, #4]
3419f502:	f7ff fbd1 	bl	3419eca8 <display_error>
3419f506:	68bb      	ldr	r3, [r7, #8]
3419f508:	2b00      	cmp	r3, #0
3419f50a:	d001      	beq.n	3419f510 <VD55G1_SetupClocks+0xbc>
3419f50c:	68bb      	ldr	r3, [r7, #8]
3419f50e:	e00d      	b.n	3419f52c <VD55G1_SetupClocks+0xd8>

  drv_ctx->pclk = VD55G1_GetPixelClock(ctx);
3419f510:	6878      	ldr	r0, [r7, #4]
3419f512:	f7ff ff59 	bl	3419f3c8 <VD55G1_GetPixelClock>
3419f516:	4602      	mov	r2, r0
3419f518:	68fb      	ldr	r3, [r7, #12]
3419f51a:	609a      	str	r2, [r3, #8]
  if (!drv_ctx->pclk)
3419f51c:	68fb      	ldr	r3, [r7, #12]
3419f51e:	689b      	ldr	r3, [r3, #8]
3419f520:	2b00      	cmp	r3, #0
3419f522:	d102      	bne.n	3419f52a <VD55G1_SetupClocks+0xd6>
    return -1;
3419f524:	f04f 33ff 	mov.w	r3, #4294967295
3419f528:	e000      	b.n	3419f52c <VD55G1_SetupClocks+0xd8>

  return 0;
3419f52a:	2300      	movs	r3, #0
}
3419f52c:	4618      	mov	r0, r3
3419f52e:	3710      	adds	r7, #16
3419f530:	46bd      	mov	sp, r7
3419f532:	bd80      	pop	{r7, pc}
3419f534:	0ee6b27f 	.word	0x0ee6b27f
3419f538:	47868c00 	.word	0x47868c00
3419f53c:	341a9f40 	.word	0x341a9f40
3419f540:	341a77b8 	.word	0x341a77b8

3419f544 <VD55G1_SetupOutput>:

static int VD55G1_SetupOutput(VD55G1_Ctx_t *ctx)
{
3419f544:	b580      	push	{r7, lr}
3419f546:	b08a      	sub	sp, #40	@ 0x28
3419f548:	af04      	add	r7, sp, #16
3419f54a:	6078      	str	r0, [r7, #4]
  VD55G1_OutItf_Config_t *out_itf = &ctx->ctx.config_save.out_itf;
3419f54c:	687b      	ldr	r3, [r7, #4]
3419f54e:	3344      	adds	r3, #68	@ 0x44
3419f550:	617b      	str	r3, [r7, #20]
  uint16_t oif_ctrl;
  int ret;

  /* Be sure we got value 0 or 1 */
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
3419f552:	697b      	ldr	r3, [r7, #20]
3419f554:	685b      	ldr	r3, [r3, #4]
3419f556:	2b00      	cmp	r3, #0
3419f558:	bf14      	ite	ne
3419f55a:	2301      	movne	r3, #1
3419f55c:	2300      	moveq	r3, #0
3419f55e:	b2db      	uxtb	r3, r3
3419f560:	461a      	mov	r2, r3
3419f562:	697b      	ldr	r3, [r7, #20]
3419f564:	605a      	str	r2, [r3, #4]
  out_itf->data_lane_swap_enable = !!out_itf->data_lane_swap_enable;
3419f566:	697b      	ldr	r3, [r7, #20]
3419f568:	689b      	ldr	r3, [r3, #8]
3419f56a:	2b00      	cmp	r3, #0
3419f56c:	bf14      	ite	ne
3419f56e:	2301      	movne	r3, #1
3419f570:	2300      	moveq	r3, #0
3419f572:	b2db      	uxtb	r3, r3
3419f574:	461a      	mov	r2, r3
3419f576:	697b      	ldr	r3, [r7, #20]
3419f578:	609a      	str	r2, [r3, #8]

  /* raw8 */
  ret = ctx->write8(ctx, VD55G1_REG_FORMAT_CTRL, 8);
3419f57a:	687b      	ldr	r3, [r7, #4]
3419f57c:	691b      	ldr	r3, [r3, #16]
3419f57e:	2208      	movs	r2, #8
3419f580:	f240 310a 	movw	r1, #778	@ 0x30a
3419f584:	6878      	ldr	r0, [r7, #4]
3419f586:	4798      	blx	r3
3419f588:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419f58a:	693b      	ldr	r3, [r7, #16]
3419f58c:	2b00      	cmp	r3, #0
3419f58e:	d00d      	beq.n	3419f5ac <VD55G1_SetupOutput+0x68>
3419f590:	693b      	ldr	r3, [r7, #16]
3419f592:	9302      	str	r3, [sp, #8]
3419f594:	f240 230d 	movw	r3, #525	@ 0x20d
3419f598:	9301      	str	r3, [sp, #4]
3419f59a:	4b37      	ldr	r3, [pc, #220]	@ (3419f678 <VD55G1_SetupOutput+0x134>)
3419f59c:	9300      	str	r3, [sp, #0]
3419f59e:	f240 230d 	movw	r3, #525	@ 0x20d
3419f5a2:	4a36      	ldr	r2, [pc, #216]	@ (3419f67c <VD55G1_SetupOutput+0x138>)
3419f5a4:	2100      	movs	r1, #0
3419f5a6:	6878      	ldr	r0, [r7, #4]
3419f5a8:	f7ff fb62 	bl	3419ec70 <VD55G1_log_impl>
3419f5ac:	693b      	ldr	r3, [r7, #16]
3419f5ae:	2b00      	cmp	r3, #0
3419f5b0:	d002      	beq.n	3419f5b8 <VD55G1_SetupOutput+0x74>
3419f5b2:	6878      	ldr	r0, [r7, #4]
3419f5b4:	f7ff fb78 	bl	3419eca8 <display_error>
3419f5b8:	693b      	ldr	r3, [r7, #16]
3419f5ba:	2b00      	cmp	r3, #0
3419f5bc:	d001      	beq.n	3419f5c2 <VD55G1_SetupOutput+0x7e>
3419f5be:	693b      	ldr	r3, [r7, #16]
3419f5c0:	e055      	b.n	3419f66e <VD55G1_SetupOutput+0x12a>

  /* csi lanes */
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
3419f5c2:	697b      	ldr	r3, [r7, #20]
3419f5c4:	689b      	ldr	r3, [r3, #8]
3419f5c6:	b21b      	sxth	r3, r3
3419f5c8:	019b      	lsls	r3, r3, #6
3419f5ca:	b21a      	sxth	r2, r3
             out_itf->clock_lane_swap_enable << 3;
3419f5cc:	697b      	ldr	r3, [r7, #20]
3419f5ce:	685b      	ldr	r3, [r3, #4]
  oif_ctrl = out_itf->data_lane_swap_enable << 6 |
3419f5d0:	b21b      	sxth	r3, r3
3419f5d2:	00db      	lsls	r3, r3, #3
3419f5d4:	b21b      	sxth	r3, r3
3419f5d6:	4313      	orrs	r3, r2
3419f5d8:	b21b      	sxth	r3, r3
3419f5da:	81fb      	strh	r3, [r7, #14]
  ret = ctx->write16(ctx, VD55G1_REG_OIF_CTRL, oif_ctrl);
3419f5dc:	687b      	ldr	r3, [r7, #4]
3419f5de:	695b      	ldr	r3, [r3, #20]
3419f5e0:	89fa      	ldrh	r2, [r7, #14]
3419f5e2:	f44f 7143 	mov.w	r1, #780	@ 0x30c
3419f5e6:	6878      	ldr	r0, [r7, #4]
3419f5e8:	4798      	blx	r3
3419f5ea:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419f5ec:	693b      	ldr	r3, [r7, #16]
3419f5ee:	2b00      	cmp	r3, #0
3419f5f0:	d00d      	beq.n	3419f60e <VD55G1_SetupOutput+0xca>
3419f5f2:	693b      	ldr	r3, [r7, #16]
3419f5f4:	9302      	str	r3, [sp, #8]
3419f5f6:	f240 2313 	movw	r3, #531	@ 0x213
3419f5fa:	9301      	str	r3, [sp, #4]
3419f5fc:	4b1e      	ldr	r3, [pc, #120]	@ (3419f678 <VD55G1_SetupOutput+0x134>)
3419f5fe:	9300      	str	r3, [sp, #0]
3419f600:	f240 2313 	movw	r3, #531	@ 0x213
3419f604:	4a1d      	ldr	r2, [pc, #116]	@ (3419f67c <VD55G1_SetupOutput+0x138>)
3419f606:	2100      	movs	r1, #0
3419f608:	6878      	ldr	r0, [r7, #4]
3419f60a:	f7ff fb31 	bl	3419ec70 <VD55G1_log_impl>
3419f60e:	693b      	ldr	r3, [r7, #16]
3419f610:	2b00      	cmp	r3, #0
3419f612:	d002      	beq.n	3419f61a <VD55G1_SetupOutput+0xd6>
3419f614:	6878      	ldr	r0, [r7, #4]
3419f616:	f7ff fb47 	bl	3419eca8 <display_error>
3419f61a:	693b      	ldr	r3, [r7, #16]
3419f61c:	2b00      	cmp	r3, #0
3419f61e:	d001      	beq.n	3419f624 <VD55G1_SetupOutput+0xe0>
3419f620:	693b      	ldr	r3, [r7, #16]
3419f622:	e024      	b.n	3419f66e <VD55G1_SetupOutput+0x12a>

  /* data type */
  ret = ctx->write8(ctx, VD55G1_REG_OIF_IMG_CTRL, 0x2a);
3419f624:	687b      	ldr	r3, [r7, #4]
3419f626:	691b      	ldr	r3, [r3, #16]
3419f628:	222a      	movs	r2, #42	@ 0x2a
3419f62a:	f240 310f 	movw	r1, #783	@ 0x30f
3419f62e:	6878      	ldr	r0, [r7, #4]
3419f630:	4798      	blx	r3
3419f632:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419f634:	693b      	ldr	r3, [r7, #16]
3419f636:	2b00      	cmp	r3, #0
3419f638:	d00d      	beq.n	3419f656 <VD55G1_SetupOutput+0x112>
3419f63a:	693b      	ldr	r3, [r7, #16]
3419f63c:	9302      	str	r3, [sp, #8]
3419f63e:	f240 2317 	movw	r3, #535	@ 0x217
3419f642:	9301      	str	r3, [sp, #4]
3419f644:	4b0c      	ldr	r3, [pc, #48]	@ (3419f678 <VD55G1_SetupOutput+0x134>)
3419f646:	9300      	str	r3, [sp, #0]
3419f648:	f240 2317 	movw	r3, #535	@ 0x217
3419f64c:	4a0b      	ldr	r2, [pc, #44]	@ (3419f67c <VD55G1_SetupOutput+0x138>)
3419f64e:	2100      	movs	r1, #0
3419f650:	6878      	ldr	r0, [r7, #4]
3419f652:	f7ff fb0d 	bl	3419ec70 <VD55G1_log_impl>
3419f656:	693b      	ldr	r3, [r7, #16]
3419f658:	2b00      	cmp	r3, #0
3419f65a:	d002      	beq.n	3419f662 <VD55G1_SetupOutput+0x11e>
3419f65c:	6878      	ldr	r0, [r7, #4]
3419f65e:	f7ff fb23 	bl	3419eca8 <display_error>
3419f662:	693b      	ldr	r3, [r7, #16]
3419f664:	2b00      	cmp	r3, #0
3419f666:	d001      	beq.n	3419f66c <VD55G1_SetupOutput+0x128>
3419f668:	693b      	ldr	r3, [r7, #16]
3419f66a:	e000      	b.n	3419f66e <VD55G1_SetupOutput+0x12a>

  return 0;
3419f66c:	2300      	movs	r3, #0
}
3419f66e:	4618      	mov	r0, r3
3419f670:	3718      	adds	r7, #24
3419f672:	46bd      	mov	sp, r7
3419f674:	bd80      	pop	{r7, pc}
3419f676:	bf00      	nop
3419f678:	341a9f54 	.word	0x341a9f54
3419f67c:	341a77b8 	.word	0x341a77b8

3419f680 <VD55G1_SetupSize>:

static int VD55G1_SetupSize(VD55G1_Ctx_t *ctx)
{
3419f680:	b580      	push	{r7, lr}
3419f682:	b08a      	sub	sp, #40	@ 0x28
3419f684:	af04      	add	r7, sp, #16
3419f686:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f688:	687b      	ldr	r3, [r7, #4]
3419f68a:	3328      	adds	r3, #40	@ 0x28
3419f68c:	617b      	str	r3, [r7, #20]
  const struct vd55g1_mode *mode;
  int ret;

  mode = VD55G1_Resolution2Mode(drv_ctx->config_save.resolution);
3419f68e:	697b      	ldr	r3, [r7, #20]
3419f690:	7c1b      	ldrb	r3, [r3, #16]
3419f692:	4618      	mov	r0, r3
3419f694:	f7ff fac0 	bl	3419ec18 <VD55G1_Resolution2Mode>
3419f698:	6138      	str	r0, [r7, #16]
  if (!mode)
3419f69a:	693b      	ldr	r3, [r7, #16]
3419f69c:	2b00      	cmp	r3, #0
3419f69e:	d102      	bne.n	3419f6a6 <VD55G1_SetupSize+0x26>
    return -1;
3419f6a0:	f04f 33ff 	mov.w	r3, #4294967295
3419f6a4:	e0bd      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>

  ret = ctx->write8(ctx, VD55G1_REG_READOUT_CTRL, mode->bin_mode);
3419f6a6:	687b      	ldr	r3, [r7, #4]
3419f6a8:	691b      	ldr	r3, [r3, #16]
3419f6aa:	693a      	ldr	r2, [r7, #16]
3419f6ac:	7a12      	ldrb	r2, [r2, #8]
3419f6ae:	f240 512e 	movw	r1, #1326	@ 0x52e
3419f6b2:	6878      	ldr	r0, [r7, #4]
3419f6b4:	4798      	blx	r3
3419f6b6:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419f6b8:	68fb      	ldr	r3, [r7, #12]
3419f6ba:	2b00      	cmp	r3, #0
3419f6bc:	d00d      	beq.n	3419f6da <VD55G1_SetupSize+0x5a>
3419f6be:	68fb      	ldr	r3, [r7, #12]
3419f6c0:	9302      	str	r3, [sp, #8]
3419f6c2:	f240 2327 	movw	r3, #551	@ 0x227
3419f6c6:	9301      	str	r3, [sp, #4]
3419f6c8:	4b58      	ldr	r3, [pc, #352]	@ (3419f82c <VD55G1_SetupSize+0x1ac>)
3419f6ca:	9300      	str	r3, [sp, #0]
3419f6cc:	f240 2327 	movw	r3, #551	@ 0x227
3419f6d0:	4a57      	ldr	r2, [pc, #348]	@ (3419f830 <VD55G1_SetupSize+0x1b0>)
3419f6d2:	2100      	movs	r1, #0
3419f6d4:	6878      	ldr	r0, [r7, #4]
3419f6d6:	f7ff facb 	bl	3419ec70 <VD55G1_log_impl>
3419f6da:	68fb      	ldr	r3, [r7, #12]
3419f6dc:	2b00      	cmp	r3, #0
3419f6de:	d002      	beq.n	3419f6e6 <VD55G1_SetupSize+0x66>
3419f6e0:	6878      	ldr	r0, [r7, #4]
3419f6e2:	f7ff fae1 	bl	3419eca8 <display_error>
3419f6e6:	68fb      	ldr	r3, [r7, #12]
3419f6e8:	2b00      	cmp	r3, #0
3419f6ea:	d001      	beq.n	3419f6f0 <VD55G1_SetupSize+0x70>
3419f6ec:	68fb      	ldr	r3, [r7, #12]
3419f6ee:	e098      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>

  ret = ctx->write16(ctx, VD55G1_REG_X_START, mode->crop.left);
3419f6f0:	687b      	ldr	r3, [r7, #4]
3419f6f2:	695b      	ldr	r3, [r3, #20]
3419f6f4:	693a      	ldr	r2, [r7, #16]
3419f6f6:	68d2      	ldr	r2, [r2, #12]
3419f6f8:	b292      	uxth	r2, r2
3419f6fa:	f240 5114 	movw	r1, #1300	@ 0x514
3419f6fe:	6878      	ldr	r0, [r7, #4]
3419f700:	4798      	blx	r3
3419f702:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419f704:	68fb      	ldr	r3, [r7, #12]
3419f706:	2b00      	cmp	r3, #0
3419f708:	d00d      	beq.n	3419f726 <VD55G1_SetupSize+0xa6>
3419f70a:	68fb      	ldr	r3, [r7, #12]
3419f70c:	9302      	str	r3, [sp, #8]
3419f70e:	f240 232a 	movw	r3, #554	@ 0x22a
3419f712:	9301      	str	r3, [sp, #4]
3419f714:	4b45      	ldr	r3, [pc, #276]	@ (3419f82c <VD55G1_SetupSize+0x1ac>)
3419f716:	9300      	str	r3, [sp, #0]
3419f718:	f240 232a 	movw	r3, #554	@ 0x22a
3419f71c:	4a44      	ldr	r2, [pc, #272]	@ (3419f830 <VD55G1_SetupSize+0x1b0>)
3419f71e:	2100      	movs	r1, #0
3419f720:	6878      	ldr	r0, [r7, #4]
3419f722:	f7ff faa5 	bl	3419ec70 <VD55G1_log_impl>
3419f726:	68fb      	ldr	r3, [r7, #12]
3419f728:	2b00      	cmp	r3, #0
3419f72a:	d002      	beq.n	3419f732 <VD55G1_SetupSize+0xb2>
3419f72c:	6878      	ldr	r0, [r7, #4]
3419f72e:	f7ff fabb 	bl	3419eca8 <display_error>
3419f732:	68fb      	ldr	r3, [r7, #12]
3419f734:	2b00      	cmp	r3, #0
3419f736:	d001      	beq.n	3419f73c <VD55G1_SetupSize+0xbc>
3419f738:	68fb      	ldr	r3, [r7, #12]
3419f73a:	e072      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_X_WIDTH, mode->crop.width);
3419f73c:	687b      	ldr	r3, [r7, #4]
3419f73e:	695b      	ldr	r3, [r3, #20]
3419f740:	693a      	ldr	r2, [r7, #16]
3419f742:	6952      	ldr	r2, [r2, #20]
3419f744:	b292      	uxth	r2, r2
3419f746:	f240 5116 	movw	r1, #1302	@ 0x516
3419f74a:	6878      	ldr	r0, [r7, #4]
3419f74c:	4798      	blx	r3
3419f74e:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419f750:	68fb      	ldr	r3, [r7, #12]
3419f752:	2b00      	cmp	r3, #0
3419f754:	d00d      	beq.n	3419f772 <VD55G1_SetupSize+0xf2>
3419f756:	68fb      	ldr	r3, [r7, #12]
3419f758:	9302      	str	r3, [sp, #8]
3419f75a:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3419f75e:	9301      	str	r3, [sp, #4]
3419f760:	4b32      	ldr	r3, [pc, #200]	@ (3419f82c <VD55G1_SetupSize+0x1ac>)
3419f762:	9300      	str	r3, [sp, #0]
3419f764:	f44f 730b 	mov.w	r3, #556	@ 0x22c
3419f768:	4a31      	ldr	r2, [pc, #196]	@ (3419f830 <VD55G1_SetupSize+0x1b0>)
3419f76a:	2100      	movs	r1, #0
3419f76c:	6878      	ldr	r0, [r7, #4]
3419f76e:	f7ff fa7f 	bl	3419ec70 <VD55G1_log_impl>
3419f772:	68fb      	ldr	r3, [r7, #12]
3419f774:	2b00      	cmp	r3, #0
3419f776:	d002      	beq.n	3419f77e <VD55G1_SetupSize+0xfe>
3419f778:	6878      	ldr	r0, [r7, #4]
3419f77a:	f7ff fa95 	bl	3419eca8 <display_error>
3419f77e:	68fb      	ldr	r3, [r7, #12]
3419f780:	2b00      	cmp	r3, #0
3419f782:	d001      	beq.n	3419f788 <VD55G1_SetupSize+0x108>
3419f784:	68fb      	ldr	r3, [r7, #12]
3419f786:	e04c      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_Y_START, mode->crop.top);
3419f788:	687b      	ldr	r3, [r7, #4]
3419f78a:	695b      	ldr	r3, [r3, #20]
3419f78c:	693a      	ldr	r2, [r7, #16]
3419f78e:	6912      	ldr	r2, [r2, #16]
3419f790:	b292      	uxth	r2, r2
3419f792:	f44f 61a2 	mov.w	r1, #1296	@ 0x510
3419f796:	6878      	ldr	r0, [r7, #4]
3419f798:	4798      	blx	r3
3419f79a:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419f79c:	68fb      	ldr	r3, [r7, #12]
3419f79e:	2b00      	cmp	r3, #0
3419f7a0:	d00d      	beq.n	3419f7be <VD55G1_SetupSize+0x13e>
3419f7a2:	68fb      	ldr	r3, [r7, #12]
3419f7a4:	9302      	str	r3, [sp, #8]
3419f7a6:	f240 232e 	movw	r3, #558	@ 0x22e
3419f7aa:	9301      	str	r3, [sp, #4]
3419f7ac:	4b1f      	ldr	r3, [pc, #124]	@ (3419f82c <VD55G1_SetupSize+0x1ac>)
3419f7ae:	9300      	str	r3, [sp, #0]
3419f7b0:	f240 232e 	movw	r3, #558	@ 0x22e
3419f7b4:	4a1e      	ldr	r2, [pc, #120]	@ (3419f830 <VD55G1_SetupSize+0x1b0>)
3419f7b6:	2100      	movs	r1, #0
3419f7b8:	6878      	ldr	r0, [r7, #4]
3419f7ba:	f7ff fa59 	bl	3419ec70 <VD55G1_log_impl>
3419f7be:	68fb      	ldr	r3, [r7, #12]
3419f7c0:	2b00      	cmp	r3, #0
3419f7c2:	d002      	beq.n	3419f7ca <VD55G1_SetupSize+0x14a>
3419f7c4:	6878      	ldr	r0, [r7, #4]
3419f7c6:	f7ff fa6f 	bl	3419eca8 <display_error>
3419f7ca:	68fb      	ldr	r3, [r7, #12]
3419f7cc:	2b00      	cmp	r3, #0
3419f7ce:	d001      	beq.n	3419f7d4 <VD55G1_SetupSize+0x154>
3419f7d0:	68fb      	ldr	r3, [r7, #12]
3419f7d2:	e026      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>
  ret = ctx->write16(ctx, VD55G1_REG_Y_HEIGHT, mode->crop.height);
3419f7d4:	687b      	ldr	r3, [r7, #4]
3419f7d6:	695b      	ldr	r3, [r3, #20]
3419f7d8:	693a      	ldr	r2, [r7, #16]
3419f7da:	6992      	ldr	r2, [r2, #24]
3419f7dc:	b292      	uxth	r2, r2
3419f7de:	f240 5112 	movw	r1, #1298	@ 0x512
3419f7e2:	6878      	ldr	r0, [r7, #4]
3419f7e4:	4798      	blx	r3
3419f7e6:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419f7e8:	68fb      	ldr	r3, [r7, #12]
3419f7ea:	2b00      	cmp	r3, #0
3419f7ec:	d00d      	beq.n	3419f80a <VD55G1_SetupSize+0x18a>
3419f7ee:	68fb      	ldr	r3, [r7, #12]
3419f7f0:	9302      	str	r3, [sp, #8]
3419f7f2:	f44f 730c 	mov.w	r3, #560	@ 0x230
3419f7f6:	9301      	str	r3, [sp, #4]
3419f7f8:	4b0c      	ldr	r3, [pc, #48]	@ (3419f82c <VD55G1_SetupSize+0x1ac>)
3419f7fa:	9300      	str	r3, [sp, #0]
3419f7fc:	f44f 730c 	mov.w	r3, #560	@ 0x230
3419f800:	4a0b      	ldr	r2, [pc, #44]	@ (3419f830 <VD55G1_SetupSize+0x1b0>)
3419f802:	2100      	movs	r1, #0
3419f804:	6878      	ldr	r0, [r7, #4]
3419f806:	f7ff fa33 	bl	3419ec70 <VD55G1_log_impl>
3419f80a:	68fb      	ldr	r3, [r7, #12]
3419f80c:	2b00      	cmp	r3, #0
3419f80e:	d002      	beq.n	3419f816 <VD55G1_SetupSize+0x196>
3419f810:	6878      	ldr	r0, [r7, #4]
3419f812:	f7ff fa49 	bl	3419eca8 <display_error>
3419f816:	68fb      	ldr	r3, [r7, #12]
3419f818:	2b00      	cmp	r3, #0
3419f81a:	d001      	beq.n	3419f820 <VD55G1_SetupSize+0x1a0>
3419f81c:	68fb      	ldr	r3, [r7, #12]
3419f81e:	e000      	b.n	3419f822 <VD55G1_SetupSize+0x1a2>

  return 0;
3419f820:	2300      	movs	r3, #0
}
3419f822:	4618      	mov	r0, r3
3419f824:	3718      	adds	r7, #24
3419f826:	46bd      	mov	sp, r7
3419f828:	bd80      	pop	{r7, pc}
3419f82a:	bf00      	nop
3419f82c:	341a9f68 	.word	0x341a9f68
3419f830:	341a77b8 	.word	0x341a77b8
3419f834:	00000000 	.word	0x00000000

3419f838 <VD55G1_SetupLineLen>:

static int VD55G1_SetupLineLen(VD55G1_Ctx_t *ctx)
{
3419f838:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3419f83c:	b08a      	sub	sp, #40	@ 0x28
3419f83e:	af04      	add	r7, sp, #16
3419f840:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f842:	687b      	ldr	r3, [r7, #4]
3419f844:	3328      	adds	r3, #40	@ 0x28
3419f846:	617b      	str	r3, [r7, #20]
  int min_line_len_mipi;
  uint16_t line_len;
  uint16_t width;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_X_WIDTH, &width);
3419f848:	687b      	ldr	r3, [r7, #4]
3419f84a:	689b      	ldr	r3, [r3, #8]
3419f84c:	f107 0208 	add.w	r2, r7, #8
3419f850:	f240 5116 	movw	r1, #1302	@ 0x516
3419f854:	6878      	ldr	r0, [r7, #4]
3419f856:	4798      	blx	r3
3419f858:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419f85a:	693b      	ldr	r3, [r7, #16]
3419f85c:	2b00      	cmp	r3, #0
3419f85e:	d00d      	beq.n	3419f87c <VD55G1_SetupLineLen+0x44>
3419f860:	693b      	ldr	r3, [r7, #16]
3419f862:	9302      	str	r3, [sp, #8]
3419f864:	f240 233e 	movw	r3, #574	@ 0x23e
3419f868:	9301      	str	r3, [sp, #4]
3419f86a:	4b3b      	ldr	r3, [pc, #236]	@ (3419f958 <VD55G1_SetupLineLen+0x120>)
3419f86c:	9300      	str	r3, [sp, #0]
3419f86e:	f240 233e 	movw	r3, #574	@ 0x23e
3419f872:	4a3a      	ldr	r2, [pc, #232]	@ (3419f95c <VD55G1_SetupLineLen+0x124>)
3419f874:	2100      	movs	r1, #0
3419f876:	6878      	ldr	r0, [r7, #4]
3419f878:	f7ff f9fa 	bl	3419ec70 <VD55G1_log_impl>
3419f87c:	693b      	ldr	r3, [r7, #16]
3419f87e:	2b00      	cmp	r3, #0
3419f880:	d002      	beq.n	3419f888 <VD55G1_SetupLineLen+0x50>
3419f882:	6878      	ldr	r0, [r7, #4]
3419f884:	f7ff fa10 	bl	3419eca8 <display_error>
3419f888:	693b      	ldr	r3, [r7, #16]
3419f88a:	2b00      	cmp	r3, #0
3419f88c:	d001      	beq.n	3419f892 <VD55G1_SetupLineLen+0x5a>
3419f88e:	693b      	ldr	r3, [r7, #16]
3419f890:	e056      	b.n	3419f940 <VD55G1_SetupLineLen+0x108>

  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
3419f892:	893b      	ldrh	r3, [r7, #8]
3419f894:	00db      	lsls	r3, r3, #3
3419f896:	f503 7361 	add.w	r3, r3, #900	@ 0x384
3419f89a:	17da      	asrs	r2, r3, #31
3419f89c:	469a      	mov	sl, r3
3419f89e:	4693      	mov	fp, r2
3419f8a0:	697b      	ldr	r3, [r7, #20]
3419f8a2:	689b      	ldr	r3, [r3, #8]
3419f8a4:	2200      	movs	r2, #0
3419f8a6:	4698      	mov	r8, r3
3419f8a8:	4691      	mov	r9, r2
3419f8aa:	fb08 f20b 	mul.w	r2, r8, fp
3419f8ae:	fb0a f309 	mul.w	r3, sl, r9
3419f8b2:	4413      	add	r3, r2
3419f8b4:	fbaa 4508 	umull	r4, r5, sl, r8
3419f8b8:	442b      	add	r3, r5
3419f8ba:	461d      	mov	r5, r3
                      / VD55G1_MIPI_DATA_RATE_HZ;
3419f8bc:	a324      	add	r3, pc, #144	@ (adr r3, 3419f950 <VD55G1_SetupLineLen+0x118>)
3419f8be:	e9d3 2300 	ldrd	r2, r3, [r3]
3419f8c2:	4620      	mov	r0, r4
3419f8c4:	4629      	mov	r1, r5
3419f8c6:	f7e1 ff89 	bl	341817dc <__aeabi_uldivmod>
3419f8ca:	4602      	mov	r2, r0
3419f8cc:	460b      	mov	r3, r1
  min_line_len_mipi = ((width * VD55G1_MIPI_BPP + VD55G1_MIPI_MARGIN) * (uint64_t)drv_ctx->pclk)
3419f8ce:	4613      	mov	r3, r2
3419f8d0:	60fb      	str	r3, [r7, #12]
  line_len = MAX(VD55G1_MIN_LINE_LEN_ADC_10, min_line_len_mipi);
3419f8d2:	68fb      	ldr	r3, [r7, #12]
3419f8d4:	f5b3 6f8d 	cmp.w	r3, #1128	@ 0x468
3419f8d8:	bfb8      	it	lt
3419f8da:	f44f 638d 	movlt.w	r3, #1128	@ 0x468
3419f8de:	817b      	strh	r3, [r7, #10]

  ret = ctx->write16(ctx, VD55G1_REG_LINE_LENGTH, line_len);
3419f8e0:	687b      	ldr	r3, [r7, #4]
3419f8e2:	695b      	ldr	r3, [r3, #20]
3419f8e4:	897a      	ldrh	r2, [r7, #10]
3419f8e6:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419f8ea:	6878      	ldr	r0, [r7, #4]
3419f8ec:	4798      	blx	r3
3419f8ee:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419f8f0:	693b      	ldr	r3, [r7, #16]
3419f8f2:	2b00      	cmp	r3, #0
3419f8f4:	d00d      	beq.n	3419f912 <VD55G1_SetupLineLen+0xda>
3419f8f6:	693b      	ldr	r3, [r7, #16]
3419f8f8:	9302      	str	r3, [sp, #8]
3419f8fa:	f240 2345 	movw	r3, #581	@ 0x245
3419f8fe:	9301      	str	r3, [sp, #4]
3419f900:	4b15      	ldr	r3, [pc, #84]	@ (3419f958 <VD55G1_SetupLineLen+0x120>)
3419f902:	9300      	str	r3, [sp, #0]
3419f904:	f240 2345 	movw	r3, #581	@ 0x245
3419f908:	4a14      	ldr	r2, [pc, #80]	@ (3419f95c <VD55G1_SetupLineLen+0x124>)
3419f90a:	2100      	movs	r1, #0
3419f90c:	6878      	ldr	r0, [r7, #4]
3419f90e:	f7ff f9af 	bl	3419ec70 <VD55G1_log_impl>
3419f912:	693b      	ldr	r3, [r7, #16]
3419f914:	2b00      	cmp	r3, #0
3419f916:	d002      	beq.n	3419f91e <VD55G1_SetupLineLen+0xe6>
3419f918:	6878      	ldr	r0, [r7, #4]
3419f91a:	f7ff f9c5 	bl	3419eca8 <display_error>
3419f91e:	693b      	ldr	r3, [r7, #16]
3419f920:	2b00      	cmp	r3, #0
3419f922:	d001      	beq.n	3419f928 <VD55G1_SetupLineLen+0xf0>
3419f924:	693b      	ldr	r3, [r7, #16]
3419f926:	e00b      	b.n	3419f940 <VD55G1_SetupLineLen+0x108>
  VD55G1_dbg(ctx, 1, "line_length = %d\n", line_len);
3419f928:	897b      	ldrh	r3, [r7, #10]
3419f92a:	9301      	str	r3, [sp, #4]
3419f92c:	f240 2346 	movw	r3, #582	@ 0x246
3419f930:	9300      	str	r3, [sp, #0]
3419f932:	2301      	movs	r3, #1
3419f934:	4a0a      	ldr	r2, [pc, #40]	@ (3419f960 <VD55G1_SetupLineLen+0x128>)
3419f936:	2104      	movs	r1, #4
3419f938:	6878      	ldr	r0, [r7, #4]
3419f93a:	f7ff f999 	bl	3419ec70 <VD55G1_log_impl>

  return 0;
3419f93e:	2300      	movs	r3, #0
}
3419f940:	4618      	mov	r0, r3
3419f942:	3718      	adds	r7, #24
3419f944:	46bd      	mov	sp, r7
3419f946:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3419f94a:	bf00      	nop
3419f94c:	f3af 8000 	nop.w
3419f950:	2fec1100 	.word	0x2fec1100
3419f954:	00000000 	.word	0x00000000
3419f958:	341a9f7c 	.word	0x341a9f7c
3419f95c:	341a77b8 	.word	0x341a77b8
3419f960:	341a79dc 	.word	0x341a79dc

3419f964 <VD55G1_ComputeFrameLength>:

static int VD55G1_ComputeFrameLength(VD55G1_Ctx_t *ctx, int fps, uint16_t *frame_length)
{
3419f964:	b580      	push	{r7, lr}
3419f966:	b090      	sub	sp, #64	@ 0x40
3419f968:	af06      	add	r7, sp, #24
3419f96a:	60f8      	str	r0, [r7, #12]
3419f96c:	60b9      	str	r1, [r7, #8]
3419f96e:	607a      	str	r2, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419f970:	68fb      	ldr	r3, [r7, #12]
3419f972:	3328      	adds	r3, #40	@ 0x28
3419f974:	627b      	str	r3, [r7, #36]	@ 0x24
  int req_frame_length;
  uint16_t line_length;
  uint16_t height;
  int ret;

  ret = ctx->read16(ctx, VD55G1_REG_LINE_LENGTH, &line_length);
3419f976:	68fb      	ldr	r3, [r7, #12]
3419f978:	689b      	ldr	r3, [r3, #8]
3419f97a:	f107 0216 	add.w	r2, r7, #22
3419f97e:	f44f 7140 	mov.w	r1, #768	@ 0x300
3419f982:	68f8      	ldr	r0, [r7, #12]
3419f984:	4798      	blx	r3
3419f986:	6238      	str	r0, [r7, #32]
  VD55G1_TraceError(ctx, ret);
3419f988:	6a3b      	ldr	r3, [r7, #32]
3419f98a:	2b00      	cmp	r3, #0
3419f98c:	d00d      	beq.n	3419f9aa <VD55G1_ComputeFrameLength+0x46>
3419f98e:	6a3b      	ldr	r3, [r7, #32]
3419f990:	9302      	str	r3, [sp, #8]
3419f992:	f240 2355 	movw	r3, #597	@ 0x255
3419f996:	9301      	str	r3, [sp, #4]
3419f998:	4b35      	ldr	r3, [pc, #212]	@ (3419fa70 <VD55G1_ComputeFrameLength+0x10c>)
3419f99a:	9300      	str	r3, [sp, #0]
3419f99c:	f240 2355 	movw	r3, #597	@ 0x255
3419f9a0:	4a34      	ldr	r2, [pc, #208]	@ (3419fa74 <VD55G1_ComputeFrameLength+0x110>)
3419f9a2:	2100      	movs	r1, #0
3419f9a4:	68f8      	ldr	r0, [r7, #12]
3419f9a6:	f7ff f963 	bl	3419ec70 <VD55G1_log_impl>
3419f9aa:	6a3b      	ldr	r3, [r7, #32]
3419f9ac:	2b00      	cmp	r3, #0
3419f9ae:	d002      	beq.n	3419f9b6 <VD55G1_ComputeFrameLength+0x52>
3419f9b0:	68f8      	ldr	r0, [r7, #12]
3419f9b2:	f7ff f979 	bl	3419eca8 <display_error>
3419f9b6:	6a3b      	ldr	r3, [r7, #32]
3419f9b8:	2b00      	cmp	r3, #0
3419f9ba:	d001      	beq.n	3419f9c0 <VD55G1_ComputeFrameLength+0x5c>
3419f9bc:	6a3b      	ldr	r3, [r7, #32]
3419f9be:	e052      	b.n	3419fa66 <VD55G1_ComputeFrameLength+0x102>

  ret = ctx->read16(ctx, VD55G1_REG_Y_HEIGHT, &height);
3419f9c0:	68fb      	ldr	r3, [r7, #12]
3419f9c2:	689b      	ldr	r3, [r3, #8]
3419f9c4:	f107 0214 	add.w	r2, r7, #20
3419f9c8:	f240 5112 	movw	r1, #1298	@ 0x512
3419f9cc:	68f8      	ldr	r0, [r7, #12]
3419f9ce:	4798      	blx	r3
3419f9d0:	6238      	str	r0, [r7, #32]
  VD55G1_TraceError(ctx, ret);
3419f9d2:	6a3b      	ldr	r3, [r7, #32]
3419f9d4:	2b00      	cmp	r3, #0
3419f9d6:	d00d      	beq.n	3419f9f4 <VD55G1_ComputeFrameLength+0x90>
3419f9d8:	6a3b      	ldr	r3, [r7, #32]
3419f9da:	9302      	str	r3, [sp, #8]
3419f9dc:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419f9e0:	9301      	str	r3, [sp, #4]
3419f9e2:	4b23      	ldr	r3, [pc, #140]	@ (3419fa70 <VD55G1_ComputeFrameLength+0x10c>)
3419f9e4:	9300      	str	r3, [sp, #0]
3419f9e6:	f44f 7316 	mov.w	r3, #600	@ 0x258
3419f9ea:	4a22      	ldr	r2, [pc, #136]	@ (3419fa74 <VD55G1_ComputeFrameLength+0x110>)
3419f9ec:	2100      	movs	r1, #0
3419f9ee:	68f8      	ldr	r0, [r7, #12]
3419f9f0:	f7ff f93e 	bl	3419ec70 <VD55G1_log_impl>
3419f9f4:	6a3b      	ldr	r3, [r7, #32]
3419f9f6:	2b00      	cmp	r3, #0
3419f9f8:	d002      	beq.n	3419fa00 <VD55G1_ComputeFrameLength+0x9c>
3419f9fa:	68f8      	ldr	r0, [r7, #12]
3419f9fc:	f7ff f954 	bl	3419eca8 <display_error>
3419fa00:	6a3b      	ldr	r3, [r7, #32]
3419fa02:	2b00      	cmp	r3, #0
3419fa04:	d001      	beq.n	3419fa0a <VD55G1_ComputeFrameLength+0xa6>
3419fa06:	6a3b      	ldr	r3, [r7, #32]
3419fa08:	e02d      	b.n	3419fa66 <VD55G1_ComputeFrameLength+0x102>

  min_frame_length = height + VD55G1_MIN_VBLANK;
3419fa0a:	8abb      	ldrh	r3, [r7, #20]
3419fa0c:	3356      	adds	r3, #86	@ 0x56
3419fa0e:	61fb      	str	r3, [r7, #28]
  req_frame_length = drv_ctx->pclk / (line_length * fps);
3419fa10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3419fa12:	689b      	ldr	r3, [r3, #8]
3419fa14:	8afa      	ldrh	r2, [r7, #22]
3419fa16:	4611      	mov	r1, r2
3419fa18:	68ba      	ldr	r2, [r7, #8]
3419fa1a:	fb01 f202 	mul.w	r2, r1, r2
3419fa1e:	fbb3 f3f2 	udiv	r3, r3, r2
3419fa22:	61bb      	str	r3, [r7, #24]
  *frame_length = MIN(MAX(min_frame_length, req_frame_length), 65535);
3419fa24:	69ba      	ldr	r2, [r7, #24]
3419fa26:	69fb      	ldr	r3, [r7, #28]
3419fa28:	4293      	cmp	r3, r2
3419fa2a:	bfb8      	it	lt
3419fa2c:	4613      	movlt	r3, r2
3419fa2e:	f64f 72ff 	movw	r2, #65535	@ 0xffff
3419fa32:	4293      	cmp	r3, r2
3419fa34:	bfa8      	it	ge
3419fa36:	4613      	movge	r3, r2
3419fa38:	b29a      	uxth	r2, r3
3419fa3a:	687b      	ldr	r3, [r7, #4]
3419fa3c:	801a      	strh	r2, [r3, #0]

  VD55G1_dbg(ctx, 1, "frame_length to MAX(%d, %d) = %d to reach %d fps\n", min_frame_length, req_frame_length,
3419fa3e:	687b      	ldr	r3, [r7, #4]
3419fa40:	881b      	ldrh	r3, [r3, #0]
3419fa42:	461a      	mov	r2, r3
3419fa44:	68bb      	ldr	r3, [r7, #8]
3419fa46:	9304      	str	r3, [sp, #16]
3419fa48:	9203      	str	r2, [sp, #12]
3419fa4a:	69bb      	ldr	r3, [r7, #24]
3419fa4c:	9302      	str	r3, [sp, #8]
3419fa4e:	69fb      	ldr	r3, [r7, #28]
3419fa50:	9301      	str	r3, [sp, #4]
3419fa52:	f240 235e 	movw	r3, #606	@ 0x25e
3419fa56:	9300      	str	r3, [sp, #0]
3419fa58:	2301      	movs	r3, #1
3419fa5a:	4a07      	ldr	r2, [pc, #28]	@ (3419fa78 <VD55G1_ComputeFrameLength+0x114>)
3419fa5c:	2104      	movs	r1, #4
3419fa5e:	68f8      	ldr	r0, [r7, #12]
3419fa60:	f7ff f906 	bl	3419ec70 <VD55G1_log_impl>
             *frame_length, fps);

  return 0;
3419fa64:	2300      	movs	r3, #0
}
3419fa66:	4618      	mov	r0, r3
3419fa68:	3728      	adds	r7, #40	@ 0x28
3419fa6a:	46bd      	mov	sp, r7
3419fa6c:	bd80      	pop	{r7, pc}
3419fa6e:	bf00      	nop
3419fa70:	341a9f90 	.word	0x341a9f90
3419fa74:	341a77b8 	.word	0x341a77b8
3419fa78:	341a7a00 	.word	0x341a7a00

3419fa7c <VD55G1_SetupFrameRate>:

static int VD55G1_SetupFrameRate(VD55G1_Ctx_t *ctx)
{
3419fa7c:	b580      	push	{r7, lr}
3419fa7e:	b08a      	sub	sp, #40	@ 0x28
3419fa80:	af04      	add	r7, sp, #16
3419fa82:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419fa84:	687b      	ldr	r3, [r7, #4]
3419fa86:	3328      	adds	r3, #40	@ 0x28
3419fa88:	617b      	str	r3, [r7, #20]
  uint16_t frame_length;
  int ret;

  ret = VD55G1_SetupLineLen(ctx);
3419fa8a:	6878      	ldr	r0, [r7, #4]
3419fa8c:	f7ff fed4 	bl	3419f838 <VD55G1_SetupLineLen>
3419fa90:	6138      	str	r0, [r7, #16]
  if (ret)
3419fa92:	693b      	ldr	r3, [r7, #16]
3419fa94:	2b00      	cmp	r3, #0
3419fa96:	d001      	beq.n	3419fa9c <VD55G1_SetupFrameRate+0x20>
    return ret;
3419fa98:	693b      	ldr	r3, [r7, #16]
3419fa9a:	e041      	b.n	3419fb20 <VD55G1_SetupFrameRate+0xa4>

  ret = VD55G1_ComputeFrameLength(ctx, drv_ctx->config_save.frame_rate, &frame_length);
3419fa9c:	697b      	ldr	r3, [r7, #20]
3419fa9e:	695b      	ldr	r3, [r3, #20]
3419faa0:	f107 020e 	add.w	r2, r7, #14
3419faa4:	4619      	mov	r1, r3
3419faa6:	6878      	ldr	r0, [r7, #4]
3419faa8:	f7ff ff5c 	bl	3419f964 <VD55G1_ComputeFrameLength>
3419faac:	6138      	str	r0, [r7, #16]
  if (ret)
3419faae:	693b      	ldr	r3, [r7, #16]
3419fab0:	2b00      	cmp	r3, #0
3419fab2:	d001      	beq.n	3419fab8 <VD55G1_SetupFrameRate+0x3c>
    return ret;
3419fab4:	693b      	ldr	r3, [r7, #16]
3419fab6:	e033      	b.n	3419fb20 <VD55G1_SetupFrameRate+0xa4>

  VD55G1_dbg(ctx, 1, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
3419fab8:	89fb      	ldrh	r3, [r7, #14]
3419faba:	461a      	mov	r2, r3
3419fabc:	697b      	ldr	r3, [r7, #20]
3419fabe:	695b      	ldr	r3, [r3, #20]
3419fac0:	9302      	str	r3, [sp, #8]
3419fac2:	9201      	str	r2, [sp, #4]
3419fac4:	f240 2372 	movw	r3, #626	@ 0x272
3419fac8:	9300      	str	r3, [sp, #0]
3419faca:	2301      	movs	r3, #1
3419facc:	4a16      	ldr	r2, [pc, #88]	@ (3419fb28 <VD55G1_SetupFrameRate+0xac>)
3419face:	2104      	movs	r1, #4
3419fad0:	6878      	ldr	r0, [r7, #4]
3419fad2:	f7ff f8cd 	bl	3419ec70 <VD55G1_log_impl>
  ret = ctx->write16(ctx, VD55G1_REG_FRAME_LENGTH, frame_length);
3419fad6:	687b      	ldr	r3, [r7, #4]
3419fad8:	695b      	ldr	r3, [r3, #20]
3419fada:	89fa      	ldrh	r2, [r7, #14]
3419fadc:	f240 510c 	movw	r1, #1292	@ 0x50c
3419fae0:	6878      	ldr	r0, [r7, #4]
3419fae2:	4798      	blx	r3
3419fae4:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419fae6:	693b      	ldr	r3, [r7, #16]
3419fae8:	2b00      	cmp	r3, #0
3419faea:	d00d      	beq.n	3419fb08 <VD55G1_SetupFrameRate+0x8c>
3419faec:	693b      	ldr	r3, [r7, #16]
3419faee:	9302      	str	r3, [sp, #8]
3419faf0:	f44f 731d 	mov.w	r3, #628	@ 0x274
3419faf4:	9301      	str	r3, [sp, #4]
3419faf6:	4b0d      	ldr	r3, [pc, #52]	@ (3419fb2c <VD55G1_SetupFrameRate+0xb0>)
3419faf8:	9300      	str	r3, [sp, #0]
3419fafa:	f44f 731d 	mov.w	r3, #628	@ 0x274
3419fafe:	4a0c      	ldr	r2, [pc, #48]	@ (3419fb30 <VD55G1_SetupFrameRate+0xb4>)
3419fb00:	2100      	movs	r1, #0
3419fb02:	6878      	ldr	r0, [r7, #4]
3419fb04:	f7ff f8b4 	bl	3419ec70 <VD55G1_log_impl>
3419fb08:	693b      	ldr	r3, [r7, #16]
3419fb0a:	2b00      	cmp	r3, #0
3419fb0c:	d002      	beq.n	3419fb14 <VD55G1_SetupFrameRate+0x98>
3419fb0e:	6878      	ldr	r0, [r7, #4]
3419fb10:	f7ff f8ca 	bl	3419eca8 <display_error>
3419fb14:	693b      	ldr	r3, [r7, #16]
3419fb16:	2b00      	cmp	r3, #0
3419fb18:	d001      	beq.n	3419fb1e <VD55G1_SetupFrameRate+0xa2>
3419fb1a:	693b      	ldr	r3, [r7, #16]
3419fb1c:	e000      	b.n	3419fb20 <VD55G1_SetupFrameRate+0xa4>

  return 0;
3419fb1e:	2300      	movs	r3, #0
}
3419fb20:	4618      	mov	r0, r3
3419fb22:	3718      	adds	r7, #24
3419fb24:	46bd      	mov	sp, r7
3419fb26:	bd80      	pop	{r7, pc}
3419fb28:	341a7a44 	.word	0x341a7a44
3419fb2c:	341a9fac 	.word	0x341a9fac
3419fb30:	341a77b8 	.word	0x341a77b8

3419fb34 <VD55G1_SetupExposure>:

static int VD55G1_SetupExposure(VD55G1_Ctx_t *ctx)
{
3419fb34:	b580      	push	{r7, lr}
3419fb36:	b08c      	sub	sp, #48	@ 0x30
3419fb38:	af04      	add	r7, sp, #16
3419fb3a:	6078      	str	r0, [r7, #4]
  VD55G1_AWUConfig_t *awu = &ctx->ctx.config_save.awu;
3419fb3c:	687b      	ldr	r3, [r7, #4]
3419fb3e:	3350      	adds	r3, #80	@ 0x50
3419fb40:	61bb      	str	r3, [r7, #24]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419fb42:	687b      	ldr	r3, [r7, #4]
3419fb44:	3328      	adds	r3, #40	@ 0x28
3419fb46:	617b      	str	r3, [r7, #20]
  uint8_t reg;
  int ret;

  /* max integration lines */
   /* first get minimum frame len */
  max_fps = drv_ctx->config_save.frame_rate;
3419fb48:	697b      	ldr	r3, [r7, #20]
3419fb4a:	695b      	ldr	r3, [r3, #20]
3419fb4c:	61fb      	str	r3, [r7, #28]
  if (awu->is_enable)
3419fb4e:	69bb      	ldr	r3, [r7, #24]
3419fb50:	681b      	ldr	r3, [r3, #0]
3419fb52:	2b00      	cmp	r3, #0
3419fb54:	d00d      	beq.n	3419fb72 <VD55G1_SetupExposure+0x3e>
  {
    max_fps = MAX(max_fps, awu->convergence_frame_rate);
3419fb56:	69bb      	ldr	r3, [r7, #24]
3419fb58:	685b      	ldr	r3, [r3, #4]
3419fb5a:	69fa      	ldr	r2, [r7, #28]
3419fb5c:	4293      	cmp	r3, r2
3419fb5e:	bfb8      	it	lt
3419fb60:	4613      	movlt	r3, r2
3419fb62:	61fb      	str	r3, [r7, #28]
    max_fps = MAX(max_fps, awu->awu_frame_rate);
3419fb64:	69bb      	ldr	r3, [r7, #24]
3419fb66:	689b      	ldr	r3, [r3, #8]
3419fb68:	69fa      	ldr	r2, [r7, #28]
3419fb6a:	4293      	cmp	r3, r2
3419fb6c:	bfb8      	it	lt
3419fb6e:	4613      	movlt	r3, r2
3419fb70:	61fb      	str	r3, [r7, #28]
  }
  ret = VD55G1_ComputeFrameLength(ctx, max_fps, &frame_length);
3419fb72:	f107 030c 	add.w	r3, r7, #12
3419fb76:	461a      	mov	r2, r3
3419fb78:	69f9      	ldr	r1, [r7, #28]
3419fb7a:	6878      	ldr	r0, [r7, #4]
3419fb7c:	f7ff fef2 	bl	3419f964 <VD55G1_ComputeFrameLength>
3419fb80:	6138      	str	r0, [r7, #16]
  if (ret)
3419fb82:	693b      	ldr	r3, [r7, #16]
3419fb84:	2b00      	cmp	r3, #0
3419fb86:	d001      	beq.n	3419fb8c <VD55G1_SetupExposure+0x58>
    return ret;
3419fb88:	693b      	ldr	r3, [r7, #16]
3419fb8a:	e05e      	b.n	3419fc4a <VD55G1_SetupExposure+0x116>
   /* set max integration lines to this value minus 10 lines */
  ret = ctx->write16(ctx, VD55G1_REG_MAX_COARSE_INTEGRATION_LINES, frame_length - 10);
3419fb8c:	687b      	ldr	r3, [r7, #4]
3419fb8e:	695b      	ldr	r3, [r3, #20]
3419fb90:	89ba      	ldrh	r2, [r7, #12]
3419fb92:	3a0a      	subs	r2, #10
3419fb94:	b292      	uxth	r2, r2
3419fb96:	f240 3172 	movw	r1, #882	@ 0x372
3419fb9a:	6878      	ldr	r0, [r7, #4]
3419fb9c:	4798      	blx	r3
3419fb9e:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419fba0:	693b      	ldr	r3, [r7, #16]
3419fba2:	2b00      	cmp	r3, #0
3419fba4:	d00d      	beq.n	3419fbc2 <VD55G1_SetupExposure+0x8e>
3419fba6:	693b      	ldr	r3, [r7, #16]
3419fba8:	9302      	str	r3, [sp, #8]
3419fbaa:	f240 238f 	movw	r3, #655	@ 0x28f
3419fbae:	9301      	str	r3, [sp, #4]
3419fbb0:	4b28      	ldr	r3, [pc, #160]	@ (3419fc54 <VD55G1_SetupExposure+0x120>)
3419fbb2:	9300      	str	r3, [sp, #0]
3419fbb4:	f240 238f 	movw	r3, #655	@ 0x28f
3419fbb8:	4a27      	ldr	r2, [pc, #156]	@ (3419fc58 <VD55G1_SetupExposure+0x124>)
3419fbba:	2100      	movs	r1, #0
3419fbbc:	6878      	ldr	r0, [r7, #4]
3419fbbe:	f7ff f857 	bl	3419ec70 <VD55G1_log_impl>
3419fbc2:	693b      	ldr	r3, [r7, #16]
3419fbc4:	2b00      	cmp	r3, #0
3419fbc6:	d002      	beq.n	3419fbce <VD55G1_SetupExposure+0x9a>
3419fbc8:	6878      	ldr	r0, [r7, #4]
3419fbca:	f7ff f86d 	bl	3419eca8 <display_error>
3419fbce:	693b      	ldr	r3, [r7, #16]
3419fbd0:	2b00      	cmp	r3, #0
3419fbd2:	d001      	beq.n	3419fbd8 <VD55G1_SetupExposure+0xa4>
3419fbd4:	693b      	ldr	r3, [r7, #16]
3419fbd6:	e038      	b.n	3419fc4a <VD55G1_SetupExposure+0x116>
  VD55G1_dbg(ctx, 1, "Max coarse lines = %d\n", frame_length - 10);
3419fbd8:	89bb      	ldrh	r3, [r7, #12]
3419fbda:	3b0a      	subs	r3, #10
3419fbdc:	9301      	str	r3, [sp, #4]
3419fbde:	f44f 7324 	mov.w	r3, #656	@ 0x290
3419fbe2:	9300      	str	r3, [sp, #0]
3419fbe4:	2301      	movs	r3, #1
3419fbe6:	4a1d      	ldr	r2, [pc, #116]	@ (3419fc5c <VD55G1_SetupExposure+0x128>)
3419fbe8:	2104      	movs	r1, #4
3419fbea:	6878      	ldr	r0, [r7, #4]
3419fbec:	f7ff f840 	bl	3419ec70 <VD55G1_log_impl>

  /* turn on auto exposure except when patgen is active */
  reg = drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE ? VD55G1_EXP_MODE_MANUAL : VD55G1_EXP_MODE_AUTO;
3419fbf0:	697b      	ldr	r3, [r7, #20]
3419fbf2:	7e5b      	ldrb	r3, [r3, #25]
3419fbf4:	2b00      	cmp	r3, #0
3419fbf6:	d001      	beq.n	3419fbfc <VD55G1_SetupExposure+0xc8>
3419fbf8:	2302      	movs	r3, #2
3419fbfa:	e000      	b.n	3419fbfe <VD55G1_SetupExposure+0xca>
3419fbfc:	2300      	movs	r3, #0
3419fbfe:	73fb      	strb	r3, [r7, #15]
  ret = ctx->write8(ctx, VD55G1_REG_EXP_MODE, reg);
3419fc00:	687b      	ldr	r3, [r7, #4]
3419fc02:	691b      	ldr	r3, [r3, #16]
3419fc04:	7bfa      	ldrb	r2, [r7, #15]
3419fc06:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
3419fc0a:	6878      	ldr	r0, [r7, #4]
3419fc0c:	4798      	blx	r3
3419fc0e:	6138      	str	r0, [r7, #16]
  VD55G1_TraceError(ctx, ret);
3419fc10:	693b      	ldr	r3, [r7, #16]
3419fc12:	2b00      	cmp	r3, #0
3419fc14:	d00d      	beq.n	3419fc32 <VD55G1_SetupExposure+0xfe>
3419fc16:	693b      	ldr	r3, [r7, #16]
3419fc18:	9302      	str	r3, [sp, #8]
3419fc1a:	f240 2395 	movw	r3, #661	@ 0x295
3419fc1e:	9301      	str	r3, [sp, #4]
3419fc20:	4b0c      	ldr	r3, [pc, #48]	@ (3419fc54 <VD55G1_SetupExposure+0x120>)
3419fc22:	9300      	str	r3, [sp, #0]
3419fc24:	f240 2395 	movw	r3, #661	@ 0x295
3419fc28:	4a0b      	ldr	r2, [pc, #44]	@ (3419fc58 <VD55G1_SetupExposure+0x124>)
3419fc2a:	2100      	movs	r1, #0
3419fc2c:	6878      	ldr	r0, [r7, #4]
3419fc2e:	f7ff f81f 	bl	3419ec70 <VD55G1_log_impl>
3419fc32:	693b      	ldr	r3, [r7, #16]
3419fc34:	2b00      	cmp	r3, #0
3419fc36:	d002      	beq.n	3419fc3e <VD55G1_SetupExposure+0x10a>
3419fc38:	6878      	ldr	r0, [r7, #4]
3419fc3a:	f7ff f835 	bl	3419eca8 <display_error>
3419fc3e:	693b      	ldr	r3, [r7, #16]
3419fc40:	2b00      	cmp	r3, #0
3419fc42:	d001      	beq.n	3419fc48 <VD55G1_SetupExposure+0x114>
3419fc44:	693b      	ldr	r3, [r7, #16]
3419fc46:	e000      	b.n	3419fc4a <VD55G1_SetupExposure+0x116>

  return 0;
3419fc48:	2300      	movs	r3, #0
}
3419fc4a:	4618      	mov	r0, r3
3419fc4c:	3720      	adds	r7, #32
3419fc4e:	46bd      	mov	sp, r7
3419fc50:	bd80      	pop	{r7, pc}
3419fc52:	bf00      	nop
3419fc54:	341a9fc4 	.word	0x341a9fc4
3419fc58:	341a77b8 	.word	0x341a77b8
3419fc5c:	341a7a80 	.word	0x341a7a80

3419fc60 <VD55G1_SetupMirrorFlip>:

static int VD55G1_SetupMirrorFlip(VD55G1_Ctx_t *ctx)
{
3419fc60:	b580      	push	{r7, lr}
3419fc62:	b08a      	sub	sp, #40	@ 0x28
3419fc64:	af04      	add	r7, sp, #16
3419fc66:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419fc68:	687b      	ldr	r3, [r7, #4]
3419fc6a:	3328      	adds	r3, #40	@ 0x28
3419fc6c:	613b      	str	r3, [r7, #16]
  uint8_t mode;
  int ret;

  switch (drv_ctx->config_save.flip_mirror_mode) {
3419fc6e:	693b      	ldr	r3, [r7, #16]
3419fc70:	7e1b      	ldrb	r3, [r3, #24]
3419fc72:	2b03      	cmp	r3, #3
3419fc74:	d816      	bhi.n	3419fca4 <VD55G1_SetupMirrorFlip+0x44>
3419fc76:	a201      	add	r2, pc, #4	@ (adr r2, 3419fc7c <VD55G1_SetupMirrorFlip+0x1c>)
3419fc78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3419fc7c:	3419fc8d 	.word	0x3419fc8d
3419fc80:	3419fc93 	.word	0x3419fc93
3419fc84:	3419fc99 	.word	0x3419fc99
3419fc88:	3419fc9f 	.word	0x3419fc9f
  case VD55G1_MIRROR_FLIP_NONE:
    mode = 0;
3419fc8c:	2300      	movs	r3, #0
3419fc8e:	75fb      	strb	r3, [r7, #23]
    break;
3419fc90:	e00b      	b.n	3419fcaa <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_FLIP:
    mode = 2;
3419fc92:	2302      	movs	r3, #2
3419fc94:	75fb      	strb	r3, [r7, #23]
    break;
3419fc96:	e008      	b.n	3419fcaa <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_MIRROR:
    mode = 1;
3419fc98:	2301      	movs	r3, #1
3419fc9a:	75fb      	strb	r3, [r7, #23]
    break;
3419fc9c:	e005      	b.n	3419fcaa <VD55G1_SetupMirrorFlip+0x4a>
  case VD55G1_MIRROR_FLIP:
    mode = 3;
3419fc9e:	2303      	movs	r3, #3
3419fca0:	75fb      	strb	r3, [r7, #23]
    break;
3419fca2:	e002      	b.n	3419fcaa <VD55G1_SetupMirrorFlip+0x4a>
  default:
    return -1;
3419fca4:	f04f 33ff 	mov.w	r3, #4294967295
3419fca8:	e024      	b.n	3419fcf4 <VD55G1_SetupMirrorFlip+0x94>
  }

  ret = ctx->write8(ctx, VD55G1_REG_ORIENTATION, mode);
3419fcaa:	687b      	ldr	r3, [r7, #4]
3419fcac:	691b      	ldr	r3, [r3, #16]
3419fcae:	7dfa      	ldrb	r2, [r7, #23]
3419fcb0:	f240 3102 	movw	r1, #770	@ 0x302
3419fcb4:	6878      	ldr	r0, [r7, #4]
3419fcb6:	4798      	blx	r3
3419fcb8:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419fcba:	68fb      	ldr	r3, [r7, #12]
3419fcbc:	2b00      	cmp	r3, #0
3419fcbe:	d00d      	beq.n	3419fcdc <VD55G1_SetupMirrorFlip+0x7c>
3419fcc0:	68fb      	ldr	r3, [r7, #12]
3419fcc2:	9302      	str	r3, [sp, #8]
3419fcc4:	f240 23b2 	movw	r3, #690	@ 0x2b2
3419fcc8:	9301      	str	r3, [sp, #4]
3419fcca:	4b0c      	ldr	r3, [pc, #48]	@ (3419fcfc <VD55G1_SetupMirrorFlip+0x9c>)
3419fccc:	9300      	str	r3, [sp, #0]
3419fcce:	f240 23b2 	movw	r3, #690	@ 0x2b2
3419fcd2:	4a0b      	ldr	r2, [pc, #44]	@ (3419fd00 <VD55G1_SetupMirrorFlip+0xa0>)
3419fcd4:	2100      	movs	r1, #0
3419fcd6:	6878      	ldr	r0, [r7, #4]
3419fcd8:	f7fe ffca 	bl	3419ec70 <VD55G1_log_impl>
3419fcdc:	68fb      	ldr	r3, [r7, #12]
3419fcde:	2b00      	cmp	r3, #0
3419fce0:	d002      	beq.n	3419fce8 <VD55G1_SetupMirrorFlip+0x88>
3419fce2:	6878      	ldr	r0, [r7, #4]
3419fce4:	f7fe ffe0 	bl	3419eca8 <display_error>
3419fce8:	68fb      	ldr	r3, [r7, #12]
3419fcea:	2b00      	cmp	r3, #0
3419fcec:	d001      	beq.n	3419fcf2 <VD55G1_SetupMirrorFlip+0x92>
3419fcee:	68fb      	ldr	r3, [r7, #12]
3419fcf0:	e000      	b.n	3419fcf4 <VD55G1_SetupMirrorFlip+0x94>

  return 0;
3419fcf2:	2300      	movs	r3, #0
}
3419fcf4:	4618      	mov	r0, r3
3419fcf6:	3718      	adds	r7, #24
3419fcf8:	46bd      	mov	sp, r7
3419fcfa:	bd80      	pop	{r7, pc}
3419fcfc:	341a9fdc 	.word	0x341a9fdc
3419fd00:	341a77b8 	.word	0x341a77b8

3419fd04 <VD55G1_SetupPatGen>:

static int VD55G1_SetupPatGen(VD55G1_Ctx_t *ctx)
{
3419fd04:	b580      	push	{r7, lr}
3419fd06:	b08a      	sub	sp, #40	@ 0x28
3419fd08:	af04      	add	r7, sp, #16
3419fd0a:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419fd0c:	687b      	ldr	r3, [r7, #4]
3419fd0e:	3328      	adds	r3, #40	@ 0x28
3419fd10:	613b      	str	r3, [r7, #16]
  uint16_t value = VD55G1_PATGEN_CTRL_DISABLE;
3419fd12:	2300      	movs	r3, #0
3419fd14:	82fb      	strh	r3, [r7, #22]
  int ret;

  switch (drv_ctx->config_save.patgen) {
3419fd16:	693b      	ldr	r3, [r7, #16]
3419fd18:	7e5b      	ldrb	r3, [r3, #25]
3419fd1a:	2b02      	cmp	r3, #2
3419fd1c:	d00d      	beq.n	3419fd3a <VD55G1_SetupPatGen+0x36>
3419fd1e:	2b02      	cmp	r3, #2
3419fd20:	dc0f      	bgt.n	3419fd42 <VD55G1_SetupPatGen+0x3e>
3419fd22:	2b00      	cmp	r3, #0
3419fd24:	d002      	beq.n	3419fd2c <VD55G1_SetupPatGen+0x28>
3419fd26:	2b01      	cmp	r3, #1
3419fd28:	d003      	beq.n	3419fd32 <VD55G1_SetupPatGen+0x2e>
3419fd2a:	e00a      	b.n	3419fd42 <VD55G1_SetupPatGen+0x3e>
  case VD55G1_PATGEN_DISABLE:
    value = VD55G1_PATGEN_CTRL_DISABLE;
3419fd2c:	2300      	movs	r3, #0
3419fd2e:	82fb      	strh	r3, [r7, #22]
    break;
3419fd30:	e00a      	b.n	3419fd48 <VD55G1_SetupPatGen+0x44>
  case VD55G1_PATGEN_DIAGONAL_GRAYSCALE:
    value = VD55G1_PATGEN_CTRL_DIAG_GRAY;
3419fd32:	f240 2321 	movw	r3, #545	@ 0x221
3419fd36:	82fb      	strh	r3, [r7, #22]
    break;
3419fd38:	e006      	b.n	3419fd48 <VD55G1_SetupPatGen+0x44>
  case VD55G1_PATGEN_PSEUDO_RANDOM:
    value = VD55G1_PATGEN_CTRL_PSN;
3419fd3a:	f240 2381 	movw	r3, #641	@ 0x281
3419fd3e:	82fb      	strh	r3, [r7, #22]
    break;
3419fd40:	e002      	b.n	3419fd48 <VD55G1_SetupPatGen+0x44>
  default:
    return -1;
3419fd42:	f04f 33ff 	mov.w	r3, #4294967295
3419fd46:	e070      	b.n	3419fe2a <VD55G1_SetupPatGen+0x126>
  }

  if (drv_ctx->config_save.patgen != VD55G1_PATGEN_CTRL_DISABLE)
3419fd48:	693b      	ldr	r3, [r7, #16]
3419fd4a:	7e5b      	ldrb	r3, [r3, #25]
3419fd4c:	2b00      	cmp	r3, #0
3419fd4e:	d047      	beq.n	3419fde0 <VD55G1_SetupPatGen+0xdc>
  {
    ret = ctx->write8(ctx, VD55G1_REG_DUSTER_CTRL, VD55G1_DUSTER_DISABLE);
3419fd50:	687b      	ldr	r3, [r7, #4]
3419fd52:	691b      	ldr	r3, [r3, #16]
3419fd54:	2200      	movs	r2, #0
3419fd56:	f240 31ae 	movw	r1, #942	@ 0x3ae
3419fd5a:	6878      	ldr	r0, [r7, #4]
3419fd5c:	4798      	blx	r3
3419fd5e:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419fd60:	68fb      	ldr	r3, [r7, #12]
3419fd62:	2b00      	cmp	r3, #0
3419fd64:	d00d      	beq.n	3419fd82 <VD55G1_SetupPatGen+0x7e>
3419fd66:	68fb      	ldr	r3, [r7, #12]
3419fd68:	9302      	str	r3, [sp, #8]
3419fd6a:	f240 23ce 	movw	r3, #718	@ 0x2ce
3419fd6e:	9301      	str	r3, [sp, #4]
3419fd70:	4b30      	ldr	r3, [pc, #192]	@ (3419fe34 <VD55G1_SetupPatGen+0x130>)
3419fd72:	9300      	str	r3, [sp, #0]
3419fd74:	f240 23ce 	movw	r3, #718	@ 0x2ce
3419fd78:	4a2f      	ldr	r2, [pc, #188]	@ (3419fe38 <VD55G1_SetupPatGen+0x134>)
3419fd7a:	2100      	movs	r1, #0
3419fd7c:	6878      	ldr	r0, [r7, #4]
3419fd7e:	f7fe ff77 	bl	3419ec70 <VD55G1_log_impl>
3419fd82:	68fb      	ldr	r3, [r7, #12]
3419fd84:	2b00      	cmp	r3, #0
3419fd86:	d002      	beq.n	3419fd8e <VD55G1_SetupPatGen+0x8a>
3419fd88:	6878      	ldr	r0, [r7, #4]
3419fd8a:	f7fe ff8d 	bl	3419eca8 <display_error>
3419fd8e:	68fb      	ldr	r3, [r7, #12]
3419fd90:	2b00      	cmp	r3, #0
3419fd92:	d001      	beq.n	3419fd98 <VD55G1_SetupPatGen+0x94>
3419fd94:	68fb      	ldr	r3, [r7, #12]
3419fd96:	e048      	b.n	3419fe2a <VD55G1_SetupPatGen+0x126>
    ret = ctx->write8(ctx, VD55G1_REG_DARKCAL_CTRL, VD55G1_DARKCAL_BYPASS_DARKAVG);
3419fd98:	687b      	ldr	r3, [r7, #4]
3419fd9a:	691b      	ldr	r3, [r3, #16]
3419fd9c:	2202      	movs	r2, #2
3419fd9e:	f240 312a 	movw	r1, #810	@ 0x32a
3419fda2:	6878      	ldr	r0, [r7, #4]
3419fda4:	4798      	blx	r3
3419fda6:	60f8      	str	r0, [r7, #12]
    VD55G1_TraceError(ctx, ret);
3419fda8:	68fb      	ldr	r3, [r7, #12]
3419fdaa:	2b00      	cmp	r3, #0
3419fdac:	d00d      	beq.n	3419fdca <VD55G1_SetupPatGen+0xc6>
3419fdae:	68fb      	ldr	r3, [r7, #12]
3419fdb0:	9302      	str	r3, [sp, #8]
3419fdb2:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
3419fdb6:	9301      	str	r3, [sp, #4]
3419fdb8:	4b1e      	ldr	r3, [pc, #120]	@ (3419fe34 <VD55G1_SetupPatGen+0x130>)
3419fdba:	9300      	str	r3, [sp, #0]
3419fdbc:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
3419fdc0:	4a1d      	ldr	r2, [pc, #116]	@ (3419fe38 <VD55G1_SetupPatGen+0x134>)
3419fdc2:	2100      	movs	r1, #0
3419fdc4:	6878      	ldr	r0, [r7, #4]
3419fdc6:	f7fe ff53 	bl	3419ec70 <VD55G1_log_impl>
3419fdca:	68fb      	ldr	r3, [r7, #12]
3419fdcc:	2b00      	cmp	r3, #0
3419fdce:	d002      	beq.n	3419fdd6 <VD55G1_SetupPatGen+0xd2>
3419fdd0:	6878      	ldr	r0, [r7, #4]
3419fdd2:	f7fe ff69 	bl	3419eca8 <display_error>
3419fdd6:	68fb      	ldr	r3, [r7, #12]
3419fdd8:	2b00      	cmp	r3, #0
3419fdda:	d001      	beq.n	3419fde0 <VD55G1_SetupPatGen+0xdc>
3419fddc:	68fb      	ldr	r3, [r7, #12]
3419fdde:	e024      	b.n	3419fe2a <VD55G1_SetupPatGen+0x126>
  }

  ret = ctx->write16(ctx, VD55G1_REG_PATGEN_CTRL, value);
3419fde0:	687b      	ldr	r3, [r7, #4]
3419fde2:	695b      	ldr	r3, [r3, #20]
3419fde4:	8afa      	ldrh	r2, [r7, #22]
3419fde6:	f44f 7141 	mov.w	r1, #772	@ 0x304
3419fdea:	6878      	ldr	r0, [r7, #4]
3419fdec:	4798      	blx	r3
3419fdee:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419fdf0:	68fb      	ldr	r3, [r7, #12]
3419fdf2:	2b00      	cmp	r3, #0
3419fdf4:	d00d      	beq.n	3419fe12 <VD55G1_SetupPatGen+0x10e>
3419fdf6:	68fb      	ldr	r3, [r7, #12]
3419fdf8:	9302      	str	r3, [sp, #8]
3419fdfa:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
3419fdfe:	9301      	str	r3, [sp, #4]
3419fe00:	4b0c      	ldr	r3, [pc, #48]	@ (3419fe34 <VD55G1_SetupPatGen+0x130>)
3419fe02:	9300      	str	r3, [sp, #0]
3419fe04:	f44f 7335 	mov.w	r3, #724	@ 0x2d4
3419fe08:	4a0b      	ldr	r2, [pc, #44]	@ (3419fe38 <VD55G1_SetupPatGen+0x134>)
3419fe0a:	2100      	movs	r1, #0
3419fe0c:	6878      	ldr	r0, [r7, #4]
3419fe0e:	f7fe ff2f 	bl	3419ec70 <VD55G1_log_impl>
3419fe12:	68fb      	ldr	r3, [r7, #12]
3419fe14:	2b00      	cmp	r3, #0
3419fe16:	d002      	beq.n	3419fe1e <VD55G1_SetupPatGen+0x11a>
3419fe18:	6878      	ldr	r0, [r7, #4]
3419fe1a:	f7fe ff45 	bl	3419eca8 <display_error>
3419fe1e:	68fb      	ldr	r3, [r7, #12]
3419fe20:	2b00      	cmp	r3, #0
3419fe22:	d001      	beq.n	3419fe28 <VD55G1_SetupPatGen+0x124>
3419fe24:	68fb      	ldr	r3, [r7, #12]
3419fe26:	e000      	b.n	3419fe2a <VD55G1_SetupPatGen+0x126>

  return 0;
3419fe28:	2300      	movs	r3, #0
}
3419fe2a:	4618      	mov	r0, r3
3419fe2c:	3718      	adds	r7, #24
3419fe2e:	46bd      	mov	sp, r7
3419fe30:	bd80      	pop	{r7, pc}
3419fe32:	bf00      	nop
3419fe34:	341a9ff4 	.word	0x341a9ff4
3419fe38:	341a77b8 	.word	0x341a77b8

3419fe3c <VD55G1_SetFlicker>:

static int VD55G1_SetFlicker(VD55G1_Ctx_t *ctx, VD55G1_Flicker_t flicker)
{
3419fe3c:	b580      	push	{r7, lr}
3419fe3e:	b088      	sub	sp, #32
3419fe40:	af04      	add	r7, sp, #16
3419fe42:	6078      	str	r0, [r7, #4]
3419fe44:	460b      	mov	r3, r1
3419fe46:	70fb      	strb	r3, [r7, #3]
  uint16_t mode;
  int ret;

  switch (flicker) {
3419fe48:	78fb      	ldrb	r3, [r7, #3]
3419fe4a:	2b02      	cmp	r3, #2
3419fe4c:	d00c      	beq.n	3419fe68 <VD55G1_SetFlicker+0x2c>
3419fe4e:	2b02      	cmp	r3, #2
3419fe50:	dc0d      	bgt.n	3419fe6e <VD55G1_SetFlicker+0x32>
3419fe52:	2b00      	cmp	r3, #0
3419fe54:	d002      	beq.n	3419fe5c <VD55G1_SetFlicker+0x20>
3419fe56:	2b01      	cmp	r3, #1
3419fe58:	d003      	beq.n	3419fe62 <VD55G1_SetFlicker+0x26>
3419fe5a:	e008      	b.n	3419fe6e <VD55G1_SetFlicker+0x32>
  case VD55G1_FLICKER_FREE_NONE:
    mode = 0;
3419fe5c:	2300      	movs	r3, #0
3419fe5e:	81fb      	strh	r3, [r7, #14]
    break;
3419fe60:	e008      	b.n	3419fe74 <VD55G1_SetFlicker+0x38>
  case VD55G1_FLICKER_FREE_50HZ:
    mode = 1;
3419fe62:	2301      	movs	r3, #1
3419fe64:	81fb      	strh	r3, [r7, #14]
    break;
3419fe66:	e005      	b.n	3419fe74 <VD55G1_SetFlicker+0x38>
  case VD55G1_FLICKER_FREE_60HZ:
    mode = 3;
3419fe68:	2303      	movs	r3, #3
3419fe6a:	81fb      	strh	r3, [r7, #14]
    break;
3419fe6c:	e002      	b.n	3419fe74 <VD55G1_SetFlicker+0x38>
  default:
    return -1;
3419fe6e:	f04f 33ff 	mov.w	r3, #4294967295
3419fe72:	e024      	b.n	3419febe <VD55G1_SetFlicker+0x82>
  }

  ret = ctx->write16(ctx, VD55G1_REG_EXPOSURE_COMPILER_CONTROL_A, mode);
3419fe74:	687b      	ldr	r3, [r7, #4]
3419fe76:	695b      	ldr	r3, [r3, #20]
3419fe78:	89fa      	ldrh	r2, [r7, #14]
3419fe7a:	f240 4182 	movw	r1, #1154	@ 0x482
3419fe7e:	6878      	ldr	r0, [r7, #4]
3419fe80:	4798      	blx	r3
3419fe82:	60b8      	str	r0, [r7, #8]
  VD55G1_TraceError(ctx, ret);
3419fe84:	68bb      	ldr	r3, [r7, #8]
3419fe86:	2b00      	cmp	r3, #0
3419fe88:	d00d      	beq.n	3419fea6 <VD55G1_SetFlicker+0x6a>
3419fe8a:	68bb      	ldr	r3, [r7, #8]
3419fe8c:	9302      	str	r3, [sp, #8]
3419fe8e:	f240 23ed 	movw	r3, #749	@ 0x2ed
3419fe92:	9301      	str	r3, [sp, #4]
3419fe94:	4b0c      	ldr	r3, [pc, #48]	@ (3419fec8 <VD55G1_SetFlicker+0x8c>)
3419fe96:	9300      	str	r3, [sp, #0]
3419fe98:	f240 23ed 	movw	r3, #749	@ 0x2ed
3419fe9c:	4a0b      	ldr	r2, [pc, #44]	@ (3419fecc <VD55G1_SetFlicker+0x90>)
3419fe9e:	2100      	movs	r1, #0
3419fea0:	6878      	ldr	r0, [r7, #4]
3419fea2:	f7fe fee5 	bl	3419ec70 <VD55G1_log_impl>
3419fea6:	68bb      	ldr	r3, [r7, #8]
3419fea8:	2b00      	cmp	r3, #0
3419feaa:	d002      	beq.n	3419feb2 <VD55G1_SetFlicker+0x76>
3419feac:	6878      	ldr	r0, [r7, #4]
3419feae:	f7fe fefb 	bl	3419eca8 <display_error>
3419feb2:	68bb      	ldr	r3, [r7, #8]
3419feb4:	2b00      	cmp	r3, #0
3419feb6:	d001      	beq.n	3419febc <VD55G1_SetFlicker+0x80>
3419feb8:	68bb      	ldr	r3, [r7, #8]
3419feba:	e000      	b.n	3419febe <VD55G1_SetFlicker+0x82>

  return 0;
3419febc:	2300      	movs	r3, #0
}
3419febe:	4618      	mov	r0, r3
3419fec0:	3710      	adds	r7, #16
3419fec2:	46bd      	mov	sp, r7
3419fec4:	bd80      	pop	{r7, pc}
3419fec6:	bf00      	nop
3419fec8:	341aa008 	.word	0x341aa008
3419fecc:	341a77b8 	.word	0x341a77b8

3419fed0 <VD55G1_Flicker>:

static int VD55G1_Flicker(VD55G1_Ctx_t *ctx)
{
3419fed0:	b580      	push	{r7, lr}
3419fed2:	b084      	sub	sp, #16
3419fed4:	af00      	add	r7, sp, #0
3419fed6:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
3419fed8:	687b      	ldr	r3, [r7, #4]
3419feda:	3328      	adds	r3, #40	@ 0x28
3419fedc:	60fb      	str	r3, [r7, #12]

  return VD55G1_SetFlicker(ctx, drv_ctx->config_save.flicker);
3419fede:	68fb      	ldr	r3, [r7, #12]
3419fee0:	7e9b      	ldrb	r3, [r3, #26]
3419fee2:	4619      	mov	r1, r3
3419fee4:	6878      	ldr	r0, [r7, #4]
3419fee6:	f7ff ffa9 	bl	3419fe3c <VD55G1_SetFlicker>
3419feea:	4603      	mov	r3, r0
}
3419feec:	4618      	mov	r0, r3
3419feee:	3710      	adds	r7, #16
3419fef0:	46bd      	mov	sp, r7
3419fef2:	bd80      	pop	{r7, pc}

3419fef4 <VD55G1_Setup>:

static int VD55G1_Setup(VD55G1_Ctx_t *ctx)
{
3419fef4:	b580      	push	{r7, lr}
3419fef6:	b088      	sub	sp, #32
3419fef8:	af04      	add	r7, sp, #16
3419fefa:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD55G1_SetupClocks(ctx);
3419fefc:	6878      	ldr	r0, [r7, #4]
3419fefe:	f7ff faa9 	bl	3419f454 <VD55G1_SetupClocks>
3419ff02:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ff04:	68fb      	ldr	r3, [r7, #12]
3419ff06:	2b00      	cmp	r3, #0
3419ff08:	d00d      	beq.n	3419ff26 <VD55G1_Setup+0x32>
3419ff0a:	68fb      	ldr	r3, [r7, #12]
3419ff0c:	9302      	str	r3, [sp, #8]
3419ff0e:	f240 23fe 	movw	r3, #766	@ 0x2fe
3419ff12:	9301      	str	r3, [sp, #4]
3419ff14:	4b7c      	ldr	r3, [pc, #496]	@ (341a0108 <VD55G1_Setup+0x214>)
3419ff16:	9300      	str	r3, [sp, #0]
3419ff18:	f240 23fe 	movw	r3, #766	@ 0x2fe
3419ff1c:	4a7b      	ldr	r2, [pc, #492]	@ (341a010c <VD55G1_Setup+0x218>)
3419ff1e:	2100      	movs	r1, #0
3419ff20:	6878      	ldr	r0, [r7, #4]
3419ff22:	f7fe fea5 	bl	3419ec70 <VD55G1_log_impl>
3419ff26:	68fb      	ldr	r3, [r7, #12]
3419ff28:	2b00      	cmp	r3, #0
3419ff2a:	d002      	beq.n	3419ff32 <VD55G1_Setup+0x3e>
3419ff2c:	6878      	ldr	r0, [r7, #4]
3419ff2e:	f7fe febb 	bl	3419eca8 <display_error>
3419ff32:	68fb      	ldr	r3, [r7, #12]
3419ff34:	2b00      	cmp	r3, #0
3419ff36:	d001      	beq.n	3419ff3c <VD55G1_Setup+0x48>
3419ff38:	68fb      	ldr	r3, [r7, #12]
3419ff3a:	e0e0      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupOutput(ctx);
3419ff3c:	6878      	ldr	r0, [r7, #4]
3419ff3e:	f7ff fb01 	bl	3419f544 <VD55G1_SetupOutput>
3419ff42:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ff44:	68fb      	ldr	r3, [r7, #12]
3419ff46:	2b00      	cmp	r3, #0
3419ff48:	d00d      	beq.n	3419ff66 <VD55G1_Setup+0x72>
3419ff4a:	68fb      	ldr	r3, [r7, #12]
3419ff4c:	9302      	str	r3, [sp, #8]
3419ff4e:	f240 3301 	movw	r3, #769	@ 0x301
3419ff52:	9301      	str	r3, [sp, #4]
3419ff54:	4b6c      	ldr	r3, [pc, #432]	@ (341a0108 <VD55G1_Setup+0x214>)
3419ff56:	9300      	str	r3, [sp, #0]
3419ff58:	f240 3301 	movw	r3, #769	@ 0x301
3419ff5c:	4a6b      	ldr	r2, [pc, #428]	@ (341a010c <VD55G1_Setup+0x218>)
3419ff5e:	2100      	movs	r1, #0
3419ff60:	6878      	ldr	r0, [r7, #4]
3419ff62:	f7fe fe85 	bl	3419ec70 <VD55G1_log_impl>
3419ff66:	68fb      	ldr	r3, [r7, #12]
3419ff68:	2b00      	cmp	r3, #0
3419ff6a:	d002      	beq.n	3419ff72 <VD55G1_Setup+0x7e>
3419ff6c:	6878      	ldr	r0, [r7, #4]
3419ff6e:	f7fe fe9b 	bl	3419eca8 <display_error>
3419ff72:	68fb      	ldr	r3, [r7, #12]
3419ff74:	2b00      	cmp	r3, #0
3419ff76:	d001      	beq.n	3419ff7c <VD55G1_Setup+0x88>
3419ff78:	68fb      	ldr	r3, [r7, #12]
3419ff7a:	e0c0      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupSize(ctx);
3419ff7c:	6878      	ldr	r0, [r7, #4]
3419ff7e:	f7ff fb7f 	bl	3419f680 <VD55G1_SetupSize>
3419ff82:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ff84:	68fb      	ldr	r3, [r7, #12]
3419ff86:	2b00      	cmp	r3, #0
3419ff88:	d00d      	beq.n	3419ffa6 <VD55G1_Setup+0xb2>
3419ff8a:	68fb      	ldr	r3, [r7, #12]
3419ff8c:	9302      	str	r3, [sp, #8]
3419ff8e:	f44f 7341 	mov.w	r3, #772	@ 0x304
3419ff92:	9301      	str	r3, [sp, #4]
3419ff94:	4b5c      	ldr	r3, [pc, #368]	@ (341a0108 <VD55G1_Setup+0x214>)
3419ff96:	9300      	str	r3, [sp, #0]
3419ff98:	f44f 7341 	mov.w	r3, #772	@ 0x304
3419ff9c:	4a5b      	ldr	r2, [pc, #364]	@ (341a010c <VD55G1_Setup+0x218>)
3419ff9e:	2100      	movs	r1, #0
3419ffa0:	6878      	ldr	r0, [r7, #4]
3419ffa2:	f7fe fe65 	bl	3419ec70 <VD55G1_log_impl>
3419ffa6:	68fb      	ldr	r3, [r7, #12]
3419ffa8:	2b00      	cmp	r3, #0
3419ffaa:	d002      	beq.n	3419ffb2 <VD55G1_Setup+0xbe>
3419ffac:	6878      	ldr	r0, [r7, #4]
3419ffae:	f7fe fe7b 	bl	3419eca8 <display_error>
3419ffb2:	68fb      	ldr	r3, [r7, #12]
3419ffb4:	2b00      	cmp	r3, #0
3419ffb6:	d001      	beq.n	3419ffbc <VD55G1_Setup+0xc8>
3419ffb8:	68fb      	ldr	r3, [r7, #12]
3419ffba:	e0a0      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupFrameRate(ctx);
3419ffbc:	6878      	ldr	r0, [r7, #4]
3419ffbe:	f7ff fd5d 	bl	3419fa7c <VD55G1_SetupFrameRate>
3419ffc2:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
3419ffc4:	68fb      	ldr	r3, [r7, #12]
3419ffc6:	2b00      	cmp	r3, #0
3419ffc8:	d00d      	beq.n	3419ffe6 <VD55G1_Setup+0xf2>
3419ffca:	68fb      	ldr	r3, [r7, #12]
3419ffcc:	9302      	str	r3, [sp, #8]
3419ffce:	f240 3307 	movw	r3, #775	@ 0x307
3419ffd2:	9301      	str	r3, [sp, #4]
3419ffd4:	4b4c      	ldr	r3, [pc, #304]	@ (341a0108 <VD55G1_Setup+0x214>)
3419ffd6:	9300      	str	r3, [sp, #0]
3419ffd8:	f240 3307 	movw	r3, #775	@ 0x307
3419ffdc:	4a4b      	ldr	r2, [pc, #300]	@ (341a010c <VD55G1_Setup+0x218>)
3419ffde:	2100      	movs	r1, #0
3419ffe0:	6878      	ldr	r0, [r7, #4]
3419ffe2:	f7fe fe45 	bl	3419ec70 <VD55G1_log_impl>
3419ffe6:	68fb      	ldr	r3, [r7, #12]
3419ffe8:	2b00      	cmp	r3, #0
3419ffea:	d002      	beq.n	3419fff2 <VD55G1_Setup+0xfe>
3419ffec:	6878      	ldr	r0, [r7, #4]
3419ffee:	f7fe fe5b 	bl	3419eca8 <display_error>
3419fff2:	68fb      	ldr	r3, [r7, #12]
3419fff4:	2b00      	cmp	r3, #0
3419fff6:	d001      	beq.n	3419fffc <VD55G1_Setup+0x108>
3419fff8:	68fb      	ldr	r3, [r7, #12]
3419fffa:	e080      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupExposure(ctx);
3419fffc:	6878      	ldr	r0, [r7, #4]
3419fffe:	f7ff fd99 	bl	3419fb34 <VD55G1_SetupExposure>
341a0002:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a0004:	68fb      	ldr	r3, [r7, #12]
341a0006:	2b00      	cmp	r3, #0
341a0008:	d00d      	beq.n	341a0026 <VD55G1_Setup+0x132>
341a000a:	68fb      	ldr	r3, [r7, #12]
341a000c:	9302      	str	r3, [sp, #8]
341a000e:	f240 330a 	movw	r3, #778	@ 0x30a
341a0012:	9301      	str	r3, [sp, #4]
341a0014:	4b3c      	ldr	r3, [pc, #240]	@ (341a0108 <VD55G1_Setup+0x214>)
341a0016:	9300      	str	r3, [sp, #0]
341a0018:	f240 330a 	movw	r3, #778	@ 0x30a
341a001c:	4a3b      	ldr	r2, [pc, #236]	@ (341a010c <VD55G1_Setup+0x218>)
341a001e:	2100      	movs	r1, #0
341a0020:	6878      	ldr	r0, [r7, #4]
341a0022:	f7fe fe25 	bl	3419ec70 <VD55G1_log_impl>
341a0026:	68fb      	ldr	r3, [r7, #12]
341a0028:	2b00      	cmp	r3, #0
341a002a:	d002      	beq.n	341a0032 <VD55G1_Setup+0x13e>
341a002c:	6878      	ldr	r0, [r7, #4]
341a002e:	f7fe fe3b 	bl	3419eca8 <display_error>
341a0032:	68fb      	ldr	r3, [r7, #12]
341a0034:	2b00      	cmp	r3, #0
341a0036:	d001      	beq.n	341a003c <VD55G1_Setup+0x148>
341a0038:	68fb      	ldr	r3, [r7, #12]
341a003a:	e060      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupMirrorFlip(ctx);
341a003c:	6878      	ldr	r0, [r7, #4]
341a003e:	f7ff fe0f 	bl	3419fc60 <VD55G1_SetupMirrorFlip>
341a0042:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a0044:	68fb      	ldr	r3, [r7, #12]
341a0046:	2b00      	cmp	r3, #0
341a0048:	d00d      	beq.n	341a0066 <VD55G1_Setup+0x172>
341a004a:	68fb      	ldr	r3, [r7, #12]
341a004c:	9302      	str	r3, [sp, #8]
341a004e:	f240 330d 	movw	r3, #781	@ 0x30d
341a0052:	9301      	str	r3, [sp, #4]
341a0054:	4b2c      	ldr	r3, [pc, #176]	@ (341a0108 <VD55G1_Setup+0x214>)
341a0056:	9300      	str	r3, [sp, #0]
341a0058:	f240 330d 	movw	r3, #781	@ 0x30d
341a005c:	4a2b      	ldr	r2, [pc, #172]	@ (341a010c <VD55G1_Setup+0x218>)
341a005e:	2100      	movs	r1, #0
341a0060:	6878      	ldr	r0, [r7, #4]
341a0062:	f7fe fe05 	bl	3419ec70 <VD55G1_log_impl>
341a0066:	68fb      	ldr	r3, [r7, #12]
341a0068:	2b00      	cmp	r3, #0
341a006a:	d002      	beq.n	341a0072 <VD55G1_Setup+0x17e>
341a006c:	6878      	ldr	r0, [r7, #4]
341a006e:	f7fe fe1b 	bl	3419eca8 <display_error>
341a0072:	68fb      	ldr	r3, [r7, #12]
341a0074:	2b00      	cmp	r3, #0
341a0076:	d001      	beq.n	341a007c <VD55G1_Setup+0x188>
341a0078:	68fb      	ldr	r3, [r7, #12]
341a007a:	e040      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_SetupPatGen(ctx);
341a007c:	6878      	ldr	r0, [r7, #4]
341a007e:	f7ff fe41 	bl	3419fd04 <VD55G1_SetupPatGen>
341a0082:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a0084:	68fb      	ldr	r3, [r7, #12]
341a0086:	2b00      	cmp	r3, #0
341a0088:	d00d      	beq.n	341a00a6 <VD55G1_Setup+0x1b2>
341a008a:	68fb      	ldr	r3, [r7, #12]
341a008c:	9302      	str	r3, [sp, #8]
341a008e:	f44f 7344 	mov.w	r3, #784	@ 0x310
341a0092:	9301      	str	r3, [sp, #4]
341a0094:	4b1c      	ldr	r3, [pc, #112]	@ (341a0108 <VD55G1_Setup+0x214>)
341a0096:	9300      	str	r3, [sp, #0]
341a0098:	f44f 7344 	mov.w	r3, #784	@ 0x310
341a009c:	4a1b      	ldr	r2, [pc, #108]	@ (341a010c <VD55G1_Setup+0x218>)
341a009e:	2100      	movs	r1, #0
341a00a0:	6878      	ldr	r0, [r7, #4]
341a00a2:	f7fe fde5 	bl	3419ec70 <VD55G1_log_impl>
341a00a6:	68fb      	ldr	r3, [r7, #12]
341a00a8:	2b00      	cmp	r3, #0
341a00aa:	d002      	beq.n	341a00b2 <VD55G1_Setup+0x1be>
341a00ac:	6878      	ldr	r0, [r7, #4]
341a00ae:	f7fe fdfb 	bl	3419eca8 <display_error>
341a00b2:	68fb      	ldr	r3, [r7, #12]
341a00b4:	2b00      	cmp	r3, #0
341a00b6:	d001      	beq.n	341a00bc <VD55G1_Setup+0x1c8>
341a00b8:	68fb      	ldr	r3, [r7, #12]
341a00ba:	e020      	b.n	341a00fe <VD55G1_Setup+0x20a>

  ret = VD55G1_Flicker(ctx);
341a00bc:	6878      	ldr	r0, [r7, #4]
341a00be:	f7ff ff07 	bl	3419fed0 <VD55G1_Flicker>
341a00c2:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a00c4:	68fb      	ldr	r3, [r7, #12]
341a00c6:	2b00      	cmp	r3, #0
341a00c8:	d00d      	beq.n	341a00e6 <VD55G1_Setup+0x1f2>
341a00ca:	68fb      	ldr	r3, [r7, #12]
341a00cc:	9302      	str	r3, [sp, #8]
341a00ce:	f240 3313 	movw	r3, #787	@ 0x313
341a00d2:	9301      	str	r3, [sp, #4]
341a00d4:	4b0c      	ldr	r3, [pc, #48]	@ (341a0108 <VD55G1_Setup+0x214>)
341a00d6:	9300      	str	r3, [sp, #0]
341a00d8:	f240 3313 	movw	r3, #787	@ 0x313
341a00dc:	4a0b      	ldr	r2, [pc, #44]	@ (341a010c <VD55G1_Setup+0x218>)
341a00de:	2100      	movs	r1, #0
341a00e0:	6878      	ldr	r0, [r7, #4]
341a00e2:	f7fe fdc5 	bl	3419ec70 <VD55G1_log_impl>
341a00e6:	68fb      	ldr	r3, [r7, #12]
341a00e8:	2b00      	cmp	r3, #0
341a00ea:	d002      	beq.n	341a00f2 <VD55G1_Setup+0x1fe>
341a00ec:	6878      	ldr	r0, [r7, #4]
341a00ee:	f7fe fddb 	bl	3419eca8 <display_error>
341a00f2:	68fb      	ldr	r3, [r7, #12]
341a00f4:	2b00      	cmp	r3, #0
341a00f6:	d001      	beq.n	341a00fc <VD55G1_Setup+0x208>
341a00f8:	68fb      	ldr	r3, [r7, #12]
341a00fa:	e000      	b.n	341a00fe <VD55G1_Setup+0x20a>

  return 0;
341a00fc:	2300      	movs	r3, #0
}
341a00fe:	4618      	mov	r0, r3
341a0100:	3710      	adds	r7, #16
341a0102:	46bd      	mov	sp, r7
341a0104:	bd80      	pop	{r7, pc}
341a0106:	bf00      	nop
341a0108:	341aa01c 	.word	0x341aa01c
341a010c:	341a77b8 	.word	0x341a77b8

341a0110 <VD55G1_StartStreaming>:

static int VD55G1_StartStreaming(VD55G1_Ctx_t *ctx)
{
341a0110:	b580      	push	{r7, lr}
341a0112:	b088      	sub	sp, #32
341a0114:	af04      	add	r7, sp, #16
341a0116:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STBY, VD55G1_STBY_START_STREAM);
341a0118:	687b      	ldr	r3, [r7, #4]
341a011a:	691b      	ldr	r3, [r3, #16]
341a011c:	2201      	movs	r2, #1
341a011e:	f240 2101 	movw	r1, #513	@ 0x201
341a0122:	6878      	ldr	r0, [r7, #4]
341a0124:	4798      	blx	r3
341a0126:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a0128:	68fb      	ldr	r3, [r7, #12]
341a012a:	2b00      	cmp	r3, #0
341a012c:	d00d      	beq.n	341a014a <VD55G1_StartStreaming+0x3a>
341a012e:	68fb      	ldr	r3, [r7, #12]
341a0130:	9302      	str	r3, [sp, #8]
341a0132:	f240 331d 	movw	r3, #797	@ 0x31d
341a0136:	9301      	str	r3, [sp, #4]
341a0138:	4b31      	ldr	r3, [pc, #196]	@ (341a0200 <VD55G1_StartStreaming+0xf0>)
341a013a:	9300      	str	r3, [sp, #0]
341a013c:	f240 331d 	movw	r3, #797	@ 0x31d
341a0140:	4a30      	ldr	r2, [pc, #192]	@ (341a0204 <VD55G1_StartStreaming+0xf4>)
341a0142:	2100      	movs	r1, #0
341a0144:	6878      	ldr	r0, [r7, #4]
341a0146:	f7fe fd93 	bl	3419ec70 <VD55G1_log_impl>
341a014a:	68fb      	ldr	r3, [r7, #12]
341a014c:	2b00      	cmp	r3, #0
341a014e:	d002      	beq.n	341a0156 <VD55G1_StartStreaming+0x46>
341a0150:	6878      	ldr	r0, [r7, #4]
341a0152:	f7fe fda9 	bl	3419eca8 <display_error>
341a0156:	68fb      	ldr	r3, [r7, #12]
341a0158:	2b00      	cmp	r3, #0
341a015a:	d001      	beq.n	341a0160 <VD55G1_StartStreaming+0x50>
341a015c:	68fb      	ldr	r3, [r7, #12]
341a015e:	e04b      	b.n	341a01f8 <VD55G1_StartStreaming+0xe8>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STBY, VD55G1_CMD_ACK);
341a0160:	2200      	movs	r2, #0
341a0162:	f240 2101 	movw	r1, #513	@ 0x201
341a0166:	6878      	ldr	r0, [r7, #4]
341a0168:	f7fe fdc8 	bl	3419ecfc <VD55G1_PollReg8>
341a016c:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a016e:	68fb      	ldr	r3, [r7, #12]
341a0170:	2b00      	cmp	r3, #0
341a0172:	d00d      	beq.n	341a0190 <VD55G1_StartStreaming+0x80>
341a0174:	68fb      	ldr	r3, [r7, #12]
341a0176:	9302      	str	r3, [sp, #8]
341a0178:	f44f 7348 	mov.w	r3, #800	@ 0x320
341a017c:	9301      	str	r3, [sp, #4]
341a017e:	4b20      	ldr	r3, [pc, #128]	@ (341a0200 <VD55G1_StartStreaming+0xf0>)
341a0180:	9300      	str	r3, [sp, #0]
341a0182:	f44f 7348 	mov.w	r3, #800	@ 0x320
341a0186:	4a1f      	ldr	r2, [pc, #124]	@ (341a0204 <VD55G1_StartStreaming+0xf4>)
341a0188:	2100      	movs	r1, #0
341a018a:	6878      	ldr	r0, [r7, #4]
341a018c:	f7fe fd70 	bl	3419ec70 <VD55G1_log_impl>
341a0190:	68fb      	ldr	r3, [r7, #12]
341a0192:	2b00      	cmp	r3, #0
341a0194:	d002      	beq.n	341a019c <VD55G1_StartStreaming+0x8c>
341a0196:	6878      	ldr	r0, [r7, #4]
341a0198:	f7fe fd86 	bl	3419eca8 <display_error>
341a019c:	68fb      	ldr	r3, [r7, #12]
341a019e:	2b00      	cmp	r3, #0
341a01a0:	d001      	beq.n	341a01a6 <VD55G1_StartStreaming+0x96>
341a01a2:	68fb      	ldr	r3, [r7, #12]
341a01a4:	e028      	b.n	341a01f8 <VD55G1_StartStreaming+0xe8>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_STREAMING);
341a01a6:	2103      	movs	r1, #3
341a01a8:	6878      	ldr	r0, [r7, #4]
341a01aa:	f7fe fe07 	bl	3419edbc <VD55G1_WaitState>
341a01ae:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a01b0:	68fb      	ldr	r3, [r7, #12]
341a01b2:	2b00      	cmp	r3, #0
341a01b4:	d00d      	beq.n	341a01d2 <VD55G1_StartStreaming+0xc2>
341a01b6:	68fb      	ldr	r3, [r7, #12]
341a01b8:	9302      	str	r3, [sp, #8]
341a01ba:	f240 3323 	movw	r3, #803	@ 0x323
341a01be:	9301      	str	r3, [sp, #4]
341a01c0:	4b0f      	ldr	r3, [pc, #60]	@ (341a0200 <VD55G1_StartStreaming+0xf0>)
341a01c2:	9300      	str	r3, [sp, #0]
341a01c4:	f240 3323 	movw	r3, #803	@ 0x323
341a01c8:	4a0e      	ldr	r2, [pc, #56]	@ (341a0204 <VD55G1_StartStreaming+0xf4>)
341a01ca:	2100      	movs	r1, #0
341a01cc:	6878      	ldr	r0, [r7, #4]
341a01ce:	f7fe fd4f 	bl	3419ec70 <VD55G1_log_impl>
341a01d2:	68fb      	ldr	r3, [r7, #12]
341a01d4:	2b00      	cmp	r3, #0
341a01d6:	d002      	beq.n	341a01de <VD55G1_StartStreaming+0xce>
341a01d8:	6878      	ldr	r0, [r7, #4]
341a01da:	f7fe fd65 	bl	3419eca8 <display_error>
341a01de:	68fb      	ldr	r3, [r7, #12]
341a01e0:	2b00      	cmp	r3, #0
341a01e2:	d001      	beq.n	341a01e8 <VD55G1_StartStreaming+0xd8>
341a01e4:	68fb      	ldr	r3, [r7, #12]
341a01e6:	e007      	b.n	341a01f8 <VD55G1_StartStreaming+0xe8>

  VD55G1_notice(ctx, "Streaming is on\n");
341a01e8:	f240 3325 	movw	r3, #805	@ 0x325
341a01ec:	4a06      	ldr	r2, [pc, #24]	@ (341a0208 <VD55G1_StartStreaming+0xf8>)
341a01ee:	2102      	movs	r1, #2
341a01f0:	6878      	ldr	r0, [r7, #4]
341a01f2:	f7fe fd3d 	bl	3419ec70 <VD55G1_log_impl>

  return 0;
341a01f6:	2300      	movs	r3, #0
}
341a01f8:	4618      	mov	r0, r3
341a01fa:	3710      	adds	r7, #16
341a01fc:	46bd      	mov	sp, r7
341a01fe:	bd80      	pop	{r7, pc}
341a0200:	341aa02c 	.word	0x341aa02c
341a0204:	341a77b8 	.word	0x341a77b8
341a0208:	341a7aa8 	.word	0x341a7aa8

341a020c <VD55G1_StopStreaming>:

static int VD55G1_StopStreaming(VD55G1_Ctx_t *ctx)
{
341a020c:	b580      	push	{r7, lr}
341a020e:	b088      	sub	sp, #32
341a0210:	af04      	add	r7, sp, #16
341a0212:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD55G1_REG_STREAMING, VD55G1_STREAMING_STOP_STREAM);
341a0214:	687b      	ldr	r3, [r7, #4]
341a0216:	691b      	ldr	r3, [r3, #16]
341a0218:	2201      	movs	r2, #1
341a021a:	f240 2102 	movw	r1, #514	@ 0x202
341a021e:	6878      	ldr	r0, [r7, #4]
341a0220:	4798      	blx	r3
341a0222:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a0224:	68fb      	ldr	r3, [r7, #12]
341a0226:	2b00      	cmp	r3, #0
341a0228:	d00d      	beq.n	341a0246 <VD55G1_StopStreaming+0x3a>
341a022a:	68fb      	ldr	r3, [r7, #12]
341a022c:	9302      	str	r3, [sp, #8]
341a022e:	f240 332f 	movw	r3, #815	@ 0x32f
341a0232:	9301      	str	r3, [sp, #4]
341a0234:	4b31      	ldr	r3, [pc, #196]	@ (341a02fc <VD55G1_StopStreaming+0xf0>)
341a0236:	9300      	str	r3, [sp, #0]
341a0238:	f240 332f 	movw	r3, #815	@ 0x32f
341a023c:	4a30      	ldr	r2, [pc, #192]	@ (341a0300 <VD55G1_StopStreaming+0xf4>)
341a023e:	2100      	movs	r1, #0
341a0240:	6878      	ldr	r0, [r7, #4]
341a0242:	f7fe fd15 	bl	3419ec70 <VD55G1_log_impl>
341a0246:	68fb      	ldr	r3, [r7, #12]
341a0248:	2b00      	cmp	r3, #0
341a024a:	d002      	beq.n	341a0252 <VD55G1_StopStreaming+0x46>
341a024c:	6878      	ldr	r0, [r7, #4]
341a024e:	f7fe fd2b 	bl	3419eca8 <display_error>
341a0252:	68fb      	ldr	r3, [r7, #12]
341a0254:	2b00      	cmp	r3, #0
341a0256:	d001      	beq.n	341a025c <VD55G1_StopStreaming+0x50>
341a0258:	68fb      	ldr	r3, [r7, #12]
341a025a:	e04b      	b.n	341a02f4 <VD55G1_StopStreaming+0xe8>

  ret = VD55G1_PollReg8(ctx, VD55G1_REG_STREAMING, VD55G1_CMD_ACK);
341a025c:	2200      	movs	r2, #0
341a025e:	f240 2102 	movw	r1, #514	@ 0x202
341a0262:	6878      	ldr	r0, [r7, #4]
341a0264:	f7fe fd4a 	bl	3419ecfc <VD55G1_PollReg8>
341a0268:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a026a:	68fb      	ldr	r3, [r7, #12]
341a026c:	2b00      	cmp	r3, #0
341a026e:	d00d      	beq.n	341a028c <VD55G1_StopStreaming+0x80>
341a0270:	68fb      	ldr	r3, [r7, #12]
341a0272:	9302      	str	r3, [sp, #8]
341a0274:	f240 3332 	movw	r3, #818	@ 0x332
341a0278:	9301      	str	r3, [sp, #4]
341a027a:	4b20      	ldr	r3, [pc, #128]	@ (341a02fc <VD55G1_StopStreaming+0xf0>)
341a027c:	9300      	str	r3, [sp, #0]
341a027e:	f240 3332 	movw	r3, #818	@ 0x332
341a0282:	4a1f      	ldr	r2, [pc, #124]	@ (341a0300 <VD55G1_StopStreaming+0xf4>)
341a0284:	2100      	movs	r1, #0
341a0286:	6878      	ldr	r0, [r7, #4]
341a0288:	f7fe fcf2 	bl	3419ec70 <VD55G1_log_impl>
341a028c:	68fb      	ldr	r3, [r7, #12]
341a028e:	2b00      	cmp	r3, #0
341a0290:	d002      	beq.n	341a0298 <VD55G1_StopStreaming+0x8c>
341a0292:	6878      	ldr	r0, [r7, #4]
341a0294:	f7fe fd08 	bl	3419eca8 <display_error>
341a0298:	68fb      	ldr	r3, [r7, #12]
341a029a:	2b00      	cmp	r3, #0
341a029c:	d001      	beq.n	341a02a2 <VD55G1_StopStreaming+0x96>
341a029e:	68fb      	ldr	r3, [r7, #12]
341a02a0:	e028      	b.n	341a02f4 <VD55G1_StopStreaming+0xe8>

  ret = VD55G1_WaitState(ctx, VD55G1_SYSTEM_FSM_SW_STBY);
341a02a2:	2102      	movs	r1, #2
341a02a4:	6878      	ldr	r0, [r7, #4]
341a02a6:	f7fe fd89 	bl	3419edbc <VD55G1_WaitState>
341a02aa:	60f8      	str	r0, [r7, #12]
  VD55G1_TraceError(ctx, ret);
341a02ac:	68fb      	ldr	r3, [r7, #12]
341a02ae:	2b00      	cmp	r3, #0
341a02b0:	d00d      	beq.n	341a02ce <VD55G1_StopStreaming+0xc2>
341a02b2:	68fb      	ldr	r3, [r7, #12]
341a02b4:	9302      	str	r3, [sp, #8]
341a02b6:	f240 3335 	movw	r3, #821	@ 0x335
341a02ba:	9301      	str	r3, [sp, #4]
341a02bc:	4b0f      	ldr	r3, [pc, #60]	@ (341a02fc <VD55G1_StopStreaming+0xf0>)
341a02be:	9300      	str	r3, [sp, #0]
341a02c0:	f240 3335 	movw	r3, #821	@ 0x335
341a02c4:	4a0e      	ldr	r2, [pc, #56]	@ (341a0300 <VD55G1_StopStreaming+0xf4>)
341a02c6:	2100      	movs	r1, #0
341a02c8:	6878      	ldr	r0, [r7, #4]
341a02ca:	f7fe fcd1 	bl	3419ec70 <VD55G1_log_impl>
341a02ce:	68fb      	ldr	r3, [r7, #12]
341a02d0:	2b00      	cmp	r3, #0
341a02d2:	d002      	beq.n	341a02da <VD55G1_StopStreaming+0xce>
341a02d4:	6878      	ldr	r0, [r7, #4]
341a02d6:	f7fe fce7 	bl	3419eca8 <display_error>
341a02da:	68fb      	ldr	r3, [r7, #12]
341a02dc:	2b00      	cmp	r3, #0
341a02de:	d001      	beq.n	341a02e4 <VD55G1_StopStreaming+0xd8>
341a02e0:	68fb      	ldr	r3, [r7, #12]
341a02e2:	e007      	b.n	341a02f4 <VD55G1_StopStreaming+0xe8>

  VD55G1_notice(ctx, "Streaming is off\n");
341a02e4:	f240 3337 	movw	r3, #823	@ 0x337
341a02e8:	4a06      	ldr	r2, [pc, #24]	@ (341a0304 <VD55G1_StopStreaming+0xf8>)
341a02ea:	2102      	movs	r1, #2
341a02ec:	6878      	ldr	r0, [r7, #4]
341a02ee:	f7fe fcbf 	bl	3419ec70 <VD55G1_log_impl>

  return 0;
341a02f2:	2300      	movs	r3, #0
}
341a02f4:	4618      	mov	r0, r3
341a02f6:	3710      	adds	r7, #16
341a02f8:	46bd      	mov	sp, r7
341a02fa:	bd80      	pop	{r7, pc}
341a02fc:	341aa044 	.word	0x341aa044
341a0300:	341a77b8 	.word	0x341a77b8
341a0304:	341a7acc 	.word	0x341a7acc

341a0308 <VD55G1_Init>:

  return VD55G1_StartAWU(ctx);
}

int VD55G1_Init(VD55G1_Ctx_t *ctx, VD55G1_Config_t *config)
{
341a0308:	b5b0      	push	{r4, r5, r7, lr}
341a030a:	b086      	sub	sp, #24
341a030c:	af00      	add	r7, sp, #0
341a030e:	6078      	str	r0, [r7, #4]
341a0310:	6039      	str	r1, [r7, #0]
  VD55G1_AWUConfig_t *awu = &config->awu;
341a0312:	683b      	ldr	r3, [r7, #0]
341a0314:	331c      	adds	r3, #28
341a0316:	617b      	str	r3, [r7, #20]
  struct drv_ctx *drv_ctx = &ctx->ctx;
341a0318:	687b      	ldr	r3, [r7, #4]
341a031a:	3328      	adds	r3, #40	@ 0x28
341a031c:	613b      	str	r3, [r7, #16]
  int ret;

  if (config->frame_rate < VD55G1_MIN_FPS)
341a031e:	683b      	ldr	r3, [r7, #0]
341a0320:	689b      	ldr	r3, [r3, #8]
341a0322:	2b01      	cmp	r3, #1
341a0324:	dc02      	bgt.n	341a032c <VD55G1_Init+0x24>
    return -1;
341a0326:	f04f 33ff 	mov.w	r3, #4294967295
341a032a:	e05d      	b.n	341a03e8 <VD55G1_Init+0xe0>
  if (config->frame_rate > VD55G1_MAX_FPS)
341a032c:	683b      	ldr	r3, [r7, #0]
341a032e:	689b      	ldr	r3, [r3, #8]
341a0330:	2ba8      	cmp	r3, #168	@ 0xa8
341a0332:	dd02      	ble.n	341a033a <VD55G1_Init+0x32>
    return -1;
341a0334:	f04f 33ff 	mov.w	r3, #4294967295
341a0338:	e056      	b.n	341a03e8 <VD55G1_Init+0xe0>

  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
341a033a:	683b      	ldr	r3, [r7, #0]
341a033c:	791b      	ldrb	r3, [r3, #4]
341a033e:	2b00      	cmp	r3, #0
341a0340:	d00e      	beq.n	341a0360 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_VGA_640_480) &&
341a0342:	683b      	ldr	r3, [r7, #0]
341a0344:	791b      	ldrb	r3, [r3, #4]
  if ((config->resolution != VD55G1_RES_QVGA_320_240) &&
341a0346:	2b01      	cmp	r3, #1
341a0348:	d00a      	beq.n	341a0360 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_SXGA_800_600) &&
341a034a:	683b      	ldr	r3, [r7, #0]
341a034c:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD55G1_RES_VGA_640_480) &&
341a034e:	2b02      	cmp	r3, #2
341a0350:	d006      	beq.n	341a0360 <VD55G1_Init+0x58>
      (config->resolution != VD55G1_RES_FULL_804_704)) {
341a0352:	683b      	ldr	r3, [r7, #0]
341a0354:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD55G1_RES_SXGA_800_600) &&
341a0356:	2b03      	cmp	r3, #3
341a0358:	d002      	beq.n	341a0360 <VD55G1_Init+0x58>
    return -1;
341a035a:	f04f 33ff 	mov.w	r3, #4294967295
341a035e:	e043      	b.n	341a03e8 <VD55G1_Init+0xe0>
  }

  if (awu->is_enable && awu->threshold != VD55G1_AWU_THRESHOLD_DEFAULT) {
341a0360:	697b      	ldr	r3, [r7, #20]
341a0362:	681b      	ldr	r3, [r3, #0]
341a0364:	2b00      	cmp	r3, #0
341a0366:	d011      	beq.n	341a038c <VD55G1_Init+0x84>
341a0368:	697b      	ldr	r3, [r7, #20]
341a036a:	691b      	ldr	r3, [r3, #16]
341a036c:	2b00      	cmp	r3, #0
341a036e:	d00d      	beq.n	341a038c <VD55G1_Init+0x84>
    if (awu->threshold < VD55G1_AWU_THRESHOLD_MIN)
341a0370:	697b      	ldr	r3, [r7, #20]
341a0372:	691b      	ldr	r3, [r3, #16]
341a0374:	2b01      	cmp	r3, #1
341a0376:	dc02      	bgt.n	341a037e <VD55G1_Init+0x76>
      return -1;
341a0378:	f04f 33ff 	mov.w	r3, #4294967295
341a037c:	e034      	b.n	341a03e8 <VD55G1_Init+0xe0>
    if (awu->threshold > VD55G1_AWU_THRESHOLD_MAX)
341a037e:	697b      	ldr	r3, [r7, #20]
341a0380:	691b      	ldr	r3, [r3, #16]
341a0382:	2b80      	cmp	r3, #128	@ 0x80
341a0384:	dd02      	ble.n	341a038c <VD55G1_Init+0x84>
      return -1;
341a0386:	f04f 33ff 	mov.w	r3, #4294967295
341a038a:	e02d      	b.n	341a03e8 <VD55G1_Init+0xe0>
  }

  drv_ctx->config_save = *config;
341a038c:	693b      	ldr	r3, [r7, #16]
341a038e:	683a      	ldr	r2, [r7, #0]
341a0390:	f103 040c 	add.w	r4, r3, #12
341a0394:	4615      	mov	r5, r2
341a0396:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a0398:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a039a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a039c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a039e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a03a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a03a2:	682b      	ldr	r3, [r5, #0]
341a03a4:	6023      	str	r3, [r4, #0]

  ctx->shutdown_pin(ctx, 0);
341a03a6:	687b      	ldr	r3, [r7, #4]
341a03a8:	681b      	ldr	r3, [r3, #0]
341a03aa:	2100      	movs	r1, #0
341a03ac:	6878      	ldr	r0, [r7, #4]
341a03ae:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a03b0:	687b      	ldr	r3, [r7, #4]
341a03b2:	6a1b      	ldr	r3, [r3, #32]
341a03b4:	210a      	movs	r1, #10
341a03b6:	6878      	ldr	r0, [r7, #4]
341a03b8:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
341a03ba:	687b      	ldr	r3, [r7, #4]
341a03bc:	681b      	ldr	r3, [r3, #0]
341a03be:	2101      	movs	r1, #1
341a03c0:	6878      	ldr	r0, [r7, #4]
341a03c2:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a03c4:	687b      	ldr	r3, [r7, #4]
341a03c6:	6a1b      	ldr	r3, [r3, #32]
341a03c8:	210a      	movs	r1, #10
341a03ca:	6878      	ldr	r0, [r7, #4]
341a03cc:	4798      	blx	r3

  ret = VD55G1_Boot(ctx);
341a03ce:	6878      	ldr	r0, [r7, #4]
341a03d0:	f7fe ff8c 	bl	3419f2ec <VD55G1_Boot>
341a03d4:	60f8      	str	r0, [r7, #12]
  if (ret)
341a03d6:	68fb      	ldr	r3, [r7, #12]
341a03d8:	2b00      	cmp	r3, #0
341a03da:	d001      	beq.n	341a03e0 <VD55G1_Init+0xd8>
    return ret;
341a03dc:	68fb      	ldr	r3, [r7, #12]
341a03de:	e003      	b.n	341a03e8 <VD55G1_Init+0xe0>

  drv_ctx->state = VD55G1_ST_IDLE;
341a03e0:	693b      	ldr	r3, [r7, #16]
341a03e2:	2200      	movs	r2, #0
341a03e4:	601a      	str	r2, [r3, #0]

  return 0;
341a03e6:	2300      	movs	r3, #0
}
341a03e8:	4618      	mov	r0, r3
341a03ea:	3718      	adds	r7, #24
341a03ec:	46bd      	mov	sp, r7
341a03ee:	bdb0      	pop	{r4, r5, r7, pc}

341a03f0 <VD55G1_DeInit>:

int VD55G1_DeInit(VD55G1_Ctx_t *ctx)
{
341a03f0:	b580      	push	{r7, lr}
341a03f2:	b084      	sub	sp, #16
341a03f4:	af00      	add	r7, sp, #0
341a03f6:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
341a03f8:	687b      	ldr	r3, [r7, #4]
341a03fa:	3328      	adds	r3, #40	@ 0x28
341a03fc:	60fb      	str	r3, [r7, #12]

  if (drv_ctx->state == VD55G1_ST_STREAMING)
341a03fe:	68fb      	ldr	r3, [r7, #12]
341a0400:	681b      	ldr	r3, [r3, #0]
341a0402:	2b01      	cmp	r3, #1
341a0404:	d102      	bne.n	341a040c <VD55G1_DeInit+0x1c>
    return -1;
341a0406:	f04f 33ff 	mov.w	r3, #4294967295
341a040a:	e00a      	b.n	341a0422 <VD55G1_DeInit+0x32>

  ctx->shutdown_pin(ctx, 0);
341a040c:	687b      	ldr	r3, [r7, #4]
341a040e:	681b      	ldr	r3, [r3, #0]
341a0410:	2100      	movs	r1, #0
341a0412:	6878      	ldr	r0, [r7, #4]
341a0414:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a0416:	687b      	ldr	r3, [r7, #4]
341a0418:	6a1b      	ldr	r3, [r3, #32]
341a041a:	210a      	movs	r1, #10
341a041c:	6878      	ldr	r0, [r7, #4]
341a041e:	4798      	blx	r3

  return 0;
341a0420:	2300      	movs	r3, #0
}
341a0422:	4618      	mov	r0, r3
341a0424:	3710      	adds	r7, #16
341a0426:	46bd      	mov	sp, r7
341a0428:	bd80      	pop	{r7, pc}

341a042a <VD55G1_Start>:

int VD55G1_Start(VD55G1_Ctx_t *ctx)
{
341a042a:	b580      	push	{r7, lr}
341a042c:	b084      	sub	sp, #16
341a042e:	af00      	add	r7, sp, #0
341a0430:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
341a0432:	687b      	ldr	r3, [r7, #4]
341a0434:	3328      	adds	r3, #40	@ 0x28
341a0436:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD55G1_Setup(ctx);
341a0438:	6878      	ldr	r0, [r7, #4]
341a043a:	f7ff fd5b 	bl	3419fef4 <VD55G1_Setup>
341a043e:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0440:	68bb      	ldr	r3, [r7, #8]
341a0442:	2b00      	cmp	r3, #0
341a0444:	d001      	beq.n	341a044a <VD55G1_Start+0x20>
    return ret;
341a0446:	68bb      	ldr	r3, [r7, #8]
341a0448:	e00c      	b.n	341a0464 <VD55G1_Start+0x3a>

  ret = VD55G1_StartStreaming(ctx);
341a044a:	6878      	ldr	r0, [r7, #4]
341a044c:	f7ff fe60 	bl	341a0110 <VD55G1_StartStreaming>
341a0450:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0452:	68bb      	ldr	r3, [r7, #8]
341a0454:	2b00      	cmp	r3, #0
341a0456:	d001      	beq.n	341a045c <VD55G1_Start+0x32>
    return ret;
341a0458:	68bb      	ldr	r3, [r7, #8]
341a045a:	e003      	b.n	341a0464 <VD55G1_Start+0x3a>
  drv_ctx->state = VD55G1_ST_STREAMING;
341a045c:	68fb      	ldr	r3, [r7, #12]
341a045e:	2201      	movs	r2, #1
341a0460:	601a      	str	r2, [r3, #0]

  return 0;
341a0462:	2300      	movs	r3, #0
}
341a0464:	4618      	mov	r0, r3
341a0466:	3710      	adds	r7, #16
341a0468:	46bd      	mov	sp, r7
341a046a:	bd80      	pop	{r7, pc}

341a046c <VD55G1_Stop>:

int VD55G1_Stop(VD55G1_Ctx_t *ctx)
{
341a046c:	b580      	push	{r7, lr}
341a046e:	b084      	sub	sp, #16
341a0470:	af00      	add	r7, sp, #0
341a0472:	6078      	str	r0, [r7, #4]
  struct drv_ctx *drv_ctx = &ctx->ctx;
341a0474:	687b      	ldr	r3, [r7, #4]
341a0476:	3328      	adds	r3, #40	@ 0x28
341a0478:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD55G1_StopStreaming(ctx);
341a047a:	6878      	ldr	r0, [r7, #4]
341a047c:	f7ff fec6 	bl	341a020c <VD55G1_StopStreaming>
341a0480:	60b8      	str	r0, [r7, #8]
  if (ret)
341a0482:	68bb      	ldr	r3, [r7, #8]
341a0484:	2b00      	cmp	r3, #0
341a0486:	d001      	beq.n	341a048c <VD55G1_Stop+0x20>
    return ret;
341a0488:	68bb      	ldr	r3, [r7, #8]
341a048a:	e003      	b.n	341a0494 <VD55G1_Stop+0x28>
  drv_ctx->state = VD55G1_ST_IDLE;
341a048c:	68fb      	ldr	r3, [r7, #12]
341a048e:	2200      	movs	r2, #0
341a0490:	601a      	str	r2, [r3, #0]

  return 0;
341a0492:	2300      	movs	r3, #0
}
341a0494:	4618      	mov	r0, r3
341a0496:	3710      	adds	r7, #16
341a0498:	46bd      	mov	sp, r7
341a049a:	bd80      	pop	{r7, pc}

341a049c <VD55G1_SetFlipMirrorMode>:

  return 0;
}

int VD55G1_SetFlipMirrorMode(VD55G1_Ctx_t *ctx, VD55G1_MirrorFlip_t mode)
{
341a049c:	b580      	push	{r7, lr}
341a049e:	b086      	sub	sp, #24
341a04a0:	af00      	add	r7, sp, #0
341a04a2:	6078      	str	r0, [r7, #4]
341a04a4:	460b      	mov	r3, r1
341a04a6:	70fb      	strb	r3, [r7, #3]
  struct drv_ctx *drv_ctx = &ctx->ctx;
341a04a8:	687b      	ldr	r3, [r7, #4]
341a04aa:	3328      	adds	r3, #40	@ 0x28
341a04ac:	617b      	str	r3, [r7, #20]
  int is_streaming;
  int ret;

  is_streaming = VD55G1_IsStreaming(ctx);
341a04ae:	6878      	ldr	r0, [r7, #4]
341a04b0:	f7fe fc68 	bl	3419ed84 <VD55G1_IsStreaming>
341a04b4:	6138      	str	r0, [r7, #16]
  if (is_streaming < 0)
341a04b6:	693b      	ldr	r3, [r7, #16]
341a04b8:	2b00      	cmp	r3, #0
341a04ba:	da01      	bge.n	341a04c0 <VD55G1_SetFlipMirrorMode+0x24>
    return is_streaming;
341a04bc:	693b      	ldr	r3, [r7, #16]
341a04be:	e01b      	b.n	341a04f8 <VD55G1_SetFlipMirrorMode+0x5c>

  if (is_streaming) {
341a04c0:	693b      	ldr	r3, [r7, #16]
341a04c2:	2b00      	cmp	r3, #0
341a04c4:	d008      	beq.n	341a04d8 <VD55G1_SetFlipMirrorMode+0x3c>
    ret = VD55G1_Stop(ctx);
341a04c6:	6878      	ldr	r0, [r7, #4]
341a04c8:	f7ff ffd0 	bl	341a046c <VD55G1_Stop>
341a04cc:	60f8      	str	r0, [r7, #12]
    if (ret)
341a04ce:	68fb      	ldr	r3, [r7, #12]
341a04d0:	2b00      	cmp	r3, #0
341a04d2:	d001      	beq.n	341a04d8 <VD55G1_SetFlipMirrorMode+0x3c>
      return ret;
341a04d4:	68fb      	ldr	r3, [r7, #12]
341a04d6:	e00f      	b.n	341a04f8 <VD55G1_SetFlipMirrorMode+0x5c>
  }

  drv_ctx->config_save.flip_mirror_mode = mode;
341a04d8:	697b      	ldr	r3, [r7, #20]
341a04da:	78fa      	ldrb	r2, [r7, #3]
341a04dc:	761a      	strb	r2, [r3, #24]

  if (is_streaming) {
341a04de:	693b      	ldr	r3, [r7, #16]
341a04e0:	2b00      	cmp	r3, #0
341a04e2:	d008      	beq.n	341a04f6 <VD55G1_SetFlipMirrorMode+0x5a>
    ret = VD55G1_Start(ctx);
341a04e4:	6878      	ldr	r0, [r7, #4]
341a04e6:	f7ff ffa0 	bl	341a042a <VD55G1_Start>
341a04ea:	60f8      	str	r0, [r7, #12]
    if (ret)
341a04ec:	68fb      	ldr	r3, [r7, #12]
341a04ee:	2b00      	cmp	r3, #0
341a04f0:	d001      	beq.n	341a04f6 <VD55G1_SetFlipMirrorMode+0x5a>
      return ret;
341a04f2:	68fb      	ldr	r3, [r7, #12]
341a04f4:	e000      	b.n	341a04f8 <VD55G1_SetFlipMirrorMode+0x5c>
  }

  return 0;
341a04f6:	2300      	movs	r3, #0
}
341a04f8:	4618      	mov	r0, r3
341a04fa:	3718      	adds	r7, #24
341a04fc:	46bd      	mov	sp, r7
341a04fe:	bd80      	pop	{r7, pc}

341a0500 <VD6G_dbg>:
  if (_ret_) display_error(_ctx_); \
  if (_ret_) return _ret_; \
} while(0)

static void VD6G_dbg(VD6G_Ctx_t *ctx, int lvl, const char *format, ...)
{
341a0500:	b40c      	push	{r2, r3}
341a0502:	b590      	push	{r4, r7, lr}
341a0504:	b085      	sub	sp, #20
341a0506:	af00      	add	r7, sp, #0
341a0508:	6078      	str	r0, [r7, #4]
341a050a:	6039      	str	r1, [r7, #0]
  va_list ap;

  if (!ctx->log)
341a050c:	687b      	ldr	r3, [r7, #4]
341a050e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a0510:	2b00      	cmp	r3, #0
341a0512:	d00b      	beq.n	341a052c <VD6G_dbg+0x2c>
    return ;

  va_start(ap, format);
341a0514:	f107 0324 	add.w	r3, r7, #36	@ 0x24
341a0518:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_DBG(lvl), format, ap);
341a051a:	687b      	ldr	r3, [r7, #4]
341a051c:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
341a051e:	683b      	ldr	r3, [r7, #0]
341a0520:	1cd9      	adds	r1, r3, #3
341a0522:	68fb      	ldr	r3, [r7, #12]
341a0524:	6a3a      	ldr	r2, [r7, #32]
341a0526:	6878      	ldr	r0, [r7, #4]
341a0528:	47a0      	blx	r4
341a052a:	e000      	b.n	341a052e <VD6G_dbg+0x2e>
    return ;
341a052c:	bf00      	nop
  va_end(ap);
}
341a052e:	3714      	adds	r7, #20
341a0530:	46bd      	mov	sp, r7
341a0532:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
341a0536:	b002      	add	sp, #8
341a0538:	4770      	bx	lr

341a053a <VD6G_notice>:

static void VD6G_notice(VD6G_Ctx_t *ctx, const char *format, ...)
{
341a053a:	b40e      	push	{r1, r2, r3}
341a053c:	b590      	push	{r4, r7, lr}
341a053e:	b084      	sub	sp, #16
341a0540:	af00      	add	r7, sp, #0
341a0542:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
341a0544:	687b      	ldr	r3, [r7, #4]
341a0546:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a0548:	2b00      	cmp	r3, #0
341a054a:	d00a      	beq.n	341a0562 <VD6G_notice+0x28>
    return ;

  va_start(ap, format);
341a054c:	f107 0320 	add.w	r3, r7, #32
341a0550:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_NOTICE, format, ap);
341a0552:	687b      	ldr	r3, [r7, #4]
341a0554:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
341a0556:	68fb      	ldr	r3, [r7, #12]
341a0558:	69fa      	ldr	r2, [r7, #28]
341a055a:	2102      	movs	r1, #2
341a055c:	6878      	ldr	r0, [r7, #4]
341a055e:	47a0      	blx	r4
341a0560:	e000      	b.n	341a0564 <VD6G_notice+0x2a>
    return ;
341a0562:	bf00      	nop
  va_end(ap);
}
341a0564:	3710      	adds	r7, #16
341a0566:	46bd      	mov	sp, r7
341a0568:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
341a056c:	b003      	add	sp, #12
341a056e:	4770      	bx	lr

341a0570 <VD6G_warn>:

static void VD6G_warn(VD6G_Ctx_t *ctx, const char *format, ...)
{
341a0570:	b40e      	push	{r1, r2, r3}
341a0572:	b590      	push	{r4, r7, lr}
341a0574:	b084      	sub	sp, #16
341a0576:	af00      	add	r7, sp, #0
341a0578:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
341a057a:	687b      	ldr	r3, [r7, #4]
341a057c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a057e:	2b00      	cmp	r3, #0
341a0580:	d00a      	beq.n	341a0598 <VD6G_warn+0x28>
    return ;

  va_start(ap, format);
341a0582:	f107 0320 	add.w	r3, r7, #32
341a0586:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_WARNING, format, ap);
341a0588:	687b      	ldr	r3, [r7, #4]
341a058a:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
341a058c:	68fb      	ldr	r3, [r7, #12]
341a058e:	69fa      	ldr	r2, [r7, #28]
341a0590:	2101      	movs	r1, #1
341a0592:	6878      	ldr	r0, [r7, #4]
341a0594:	47a0      	blx	r4
341a0596:	e000      	b.n	341a059a <VD6G_warn+0x2a>
    return ;
341a0598:	bf00      	nop
  va_end(ap);
}
341a059a:	3710      	adds	r7, #16
341a059c:	46bd      	mov	sp, r7
341a059e:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
341a05a2:	b003      	add	sp, #12
341a05a4:	4770      	bx	lr

341a05a6 <VD6G_error>:

static void VD6G_error(VD6G_Ctx_t *ctx, const char *format, ...)
{
341a05a6:	b40e      	push	{r1, r2, r3}
341a05a8:	b590      	push	{r4, r7, lr}
341a05aa:	b084      	sub	sp, #16
341a05ac:	af00      	add	r7, sp, #0
341a05ae:	6078      	str	r0, [r7, #4]
  va_list ap;

  if (!ctx->log)
341a05b0:	687b      	ldr	r3, [r7, #4]
341a05b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a05b4:	2b00      	cmp	r3, #0
341a05b6:	d00a      	beq.n	341a05ce <VD6G_error+0x28>
    return ;

  va_start(ap, format);
341a05b8:	f107 0320 	add.w	r3, r7, #32
341a05bc:	60fb      	str	r3, [r7, #12]
  ctx->log(ctx, VD6G_LVL_ERROR, format, ap);
341a05be:	687b      	ldr	r3, [r7, #4]
341a05c0:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
341a05c2:	68fb      	ldr	r3, [r7, #12]
341a05c4:	69fa      	ldr	r2, [r7, #28]
341a05c6:	2100      	movs	r1, #0
341a05c8:	6878      	ldr	r0, [r7, #4]
341a05ca:	47a0      	blx	r4
341a05cc:	e000      	b.n	341a05d0 <VD6G_error+0x2a>
    return ;
341a05ce:	bf00      	nop
  va_end(ap);
}
341a05d0:	3710      	adds	r7, #16
341a05d2:	46bd      	mov	sp, r7
341a05d4:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
341a05d8:	b003      	add	sp, #12
341a05da:	4770      	bx	lr

341a05dc <display_error>:

static void display_error(VD6G_Ctx_t *ctx)
{
341a05dc:	b580      	push	{r7, lr}
341a05de:	b084      	sub	sp, #16
341a05e0:	af00      	add	r7, sp, #0
341a05e2:	6078      	str	r0, [r7, #4]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_ERROR_CODE, &reg16);
341a05e4:	687b      	ldr	r3, [r7, #4]
341a05e6:	689b      	ldr	r3, [r3, #8]
341a05e8:	f107 020a 	add.w	r2, r7, #10
341a05ec:	211c      	movs	r1, #28
341a05ee:	6878      	ldr	r0, [r7, #4]
341a05f0:	4798      	blx	r3
341a05f2:	60f8      	str	r0, [r7, #12]
  assert(ret == 0);
341a05f4:	68fb      	ldr	r3, [r7, #12]
341a05f6:	2b00      	cmp	r3, #0
341a05f8:	d006      	beq.n	341a0608 <display_error+0x2c>
341a05fa:	4b08      	ldr	r3, [pc, #32]	@ (341a061c <display_error+0x40>)
341a05fc:	4a08      	ldr	r2, [pc, #32]	@ (341a0620 <display_error+0x44>)
341a05fe:	f240 1131 	movw	r1, #305	@ 0x131
341a0602:	4808      	ldr	r0, [pc, #32]	@ (341a0624 <display_error+0x48>)
341a0604:	f004 fcea 	bl	341a4fdc <__assert_func>
  VD6G_error(ctx, "ERROR_CODE : 0x%04x\n", reg16);
341a0608:	897b      	ldrh	r3, [r7, #10]
341a060a:	461a      	mov	r2, r3
341a060c:	4906      	ldr	r1, [pc, #24]	@ (341a0628 <display_error+0x4c>)
341a060e:	6878      	ldr	r0, [r7, #4]
341a0610:	f7ff ffc9 	bl	341a05a6 <VD6G_error>
}
341a0614:	bf00      	nop
341a0616:	3710      	adds	r7, #16
341a0618:	46bd      	mov	sp, r7
341a061a:	bd80      	pop	{r7, pc}
341a061c:	341a7b0c 	.word	0x341a7b0c
341a0620:	341ae418 	.word	0x341ae418
341a0624:	341a7b18 	.word	0x341a7b18
341a0628:	341a7b50 	.word	0x341a7b50

341a062c <VD6G_PollReg8>:

static int VD6G_PollReg8(VD6G_Ctx_t *ctx, uint16_t addr, uint8_t poll_val)
{
341a062c:	b580      	push	{r7, lr}
341a062e:	b08a      	sub	sp, #40	@ 0x28
341a0630:	af02      	add	r7, sp, #8
341a0632:	6078      	str	r0, [r7, #4]
341a0634:	460b      	mov	r3, r1
341a0636:	807b      	strh	r3, [r7, #2]
341a0638:	4613      	mov	r3, r2
341a063a:	707b      	strb	r3, [r7, #1]
  const unsigned int loop_delay_ms = 10;
341a063c:	230a      	movs	r3, #10
341a063e:	61bb      	str	r3, [r7, #24]
  const unsigned int timeout_ms = 500;
341a0640:	f44f 73fa 	mov.w	r3, #500	@ 0x1f4
341a0644:	617b      	str	r3, [r7, #20]
  int loop_nb = timeout_ms / loop_delay_ms;
341a0646:	697a      	ldr	r2, [r7, #20]
341a0648:	69bb      	ldr	r3, [r7, #24]
341a064a:	fbb2 f3f3 	udiv	r3, r2, r3
341a064e:	61fb      	str	r3, [r7, #28]
  uint8_t val;
  int ret;

  while (--loop_nb) {
341a0650:	e029      	b.n	341a06a6 <VD6G_PollReg8+0x7a>
    ret = ctx->read8(ctx, addr, &val);
341a0652:	687b      	ldr	r3, [r7, #4]
341a0654:	685b      	ldr	r3, [r3, #4]
341a0656:	f107 020f 	add.w	r2, r7, #15
341a065a:	8879      	ldrh	r1, [r7, #2]
341a065c:	6878      	ldr	r0, [r7, #4]
341a065e:	4798      	blx	r3
341a0660:	6138      	str	r0, [r7, #16]
    VD6G_TraceError(ctx, ret);
341a0662:	693b      	ldr	r3, [r7, #16]
341a0664:	2b00      	cmp	r3, #0
341a0666:	d008      	beq.n	341a067a <VD6G_PollReg8+0x4e>
341a0668:	693b      	ldr	r3, [r7, #16]
341a066a:	9300      	str	r3, [sp, #0]
341a066c:	f240 133f 	movw	r3, #319	@ 0x13f
341a0670:	4a13      	ldr	r2, [pc, #76]	@ (341a06c0 <VD6G_PollReg8+0x94>)
341a0672:	4914      	ldr	r1, [pc, #80]	@ (341a06c4 <VD6G_PollReg8+0x98>)
341a0674:	6878      	ldr	r0, [r7, #4]
341a0676:	f7ff ff96 	bl	341a05a6 <VD6G_error>
341a067a:	693b      	ldr	r3, [r7, #16]
341a067c:	2b00      	cmp	r3, #0
341a067e:	d002      	beq.n	341a0686 <VD6G_PollReg8+0x5a>
341a0680:	6878      	ldr	r0, [r7, #4]
341a0682:	f7ff ffab 	bl	341a05dc <display_error>
341a0686:	693b      	ldr	r3, [r7, #16]
341a0688:	2b00      	cmp	r3, #0
341a068a:	d001      	beq.n	341a0690 <VD6G_PollReg8+0x64>
341a068c:	693b      	ldr	r3, [r7, #16]
341a068e:	e012      	b.n	341a06b6 <VD6G_PollReg8+0x8a>
    if (val == poll_val)
341a0690:	7bfb      	ldrb	r3, [r7, #15]
341a0692:	787a      	ldrb	r2, [r7, #1]
341a0694:	429a      	cmp	r2, r3
341a0696:	d101      	bne.n	341a069c <VD6G_PollReg8+0x70>
      return 0;
341a0698:	2300      	movs	r3, #0
341a069a:	e00c      	b.n	341a06b6 <VD6G_PollReg8+0x8a>
    ctx->delay(ctx, loop_delay_ms);
341a069c:	687b      	ldr	r3, [r7, #4]
341a069e:	6a1b      	ldr	r3, [r3, #32]
341a06a0:	69b9      	ldr	r1, [r7, #24]
341a06a2:	6878      	ldr	r0, [r7, #4]
341a06a4:	4798      	blx	r3
  while (--loop_nb) {
341a06a6:	69fb      	ldr	r3, [r7, #28]
341a06a8:	3b01      	subs	r3, #1
341a06aa:	61fb      	str	r3, [r7, #28]
341a06ac:	69fb      	ldr	r3, [r7, #28]
341a06ae:	2b00      	cmp	r3, #0
341a06b0:	d1cf      	bne.n	341a0652 <VD6G_PollReg8+0x26>
  }

  return -1;
341a06b2:	f04f 33ff 	mov.w	r3, #4294967295
}
341a06b6:	4618      	mov	r0, r3
341a06b8:	3720      	adds	r7, #32
341a06ba:	46bd      	mov	sp, r7
341a06bc:	bd80      	pop	{r7, pc}
341a06be:	bf00      	nop
341a06c0:	341ae428 	.word	0x341ae428
341a06c4:	341a7b68 	.word	0x341a7b68

341a06c8 <VD6G_GetLineTimeInUs>:

static int VD6G_GetLineTimeInUs(VD6G_Ctx_t *ctx, uint32_t *line_time_in_us)
{
341a06c8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
341a06cc:	b08a      	sub	sp, #40	@ 0x28
341a06ce:	af02      	add	r7, sp, #8
341a06d0:	6178      	str	r0, [r7, #20]
341a06d2:	6139      	str	r1, [r7, #16]
  uint16_t line_len;
  int ret;

  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_len);
341a06d4:	697b      	ldr	r3, [r7, #20]
341a06d6:	689b      	ldr	r3, [r3, #8]
341a06d8:	f107 021a 	add.w	r2, r7, #26
341a06dc:	f44f 7140 	mov.w	r1, #768	@ 0x300
341a06e0:	6978      	ldr	r0, [r7, #20]
341a06e2:	4798      	blx	r3
341a06e4:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
341a06e6:	69fb      	ldr	r3, [r7, #28]
341a06e8:	2b00      	cmp	r3, #0
341a06ea:	d008      	beq.n	341a06fe <VD6G_GetLineTimeInUs+0x36>
341a06ec:	69fb      	ldr	r3, [r7, #28]
341a06ee:	9300      	str	r3, [sp, #0]
341a06f0:	f44f 73a7 	mov.w	r3, #334	@ 0x14e
341a06f4:	4a28      	ldr	r2, [pc, #160]	@ (341a0798 <VD6G_GetLineTimeInUs+0xd0>)
341a06f6:	4929      	ldr	r1, [pc, #164]	@ (341a079c <VD6G_GetLineTimeInUs+0xd4>)
341a06f8:	6978      	ldr	r0, [r7, #20]
341a06fa:	f7ff ff54 	bl	341a05a6 <VD6G_error>
341a06fe:	69fb      	ldr	r3, [r7, #28]
341a0700:	2b00      	cmp	r3, #0
341a0702:	d002      	beq.n	341a070a <VD6G_GetLineTimeInUs+0x42>
341a0704:	6978      	ldr	r0, [r7, #20]
341a0706:	f7ff ff69 	bl	341a05dc <display_error>
341a070a:	69fb      	ldr	r3, [r7, #28]
341a070c:	2b00      	cmp	r3, #0
341a070e:	d001      	beq.n	341a0714 <VD6G_GetLineTimeInUs+0x4c>
341a0710:	69fb      	ldr	r3, [r7, #28]
341a0712:	e035      	b.n	341a0780 <VD6G_GetLineTimeInUs+0xb8>

  /* compute line_time_in_us */
  *line_time_in_us = ((uint64_t)line_len * 1000000) / VD6G_PIXEL_CLOCK;
341a0714:	8b7b      	ldrh	r3, [r7, #26]
341a0716:	b29b      	uxth	r3, r3
341a0718:	2200      	movs	r2, #0
341a071a:	461c      	mov	r4, r3
341a071c:	4615      	mov	r5, r2
341a071e:	4622      	mov	r2, r4
341a0720:	462b      	mov	r3, r5
341a0722:	ea52 134f 	orrs.w	r3, r2, pc, lsl #5
341a0726:	ebb2 0804 	subs.w	r8, r2, r4
341a072a:	eb63 0905 	sbc.w	r9, r3, r5
341a072e:	4642      	mov	r2, r8
341a0730:	464b      	mov	r3, r9
341a0732:	ea52 234f 	orrs.w	r3, r2, pc, lsl #9
341a0736:	4690      	mov	r8, r2
341a0738:	4699      	mov	r9, r3
341a073a:	eb18 0a04 	adds.w	sl, r8, r4
341a073e:	eb49 0b05 	adc.w	fp, r9, r5
341a0742:	4652      	mov	r2, sl
341a0744:	465b      	mov	r3, fp
341a0746:	ea52 138f 	orrs.w	r3, r2, pc, lsl #6
341a074a:	ebb2 010a 	subs.w	r1, r2, sl
341a074e:	6039      	str	r1, [r7, #0]
341a0750:	eb63 030b 	sbc.w	r3, r3, fp
341a0754:	607b      	str	r3, [r7, #4]
341a0756:	e9d7 0100 	ldrd	r0, r1, [r7]
341a075a:	4603      	mov	r3, r0
341a075c:	191b      	adds	r3, r3, r4
341a075e:	60bb      	str	r3, [r7, #8]
341a0760:	460b      	mov	r3, r1
341a0762:	eb45 0303 	adc.w	r3, r5, r3
341a0766:	60fb      	str	r3, [r7, #12]
341a0768:	a309      	add	r3, pc, #36	@ (adr r3, 341a0790 <VD6G_GetLineTimeInUs+0xc8>)
341a076a:	e9d3 2300 	ldrd	r2, r3, [r3]
341a076e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
341a0772:	f7e1 f833 	bl	341817dc <__aeabi_uldivmod>
341a0776:	4602      	mov	r2, r0
341a0778:	460b      	mov	r3, r1
341a077a:	693b      	ldr	r3, [r7, #16]
341a077c:	601a      	str	r2, [r3, #0]

  return 0;
341a077e:	2300      	movs	r3, #0
}
341a0780:	4618      	mov	r0, r3
341a0782:	3720      	adds	r7, #32
341a0784:	46bd      	mov	sp, r7
341a0786:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
341a078a:	bf00      	nop
341a078c:	f3af 8000 	nop.w
341a0790:	09959d00 	.word	0x09959d00
341a0794:	00000000 	.word	0x00000000
341a0798:	341ae438 	.word	0x341ae438
341a079c:	341a7b68 	.word	0x341a7b68

341a07a0 <VD6G_WaitState>:

  return state == VD6G_SYSTEM_FSM_STREAMING;
}

static int VD6G_WaitState(VD6G_Ctx_t *ctx, int state)
{
341a07a0:	b580      	push	{r7, lr}
341a07a2:	b084      	sub	sp, #16
341a07a4:	af00      	add	r7, sp, #0
341a07a6:	6078      	str	r0, [r7, #4]
341a07a8:	6039      	str	r1, [r7, #0]
  int ret = VD6G_PollReg8(ctx, VD6G_REG_SYSTEM_FSM, state);
341a07aa:	683b      	ldr	r3, [r7, #0]
341a07ac:	b2db      	uxtb	r3, r3
341a07ae:	461a      	mov	r2, r3
341a07b0:	2128      	movs	r1, #40	@ 0x28
341a07b2:	6878      	ldr	r0, [r7, #4]
341a07b4:	f7ff ff3a 	bl	341a062c <VD6G_PollReg8>
341a07b8:	60f8      	str	r0, [r7, #12]

  if (ret)
341a07ba:	68fb      	ldr	r3, [r7, #12]
341a07bc:	2b00      	cmp	r3, #0
341a07be:	d005      	beq.n	341a07cc <VD6G_WaitState+0x2c>
    VD6G_warn(ctx, "Unable to reach state %d\n", state);
341a07c0:	683a      	ldr	r2, [r7, #0]
341a07c2:	4908      	ldr	r1, [pc, #32]	@ (341a07e4 <VD6G_WaitState+0x44>)
341a07c4:	6878      	ldr	r0, [r7, #4]
341a07c6:	f7ff fed3 	bl	341a0570 <VD6G_warn>
341a07ca:	e005      	b.n	341a07d8 <VD6G_WaitState+0x38>
  else
    VD6G_dbg(ctx, 0, "reach state %d\n", state);
341a07cc:	683b      	ldr	r3, [r7, #0]
341a07ce:	4a06      	ldr	r2, [pc, #24]	@ (341a07e8 <VD6G_WaitState+0x48>)
341a07d0:	2100      	movs	r1, #0
341a07d2:	6878      	ldr	r0, [r7, #4]
341a07d4:	f7ff fe94 	bl	341a0500 <VD6G_dbg>

  return ret;
341a07d8:	68fb      	ldr	r3, [r7, #12]
}
341a07da:	4618      	mov	r0, r3
341a07dc:	3710      	adds	r7, #16
341a07de:	46bd      	mov	sp, r7
341a07e0:	bd80      	pop	{r7, pc}
341a07e2:	bf00      	nop
341a07e4:	341a7b80 	.word	0x341a7b80
341a07e8:	341a7b9c 	.word	0x341a7b9c

341a07ec <VD6G_GetTopDie>:

static int VD6G_GetTopDie(VD6G_Ctx_t *ctx, uint8_t *top_die)
{
341a07ec:	b580      	push	{r7, lr}
341a07ee:	b086      	sub	sp, #24
341a07f0:	af02      	add	r7, sp, #8
341a07f2:	6078      	str	r0, [r7, #4]
341a07f4:	6039      	str	r1, [r7, #0]
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_REG_REVISION, &reg16);
341a07f6:	687b      	ldr	r3, [r7, #4]
341a07f8:	689b      	ldr	r3, [r3, #8]
341a07fa:	f107 020a 	add.w	r2, r7, #10
341a07fe:	2102      	movs	r1, #2
341a0800:	6878      	ldr	r0, [r7, #4]
341a0802:	4798      	blx	r3
341a0804:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0806:	68fb      	ldr	r3, [r7, #12]
341a0808:	2b00      	cmp	r3, #0
341a080a:	d008      	beq.n	341a081e <VD6G_GetTopDie+0x32>
341a080c:	68fb      	ldr	r3, [r7, #12]
341a080e:	9300      	str	r3, [sp, #0]
341a0810:	f240 1373 	movw	r3, #371	@ 0x173
341a0814:	4a10      	ldr	r2, [pc, #64]	@ (341a0858 <VD6G_GetTopDie+0x6c>)
341a0816:	4911      	ldr	r1, [pc, #68]	@ (341a085c <VD6G_GetTopDie+0x70>)
341a0818:	6878      	ldr	r0, [r7, #4]
341a081a:	f7ff fec4 	bl	341a05a6 <VD6G_error>
341a081e:	68fb      	ldr	r3, [r7, #12]
341a0820:	2b00      	cmp	r3, #0
341a0822:	d002      	beq.n	341a082a <VD6G_GetTopDie+0x3e>
341a0824:	6878      	ldr	r0, [r7, #4]
341a0826:	f7ff fed9 	bl	341a05dc <display_error>
341a082a:	68fb      	ldr	r3, [r7, #12]
341a082c:	2b00      	cmp	r3, #0
341a082e:	d001      	beq.n	341a0834 <VD6G_GetTopDie+0x48>
341a0830:	68fb      	ldr	r3, [r7, #12]
341a0832:	e00c      	b.n	341a084e <VD6G_GetTopDie+0x62>
  VD6G_dbg(ctx, 0, "revision = 0x%04x\n", reg16);
341a0834:	897b      	ldrh	r3, [r7, #10]
341a0836:	4a0a      	ldr	r2, [pc, #40]	@ (341a0860 <VD6G_GetTopDie+0x74>)
341a0838:	2100      	movs	r1, #0
341a083a:	6878      	ldr	r0, [r7, #4]
341a083c:	f7ff fe60 	bl	341a0500 <VD6G_dbg>
  *top_die = reg16 >> 8;
341a0840:	897b      	ldrh	r3, [r7, #10]
341a0842:	0a1b      	lsrs	r3, r3, #8
341a0844:	b29b      	uxth	r3, r3
341a0846:	b2da      	uxtb	r2, r3
341a0848:	683b      	ldr	r3, [r7, #0]
341a084a:	701a      	strb	r2, [r3, #0]

  return 0;
341a084c:	2300      	movs	r3, #0
}
341a084e:	4618      	mov	r0, r3
341a0850:	3710      	adds	r7, #16
341a0852:	46bd      	mov	sp, r7
341a0854:	bd80      	pop	{r7, pc}
341a0856:	bf00      	nop
341a0858:	341ae450 	.word	0x341ae450
341a085c:	341a7b68 	.word	0x341a7b68
341a0860:	341a7bac 	.word	0x341a7bac

341a0864 <VD6G_CheckModelId>:

static int VD6G_CheckModelId(VD6G_Ctx_t *ctx)
{
341a0864:	b580      	push	{r7, lr}
341a0866:	b086      	sub	sp, #24
341a0868:	af02      	add	r7, sp, #8
341a086a:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  uint16_t reg16;
  int ret;

  ret = ctx->read16(ctx, VD6G_REG_MODEL_ID, &reg16);
341a086c:	687b      	ldr	r3, [r7, #4]
341a086e:	689b      	ldr	r3, [r3, #8]
341a0870:	f107 0208 	add.w	r2, r7, #8
341a0874:	2100      	movs	r1, #0
341a0876:	6878      	ldr	r0, [r7, #4]
341a0878:	4798      	blx	r3
341a087a:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a087c:	68fb      	ldr	r3, [r7, #12]
341a087e:	2b00      	cmp	r3, #0
341a0880:	d008      	beq.n	341a0894 <VD6G_CheckModelId+0x30>
341a0882:	68fb      	ldr	r3, [r7, #12]
341a0884:	9300      	str	r3, [sp, #0]
341a0886:	f240 1381 	movw	r3, #385	@ 0x181
341a088a:	4a34      	ldr	r2, [pc, #208]	@ (341a095c <VD6G_CheckModelId+0xf8>)
341a088c:	4934      	ldr	r1, [pc, #208]	@ (341a0960 <VD6G_CheckModelId+0xfc>)
341a088e:	6878      	ldr	r0, [r7, #4]
341a0890:	f7ff fe89 	bl	341a05a6 <VD6G_error>
341a0894:	68fb      	ldr	r3, [r7, #12]
341a0896:	2b00      	cmp	r3, #0
341a0898:	d002      	beq.n	341a08a0 <VD6G_CheckModelId+0x3c>
341a089a:	6878      	ldr	r0, [r7, #4]
341a089c:	f7ff fe9e 	bl	341a05dc <display_error>
341a08a0:	68fb      	ldr	r3, [r7, #12]
341a08a2:	2b00      	cmp	r3, #0
341a08a4:	d001      	beq.n	341a08aa <VD6G_CheckModelId+0x46>
341a08a6:	68fb      	ldr	r3, [r7, #12]
341a08a8:	e053      	b.n	341a0952 <VD6G_CheckModelId+0xee>
  VD6G_dbg(ctx, 0, "model_id = 0x%04x\n", reg16);
341a08aa:	893b      	ldrh	r3, [r7, #8]
341a08ac:	4a2d      	ldr	r2, [pc, #180]	@ (341a0964 <VD6G_CheckModelId+0x100>)
341a08ae:	2100      	movs	r1, #0
341a08b0:	6878      	ldr	r0, [r7, #4]
341a08b2:	f7ff fe25 	bl	341a0500 <VD6G_dbg>
  if (reg16 != VD6G_MODEL_ID) {
341a08b6:	893b      	ldrh	r3, [r7, #8]
341a08b8:	f245 6203 	movw	r2, #22019	@ 0x5603
341a08bc:	4293      	cmp	r3, r2
341a08be:	d009      	beq.n	341a08d4 <VD6G_CheckModelId+0x70>
    VD6G_error(ctx, "Bad model id expected 0x%04x / got 0x%04x\n", VD6G_MODEL_ID, reg16);
341a08c0:	893b      	ldrh	r3, [r7, #8]
341a08c2:	f245 6203 	movw	r2, #22019	@ 0x5603
341a08c6:	4928      	ldr	r1, [pc, #160]	@ (341a0968 <VD6G_CheckModelId+0x104>)
341a08c8:	6878      	ldr	r0, [r7, #4]
341a08ca:	f7ff fe6c 	bl	341a05a6 <VD6G_error>
    return -1;
341a08ce:	f04f 33ff 	mov.w	r3, #4294967295
341a08d2:	e03e      	b.n	341a0952 <VD6G_CheckModelId+0xee>
  }

  ret = VD6G_GetTopDie(ctx, &top_die);
341a08d4:	f107 030b 	add.w	r3, r7, #11
341a08d8:	4619      	mov	r1, r3
341a08da:	6878      	ldr	r0, [r7, #4]
341a08dc:	f7ff ff86 	bl	341a07ec <VD6G_GetTopDie>
341a08e0:	60f8      	str	r0, [r7, #12]
  if (ret)
341a08e2:	68fb      	ldr	r3, [r7, #12]
341a08e4:	2b00      	cmp	r3, #0
341a08e6:	d001      	beq.n	341a08ec <VD6G_CheckModelId+0x88>
    return ret;
341a08e8:	68fb      	ldr	r3, [r7, #12]
341a08ea:	e032      	b.n	341a0952 <VD6G_CheckModelId+0xee>
  if (top_die != VD6G_TOP_DIE_SLOW_BOOT && top_die != VD6G_TOP_DIE_FAST_BOOT) {
341a08ec:	7afb      	ldrb	r3, [r7, #11]
341a08ee:	2b20      	cmp	r3, #32
341a08f0:	d009      	beq.n	341a0906 <VD6G_CheckModelId+0xa2>
341a08f2:	7afb      	ldrb	r3, [r7, #11]
341a08f4:	2b31      	cmp	r3, #49	@ 0x31
341a08f6:	d006      	beq.n	341a0906 <VD6G_CheckModelId+0xa2>
    VD6G_error(ctx, "Unsupported revision\n");
341a08f8:	491c      	ldr	r1, [pc, #112]	@ (341a096c <VD6G_CheckModelId+0x108>)
341a08fa:	6878      	ldr	r0, [r7, #4]
341a08fc:	f7ff fe53 	bl	341a05a6 <VD6G_error>
    return -1;
341a0900:	f04f 33ff 	mov.w	r3, #4294967295
341a0904:	e025      	b.n	341a0952 <VD6G_CheckModelId+0xee>
  }

  ret = ctx->read16(ctx, VD6G_REG_ROM_REVISION, &reg16);
341a0906:	687b      	ldr	r3, [r7, #4]
341a0908:	689b      	ldr	r3, [r3, #8]
341a090a:	f107 0208 	add.w	r2, r7, #8
341a090e:	2114      	movs	r1, #20
341a0910:	6878      	ldr	r0, [r7, #4]
341a0912:	4798      	blx	r3
341a0914:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0916:	68fb      	ldr	r3, [r7, #12]
341a0918:	2b00      	cmp	r3, #0
341a091a:	d008      	beq.n	341a092e <VD6G_CheckModelId+0xca>
341a091c:	68fb      	ldr	r3, [r7, #12]
341a091e:	9300      	str	r3, [sp, #0]
341a0920:	f240 1391 	movw	r3, #401	@ 0x191
341a0924:	4a0d      	ldr	r2, [pc, #52]	@ (341a095c <VD6G_CheckModelId+0xf8>)
341a0926:	490e      	ldr	r1, [pc, #56]	@ (341a0960 <VD6G_CheckModelId+0xfc>)
341a0928:	6878      	ldr	r0, [r7, #4]
341a092a:	f7ff fe3c 	bl	341a05a6 <VD6G_error>
341a092e:	68fb      	ldr	r3, [r7, #12]
341a0930:	2b00      	cmp	r3, #0
341a0932:	d002      	beq.n	341a093a <VD6G_CheckModelId+0xd6>
341a0934:	6878      	ldr	r0, [r7, #4]
341a0936:	f7ff fe51 	bl	341a05dc <display_error>
341a093a:	68fb      	ldr	r3, [r7, #12]
341a093c:	2b00      	cmp	r3, #0
341a093e:	d001      	beq.n	341a0944 <VD6G_CheckModelId+0xe0>
341a0940:	68fb      	ldr	r3, [r7, #12]
341a0942:	e006      	b.n	341a0952 <VD6G_CheckModelId+0xee>
  VD6G_dbg(ctx, 0, "rom = 0x%04x\n", reg16);
341a0944:	893b      	ldrh	r3, [r7, #8]
341a0946:	4a0a      	ldr	r2, [pc, #40]	@ (341a0970 <VD6G_CheckModelId+0x10c>)
341a0948:	2100      	movs	r1, #0
341a094a:	6878      	ldr	r0, [r7, #4]
341a094c:	f7ff fdd8 	bl	341a0500 <VD6G_dbg>

  return 0;
341a0950:	2300      	movs	r3, #0
}
341a0952:	4618      	mov	r0, r3
341a0954:	3710      	adds	r7, #16
341a0956:	46bd      	mov	sp, r7
341a0958:	bd80      	pop	{r7, pc}
341a095a:	bf00      	nop
341a095c:	341ae460 	.word	0x341ae460
341a0960:	341a7b68 	.word	0x341a7b68
341a0964:	341a7bc0 	.word	0x341a7bc0
341a0968:	341a7bd4 	.word	0x341a7bd4
341a096c:	341a7c00 	.word	0x341a7c00
341a0970:	341a7c18 	.word	0x341a7c18

341a0974 <VD6G_ApplyPatchSlowBoot>:

static int VD6G_ApplyPatchSlowBoot(VD6G_Ctx_t *ctx)
{
341a0974:	b590      	push	{r4, r7, lr}
341a0976:	b089      	sub	sp, #36	@ 0x24
341a0978:	af02      	add	r7, sp, #8
341a097a:	6078      	str	r0, [r7, #4]
  uint8_t patch_major;
  uint8_t patch_minor;
  uint16_t reg16;
  int ret;

  patch_major = patch_cut2[3];
341a097c:	2302      	movs	r3, #2
341a097e:	75fb      	strb	r3, [r7, #23]
  patch_minor = patch_cut2[2];
341a0980:	231c      	movs	r3, #28
341a0982:	75bb      	strb	r3, [r7, #22]

  ret = ctx->write_array(ctx, 0x2000, (uint8_t *) patch_cut2, sizeof(patch_cut2));
341a0984:	687b      	ldr	r3, [r7, #4]
341a0986:	69dc      	ldr	r4, [r3, #28]
341a0988:	f642 23f8 	movw	r3, #11000	@ 0x2af8
341a098c:	4a4a      	ldr	r2, [pc, #296]	@ (341a0ab8 <VD6G_ApplyPatchSlowBoot+0x144>)
341a098e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
341a0992:	6878      	ldr	r0, [r7, #4]
341a0994:	47a0      	blx	r4
341a0996:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0998:	693b      	ldr	r3, [r7, #16]
341a099a:	2b00      	cmp	r3, #0
341a099c:	d008      	beq.n	341a09b0 <VD6G_ApplyPatchSlowBoot+0x3c>
341a099e:	693b      	ldr	r3, [r7, #16]
341a09a0:	9300      	str	r3, [sp, #0]
341a09a2:	f44f 73d1 	mov.w	r3, #418	@ 0x1a2
341a09a6:	4a45      	ldr	r2, [pc, #276]	@ (341a0abc <VD6G_ApplyPatchSlowBoot+0x148>)
341a09a8:	4945      	ldr	r1, [pc, #276]	@ (341a0ac0 <VD6G_ApplyPatchSlowBoot+0x14c>)
341a09aa:	6878      	ldr	r0, [r7, #4]
341a09ac:	f7ff fdfb 	bl	341a05a6 <VD6G_error>
341a09b0:	693b      	ldr	r3, [r7, #16]
341a09b2:	2b00      	cmp	r3, #0
341a09b4:	d002      	beq.n	341a09bc <VD6G_ApplyPatchSlowBoot+0x48>
341a09b6:	6878      	ldr	r0, [r7, #4]
341a09b8:	f7ff fe10 	bl	341a05dc <display_error>
341a09bc:	693b      	ldr	r3, [r7, #16]
341a09be:	2b00      	cmp	r3, #0
341a09c0:	d001      	beq.n	341a09c6 <VD6G_ApplyPatchSlowBoot+0x52>
341a09c2:	693b      	ldr	r3, [r7, #16]
341a09c4:	e074      	b.n	341a0ab0 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_PATCH_SETUP);
341a09c6:	687b      	ldr	r3, [r7, #4]
341a09c8:	691b      	ldr	r3, [r3, #16]
341a09ca:	2202      	movs	r2, #2
341a09cc:	f44f 7100 	mov.w	r1, #512	@ 0x200
341a09d0:	6878      	ldr	r0, [r7, #4]
341a09d2:	4798      	blx	r3
341a09d4:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a09d6:	693b      	ldr	r3, [r7, #16]
341a09d8:	2b00      	cmp	r3, #0
341a09da:	d008      	beq.n	341a09ee <VD6G_ApplyPatchSlowBoot+0x7a>
341a09dc:	693b      	ldr	r3, [r7, #16]
341a09de:	9300      	str	r3, [sp, #0]
341a09e0:	f240 13a5 	movw	r3, #421	@ 0x1a5
341a09e4:	4a35      	ldr	r2, [pc, #212]	@ (341a0abc <VD6G_ApplyPatchSlowBoot+0x148>)
341a09e6:	4936      	ldr	r1, [pc, #216]	@ (341a0ac0 <VD6G_ApplyPatchSlowBoot+0x14c>)
341a09e8:	6878      	ldr	r0, [r7, #4]
341a09ea:	f7ff fddc 	bl	341a05a6 <VD6G_error>
341a09ee:	693b      	ldr	r3, [r7, #16]
341a09f0:	2b00      	cmp	r3, #0
341a09f2:	d002      	beq.n	341a09fa <VD6G_ApplyPatchSlowBoot+0x86>
341a09f4:	6878      	ldr	r0, [r7, #4]
341a09f6:	f7ff fdf1 	bl	341a05dc <display_error>
341a09fa:	693b      	ldr	r3, [r7, #16]
341a09fc:	2b00      	cmp	r3, #0
341a09fe:	d001      	beq.n	341a0a04 <VD6G_ApplyPatchSlowBoot+0x90>
341a0a00:	693b      	ldr	r3, [r7, #16]
341a0a02:	e055      	b.n	341a0ab0 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
341a0a04:	2200      	movs	r2, #0
341a0a06:	f44f 7100 	mov.w	r1, #512	@ 0x200
341a0a0a:	6878      	ldr	r0, [r7, #4]
341a0a0c:	f7ff fe0e 	bl	341a062c <VD6G_PollReg8>
341a0a10:	6138      	str	r0, [r7, #16]
  if (ret)
341a0a12:	693b      	ldr	r3, [r7, #16]
341a0a14:	2b00      	cmp	r3, #0
341a0a16:	d001      	beq.n	341a0a1c <VD6G_ApplyPatchSlowBoot+0xa8>
    return ret;
341a0a18:	693b      	ldr	r3, [r7, #16]
341a0a1a:	e049      	b.n	341a0ab0 <VD6G_ApplyPatchSlowBoot+0x13c>

  ret = ctx->read16(ctx, VD6G_REG_FWPATCH_REVISION, &reg16);
341a0a1c:	687b      	ldr	r3, [r7, #4]
341a0a1e:	689b      	ldr	r3, [r3, #8]
341a0a20:	f107 020e 	add.w	r2, r7, #14
341a0a24:	211e      	movs	r1, #30
341a0a26:	6878      	ldr	r0, [r7, #4]
341a0a28:	4798      	blx	r3
341a0a2a:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0a2c:	693b      	ldr	r3, [r7, #16]
341a0a2e:	2b00      	cmp	r3, #0
341a0a30:	d008      	beq.n	341a0a44 <VD6G_ApplyPatchSlowBoot+0xd0>
341a0a32:	693b      	ldr	r3, [r7, #16]
341a0a34:	9300      	str	r3, [sp, #0]
341a0a36:	f44f 73d6 	mov.w	r3, #428	@ 0x1ac
341a0a3a:	4a20      	ldr	r2, [pc, #128]	@ (341a0abc <VD6G_ApplyPatchSlowBoot+0x148>)
341a0a3c:	4920      	ldr	r1, [pc, #128]	@ (341a0ac0 <VD6G_ApplyPatchSlowBoot+0x14c>)
341a0a3e:	6878      	ldr	r0, [r7, #4]
341a0a40:	f7ff fdb1 	bl	341a05a6 <VD6G_error>
341a0a44:	693b      	ldr	r3, [r7, #16]
341a0a46:	2b00      	cmp	r3, #0
341a0a48:	d002      	beq.n	341a0a50 <VD6G_ApplyPatchSlowBoot+0xdc>
341a0a4a:	6878      	ldr	r0, [r7, #4]
341a0a4c:	f7ff fdc6 	bl	341a05dc <display_error>
341a0a50:	693b      	ldr	r3, [r7, #16]
341a0a52:	2b00      	cmp	r3, #0
341a0a54:	d001      	beq.n	341a0a5a <VD6G_ApplyPatchSlowBoot+0xe6>
341a0a56:	693b      	ldr	r3, [r7, #16]
341a0a58:	e02a      	b.n	341a0ab0 <VD6G_ApplyPatchSlowBoot+0x13c>
  VD6G_dbg(ctx, 0, "patch = 0x%04x\n", reg16);
341a0a5a:	89fb      	ldrh	r3, [r7, #14]
341a0a5c:	4a19      	ldr	r2, [pc, #100]	@ (341a0ac4 <VD6G_ApplyPatchSlowBoot+0x150>)
341a0a5e:	2100      	movs	r1, #0
341a0a60:	6878      	ldr	r0, [r7, #4]
341a0a62:	f7ff fd4d 	bl	341a0500 <VD6G_dbg>

  if (reg16 != (patch_major << 8) + patch_minor) {
341a0a66:	89fb      	ldrh	r3, [r7, #14]
341a0a68:	4619      	mov	r1, r3
341a0a6a:	7dfb      	ldrb	r3, [r7, #23]
341a0a6c:	021a      	lsls	r2, r3, #8
341a0a6e:	7dbb      	ldrb	r3, [r7, #22]
341a0a70:	4413      	add	r3, r2
341a0a72:	4299      	cmp	r1, r3
341a0a74:	d011      	beq.n	341a0a9a <VD6G_ApplyPatchSlowBoot+0x126>
    VD6G_error(ctx, "bad patch version expected %d.%d got %d.%d\n", patch_major, patch_minor,
341a0a76:	7dfa      	ldrb	r2, [r7, #23]
341a0a78:	7db9      	ldrb	r1, [r7, #22]
341a0a7a:	89fb      	ldrh	r3, [r7, #14]
341a0a7c:	0a1b      	lsrs	r3, r3, #8
341a0a7e:	b29b      	uxth	r3, r3
341a0a80:	4618      	mov	r0, r3
341a0a82:	89fb      	ldrh	r3, [r7, #14]
341a0a84:	b2db      	uxtb	r3, r3
341a0a86:	9301      	str	r3, [sp, #4]
341a0a88:	9000      	str	r0, [sp, #0]
341a0a8a:	460b      	mov	r3, r1
341a0a8c:	490e      	ldr	r1, [pc, #56]	@ (341a0ac8 <VD6G_ApplyPatchSlowBoot+0x154>)
341a0a8e:	6878      	ldr	r0, [r7, #4]
341a0a90:	f7ff fd89 	bl	341a05a6 <VD6G_error>
                 reg16 >> 8, reg16 & 0xff);
    return -1;
341a0a94:	f04f 33ff 	mov.w	r3, #4294967295
341a0a98:	e00a      	b.n	341a0ab0 <VD6G_ApplyPatchSlowBoot+0x13c>
  }
  VD6G_notice(ctx, "patch %d.%d applied\n", reg16 >> 8, reg16 & 0xff);
341a0a9a:	89fb      	ldrh	r3, [r7, #14]
341a0a9c:	0a1b      	lsrs	r3, r3, #8
341a0a9e:	b29b      	uxth	r3, r3
341a0aa0:	461a      	mov	r2, r3
341a0aa2:	89fb      	ldrh	r3, [r7, #14]
341a0aa4:	b2db      	uxtb	r3, r3
341a0aa6:	4909      	ldr	r1, [pc, #36]	@ (341a0acc <VD6G_ApplyPatchSlowBoot+0x158>)
341a0aa8:	6878      	ldr	r0, [r7, #4]
341a0aaa:	f7ff fd46 	bl	341a053a <VD6G_notice>

  return 0;
341a0aae:	2300      	movs	r3, #0
}
341a0ab0:	4618      	mov	r0, r3
341a0ab2:	371c      	adds	r7, #28
341a0ab4:	46bd      	mov	sp, r7
341a0ab6:	bd90      	pop	{r4, r7, pc}
341a0ab8:	341aa05c 	.word	0x341aa05c
341a0abc:	341ae474 	.word	0x341ae474
341a0ac0:	341a7b68 	.word	0x341a7b68
341a0ac4:	341a7c28 	.word	0x341a7c28
341a0ac8:	341a7c38 	.word	0x341a7c38
341a0acc:	341a7c64 	.word	0x341a7c64

341a0ad0 <VD6G_ApplyPatch>:

static int VD6G_ApplyPatch(VD6G_Ctx_t *ctx)
{
341a0ad0:	b580      	push	{r7, lr}
341a0ad2:	b084      	sub	sp, #16
341a0ad4:	af00      	add	r7, sp, #0
341a0ad6:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  int ret;

  ret = VD6G_GetTopDie(ctx, &top_die);
341a0ad8:	f107 030b 	add.w	r3, r7, #11
341a0adc:	4619      	mov	r1, r3
341a0ade:	6878      	ldr	r0, [r7, #4]
341a0ae0:	f7ff fe84 	bl	341a07ec <VD6G_GetTopDie>
341a0ae4:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0ae6:	68fb      	ldr	r3, [r7, #12]
341a0ae8:	2b00      	cmp	r3, #0
341a0aea:	d001      	beq.n	341a0af0 <VD6G_ApplyPatch+0x20>
    return ret;
341a0aec:	68fb      	ldr	r3, [r7, #12]
341a0aee:	e015      	b.n	341a0b1c <VD6G_ApplyPatch+0x4c>

  switch (top_die) {
341a0af0:	7afb      	ldrb	r3, [r7, #11]
341a0af2:	2b20      	cmp	r3, #32
341a0af4:	d002      	beq.n	341a0afc <VD6G_ApplyPatch+0x2c>
341a0af6:	2b31      	cmp	r3, #49	@ 0x31
341a0af8:	d005      	beq.n	341a0b06 <VD6G_ApplyPatch+0x36>
341a0afa:	e007      	b.n	341a0b0c <VD6G_ApplyPatch+0x3c>
  case VD6G_TOP_DIE_SLOW_BOOT:
    ret = VD6G_ApplyPatchSlowBoot(ctx);
341a0afc:	6878      	ldr	r0, [r7, #4]
341a0afe:	f7ff ff39 	bl	341a0974 <VD6G_ApplyPatchSlowBoot>
341a0b02:	60f8      	str	r0, [r7, #12]
    break;
341a0b04:	e009      	b.n	341a0b1a <VD6G_ApplyPatch+0x4a>
  case VD6G_TOP_DIE_FAST_BOOT:
    ret = 0;
341a0b06:	2300      	movs	r3, #0
341a0b08:	60fb      	str	r3, [r7, #12]
    break;
341a0b0a:	e006      	b.n	341a0b1a <VD6G_ApplyPatch+0x4a>
  default:
    assert(0);
341a0b0c:	4b05      	ldr	r3, [pc, #20]	@ (341a0b24 <VD6G_ApplyPatch+0x54>)
341a0b0e:	4a06      	ldr	r2, [pc, #24]	@ (341a0b28 <VD6G_ApplyPatch+0x58>)
341a0b10:	f44f 71e5 	mov.w	r1, #458	@ 0x1ca
341a0b14:	4805      	ldr	r0, [pc, #20]	@ (341a0b2c <VD6G_ApplyPatch+0x5c>)
341a0b16:	f004 fa61 	bl	341a4fdc <__assert_func>
  }

  return ret;
341a0b1a:	68fb      	ldr	r3, [r7, #12]
}
341a0b1c:	4618      	mov	r0, r3
341a0b1e:	3710      	adds	r7, #16
341a0b20:	46bd      	mov	sp, r7
341a0b22:	bd80      	pop	{r7, pc}
341a0b24:	341a7c7c 	.word	0x341a7c7c
341a0b28:	341ae48c 	.word	0x341ae48c
341a0b2c:	341a7b18 	.word	0x341a7b18

341a0b30 <VD6G_BootMcu>:

static int VD6G_BootMcu(VD6G_Ctx_t *ctx)
{
341a0b30:	b580      	push	{r7, lr}
341a0b32:	b086      	sub	sp, #24
341a0b34:	af02      	add	r7, sp, #8
341a0b36:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_BOOT, VD6G_CMD_BOOT);
341a0b38:	687b      	ldr	r3, [r7, #4]
341a0b3a:	691b      	ldr	r3, [r3, #16]
341a0b3c:	2201      	movs	r2, #1
341a0b3e:	f44f 7100 	mov.w	r1, #512	@ 0x200
341a0b42:	6878      	ldr	r0, [r7, #4]
341a0b44:	4798      	blx	r3
341a0b46:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0b48:	68fb      	ldr	r3, [r7, #12]
341a0b4a:	2b00      	cmp	r3, #0
341a0b4c:	d008      	beq.n	341a0b60 <VD6G_BootMcu+0x30>
341a0b4e:	68fb      	ldr	r3, [r7, #12]
341a0b50:	9300      	str	r3, [sp, #0]
341a0b52:	f240 13d5 	movw	r3, #469	@ 0x1d5
341a0b56:	4a17      	ldr	r2, [pc, #92]	@ (341a0bb4 <VD6G_BootMcu+0x84>)
341a0b58:	4917      	ldr	r1, [pc, #92]	@ (341a0bb8 <VD6G_BootMcu+0x88>)
341a0b5a:	6878      	ldr	r0, [r7, #4]
341a0b5c:	f7ff fd23 	bl	341a05a6 <VD6G_error>
341a0b60:	68fb      	ldr	r3, [r7, #12]
341a0b62:	2b00      	cmp	r3, #0
341a0b64:	d002      	beq.n	341a0b6c <VD6G_BootMcu+0x3c>
341a0b66:	6878      	ldr	r0, [r7, #4]
341a0b68:	f7ff fd38 	bl	341a05dc <display_error>
341a0b6c:	68fb      	ldr	r3, [r7, #12]
341a0b6e:	2b00      	cmp	r3, #0
341a0b70:	d001      	beq.n	341a0b76 <VD6G_BootMcu+0x46>
341a0b72:	68fb      	ldr	r3, [r7, #12]
341a0b74:	e01a      	b.n	341a0bac <VD6G_BootMcu+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_BOOT, VD6G_CMD_ACK);
341a0b76:	2200      	movs	r2, #0
341a0b78:	f44f 7100 	mov.w	r1, #512	@ 0x200
341a0b7c:	6878      	ldr	r0, [r7, #4]
341a0b7e:	f7ff fd55 	bl	341a062c <VD6G_PollReg8>
341a0b82:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0b84:	68fb      	ldr	r3, [r7, #12]
341a0b86:	2b00      	cmp	r3, #0
341a0b88:	d001      	beq.n	341a0b8e <VD6G_BootMcu+0x5e>
    return ret;
341a0b8a:	68fb      	ldr	r3, [r7, #12]
341a0b8c:	e00e      	b.n	341a0bac <VD6G_BootMcu+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
341a0b8e:	2102      	movs	r1, #2
341a0b90:	6878      	ldr	r0, [r7, #4]
341a0b92:	f7ff fe05 	bl	341a07a0 <VD6G_WaitState>
341a0b96:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0b98:	68fb      	ldr	r3, [r7, #12]
341a0b9a:	2b00      	cmp	r3, #0
341a0b9c:	d001      	beq.n	341a0ba2 <VD6G_BootMcu+0x72>
    return ret;
341a0b9e:	68fb      	ldr	r3, [r7, #12]
341a0ba0:	e004      	b.n	341a0bac <VD6G_BootMcu+0x7c>

  VD6G_notice(ctx, "sensor boot successfully\n");
341a0ba2:	4906      	ldr	r1, [pc, #24]	@ (341a0bbc <VD6G_BootMcu+0x8c>)
341a0ba4:	6878      	ldr	r0, [r7, #4]
341a0ba6:	f7ff fcc8 	bl	341a053a <VD6G_notice>

  return 0;
341a0baa:	2300      	movs	r3, #0
}
341a0bac:	4618      	mov	r0, r3
341a0bae:	3710      	adds	r7, #16
341a0bb0:	46bd      	mov	sp, r7
341a0bb2:	bd80      	pop	{r7, pc}
341a0bb4:	341ae49c 	.word	0x341ae49c
341a0bb8:	341a7b68 	.word	0x341a7b68
341a0bbc:	341a7c80 	.word	0x341a7c80

341a0bc0 <VD6G_ApplyVtPatchSlowBoot>:

static int VD6G_ApplyVtPatchSlowBoot(VD6G_Ctx_t *ctx)
{
341a0bc0:	b590      	push	{r4, r7, lr}
341a0bc2:	b089      	sub	sp, #36	@ 0x24
341a0bc4:	af02      	add	r7, sp, #8
341a0bc6:	6078      	str	r0, [r7, #4]
  uint8_t cur_vtpatch_rd_rev, cur_vtpatch_gr_rev, cur_vtpatch_gt_rev;
  int vtpatch_offset = 0;
341a0bc8:	2300      	movs	r3, #0
341a0bca:	617b      	str	r3, [r7, #20]
  int ret;
  int i;

  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_START_VTRAM_UPDATE);
341a0bcc:	687b      	ldr	r3, [r7, #4]
341a0bce:	691b      	ldr	r3, [r3, #16]
341a0bd0:	2201      	movs	r2, #1
341a0bd2:	f240 2103 	movw	r1, #515	@ 0x203
341a0bd6:	6878      	ldr	r0, [r7, #4]
341a0bd8:	4798      	blx	r3
341a0bda:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0bdc:	68fb      	ldr	r3, [r7, #12]
341a0bde:	2b00      	cmp	r3, #0
341a0be0:	d008      	beq.n	341a0bf4 <VD6G_ApplyVtPatchSlowBoot+0x34>
341a0be2:	68fb      	ldr	r3, [r7, #12]
341a0be4:	9300      	str	r3, [sp, #0]
341a0be6:	f44f 73f6 	mov.w	r3, #492	@ 0x1ec
341a0bea:	4a89      	ldr	r2, [pc, #548]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0bec:	4989      	ldr	r1, [pc, #548]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0bee:	6878      	ldr	r0, [r7, #4]
341a0bf0:	f7ff fcd9 	bl	341a05a6 <VD6G_error>
341a0bf4:	68fb      	ldr	r3, [r7, #12]
341a0bf6:	2b00      	cmp	r3, #0
341a0bf8:	d002      	beq.n	341a0c00 <VD6G_ApplyVtPatchSlowBoot+0x40>
341a0bfa:	6878      	ldr	r0, [r7, #4]
341a0bfc:	f7ff fcee 	bl	341a05dc <display_error>
341a0c00:	68fb      	ldr	r3, [r7, #12]
341a0c02:	2b00      	cmp	r3, #0
341a0c04:	d001      	beq.n	341a0c0a <VD6G_ApplyVtPatchSlowBoot+0x4a>
341a0c06:	68fb      	ldr	r3, [r7, #12]
341a0c08:	e187      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
341a0c0a:	2200      	movs	r2, #0
341a0c0c:	f240 2103 	movw	r1, #515	@ 0x203
341a0c10:	6878      	ldr	r0, [r7, #4]
341a0c12:	f7ff fd0b 	bl	341a062c <VD6G_PollReg8>
341a0c16:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0c18:	68fb      	ldr	r3, [r7, #12]
341a0c1a:	2b00      	cmp	r3, #0
341a0c1c:	d001      	beq.n	341a0c22 <VD6G_ApplyVtPatchSlowBoot+0x62>
    return ret;
341a0c1e:	68fb      	ldr	r3, [r7, #12]
341a0c20:	e17b      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
341a0c22:	2102      	movs	r1, #2
341a0c24:	6878      	ldr	r0, [r7, #4]
341a0c26:	f7ff fdbb 	bl	341a07a0 <VD6G_WaitState>
341a0c2a:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0c2c:	68fb      	ldr	r3, [r7, #12]
341a0c2e:	2b00      	cmp	r3, #0
341a0c30:	d001      	beq.n	341a0c36 <VD6G_ApplyVtPatchSlowBoot+0x76>
    return ret;
341a0c32:	68fb      	ldr	r3, [r7, #12]
341a0c34:	e171      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  for (i = 0; i < vtpatch_area_nb; i++) {
341a0c36:	2300      	movs	r3, #0
341a0c38:	613b      	str	r3, [r7, #16]
341a0c3a:	e033      	b.n	341a0ca4 <VD6G_ApplyVtPatchSlowBoot+0xe4>
    ret = ctx->write_array(ctx, vtpatch_desc[i].offset, (uint8_t *) (vtpatch + vtpatch_offset),
341a0c3c:	687b      	ldr	r3, [r7, #4]
341a0c3e:	69dc      	ldr	r4, [r3, #28]
341a0c40:	4a75      	ldr	r2, [pc, #468]	@ (341a0e18 <VD6G_ApplyVtPatchSlowBoot+0x258>)
341a0c42:	693b      	ldr	r3, [r7, #16]
341a0c44:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
341a0c48:	b299      	uxth	r1, r3
341a0c4a:	697b      	ldr	r3, [r7, #20]
341a0c4c:	4a73      	ldr	r2, [pc, #460]	@ (341a0e1c <VD6G_ApplyVtPatchSlowBoot+0x25c>)
341a0c4e:	441a      	add	r2, r3
341a0c50:	4871      	ldr	r0, [pc, #452]	@ (341a0e18 <VD6G_ApplyVtPatchSlowBoot+0x258>)
341a0c52:	693b      	ldr	r3, [r7, #16]
341a0c54:	00db      	lsls	r3, r3, #3
341a0c56:	4403      	add	r3, r0
341a0c58:	685b      	ldr	r3, [r3, #4]
341a0c5a:	6878      	ldr	r0, [r7, #4]
341a0c5c:	47a0      	blx	r4
341a0c5e:	60f8      	str	r0, [r7, #12]
                           vtpatch_desc[i].size);
    VD6G_TraceError(ctx, ret);
341a0c60:	68fb      	ldr	r3, [r7, #12]
341a0c62:	2b00      	cmp	r3, #0
341a0c64:	d008      	beq.n	341a0c78 <VD6G_ApplyVtPatchSlowBoot+0xb8>
341a0c66:	68fb      	ldr	r3, [r7, #12]
341a0c68:	9300      	str	r3, [sp, #0]
341a0c6a:	f240 13f9 	movw	r3, #505	@ 0x1f9
341a0c6e:	4a68      	ldr	r2, [pc, #416]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0c70:	4968      	ldr	r1, [pc, #416]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0c72:	6878      	ldr	r0, [r7, #4]
341a0c74:	f7ff fc97 	bl	341a05a6 <VD6G_error>
341a0c78:	68fb      	ldr	r3, [r7, #12]
341a0c7a:	2b00      	cmp	r3, #0
341a0c7c:	d002      	beq.n	341a0c84 <VD6G_ApplyVtPatchSlowBoot+0xc4>
341a0c7e:	6878      	ldr	r0, [r7, #4]
341a0c80:	f7ff fcac 	bl	341a05dc <display_error>
341a0c84:	68fb      	ldr	r3, [r7, #12]
341a0c86:	2b00      	cmp	r3, #0
341a0c88:	d001      	beq.n	341a0c8e <VD6G_ApplyVtPatchSlowBoot+0xce>
341a0c8a:	68fb      	ldr	r3, [r7, #12]
341a0c8c:	e145      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
    vtpatch_offset += vtpatch_desc[i].size;
341a0c8e:	4a62      	ldr	r2, [pc, #392]	@ (341a0e18 <VD6G_ApplyVtPatchSlowBoot+0x258>)
341a0c90:	693b      	ldr	r3, [r7, #16]
341a0c92:	00db      	lsls	r3, r3, #3
341a0c94:	4413      	add	r3, r2
341a0c96:	685b      	ldr	r3, [r3, #4]
341a0c98:	697a      	ldr	r2, [r7, #20]
341a0c9a:	4413      	add	r3, r2
341a0c9c:	617b      	str	r3, [r7, #20]
  for (i = 0; i < vtpatch_area_nb; i++) {
341a0c9e:	693b      	ldr	r3, [r7, #16]
341a0ca0:	3301      	adds	r3, #1
341a0ca2:	613b      	str	r3, [r7, #16]
341a0ca4:	4b5e      	ldr	r3, [pc, #376]	@ (341a0e20 <VD6G_ApplyVtPatchSlowBoot+0x260>)
341a0ca6:	681b      	ldr	r3, [r3, #0]
341a0ca8:	693a      	ldr	r2, [r7, #16]
341a0caa:	429a      	cmp	r2, r3
341a0cac:	dbc6      	blt.n	341a0c3c <VD6G_ApplyVtPatchSlowBoot+0x7c>
  }
  ret = ctx->write8(ctx, 0xd9f8, VT_REVISION);
341a0cae:	687b      	ldr	r3, [r7, #4]
341a0cb0:	691b      	ldr	r3, [r3, #16]
341a0cb2:	2211      	movs	r2, #17
341a0cb4:	f64d 11f8 	movw	r1, #55800	@ 0xd9f8
341a0cb8:	6878      	ldr	r0, [r7, #4]
341a0cba:	4798      	blx	r3
341a0cbc:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0cbe:	68fb      	ldr	r3, [r7, #12]
341a0cc0:	2b00      	cmp	r3, #0
341a0cc2:	d008      	beq.n	341a0cd6 <VD6G_ApplyVtPatchSlowBoot+0x116>
341a0cc4:	68fb      	ldr	r3, [r7, #12]
341a0cc6:	9300      	str	r3, [sp, #0]
341a0cc8:	f240 13fd 	movw	r3, #509	@ 0x1fd
341a0ccc:	4a50      	ldr	r2, [pc, #320]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0cce:	4951      	ldr	r1, [pc, #324]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0cd0:	6878      	ldr	r0, [r7, #4]
341a0cd2:	f7ff fc68 	bl	341a05a6 <VD6G_error>
341a0cd6:	68fb      	ldr	r3, [r7, #12]
341a0cd8:	2b00      	cmp	r3, #0
341a0cda:	d002      	beq.n	341a0ce2 <VD6G_ApplyVtPatchSlowBoot+0x122>
341a0cdc:	6878      	ldr	r0, [r7, #4]
341a0cde:	f7ff fc7d 	bl	341a05dc <display_error>
341a0ce2:	68fb      	ldr	r3, [r7, #12]
341a0ce4:	2b00      	cmp	r3, #0
341a0ce6:	d001      	beq.n	341a0cec <VD6G_ApplyVtPatchSlowBoot+0x12c>
341a0ce8:	68fb      	ldr	r3, [r7, #12]
341a0cea:	e116      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xaffc, VT_REVISION);
341a0cec:	687b      	ldr	r3, [r7, #4]
341a0cee:	691b      	ldr	r3, [r3, #16]
341a0cf0:	2211      	movs	r2, #17
341a0cf2:	f64a 71fc 	movw	r1, #45052	@ 0xaffc
341a0cf6:	6878      	ldr	r0, [r7, #4]
341a0cf8:	4798      	blx	r3
341a0cfa:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0cfc:	68fb      	ldr	r3, [r7, #12]
341a0cfe:	2b00      	cmp	r3, #0
341a0d00:	d008      	beq.n	341a0d14 <VD6G_ApplyVtPatchSlowBoot+0x154>
341a0d02:	68fb      	ldr	r3, [r7, #12]
341a0d04:	9300      	str	r3, [sp, #0]
341a0d06:	f240 13ff 	movw	r3, #511	@ 0x1ff
341a0d0a:	4a41      	ldr	r2, [pc, #260]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0d0c:	4941      	ldr	r1, [pc, #260]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0d0e:	6878      	ldr	r0, [r7, #4]
341a0d10:	f7ff fc49 	bl	341a05a6 <VD6G_error>
341a0d14:	68fb      	ldr	r3, [r7, #12]
341a0d16:	2b00      	cmp	r3, #0
341a0d18:	d002      	beq.n	341a0d20 <VD6G_ApplyVtPatchSlowBoot+0x160>
341a0d1a:	6878      	ldr	r0, [r7, #4]
341a0d1c:	f7ff fc5e 	bl	341a05dc <display_error>
341a0d20:	68fb      	ldr	r3, [r7, #12]
341a0d22:	2b00      	cmp	r3, #0
341a0d24:	d001      	beq.n	341a0d2a <VD6G_ApplyVtPatchSlowBoot+0x16a>
341a0d26:	68fb      	ldr	r3, [r7, #12]
341a0d28:	e0f7      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xbbb4, VT_REVISION);
341a0d2a:	687b      	ldr	r3, [r7, #4]
341a0d2c:	691b      	ldr	r3, [r3, #16]
341a0d2e:	2211      	movs	r2, #17
341a0d30:	f64b 31b4 	movw	r1, #48052	@ 0xbbb4
341a0d34:	6878      	ldr	r0, [r7, #4]
341a0d36:	4798      	blx	r3
341a0d38:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0d3a:	68fb      	ldr	r3, [r7, #12]
341a0d3c:	2b00      	cmp	r3, #0
341a0d3e:	d008      	beq.n	341a0d52 <VD6G_ApplyVtPatchSlowBoot+0x192>
341a0d40:	68fb      	ldr	r3, [r7, #12]
341a0d42:	9300      	str	r3, [sp, #0]
341a0d44:	f240 2301 	movw	r3, #513	@ 0x201
341a0d48:	4a31      	ldr	r2, [pc, #196]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0d4a:	4932      	ldr	r1, [pc, #200]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0d4c:	6878      	ldr	r0, [r7, #4]
341a0d4e:	f7ff fc2a 	bl	341a05a6 <VD6G_error>
341a0d52:	68fb      	ldr	r3, [r7, #12]
341a0d54:	2b00      	cmp	r3, #0
341a0d56:	d002      	beq.n	341a0d5e <VD6G_ApplyVtPatchSlowBoot+0x19e>
341a0d58:	6878      	ldr	r0, [r7, #4]
341a0d5a:	f7ff fc3f 	bl	341a05dc <display_error>
341a0d5e:	68fb      	ldr	r3, [r7, #12]
341a0d60:	2b00      	cmp	r3, #0
341a0d62:	d001      	beq.n	341a0d68 <VD6G_ApplyVtPatchSlowBoot+0x1a8>
341a0d64:	68fb      	ldr	r3, [r7, #12]
341a0d66:	e0d8      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->write8(ctx, 0xb898, VT_REVISION);
341a0d68:	687b      	ldr	r3, [r7, #4]
341a0d6a:	691b      	ldr	r3, [r3, #16]
341a0d6c:	2211      	movs	r2, #17
341a0d6e:	f64b 0198 	movw	r1, #47256	@ 0xb898
341a0d72:	6878      	ldr	r0, [r7, #4]
341a0d74:	4798      	blx	r3
341a0d76:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0d78:	68fb      	ldr	r3, [r7, #12]
341a0d7a:	2b00      	cmp	r3, #0
341a0d7c:	d008      	beq.n	341a0d90 <VD6G_ApplyVtPatchSlowBoot+0x1d0>
341a0d7e:	68fb      	ldr	r3, [r7, #12]
341a0d80:	9300      	str	r3, [sp, #0]
341a0d82:	f240 2303 	movw	r3, #515	@ 0x203
341a0d86:	4a22      	ldr	r2, [pc, #136]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0d88:	4922      	ldr	r1, [pc, #136]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0d8a:	6878      	ldr	r0, [r7, #4]
341a0d8c:	f7ff fc0b 	bl	341a05a6 <VD6G_error>
341a0d90:	68fb      	ldr	r3, [r7, #12]
341a0d92:	2b00      	cmp	r3, #0
341a0d94:	d002      	beq.n	341a0d9c <VD6G_ApplyVtPatchSlowBoot+0x1dc>
341a0d96:	6878      	ldr	r0, [r7, #4]
341a0d98:	f7ff fc20 	bl	341a05dc <display_error>
341a0d9c:	68fb      	ldr	r3, [r7, #12]
341a0d9e:	2b00      	cmp	r3, #0
341a0da0:	d001      	beq.n	341a0da6 <VD6G_ApplyVtPatchSlowBoot+0x1e6>
341a0da2:	68fb      	ldr	r3, [r7, #12]
341a0da4:	e0b9      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = ctx->write8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_END_VTRAM_UPDATE);
341a0da6:	687b      	ldr	r3, [r7, #4]
341a0da8:	691b      	ldr	r3, [r3, #16]
341a0daa:	2202      	movs	r2, #2
341a0dac:	f240 2103 	movw	r1, #515	@ 0x203
341a0db0:	6878      	ldr	r0, [r7, #4]
341a0db2:	4798      	blx	r3
341a0db4:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0db6:	68fb      	ldr	r3, [r7, #12]
341a0db8:	2b00      	cmp	r3, #0
341a0dba:	d008      	beq.n	341a0dce <VD6G_ApplyVtPatchSlowBoot+0x20e>
341a0dbc:	68fb      	ldr	r3, [r7, #12]
341a0dbe:	9300      	str	r3, [sp, #0]
341a0dc0:	f240 2306 	movw	r3, #518	@ 0x206
341a0dc4:	4a12      	ldr	r2, [pc, #72]	@ (341a0e10 <VD6G_ApplyVtPatchSlowBoot+0x250>)
341a0dc6:	4913      	ldr	r1, [pc, #76]	@ (341a0e14 <VD6G_ApplyVtPatchSlowBoot+0x254>)
341a0dc8:	6878      	ldr	r0, [r7, #4]
341a0dca:	f7ff fbec 	bl	341a05a6 <VD6G_error>
341a0dce:	68fb      	ldr	r3, [r7, #12]
341a0dd0:	2b00      	cmp	r3, #0
341a0dd2:	d002      	beq.n	341a0dda <VD6G_ApplyVtPatchSlowBoot+0x21a>
341a0dd4:	6878      	ldr	r0, [r7, #4]
341a0dd6:	f7ff fc01 	bl	341a05dc <display_error>
341a0dda:	68fb      	ldr	r3, [r7, #12]
341a0ddc:	2b00      	cmp	r3, #0
341a0dde:	d001      	beq.n	341a0de4 <VD6G_ApplyVtPatchSlowBoot+0x224>
341a0de0:	68fb      	ldr	r3, [r7, #12]
341a0de2:	e09a      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_PollReg8(ctx, VD6G_REG_VTPATCHING, VD6G_CMD_ACK);
341a0de4:	2200      	movs	r2, #0
341a0de6:	f240 2103 	movw	r1, #515	@ 0x203
341a0dea:	6878      	ldr	r0, [r7, #4]
341a0dec:	f7ff fc1e 	bl	341a062c <VD6G_PollReg8>
341a0df0:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0df2:	68fb      	ldr	r3, [r7, #12]
341a0df4:	2b00      	cmp	r3, #0
341a0df6:	d001      	beq.n	341a0dfc <VD6G_ApplyVtPatchSlowBoot+0x23c>
    return ret;
341a0df8:	68fb      	ldr	r3, [r7, #12]
341a0dfa:	e08e      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
341a0dfc:	2102      	movs	r1, #2
341a0dfe:	6878      	ldr	r0, [r7, #4]
341a0e00:	f7ff fcce 	bl	341a07a0 <VD6G_WaitState>
341a0e04:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0e06:	68fb      	ldr	r3, [r7, #12]
341a0e08:	2b00      	cmp	r3, #0
341a0e0a:	d00b      	beq.n	341a0e24 <VD6G_ApplyVtPatchSlowBoot+0x264>
    return ret;
341a0e0c:	68fb      	ldr	r3, [r7, #12]
341a0e0e:	e084      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
341a0e10:	341ae4ac 	.word	0x341ae4ac
341a0e14:	341a7b68 	.word	0x341a7b68
341a0e18:	341c00f4 	.word	0x341c00f4
341a0e1c:	341acb54 	.word	0x341acb54
341a0e20:	341c012c 	.word	0x341c012c

  ret = ctx->read8(ctx, VD6G_REG_VTIMING_RD_REVISION, &cur_vtpatch_rd_rev);
341a0e24:	687b      	ldr	r3, [r7, #4]
341a0e26:	685b      	ldr	r3, [r3, #4]
341a0e28:	f107 020b 	add.w	r2, r7, #11
341a0e2c:	2120      	movs	r1, #32
341a0e2e:	6878      	ldr	r0, [r7, #4]
341a0e30:	4798      	blx	r3
341a0e32:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0e34:	68fb      	ldr	r3, [r7, #12]
341a0e36:	2b00      	cmp	r3, #0
341a0e38:	d008      	beq.n	341a0e4c <VD6G_ApplyVtPatchSlowBoot+0x28c>
341a0e3a:	68fb      	ldr	r3, [r7, #12]
341a0e3c:	9300      	str	r3, [sp, #0]
341a0e3e:	f240 2311 	movw	r3, #529	@ 0x211
341a0e42:	4a38      	ldr	r2, [pc, #224]	@ (341a0f24 <VD6G_ApplyVtPatchSlowBoot+0x364>)
341a0e44:	4938      	ldr	r1, [pc, #224]	@ (341a0f28 <VD6G_ApplyVtPatchSlowBoot+0x368>)
341a0e46:	6878      	ldr	r0, [r7, #4]
341a0e48:	f7ff fbad 	bl	341a05a6 <VD6G_error>
341a0e4c:	68fb      	ldr	r3, [r7, #12]
341a0e4e:	2b00      	cmp	r3, #0
341a0e50:	d002      	beq.n	341a0e58 <VD6G_ApplyVtPatchSlowBoot+0x298>
341a0e52:	6878      	ldr	r0, [r7, #4]
341a0e54:	f7ff fbc2 	bl	341a05dc <display_error>
341a0e58:	68fb      	ldr	r3, [r7, #12]
341a0e5a:	2b00      	cmp	r3, #0
341a0e5c:	d001      	beq.n	341a0e62 <VD6G_ApplyVtPatchSlowBoot+0x2a2>
341a0e5e:	68fb      	ldr	r3, [r7, #12]
341a0e60:	e05b      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GR_REVISION, &cur_vtpatch_gr_rev);
341a0e62:	687b      	ldr	r3, [r7, #4]
341a0e64:	685b      	ldr	r3, [r3, #4]
341a0e66:	f107 020a 	add.w	r2, r7, #10
341a0e6a:	2124      	movs	r1, #36	@ 0x24
341a0e6c:	6878      	ldr	r0, [r7, #4]
341a0e6e:	4798      	blx	r3
341a0e70:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0e72:	68fb      	ldr	r3, [r7, #12]
341a0e74:	2b00      	cmp	r3, #0
341a0e76:	d008      	beq.n	341a0e8a <VD6G_ApplyVtPatchSlowBoot+0x2ca>
341a0e78:	68fb      	ldr	r3, [r7, #12]
341a0e7a:	9300      	str	r3, [sp, #0]
341a0e7c:	f240 2313 	movw	r3, #531	@ 0x213
341a0e80:	4a28      	ldr	r2, [pc, #160]	@ (341a0f24 <VD6G_ApplyVtPatchSlowBoot+0x364>)
341a0e82:	4929      	ldr	r1, [pc, #164]	@ (341a0f28 <VD6G_ApplyVtPatchSlowBoot+0x368>)
341a0e84:	6878      	ldr	r0, [r7, #4]
341a0e86:	f7ff fb8e 	bl	341a05a6 <VD6G_error>
341a0e8a:	68fb      	ldr	r3, [r7, #12]
341a0e8c:	2b00      	cmp	r3, #0
341a0e8e:	d002      	beq.n	341a0e96 <VD6G_ApplyVtPatchSlowBoot+0x2d6>
341a0e90:	6878      	ldr	r0, [r7, #4]
341a0e92:	f7ff fba3 	bl	341a05dc <display_error>
341a0e96:	68fb      	ldr	r3, [r7, #12]
341a0e98:	2b00      	cmp	r3, #0
341a0e9a:	d001      	beq.n	341a0ea0 <VD6G_ApplyVtPatchSlowBoot+0x2e0>
341a0e9c:	68fb      	ldr	r3, [r7, #12]
341a0e9e:	e03c      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  ret = ctx->read8(ctx, VD6G_REG_VTIMING_GT_REVISION, &cur_vtpatch_gt_rev);
341a0ea0:	687b      	ldr	r3, [r7, #4]
341a0ea2:	685b      	ldr	r3, [r3, #4]
341a0ea4:	f107 0209 	add.w	r2, r7, #9
341a0ea8:	2126      	movs	r1, #38	@ 0x26
341a0eaa:	6878      	ldr	r0, [r7, #4]
341a0eac:	4798      	blx	r3
341a0eae:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a0eb0:	68fb      	ldr	r3, [r7, #12]
341a0eb2:	2b00      	cmp	r3, #0
341a0eb4:	d008      	beq.n	341a0ec8 <VD6G_ApplyVtPatchSlowBoot+0x308>
341a0eb6:	68fb      	ldr	r3, [r7, #12]
341a0eb8:	9300      	str	r3, [sp, #0]
341a0eba:	f240 2315 	movw	r3, #533	@ 0x215
341a0ebe:	4a19      	ldr	r2, [pc, #100]	@ (341a0f24 <VD6G_ApplyVtPatchSlowBoot+0x364>)
341a0ec0:	4919      	ldr	r1, [pc, #100]	@ (341a0f28 <VD6G_ApplyVtPatchSlowBoot+0x368>)
341a0ec2:	6878      	ldr	r0, [r7, #4]
341a0ec4:	f7ff fb6f 	bl	341a05a6 <VD6G_error>
341a0ec8:	68fb      	ldr	r3, [r7, #12]
341a0eca:	2b00      	cmp	r3, #0
341a0ecc:	d002      	beq.n	341a0ed4 <VD6G_ApplyVtPatchSlowBoot+0x314>
341a0ece:	6878      	ldr	r0, [r7, #4]
341a0ed0:	f7ff fb84 	bl	341a05dc <display_error>
341a0ed4:	68fb      	ldr	r3, [r7, #12]
341a0ed6:	2b00      	cmp	r3, #0
341a0ed8:	d001      	beq.n	341a0ede <VD6G_ApplyVtPatchSlowBoot+0x31e>
341a0eda:	68fb      	ldr	r3, [r7, #12]
341a0edc:	e01d      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>

  if (cur_vtpatch_rd_rev != VT_REVISION ||
341a0ede:	7afb      	ldrb	r3, [r7, #11]
341a0ee0:	2b11      	cmp	r3, #17
341a0ee2:	d105      	bne.n	341a0ef0 <VD6G_ApplyVtPatchSlowBoot+0x330>
      cur_vtpatch_gr_rev != VT_REVISION ||
341a0ee4:	7abb      	ldrb	r3, [r7, #10]
  if (cur_vtpatch_rd_rev != VT_REVISION ||
341a0ee6:	2b11      	cmp	r3, #17
341a0ee8:	d102      	bne.n	341a0ef0 <VD6G_ApplyVtPatchSlowBoot+0x330>
      cur_vtpatch_gt_rev != VT_REVISION) {
341a0eea:	7a7b      	ldrb	r3, [r7, #9]
      cur_vtpatch_gr_rev != VT_REVISION ||
341a0eec:	2b11      	cmp	r3, #17
341a0eee:	d00e      	beq.n	341a0f0e <VD6G_ApplyVtPatchSlowBoot+0x34e>
    VD6G_error(ctx, "bad vtpatch version, expected %d got rd:%d, gr:%d gt:%d\n", VT_REVISION, cur_vtpatch_rd_rev,
341a0ef0:	7afb      	ldrb	r3, [r7, #11]
341a0ef2:	4619      	mov	r1, r3
341a0ef4:	7abb      	ldrb	r3, [r7, #10]
341a0ef6:	7a7a      	ldrb	r2, [r7, #9]
341a0ef8:	9201      	str	r2, [sp, #4]
341a0efa:	9300      	str	r3, [sp, #0]
341a0efc:	460b      	mov	r3, r1
341a0efe:	2211      	movs	r2, #17
341a0f00:	490a      	ldr	r1, [pc, #40]	@ (341a0f2c <VD6G_ApplyVtPatchSlowBoot+0x36c>)
341a0f02:	6878      	ldr	r0, [r7, #4]
341a0f04:	f7ff fb4f 	bl	341a05a6 <VD6G_error>
                 cur_vtpatch_gr_rev, cur_vtpatch_gt_rev);
    return -1;
341a0f08:	f04f 33ff 	mov.w	r3, #4294967295
341a0f0c:	e005      	b.n	341a0f1a <VD6G_ApplyVtPatchSlowBoot+0x35a>
  }
  VD6G_notice(ctx, "VT patch %d applied\n", VT_REVISION);
341a0f0e:	2211      	movs	r2, #17
341a0f10:	4907      	ldr	r1, [pc, #28]	@ (341a0f30 <VD6G_ApplyVtPatchSlowBoot+0x370>)
341a0f12:	6878      	ldr	r0, [r7, #4]
341a0f14:	f7ff fb11 	bl	341a053a <VD6G_notice>

  return 0;
341a0f18:	2300      	movs	r3, #0
}
341a0f1a:	4618      	mov	r0, r3
341a0f1c:	371c      	adds	r7, #28
341a0f1e:	46bd      	mov	sp, r7
341a0f20:	bd90      	pop	{r4, r7, pc}
341a0f22:	bf00      	nop
341a0f24:	341ae4ac 	.word	0x341ae4ac
341a0f28:	341a7b68 	.word	0x341a7b68
341a0f2c:	341a7c9c 	.word	0x341a7c9c
341a0f30:	341a7cd8 	.word	0x341a7cd8

341a0f34 <VD6G_ApplyVtPatch>:

static int VD6G_ApplyVtPatch(VD6G_Ctx_t *ctx)
{
341a0f34:	b580      	push	{r7, lr}
341a0f36:	b084      	sub	sp, #16
341a0f38:	af00      	add	r7, sp, #0
341a0f3a:	6078      	str	r0, [r7, #4]
  uint8_t top_die;
  int ret;

  ret = VD6G_GetTopDie(ctx, &top_die);
341a0f3c:	f107 030b 	add.w	r3, r7, #11
341a0f40:	4619      	mov	r1, r3
341a0f42:	6878      	ldr	r0, [r7, #4]
341a0f44:	f7ff fc52 	bl	341a07ec <VD6G_GetTopDie>
341a0f48:	60f8      	str	r0, [r7, #12]
  if (ret)
341a0f4a:	68fb      	ldr	r3, [r7, #12]
341a0f4c:	2b00      	cmp	r3, #0
341a0f4e:	d001      	beq.n	341a0f54 <VD6G_ApplyVtPatch+0x20>
    return ret;
341a0f50:	68fb      	ldr	r3, [r7, #12]
341a0f52:	e015      	b.n	341a0f80 <VD6G_ApplyVtPatch+0x4c>

  switch (top_die) {
341a0f54:	7afb      	ldrb	r3, [r7, #11]
341a0f56:	2b20      	cmp	r3, #32
341a0f58:	d002      	beq.n	341a0f60 <VD6G_ApplyVtPatch+0x2c>
341a0f5a:	2b31      	cmp	r3, #49	@ 0x31
341a0f5c:	d005      	beq.n	341a0f6a <VD6G_ApplyVtPatch+0x36>
341a0f5e:	e007      	b.n	341a0f70 <VD6G_ApplyVtPatch+0x3c>
  case VD6G_TOP_DIE_SLOW_BOOT:
    ret = VD6G_ApplyVtPatchSlowBoot(ctx);
341a0f60:	6878      	ldr	r0, [r7, #4]
341a0f62:	f7ff fe2d 	bl	341a0bc0 <VD6G_ApplyVtPatchSlowBoot>
341a0f66:	60f8      	str	r0, [r7, #12]
    break;
341a0f68:	e009      	b.n	341a0f7e <VD6G_ApplyVtPatch+0x4a>
  case VD6G_TOP_DIE_FAST_BOOT:
    ret = 0;
341a0f6a:	2300      	movs	r3, #0
341a0f6c:	60fb      	str	r3, [r7, #12]
    break;
341a0f6e:	e006      	b.n	341a0f7e <VD6G_ApplyVtPatch+0x4a>
  default:
    assert(0);
341a0f70:	4b05      	ldr	r3, [pc, #20]	@ (341a0f88 <VD6G_ApplyVtPatch+0x54>)
341a0f72:	4a06      	ldr	r2, [pc, #24]	@ (341a0f8c <VD6G_ApplyVtPatch+0x58>)
341a0f74:	f44f 710d 	mov.w	r1, #564	@ 0x234
341a0f78:	4805      	ldr	r0, [pc, #20]	@ (341a0f90 <VD6G_ApplyVtPatch+0x5c>)
341a0f7a:	f004 f82f 	bl	341a4fdc <__assert_func>
  }

  return ret;
341a0f7e:	68fb      	ldr	r3, [r7, #12]
}
341a0f80:	4618      	mov	r0, r3
341a0f82:	3710      	adds	r7, #16
341a0f84:	46bd      	mov	sp, r7
341a0f86:	bd80      	pop	{r7, pc}
341a0f88:	341a7c7c 	.word	0x341a7c7c
341a0f8c:	341ae4c8 	.word	0x341ae4c8
341a0f90:	341a7b18 	.word	0x341a7b18

341a0f94 <VD6G_SetBayerType>:

static int VD6G_SetBayerType(VD6G_Ctx_t *ctx)
{
341a0f94:	b580      	push	{r7, lr}
341a0f96:	b088      	sub	sp, #32
341a0f98:	af02      	add	r7, sp, #8
341a0f9a:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a0f9c:	687b      	ldr	r3, [r7, #4]
341a0f9e:	332c      	adds	r3, #44	@ 0x2c
341a0fa0:	617b      	str	r3, [r7, #20]
  uint8_t reg8;
  int ret;

  ret = ctx->read8(ctx, VD6G_REG_OPTICAL_REVISION, &reg8);
341a0fa2:	687b      	ldr	r3, [r7, #4]
341a0fa4:	685b      	ldr	r3, [r3, #4]
341a0fa6:	f107 020f 	add.w	r2, r7, #15
341a0faa:	211a      	movs	r1, #26
341a0fac:	6878      	ldr	r0, [r7, #4]
341a0fae:	4798      	blx	r3
341a0fb0:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a0fb2:	693b      	ldr	r3, [r7, #16]
341a0fb4:	2b00      	cmp	r3, #0
341a0fb6:	d008      	beq.n	341a0fca <VD6G_SetBayerType+0x36>
341a0fb8:	693b      	ldr	r3, [r7, #16]
341a0fba:	9300      	str	r3, [sp, #0]
341a0fbc:	f240 2341 	movw	r3, #577	@ 0x241
341a0fc0:	4a24      	ldr	r2, [pc, #144]	@ (341a1054 <VD6G_SetBayerType+0xc0>)
341a0fc2:	4925      	ldr	r1, [pc, #148]	@ (341a1058 <VD6G_SetBayerType+0xc4>)
341a0fc4:	6878      	ldr	r0, [r7, #4]
341a0fc6:	f7ff faee 	bl	341a05a6 <VD6G_error>
341a0fca:	693b      	ldr	r3, [r7, #16]
341a0fcc:	2b00      	cmp	r3, #0
341a0fce:	d002      	beq.n	341a0fd6 <VD6G_SetBayerType+0x42>
341a0fd0:	6878      	ldr	r0, [r7, #4]
341a0fd2:	f7ff fb03 	bl	341a05dc <display_error>
341a0fd6:	693b      	ldr	r3, [r7, #16]
341a0fd8:	2b00      	cmp	r3, #0
341a0fda:	d001      	beq.n	341a0fe0 <VD6G_SetBayerType+0x4c>
341a0fdc:	693b      	ldr	r3, [r7, #16]
341a0fde:	e035      	b.n	341a104c <VD6G_SetBayerType+0xb8>

  if (!(reg8 & 1)) {
341a0fe0:	7bfb      	ldrb	r3, [r7, #15]
341a0fe2:	f003 0301 	and.w	r3, r3, #1
341a0fe6:	2b00      	cmp	r3, #0
341a0fe8:	d105      	bne.n	341a0ff6 <VD6G_SetBayerType+0x62>
    ctx->bayer = VD6G_BAYER_NONE;
341a0fea:	687b      	ldr	r3, [r7, #4]
341a0fec:	2200      	movs	r2, #0
341a0fee:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    return 0;
341a0ff2:	2300      	movs	r3, #0
341a0ff4:	e02a      	b.n	341a104c <VD6G_SetBayerType+0xb8>
  }

  switch (drv_ctx->config_save.flip_mirror_mode) {
341a0ff6:	697b      	ldr	r3, [r7, #20]
341a0ff8:	7c1b      	ldrb	r3, [r3, #16]
341a0ffa:	2b03      	cmp	r3, #3
341a0ffc:	d81e      	bhi.n	341a103c <VD6G_SetBayerType+0xa8>
341a0ffe:	a201      	add	r2, pc, #4	@ (adr r2, 341a1004 <VD6G_SetBayerType+0x70>)
341a1000:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a1004:	341a1015 	.word	0x341a1015
341a1008:	341a101f 	.word	0x341a101f
341a100c:	341a1029 	.word	0x341a1029
341a1010:	341a1033 	.word	0x341a1033
  case VD6G_MIRROR_FLIP_NONE:
    ctx->bayer = VD6G_BAYER_GRBG;
341a1014:	687b      	ldr	r3, [r7, #4]
341a1016:	2202      	movs	r2, #2
341a1018:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
341a101c:	e015      	b.n	341a104a <VD6G_SetBayerType+0xb6>
  case VD6G_FLIP:
    ctx->bayer = VD6G_BAYER_BGGR;
341a101e:	687b      	ldr	r3, [r7, #4]
341a1020:	2204      	movs	r2, #4
341a1022:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
341a1026:	e010      	b.n	341a104a <VD6G_SetBayerType+0xb6>
  case VD6G_MIRROR:
    ctx->bayer = VD6G_BAYER_RGGB;
341a1028:	687b      	ldr	r3, [r7, #4]
341a102a:	2201      	movs	r2, #1
341a102c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
341a1030:	e00b      	b.n	341a104a <VD6G_SetBayerType+0xb6>
  case VD6G_MIRROR_FLIP:
    ctx->bayer = VD6G_BAYER_GBRG;
341a1032:	687b      	ldr	r3, [r7, #4]
341a1034:	2203      	movs	r2, #3
341a1036:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    break;
341a103a:	e006      	b.n	341a104a <VD6G_SetBayerType+0xb6>
  default:
    assert(0);
341a103c:	4b07      	ldr	r3, [pc, #28]	@ (341a105c <VD6G_SetBayerType+0xc8>)
341a103e:	4a05      	ldr	r2, [pc, #20]	@ (341a1054 <VD6G_SetBayerType+0xc0>)
341a1040:	f240 2156 	movw	r1, #598	@ 0x256
341a1044:	4806      	ldr	r0, [pc, #24]	@ (341a1060 <VD6G_SetBayerType+0xcc>)
341a1046:	f003 ffc9 	bl	341a4fdc <__assert_func>
  }

  return 0;
341a104a:	2300      	movs	r3, #0
}
341a104c:	4618      	mov	r0, r3
341a104e:	3718      	adds	r7, #24
341a1050:	46bd      	mov	sp, r7
341a1052:	bd80      	pop	{r7, pc}
341a1054:	341ae4dc 	.word	0x341ae4dc
341a1058:	341a7b68 	.word	0x341a7b68
341a105c:	341a7c7c 	.word	0x341a7c7c
341a1060:	341a7b18 	.word	0x341a7b18

341a1064 <VD6G_SetExposureModeInternal>:

static int VD6G_SetExposureModeInternal(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
341a1064:	b580      	push	{r7, lr}
341a1066:	b086      	sub	sp, #24
341a1068:	af02      	add	r7, sp, #8
341a106a:	6078      	str	r0, [r7, #4]
341a106c:	460b      	mov	r3, r1
341a106e:	70fb      	strb	r3, [r7, #3]
  int ret;

  if ((mode != VD6G_EXPOSURE_AUTO) &&
341a1070:	78fb      	ldrb	r3, [r7, #3]
341a1072:	2b00      	cmp	r3, #0
341a1074:	d008      	beq.n	341a1088 <VD6G_SetExposureModeInternal+0x24>
341a1076:	78fb      	ldrb	r3, [r7, #3]
341a1078:	2b01      	cmp	r3, #1
341a107a:	d005      	beq.n	341a1088 <VD6G_SetExposureModeInternal+0x24>
      (mode != VD6G_EXPOSURE_FREEZE_AEALGO) &&
341a107c:	78fb      	ldrb	r3, [r7, #3]
341a107e:	2b02      	cmp	r3, #2
341a1080:	d002      	beq.n	341a1088 <VD6G_SetExposureModeInternal+0x24>
      (mode != VD6G_EXPOSURE_MANUAL)) {
    return -1;
341a1082:	f04f 33ff 	mov.w	r3, #4294967295
341a1086:	e01f      	b.n	341a10c8 <VD6G_SetExposureModeInternal+0x64>
  }

  ret = ctx->write8(ctx, VD6G_REG_EXP_MODE, mode);
341a1088:	687b      	ldr	r3, [r7, #4]
341a108a:	691b      	ldr	r3, [r3, #16]
341a108c:	78fa      	ldrb	r2, [r7, #3]
341a108e:	f240 414c 	movw	r1, #1100	@ 0x44c
341a1092:	6878      	ldr	r0, [r7, #4]
341a1094:	4798      	blx	r3
341a1096:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1098:	68fb      	ldr	r3, [r7, #12]
341a109a:	2b00      	cmp	r3, #0
341a109c:	d008      	beq.n	341a10b0 <VD6G_SetExposureModeInternal+0x4c>
341a109e:	68fb      	ldr	r3, [r7, #12]
341a10a0:	9300      	str	r3, [sp, #0]
341a10a2:	f240 2367 	movw	r3, #615	@ 0x267
341a10a6:	4a0a      	ldr	r2, [pc, #40]	@ (341a10d0 <VD6G_SetExposureModeInternal+0x6c>)
341a10a8:	490a      	ldr	r1, [pc, #40]	@ (341a10d4 <VD6G_SetExposureModeInternal+0x70>)
341a10aa:	6878      	ldr	r0, [r7, #4]
341a10ac:	f7ff fa7b 	bl	341a05a6 <VD6G_error>
341a10b0:	68fb      	ldr	r3, [r7, #12]
341a10b2:	2b00      	cmp	r3, #0
341a10b4:	d002      	beq.n	341a10bc <VD6G_SetExposureModeInternal+0x58>
341a10b6:	6878      	ldr	r0, [r7, #4]
341a10b8:	f7ff fa90 	bl	341a05dc <display_error>
341a10bc:	68fb      	ldr	r3, [r7, #12]
341a10be:	2b00      	cmp	r3, #0
341a10c0:	d001      	beq.n	341a10c6 <VD6G_SetExposureModeInternal+0x62>
341a10c2:	68fb      	ldr	r3, [r7, #12]
341a10c4:	e000      	b.n	341a10c8 <VD6G_SetExposureModeInternal+0x64>

  return 0;
341a10c6:	2300      	movs	r3, #0
}
341a10c8:	4618      	mov	r0, r3
341a10ca:	3710      	adds	r7, #16
341a10cc:	46bd      	mov	sp, r7
341a10ce:	bd80      	pop	{r7, pc}
341a10d0:	341ae4f0 	.word	0x341ae4f0
341a10d4:	341a7b68 	.word	0x341a7b68

341a10d8 <VD6G_Gpios>:

static int VD6G_Gpios(VD6G_Ctx_t *ctx)
{
341a10d8:	b580      	push	{r7, lr}
341a10da:	b088      	sub	sp, #32
341a10dc:	af02      	add	r7, sp, #8
341a10de:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a10e0:	687b      	ldr	r3, [r7, #4]
341a10e2:	332c      	adds	r3, #44	@ 0x2c
341a10e4:	613b      	str	r3, [r7, #16]
  int ret;
  int i;

  for (i = 0; i < VD6G_GPIO_NB; i++) {
341a10e6:	2300      	movs	r3, #0
341a10e8:	617b      	str	r3, [r7, #20]
341a10ea:	e029      	b.n	341a1140 <VD6G_Gpios+0x68>
    ret = ctx->write8(ctx, VD6G_REG_GPIO_x_CTRL(i), drv_ctx->config_save.gpio_ctrl[i]);
341a10ec:	687b      	ldr	r3, [r7, #4]
341a10ee:	691b      	ldr	r3, [r3, #16]
341a10f0:	697a      	ldr	r2, [r7, #20]
341a10f2:	b292      	uxth	r2, r2
341a10f4:	f202 4267 	addw	r2, r2, #1127	@ 0x467
341a10f8:	b290      	uxth	r0, r2
341a10fa:	6939      	ldr	r1, [r7, #16]
341a10fc:	697a      	ldr	r2, [r7, #20]
341a10fe:	440a      	add	r2, r1
341a1100:	3230      	adds	r2, #48	@ 0x30
341a1102:	7812      	ldrb	r2, [r2, #0]
341a1104:	4601      	mov	r1, r0
341a1106:	6878      	ldr	r0, [r7, #4]
341a1108:	4798      	blx	r3
341a110a:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
341a110c:	68fb      	ldr	r3, [r7, #12]
341a110e:	2b00      	cmp	r3, #0
341a1110:	d008      	beq.n	341a1124 <VD6G_Gpios+0x4c>
341a1112:	68fb      	ldr	r3, [r7, #12]
341a1114:	9300      	str	r3, [sp, #0]
341a1116:	f44f 731d 	mov.w	r3, #628	@ 0x274
341a111a:	4a0d      	ldr	r2, [pc, #52]	@ (341a1150 <VD6G_Gpios+0x78>)
341a111c:	490d      	ldr	r1, [pc, #52]	@ (341a1154 <VD6G_Gpios+0x7c>)
341a111e:	6878      	ldr	r0, [r7, #4]
341a1120:	f7ff fa41 	bl	341a05a6 <VD6G_error>
341a1124:	68fb      	ldr	r3, [r7, #12]
341a1126:	2b00      	cmp	r3, #0
341a1128:	d002      	beq.n	341a1130 <VD6G_Gpios+0x58>
341a112a:	6878      	ldr	r0, [r7, #4]
341a112c:	f7ff fa56 	bl	341a05dc <display_error>
341a1130:	68fb      	ldr	r3, [r7, #12]
341a1132:	2b00      	cmp	r3, #0
341a1134:	d001      	beq.n	341a113a <VD6G_Gpios+0x62>
341a1136:	68fb      	ldr	r3, [r7, #12]
341a1138:	e006      	b.n	341a1148 <VD6G_Gpios+0x70>
  for (i = 0; i < VD6G_GPIO_NB; i++) {
341a113a:	697b      	ldr	r3, [r7, #20]
341a113c:	3301      	adds	r3, #1
341a113e:	617b      	str	r3, [r7, #20]
341a1140:	697b      	ldr	r3, [r7, #20]
341a1142:	2b07      	cmp	r3, #7
341a1144:	ddd2      	ble.n	341a10ec <VD6G_Gpios+0x14>
  }

  return 0;
341a1146:	2300      	movs	r3, #0
}
341a1148:	4618      	mov	r0, r3
341a114a:	3718      	adds	r7, #24
341a114c:	46bd      	mov	sp, r7
341a114e:	bd80      	pop	{r7, pc}
341a1150:	341ae510 	.word	0x341ae510
341a1154:	341a7b68 	.word	0x341a7b68

341a1158 <VD6G_Boot>:

static int VD6G_Boot(VD6G_Ctx_t *ctx)
{
341a1158:	b580      	push	{r7, lr}
341a115a:	b084      	sub	sp, #16
341a115c:	af00      	add	r7, sp, #0
341a115e:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_READY_TO_BOOT);
341a1160:	2101      	movs	r1, #1
341a1162:	6878      	ldr	r0, [r7, #4]
341a1164:	f7ff fb1c 	bl	341a07a0 <VD6G_WaitState>
341a1168:	60f8      	str	r0, [r7, #12]
  if (ret)
341a116a:	68fb      	ldr	r3, [r7, #12]
341a116c:	2b00      	cmp	r3, #0
341a116e:	d001      	beq.n	341a1174 <VD6G_Boot+0x1c>
    return ret;
341a1170:	68fb      	ldr	r3, [r7, #12]
341a1172:	e036      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_CheckModelId(ctx);
341a1174:	6878      	ldr	r0, [r7, #4]
341a1176:	f7ff fb75 	bl	341a0864 <VD6G_CheckModelId>
341a117a:	60f8      	str	r0, [r7, #12]
  if (ret)
341a117c:	68fb      	ldr	r3, [r7, #12]
341a117e:	2b00      	cmp	r3, #0
341a1180:	d001      	beq.n	341a1186 <VD6G_Boot+0x2e>
    return ret;
341a1182:	68fb      	ldr	r3, [r7, #12]
341a1184:	e02d      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_ApplyPatch(ctx);
341a1186:	6878      	ldr	r0, [r7, #4]
341a1188:	f7ff fca2 	bl	341a0ad0 <VD6G_ApplyPatch>
341a118c:	60f8      	str	r0, [r7, #12]
  if (ret)
341a118e:	68fb      	ldr	r3, [r7, #12]
341a1190:	2b00      	cmp	r3, #0
341a1192:	d001      	beq.n	341a1198 <VD6G_Boot+0x40>
    return ret;
341a1194:	68fb      	ldr	r3, [r7, #12]
341a1196:	e024      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_BootMcu(ctx);
341a1198:	6878      	ldr	r0, [r7, #4]
341a119a:	f7ff fcc9 	bl	341a0b30 <VD6G_BootMcu>
341a119e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a11a0:	68fb      	ldr	r3, [r7, #12]
341a11a2:	2b00      	cmp	r3, #0
341a11a4:	d001      	beq.n	341a11aa <VD6G_Boot+0x52>
    return ret;
341a11a6:	68fb      	ldr	r3, [r7, #12]
341a11a8:	e01b      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_ApplyVtPatch(ctx);
341a11aa:	6878      	ldr	r0, [r7, #4]
341a11ac:	f7ff fec2 	bl	341a0f34 <VD6G_ApplyVtPatch>
341a11b0:	60f8      	str	r0, [r7, #12]
  if (ret)
341a11b2:	68fb      	ldr	r3, [r7, #12]
341a11b4:	2b00      	cmp	r3, #0
341a11b6:	d001      	beq.n	341a11bc <VD6G_Boot+0x64>
    return ret;
341a11b8:	68fb      	ldr	r3, [r7, #12]
341a11ba:	e012      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_SetBayerType(ctx);
341a11bc:	6878      	ldr	r0, [r7, #4]
341a11be:	f7ff fee9 	bl	341a0f94 <VD6G_SetBayerType>
341a11c2:	60f8      	str	r0, [r7, #12]
  if (ret)
341a11c4:	68fb      	ldr	r3, [r7, #12]
341a11c6:	2b00      	cmp	r3, #0
341a11c8:	d001      	beq.n	341a11ce <VD6G_Boot+0x76>
    return ret;
341a11ca:	68fb      	ldr	r3, [r7, #12]
341a11cc:	e009      	b.n	341a11e2 <VD6G_Boot+0x8a>

  ret = VD6G_Gpios(ctx);
341a11ce:	6878      	ldr	r0, [r7, #4]
341a11d0:	f7ff ff82 	bl	341a10d8 <VD6G_Gpios>
341a11d4:	60f8      	str	r0, [r7, #12]
  if (ret)
341a11d6:	68fb      	ldr	r3, [r7, #12]
341a11d8:	2b00      	cmp	r3, #0
341a11da:	d001      	beq.n	341a11e0 <VD6G_Boot+0x88>
    return ret;
341a11dc:	68fb      	ldr	r3, [r7, #12]
341a11de:	e000      	b.n	341a11e2 <VD6G_Boot+0x8a>
  return 0;
341a11e0:	2300      	movs	r3, #0
}
341a11e2:	4618      	mov	r0, r3
341a11e4:	3710      	adds	r7, #16
341a11e6:	46bd      	mov	sp, r7
341a11e8:	bd80      	pop	{r7, pc}
	...

341a11ec <VD6G_ComputeClocks>:

static int VD6G_ComputeClocks(VD6G_Ctx_t *ctx, uint32_t ext_clock, uint8_t *pll_prediv, uint8_t *pll_mult)
{
341a11ec:	b580      	push	{r7, lr}
341a11ee:	b088      	sub	sp, #32
341a11f0:	af00      	add	r7, sp, #0
341a11f2:	60f8      	str	r0, [r7, #12]
341a11f4:	60b9      	str	r1, [r7, #8]
341a11f6:	607a      	str	r2, [r7, #4]
341a11f8:	603b      	str	r3, [r7, #0]
  const unsigned int predivs[] = { 1, 2, 4 };
341a11fa:	4a2d      	ldr	r2, [pc, #180]	@ (341a12b0 <VD6G_ComputeClocks+0xc4>)
341a11fc:	f107 0310 	add.w	r3, r7, #16
341a1200:	ca07      	ldmia	r2, {r0, r1, r2}
341a1202:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  int i;

  if (ext_clock < 6 * M_HZ ||
341a1206:	68bb      	ldr	r3, [r7, #8]
341a1208:	4a2a      	ldr	r2, [pc, #168]	@ (341a12b4 <VD6G_ComputeClocks+0xc8>)
341a120a:	4293      	cmp	r3, r2
341a120c:	d903      	bls.n	341a1216 <VD6G_ComputeClocks+0x2a>
341a120e:	68bb      	ldr	r3, [r7, #8]
341a1210:	4a29      	ldr	r2, [pc, #164]	@ (341a12b8 <VD6G_ComputeClocks+0xcc>)
341a1212:	4293      	cmp	r3, r2
341a1214:	d906      	bls.n	341a1224 <VD6G_ComputeClocks+0x38>
      ext_clock > 27 * M_HZ) {
    VD6G_error(ctx, "External clock out of rangen\n");
341a1216:	4929      	ldr	r1, [pc, #164]	@ (341a12bc <VD6G_ComputeClocks+0xd0>)
341a1218:	68f8      	ldr	r0, [r7, #12]
341a121a:	f7ff f9c4 	bl	341a05a6 <VD6G_error>
    return -1;
341a121e:	f04f 33ff 	mov.w	r3, #4294967295
341a1222:	e040      	b.n	341a12a6 <VD6G_ComputeClocks+0xba>
  }

  /* PLL input should be in [6Mhz-12Mhz[ */
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
341a1224:	2300      	movs	r3, #0
341a1226:	61fb      	str	r3, [r7, #28]
341a1228:	e014      	b.n	341a1254 <VD6G_ComputeClocks+0x68>
    *pll_prediv = predivs[i];
341a122a:	69fb      	ldr	r3, [r7, #28]
341a122c:	009b      	lsls	r3, r3, #2
341a122e:	3320      	adds	r3, #32
341a1230:	443b      	add	r3, r7
341a1232:	f853 3c10 	ldr.w	r3, [r3, #-16]
341a1236:	b2da      	uxtb	r2, r3
341a1238:	687b      	ldr	r3, [r7, #4]
341a123a:	701a      	strb	r2, [r3, #0]
    if (ext_clock / *pll_prediv < 12 * M_HZ)
341a123c:	687b      	ldr	r3, [r7, #4]
341a123e:	781b      	ldrb	r3, [r3, #0]
341a1240:	461a      	mov	r2, r3
341a1242:	68bb      	ldr	r3, [r7, #8]
341a1244:	fbb3 f3f2 	udiv	r3, r3, r2
341a1248:	4a1d      	ldr	r2, [pc, #116]	@ (341a12c0 <VD6G_ComputeClocks+0xd4>)
341a124a:	4293      	cmp	r3, r2
341a124c:	d306      	bcc.n	341a125c <VD6G_ComputeClocks+0x70>
  for (i = 0; i < ARRAY_SIZE(predivs); i++) {
341a124e:	69fb      	ldr	r3, [r7, #28]
341a1250:	3301      	adds	r3, #1
341a1252:	61fb      	str	r3, [r7, #28]
341a1254:	69fb      	ldr	r3, [r7, #28]
341a1256:	2b02      	cmp	r3, #2
341a1258:	d9e7      	bls.n	341a122a <VD6G_ComputeClocks+0x3e>
341a125a:	e000      	b.n	341a125e <VD6G_ComputeClocks+0x72>
      break;
341a125c:	bf00      	nop
  }

  /* PLL output clock must be as close as possible to 804Mhz */
  *pll_mult = (VD6G_TARGET_PLL * *pll_prediv + ext_clock / 2) / ext_clock;
341a125e:	687b      	ldr	r3, [r7, #4]
341a1260:	781b      	ldrb	r3, [r3, #0]
341a1262:	461a      	mov	r2, r3
341a1264:	4b17      	ldr	r3, [pc, #92]	@ (341a12c4 <VD6G_ComputeClocks+0xd8>)
341a1266:	fb03 f202 	mul.w	r2, r3, r2
341a126a:	68bb      	ldr	r3, [r7, #8]
341a126c:	085b      	lsrs	r3, r3, #1
341a126e:	441a      	add	r2, r3
341a1270:	68bb      	ldr	r3, [r7, #8]
341a1272:	fbb2 f3f3 	udiv	r3, r2, r3
341a1276:	b2da      	uxtb	r2, r3
341a1278:	683b      	ldr	r3, [r7, #0]
341a127a:	701a      	strb	r2, [r3, #0]

  VD6G_dbg(ctx, 0, "Ext Clock = %d Hz\n", ext_clock);
341a127c:	68bb      	ldr	r3, [r7, #8]
341a127e:	4a12      	ldr	r2, [pc, #72]	@ (341a12c8 <VD6G_ComputeClocks+0xdc>)
341a1280:	2100      	movs	r1, #0
341a1282:	68f8      	ldr	r0, [r7, #12]
341a1284:	f7ff f93c 	bl	341a0500 <VD6G_dbg>
  VD6G_dbg(ctx, 0, "PLL prediv = %d\n", *pll_prediv);
341a1288:	687b      	ldr	r3, [r7, #4]
341a128a:	781b      	ldrb	r3, [r3, #0]
341a128c:	4a0f      	ldr	r2, [pc, #60]	@ (341a12cc <VD6G_ComputeClocks+0xe0>)
341a128e:	2100      	movs	r1, #0
341a1290:	68f8      	ldr	r0, [r7, #12]
341a1292:	f7ff f935 	bl	341a0500 <VD6G_dbg>
  VD6G_dbg(ctx, 0, "PLL mult = %d\n", *pll_mult);
341a1296:	683b      	ldr	r3, [r7, #0]
341a1298:	781b      	ldrb	r3, [r3, #0]
341a129a:	4a0d      	ldr	r2, [pc, #52]	@ (341a12d0 <VD6G_ComputeClocks+0xe4>)
341a129c:	2100      	movs	r1, #0
341a129e:	68f8      	ldr	r0, [r7, #12]
341a12a0:	f7ff f92e 	bl	341a0500 <VD6G_dbg>

  return 0;
341a12a4:	2300      	movs	r3, #0
}
341a12a6:	4618      	mov	r0, r3
341a12a8:	3720      	adds	r7, #32
341a12aa:	46bd      	mov	sp, r7
341a12ac:	bd80      	pop	{r7, pc}
341a12ae:	bf00      	nop
341a12b0:	341a7d48 	.word	0x341a7d48
341a12b4:	005b8d7f 	.word	0x005b8d7f
341a12b8:	019bfcc0 	.word	0x019bfcc0
341a12bc:	341a7cf0 	.word	0x341a7cf0
341a12c0:	00b71b00 	.word	0x00b71b00
341a12c4:	2fec1100 	.word	0x2fec1100
341a12c8:	341a7d10 	.word	0x341a7d10
341a12cc:	341a7d24 	.word	0x341a7d24
341a12d0:	341a7d38 	.word	0x341a7d38

341a12d4 <VD6G_SetupClocks>:

static int VD6G_SetupClocks(VD6G_Ctx_t *ctx)
{
341a12d4:	b580      	push	{r7, lr}
341a12d6:	b088      	sub	sp, #32
341a12d8:	af02      	add	r7, sp, #8
341a12da:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a12dc:	687b      	ldr	r3, [r7, #4]
341a12de:	332c      	adds	r3, #44	@ 0x2c
341a12e0:	617b      	str	r3, [r7, #20]
  uint8_t pll_prediv;
  uint8_t pll_mult;
  int ret;

  ret = VD6G_ComputeClocks(ctx, drv_ctx->config_save.ext_clock_freq_in_hz, &pll_prediv, &pll_mult);
341a12e2:	697b      	ldr	r3, [r7, #20]
341a12e4:	685b      	ldr	r3, [r3, #4]
341a12e6:	4619      	mov	r1, r3
341a12e8:	f107 030e 	add.w	r3, r7, #14
341a12ec:	f107 020f 	add.w	r2, r7, #15
341a12f0:	6878      	ldr	r0, [r7, #4]
341a12f2:	f7ff ff7b 	bl	341a11ec <VD6G_ComputeClocks>
341a12f6:	6138      	str	r0, [r7, #16]
  if (ret)
341a12f8:	693b      	ldr	r3, [r7, #16]
341a12fa:	2b00      	cmp	r3, #0
341a12fc:	d001      	beq.n	341a1302 <VD6G_SetupClocks+0x2e>
    return ret;
341a12fe:	693b      	ldr	r3, [r7, #16]
341a1300:	e083      	b.n	341a140a <VD6G_SetupClocks+0x136>

  ret = ctx->write32(ctx, VD6G_REG_EXT_CLOCK, drv_ctx->config_save.ext_clock_freq_in_hz);
341a1302:	687b      	ldr	r3, [r7, #4]
341a1304:	699b      	ldr	r3, [r3, #24]
341a1306:	697a      	ldr	r2, [r7, #20]
341a1308:	6852      	ldr	r2, [r2, #4]
341a130a:	f44f 7108 	mov.w	r1, #544	@ 0x220
341a130e:	6878      	ldr	r0, [r7, #4]
341a1310:	4798      	blx	r3
341a1312:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1314:	693b      	ldr	r3, [r7, #16]
341a1316:	2b00      	cmp	r3, #0
341a1318:	d008      	beq.n	341a132c <VD6G_SetupClocks+0x58>
341a131a:	693b      	ldr	r3, [r7, #16]
341a131c:	9300      	str	r3, [sp, #0]
341a131e:	f44f 7331 	mov.w	r3, #708	@ 0x2c4
341a1322:	4a3c      	ldr	r2, [pc, #240]	@ (341a1414 <VD6G_SetupClocks+0x140>)
341a1324:	493c      	ldr	r1, [pc, #240]	@ (341a1418 <VD6G_SetupClocks+0x144>)
341a1326:	6878      	ldr	r0, [r7, #4]
341a1328:	f7ff f93d 	bl	341a05a6 <VD6G_error>
341a132c:	693b      	ldr	r3, [r7, #16]
341a132e:	2b00      	cmp	r3, #0
341a1330:	d002      	beq.n	341a1338 <VD6G_SetupClocks+0x64>
341a1332:	6878      	ldr	r0, [r7, #4]
341a1334:	f7ff f952 	bl	341a05dc <display_error>
341a1338:	693b      	ldr	r3, [r7, #16]
341a133a:	2b00      	cmp	r3, #0
341a133c:	d001      	beq.n	341a1342 <VD6G_SetupClocks+0x6e>
341a133e:	693b      	ldr	r3, [r7, #16]
341a1340:	e063      	b.n	341a140a <VD6G_SetupClocks+0x136>

  ret = ctx->write8(ctx, VD6G_REG_CLK_PLL_PREDIV, pll_prediv);
341a1342:	687b      	ldr	r3, [r7, #4]
341a1344:	691b      	ldr	r3, [r3, #16]
341a1346:	7bfa      	ldrb	r2, [r7, #15]
341a1348:	f44f 7109 	mov.w	r1, #548	@ 0x224
341a134c:	6878      	ldr	r0, [r7, #4]
341a134e:	4798      	blx	r3
341a1350:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1352:	693b      	ldr	r3, [r7, #16]
341a1354:	2b00      	cmp	r3, #0
341a1356:	d008      	beq.n	341a136a <VD6G_SetupClocks+0x96>
341a1358:	693b      	ldr	r3, [r7, #16]
341a135a:	9300      	str	r3, [sp, #0]
341a135c:	f240 23c7 	movw	r3, #711	@ 0x2c7
341a1360:	4a2c      	ldr	r2, [pc, #176]	@ (341a1414 <VD6G_SetupClocks+0x140>)
341a1362:	492d      	ldr	r1, [pc, #180]	@ (341a1418 <VD6G_SetupClocks+0x144>)
341a1364:	6878      	ldr	r0, [r7, #4]
341a1366:	f7ff f91e 	bl	341a05a6 <VD6G_error>
341a136a:	693b      	ldr	r3, [r7, #16]
341a136c:	2b00      	cmp	r3, #0
341a136e:	d002      	beq.n	341a1376 <VD6G_SetupClocks+0xa2>
341a1370:	6878      	ldr	r0, [r7, #4]
341a1372:	f7ff f933 	bl	341a05dc <display_error>
341a1376:	693b      	ldr	r3, [r7, #16]
341a1378:	2b00      	cmp	r3, #0
341a137a:	d001      	beq.n	341a1380 <VD6G_SetupClocks+0xac>
341a137c:	693b      	ldr	r3, [r7, #16]
341a137e:	e044      	b.n	341a140a <VD6G_SetupClocks+0x136>

  ret = ctx->write8(ctx, VD6G_REG_CLK_SYS_PLL_MULT, pll_mult);
341a1380:	687b      	ldr	r3, [r7, #4]
341a1382:	691b      	ldr	r3, [r3, #16]
341a1384:	7bba      	ldrb	r2, [r7, #14]
341a1386:	f240 2126 	movw	r1, #550	@ 0x226
341a138a:	6878      	ldr	r0, [r7, #4]
341a138c:	4798      	blx	r3
341a138e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1390:	693b      	ldr	r3, [r7, #16]
341a1392:	2b00      	cmp	r3, #0
341a1394:	d008      	beq.n	341a13a8 <VD6G_SetupClocks+0xd4>
341a1396:	693b      	ldr	r3, [r7, #16]
341a1398:	9300      	str	r3, [sp, #0]
341a139a:	f240 23ca 	movw	r3, #714	@ 0x2ca
341a139e:	4a1d      	ldr	r2, [pc, #116]	@ (341a1414 <VD6G_SetupClocks+0x140>)
341a13a0:	491d      	ldr	r1, [pc, #116]	@ (341a1418 <VD6G_SetupClocks+0x144>)
341a13a2:	6878      	ldr	r0, [r7, #4]
341a13a4:	f7ff f8ff 	bl	341a05a6 <VD6G_error>
341a13a8:	693b      	ldr	r3, [r7, #16]
341a13aa:	2b00      	cmp	r3, #0
341a13ac:	d002      	beq.n	341a13b4 <VD6G_SetupClocks+0xe0>
341a13ae:	6878      	ldr	r0, [r7, #4]
341a13b0:	f7ff f914 	bl	341a05dc <display_error>
341a13b4:	693b      	ldr	r3, [r7, #16]
341a13b6:	2b00      	cmp	r3, #0
341a13b8:	d001      	beq.n	341a13be <VD6G_SetupClocks+0xea>
341a13ba:	693b      	ldr	r3, [r7, #16]
341a13bc:	e025      	b.n	341a140a <VD6G_SetupClocks+0x136>

  if (drv_ctx->config_save.line_len) {
341a13be:	697b      	ldr	r3, [r7, #20]
341a13c0:	695b      	ldr	r3, [r3, #20]
341a13c2:	2b00      	cmp	r3, #0
341a13c4:	d020      	beq.n	341a1408 <VD6G_SetupClocks+0x134>
    ret = ctx->write16(ctx, VD6G_LINE_LENGTH, drv_ctx->config_save.line_len);
341a13c6:	687b      	ldr	r3, [r7, #4]
341a13c8:	695b      	ldr	r3, [r3, #20]
341a13ca:	697a      	ldr	r2, [r7, #20]
341a13cc:	6952      	ldr	r2, [r2, #20]
341a13ce:	b292      	uxth	r2, r2
341a13d0:	f44f 7140 	mov.w	r1, #768	@ 0x300
341a13d4:	6878      	ldr	r0, [r7, #4]
341a13d6:	4798      	blx	r3
341a13d8:	6138      	str	r0, [r7, #16]
    VD6G_TraceError(ctx, ret);
341a13da:	693b      	ldr	r3, [r7, #16]
341a13dc:	2b00      	cmp	r3, #0
341a13de:	d008      	beq.n	341a13f2 <VD6G_SetupClocks+0x11e>
341a13e0:	693b      	ldr	r3, [r7, #16]
341a13e2:	9300      	str	r3, [sp, #0]
341a13e4:	f240 23ce 	movw	r3, #718	@ 0x2ce
341a13e8:	4a0a      	ldr	r2, [pc, #40]	@ (341a1414 <VD6G_SetupClocks+0x140>)
341a13ea:	490b      	ldr	r1, [pc, #44]	@ (341a1418 <VD6G_SetupClocks+0x144>)
341a13ec:	6878      	ldr	r0, [r7, #4]
341a13ee:	f7ff f8da 	bl	341a05a6 <VD6G_error>
341a13f2:	693b      	ldr	r3, [r7, #16]
341a13f4:	2b00      	cmp	r3, #0
341a13f6:	d002      	beq.n	341a13fe <VD6G_SetupClocks+0x12a>
341a13f8:	6878      	ldr	r0, [r7, #4]
341a13fa:	f7ff f8ef 	bl	341a05dc <display_error>
341a13fe:	693b      	ldr	r3, [r7, #16]
341a1400:	2b00      	cmp	r3, #0
341a1402:	d001      	beq.n	341a1408 <VD6G_SetupClocks+0x134>
341a1404:	693b      	ldr	r3, [r7, #16]
341a1406:	e000      	b.n	341a140a <VD6G_SetupClocks+0x136>
  }

  return 0;
341a1408:	2300      	movs	r3, #0
}
341a140a:	4618      	mov	r0, r3
341a140c:	3718      	adds	r7, #24
341a140e:	46bd      	mov	sp, r7
341a1410:	bd80      	pop	{r7, pc}
341a1412:	bf00      	nop
341a1414:	341ae51c 	.word	0x341ae51c
341a1418:	341a7b68 	.word	0x341a7b68

341a141c <VD6G_SetupOutput>:

static int VD6G_SetupOutput(VD6G_Ctx_t *ctx)
{
341a141c:	b580      	push	{r7, lr}
341a141e:	b088      	sub	sp, #32
341a1420:	af02      	add	r7, sp, #8
341a1422:	6078      	str	r0, [r7, #4]
  VD6G_OutItf_Config_t *out_itf = &ctx->ctx.config_save.out_itf;
341a1424:	687b      	ldr	r3, [r7, #4]
341a1426:	3348      	adds	r3, #72	@ 0x48
341a1428:	617b      	str	r3, [r7, #20]
  uint16_t oif_ctrl;
  int ret;

  if (out_itf->datalane_nb != 1 && out_itf->datalane_nb != 2)
341a142a:	697b      	ldr	r3, [r7, #20]
341a142c:	681b      	ldr	r3, [r3, #0]
341a142e:	2b01      	cmp	r3, #1
341a1430:	d006      	beq.n	341a1440 <VD6G_SetupOutput+0x24>
341a1432:	697b      	ldr	r3, [r7, #20]
341a1434:	681b      	ldr	r3, [r3, #0]
341a1436:	2b02      	cmp	r3, #2
341a1438:	d002      	beq.n	341a1440 <VD6G_SetupOutput+0x24>
    return -1;
341a143a:	f04f 33ff 	mov.w	r3, #4294967295
341a143e:	e0ce      	b.n	341a15de <VD6G_SetupOutput+0x1c2>
  /* Be sure we got value 0 or 1 */
  out_itf->clock_lane_swap_enable = !!out_itf->clock_lane_swap_enable;
341a1440:	697b      	ldr	r3, [r7, #20]
341a1442:	685b      	ldr	r3, [r3, #4]
341a1444:	2b00      	cmp	r3, #0
341a1446:	bf14      	ite	ne
341a1448:	2301      	movne	r3, #1
341a144a:	2300      	moveq	r3, #0
341a144c:	b2db      	uxtb	r3, r3
341a144e:	461a      	mov	r2, r3
341a1450:	697b      	ldr	r3, [r7, #20]
341a1452:	605a      	str	r2, [r3, #4]
  out_itf->data_lane0_swap_enable = !!out_itf->data_lane0_swap_enable;
341a1454:	697b      	ldr	r3, [r7, #20]
341a1456:	689b      	ldr	r3, [r3, #8]
341a1458:	2b00      	cmp	r3, #0
341a145a:	bf14      	ite	ne
341a145c:	2301      	movne	r3, #1
341a145e:	2300      	moveq	r3, #0
341a1460:	b2db      	uxtb	r3, r3
341a1462:	461a      	mov	r2, r3
341a1464:	697b      	ldr	r3, [r7, #20]
341a1466:	609a      	str	r2, [r3, #8]
  out_itf->data_lane1_swap_enable = !!out_itf->data_lane1_swap_enable;
341a1468:	697b      	ldr	r3, [r7, #20]
341a146a:	68db      	ldr	r3, [r3, #12]
341a146c:	2b00      	cmp	r3, #0
341a146e:	bf14      	ite	ne
341a1470:	2301      	movne	r3, #1
341a1472:	2300      	moveq	r3, #0
341a1474:	b2db      	uxtb	r3, r3
341a1476:	461a      	mov	r2, r3
341a1478:	697b      	ldr	r3, [r7, #20]
341a147a:	60da      	str	r2, [r3, #12]
  out_itf->data_lanes_mapping_swap_enable = !!out_itf->data_lanes_mapping_swap_enable;
341a147c:	697b      	ldr	r3, [r7, #20]
341a147e:	691b      	ldr	r3, [r3, #16]
341a1480:	2b00      	cmp	r3, #0
341a1482:	bf14      	ite	ne
341a1484:	2301      	movne	r3, #1
341a1486:	2300      	moveq	r3, #0
341a1488:	b2db      	uxtb	r3, r3
341a148a:	461a      	mov	r2, r3
341a148c:	697b      	ldr	r3, [r7, #20]
341a148e:	611a      	str	r2, [r3, #16]

  /* raw8 */
  ret = ctx->write8(ctx, VD6G_REG_FORMAT_CTRL, VD6G_COLOR_DEPTH_RAW8);
341a1490:	687b      	ldr	r3, [r7, #4]
341a1492:	691b      	ldr	r3, [r3, #16]
341a1494:	2208      	movs	r2, #8
341a1496:	f240 310a 	movw	r1, #778	@ 0x30a
341a149a:	6878      	ldr	r0, [r7, #4]
341a149c:	4798      	blx	r3
341a149e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a14a0:	693b      	ldr	r3, [r7, #16]
341a14a2:	2b00      	cmp	r3, #0
341a14a4:	d008      	beq.n	341a14b8 <VD6G_SetupOutput+0x9c>
341a14a6:	693b      	ldr	r3, [r7, #16]
341a14a8:	9300      	str	r3, [sp, #0]
341a14aa:	f44f 7339 	mov.w	r3, #740	@ 0x2e4
341a14ae:	4a4e      	ldr	r2, [pc, #312]	@ (341a15e8 <VD6G_SetupOutput+0x1cc>)
341a14b0:	494e      	ldr	r1, [pc, #312]	@ (341a15ec <VD6G_SetupOutput+0x1d0>)
341a14b2:	6878      	ldr	r0, [r7, #4]
341a14b4:	f7ff f877 	bl	341a05a6 <VD6G_error>
341a14b8:	693b      	ldr	r3, [r7, #16]
341a14ba:	2b00      	cmp	r3, #0
341a14bc:	d002      	beq.n	341a14c4 <VD6G_SetupOutput+0xa8>
341a14be:	6878      	ldr	r0, [r7, #4]
341a14c0:	f7ff f88c 	bl	341a05dc <display_error>
341a14c4:	693b      	ldr	r3, [r7, #16]
341a14c6:	2b00      	cmp	r3, #0
341a14c8:	d001      	beq.n	341a14ce <VD6G_SetupOutput+0xb2>
341a14ca:	693b      	ldr	r3, [r7, #16]
341a14cc:	e087      	b.n	341a15de <VD6G_SetupOutput+0x1c2>

  /* csi lanes */
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a14ce:	697b      	ldr	r3, [r7, #20]
341a14d0:	68db      	ldr	r3, [r3, #12]
341a14d2:	b21b      	sxth	r3, r3
341a14d4:	025b      	lsls	r3, r3, #9
341a14d6:	b21b      	sxth	r3, r3
             !out_itf->data_lanes_mapping_swap_enable << 7 |
341a14d8:	697a      	ldr	r2, [r7, #20]
341a14da:	6912      	ldr	r2, [r2, #16]
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a14dc:	2a00      	cmp	r2, #0
341a14de:	d101      	bne.n	341a14e4 <VD6G_SetupOutput+0xc8>
341a14e0:	2280      	movs	r2, #128	@ 0x80
341a14e2:	e000      	b.n	341a14e6 <VD6G_SetupOutput+0xca>
341a14e4:	2200      	movs	r2, #0
341a14e6:	4313      	orrs	r3, r2
341a14e8:	b21a      	sxth	r2, r3
             out_itf->data_lane0_swap_enable << 6 |
341a14ea:	697b      	ldr	r3, [r7, #20]
341a14ec:	689b      	ldr	r3, [r3, #8]
             !out_itf->data_lanes_mapping_swap_enable << 7 |
341a14ee:	b21b      	sxth	r3, r3
341a14f0:	019b      	lsls	r3, r3, #6
341a14f2:	b21b      	sxth	r3, r3
341a14f4:	4313      	orrs	r3, r2
341a14f6:	b21a      	sxth	r2, r3
             out_itf->data_lanes_mapping_swap_enable << 4 |
341a14f8:	697b      	ldr	r3, [r7, #20]
341a14fa:	691b      	ldr	r3, [r3, #16]
             out_itf->data_lane0_swap_enable << 6 |
341a14fc:	b21b      	sxth	r3, r3
341a14fe:	011b      	lsls	r3, r3, #4
341a1500:	b21b      	sxth	r3, r3
341a1502:	4313      	orrs	r3, r2
341a1504:	b21a      	sxth	r2, r3
             out_itf->clock_lane_swap_enable << 3 |
341a1506:	697b      	ldr	r3, [r7, #20]
341a1508:	685b      	ldr	r3, [r3, #4]
             out_itf->data_lanes_mapping_swap_enable << 4 |
341a150a:	b21b      	sxth	r3, r3
341a150c:	00db      	lsls	r3, r3, #3
341a150e:	b21b      	sxth	r3, r3
341a1510:	4313      	orrs	r3, r2
341a1512:	b21a      	sxth	r2, r3
             out_itf->datalane_nb << 0;
341a1514:	697b      	ldr	r3, [r7, #20]
341a1516:	681b      	ldr	r3, [r3, #0]
             out_itf->clock_lane_swap_enable << 3 |
341a1518:	b21b      	sxth	r3, r3
341a151a:	4313      	orrs	r3, r2
341a151c:	b21b      	sxth	r3, r3
  oif_ctrl = out_itf->data_lane1_swap_enable << 9 |
341a151e:	81fb      	strh	r3, [r7, #14]
  ret = ctx->write16(ctx, VD6G_REG_OIF_CTRL, oif_ctrl);
341a1520:	687b      	ldr	r3, [r7, #4]
341a1522:	695b      	ldr	r3, [r3, #20]
341a1524:	89fa      	ldrh	r2, [r7, #14]
341a1526:	f44f 7143 	mov.w	r1, #780	@ 0x30c
341a152a:	6878      	ldr	r0, [r7, #4]
341a152c:	4798      	blx	r3
341a152e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1530:	693b      	ldr	r3, [r7, #16]
341a1532:	2b00      	cmp	r3, #0
341a1534:	d008      	beq.n	341a1548 <VD6G_SetupOutput+0x12c>
341a1536:	693b      	ldr	r3, [r7, #16]
341a1538:	9300      	str	r3, [sp, #0]
341a153a:	f240 23ee 	movw	r3, #750	@ 0x2ee
341a153e:	4a2a      	ldr	r2, [pc, #168]	@ (341a15e8 <VD6G_SetupOutput+0x1cc>)
341a1540:	492a      	ldr	r1, [pc, #168]	@ (341a15ec <VD6G_SetupOutput+0x1d0>)
341a1542:	6878      	ldr	r0, [r7, #4]
341a1544:	f7ff f82f 	bl	341a05a6 <VD6G_error>
341a1548:	693b      	ldr	r3, [r7, #16]
341a154a:	2b00      	cmp	r3, #0
341a154c:	d002      	beq.n	341a1554 <VD6G_SetupOutput+0x138>
341a154e:	6878      	ldr	r0, [r7, #4]
341a1550:	f7ff f844 	bl	341a05dc <display_error>
341a1554:	693b      	ldr	r3, [r7, #16]
341a1556:	2b00      	cmp	r3, #0
341a1558:	d001      	beq.n	341a155e <VD6G_SetupOutput+0x142>
341a155a:	693b      	ldr	r3, [r7, #16]
341a155c:	e03f      	b.n	341a15de <VD6G_SetupOutput+0x1c2>

  /* csi speed */
  ret = ctx->write16(ctx, VD6G_REG_OIF_CSI_BITRATE, 804);
341a155e:	687b      	ldr	r3, [r7, #4]
341a1560:	695b      	ldr	r3, [r3, #20]
341a1562:	f44f 7249 	mov.w	r2, #804	@ 0x324
341a1566:	f240 3112 	movw	r1, #786	@ 0x312
341a156a:	6878      	ldr	r0, [r7, #4]
341a156c:	4798      	blx	r3
341a156e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1570:	693b      	ldr	r3, [r7, #16]
341a1572:	2b00      	cmp	r3, #0
341a1574:	d008      	beq.n	341a1588 <VD6G_SetupOutput+0x16c>
341a1576:	693b      	ldr	r3, [r7, #16]
341a1578:	9300      	str	r3, [sp, #0]
341a157a:	f240 23f2 	movw	r3, #754	@ 0x2f2
341a157e:	4a1a      	ldr	r2, [pc, #104]	@ (341a15e8 <VD6G_SetupOutput+0x1cc>)
341a1580:	491a      	ldr	r1, [pc, #104]	@ (341a15ec <VD6G_SetupOutput+0x1d0>)
341a1582:	6878      	ldr	r0, [r7, #4]
341a1584:	f7ff f80f 	bl	341a05a6 <VD6G_error>
341a1588:	693b      	ldr	r3, [r7, #16]
341a158a:	2b00      	cmp	r3, #0
341a158c:	d002      	beq.n	341a1594 <VD6G_SetupOutput+0x178>
341a158e:	6878      	ldr	r0, [r7, #4]
341a1590:	f7ff f824 	bl	341a05dc <display_error>
341a1594:	693b      	ldr	r3, [r7, #16]
341a1596:	2b00      	cmp	r3, #0
341a1598:	d001      	beq.n	341a159e <VD6G_SetupOutput+0x182>
341a159a:	693b      	ldr	r3, [r7, #16]
341a159c:	e01f      	b.n	341a15de <VD6G_SetupOutput+0x1c2>

  /* data type */
  ret = ctx->write8(ctx, VD6G_REG_OIF_IMG_CTRL, 0x2a);
341a159e:	687b      	ldr	r3, [r7, #4]
341a15a0:	691b      	ldr	r3, [r3, #16]
341a15a2:	222a      	movs	r2, #42	@ 0x2a
341a15a4:	f240 310f 	movw	r1, #783	@ 0x30f
341a15a8:	6878      	ldr	r0, [r7, #4]
341a15aa:	4798      	blx	r3
341a15ac:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a15ae:	693b      	ldr	r3, [r7, #16]
341a15b0:	2b00      	cmp	r3, #0
341a15b2:	d008      	beq.n	341a15c6 <VD6G_SetupOutput+0x1aa>
341a15b4:	693b      	ldr	r3, [r7, #16]
341a15b6:	9300      	str	r3, [sp, #0]
341a15b8:	f240 23f6 	movw	r3, #758	@ 0x2f6
341a15bc:	4a0a      	ldr	r2, [pc, #40]	@ (341a15e8 <VD6G_SetupOutput+0x1cc>)
341a15be:	490b      	ldr	r1, [pc, #44]	@ (341a15ec <VD6G_SetupOutput+0x1d0>)
341a15c0:	6878      	ldr	r0, [r7, #4]
341a15c2:	f7fe fff0 	bl	341a05a6 <VD6G_error>
341a15c6:	693b      	ldr	r3, [r7, #16]
341a15c8:	2b00      	cmp	r3, #0
341a15ca:	d002      	beq.n	341a15d2 <VD6G_SetupOutput+0x1b6>
341a15cc:	6878      	ldr	r0, [r7, #4]
341a15ce:	f7ff f805 	bl	341a05dc <display_error>
341a15d2:	693b      	ldr	r3, [r7, #16]
341a15d4:	2b00      	cmp	r3, #0
341a15d6:	d001      	beq.n	341a15dc <VD6G_SetupOutput+0x1c0>
341a15d8:	693b      	ldr	r3, [r7, #16]
341a15da:	e000      	b.n	341a15de <VD6G_SetupOutput+0x1c2>

  return 0;
341a15dc:	2300      	movs	r3, #0
}
341a15de:	4618      	mov	r0, r3
341a15e0:	3718      	adds	r7, #24
341a15e2:	46bd      	mov	sp, r7
341a15e4:	bd80      	pop	{r7, pc}
341a15e6:	bf00      	nop
341a15e8:	341ae530 	.word	0x341ae530
341a15ec:	341a7b68 	.word	0x341a7b68

341a15f0 <VD6G_Resolution2Mode>:

static const struct vdg_mode *VD6G_Resolution2Mode(VD6G_Res_t resolution)
{
341a15f0:	b480      	push	{r7}
341a15f2:	b083      	sub	sp, #12
341a15f4:	af00      	add	r7, sp, #0
341a15f6:	4603      	mov	r3, r0
341a15f8:	71fb      	strb	r3, [r7, #7]
  switch (resolution) {
341a15fa:	79fb      	ldrb	r3, [r7, #7]
341a15fc:	2b08      	cmp	r3, #8
341a15fe:	d827      	bhi.n	341a1650 <VD6G_Resolution2Mode+0x60>
341a1600:	a201      	add	r2, pc, #4	@ (adr r2, 341a1608 <VD6G_Resolution2Mode+0x18>)
341a1602:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a1606:	bf00      	nop
341a1608:	341a162d 	.word	0x341a162d
341a160c:	341a1631 	.word	0x341a1631
341a1610:	341a1635 	.word	0x341a1635
341a1614:	341a1639 	.word	0x341a1639
341a1618:	341a163d 	.word	0x341a163d
341a161c:	341a1641 	.word	0x341a1641
341a1620:	341a1645 	.word	0x341a1645
341a1624:	341a1649 	.word	0x341a1649
341a1628:	341a164d 	.word	0x341a164d
  case VD6G_RES_QVGA_320_240:
    return &vdg_supported_modes[7];
341a162c:	4b0c      	ldr	r3, [pc, #48]	@ (341a1660 <VD6G_Resolution2Mode+0x70>)
341a162e:	e010      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_VGA_640_480:
    return &vdg_supported_modes[5];
341a1630:	4b0c      	ldr	r3, [pc, #48]	@ (341a1664 <VD6G_Resolution2Mode+0x74>)
341a1632:	e00e      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_VGA_PORTRAIT_480_640:
    return &vdg_supported_modes[6];
341a1634:	4b0c      	ldr	r3, [pc, #48]	@ (341a1668 <VD6G_Resolution2Mode+0x78>)
341a1636:	e00c      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_XGA_1024_768:
    return &vdg_supported_modes[2];
341a1638:	4b0c      	ldr	r3, [pc, #48]	@ (341a166c <VD6G_Resolution2Mode+0x7c>)
341a163a:	e00a      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_XGA_PORTRAIT_768_1024:
    return &vdg_supported_modes[3];
341a163c:	4b0c      	ldr	r3, [pc, #48]	@ (341a1670 <VD6G_Resolution2Mode+0x80>)
341a163e:	e008      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_720P_PORTRAIT_720_1280:
    return &vdg_supported_modes[4];
341a1640:	4b0c      	ldr	r3, [pc, #48]	@ (341a1674 <VD6G_Resolution2Mode+0x84>)
341a1642:	e006      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_SXGA_PORTRAIT_1024_1280:
    return &vdg_supported_modes[1];
341a1644:	4b0c      	ldr	r3, [pc, #48]	@ (341a1678 <VD6G_Resolution2Mode+0x88>)
341a1646:	e004      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_PORTRAIT_1120_720:
    return &vdg_supported_modes[8];
341a1648:	4b0c      	ldr	r3, [pc, #48]	@ (341a167c <VD6G_Resolution2Mode+0x8c>)
341a164a:	e002      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  case VD6G_RES_FULL_1120_1364:
    return &vdg_supported_modes[0];
341a164c:	4b0c      	ldr	r3, [pc, #48]	@ (341a1680 <VD6G_Resolution2Mode+0x90>)
341a164e:	e000      	b.n	341a1652 <VD6G_Resolution2Mode+0x62>
    break;
  default:
    return NULL;
341a1650:	2300      	movs	r3, #0
  }
}
341a1652:	4618      	mov	r0, r3
341a1654:	370c      	adds	r7, #12
341a1656:	46bd      	mov	sp, r7
341a1658:	f85d 7b04 	ldr.w	r7, [sp], #4
341a165c:	4770      	bx	lr
341a165e:	bf00      	nop
341a1660:	341ae3e0 	.word	0x341ae3e0
341a1664:	341ae3a8 	.word	0x341ae3a8
341a1668:	341ae3c4 	.word	0x341ae3c4
341a166c:	341ae354 	.word	0x341ae354
341a1670:	341ae370 	.word	0x341ae370
341a1674:	341ae38c 	.word	0x341ae38c
341a1678:	341ae338 	.word	0x341ae338
341a167c:	341ae3fc 	.word	0x341ae3fc
341a1680:	341ae31c 	.word	0x341ae31c

341a1684 <VD6G_SetupSize>:

static int VD6G_SetupSize(VD6G_Ctx_t *ctx)
{
341a1684:	b580      	push	{r7, lr}
341a1686:	b088      	sub	sp, #32
341a1688:	af02      	add	r7, sp, #8
341a168a:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a168c:	687b      	ldr	r3, [r7, #4]
341a168e:	332c      	adds	r3, #44	@ 0x2c
341a1690:	617b      	str	r3, [r7, #20]
  const struct vdg_mode *mode;
  int ret;

  mode = VD6G_Resolution2Mode(drv_ctx->config_save.resolution);
341a1692:	697b      	ldr	r3, [r7, #20]
341a1694:	7a1b      	ldrb	r3, [r3, #8]
341a1696:	4618      	mov	r0, r3
341a1698:	f7ff ffaa 	bl	341a15f0 <VD6G_Resolution2Mode>
341a169c:	6138      	str	r0, [r7, #16]
  if (!mode)
341a169e:	693b      	ldr	r3, [r7, #16]
341a16a0:	2b00      	cmp	r3, #0
341a16a2:	d102      	bne.n	341a16aa <VD6G_SetupSize+0x26>
    return -1;
341a16a4:	f04f 33ff 	mov.w	r3, #4294967295
341a16a8:	e0b2      	b.n	341a1810 <VD6G_SetupSize+0x18c>

  ret = ctx->write8(ctx, VD6G_REG_READOUT_CTRL, mode->bin_mode);
341a16aa:	687b      	ldr	r3, [r7, #4]
341a16ac:	691b      	ldr	r3, [r3, #16]
341a16ae:	693a      	ldr	r2, [r7, #16]
341a16b0:	7a12      	ldrb	r2, [r2, #8]
341a16b2:	f240 417e 	movw	r1, #1150	@ 0x47e
341a16b6:	6878      	ldr	r0, [r7, #4]
341a16b8:	4798      	blx	r3
341a16ba:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a16bc:	68fb      	ldr	r3, [r7, #12]
341a16be:	2b00      	cmp	r3, #0
341a16c0:	d008      	beq.n	341a16d4 <VD6G_SetupSize+0x50>
341a16c2:	68fb      	ldr	r3, [r7, #12]
341a16c4:	9300      	str	r3, [sp, #0]
341a16c6:	f240 3329 	movw	r3, #809	@ 0x329
341a16ca:	4a53      	ldr	r2, [pc, #332]	@ (341a1818 <VD6G_SetupSize+0x194>)
341a16cc:	4953      	ldr	r1, [pc, #332]	@ (341a181c <VD6G_SetupSize+0x198>)
341a16ce:	6878      	ldr	r0, [r7, #4]
341a16d0:	f7fe ff69 	bl	341a05a6 <VD6G_error>
341a16d4:	68fb      	ldr	r3, [r7, #12]
341a16d6:	2b00      	cmp	r3, #0
341a16d8:	d002      	beq.n	341a16e0 <VD6G_SetupSize+0x5c>
341a16da:	6878      	ldr	r0, [r7, #4]
341a16dc:	f7fe ff7e 	bl	341a05dc <display_error>
341a16e0:	68fb      	ldr	r3, [r7, #12]
341a16e2:	2b00      	cmp	r3, #0
341a16e4:	d001      	beq.n	341a16ea <VD6G_SetupSize+0x66>
341a16e6:	68fb      	ldr	r3, [r7, #12]
341a16e8:	e092      	b.n	341a1810 <VD6G_SetupSize+0x18c>

  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_START, mode->crop.left);
341a16ea:	687b      	ldr	r3, [r7, #4]
341a16ec:	695b      	ldr	r3, [r3, #20]
341a16ee:	693a      	ldr	r2, [r7, #16]
341a16f0:	68d2      	ldr	r2, [r2, #12]
341a16f2:	b292      	uxth	r2, r2
341a16f4:	f240 415e 	movw	r1, #1118	@ 0x45e
341a16f8:	6878      	ldr	r0, [r7, #4]
341a16fa:	4798      	blx	r3
341a16fc:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a16fe:	68fb      	ldr	r3, [r7, #12]
341a1700:	2b00      	cmp	r3, #0
341a1702:	d008      	beq.n	341a1716 <VD6G_SetupSize+0x92>
341a1704:	68fb      	ldr	r3, [r7, #12]
341a1706:	9300      	str	r3, [sp, #0]
341a1708:	f44f 734b 	mov.w	r3, #812	@ 0x32c
341a170c:	4a42      	ldr	r2, [pc, #264]	@ (341a1818 <VD6G_SetupSize+0x194>)
341a170e:	4943      	ldr	r1, [pc, #268]	@ (341a181c <VD6G_SetupSize+0x198>)
341a1710:	6878      	ldr	r0, [r7, #4]
341a1712:	f7fe ff48 	bl	341a05a6 <VD6G_error>
341a1716:	68fb      	ldr	r3, [r7, #12]
341a1718:	2b00      	cmp	r3, #0
341a171a:	d002      	beq.n	341a1722 <VD6G_SetupSize+0x9e>
341a171c:	6878      	ldr	r0, [r7, #4]
341a171e:	f7fe ff5d 	bl	341a05dc <display_error>
341a1722:	68fb      	ldr	r3, [r7, #12]
341a1724:	2b00      	cmp	r3, #0
341a1726:	d001      	beq.n	341a172c <VD6G_SetupSize+0xa8>
341a1728:	68fb      	ldr	r3, [r7, #12]
341a172a:	e071      	b.n	341a1810 <VD6G_SetupSize+0x18c>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_X_END, mode->crop.left + mode->crop.width - 1);
341a172c:	687b      	ldr	r3, [r7, #4]
341a172e:	695b      	ldr	r3, [r3, #20]
341a1730:	693a      	ldr	r2, [r7, #16]
341a1732:	68d2      	ldr	r2, [r2, #12]
341a1734:	b291      	uxth	r1, r2
341a1736:	693a      	ldr	r2, [r7, #16]
341a1738:	6952      	ldr	r2, [r2, #20]
341a173a:	b292      	uxth	r2, r2
341a173c:	440a      	add	r2, r1
341a173e:	b292      	uxth	r2, r2
341a1740:	3a01      	subs	r2, #1
341a1742:	b292      	uxth	r2, r2
341a1744:	f44f 618c 	mov.w	r1, #1120	@ 0x460
341a1748:	6878      	ldr	r0, [r7, #4]
341a174a:	4798      	blx	r3
341a174c:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a174e:	68fb      	ldr	r3, [r7, #12]
341a1750:	2b00      	cmp	r3, #0
341a1752:	d008      	beq.n	341a1766 <VD6G_SetupSize+0xe2>
341a1754:	68fb      	ldr	r3, [r7, #12]
341a1756:	9300      	str	r3, [sp, #0]
341a1758:	f240 332e 	movw	r3, #814	@ 0x32e
341a175c:	4a2e      	ldr	r2, [pc, #184]	@ (341a1818 <VD6G_SetupSize+0x194>)
341a175e:	492f      	ldr	r1, [pc, #188]	@ (341a181c <VD6G_SetupSize+0x198>)
341a1760:	6878      	ldr	r0, [r7, #4]
341a1762:	f7fe ff20 	bl	341a05a6 <VD6G_error>
341a1766:	68fb      	ldr	r3, [r7, #12]
341a1768:	2b00      	cmp	r3, #0
341a176a:	d002      	beq.n	341a1772 <VD6G_SetupSize+0xee>
341a176c:	6878      	ldr	r0, [r7, #4]
341a176e:	f7fe ff35 	bl	341a05dc <display_error>
341a1772:	68fb      	ldr	r3, [r7, #12]
341a1774:	2b00      	cmp	r3, #0
341a1776:	d001      	beq.n	341a177c <VD6G_SetupSize+0xf8>
341a1778:	68fb      	ldr	r3, [r7, #12]
341a177a:	e049      	b.n	341a1810 <VD6G_SetupSize+0x18c>

  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_START, mode->crop.top);
341a177c:	687b      	ldr	r3, [r7, #4]
341a177e:	695b      	ldr	r3, [r3, #20]
341a1780:	693a      	ldr	r2, [r7, #16]
341a1782:	6912      	ldr	r2, [r2, #16]
341a1784:	b292      	uxth	r2, r2
341a1786:	f240 4162 	movw	r1, #1122	@ 0x462
341a178a:	6878      	ldr	r0, [r7, #4]
341a178c:	4798      	blx	r3
341a178e:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1790:	68fb      	ldr	r3, [r7, #12]
341a1792:	2b00      	cmp	r3, #0
341a1794:	d008      	beq.n	341a17a8 <VD6G_SetupSize+0x124>
341a1796:	68fb      	ldr	r3, [r7, #12]
341a1798:	9300      	str	r3, [sp, #0]
341a179a:	f240 3331 	movw	r3, #817	@ 0x331
341a179e:	4a1e      	ldr	r2, [pc, #120]	@ (341a1818 <VD6G_SetupSize+0x194>)
341a17a0:	491e      	ldr	r1, [pc, #120]	@ (341a181c <VD6G_SetupSize+0x198>)
341a17a2:	6878      	ldr	r0, [r7, #4]
341a17a4:	f7fe feff 	bl	341a05a6 <VD6G_error>
341a17a8:	68fb      	ldr	r3, [r7, #12]
341a17aa:	2b00      	cmp	r3, #0
341a17ac:	d002      	beq.n	341a17b4 <VD6G_SetupSize+0x130>
341a17ae:	6878      	ldr	r0, [r7, #4]
341a17b0:	f7fe ff14 	bl	341a05dc <display_error>
341a17b4:	68fb      	ldr	r3, [r7, #12]
341a17b6:	2b00      	cmp	r3, #0
341a17b8:	d001      	beq.n	341a17be <VD6G_SetupSize+0x13a>
341a17ba:	68fb      	ldr	r3, [r7, #12]
341a17bc:	e028      	b.n	341a1810 <VD6G_SetupSize+0x18c>
  ret = ctx->write16(ctx, VD6G_REG_OUT_ROI_Y_END, mode->crop.top + mode->crop.height - 1);
341a17be:	687b      	ldr	r3, [r7, #4]
341a17c0:	695b      	ldr	r3, [r3, #20]
341a17c2:	693a      	ldr	r2, [r7, #16]
341a17c4:	6912      	ldr	r2, [r2, #16]
341a17c6:	b291      	uxth	r1, r2
341a17c8:	693a      	ldr	r2, [r7, #16]
341a17ca:	6992      	ldr	r2, [r2, #24]
341a17cc:	b292      	uxth	r2, r2
341a17ce:	440a      	add	r2, r1
341a17d0:	b292      	uxth	r2, r2
341a17d2:	3a01      	subs	r2, #1
341a17d4:	b292      	uxth	r2, r2
341a17d6:	f240 4164 	movw	r1, #1124	@ 0x464
341a17da:	6878      	ldr	r0, [r7, #4]
341a17dc:	4798      	blx	r3
341a17de:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a17e0:	68fb      	ldr	r3, [r7, #12]
341a17e2:	2b00      	cmp	r3, #0
341a17e4:	d008      	beq.n	341a17f8 <VD6G_SetupSize+0x174>
341a17e6:	68fb      	ldr	r3, [r7, #12]
341a17e8:	9300      	str	r3, [sp, #0]
341a17ea:	f240 3333 	movw	r3, #819	@ 0x333
341a17ee:	4a0a      	ldr	r2, [pc, #40]	@ (341a1818 <VD6G_SetupSize+0x194>)
341a17f0:	490a      	ldr	r1, [pc, #40]	@ (341a181c <VD6G_SetupSize+0x198>)
341a17f2:	6878      	ldr	r0, [r7, #4]
341a17f4:	f7fe fed7 	bl	341a05a6 <VD6G_error>
341a17f8:	68fb      	ldr	r3, [r7, #12]
341a17fa:	2b00      	cmp	r3, #0
341a17fc:	d002      	beq.n	341a1804 <VD6G_SetupSize+0x180>
341a17fe:	6878      	ldr	r0, [r7, #4]
341a1800:	f7fe feec 	bl	341a05dc <display_error>
341a1804:	68fb      	ldr	r3, [r7, #12]
341a1806:	2b00      	cmp	r3, #0
341a1808:	d001      	beq.n	341a180e <VD6G_SetupSize+0x18a>
341a180a:	68fb      	ldr	r3, [r7, #12]
341a180c:	e000      	b.n	341a1810 <VD6G_SetupSize+0x18c>

  return 0;
341a180e:	2300      	movs	r3, #0
}
341a1810:	4618      	mov	r0, r3
341a1812:	3718      	adds	r7, #24
341a1814:	46bd      	mov	sp, r7
341a1816:	bd80      	pop	{r7, pc}
341a1818:	341ae544 	.word	0x341ae544
341a181c:	341a7b68 	.word	0x341a7b68

341a1820 <VD6G_SetupFrameRate>:

static int VD6G_SetupFrameRate(VD6G_Ctx_t *ctx)
{
341a1820:	b580      	push	{r7, lr}
341a1822:	b088      	sub	sp, #32
341a1824:	af02      	add	r7, sp, #8
341a1826:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1828:	687b      	ldr	r3, [r7, #4]
341a182a:	332c      	adds	r3, #44	@ 0x2c
341a182c:	617b      	str	r3, [r7, #20]
  uint16_t frame_length;
  uint16_t line_length;
  int ret;

  ret = ctx->read16(ctx, VD6G_LINE_LENGTH, &line_length);
341a182e:	687b      	ldr	r3, [r7, #4]
341a1830:	689b      	ldr	r3, [r3, #8]
341a1832:	f107 020c 	add.w	r2, r7, #12
341a1836:	f44f 7140 	mov.w	r1, #768	@ 0x300
341a183a:	6878      	ldr	r0, [r7, #4]
341a183c:	4798      	blx	r3
341a183e:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a1840:	693b      	ldr	r3, [r7, #16]
341a1842:	2b00      	cmp	r3, #0
341a1844:	d008      	beq.n	341a1858 <VD6G_SetupFrameRate+0x38>
341a1846:	693b      	ldr	r3, [r7, #16]
341a1848:	9300      	str	r3, [sp, #0]
341a184a:	f44f 7350 	mov.w	r3, #832	@ 0x340
341a184e:	4a27      	ldr	r2, [pc, #156]	@ (341a18ec <VD6G_SetupFrameRate+0xcc>)
341a1850:	4927      	ldr	r1, [pc, #156]	@ (341a18f0 <VD6G_SetupFrameRate+0xd0>)
341a1852:	6878      	ldr	r0, [r7, #4]
341a1854:	f7fe fea7 	bl	341a05a6 <VD6G_error>
341a1858:	693b      	ldr	r3, [r7, #16]
341a185a:	2b00      	cmp	r3, #0
341a185c:	d002      	beq.n	341a1864 <VD6G_SetupFrameRate+0x44>
341a185e:	6878      	ldr	r0, [r7, #4]
341a1860:	f7fe febc 	bl	341a05dc <display_error>
341a1864:	693b      	ldr	r3, [r7, #16]
341a1866:	2b00      	cmp	r3, #0
341a1868:	d001      	beq.n	341a186e <VD6G_SetupFrameRate+0x4e>
341a186a:	693b      	ldr	r3, [r7, #16]
341a186c:	e039      	b.n	341a18e2 <VD6G_SetupFrameRate+0xc2>
  VD6G_dbg(ctx, 0, "Line len = %d\n", line_length);
341a186e:	89bb      	ldrh	r3, [r7, #12]
341a1870:	4a20      	ldr	r2, [pc, #128]	@ (341a18f4 <VD6G_SetupFrameRate+0xd4>)
341a1872:	2100      	movs	r1, #0
341a1874:	6878      	ldr	r0, [r7, #4]
341a1876:	f7fe fe43 	bl	341a0500 <VD6G_dbg>

  frame_length = VD6G_PIXEL_CLOCK / (line_length * drv_ctx->config_save.frame_rate);
341a187a:	89bb      	ldrh	r3, [r7, #12]
341a187c:	461a      	mov	r2, r3
341a187e:	697b      	ldr	r3, [r7, #20]
341a1880:	68db      	ldr	r3, [r3, #12]
341a1882:	fb02 f303 	mul.w	r3, r2, r3
341a1886:	4a1c      	ldr	r2, [pc, #112]	@ (341a18f8 <VD6G_SetupFrameRate+0xd8>)
341a1888:	fb92 f3f3 	sdiv	r3, r2, r3
341a188c:	81fb      	strh	r3, [r7, #14]
  VD6G_dbg(ctx, 0, "Set frame_length to %d to reach %d fps\n", frame_length, drv_ctx->config_save.frame_rate);
341a188e:	89fa      	ldrh	r2, [r7, #14]
341a1890:	697b      	ldr	r3, [r7, #20]
341a1892:	68db      	ldr	r3, [r3, #12]
341a1894:	9300      	str	r3, [sp, #0]
341a1896:	4613      	mov	r3, r2
341a1898:	4a18      	ldr	r2, [pc, #96]	@ (341a18fc <VD6G_SetupFrameRate+0xdc>)
341a189a:	2100      	movs	r1, #0
341a189c:	6878      	ldr	r0, [r7, #4]
341a189e:	f7fe fe2f 	bl	341a0500 <VD6G_dbg>
  ret = ctx->write16(ctx, VD6G_FRAME_LENGTH, frame_length);
341a18a2:	687b      	ldr	r3, [r7, #4]
341a18a4:	695b      	ldr	r3, [r3, #20]
341a18a6:	89fa      	ldrh	r2, [r7, #14]
341a18a8:	f44f 618b 	mov.w	r1, #1112	@ 0x458
341a18ac:	6878      	ldr	r0, [r7, #4]
341a18ae:	4798      	blx	r3
341a18b0:	6138      	str	r0, [r7, #16]
  VD6G_TraceError(ctx, ret);
341a18b2:	693b      	ldr	r3, [r7, #16]
341a18b4:	2b00      	cmp	r3, #0
341a18b6:	d008      	beq.n	341a18ca <VD6G_SetupFrameRate+0xaa>
341a18b8:	693b      	ldr	r3, [r7, #16]
341a18ba:	9300      	str	r3, [sp, #0]
341a18bc:	f240 3346 	movw	r3, #838	@ 0x346
341a18c0:	4a0a      	ldr	r2, [pc, #40]	@ (341a18ec <VD6G_SetupFrameRate+0xcc>)
341a18c2:	490b      	ldr	r1, [pc, #44]	@ (341a18f0 <VD6G_SetupFrameRate+0xd0>)
341a18c4:	6878      	ldr	r0, [r7, #4]
341a18c6:	f7fe fe6e 	bl	341a05a6 <VD6G_error>
341a18ca:	693b      	ldr	r3, [r7, #16]
341a18cc:	2b00      	cmp	r3, #0
341a18ce:	d002      	beq.n	341a18d6 <VD6G_SetupFrameRate+0xb6>
341a18d0:	6878      	ldr	r0, [r7, #4]
341a18d2:	f7fe fe83 	bl	341a05dc <display_error>
341a18d6:	693b      	ldr	r3, [r7, #16]
341a18d8:	2b00      	cmp	r3, #0
341a18da:	d001      	beq.n	341a18e0 <VD6G_SetupFrameRate+0xc0>
341a18dc:	693b      	ldr	r3, [r7, #16]
341a18de:	e000      	b.n	341a18e2 <VD6G_SetupFrameRate+0xc2>

  return 0;
341a18e0:	2300      	movs	r3, #0
}
341a18e2:	4618      	mov	r0, r3
341a18e4:	3718      	adds	r7, #24
341a18e6:	46bd      	mov	sp, r7
341a18e8:	bd80      	pop	{r7, pc}
341a18ea:	bf00      	nop
341a18ec:	341ae554 	.word	0x341ae554
341a18f0:	341a7b68 	.word	0x341a7b68
341a18f4:	341a7d54 	.word	0x341a7d54
341a18f8:	09959d00 	.word	0x09959d00
341a18fc:	341a7d64 	.word	0x341a7d64

341a1900 <VD6G_SetupExposure>:

static int VD6G_SetupExposure(VD6G_Ctx_t *ctx)
{
341a1900:	b580      	push	{r7, lr}
341a1902:	b084      	sub	sp, #16
341a1904:	af00      	add	r7, sp, #0
341a1906:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1908:	687b      	ldr	r3, [r7, #4]
341a190a:	332c      	adds	r3, #44	@ 0x2c
341a190c:	60fb      	str	r3, [r7, #12]

  return VD6G_SetExposureModeInternal(ctx, drv_ctx->config_save.exposure_mode);
341a190e:	68fb      	ldr	r3, [r7, #12]
341a1910:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a1914:	4619      	mov	r1, r3
341a1916:	6878      	ldr	r0, [r7, #4]
341a1918:	f7ff fba4 	bl	341a1064 <VD6G_SetExposureModeInternal>
341a191c:	4603      	mov	r3, r0
}
341a191e:	4618      	mov	r0, r3
341a1920:	3710      	adds	r7, #16
341a1922:	46bd      	mov	sp, r7
341a1924:	bd80      	pop	{r7, pc}
	...

341a1928 <VD6G_SetupMirrorFlip>:

static int VD6G_SetupMirrorFlip(VD6G_Ctx_t *ctx)
{
341a1928:	b580      	push	{r7, lr}
341a192a:	b088      	sub	sp, #32
341a192c:	af02      	add	r7, sp, #8
341a192e:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1930:	687b      	ldr	r3, [r7, #4]
341a1932:	332c      	adds	r3, #44	@ 0x2c
341a1934:	613b      	str	r3, [r7, #16]
  uint8_t mode;
  int ret;

  switch (drv_ctx->config_save.flip_mirror_mode) {
341a1936:	693b      	ldr	r3, [r7, #16]
341a1938:	7c1b      	ldrb	r3, [r3, #16]
341a193a:	2b03      	cmp	r3, #3
341a193c:	d816      	bhi.n	341a196c <VD6G_SetupMirrorFlip+0x44>
341a193e:	a201      	add	r2, pc, #4	@ (adr r2, 341a1944 <VD6G_SetupMirrorFlip+0x1c>)
341a1940:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a1944:	341a1955 	.word	0x341a1955
341a1948:	341a195b 	.word	0x341a195b
341a194c:	341a1961 	.word	0x341a1961
341a1950:	341a1967 	.word	0x341a1967
  case VD6G_MIRROR_FLIP_NONE:
    mode = 0;
341a1954:	2300      	movs	r3, #0
341a1956:	75fb      	strb	r3, [r7, #23]
    break;
341a1958:	e00b      	b.n	341a1972 <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_FLIP:
    mode = 2;
341a195a:	2302      	movs	r3, #2
341a195c:	75fb      	strb	r3, [r7, #23]
    break;
341a195e:	e008      	b.n	341a1972 <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_MIRROR:
    mode = 1;
341a1960:	2301      	movs	r3, #1
341a1962:	75fb      	strb	r3, [r7, #23]
    break;
341a1964:	e005      	b.n	341a1972 <VD6G_SetupMirrorFlip+0x4a>
  case VD6G_MIRROR_FLIP:
    mode = 3;
341a1966:	2303      	movs	r3, #3
341a1968:	75fb      	strb	r3, [r7, #23]
    break;
341a196a:	e002      	b.n	341a1972 <VD6G_SetupMirrorFlip+0x4a>
  default:
    return -1;
341a196c:	f04f 33ff 	mov.w	r3, #4294967295
341a1970:	e01f      	b.n	341a19b2 <VD6G_SetupMirrorFlip+0x8a>
  }

  ret = ctx->write8(ctx, VD6G_REG_ORIENTATION, mode);
341a1972:	687b      	ldr	r3, [r7, #4]
341a1974:	691b      	ldr	r3, [r3, #16]
341a1976:	7dfa      	ldrb	r2, [r7, #23]
341a1978:	f240 3102 	movw	r1, #770	@ 0x302
341a197c:	6878      	ldr	r0, [r7, #4]
341a197e:	4798      	blx	r3
341a1980:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1982:	68fb      	ldr	r3, [r7, #12]
341a1984:	2b00      	cmp	r3, #0
341a1986:	d008      	beq.n	341a199a <VD6G_SetupMirrorFlip+0x72>
341a1988:	68fb      	ldr	r3, [r7, #12]
341a198a:	9300      	str	r3, [sp, #0]
341a198c:	f240 336a 	movw	r3, #874	@ 0x36a
341a1990:	4a0a      	ldr	r2, [pc, #40]	@ (341a19bc <VD6G_SetupMirrorFlip+0x94>)
341a1992:	490b      	ldr	r1, [pc, #44]	@ (341a19c0 <VD6G_SetupMirrorFlip+0x98>)
341a1994:	6878      	ldr	r0, [r7, #4]
341a1996:	f7fe fe06 	bl	341a05a6 <VD6G_error>
341a199a:	68fb      	ldr	r3, [r7, #12]
341a199c:	2b00      	cmp	r3, #0
341a199e:	d002      	beq.n	341a19a6 <VD6G_SetupMirrorFlip+0x7e>
341a19a0:	6878      	ldr	r0, [r7, #4]
341a19a2:	f7fe fe1b 	bl	341a05dc <display_error>
341a19a6:	68fb      	ldr	r3, [r7, #12]
341a19a8:	2b00      	cmp	r3, #0
341a19aa:	d001      	beq.n	341a19b0 <VD6G_SetupMirrorFlip+0x88>
341a19ac:	68fb      	ldr	r3, [r7, #12]
341a19ae:	e000      	b.n	341a19b2 <VD6G_SetupMirrorFlip+0x8a>

  return 0;
341a19b0:	2300      	movs	r3, #0
}
341a19b2:	4618      	mov	r0, r3
341a19b4:	3718      	adds	r7, #24
341a19b6:	46bd      	mov	sp, r7
341a19b8:	bd80      	pop	{r7, pc}
341a19ba:	bf00      	nop
341a19bc:	341ae568 	.word	0x341ae568
341a19c0:	341a7b68 	.word	0x341a7b68

341a19c4 <VD6G_SetupPatGen>:

static int VD6G_SetupPatGen(VD6G_Ctx_t *ctx)
{
341a19c4:	b580      	push	{r7, lr}
341a19c6:	b088      	sub	sp, #32
341a19c8:	af02      	add	r7, sp, #8
341a19ca:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a19cc:	687b      	ldr	r3, [r7, #4]
341a19ce:	332c      	adds	r3, #44	@ 0x2c
341a19d0:	613b      	str	r3, [r7, #16]
  uint16_t value = VD6G_PATGEN_CTRL_DISABLE;
341a19d2:	2300      	movs	r3, #0
341a19d4:	82fb      	strh	r3, [r7, #22]
  int ret;

  switch (drv_ctx->config_save.patgen) {
341a19d6:	693b      	ldr	r3, [r7, #16]
341a19d8:	7e1b      	ldrb	r3, [r3, #24]
341a19da:	2b06      	cmp	r3, #6
341a19dc:	d829      	bhi.n	341a1a32 <VD6G_SetupPatGen+0x6e>
341a19de:	a201      	add	r2, pc, #4	@ (adr r2, 341a19e4 <VD6G_SetupPatGen+0x20>)
341a19e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a19e4:	341a1a01 	.word	0x341a1a01
341a19e8:	341a1a07 	.word	0x341a1a07
341a19ec:	341a1a0d 	.word	0x341a1a0d
341a19f0:	341a1a13 	.word	0x341a1a13
341a19f4:	341a1a1b 	.word	0x341a1a1b
341a19f8:	341a1a23 	.word	0x341a1a23
341a19fc:	341a1a2b 	.word	0x341a1a2b
  case VD6G_PATGEN_DISABLE:
    value = VD6G_PATGEN_CTRL_DISABLE;
341a1a00:	2300      	movs	r3, #0
341a1a02:	82fb      	strh	r3, [r7, #22]
    break;
341a1a04:	e018      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_SOLID_COLOR:
    value = VD6G_PATGEN_CTRL_SOLID_COLOR ;
341a1a06:	2311      	movs	r3, #17
341a1a08:	82fb      	strh	r3, [r7, #22]
    break;
341a1a0a:	e015      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_VERTICAL_COLOR_BARS:
    value = VD6G_PATGEN_CTRL_VER_COLOR_BAR;
341a1a0c:	2321      	movs	r3, #33	@ 0x21
341a1a0e:	82fb      	strh	r3, [r7, #22]
    break;
341a1a10:	e012      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_HORIZONTAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_HOR_GRAY;
341a1a12:	f240 1301 	movw	r3, #257	@ 0x101
341a1a16:	82fb      	strh	r3, [r7, #22]
    break;
341a1a18:	e00e      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_VERTICAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_VER_GRAY;
341a1a1a:	f240 1311 	movw	r3, #273	@ 0x111
341a1a1e:	82fb      	strh	r3, [r7, #22]
    break;
341a1a20:	e00a      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_DIAGONAL_GRAYSCALE:
    value = VD6G_PATGEN_CTRL_DIAG_GRAY;
341a1a22:	f240 1321 	movw	r3, #289	@ 0x121
341a1a26:	82fb      	strh	r3, [r7, #22]
    break;
341a1a28:	e006      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  case VD6G_PATGEN_PSEUDO_RANDOM:
    value = VD6G_PATGEN_CTRL_PSN;
341a1a2a:	f240 1331 	movw	r3, #305	@ 0x131
341a1a2e:	82fb      	strh	r3, [r7, #22]
    break;
341a1a30:	e002      	b.n	341a1a38 <VD6G_SetupPatGen+0x74>
  default:
    return -1;
341a1a32:	f04f 33ff 	mov.w	r3, #4294967295
341a1a36:	e061      	b.n	341a1afc <VD6G_SetupPatGen+0x138>
  }

  if (drv_ctx->config_save.patgen != VD6G_PATGEN_DISABLE)
341a1a38:	693b      	ldr	r3, [r7, #16]
341a1a3a:	7e1b      	ldrb	r3, [r3, #24]
341a1a3c:	2b00      	cmp	r3, #0
341a1a3e:	d03d      	beq.n	341a1abc <VD6G_SetupPatGen+0xf8>
  {
    ret = ctx->write8(ctx, VD6G_REG_DUSTER_CTRL, VD6G_DUSTER_CTRL_DISABLE);
341a1a40:	687b      	ldr	r3, [r7, #4]
341a1a42:	691b      	ldr	r3, [r3, #16]
341a1a44:	2200      	movs	r2, #0
341a1a46:	f44f 7146 	mov.w	r1, #792	@ 0x318
341a1a4a:	6878      	ldr	r0, [r7, #4]
341a1a4c:	4798      	blx	r3
341a1a4e:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
341a1a50:	68fb      	ldr	r3, [r7, #12]
341a1a52:	2b00      	cmp	r3, #0
341a1a54:	d008      	beq.n	341a1a68 <VD6G_SetupPatGen+0xa4>
341a1a56:	68fb      	ldr	r3, [r7, #12]
341a1a58:	9300      	str	r3, [sp, #0]
341a1a5a:	f240 3392 	movw	r3, #914	@ 0x392
341a1a5e:	4a29      	ldr	r2, [pc, #164]	@ (341a1b04 <VD6G_SetupPatGen+0x140>)
341a1a60:	4929      	ldr	r1, [pc, #164]	@ (341a1b08 <VD6G_SetupPatGen+0x144>)
341a1a62:	6878      	ldr	r0, [r7, #4]
341a1a64:	f7fe fd9f 	bl	341a05a6 <VD6G_error>
341a1a68:	68fb      	ldr	r3, [r7, #12]
341a1a6a:	2b00      	cmp	r3, #0
341a1a6c:	d002      	beq.n	341a1a74 <VD6G_SetupPatGen+0xb0>
341a1a6e:	6878      	ldr	r0, [r7, #4]
341a1a70:	f7fe fdb4 	bl	341a05dc <display_error>
341a1a74:	68fb      	ldr	r3, [r7, #12]
341a1a76:	2b00      	cmp	r3, #0
341a1a78:	d001      	beq.n	341a1a7e <VD6G_SetupPatGen+0xba>
341a1a7a:	68fb      	ldr	r3, [r7, #12]
341a1a7c:	e03e      	b.n	341a1afc <VD6G_SetupPatGen+0x138>
    ret = ctx->write8(ctx, VD6G_REG_DARKCAL_CTRL, VD6G_DARKCAL_CTRL_DISABLE_DARKAVG);
341a1a7e:	687b      	ldr	r3, [r7, #4]
341a1a80:	691b      	ldr	r3, [r3, #16]
341a1a82:	2202      	movs	r2, #2
341a1a84:	f44f 7150 	mov.w	r1, #832	@ 0x340
341a1a88:	6878      	ldr	r0, [r7, #4]
341a1a8a:	4798      	blx	r3
341a1a8c:	60f8      	str	r0, [r7, #12]
    VD6G_TraceError(ctx, ret);
341a1a8e:	68fb      	ldr	r3, [r7, #12]
341a1a90:	2b00      	cmp	r3, #0
341a1a92:	d008      	beq.n	341a1aa6 <VD6G_SetupPatGen+0xe2>
341a1a94:	68fb      	ldr	r3, [r7, #12]
341a1a96:	9300      	str	r3, [sp, #0]
341a1a98:	f44f 7365 	mov.w	r3, #916	@ 0x394
341a1a9c:	4a19      	ldr	r2, [pc, #100]	@ (341a1b04 <VD6G_SetupPatGen+0x140>)
341a1a9e:	491a      	ldr	r1, [pc, #104]	@ (341a1b08 <VD6G_SetupPatGen+0x144>)
341a1aa0:	6878      	ldr	r0, [r7, #4]
341a1aa2:	f7fe fd80 	bl	341a05a6 <VD6G_error>
341a1aa6:	68fb      	ldr	r3, [r7, #12]
341a1aa8:	2b00      	cmp	r3, #0
341a1aaa:	d002      	beq.n	341a1ab2 <VD6G_SetupPatGen+0xee>
341a1aac:	6878      	ldr	r0, [r7, #4]
341a1aae:	f7fe fd95 	bl	341a05dc <display_error>
341a1ab2:	68fb      	ldr	r3, [r7, #12]
341a1ab4:	2b00      	cmp	r3, #0
341a1ab6:	d001      	beq.n	341a1abc <VD6G_SetupPatGen+0xf8>
341a1ab8:	68fb      	ldr	r3, [r7, #12]
341a1aba:	e01f      	b.n	341a1afc <VD6G_SetupPatGen+0x138>
  }

  ret = ctx->write16(ctx, VD6G_REG_PATGEN_CTRL, value);
341a1abc:	687b      	ldr	r3, [r7, #4]
341a1abe:	695b      	ldr	r3, [r3, #20]
341a1ac0:	8afa      	ldrh	r2, [r7, #22]
341a1ac2:	f44f 6180 	mov.w	r1, #1024	@ 0x400
341a1ac6:	6878      	ldr	r0, [r7, #4]
341a1ac8:	4798      	blx	r3
341a1aca:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1acc:	68fb      	ldr	r3, [r7, #12]
341a1ace:	2b00      	cmp	r3, #0
341a1ad0:	d008      	beq.n	341a1ae4 <VD6G_SetupPatGen+0x120>
341a1ad2:	68fb      	ldr	r3, [r7, #12]
341a1ad4:	9300      	str	r3, [sp, #0]
341a1ad6:	f44f 7366 	mov.w	r3, #920	@ 0x398
341a1ada:	4a0a      	ldr	r2, [pc, #40]	@ (341a1b04 <VD6G_SetupPatGen+0x140>)
341a1adc:	490a      	ldr	r1, [pc, #40]	@ (341a1b08 <VD6G_SetupPatGen+0x144>)
341a1ade:	6878      	ldr	r0, [r7, #4]
341a1ae0:	f7fe fd61 	bl	341a05a6 <VD6G_error>
341a1ae4:	68fb      	ldr	r3, [r7, #12]
341a1ae6:	2b00      	cmp	r3, #0
341a1ae8:	d002      	beq.n	341a1af0 <VD6G_SetupPatGen+0x12c>
341a1aea:	6878      	ldr	r0, [r7, #4]
341a1aec:	f7fe fd76 	bl	341a05dc <display_error>
341a1af0:	68fb      	ldr	r3, [r7, #12]
341a1af2:	2b00      	cmp	r3, #0
341a1af4:	d001      	beq.n	341a1afa <VD6G_SetupPatGen+0x136>
341a1af6:	68fb      	ldr	r3, [r7, #12]
341a1af8:	e000      	b.n	341a1afc <VD6G_SetupPatGen+0x138>

  return 0;
341a1afa:	2300      	movs	r3, #0
}
341a1afc:	4618      	mov	r0, r3
341a1afe:	3718      	adds	r7, #24
341a1b00:	46bd      	mov	sp, r7
341a1b02:	bd80      	pop	{r7, pc}
341a1b04:	341ae580 	.word	0x341ae580
341a1b08:	341a7b68 	.word	0x341a7b68

341a1b0c <VD6G_SetFlicker>:

static int VD6G_SetFlicker(VD6G_Ctx_t *ctx, VD6G_Flicker_t flicker)
{
341a1b0c:	b580      	push	{r7, lr}
341a1b0e:	b086      	sub	sp, #24
341a1b10:	af02      	add	r7, sp, #8
341a1b12:	6078      	str	r0, [r7, #4]
341a1b14:	460b      	mov	r3, r1
341a1b16:	70fb      	strb	r3, [r7, #3]
  uint16_t mode;
  int ret;

  switch (flicker) {
341a1b18:	78fb      	ldrb	r3, [r7, #3]
341a1b1a:	2b02      	cmp	r3, #2
341a1b1c:	d00c      	beq.n	341a1b38 <VD6G_SetFlicker+0x2c>
341a1b1e:	2b02      	cmp	r3, #2
341a1b20:	dc0d      	bgt.n	341a1b3e <VD6G_SetFlicker+0x32>
341a1b22:	2b00      	cmp	r3, #0
341a1b24:	d002      	beq.n	341a1b2c <VD6G_SetFlicker+0x20>
341a1b26:	2b01      	cmp	r3, #1
341a1b28:	d003      	beq.n	341a1b32 <VD6G_SetFlicker+0x26>
341a1b2a:	e008      	b.n	341a1b3e <VD6G_SetFlicker+0x32>
  case VD6G_FLICKER_FREE_NONE:
    mode = AE_COMP_CTRL_GAIN_PRIO;
341a1b2c:	2300      	movs	r3, #0
341a1b2e:	81fb      	strh	r3, [r7, #14]
    break;
341a1b30:	e008      	b.n	341a1b44 <VD6G_SetFlicker+0x38>
  case VD6G_FLICKER_FREE_50HZ:
    mode = AE_COMP_CTRL_FLICKER_50_HZ;
341a1b32:	2301      	movs	r3, #1
341a1b34:	81fb      	strh	r3, [r7, #14]
    break;
341a1b36:	e005      	b.n	341a1b44 <VD6G_SetFlicker+0x38>
  case VD6G_FLICKER_FREE_60HZ:
    mode = AE_COMP_CTRL_FLICKER_60_HZ;
341a1b38:	2303      	movs	r3, #3
341a1b3a:	81fb      	strh	r3, [r7, #14]
    break;
341a1b3c:	e002      	b.n	341a1b44 <VD6G_SetFlicker+0x38>
  default:
    return -1;
341a1b3e:	f04f 33ff 	mov.w	r3, #4294967295
341a1b42:	e01f      	b.n	341a1b84 <VD6G_SetFlicker+0x78>
  }

  ret = ctx->write16(ctx, VD6G_REG_AE_COMPILER_CONTROL, mode);
341a1b44:	687b      	ldr	r3, [r7, #4]
341a1b46:	695b      	ldr	r3, [r3, #20]
341a1b48:	89fa      	ldrh	r2, [r7, #14]
341a1b4a:	f44f 6186 	mov.w	r1, #1072	@ 0x430
341a1b4e:	6878      	ldr	r0, [r7, #4]
341a1b50:	4798      	blx	r3
341a1b52:	60b8      	str	r0, [r7, #8]
  VD6G_TraceError(ctx, ret);
341a1b54:	68bb      	ldr	r3, [r7, #8]
341a1b56:	2b00      	cmp	r3, #0
341a1b58:	d008      	beq.n	341a1b6c <VD6G_SetFlicker+0x60>
341a1b5a:	68bb      	ldr	r3, [r7, #8]
341a1b5c:	9300      	str	r3, [sp, #0]
341a1b5e:	f240 33b1 	movw	r3, #945	@ 0x3b1
341a1b62:	4a0a      	ldr	r2, [pc, #40]	@ (341a1b8c <VD6G_SetFlicker+0x80>)
341a1b64:	490a      	ldr	r1, [pc, #40]	@ (341a1b90 <VD6G_SetFlicker+0x84>)
341a1b66:	6878      	ldr	r0, [r7, #4]
341a1b68:	f7fe fd1d 	bl	341a05a6 <VD6G_error>
341a1b6c:	68bb      	ldr	r3, [r7, #8]
341a1b6e:	2b00      	cmp	r3, #0
341a1b70:	d002      	beq.n	341a1b78 <VD6G_SetFlicker+0x6c>
341a1b72:	6878      	ldr	r0, [r7, #4]
341a1b74:	f7fe fd32 	bl	341a05dc <display_error>
341a1b78:	68bb      	ldr	r3, [r7, #8]
341a1b7a:	2b00      	cmp	r3, #0
341a1b7c:	d001      	beq.n	341a1b82 <VD6G_SetFlicker+0x76>
341a1b7e:	68bb      	ldr	r3, [r7, #8]
341a1b80:	e000      	b.n	341a1b84 <VD6G_SetFlicker+0x78>

  return 0;
341a1b82:	2300      	movs	r3, #0
}
341a1b84:	4618      	mov	r0, r3
341a1b86:	3710      	adds	r7, #16
341a1b88:	46bd      	mov	sp, r7
341a1b8a:	bd80      	pop	{r7, pc}
341a1b8c:	341ae594 	.word	0x341ae594
341a1b90:	341a7b68 	.word	0x341a7b68

341a1b94 <VD6G_Flicker>:

static int VD6G_Flicker(VD6G_Ctx_t *ctx)
{
341a1b94:	b580      	push	{r7, lr}
341a1b96:	b084      	sub	sp, #16
341a1b98:	af00      	add	r7, sp, #0
341a1b9a:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1b9c:	687b      	ldr	r3, [r7, #4]
341a1b9e:	332c      	adds	r3, #44	@ 0x2c
341a1ba0:	60fb      	str	r3, [r7, #12]

  return VD6G_SetFlicker(ctx, drv_ctx->config_save.flicker);
341a1ba2:	68fb      	ldr	r3, [r7, #12]
341a1ba4:	7e5b      	ldrb	r3, [r3, #25]
341a1ba6:	4619      	mov	r1, r3
341a1ba8:	6878      	ldr	r0, [r7, #4]
341a1baa:	f7ff ffaf 	bl	341a1b0c <VD6G_SetFlicker>
341a1bae:	4603      	mov	r3, r0
}
341a1bb0:	4618      	mov	r0, r3
341a1bb2:	3710      	adds	r7, #16
341a1bb4:	46bd      	mov	sp, r7
341a1bb6:	bd80      	pop	{r7, pc}

341a1bb8 <VD6G_SetupEarly>:

static int VD6G_SetupEarly(VD6G_Ctx_t *ctx)
{
341a1bb8:	b580      	push	{r7, lr}
341a1bba:	b084      	sub	sp, #16
341a1bbc:	af00      	add	r7, sp, #0
341a1bbe:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_SetupClocks(ctx);
341a1bc0:	6878      	ldr	r0, [r7, #4]
341a1bc2:	f7ff fb87 	bl	341a12d4 <VD6G_SetupClocks>
341a1bc6:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1bc8:	68fb      	ldr	r3, [r7, #12]
341a1bca:	2b00      	cmp	r3, #0
341a1bcc:	d001      	beq.n	341a1bd2 <VD6G_SetupEarly+0x1a>
    return ret;
341a1bce:	68fb      	ldr	r3, [r7, #12]
341a1bd0:	e009      	b.n	341a1be6 <VD6G_SetupEarly+0x2e>

  ret = VD6G_SetupFrameRate(ctx);
341a1bd2:	6878      	ldr	r0, [r7, #4]
341a1bd4:	f7ff fe24 	bl	341a1820 <VD6G_SetupFrameRate>
341a1bd8:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1bda:	68fb      	ldr	r3, [r7, #12]
341a1bdc:	2b00      	cmp	r3, #0
341a1bde:	d001      	beq.n	341a1be4 <VD6G_SetupEarly+0x2c>
    return ret;
341a1be0:	68fb      	ldr	r3, [r7, #12]
341a1be2:	e000      	b.n	341a1be6 <VD6G_SetupEarly+0x2e>

  return 0;
341a1be4:	2300      	movs	r3, #0
}
341a1be6:	4618      	mov	r0, r3
341a1be8:	3710      	adds	r7, #16
341a1bea:	46bd      	mov	sp, r7
341a1bec:	bd80      	pop	{r7, pc}

341a1bee <VD6G_Setup>:

static int VD6G_Setup(VD6G_Ctx_t *ctx)
{
341a1bee:	b580      	push	{r7, lr}
341a1bf0:	b084      	sub	sp, #16
341a1bf2:	af00      	add	r7, sp, #0
341a1bf4:	6078      	str	r0, [r7, #4]
  int ret;

  ret = VD6G_SetupOutput(ctx);
341a1bf6:	6878      	ldr	r0, [r7, #4]
341a1bf8:	f7ff fc10 	bl	341a141c <VD6G_SetupOutput>
341a1bfc:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1bfe:	68fb      	ldr	r3, [r7, #12]
341a1c00:	2b00      	cmp	r3, #0
341a1c02:	d001      	beq.n	341a1c08 <VD6G_Setup+0x1a>
    return ret;
341a1c04:	68fb      	ldr	r3, [r7, #12]
341a1c06:	e02d      	b.n	341a1c64 <VD6G_Setup+0x76>

  ret = VD6G_SetupSize(ctx);
341a1c08:	6878      	ldr	r0, [r7, #4]
341a1c0a:	f7ff fd3b 	bl	341a1684 <VD6G_SetupSize>
341a1c0e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1c10:	68fb      	ldr	r3, [r7, #12]
341a1c12:	2b00      	cmp	r3, #0
341a1c14:	d001      	beq.n	341a1c1a <VD6G_Setup+0x2c>
    return ret;
341a1c16:	68fb      	ldr	r3, [r7, #12]
341a1c18:	e024      	b.n	341a1c64 <VD6G_Setup+0x76>

  ret = VD6G_SetupExposure(ctx);
341a1c1a:	6878      	ldr	r0, [r7, #4]
341a1c1c:	f7ff fe70 	bl	341a1900 <VD6G_SetupExposure>
341a1c20:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1c22:	68fb      	ldr	r3, [r7, #12]
341a1c24:	2b00      	cmp	r3, #0
341a1c26:	d001      	beq.n	341a1c2c <VD6G_Setup+0x3e>
    return ret;
341a1c28:	68fb      	ldr	r3, [r7, #12]
341a1c2a:	e01b      	b.n	341a1c64 <VD6G_Setup+0x76>

  ret = VD6G_SetupMirrorFlip(ctx);
341a1c2c:	6878      	ldr	r0, [r7, #4]
341a1c2e:	f7ff fe7b 	bl	341a1928 <VD6G_SetupMirrorFlip>
341a1c32:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1c34:	68fb      	ldr	r3, [r7, #12]
341a1c36:	2b00      	cmp	r3, #0
341a1c38:	d001      	beq.n	341a1c3e <VD6G_Setup+0x50>
    return ret;
341a1c3a:	68fb      	ldr	r3, [r7, #12]
341a1c3c:	e012      	b.n	341a1c64 <VD6G_Setup+0x76>

  ret = VD6G_SetupPatGen(ctx);
341a1c3e:	6878      	ldr	r0, [r7, #4]
341a1c40:	f7ff fec0 	bl	341a19c4 <VD6G_SetupPatGen>
341a1c44:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1c46:	68fb      	ldr	r3, [r7, #12]
341a1c48:	2b00      	cmp	r3, #0
341a1c4a:	d001      	beq.n	341a1c50 <VD6G_Setup+0x62>
    return ret;
341a1c4c:	68fb      	ldr	r3, [r7, #12]
341a1c4e:	e009      	b.n	341a1c64 <VD6G_Setup+0x76>

  ret = VD6G_Flicker(ctx);
341a1c50:	6878      	ldr	r0, [r7, #4]
341a1c52:	f7ff ff9f 	bl	341a1b94 <VD6G_Flicker>
341a1c56:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1c58:	68fb      	ldr	r3, [r7, #12]
341a1c5a:	2b00      	cmp	r3, #0
341a1c5c:	d001      	beq.n	341a1c62 <VD6G_Setup+0x74>
    return ret;
341a1c5e:	68fb      	ldr	r3, [r7, #12]
341a1c60:	e000      	b.n	341a1c64 <VD6G_Setup+0x76>

  return 0;
341a1c62:	2300      	movs	r3, #0
}
341a1c64:	4618      	mov	r0, r3
341a1c66:	3710      	adds	r7, #16
341a1c68:	46bd      	mov	sp, r7
341a1c6a:	bd80      	pop	{r7, pc}

341a1c6c <VD6G_StartStreaming>:

static int VD6G_StartStreaming(VD6G_Ctx_t *ctx)
{
341a1c6c:	b580      	push	{r7, lr}
341a1c6e:	b086      	sub	sp, #24
341a1c70:	af02      	add	r7, sp, #8
341a1c72:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_STBY, VD6G_CMD_START_STREAM);
341a1c74:	687b      	ldr	r3, [r7, #4]
341a1c76:	691b      	ldr	r3, [r3, #16]
341a1c78:	2201      	movs	r2, #1
341a1c7a:	f240 2101 	movw	r1, #513	@ 0x201
341a1c7e:	6878      	ldr	r0, [r7, #4]
341a1c80:	4798      	blx	r3
341a1c82:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1c84:	68fb      	ldr	r3, [r7, #12]
341a1c86:	2b00      	cmp	r3, #0
341a1c88:	d008      	beq.n	341a1c9c <VD6G_StartStreaming+0x30>
341a1c8a:	68fb      	ldr	r3, [r7, #12]
341a1c8c:	9300      	str	r3, [sp, #0]
341a1c8e:	f44f 737c 	mov.w	r3, #1008	@ 0x3f0
341a1c92:	4a17      	ldr	r2, [pc, #92]	@ (341a1cf0 <VD6G_StartStreaming+0x84>)
341a1c94:	4917      	ldr	r1, [pc, #92]	@ (341a1cf4 <VD6G_StartStreaming+0x88>)
341a1c96:	6878      	ldr	r0, [r7, #4]
341a1c98:	f7fe fc85 	bl	341a05a6 <VD6G_error>
341a1c9c:	68fb      	ldr	r3, [r7, #12]
341a1c9e:	2b00      	cmp	r3, #0
341a1ca0:	d002      	beq.n	341a1ca8 <VD6G_StartStreaming+0x3c>
341a1ca2:	6878      	ldr	r0, [r7, #4]
341a1ca4:	f7fe fc9a 	bl	341a05dc <display_error>
341a1ca8:	68fb      	ldr	r3, [r7, #12]
341a1caa:	2b00      	cmp	r3, #0
341a1cac:	d001      	beq.n	341a1cb2 <VD6G_StartStreaming+0x46>
341a1cae:	68fb      	ldr	r3, [r7, #12]
341a1cb0:	e01a      	b.n	341a1ce8 <VD6G_StartStreaming+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_STBY, VD6G_CMD_ACK);
341a1cb2:	2200      	movs	r2, #0
341a1cb4:	f240 2101 	movw	r1, #513	@ 0x201
341a1cb8:	6878      	ldr	r0, [r7, #4]
341a1cba:	f7fe fcb7 	bl	341a062c <VD6G_PollReg8>
341a1cbe:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1cc0:	68fb      	ldr	r3, [r7, #12]
341a1cc2:	2b00      	cmp	r3, #0
341a1cc4:	d001      	beq.n	341a1cca <VD6G_StartStreaming+0x5e>
    return ret;
341a1cc6:	68fb      	ldr	r3, [r7, #12]
341a1cc8:	e00e      	b.n	341a1ce8 <VD6G_StartStreaming+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_STREAMING);
341a1cca:	2103      	movs	r1, #3
341a1ccc:	6878      	ldr	r0, [r7, #4]
341a1cce:	f7fe fd67 	bl	341a07a0 <VD6G_WaitState>
341a1cd2:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1cd4:	68fb      	ldr	r3, [r7, #12]
341a1cd6:	2b00      	cmp	r3, #0
341a1cd8:	d001      	beq.n	341a1cde <VD6G_StartStreaming+0x72>
    return ret;
341a1cda:	68fb      	ldr	r3, [r7, #12]
341a1cdc:	e004      	b.n	341a1ce8 <VD6G_StartStreaming+0x7c>

  VD6G_notice(ctx, "Streaming is on\n");
341a1cde:	4906      	ldr	r1, [pc, #24]	@ (341a1cf8 <VD6G_StartStreaming+0x8c>)
341a1ce0:	6878      	ldr	r0, [r7, #4]
341a1ce2:	f7fe fc2a 	bl	341a053a <VD6G_notice>

  return 0;
341a1ce6:	2300      	movs	r3, #0
}
341a1ce8:	4618      	mov	r0, r3
341a1cea:	3710      	adds	r7, #16
341a1cec:	46bd      	mov	sp, r7
341a1cee:	bd80      	pop	{r7, pc}
341a1cf0:	341ae5a4 	.word	0x341ae5a4
341a1cf4:	341a7b68 	.word	0x341a7b68
341a1cf8:	341a7d8c 	.word	0x341a7d8c

341a1cfc <VD6G_StopStreaming>:

static int VD6G_StopStreaming(VD6G_Ctx_t *ctx)
{
341a1cfc:	b580      	push	{r7, lr}
341a1cfe:	b086      	sub	sp, #24
341a1d00:	af02      	add	r7, sp, #8
341a1d02:	6078      	str	r0, [r7, #4]
  int ret;

  ret = ctx->write8(ctx, VD6G_REG_STREAMING, VD6G_CMD_STOP_STREAM);
341a1d04:	687b      	ldr	r3, [r7, #4]
341a1d06:	691b      	ldr	r3, [r3, #16]
341a1d08:	2201      	movs	r2, #1
341a1d0a:	f240 2102 	movw	r1, #514	@ 0x202
341a1d0e:	6878      	ldr	r0, [r7, #4]
341a1d10:	4798      	blx	r3
341a1d12:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a1d14:	68fb      	ldr	r3, [r7, #12]
341a1d16:	2b00      	cmp	r3, #0
341a1d18:	d008      	beq.n	341a1d2c <VD6G_StopStreaming+0x30>
341a1d1a:	68fb      	ldr	r3, [r7, #12]
341a1d1c:	9300      	str	r3, [sp, #0]
341a1d1e:	f240 4304 	movw	r3, #1028	@ 0x404
341a1d22:	4a17      	ldr	r2, [pc, #92]	@ (341a1d80 <VD6G_StopStreaming+0x84>)
341a1d24:	4917      	ldr	r1, [pc, #92]	@ (341a1d84 <VD6G_StopStreaming+0x88>)
341a1d26:	6878      	ldr	r0, [r7, #4]
341a1d28:	f7fe fc3d 	bl	341a05a6 <VD6G_error>
341a1d2c:	68fb      	ldr	r3, [r7, #12]
341a1d2e:	2b00      	cmp	r3, #0
341a1d30:	d002      	beq.n	341a1d38 <VD6G_StopStreaming+0x3c>
341a1d32:	6878      	ldr	r0, [r7, #4]
341a1d34:	f7fe fc52 	bl	341a05dc <display_error>
341a1d38:	68fb      	ldr	r3, [r7, #12]
341a1d3a:	2b00      	cmp	r3, #0
341a1d3c:	d001      	beq.n	341a1d42 <VD6G_StopStreaming+0x46>
341a1d3e:	68fb      	ldr	r3, [r7, #12]
341a1d40:	e01a      	b.n	341a1d78 <VD6G_StopStreaming+0x7c>

  ret = VD6G_PollReg8(ctx, VD6G_REG_STREAMING, VD6G_CMD_ACK);
341a1d42:	2200      	movs	r2, #0
341a1d44:	f240 2102 	movw	r1, #514	@ 0x202
341a1d48:	6878      	ldr	r0, [r7, #4]
341a1d4a:	f7fe fc6f 	bl	341a062c <VD6G_PollReg8>
341a1d4e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1d50:	68fb      	ldr	r3, [r7, #12]
341a1d52:	2b00      	cmp	r3, #0
341a1d54:	d001      	beq.n	341a1d5a <VD6G_StopStreaming+0x5e>
    return ret;
341a1d56:	68fb      	ldr	r3, [r7, #12]
341a1d58:	e00e      	b.n	341a1d78 <VD6G_StopStreaming+0x7c>

  ret = VD6G_WaitState(ctx, VD6G_SYSTEM_FSM_SW_STBY);
341a1d5a:	2102      	movs	r1, #2
341a1d5c:	6878      	ldr	r0, [r7, #4]
341a1d5e:	f7fe fd1f 	bl	341a07a0 <VD6G_WaitState>
341a1d62:	60f8      	str	r0, [r7, #12]
  if (ret)
341a1d64:	68fb      	ldr	r3, [r7, #12]
341a1d66:	2b00      	cmp	r3, #0
341a1d68:	d001      	beq.n	341a1d6e <VD6G_StopStreaming+0x72>
    return ret;
341a1d6a:	68fb      	ldr	r3, [r7, #12]
341a1d6c:	e004      	b.n	341a1d78 <VD6G_StopStreaming+0x7c>

  VD6G_notice(ctx, "Streaming is off\n");
341a1d6e:	4906      	ldr	r1, [pc, #24]	@ (341a1d88 <VD6G_StopStreaming+0x8c>)
341a1d70:	6878      	ldr	r0, [r7, #4]
341a1d72:	f7fe fbe2 	bl	341a053a <VD6G_notice>

  return 0;
341a1d76:	2300      	movs	r3, #0
}
341a1d78:	4618      	mov	r0, r3
341a1d7a:	3710      	adds	r7, #16
341a1d7c:	46bd      	mov	sp, r7
341a1d7e:	bd80      	pop	{r7, pc}
341a1d80:	341ae5b8 	.word	0x341ae5b8
341a1d84:	341a7b68 	.word	0x341a7b68
341a1d88:	341a7da0 	.word	0x341a7da0

341a1d8c <VD6G_Init>:

int VD6G_Init(VD6G_Ctx_t *ctx, VD6G_Config_t *config)
{
341a1d8c:	b5b0      	push	{r4, r5, r7, lr}
341a1d8e:	b084      	sub	sp, #16
341a1d90:	af00      	add	r7, sp, #0
341a1d92:	6078      	str	r0, [r7, #4]
341a1d94:	6039      	str	r1, [r7, #0]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1d96:	687b      	ldr	r3, [r7, #4]
341a1d98:	332c      	adds	r3, #44	@ 0x2c
341a1d9a:	60fb      	str	r3, [r7, #12]
  int ret;

  if (config->frame_rate < VD6G_MIN_FPS)
341a1d9c:	683b      	ldr	r3, [r7, #0]
341a1d9e:	689b      	ldr	r3, [r3, #8]
341a1da0:	2b00      	cmp	r3, #0
341a1da2:	dc02      	bgt.n	341a1daa <VD6G_Init+0x1e>
    return -1;
341a1da4:	f04f 33ff 	mov.w	r3, #4294967295
341a1da8:	e078      	b.n	341a1e9c <VD6G_Init+0x110>
  if (config->frame_rate > VD6G_MAX_FPS)
341a1daa:	683b      	ldr	r3, [r7, #0]
341a1dac:	689b      	ldr	r3, [r3, #8]
341a1dae:	2b58      	cmp	r3, #88	@ 0x58
341a1db0:	dd02      	ble.n	341a1db8 <VD6G_Init+0x2c>
    return -1;
341a1db2:	f04f 33ff 	mov.w	r3, #4294967295
341a1db6:	e071      	b.n	341a1e9c <VD6G_Init+0x110>

  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
341a1db8:	683b      	ldr	r3, [r7, #0]
341a1dba:	791b      	ldrb	r3, [r3, #4]
341a1dbc:	2b00      	cmp	r3, #0
341a1dbe:	d022      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_VGA_640_480) &&
341a1dc0:	683b      	ldr	r3, [r7, #0]
341a1dc2:	791b      	ldrb	r3, [r3, #4]
  if ((config->resolution != VD6G_RES_QVGA_320_240) &&
341a1dc4:	2b01      	cmp	r3, #1
341a1dc6:	d01e      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_VGA_PORTRAIT_480_640) &&
341a1dc8:	683b      	ldr	r3, [r7, #0]
341a1dca:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_VGA_640_480) &&
341a1dcc:	2b02      	cmp	r3, #2
341a1dce:	d01a      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_XGA_1024_768) &&
341a1dd0:	683b      	ldr	r3, [r7, #0]
341a1dd2:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_VGA_PORTRAIT_480_640) &&
341a1dd4:	2b03      	cmp	r3, #3
341a1dd6:	d016      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_XGA_PORTRAIT_768_1024) &&
341a1dd8:	683b      	ldr	r3, [r7, #0]
341a1dda:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_XGA_1024_768) &&
341a1ddc:	2b04      	cmp	r3, #4
341a1dde:	d012      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_720P_PORTRAIT_720_1280) &&
341a1de0:	683b      	ldr	r3, [r7, #0]
341a1de2:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_XGA_PORTRAIT_768_1024) &&
341a1de4:	2b05      	cmp	r3, #5
341a1de6:	d00e      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_SXGA_PORTRAIT_1024_1280) &&
341a1de8:	683b      	ldr	r3, [r7, #0]
341a1dea:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_720P_PORTRAIT_720_1280) &&
341a1dec:	2b06      	cmp	r3, #6
341a1dee:	d00a      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_PORTRAIT_1120_720) &&
341a1df0:	683b      	ldr	r3, [r7, #0]
341a1df2:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_SXGA_PORTRAIT_1024_1280) &&
341a1df4:	2b07      	cmp	r3, #7
341a1df6:	d006      	beq.n	341a1e06 <VD6G_Init+0x7a>
      (config->resolution != VD6G_RES_FULL_1120_1364)) {
341a1df8:	683b      	ldr	r3, [r7, #0]
341a1dfa:	791b      	ldrb	r3, [r3, #4]
      (config->resolution != VD6G_RES_PORTRAIT_1120_720) &&
341a1dfc:	2b08      	cmp	r3, #8
341a1dfe:	d002      	beq.n	341a1e06 <VD6G_Init+0x7a>
    return -1;
341a1e00:	f04f 33ff 	mov.w	r3, #4294967295
341a1e04:	e04a      	b.n	341a1e9c <VD6G_Init+0x110>
  }

  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
341a1e06:	683b      	ldr	r3, [r7, #0]
341a1e08:	7b1b      	ldrb	r3, [r3, #12]
341a1e0a:	2b00      	cmp	r3, #0
341a1e0c:	d00e      	beq.n	341a1e2c <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_FLIP) &&
341a1e0e:	683b      	ldr	r3, [r7, #0]
341a1e10:	7b1b      	ldrb	r3, [r3, #12]
  if ((config->flip_mirror_mode != VD6G_MIRROR_FLIP_NONE) &&
341a1e12:	2b01      	cmp	r3, #1
341a1e14:	d00a      	beq.n	341a1e2c <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_MIRROR) &&
341a1e16:	683b      	ldr	r3, [r7, #0]
341a1e18:	7b1b      	ldrb	r3, [r3, #12]
      (config->flip_mirror_mode != VD6G_FLIP) &&
341a1e1a:	2b02      	cmp	r3, #2
341a1e1c:	d006      	beq.n	341a1e2c <VD6G_Init+0xa0>
      (config->flip_mirror_mode != VD6G_MIRROR_FLIP)) {
341a1e1e:	683b      	ldr	r3, [r7, #0]
341a1e20:	7b1b      	ldrb	r3, [r3, #12]
      (config->flip_mirror_mode != VD6G_MIRROR) &&
341a1e22:	2b03      	cmp	r3, #3
341a1e24:	d002      	beq.n	341a1e2c <VD6G_Init+0xa0>
    return -1;
341a1e26:	f04f 33ff 	mov.w	r3, #4294967295
341a1e2a:	e037      	b.n	341a1e9c <VD6G_Init+0x110>
  }

  ctx->shutdown_pin(ctx, 0);
341a1e2c:	687b      	ldr	r3, [r7, #4]
341a1e2e:	681b      	ldr	r3, [r3, #0]
341a1e30:	2100      	movs	r1, #0
341a1e32:	6878      	ldr	r0, [r7, #4]
341a1e34:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a1e36:	687b      	ldr	r3, [r7, #4]
341a1e38:	6a1b      	ldr	r3, [r3, #32]
341a1e3a:	210a      	movs	r1, #10
341a1e3c:	6878      	ldr	r0, [r7, #4]
341a1e3e:	4798      	blx	r3
  ctx->shutdown_pin(ctx, 1);
341a1e40:	687b      	ldr	r3, [r7, #4]
341a1e42:	681b      	ldr	r3, [r3, #0]
341a1e44:	2101      	movs	r1, #1
341a1e46:	6878      	ldr	r0, [r7, #4]
341a1e48:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a1e4a:	687b      	ldr	r3, [r7, #4]
341a1e4c:	6a1b      	ldr	r3, [r3, #32]
341a1e4e:	210a      	movs	r1, #10
341a1e50:	6878      	ldr	r0, [r7, #4]
341a1e52:	4798      	blx	r3

  drv_ctx->config_save = *config;
341a1e54:	68fb      	ldr	r3, [r7, #12]
341a1e56:	683a      	ldr	r2, [r7, #0]
341a1e58:	1d1c      	adds	r4, r3, #4
341a1e5a:	4615      	mov	r5, r2
341a1e5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a1e5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a1e60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a1e62:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a1e64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a1e66:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a1e68:	e895 0003 	ldmia.w	r5, {r0, r1}
341a1e6c:	e884 0003 	stmia.w	r4, {r0, r1}
  drv_ctx->is_streaming = 0;
341a1e70:	68fb      	ldr	r3, [r7, #12]
341a1e72:	2200      	movs	r2, #0
341a1e74:	601a      	str	r2, [r3, #0]

  ret = VD6G_Boot(ctx);
341a1e76:	6878      	ldr	r0, [r7, #4]
341a1e78:	f7ff f96e 	bl	341a1158 <VD6G_Boot>
341a1e7c:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1e7e:	68bb      	ldr	r3, [r7, #8]
341a1e80:	2b00      	cmp	r3, #0
341a1e82:	d001      	beq.n	341a1e88 <VD6G_Init+0xfc>
    return ret;
341a1e84:	68bb      	ldr	r3, [r7, #8]
341a1e86:	e009      	b.n	341a1e9c <VD6G_Init+0x110>

  ret = VD6G_SetupEarly(ctx);
341a1e88:	6878      	ldr	r0, [r7, #4]
341a1e8a:	f7ff fe95 	bl	341a1bb8 <VD6G_SetupEarly>
341a1e8e:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1e90:	68bb      	ldr	r3, [r7, #8]
341a1e92:	2b00      	cmp	r3, #0
341a1e94:	d001      	beq.n	341a1e9a <VD6G_Init+0x10e>
    return ret;
341a1e96:	68bb      	ldr	r3, [r7, #8]
341a1e98:	e000      	b.n	341a1e9c <VD6G_Init+0x110>

  return 0;
341a1e9a:	2300      	movs	r3, #0
}
341a1e9c:	4618      	mov	r0, r3
341a1e9e:	3710      	adds	r7, #16
341a1ea0:	46bd      	mov	sp, r7
341a1ea2:	bdb0      	pop	{r4, r5, r7, pc}

341a1ea4 <VD6G_DeInit>:

int VD6G_DeInit(VD6G_Ctx_t *ctx)
{
341a1ea4:	b580      	push	{r7, lr}
341a1ea6:	b084      	sub	sp, #16
341a1ea8:	af00      	add	r7, sp, #0
341a1eaa:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1eac:	687b      	ldr	r3, [r7, #4]
341a1eae:	332c      	adds	r3, #44	@ 0x2c
341a1eb0:	60fb      	str	r3, [r7, #12]

  if (drv_ctx->is_streaming)
341a1eb2:	68fb      	ldr	r3, [r7, #12]
341a1eb4:	681b      	ldr	r3, [r3, #0]
341a1eb6:	2b00      	cmp	r3, #0
341a1eb8:	d002      	beq.n	341a1ec0 <VD6G_DeInit+0x1c>
    return -1;
341a1eba:	f04f 33ff 	mov.w	r3, #4294967295
341a1ebe:	e00a      	b.n	341a1ed6 <VD6G_DeInit+0x32>

  ctx->shutdown_pin(ctx, 0);
341a1ec0:	687b      	ldr	r3, [r7, #4]
341a1ec2:	681b      	ldr	r3, [r3, #0]
341a1ec4:	2100      	movs	r1, #0
341a1ec6:	6878      	ldr	r0, [r7, #4]
341a1ec8:	4798      	blx	r3
  ctx->delay(ctx, 10);
341a1eca:	687b      	ldr	r3, [r7, #4]
341a1ecc:	6a1b      	ldr	r3, [r3, #32]
341a1ece:	210a      	movs	r1, #10
341a1ed0:	6878      	ldr	r0, [r7, #4]
341a1ed2:	4798      	blx	r3

  return 0;
341a1ed4:	2300      	movs	r3, #0
}
341a1ed6:	4618      	mov	r0, r3
341a1ed8:	3710      	adds	r7, #16
341a1eda:	46bd      	mov	sp, r7
341a1edc:	bd80      	pop	{r7, pc}

341a1ede <VD6G_Start>:

int VD6G_Start(VD6G_Ctx_t *ctx)
{
341a1ede:	b580      	push	{r7, lr}
341a1ee0:	b084      	sub	sp, #16
341a1ee2:	af00      	add	r7, sp, #0
341a1ee4:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1ee6:	687b      	ldr	r3, [r7, #4]
341a1ee8:	332c      	adds	r3, #44	@ 0x2c
341a1eea:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_Setup(ctx);
341a1eec:	6878      	ldr	r0, [r7, #4]
341a1eee:	f7ff fe7e 	bl	341a1bee <VD6G_Setup>
341a1ef2:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1ef4:	68bb      	ldr	r3, [r7, #8]
341a1ef6:	2b00      	cmp	r3, #0
341a1ef8:	d001      	beq.n	341a1efe <VD6G_Start+0x20>
    return ret;
341a1efa:	68bb      	ldr	r3, [r7, #8]
341a1efc:	e00c      	b.n	341a1f18 <VD6G_Start+0x3a>

  ret = VD6G_StartStreaming(ctx);
341a1efe:	6878      	ldr	r0, [r7, #4]
341a1f00:	f7ff feb4 	bl	341a1c6c <VD6G_StartStreaming>
341a1f04:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1f06:	68bb      	ldr	r3, [r7, #8]
341a1f08:	2b00      	cmp	r3, #0
341a1f0a:	d001      	beq.n	341a1f10 <VD6G_Start+0x32>
    return ret;
341a1f0c:	68bb      	ldr	r3, [r7, #8]
341a1f0e:	e003      	b.n	341a1f18 <VD6G_Start+0x3a>
  drv_ctx->is_streaming = 1;
341a1f10:	68fb      	ldr	r3, [r7, #12]
341a1f12:	2201      	movs	r2, #1
341a1f14:	601a      	str	r2, [r3, #0]

  return 0;
341a1f16:	2300      	movs	r3, #0
}
341a1f18:	4618      	mov	r0, r3
341a1f1a:	3710      	adds	r7, #16
341a1f1c:	46bd      	mov	sp, r7
341a1f1e:	bd80      	pop	{r7, pc}

341a1f20 <VD6G_Stop>:

int VD6G_Stop(VD6G_Ctx_t *ctx)
{
341a1f20:	b580      	push	{r7, lr}
341a1f22:	b084      	sub	sp, #16
341a1f24:	af00      	add	r7, sp, #0
341a1f26:	6078      	str	r0, [r7, #4]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1f28:	687b      	ldr	r3, [r7, #4]
341a1f2a:	332c      	adds	r3, #44	@ 0x2c
341a1f2c:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_StopStreaming(ctx);
341a1f2e:	6878      	ldr	r0, [r7, #4]
341a1f30:	f7ff fee4 	bl	341a1cfc <VD6G_StopStreaming>
341a1f34:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1f36:	68bb      	ldr	r3, [r7, #8]
341a1f38:	2b00      	cmp	r3, #0
341a1f3a:	d001      	beq.n	341a1f40 <VD6G_Stop+0x20>
    return ret;
341a1f3c:	68bb      	ldr	r3, [r7, #8]
341a1f3e:	e003      	b.n	341a1f48 <VD6G_Stop+0x28>
  drv_ctx->is_streaming = 0;
341a1f40:	68fb      	ldr	r3, [r7, #12]
341a1f42:	2200      	movs	r2, #0
341a1f44:	601a      	str	r2, [r3, #0]

  return 0;
341a1f46:	2300      	movs	r3, #0
}
341a1f48:	4618      	mov	r0, r3
341a1f4a:	3710      	adds	r7, #16
341a1f4c:	46bd      	mov	sp, r7
341a1f4e:	bd80      	pop	{r7, pc}

341a1f50 <VD6G_SetExposureMode>:

  return 0;
}

int VD6G_SetExposureMode(VD6G_Ctx_t *ctx, VD6G_ExposureMode_t mode)
{
341a1f50:	b580      	push	{r7, lr}
341a1f52:	b084      	sub	sp, #16
341a1f54:	af00      	add	r7, sp, #0
341a1f56:	6078      	str	r0, [r7, #4]
341a1f58:	460b      	mov	r3, r1
341a1f5a:	70fb      	strb	r3, [r7, #3]
  struct drv_vd6g_ctx *drv_ctx = &ctx->ctx;
341a1f5c:	687b      	ldr	r3, [r7, #4]
341a1f5e:	332c      	adds	r3, #44	@ 0x2c
341a1f60:	60fb      	str	r3, [r7, #12]
  int ret;

  ret = VD6G_SetExposureModeInternal(ctx, mode);
341a1f62:	78fb      	ldrb	r3, [r7, #3]
341a1f64:	4619      	mov	r1, r3
341a1f66:	6878      	ldr	r0, [r7, #4]
341a1f68:	f7ff f87c 	bl	341a1064 <VD6G_SetExposureModeInternal>
341a1f6c:	60b8      	str	r0, [r7, #8]
  if (ret)
341a1f6e:	68bb      	ldr	r3, [r7, #8]
341a1f70:	2b00      	cmp	r3, #0
341a1f72:	d001      	beq.n	341a1f78 <VD6G_SetExposureMode+0x28>
    return ret;
341a1f74:	68bb      	ldr	r3, [r7, #8]
341a1f76:	e004      	b.n	341a1f82 <VD6G_SetExposureMode+0x32>

  drv_ctx->config_save.exposure_mode = mode;
341a1f78:	68fb      	ldr	r3, [r7, #12]
341a1f7a:	78fa      	ldrb	r2, [r7, #3]
341a1f7c:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return 0;
341a1f80:	2300      	movs	r3, #0
}
341a1f82:	4618      	mov	r0, r3
341a1f84:	3710      	adds	r7, #16
341a1f86:	46bd      	mov	sp, r7
341a1f88:	bd80      	pop	{r7, pc}
	...

341a1f8c <VD6G_GetAnalogGainRegRange>:

int VD6G_GetAnalogGainRegRange(VD6G_Ctx_t *ctx, uint8_t *AGmin, uint8_t *AGmax)
{
341a1f8c:	b580      	push	{r7, lr}
341a1f8e:	b088      	sub	sp, #32
341a1f90:	af02      	add	r7, sp, #8
341a1f92:	60f8      	str	r0, [r7, #12]
341a1f94:	60b9      	str	r1, [r7, #8]
341a1f96:	607a      	str	r2, [r7, #4]
  int ret;
  uint8_t value;

  if ((AGmin == NULL) || (AGmax == NULL))
341a1f98:	68bb      	ldr	r3, [r7, #8]
341a1f9a:	2b00      	cmp	r3, #0
341a1f9c:	d002      	beq.n	341a1fa4 <VD6G_GetAnalogGainRegRange+0x18>
341a1f9e:	687b      	ldr	r3, [r7, #4]
341a1fa0:	2b00      	cmp	r3, #0
341a1fa2:	d102      	bne.n	341a1faa <VD6G_GetAnalogGainRegRange+0x1e>
    return -1;
341a1fa4:	f04f 33ff 	mov.w	r3, #4294967295
341a1fa8:	e04c      	b.n	341a2044 <VD6G_GetAnalogGainRegRange+0xb8>

  ret = ctx->read8(ctx, VD6G_REG_MIN_AG_CODED, &value);
341a1faa:	68fb      	ldr	r3, [r7, #12]
341a1fac:	685b      	ldr	r3, [r3, #4]
341a1fae:	f107 0213 	add.w	r2, r7, #19
341a1fb2:	f640 117e 	movw	r1, #2430	@ 0x97e
341a1fb6:	68f8      	ldr	r0, [r7, #12]
341a1fb8:	4798      	blx	r3
341a1fba:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a1fbc:	697b      	ldr	r3, [r7, #20]
341a1fbe:	2b00      	cmp	r3, #0
341a1fc0:	d008      	beq.n	341a1fd4 <VD6G_GetAnalogGainRegRange+0x48>
341a1fc2:	697b      	ldr	r3, [r7, #20]
341a1fc4:	9300      	str	r3, [sp, #0]
341a1fc6:	f44f 6399 	mov.w	r3, #1224	@ 0x4c8
341a1fca:	4a20      	ldr	r2, [pc, #128]	@ (341a204c <VD6G_GetAnalogGainRegRange+0xc0>)
341a1fcc:	4920      	ldr	r1, [pc, #128]	@ (341a2050 <VD6G_GetAnalogGainRegRange+0xc4>)
341a1fce:	68f8      	ldr	r0, [r7, #12]
341a1fd0:	f7fe fae9 	bl	341a05a6 <VD6G_error>
341a1fd4:	697b      	ldr	r3, [r7, #20]
341a1fd6:	2b00      	cmp	r3, #0
341a1fd8:	d002      	beq.n	341a1fe0 <VD6G_GetAnalogGainRegRange+0x54>
341a1fda:	68f8      	ldr	r0, [r7, #12]
341a1fdc:	f7fe fafe 	bl	341a05dc <display_error>
341a1fe0:	697b      	ldr	r3, [r7, #20]
341a1fe2:	2b00      	cmp	r3, #0
341a1fe4:	d001      	beq.n	341a1fea <VD6G_GetAnalogGainRegRange+0x5e>
341a1fe6:	697b      	ldr	r3, [r7, #20]
341a1fe8:	e02c      	b.n	341a2044 <VD6G_GetAnalogGainRegRange+0xb8>
  *AGmin = value & VD6G_REG_MIN_AG_CODED_MASK;
341a1fea:	7cfb      	ldrb	r3, [r7, #19]
341a1fec:	f003 031f 	and.w	r3, r3, #31
341a1ff0:	b2da      	uxtb	r2, r3
341a1ff2:	68bb      	ldr	r3, [r7, #8]
341a1ff4:	701a      	strb	r2, [r3, #0]

  ret = ctx->read8(ctx, VD6G_REG_MAX_AG_CODED, &value);
341a1ff6:	68fb      	ldr	r3, [r7, #12]
341a1ff8:	685b      	ldr	r3, [r3, #4]
341a1ffa:	f107 0213 	add.w	r2, r7, #19
341a1ffe:	f44f 6116 	mov.w	r1, #2400	@ 0x960
341a2002:	68f8      	ldr	r0, [r7, #12]
341a2004:	4798      	blx	r3
341a2006:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a2008:	697b      	ldr	r3, [r7, #20]
341a200a:	2b00      	cmp	r3, #0
341a200c:	d008      	beq.n	341a2020 <VD6G_GetAnalogGainRegRange+0x94>
341a200e:	697b      	ldr	r3, [r7, #20]
341a2010:	9300      	str	r3, [sp, #0]
341a2012:	f240 43cc 	movw	r3, #1228	@ 0x4cc
341a2016:	4a0d      	ldr	r2, [pc, #52]	@ (341a204c <VD6G_GetAnalogGainRegRange+0xc0>)
341a2018:	490d      	ldr	r1, [pc, #52]	@ (341a2050 <VD6G_GetAnalogGainRegRange+0xc4>)
341a201a:	68f8      	ldr	r0, [r7, #12]
341a201c:	f7fe fac3 	bl	341a05a6 <VD6G_error>
341a2020:	697b      	ldr	r3, [r7, #20]
341a2022:	2b00      	cmp	r3, #0
341a2024:	d002      	beq.n	341a202c <VD6G_GetAnalogGainRegRange+0xa0>
341a2026:	68f8      	ldr	r0, [r7, #12]
341a2028:	f7fe fad8 	bl	341a05dc <display_error>
341a202c:	697b      	ldr	r3, [r7, #20]
341a202e:	2b00      	cmp	r3, #0
341a2030:	d001      	beq.n	341a2036 <VD6G_GetAnalogGainRegRange+0xaa>
341a2032:	697b      	ldr	r3, [r7, #20]
341a2034:	e006      	b.n	341a2044 <VD6G_GetAnalogGainRegRange+0xb8>
  *AGmax = value & VD6G_REG_MAX_AG_CODED_MASK;
341a2036:	7cfb      	ldrb	r3, [r7, #19]
341a2038:	f003 031f 	and.w	r3, r3, #31
341a203c:	b2da      	uxtb	r2, r3
341a203e:	687b      	ldr	r3, [r7, #4]
341a2040:	701a      	strb	r2, [r3, #0]

  return 0;
341a2042:	2300      	movs	r3, #0
}
341a2044:	4618      	mov	r0, r3
341a2046:	3718      	adds	r7, #24
341a2048:	46bd      	mov	sp, r7
341a204a:	bd80      	pop	{r7, pc}
341a204c:	341ae5cc 	.word	0x341ae5cc
341a2050:	341a7b68 	.word	0x341a7b68

341a2054 <VD6G_SetAnalogGain>:

int VD6G_SetAnalogGain(VD6G_Ctx_t *ctx, int gain)
{
341a2054:	b580      	push	{r7, lr}
341a2056:	b086      	sub	sp, #24
341a2058:	af02      	add	r7, sp, #8
341a205a:	6078      	str	r0, [r7, #4]
341a205c:	6039      	str	r1, [r7, #0]
  int ret;
  uint8_t again_regmin, again_regmax;

  ret = VD6G_GetAnalogGainRegRange(ctx, &again_regmin, &again_regmax);
341a205e:	f107 020a 	add.w	r2, r7, #10
341a2062:	f107 030b 	add.w	r3, r7, #11
341a2066:	4619      	mov	r1, r3
341a2068:	6878      	ldr	r0, [r7, #4]
341a206a:	f7ff ff8f 	bl	341a1f8c <VD6G_GetAnalogGainRegRange>
341a206e:	60f8      	str	r0, [r7, #12]
  if (ret)
341a2070:	68fb      	ldr	r3, [r7, #12]
341a2072:	2b00      	cmp	r3, #0
341a2074:	d001      	beq.n	341a207a <VD6G_SetAnalogGain+0x26>
    return ret;
341a2076:	68fb      	ldr	r3, [r7, #12]
341a2078:	e034      	b.n	341a20e4 <VD6G_SetAnalogGain+0x90>

  ret = CHECK_RANGE(gain, again_regmin, again_regmax);
341a207a:	7afb      	ldrb	r3, [r7, #11]
341a207c:	461a      	mov	r2, r3
341a207e:	683b      	ldr	r3, [r7, #0]
341a2080:	4293      	cmp	r3, r2
341a2082:	db06      	blt.n	341a2092 <VD6G_SetAnalogGain+0x3e>
341a2084:	7abb      	ldrb	r3, [r7, #10]
341a2086:	461a      	mov	r2, r3
341a2088:	683b      	ldr	r3, [r7, #0]
341a208a:	4293      	cmp	r3, r2
341a208c:	dc01      	bgt.n	341a2092 <VD6G_SetAnalogGain+0x3e>
341a208e:	2300      	movs	r3, #0
341a2090:	e001      	b.n	341a2096 <VD6G_SetAnalogGain+0x42>
341a2092:	f04f 33ff 	mov.w	r3, #4294967295
341a2096:	60fb      	str	r3, [r7, #12]
  if (ret)
341a2098:	68fb      	ldr	r3, [r7, #12]
341a209a:	2b00      	cmp	r3, #0
341a209c:	d001      	beq.n	341a20a2 <VD6G_SetAnalogGain+0x4e>
    return ret;
341a209e:	68fb      	ldr	r3, [r7, #12]
341a20a0:	e020      	b.n	341a20e4 <VD6G_SetAnalogGain+0x90>

  ret = ctx->write8(ctx, VD6G_REG_MANUAL_ANALOG_GAIN, gain);
341a20a2:	687b      	ldr	r3, [r7, #4]
341a20a4:	691b      	ldr	r3, [r3, #16]
341a20a6:	683a      	ldr	r2, [r7, #0]
341a20a8:	b2d2      	uxtb	r2, r2
341a20aa:	f240 414d 	movw	r1, #1101	@ 0x44d
341a20ae:	6878      	ldr	r0, [r7, #4]
341a20b0:	4798      	blx	r3
341a20b2:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a20b4:	68fb      	ldr	r3, [r7, #12]
341a20b6:	2b00      	cmp	r3, #0
341a20b8:	d008      	beq.n	341a20cc <VD6G_SetAnalogGain+0x78>
341a20ba:	68fb      	ldr	r3, [r7, #12]
341a20bc:	9300      	str	r3, [sp, #0]
341a20be:	f44f 639c 	mov.w	r3, #1248	@ 0x4e0
341a20c2:	4a0a      	ldr	r2, [pc, #40]	@ (341a20ec <VD6G_SetAnalogGain+0x98>)
341a20c4:	490a      	ldr	r1, [pc, #40]	@ (341a20f0 <VD6G_SetAnalogGain+0x9c>)
341a20c6:	6878      	ldr	r0, [r7, #4]
341a20c8:	f7fe fa6d 	bl	341a05a6 <VD6G_error>
341a20cc:	68fb      	ldr	r3, [r7, #12]
341a20ce:	2b00      	cmp	r3, #0
341a20d0:	d002      	beq.n	341a20d8 <VD6G_SetAnalogGain+0x84>
341a20d2:	6878      	ldr	r0, [r7, #4]
341a20d4:	f7fe fa82 	bl	341a05dc <display_error>
341a20d8:	68fb      	ldr	r3, [r7, #12]
341a20da:	2b00      	cmp	r3, #0
341a20dc:	d001      	beq.n	341a20e2 <VD6G_SetAnalogGain+0x8e>
341a20de:	68fb      	ldr	r3, [r7, #12]
341a20e0:	e000      	b.n	341a20e4 <VD6G_SetAnalogGain+0x90>

  return 0;
341a20e2:	2300      	movs	r3, #0
}
341a20e4:	4618      	mov	r0, r3
341a20e6:	3710      	adds	r7, #16
341a20e8:	46bd      	mov	sp, r7
341a20ea:	bd80      	pop	{r7, pc}
341a20ec:	341ae5e8 	.word	0x341ae5e8
341a20f0:	341a7b68 	.word	0x341a7b68

341a20f4 <VD6G_GetDigitalGainRegRange>:

int VD6G_GetDigitalGainRegRange(VD6G_Ctx_t *ctx, uint16_t *DGmin, uint16_t *DGmax)
{
341a20f4:	b580      	push	{r7, lr}
341a20f6:	b088      	sub	sp, #32
341a20f8:	af02      	add	r7, sp, #8
341a20fa:	60f8      	str	r0, [r7, #12]
341a20fc:	60b9      	str	r1, [r7, #8]
341a20fe:	607a      	str	r2, [r7, #4]
  int ret;

  if ((DGmin == NULL) && (DGmax == NULL))
341a2100:	68bb      	ldr	r3, [r7, #8]
341a2102:	2b00      	cmp	r3, #0
341a2104:	d105      	bne.n	341a2112 <VD6G_GetDigitalGainRegRange+0x1e>
341a2106:	687b      	ldr	r3, [r7, #4]
341a2108:	2b00      	cmp	r3, #0
341a210a:	d102      	bne.n	341a2112 <VD6G_GetDigitalGainRegRange+0x1e>
    return -1;
341a210c:	f04f 33ff 	mov.w	r3, #4294967295
341a2110:	e03e      	b.n	341a2190 <VD6G_GetDigitalGainRegRange+0x9c>

  ret = ctx->read16(ctx, VD6G_REG_MIN_DG, DGmin);
341a2112:	68fb      	ldr	r3, [r7, #12]
341a2114:	689b      	ldr	r3, [r3, #8]
341a2116:	68ba      	ldr	r2, [r7, #8]
341a2118:	f640 117c 	movw	r1, #2428	@ 0x97c
341a211c:	68f8      	ldr	r0, [r7, #12]
341a211e:	4798      	blx	r3
341a2120:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a2122:	697b      	ldr	r3, [r7, #20]
341a2124:	2b00      	cmp	r3, #0
341a2126:	d008      	beq.n	341a213a <VD6G_GetDigitalGainRegRange+0x46>
341a2128:	697b      	ldr	r3, [r7, #20]
341a212a:	9300      	str	r3, [sp, #0]
341a212c:	f240 43ed 	movw	r3, #1261	@ 0x4ed
341a2130:	4a19      	ldr	r2, [pc, #100]	@ (341a2198 <VD6G_GetDigitalGainRegRange+0xa4>)
341a2132:	491a      	ldr	r1, [pc, #104]	@ (341a219c <VD6G_GetDigitalGainRegRange+0xa8>)
341a2134:	68f8      	ldr	r0, [r7, #12]
341a2136:	f7fe fa36 	bl	341a05a6 <VD6G_error>
341a213a:	697b      	ldr	r3, [r7, #20]
341a213c:	2b00      	cmp	r3, #0
341a213e:	d002      	beq.n	341a2146 <VD6G_GetDigitalGainRegRange+0x52>
341a2140:	68f8      	ldr	r0, [r7, #12]
341a2142:	f7fe fa4b 	bl	341a05dc <display_error>
341a2146:	697b      	ldr	r3, [r7, #20]
341a2148:	2b00      	cmp	r3, #0
341a214a:	d001      	beq.n	341a2150 <VD6G_GetDigitalGainRegRange+0x5c>
341a214c:	697b      	ldr	r3, [r7, #20]
341a214e:	e01f      	b.n	341a2190 <VD6G_GetDigitalGainRegRange+0x9c>

  ret = ctx->read16(ctx, VD6G_REG_MAX_DG, DGmax);
341a2150:	68fb      	ldr	r3, [r7, #12]
341a2152:	689b      	ldr	r3, [r3, #8]
341a2154:	687a      	ldr	r2, [r7, #4]
341a2156:	f640 115e 	movw	r1, #2398	@ 0x95e
341a215a:	68f8      	ldr	r0, [r7, #12]
341a215c:	4798      	blx	r3
341a215e:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a2160:	697b      	ldr	r3, [r7, #20]
341a2162:	2b00      	cmp	r3, #0
341a2164:	d008      	beq.n	341a2178 <VD6G_GetDigitalGainRegRange+0x84>
341a2166:	697b      	ldr	r3, [r7, #20]
341a2168:	9300      	str	r3, [sp, #0]
341a216a:	f44f 639e 	mov.w	r3, #1264	@ 0x4f0
341a216e:	4a0a      	ldr	r2, [pc, #40]	@ (341a2198 <VD6G_GetDigitalGainRegRange+0xa4>)
341a2170:	490a      	ldr	r1, [pc, #40]	@ (341a219c <VD6G_GetDigitalGainRegRange+0xa8>)
341a2172:	68f8      	ldr	r0, [r7, #12]
341a2174:	f7fe fa17 	bl	341a05a6 <VD6G_error>
341a2178:	697b      	ldr	r3, [r7, #20]
341a217a:	2b00      	cmp	r3, #0
341a217c:	d002      	beq.n	341a2184 <VD6G_GetDigitalGainRegRange+0x90>
341a217e:	68f8      	ldr	r0, [r7, #12]
341a2180:	f7fe fa2c 	bl	341a05dc <display_error>
341a2184:	697b      	ldr	r3, [r7, #20]
341a2186:	2b00      	cmp	r3, #0
341a2188:	d001      	beq.n	341a218e <VD6G_GetDigitalGainRegRange+0x9a>
341a218a:	697b      	ldr	r3, [r7, #20]
341a218c:	e000      	b.n	341a2190 <VD6G_GetDigitalGainRegRange+0x9c>

  return 0;
341a218e:	2300      	movs	r3, #0
}
341a2190:	4618      	mov	r0, r3
341a2192:	3718      	adds	r7, #24
341a2194:	46bd      	mov	sp, r7
341a2196:	bd80      	pop	{r7, pc}
341a2198:	341ae5fc 	.word	0x341ae5fc
341a219c:	341a7b68 	.word	0x341a7b68

341a21a0 <VD6G_SetDigitalGain>:

int VD6G_SetDigitalGain(VD6G_Ctx_t *ctx, int gain)
{
341a21a0:	b580      	push	{r7, lr}
341a21a2:	b086      	sub	sp, #24
341a21a4:	af02      	add	r7, sp, #8
341a21a6:	6078      	str	r0, [r7, #4]
341a21a8:	6039      	str	r1, [r7, #0]
  int ret;
  uint16_t dgain_regmin, dgain_regmax;

  ret = VD6G_GetDigitalGainRegRange(ctx, &dgain_regmin, &dgain_regmax);
341a21aa:	f107 0208 	add.w	r2, r7, #8
341a21ae:	f107 030a 	add.w	r3, r7, #10
341a21b2:	4619      	mov	r1, r3
341a21b4:	6878      	ldr	r0, [r7, #4]
341a21b6:	f7ff ff9d 	bl	341a20f4 <VD6G_GetDigitalGainRegRange>
341a21ba:	60f8      	str	r0, [r7, #12]
  if (ret)
341a21bc:	68fb      	ldr	r3, [r7, #12]
341a21be:	2b00      	cmp	r3, #0
341a21c0:	d001      	beq.n	341a21c6 <VD6G_SetDigitalGain+0x26>
    return ret;
341a21c2:	68fb      	ldr	r3, [r7, #12]
341a21c4:	e094      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  ret = CHECK_RANGE(gain, dgain_regmin, dgain_regmax);
341a21c6:	897b      	ldrh	r3, [r7, #10]
341a21c8:	461a      	mov	r2, r3
341a21ca:	683b      	ldr	r3, [r7, #0]
341a21cc:	4293      	cmp	r3, r2
341a21ce:	db06      	blt.n	341a21de <VD6G_SetDigitalGain+0x3e>
341a21d0:	893b      	ldrh	r3, [r7, #8]
341a21d2:	461a      	mov	r2, r3
341a21d4:	683b      	ldr	r3, [r7, #0]
341a21d6:	4293      	cmp	r3, r2
341a21d8:	dc01      	bgt.n	341a21de <VD6G_SetDigitalGain+0x3e>
341a21da:	2300      	movs	r3, #0
341a21dc:	e001      	b.n	341a21e2 <VD6G_SetDigitalGain+0x42>
341a21de:	f04f 33ff 	mov.w	r3, #4294967295
341a21e2:	60fb      	str	r3, [r7, #12]
  if (ret)
341a21e4:	68fb      	ldr	r3, [r7, #12]
341a21e6:	2b00      	cmp	r3, #0
341a21e8:	d001      	beq.n	341a21ee <VD6G_SetDigitalGain+0x4e>
    return ret;
341a21ea:	68fb      	ldr	r3, [r7, #12]
341a21ec:	e080      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH0_DIGITAL_GAIN, gain);
341a21ee:	687b      	ldr	r3, [r7, #4]
341a21f0:	695b      	ldr	r3, [r3, #20]
341a21f2:	683a      	ldr	r2, [r7, #0]
341a21f4:	b292      	uxth	r2, r2
341a21f6:	f44f 618a 	mov.w	r1, #1104	@ 0x450
341a21fa:	6878      	ldr	r0, [r7, #4]
341a21fc:	4798      	blx	r3
341a21fe:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a2200:	68fb      	ldr	r3, [r7, #12]
341a2202:	2b00      	cmp	r3, #0
341a2204:	d008      	beq.n	341a2218 <VD6G_SetDigitalGain+0x78>
341a2206:	68fb      	ldr	r3, [r7, #12]
341a2208:	9300      	str	r3, [sp, #0]
341a220a:	f240 5303 	movw	r3, #1283	@ 0x503
341a220e:	4a3a      	ldr	r2, [pc, #232]	@ (341a22f8 <VD6G_SetDigitalGain+0x158>)
341a2210:	493a      	ldr	r1, [pc, #232]	@ (341a22fc <VD6G_SetDigitalGain+0x15c>)
341a2212:	6878      	ldr	r0, [r7, #4]
341a2214:	f7fe f9c7 	bl	341a05a6 <VD6G_error>
341a2218:	68fb      	ldr	r3, [r7, #12]
341a221a:	2b00      	cmp	r3, #0
341a221c:	d002      	beq.n	341a2224 <VD6G_SetDigitalGain+0x84>
341a221e:	6878      	ldr	r0, [r7, #4]
341a2220:	f7fe f9dc 	bl	341a05dc <display_error>
341a2224:	68fb      	ldr	r3, [r7, #12]
341a2226:	2b00      	cmp	r3, #0
341a2228:	d001      	beq.n	341a222e <VD6G_SetDigitalGain+0x8e>
341a222a:	68fb      	ldr	r3, [r7, #12]
341a222c:	e060      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH1_DIGITAL_GAIN, gain);
341a222e:	687b      	ldr	r3, [r7, #4]
341a2230:	695b      	ldr	r3, [r3, #20]
341a2232:	683a      	ldr	r2, [r7, #0]
341a2234:	b292      	uxth	r2, r2
341a2236:	f240 4152 	movw	r1, #1106	@ 0x452
341a223a:	6878      	ldr	r0, [r7, #4]
341a223c:	4798      	blx	r3
341a223e:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a2240:	68fb      	ldr	r3, [r7, #12]
341a2242:	2b00      	cmp	r3, #0
341a2244:	d008      	beq.n	341a2258 <VD6G_SetDigitalGain+0xb8>
341a2246:	68fb      	ldr	r3, [r7, #12]
341a2248:	9300      	str	r3, [sp, #0]
341a224a:	f240 5306 	movw	r3, #1286	@ 0x506
341a224e:	4a2a      	ldr	r2, [pc, #168]	@ (341a22f8 <VD6G_SetDigitalGain+0x158>)
341a2250:	492a      	ldr	r1, [pc, #168]	@ (341a22fc <VD6G_SetDigitalGain+0x15c>)
341a2252:	6878      	ldr	r0, [r7, #4]
341a2254:	f7fe f9a7 	bl	341a05a6 <VD6G_error>
341a2258:	68fb      	ldr	r3, [r7, #12]
341a225a:	2b00      	cmp	r3, #0
341a225c:	d002      	beq.n	341a2264 <VD6G_SetDigitalGain+0xc4>
341a225e:	6878      	ldr	r0, [r7, #4]
341a2260:	f7fe f9bc 	bl	341a05dc <display_error>
341a2264:	68fb      	ldr	r3, [r7, #12]
341a2266:	2b00      	cmp	r3, #0
341a2268:	d001      	beq.n	341a226e <VD6G_SetDigitalGain+0xce>
341a226a:	68fb      	ldr	r3, [r7, #12]
341a226c:	e040      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH2_DIGITAL_GAIN, gain);
341a226e:	687b      	ldr	r3, [r7, #4]
341a2270:	695b      	ldr	r3, [r3, #20]
341a2272:	683a      	ldr	r2, [r7, #0]
341a2274:	b292      	uxth	r2, r2
341a2276:	f240 4154 	movw	r1, #1108	@ 0x454
341a227a:	6878      	ldr	r0, [r7, #4]
341a227c:	4798      	blx	r3
341a227e:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a2280:	68fb      	ldr	r3, [r7, #12]
341a2282:	2b00      	cmp	r3, #0
341a2284:	d008      	beq.n	341a2298 <VD6G_SetDigitalGain+0xf8>
341a2286:	68fb      	ldr	r3, [r7, #12]
341a2288:	9300      	str	r3, [sp, #0]
341a228a:	f240 5309 	movw	r3, #1289	@ 0x509
341a228e:	4a1a      	ldr	r2, [pc, #104]	@ (341a22f8 <VD6G_SetDigitalGain+0x158>)
341a2290:	491a      	ldr	r1, [pc, #104]	@ (341a22fc <VD6G_SetDigitalGain+0x15c>)
341a2292:	6878      	ldr	r0, [r7, #4]
341a2294:	f7fe f987 	bl	341a05a6 <VD6G_error>
341a2298:	68fb      	ldr	r3, [r7, #12]
341a229a:	2b00      	cmp	r3, #0
341a229c:	d002      	beq.n	341a22a4 <VD6G_SetDigitalGain+0x104>
341a229e:	6878      	ldr	r0, [r7, #4]
341a22a0:	f7fe f99c 	bl	341a05dc <display_error>
341a22a4:	68fb      	ldr	r3, [r7, #12]
341a22a6:	2b00      	cmp	r3, #0
341a22a8:	d001      	beq.n	341a22ae <VD6G_SetDigitalGain+0x10e>
341a22aa:	68fb      	ldr	r3, [r7, #12]
341a22ac:	e020      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_CH3_DIGITAL_GAIN, gain);
341a22ae:	687b      	ldr	r3, [r7, #4]
341a22b0:	695b      	ldr	r3, [r3, #20]
341a22b2:	683a      	ldr	r2, [r7, #0]
341a22b4:	b292      	uxth	r2, r2
341a22b6:	f240 4156 	movw	r1, #1110	@ 0x456
341a22ba:	6878      	ldr	r0, [r7, #4]
341a22bc:	4798      	blx	r3
341a22be:	60f8      	str	r0, [r7, #12]
  VD6G_TraceError(ctx, ret);
341a22c0:	68fb      	ldr	r3, [r7, #12]
341a22c2:	2b00      	cmp	r3, #0
341a22c4:	d008      	beq.n	341a22d8 <VD6G_SetDigitalGain+0x138>
341a22c6:	68fb      	ldr	r3, [r7, #12]
341a22c8:	9300      	str	r3, [sp, #0]
341a22ca:	f240 530c 	movw	r3, #1292	@ 0x50c
341a22ce:	4a0a      	ldr	r2, [pc, #40]	@ (341a22f8 <VD6G_SetDigitalGain+0x158>)
341a22d0:	490a      	ldr	r1, [pc, #40]	@ (341a22fc <VD6G_SetDigitalGain+0x15c>)
341a22d2:	6878      	ldr	r0, [r7, #4]
341a22d4:	f7fe f967 	bl	341a05a6 <VD6G_error>
341a22d8:	68fb      	ldr	r3, [r7, #12]
341a22da:	2b00      	cmp	r3, #0
341a22dc:	d002      	beq.n	341a22e4 <VD6G_SetDigitalGain+0x144>
341a22de:	6878      	ldr	r0, [r7, #4]
341a22e0:	f7fe f97c 	bl	341a05dc <display_error>
341a22e4:	68fb      	ldr	r3, [r7, #12]
341a22e6:	2b00      	cmp	r3, #0
341a22e8:	d001      	beq.n	341a22ee <VD6G_SetDigitalGain+0x14e>
341a22ea:	68fb      	ldr	r3, [r7, #12]
341a22ec:	e000      	b.n	341a22f0 <VD6G_SetDigitalGain+0x150>

  return 0;
341a22ee:	2300      	movs	r3, #0
}
341a22f0:	4618      	mov	r0, r3
341a22f2:	3710      	adds	r7, #16
341a22f4:	46bd      	mov	sp, r7
341a22f6:	bd80      	pop	{r7, pc}
341a22f8:	341ae618 	.word	0x341ae618
341a22fc:	341a7b68 	.word	0x341a7b68

341a2300 <VD6G_GetExposureRegRange>:

int VD6G_GetExposureRegRange(VD6G_Ctx_t *ctx, uint32_t *min_us, uint32_t *max_us)
{
341a2300:	b580      	push	{r7, lr}
341a2302:	b08a      	sub	sp, #40	@ 0x28
341a2304:	af02      	add	r7, sp, #8
341a2306:	60f8      	str	r0, [r7, #12]
341a2308:	60b9      	str	r1, [r7, #8]
341a230a:	607a      	str	r2, [r7, #4]
  uint16_t exp_coarse_intg_margin;
  uint32_t line_time_in_us;
  uint16_t frame_length;
  int ret;

  if ((min_us == NULL) || (max_us == NULL))
341a230c:	68bb      	ldr	r3, [r7, #8]
341a230e:	2b00      	cmp	r3, #0
341a2310:	d002      	beq.n	341a2318 <VD6G_GetExposureRegRange+0x18>
341a2312:	687b      	ldr	r3, [r7, #4]
341a2314:	2b00      	cmp	r3, #0
341a2316:	d102      	bne.n	341a231e <VD6G_GetExposureRegRange+0x1e>
    return -1;
341a2318:	f04f 33ff 	mov.w	r3, #4294967295
341a231c:	e065      	b.n	341a23ea <VD6G_GetExposureRegRange+0xea>

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
341a231e:	f107 0314 	add.w	r3, r7, #20
341a2322:	4619      	mov	r1, r3
341a2324:	68f8      	ldr	r0, [r7, #12]
341a2326:	f7fe f9cf 	bl	341a06c8 <VD6G_GetLineTimeInUs>
341a232a:	61f8      	str	r0, [r7, #28]
  if (ret)
341a232c:	69fb      	ldr	r3, [r7, #28]
341a232e:	2b00      	cmp	r3, #0
341a2330:	d001      	beq.n	341a2336 <VD6G_GetExposureRegRange+0x36>
    return ret;
341a2332:	69fb      	ldr	r3, [r7, #28]
341a2334:	e059      	b.n	341a23ea <VD6G_GetExposureRegRange+0xea>

  *min_us = VD6G_MIN_MANUAL_EXP_COARSE * line_time_in_us;
341a2336:	697a      	ldr	r2, [r7, #20]
341a2338:	4613      	mov	r3, r2
341a233a:	005b      	lsls	r3, r3, #1
341a233c:	4413      	add	r3, r2
341a233e:	00da      	lsls	r2, r3, #3
341a2340:	1ad2      	subs	r2, r2, r3
341a2342:	68bb      	ldr	r3, [r7, #8]
341a2344:	601a      	str	r2, [r3, #0]

  ret = ctx->read16(ctx, VD6G_FRAME_LENGTH, &frame_length);
341a2346:	68fb      	ldr	r3, [r7, #12]
341a2348:	689b      	ldr	r3, [r3, #8]
341a234a:	f107 0212 	add.w	r2, r7, #18
341a234e:	f44f 618b 	mov.w	r1, #1112	@ 0x458
341a2352:	68f8      	ldr	r0, [r7, #12]
341a2354:	4798      	blx	r3
341a2356:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
341a2358:	69fb      	ldr	r3, [r7, #28]
341a235a:	2b00      	cmp	r3, #0
341a235c:	d008      	beq.n	341a2370 <VD6G_GetExposureRegRange+0x70>
341a235e:	69fb      	ldr	r3, [r7, #28]
341a2360:	9300      	str	r3, [sp, #0]
341a2362:	f240 5322 	movw	r3, #1314	@ 0x522
341a2366:	4a23      	ldr	r2, [pc, #140]	@ (341a23f4 <VD6G_GetExposureRegRange+0xf4>)
341a2368:	4923      	ldr	r1, [pc, #140]	@ (341a23f8 <VD6G_GetExposureRegRange+0xf8>)
341a236a:	68f8      	ldr	r0, [r7, #12]
341a236c:	f7fe f91b 	bl	341a05a6 <VD6G_error>
341a2370:	69fb      	ldr	r3, [r7, #28]
341a2372:	2b00      	cmp	r3, #0
341a2374:	d002      	beq.n	341a237c <VD6G_GetExposureRegRange+0x7c>
341a2376:	68f8      	ldr	r0, [r7, #12]
341a2378:	f7fe f930 	bl	341a05dc <display_error>
341a237c:	69fb      	ldr	r3, [r7, #28]
341a237e:	2b00      	cmp	r3, #0
341a2380:	d001      	beq.n	341a2386 <VD6G_GetExposureRegRange+0x86>
341a2382:	69fb      	ldr	r3, [r7, #28]
341a2384:	e031      	b.n	341a23ea <VD6G_GetExposureRegRange+0xea>

  ret = ctx->read16(ctx, VD6G_REG_EXP_COARSE_INTG_MARGIN, &exp_coarse_intg_margin);
341a2386:	68fb      	ldr	r3, [r7, #12]
341a2388:	689b      	ldr	r3, [r3, #8]
341a238a:	f107 021a 	add.w	r2, r7, #26
341a238e:	f640 1146 	movw	r1, #2374	@ 0x946
341a2392:	68f8      	ldr	r0, [r7, #12]
341a2394:	4798      	blx	r3
341a2396:	61f8      	str	r0, [r7, #28]
  VD6G_TraceError(ctx, ret);
341a2398:	69fb      	ldr	r3, [r7, #28]
341a239a:	2b00      	cmp	r3, #0
341a239c:	d008      	beq.n	341a23b0 <VD6G_GetExposureRegRange+0xb0>
341a239e:	69fb      	ldr	r3, [r7, #28]
341a23a0:	9300      	str	r3, [sp, #0]
341a23a2:	f240 5325 	movw	r3, #1317	@ 0x525
341a23a6:	4a13      	ldr	r2, [pc, #76]	@ (341a23f4 <VD6G_GetExposureRegRange+0xf4>)
341a23a8:	4913      	ldr	r1, [pc, #76]	@ (341a23f8 <VD6G_GetExposureRegRange+0xf8>)
341a23aa:	68f8      	ldr	r0, [r7, #12]
341a23ac:	f7fe f8fb 	bl	341a05a6 <VD6G_error>
341a23b0:	69fb      	ldr	r3, [r7, #28]
341a23b2:	2b00      	cmp	r3, #0
341a23b4:	d002      	beq.n	341a23bc <VD6G_GetExposureRegRange+0xbc>
341a23b6:	68f8      	ldr	r0, [r7, #12]
341a23b8:	f7fe f910 	bl	341a05dc <display_error>
341a23bc:	69fb      	ldr	r3, [r7, #28]
341a23be:	2b00      	cmp	r3, #0
341a23c0:	d001      	beq.n	341a23c6 <VD6G_GetExposureRegRange+0xc6>
341a23c2:	69fb      	ldr	r3, [r7, #28]
341a23c4:	e011      	b.n	341a23ea <VD6G_GetExposureRegRange+0xea>

  if (exp_coarse_intg_margin >= VD6G_MIN_EXP_COARSE_INTG_MARGIN)
341a23c6:	8b7b      	ldrh	r3, [r7, #26]
341a23c8:	2b43      	cmp	r3, #67	@ 0x43
341a23ca:	d90c      	bls.n	341a23e6 <VD6G_GetExposureRegRange+0xe6>
    *max_us = (frame_length - exp_coarse_intg_margin - VD6G_MAX_MANUAL_EXP_COARSE_OFFSET) * line_time_in_us;
341a23cc:	8a7b      	ldrh	r3, [r7, #18]
341a23ce:	461a      	mov	r2, r3
341a23d0:	8b7b      	ldrh	r3, [r7, #26]
341a23d2:	1ad3      	subs	r3, r2, r3
341a23d4:	3b07      	subs	r3, #7
341a23d6:	461a      	mov	r2, r3
341a23d8:	697b      	ldr	r3, [r7, #20]
341a23da:	fb03 f202 	mul.w	r2, r3, r2
341a23de:	687b      	ldr	r3, [r7, #4]
341a23e0:	601a      	str	r2, [r3, #0]
  else
    return -1;

  return 0;
341a23e2:	2300      	movs	r3, #0
341a23e4:	e001      	b.n	341a23ea <VD6G_GetExposureRegRange+0xea>
    return -1;
341a23e6:	f04f 33ff 	mov.w	r3, #4294967295
}
341a23ea:	4618      	mov	r0, r3
341a23ec:	3720      	adds	r7, #32
341a23ee:	46bd      	mov	sp, r7
341a23f0:	bd80      	pop	{r7, pc}
341a23f2:	bf00      	nop
341a23f4:	341ae62c 	.word	0x341ae62c
341a23f8:	341a7b68 	.word	0x341a7b68

341a23fc <VD6G_SetExposureTime>:

int VD6G_SetExposureTime(VD6G_Ctx_t *ctx, int exposure_us)
{
341a23fc:	b580      	push	{r7, lr}
341a23fe:	b088      	sub	sp, #32
341a2400:	af02      	add	r7, sp, #8
341a2402:	6078      	str	r0, [r7, #4]
341a2404:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint32_t exp_min, exp_max;
  uint32_t line_time_in_us;

  ret = VD6G_GetExposureRegRange(ctx, &exp_min, &exp_max);
341a2406:	f107 020c 	add.w	r2, r7, #12
341a240a:	f107 0310 	add.w	r3, r7, #16
341a240e:	4619      	mov	r1, r3
341a2410:	6878      	ldr	r0, [r7, #4]
341a2412:	f7ff ff75 	bl	341a2300 <VD6G_GetExposureRegRange>
341a2416:	6178      	str	r0, [r7, #20]
  if (ret)
341a2418:	697b      	ldr	r3, [r7, #20]
341a241a:	2b00      	cmp	r3, #0
341a241c:	d001      	beq.n	341a2422 <VD6G_SetExposureTime+0x26>
    return ret;
341a241e:	697b      	ldr	r3, [r7, #20]
341a2420:	e041      	b.n	341a24a6 <VD6G_SetExposureTime+0xaa>

  ret = CHECK_RANGE(exposure_us, exp_min, exp_max);
341a2422:	683a      	ldr	r2, [r7, #0]
341a2424:	693b      	ldr	r3, [r7, #16]
341a2426:	429a      	cmp	r2, r3
341a2428:	d305      	bcc.n	341a2436 <VD6G_SetExposureTime+0x3a>
341a242a:	683a      	ldr	r2, [r7, #0]
341a242c:	68fb      	ldr	r3, [r7, #12]
341a242e:	429a      	cmp	r2, r3
341a2430:	d801      	bhi.n	341a2436 <VD6G_SetExposureTime+0x3a>
341a2432:	2300      	movs	r3, #0
341a2434:	e001      	b.n	341a243a <VD6G_SetExposureTime+0x3e>
341a2436:	f04f 33ff 	mov.w	r3, #4294967295
341a243a:	617b      	str	r3, [r7, #20]
  if (ret)
341a243c:	697b      	ldr	r3, [r7, #20]
341a243e:	2b00      	cmp	r3, #0
341a2440:	d001      	beq.n	341a2446 <VD6G_SetExposureTime+0x4a>
    return ret;
341a2442:	697b      	ldr	r3, [r7, #20]
341a2444:	e02f      	b.n	341a24a6 <VD6G_SetExposureTime+0xaa>

  ret = VD6G_GetLineTimeInUs(ctx, &line_time_in_us);
341a2446:	f107 0308 	add.w	r3, r7, #8
341a244a:	4619      	mov	r1, r3
341a244c:	6878      	ldr	r0, [r7, #4]
341a244e:	f7fe f93b 	bl	341a06c8 <VD6G_GetLineTimeInUs>
341a2452:	6178      	str	r0, [r7, #20]
  if (ret)
341a2454:	697b      	ldr	r3, [r7, #20]
341a2456:	2b00      	cmp	r3, #0
341a2458:	d001      	beq.n	341a245e <VD6G_SetExposureTime+0x62>
    return ret;
341a245a:	697b      	ldr	r3, [r7, #20]
341a245c:	e023      	b.n	341a24a6 <VD6G_SetExposureTime+0xaa>

  ret = ctx->write16(ctx, VD6G_REG_MANUAL_COARSE_EXP, CEIL(exposure_us / line_time_in_us));
341a245e:	687b      	ldr	r3, [r7, #4]
341a2460:	695b      	ldr	r3, [r3, #20]
341a2462:	6839      	ldr	r1, [r7, #0]
341a2464:	68ba      	ldr	r2, [r7, #8]
341a2466:	fbb1 f2f2 	udiv	r2, r1, r2
341a246a:	b292      	uxth	r2, r2
341a246c:	f240 414e 	movw	r1, #1102	@ 0x44e
341a2470:	6878      	ldr	r0, [r7, #4]
341a2472:	4798      	blx	r3
341a2474:	6178      	str	r0, [r7, #20]
  VD6G_TraceError(ctx, ret);
341a2476:	697b      	ldr	r3, [r7, #20]
341a2478:	2b00      	cmp	r3, #0
341a247a:	d008      	beq.n	341a248e <VD6G_SetExposureTime+0x92>
341a247c:	697b      	ldr	r3, [r7, #20]
341a247e:	9300      	str	r3, [sp, #0]
341a2480:	f240 5342 	movw	r3, #1346	@ 0x542
341a2484:	4a0a      	ldr	r2, [pc, #40]	@ (341a24b0 <VD6G_SetExposureTime+0xb4>)
341a2486:	490b      	ldr	r1, [pc, #44]	@ (341a24b4 <VD6G_SetExposureTime+0xb8>)
341a2488:	6878      	ldr	r0, [r7, #4]
341a248a:	f7fe f88c 	bl	341a05a6 <VD6G_error>
341a248e:	697b      	ldr	r3, [r7, #20]
341a2490:	2b00      	cmp	r3, #0
341a2492:	d002      	beq.n	341a249a <VD6G_SetExposureTime+0x9e>
341a2494:	6878      	ldr	r0, [r7, #4]
341a2496:	f7fe f8a1 	bl	341a05dc <display_error>
341a249a:	697b      	ldr	r3, [r7, #20]
341a249c:	2b00      	cmp	r3, #0
341a249e:	d001      	beq.n	341a24a4 <VD6G_SetExposureTime+0xa8>
341a24a0:	697b      	ldr	r3, [r7, #20]
341a24a2:	e000      	b.n	341a24a6 <VD6G_SetExposureTime+0xaa>

  return 0;
341a24a4:	2300      	movs	r3, #0
}
341a24a6:	4618      	mov	r0, r3
341a24a8:	3718      	adds	r7, #24
341a24aa:	46bd      	mov	sp, r7
341a24ac:	bd80      	pop	{r7, pc}
341a24ae:	bf00      	nop
341a24b0:	341ae648 	.word	0x341ae648
341a24b4:	341a7b68 	.word	0x341a7b68

341a24b8 <EXTMEM_Init>:
/** @defgroup EXTMEM_Exported_Functions External Memory Exported Functions
  * @{
  */

EXTMEM_StatusTypeDef EXTMEM_Init(uint32_t MemId, uint32_t ClockInput)
{
341a24b8:	b580      	push	{r7, lr}
341a24ba:	b084      	sub	sp, #16
341a24bc:	af00      	add	r7, sp, #0
341a24be:	6078      	str	r0, [r7, #4]
341a24c0:	6039      	str	r1, [r7, #0]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
341a24c2:	23fb      	movs	r3, #251	@ 0xfb
341a24c4:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();

  /* control the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
341a24c6:	687b      	ldr	r3, [r7, #4]
341a24c8:	2b01      	cmp	r3, #1
341a24ca:	d855      	bhi.n	341a2578 <EXTMEM_Init+0xc0>
  {
    retr = EXTMEM_OK;
341a24cc:	2300      	movs	r3, #0
341a24ce:	73fb      	strb	r3, [r7, #15]
    switch (extmem_list_config[MemId].MemType)
341a24d0:	4a2c      	ldr	r2, [pc, #176]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a24d2:	687b      	ldr	r3, [r7, #4]
341a24d4:	21ac      	movs	r1, #172	@ 0xac
341a24d6:	fb01 f303 	mul.w	r3, r1, r3
341a24da:	4413      	add	r3, r2
341a24dc:	781b      	ldrb	r3, [r3, #0]
341a24de:	2b00      	cmp	r3, #0
341a24e0:	d002      	beq.n	341a24e8 <EXTMEM_Init+0x30>
341a24e2:	2b02      	cmp	r3, #2
341a24e4:	d021      	beq.n	341a252a <EXTMEM_Init+0x72>
341a24e6:	e041      	b.n	341a256c <EXTMEM_Init+0xb4>
    {
#if EXTMEM_DRIVER_NOR_SFDP == 1
      case EXTMEM_NOR_SFDP:{
        /* Initialize the SFDP memory */
        if (EXTMEM_DRIVER_NOR_SFDP_OK != EXTMEM_DRIVER_NOR_SFDP_Init(extmem_list_config[MemId].Handle,
341a24e8:	4a26      	ldr	r2, [pc, #152]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a24ea:	687b      	ldr	r3, [r7, #4]
341a24ec:	21ac      	movs	r1, #172	@ 0xac
341a24ee:	fb01 f303 	mul.w	r3, r1, r3
341a24f2:	4413      	add	r3, r2
341a24f4:	3304      	adds	r3, #4
341a24f6:	6818      	ldr	r0, [r3, #0]
341a24f8:	4a22      	ldr	r2, [pc, #136]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a24fa:	687b      	ldr	r3, [r7, #4]
341a24fc:	21ac      	movs	r1, #172	@ 0xac
341a24fe:	fb01 f303 	mul.w	r3, r1, r3
341a2502:	4413      	add	r3, r2
341a2504:	3308      	adds	r3, #8
341a2506:	7819      	ldrb	r1, [r3, #0]
341a2508:	687b      	ldr	r3, [r7, #4]
341a250a:	22ac      	movs	r2, #172	@ 0xac
341a250c:	fb02 f303 	mul.w	r3, r2, r3
341a2510:	3308      	adds	r3, #8
341a2512:	4a1c      	ldr	r2, [pc, #112]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a2514:	4413      	add	r3, r2
341a2516:	3304      	adds	r3, #4
341a2518:	683a      	ldr	r2, [r7, #0]
341a251a:	f002 fb21 	bl	341a4b60 <EXTMEM_DRIVER_NOR_SFDP_Init>
341a251e:	4603      	mov	r3, r0
341a2520:	2b00      	cmp	r3, #0
341a2522:	d026      	beq.n	341a2572 <EXTMEM_Init+0xba>
                                                                     extmem_list_config[MemId].ConfigType,
                                                                     ClockInput,
                                                                     &extmem_list_config[MemId].NorSfdpObject))
        {
          retr = EXTMEM_ERROR_DRIVER;
341a2524:	23fd      	movs	r3, #253	@ 0xfd
341a2526:	73fb      	strb	r3, [r7, #15]
        }
        break;
341a2528:	e023      	b.n	341a2572 <EXTMEM_Init+0xba>
    }
#endif /* EXTMEM_DRIVER_SDCARD == 1 */
#if EXTMEM_DRIVER_PSRAM == 1
    case EXTMEM_PSRAM : {
        /* Initialize the SFDP memory */
        if (EXTMEM_DRIVER_PSRAM_OK != EXTMEM_DRIVER_PSRAM_Init(extmem_list_config[MemId].Handle,
341a252a:	4a16      	ldr	r2, [pc, #88]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a252c:	687b      	ldr	r3, [r7, #4]
341a252e:	21ac      	movs	r1, #172	@ 0xac
341a2530:	fb01 f303 	mul.w	r3, r1, r3
341a2534:	4413      	add	r3, r2
341a2536:	3304      	adds	r3, #4
341a2538:	6818      	ldr	r0, [r3, #0]
341a253a:	4a12      	ldr	r2, [pc, #72]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a253c:	687b      	ldr	r3, [r7, #4]
341a253e:	21ac      	movs	r1, #172	@ 0xac
341a2540:	fb01 f303 	mul.w	r3, r1, r3
341a2544:	4413      	add	r3, r2
341a2546:	3308      	adds	r3, #8
341a2548:	7819      	ldrb	r1, [r3, #0]
341a254a:	687b      	ldr	r3, [r7, #4]
341a254c:	22ac      	movs	r2, #172	@ 0xac
341a254e:	fb02 f303 	mul.w	r3, r2, r3
341a2552:	3308      	adds	r3, #8
341a2554:	4a0b      	ldr	r2, [pc, #44]	@ (341a2584 <EXTMEM_Init+0xcc>)
341a2556:	4413      	add	r3, r2
341a2558:	3304      	adds	r3, #4
341a255a:	683a      	ldr	r2, [r7, #0]
341a255c:	f000 f814 	bl	341a2588 <EXTMEM_DRIVER_PSRAM_Init>
341a2560:	4603      	mov	r3, r0
341a2562:	2b00      	cmp	r3, #0
341a2564:	d007      	beq.n	341a2576 <EXTMEM_Init+0xbe>
                                                               extmem_list_config[MemId].ConfigType,
                                                               ClockInput,
                                                               &extmem_list_config[MemId].PsramObject))
        {
          retr = EXTMEM_ERROR_DRIVER;
341a2566:	23fd      	movs	r3, #253	@ 0xfd
341a2568:	73fb      	strb	r3, [r7, #15]
        }
        break;
341a256a:	e004      	b.n	341a2576 <EXTMEM_Init+0xbe>
      break;
    }
#endif /* EXTMEM_DRIVER_USER == 1 */
    default:{
        EXTMEM_DEBUG("\terror unknown type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
341a256c:	23fe      	movs	r3, #254	@ 0xfe
341a256e:	73fb      	strb	r3, [r7, #15]
        break;
341a2570:	e002      	b.n	341a2578 <EXTMEM_Init+0xc0>
        break;
341a2572:	bf00      	nop
341a2574:	e000      	b.n	341a2578 <EXTMEM_Init+0xc0>
        break;
341a2576:	bf00      	nop
      }
    }
  }
  return retr;
341a2578:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a257c:	4618      	mov	r0, r3
341a257e:	3710      	adds	r7, #16
341a2580:	46bd      	mov	sp, r7
341a2582:	bd80      	pop	{r7, pc}
341a2584:	341c1b84 	.word	0x341c1b84

341a2588 <EXTMEM_DRIVER_PSRAM_Init>:
  */

EXTMEM_DRIVER_PSRAM_StatusTypeDef EXTMEM_DRIVER_PSRAM_Init(void *Peripheral, EXTMEM_LinkConfig_TypeDef Config,
                                                           uint32_t ClockInput,
                                                           EXTMEM_DRIVER_PSRAM_ObjectTypeDef *PsramObject)
{
341a2588:	b580      	push	{r7, lr}
341a258a:	b088      	sub	sp, #32
341a258c:	af00      	add	r7, sp, #0
341a258e:	60f8      	str	r0, [r7, #12]
341a2590:	607a      	str	r2, [r7, #4]
341a2592:	603b      	str	r3, [r7, #0]
341a2594:	460b      	mov	r3, r1
341a2596:	72fb      	strb	r3, [r7, #11]
  EXTMEM_DRIVER_PSRAM_StatusTypeDef retr = EXTMEM_DRIVER_PSRAM_OK;
341a2598:	2300      	movs	r3, #0
341a259a:	77fb      	strb	r3, [r7, #31]

  /* initialize the instance */
  DEBUG_STR("initialize the instance")
  
  /* Initialize XSPI low layer */
  (void)SAL_XSPI_Init(&PsramObject->psram_private.SALObject, Peripheral);
341a259c:	683b      	ldr	r3, [r7, #0]
341a259e:	68f9      	ldr	r1, [r7, #12]
341a25a0:	4618      	mov	r0, r3
341a25a2:	f000 f905 	bl	341a27b0 <SAL_XSPI_Init>

  /* Abort any ongoing XSPI action */
  (void)SAL_XSPI_DisableMapMode(&PsramObject->psram_private.SALObject);
341a25a6:	683b      	ldr	r3, [r7, #0]
341a25a8:	4618      	mov	r0, r3
341a25aa:	f000 fd98 	bl	341a30de <SAL_XSPI_DisableMapMode>

  /* Set the frequency prescaler */
  DEBUG_STR("set memory speed according freqIn and freqMax supported by the memory")
  if (HAL_OK != SAL_XSPI_SetClock(&PsramObject->psram_private.SALObject, ClockInput, PsramObject->psram_public.FreqMax, &ClockOut))
341a25ae:	6838      	ldr	r0, [r7, #0]
341a25b0:	683b      	ldr	r3, [r7, #0]
341a25b2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
341a25b4:	f107 0318 	add.w	r3, r7, #24
341a25b8:	6879      	ldr	r1, [r7, #4]
341a25ba:	f000 f8ba 	bl	341a2732 <SAL_XSPI_SetClock>
341a25be:	4603      	mov	r3, r0
341a25c0:	2b00      	cmp	r3, #0
341a25c2:	d002      	beq.n	341a25ca <EXTMEM_DRIVER_PSRAM_Init+0x42>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR;
341a25c4:	2380      	movs	r3, #128	@ 0x80
341a25c6:	77fb      	strb	r3, [r7, #31]
    goto error;
341a25c8:	e03e      	b.n	341a2648 <EXTMEM_DRIVER_PSRAM_Init+0xc0>
  }

  /* Set the memory size */
  DEBUG_STR("set memory size according")
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_FLASHSIZE, &PsramObject->psram_public.MemorySize);
341a25ca:	6838      	ldr	r0, [r7, #0]
341a25cc:	683b      	ldr	r3, [r7, #0]
341a25ce:	3354      	adds	r3, #84	@ 0x54
341a25d0:	461a      	mov	r2, r3
341a25d2:	2104      	movs	r1, #4
341a25d4:	f000 f920 	bl	341a2818 <SAL_XSPI_MemoryConfig>

  /* Set the memory size */
  DEBUG_STR("set xspi link config")
  linkvalue = PHY_LINK_RAM8;
341a25d8:	230a      	movs	r3, #10
341a25da:	75fb      	strb	r3, [r7, #23]
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_PHY_LINK, &linkvalue);
341a25dc:	683b      	ldr	r3, [r7, #0]
341a25de:	f107 0217 	add.w	r2, r7, #23
341a25e2:	2100      	movs	r1, #0
341a25e4:	4618      	mov	r0, r3
341a25e6:	f000 f917 	bl	341a2818 <SAL_XSPI_MemoryConfig>

  /* Set the configuration to perform register operation */
  (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_DUMMY_CYCLES, &PsramObject->psram_public.REG_DummyCycle);
341a25ea:	6838      	ldr	r0, [r7, #0]
341a25ec:	683b      	ldr	r3, [r7, #0]
341a25ee:	3369      	adds	r3, #105	@ 0x69
341a25f0:	461a      	mov	r2, r3
341a25f2:	2101      	movs	r1, #1
341a25f4:	f000 f910 	bl	341a2818 <SAL_XSPI_MemoryConfig>

  /* Execute the command sequence */
  for (uint8_t command_index = 0u; command_index < PsramObject->psram_public.NumberOfConfig; command_index++)
341a25f8:	2300      	movs	r3, #0
341a25fa:	77bb      	strb	r3, [r7, #30]
341a25fc:	e00d      	b.n	341a261a <EXTMEM_DRIVER_PSRAM_Init+0x92>
  {
    retr = PSRAM_ExecuteCommand(PsramObject, command_index);
341a25fe:	7fbb      	ldrb	r3, [r7, #30]
341a2600:	4619      	mov	r1, r3
341a2602:	6838      	ldr	r0, [r7, #0]
341a2604:	f000 f826 	bl	341a2654 <PSRAM_ExecuteCommand>
341a2608:	4603      	mov	r3, r0
341a260a:	77fb      	strb	r3, [r7, #31]
    if (retr != EXTMEM_DRIVER_PSRAM_OK)
341a260c:	f997 301f 	ldrsb.w	r3, [r7, #31]
341a2610:	2b00      	cmp	r3, #0
341a2612:	d118      	bne.n	341a2646 <EXTMEM_DRIVER_PSRAM_Init+0xbe>
  for (uint8_t command_index = 0u; command_index < PsramObject->psram_public.NumberOfConfig; command_index++)
341a2614:	7fbb      	ldrb	r3, [r7, #30]
341a2616:	3301      	adds	r3, #1
341a2618:	77bb      	strb	r3, [r7, #30]
341a261a:	683b      	ldr	r3, [r7, #0]
341a261c:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a2620:	7fba      	ldrb	r2, [r7, #30]
341a2622:	429a      	cmp	r2, r3
341a2624:	d3eb      	bcc.n	341a25fe <EXTMEM_DRIVER_PSRAM_Init+0x76>
    {
      goto error;
    }
  }

  switch(Config)
341a2626:	7afb      	ldrb	r3, [r7, #11]
341a2628:	2b04      	cmp	r3, #4
341a262a:	d109      	bne.n	341a2640 <EXTMEM_DRIVER_PSRAM_Init+0xb8>
  {
  case EXTMEM_LINK_CONFIG_16LINES:
    linkvalue = PHY_LINK_RAM16;
341a262c:	230b      	movs	r3, #11
341a262e:	75fb      	strb	r3, [r7, #23]
    (void)SAL_XSPI_MemoryConfig(&PsramObject->psram_private.SALObject, PARAM_PHY_LINK, &linkvalue);
341a2630:	683b      	ldr	r3, [r7, #0]
341a2632:	f107 0217 	add.w	r2, r7, #23
341a2636:	2100      	movs	r1, #0
341a2638:	4618      	mov	r0, r3
341a263a:	f000 f8ed 	bl	341a2818 <SAL_XSPI_MemoryConfig>
    break;
341a263e:	e003      	b.n	341a2648 <EXTMEM_DRIVER_PSRAM_Init+0xc0>

  case EXTMEM_LINK_CONFIG_8LINES:
  default:
    retr = EXTMEM_DRIVER_PSRAM_ERROR;
341a2640:	2380      	movs	r3, #128	@ 0x80
341a2642:	77fb      	strb	r3, [r7, #31]
    goto error;
341a2644:	e000      	b.n	341a2648 <EXTMEM_DRIVER_PSRAM_Init+0xc0>
      goto error;
341a2646:	bf00      	nop
    break;
  }

error:
  return retr;
341a2648:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
341a264c:	4618      	mov	r0, r3
341a264e:	3720      	adds	r7, #32
341a2650:	46bd      	mov	sp, r7
341a2652:	bd80      	pop	{r7, pc}

341a2654 <PSRAM_ExecuteCommand>:
 * @param PsramObject psram memory object
 * @param Index command index
 * @return @ref EXTMEM_DRIVER_PSRAM_StatusTypeDef
 **/
EXTMEM_DRIVER_PSRAM_StatusTypeDef PSRAM_ExecuteCommand(EXTMEM_DRIVER_PSRAM_ObjectTypeDef *PsramObject, uint8_t Index)
{
341a2654:	b590      	push	{r4, r7, lr}
341a2656:	b087      	sub	sp, #28
341a2658:	af02      	add	r7, sp, #8
341a265a:	6078      	str	r0, [r7, #4]
341a265c:	460b      	mov	r3, r1
341a265e:	70fb      	strb	r3, [r7, #3]
  EXTMEM_DRIVER_PSRAM_StatusTypeDef retr = EXTMEM_DRIVER_PSRAM_OK;
341a2660:	2300      	movs	r3, #0
341a2662:	73fb      	strb	r3, [r7, #15]
  uint8_t regval[2];

  if (PsramObject->psram_public.ReadREGSize > 2u)
341a2664:	687b      	ldr	r3, [r7, #4]
341a2666:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
341a266a:	2b02      	cmp	r3, #2
341a266c:	d902      	bls.n	341a2674 <PSRAM_ExecuteCommand+0x20>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_REGSIZE;
341a266e:	23f9      	movs	r3, #249	@ 0xf9
341a2670:	73fb      	strb	r3, [r7, #15]
    goto error;
341a2672:	e058      	b.n	341a2726 <PSRAM_ExecuteCommand+0xd2>
  }

  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a2674:	6878      	ldr	r0, [r7, #4]
341a2676:	687b      	ldr	r3, [r7, #4]
341a2678:	f893 4066 	ldrb.w	r4, [r3, #102]	@ 0x66
                              PsramObject->psram_public.ReadREG,
                              PsramObject->psram_public.config[Index].REGAddress, 
341a267c:	78fa      	ldrb	r2, [r7, #3]
341a267e:	6879      	ldr	r1, [r7, #4]
341a2680:	4613      	mov	r3, r2
341a2682:	005b      	lsls	r3, r3, #1
341a2684:	4413      	add	r3, r2
341a2686:	440b      	add	r3, r1
341a2688:	335f      	adds	r3, #95	@ 0x5f
341a268a:	781b      	ldrb	r3, [r3, #0]
  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a268c:	4619      	mov	r1, r3
                              regval, PsramObject->psram_public.ReadREGSize))
341a268e:	687b      	ldr	r3, [r7, #4]
341a2690:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
  if (HAL_OK != SAL_XSPI_Read(&PsramObject->psram_private.SALObject, 
341a2694:	461a      	mov	r2, r3
341a2696:	f107 030c 	add.w	r3, r7, #12
341a269a:	9200      	str	r2, [sp, #0]
341a269c:	460a      	mov	r2, r1
341a269e:	4621      	mov	r1, r4
341a26a0:	f000 fae6 	bl	341a2c70 <SAL_XSPI_Read>
341a26a4:	4603      	mov	r3, r0
341a26a6:	2b00      	cmp	r3, #0
341a26a8:	d002      	beq.n	341a26b0 <PSRAM_ExecuteCommand+0x5c>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_READREG;
341a26aa:	23ff      	movs	r3, #255	@ 0xff
341a26ac:	73fb      	strb	r3, [r7, #15]
    goto error;
341a26ae:	e03a      	b.n	341a2726 <PSRAM_ExecuteCommand+0xd2>
  }

  MODIFY_REG(regval[0], 
341a26b0:	7b3b      	ldrb	r3, [r7, #12]
341a26b2:	b259      	sxtb	r1, r3
341a26b4:	78fa      	ldrb	r2, [r7, #3]
341a26b6:	6878      	ldr	r0, [r7, #4]
341a26b8:	4613      	mov	r3, r2
341a26ba:	005b      	lsls	r3, r3, #1
341a26bc:	4413      	add	r3, r2
341a26be:	4403      	add	r3, r0
341a26c0:	335d      	adds	r3, #93	@ 0x5d
341a26c2:	781b      	ldrb	r3, [r3, #0]
341a26c4:	b25b      	sxtb	r3, r3
341a26c6:	43db      	mvns	r3, r3
341a26c8:	b25b      	sxtb	r3, r3
341a26ca:	400b      	ands	r3, r1
341a26cc:	b259      	sxtb	r1, r3
341a26ce:	78fa      	ldrb	r2, [r7, #3]
341a26d0:	6878      	ldr	r0, [r7, #4]
341a26d2:	4613      	mov	r3, r2
341a26d4:	005b      	lsls	r3, r3, #1
341a26d6:	4413      	add	r3, r2
341a26d8:	4403      	add	r3, r0
341a26da:	335e      	adds	r3, #94	@ 0x5e
341a26dc:	781b      	ldrb	r3, [r3, #0]
341a26de:	b25b      	sxtb	r3, r3
341a26e0:	430b      	orrs	r3, r1
341a26e2:	b25b      	sxtb	r3, r3
341a26e4:	b2db      	uxtb	r3, r3
341a26e6:	733b      	strb	r3, [r7, #12]
             PsramObject->psram_public.config[Index].WriteMask, 
             PsramObject->psram_public.config[Index].WriteValue);

  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a26e8:	6878      	ldr	r0, [r7, #4]
341a26ea:	687b      	ldr	r3, [r7, #4]
341a26ec:	f893 4067 	ldrb.w	r4, [r3, #103]	@ 0x67
                               PsramObject->psram_public.WriteREG,
                               PsramObject->psram_public.config[Index].REGAddress, 
341a26f0:	78fa      	ldrb	r2, [r7, #3]
341a26f2:	6879      	ldr	r1, [r7, #4]
341a26f4:	4613      	mov	r3, r2
341a26f6:	005b      	lsls	r3, r3, #1
341a26f8:	4413      	add	r3, r2
341a26fa:	440b      	add	r3, r1
341a26fc:	335f      	adds	r3, #95	@ 0x5f
341a26fe:	781b      	ldrb	r3, [r3, #0]
  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a2700:	4619      	mov	r1, r3
                               regval, PsramObject->psram_public.ReadREGSize))
341a2702:	687b      	ldr	r3, [r7, #4]
341a2704:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
  if (HAL_OK != SAL_XSPI_Write(&PsramObject->psram_private.SALObject, 
341a2708:	461a      	mov	r2, r3
341a270a:	f107 030c 	add.w	r3, r7, #12
341a270e:	9200      	str	r2, [sp, #0]
341a2710:	460a      	mov	r2, r1
341a2712:	4621      	mov	r1, r4
341a2714:	f000 fb14 	bl	341a2d40 <SAL_XSPI_Write>
341a2718:	4603      	mov	r3, r0
341a271a:	2b00      	cmp	r3, #0
341a271c:	d002      	beq.n	341a2724 <PSRAM_ExecuteCommand+0xd0>
  {
    retr = EXTMEM_DRIVER_PSRAM_ERROR_WRITEREG;
341a271e:	23fe      	movs	r3, #254	@ 0xfe
341a2720:	73fb      	strb	r3, [r7, #15]
    goto error;
341a2722:	e000      	b.n	341a2726 <PSRAM_ExecuteCommand+0xd2>
  }

error:
341a2724:	bf00      	nop
  return retr;
341a2726:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a272a:	4618      	mov	r0, r3
341a272c:	3714      	adds	r7, #20
341a272e:	46bd      	mov	sp, r7
341a2730:	bd90      	pop	{r4, r7, pc}

341a2732 <SAL_XSPI_SetClock>:
/* Private variables ---------------------------------------------------------*/
/** @defgroup SAL_XSPI_Exported_Functions SAL XSP Exported Functions
  * @{
  */
HAL_StatusTypeDef SAL_XSPI_SetClock(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t ClockIn, uint32_t ClockRequested, uint32_t *ClockReal)
{
341a2732:	b480      	push	{r7}
341a2734:	b087      	sub	sp, #28
341a2736:	af00      	add	r7, sp, #0
341a2738:	60f8      	str	r0, [r7, #12]
341a273a:	60b9      	str	r1, [r7, #8]
341a273c:	607a      	str	r2, [r7, #4]
341a273e:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr = HAL_OK;
341a2740:	2300      	movs	r3, #0
341a2742:	75fb      	strb	r3, [r7, #23]
  uint32_t divider;

  if (ClockRequested == 0u)
341a2744:	687b      	ldr	r3, [r7, #4]
341a2746:	2b00      	cmp	r3, #0
341a2748:	d102      	bne.n	341a2750 <SAL_XSPI_SetClock+0x1e>
  {
    retr = HAL_ERROR;
341a274a:	2301      	movs	r3, #1
341a274c:	75fb      	strb	r3, [r7, #23]
341a274e:	e028      	b.n	341a27a2 <SAL_XSPI_SetClock+0x70>
  }
  else
  {
    divider = (ClockIn / ClockRequested);
341a2750:	68ba      	ldr	r2, [r7, #8]
341a2752:	687b      	ldr	r3, [r7, #4]
341a2754:	fbb2 f3f3 	udiv	r3, r2, r3
341a2758:	613b      	str	r3, [r7, #16]
    if (divider >= 1u)
341a275a:	693b      	ldr	r3, [r7, #16]
341a275c:	2b00      	cmp	r3, #0
341a275e:	d00d      	beq.n	341a277c <SAL_XSPI_SetClock+0x4a>
    {
      *ClockReal = ClockIn / divider;
341a2760:	68ba      	ldr	r2, [r7, #8]
341a2762:	693b      	ldr	r3, [r7, #16]
341a2764:	fbb2 f2f3 	udiv	r2, r2, r3
341a2768:	683b      	ldr	r3, [r7, #0]
341a276a:	601a      	str	r2, [r3, #0]
      if (*ClockReal <= ClockRequested)
341a276c:	683b      	ldr	r3, [r7, #0]
341a276e:	681b      	ldr	r3, [r3, #0]
341a2770:	687a      	ldr	r2, [r7, #4]
341a2772:	429a      	cmp	r2, r3
341a2774:	d302      	bcc.n	341a277c <SAL_XSPI_SetClock+0x4a>
      {
        divider--;
341a2776:	693b      	ldr	r3, [r7, #16]
341a2778:	3b01      	subs	r3, #1
341a277a:	613b      	str	r3, [r7, #16]
      }
    }

    /* real clock calculation */
    *ClockReal = ClockIn / (divider + 1u);
341a277c:	693b      	ldr	r3, [r7, #16]
341a277e:	3301      	adds	r3, #1
341a2780:	68ba      	ldr	r2, [r7, #8]
341a2782:	fbb2 f2f3 	udiv	r2, r2, r3
341a2786:	683b      	ldr	r3, [r7, #0]
341a2788:	601a      	str	r2, [r3, #0]

    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::CLOCKDIV::"); DEBUG_PARAM_INT(divider+1); DEBUG_PARAM_END();
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::CLKFREQ::"); DEBUG_PARAM_INTD(*ClockReal); DEBUG_PARAM_END();
    MODIFY_REG(SalXspi->hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER, (uint32_t)divider << XSPI_DCR2_PRESCALER_Pos);
341a278a:	68fb      	ldr	r3, [r7, #12]
341a278c:	681b      	ldr	r3, [r3, #0]
341a278e:	681b      	ldr	r3, [r3, #0]
341a2790:	68db      	ldr	r3, [r3, #12]
341a2792:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
341a2796:	68fb      	ldr	r3, [r7, #12]
341a2798:	681b      	ldr	r3, [r3, #0]
341a279a:	681b      	ldr	r3, [r3, #0]
341a279c:	693a      	ldr	r2, [r7, #16]
341a279e:	430a      	orrs	r2, r1
341a27a0:	60da      	str	r2, [r3, #12]
  }

  return retr;
341a27a2:	7dfb      	ldrb	r3, [r7, #23]
}
341a27a4:	4618      	mov	r0, r3
341a27a6:	371c      	adds	r7, #28
341a27a8:	46bd      	mov	sp, r7
341a27aa:	f85d 7b04 	ldr.w	r7, [sp], #4
341a27ae:	4770      	bx	lr

341a27b0 <SAL_XSPI_Init>:
/*
* This function is used to configure the way to discuss with the memory
*
*/
HAL_StatusTypeDef SAL_XSPI_Init(SAL_XSPI_ObjectTypeDef *SalXspi, void *HALHandle)
{
341a27b0:	b580      	push	{r7, lr}
341a27b2:	b096      	sub	sp, #88	@ 0x58
341a27b4:	af00      	add	r7, sp, #0
341a27b6:	6078      	str	r0, [r7, #4]
341a27b8:	6039      	str	r1, [r7, #0]
  XSPI_RegularCmdTypeDef s_commandbase = {
341a27ba:	f107 030c 	add.w	r3, r7, #12
341a27be:	224c      	movs	r2, #76	@ 0x4c
341a27c0:	2100      	movs	r1, #0
341a27c2:	4618      	mov	r0, r3
341a27c4:	f002 fe94 	bl	341a54f0 <memset>
341a27c8:	235a      	movs	r3, #90	@ 0x5a
341a27ca:	617b      	str	r3, [r7, #20]
341a27cc:	2301      	movs	r3, #1
341a27ce:	61bb      	str	r3, [r7, #24]
341a27d0:	f44f 7380 	mov.w	r3, #256	@ 0x100
341a27d4:	62bb      	str	r3, [r7, #40]	@ 0x28
341a27d6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a27da:	62fb      	str	r3, [r7, #44]	@ 0x2c
341a27dc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a27e0:	647b      	str	r3, [r7, #68]	@ 0x44
341a27e2:	2308      	movs	r3, #8
341a27e4:	653b      	str	r3, [r7, #80]	@ 0x50
#if defined(XSPI_CCR_SIOO)
      .SIOOMode = HAL_XSPI_SIOO_INST_EVERY_CMD,
#endif /* HAL_XSPI_SIOO_INST_EVERY_CMD */
  };

  SalXspi->hxspi = (XSPI_HandleTypeDef *)HALHandle;
341a27e6:	687b      	ldr	r3, [r7, #4]
341a27e8:	683a      	ldr	r2, [r7, #0]
341a27ea:	601a      	str	r2, [r3, #0]
  SalXspi->Commandbase = s_commandbase;
341a27ec:	687b      	ldr	r3, [r7, #4]
341a27ee:	3304      	adds	r3, #4
341a27f0:	f107 010c 	add.w	r1, r7, #12
341a27f4:	224c      	movs	r2, #76	@ 0x4c
341a27f6:	4618      	mov	r0, r3
341a27f8:	f002 fef5 	bl	341a55e6 <memcpy>
  SalXspi->CommandExtension = 0;
341a27fc:	687b      	ldr	r3, [r7, #4]
341a27fe:	2200      	movs	r2, #0
341a2800:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  SalXspi->PhyLink = PHY_LINK_1S1S1S;
341a2804:	687b      	ldr	r3, [r7, #4]
341a2806:	2200      	movs	r2, #0
341a2808:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
  HAL_XSPI_RegisterCallback(SalXspi->hxspi,HAL_XSPI_TX_CPLT_CB_ID, SAL_XSPI_CompleteCallback);
  /* set the error callback */
  HAL_XSPI_RegisterCallback(SalXspi->hxspi,HAL_XSPI_ERROR_CB_ID, SAL_XSPI_ErrorCallback);
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

  return HAL_OK;
341a280c:	2300      	movs	r3, #0
}
341a280e:	4618      	mov	r0, r3
341a2810:	3758      	adds	r7, #88	@ 0x58
341a2812:	46bd      	mov	sp, r7
341a2814:	bd80      	pop	{r7, pc}
	...

341a2818 <SAL_XSPI_MemoryConfig>:

HAL_StatusTypeDef SAL_XSPI_MemoryConfig(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_MemParamTypeTypeDef ParametersType, void *ParamVal)
{
341a2818:	b580      	push	{r7, lr}
341a281a:	b098      	sub	sp, #96	@ 0x60
341a281c:	af00      	add	r7, sp, #0
341a281e:	60f8      	str	r0, [r7, #12]
341a2820:	460b      	mov	r3, r1
341a2822:	607a      	str	r2, [r7, #4]
341a2824:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr = HAL_OK;
341a2826:	2300      	movs	r3, #0
341a2828:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  XSPI_RegularCmdTypeDef s_commandbase = SalXspi->Commandbase;
341a282c:	68fb      	ldr	r3, [r7, #12]
341a282e:	f107 0010 	add.w	r0, r7, #16
341a2832:	3304      	adds	r3, #4
341a2834:	224c      	movs	r2, #76	@ 0x4c
341a2836:	4619      	mov	r1, r3
341a2838:	f002 fed5 	bl	341a55e6 <memcpy>

  switch (ParametersType) {
341a283c:	7afb      	ldrb	r3, [r7, #11]
341a283e:	2b04      	cmp	r3, #4
341a2840:	f200 812a 	bhi.w	341a2a98 <SAL_XSPI_MemoryConfig+0x280>
341a2844:	a201      	add	r2, pc, #4	@ (adr r2, 341a284c <SAL_XSPI_MemoryConfig+0x34>)
341a2846:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a284a:	bf00      	nop
341a284c:	341a2861 	.word	0x341a2861
341a2850:	341a2a89 	.word	0x341a2a89
341a2854:	341a2a5b 	.word	0x341a2a5b
341a2858:	341a2a99 	.word	0x341a2a99
341a285c:	341a2a63 	.word	0x341a2a63
  case PARAM_PHY_LINK:{
    SalXspi->PhyLink = *((SAL_XSPI_PhysicalLinkTypeDef *)ParamVal);
341a2860:	687b      	ldr	r3, [r7, #4]
341a2862:	781a      	ldrb	r2, [r3, #0]
341a2864:	68fb      	ldr	r3, [r7, #12]
341a2866:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_PHY_LINK::");DEBUG_PARAM_DATA(STR_PHY_LINK(SalXspi->PhyLink));
    switch (SalXspi->PhyLink)
341a286a:	68fb      	ldr	r3, [r7, #12]
341a286c:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
341a2870:	2b0b      	cmp	r3, #11
341a2872:	f200 80ed 	bhi.w	341a2a50 <SAL_XSPI_MemoryConfig+0x238>
341a2876:	a201      	add	r2, pc, #4	@ (adr r2, 341a287c <SAL_XSPI_MemoryConfig+0x64>)
341a2878:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a287c:	341a28ad 	.word	0x341a28ad
341a2880:	341a28ad 	.word	0x341a28ad
341a2884:	341a28ad 	.word	0x341a28ad
341a2888:	341a28ad 	.word	0x341a28ad
341a288c:	341a28dd 	.word	0x341a28dd
341a2890:	341a28dd 	.word	0x341a28dd
341a2894:	341a290d 	.word	0x341a290d
341a2898:	341a2941 	.word	0x341a2941
341a289c:	341a2971 	.word	0x341a2971
341a28a0:	341a29a7 	.word	0x341a29a7
341a28a4:	341a29dd 	.word	0x341a29dd
341a28a8:	341a2a17 	.word	0x341a2a17
    {
    case PHY_LINK_1S1D1D:
    case PHY_LINK_1S2S2S:
    case PHY_LINK_1S1S2S:
    case PHY_LINK_1S1S1S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
341a28ac:	2301      	movs	r3, #1
341a28ae:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a28b0:	2300      	movs	r3, #0
341a28b2:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a28b4:	2300      	movs	r3, #0
341a28b6:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
341a28b8:	f44f 7380 	mov.w	r3, #256	@ 0x100
341a28bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a28be:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a28c2:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a28c4:	2300      	movs	r3, #0
341a28c6:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_1_LINE;
341a28c8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a28cc:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a28ce:	2300      	movs	r3, #0
341a28d0:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a28d2:	2308      	movs	r3, #8
341a28d4:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a28d6:	2300      	movs	r3, #0
341a28d8:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a28da:	e0bd      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }

    case PHY_LINK_4S4D4D:
    case PHY_LINK_4S4S4S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
341a28dc:	2303      	movs	r3, #3
341a28de:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a28e0:	2300      	movs	r3, #0
341a28e2:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a28e4:	2300      	movs	r3, #0
341a28e6:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
341a28e8:	f44f 7340 	mov.w	r3, #768	@ 0x300
341a28ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a28ee:	2300      	movs	r3, #0
341a28f0:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a28f2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a28f6:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
341a28f8:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a28fc:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a28fe:	2300      	movs	r3, #0
341a2900:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 6;
341a2902:	2306      	movs	r3, #6
341a2904:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a2906:	2300      	movs	r3, #0
341a2908:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a290a:	e0a5      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
      }
    case PHY_LINK_4D4D4D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
341a290c:	2303      	movs	r3, #3
341a290e:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a2910:	2300      	movs	r3, #0
341a2912:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
341a2914:	2308      	movs	r3, #8
341a2916:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
341a2918:	f44f 7340 	mov.w	r3, #768	@ 0x300
341a291c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a291e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a2922:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a2924:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a2928:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
341a292a:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a292e:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a2930:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a2934:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 6;
341a2936:	2306      	movs	r3, #6
341a2938:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a293a:	2300      	movs	r3, #0
341a293c:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a293e:	e08b      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_1S8S8S: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
341a2940:	2301      	movs	r3, #1
341a2942:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a2944:	2300      	movs	r3, #0
341a2946:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a2948:	2300      	movs	r3, #0
341a294a:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a294c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a2950:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a2952:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a2956:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
341a2958:	2300      	movs	r3, #0
341a295a:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a295c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a2960:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
341a2962:	2300      	movs	r3, #0
341a2964:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a2966:	2308      	movs	r3, #8
341a2968:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
341a296a:	2300      	movs	r3, #0
341a296c:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a296e:	e073      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_8S8D8D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
341a2970:	2304      	movs	r3, #4
341a2972:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
341a2974:	2300      	movs	r3, #0
341a2976:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a2978:	2300      	movs	r3, #0
341a297a:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a297c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a2980:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a2982:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a2986:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a2988:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a298c:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a298e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a2992:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a2994:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a2998:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 8;
341a299a:	2308      	movs	r3, #8
341a299c:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
341a299e:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a29a2:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a29a4:	e058      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }

    case PHY_LINK_8D8D8D: {
      s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
341a29a6:	2304      	movs	r3, #4
341a29a8:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
341a29aa:	2310      	movs	r3, #16
341a29ac:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
341a29ae:	2308      	movs	r3, #8
341a29b0:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
341a29b2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a29b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a29b8:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a29bc:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a29be:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a29c2:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
341a29c4:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a29c8:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
341a29ca:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a29ce:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles = 20;
341a29d0:	2314      	movs	r3, #20
341a29d2:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
341a29d4:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a29d8:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a29da:	e03d      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }
    case PHY_LINK_RAM8:{
      s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
341a29dc:	2304      	movs	r3, #4
341a29de:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
341a29e0:	2300      	movs	r3, #0
341a29e2:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a29e4:	2300      	movs	r3, #0
341a29e6:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
341a29e8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a29ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
341a29ee:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a29f2:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a29f4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a29f8:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341a29fa:	2300      	movs	r3, #0
341a29fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
      s_commandbase.DataMode           = HAL_XSPI_DATA_8_LINES;
341a29fe:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
341a2a02:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
341a2a04:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a2a08:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles        = 10;
341a2a0a:	230a      	movs	r3, #10
341a2a0c:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
341a2a0e:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a2a12:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a2a14:	e020      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }
#if defined(HAL_XSPI_DATA_16_LINES)
    case PHY_LINK_RAM16 :{
      s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
341a2a16:	2304      	movs	r3, #4
341a2a18:	61fb      	str	r3, [r7, #28]
      s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
341a2a1a:	2300      	movs	r3, #0
341a2a1c:	623b      	str	r3, [r7, #32]
      s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
341a2a1e:	2300      	movs	r3, #0
341a2a20:	627b      	str	r3, [r7, #36]	@ 0x24
      s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
341a2a22:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a2a26:	62fb      	str	r3, [r7, #44]	@ 0x2c
      s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
341a2a28:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a2a2c:	633b      	str	r3, [r7, #48]	@ 0x30
      s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a2a2e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a2a32:	637b      	str	r3, [r7, #52]	@ 0x34
      s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
341a2a34:	2300      	movs	r3, #0
341a2a36:	63fb      	str	r3, [r7, #60]	@ 0x3c
      s_commandbase.DataMode           = HAL_XSPI_DATA_16_LINES;
341a2a38:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
341a2a3c:	64bb      	str	r3, [r7, #72]	@ 0x48
      s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
341a2a3e:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a2a42:	653b      	str	r3, [r7, #80]	@ 0x50
      s_commandbase.DummyCycles        = 10;
341a2a44:	230a      	movs	r3, #10
341a2a46:	657b      	str	r3, [r7, #84]	@ 0x54
      s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
341a2a48:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a2a4c:	65bb      	str	r3, [r7, #88]	@ 0x58
      break;
341a2a4e:	e003      	b.n	341a2a58 <SAL_XSPI_MemoryConfig+0x240>
    }
#endif /* defined(HAL_XSPI_DATA_16_LINES) */
    default:
      retr = HAL_ERROR;
341a2a50:	2301      	movs	r3, #1
341a2a52:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
      break;
341a2a56:	bf00      	nop
    }
    DEBUG_PARAM_END();
    break;
341a2a58:	e022      	b.n	341a2aa0 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_ADDRESS_4BYTES: {
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_ADDRESS_4BYTES"); DEBUG_PARAM_END();
    s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
341a2a5a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a2a5e:	633b      	str	r3, [r7, #48]	@ 0x30
    break;
341a2a60:	e01e      	b.n	341a2aa0 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_FLASHSIZE:{
    uint8_t valParam = *((uint8_t *)ParamVal);
341a2a62:	687b      	ldr	r3, [r7, #4]
341a2a64:	781b      	ldrb	r3, [r3, #0]
341a2a66:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_FLASHSIZE::"); DEBUG_PARAM_INT(valParam); DEBUG_PARAM_END();
    MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_DEVSIZE, ((uint32_t)valParam) << XSPI_DCR1_DEVSIZE_Pos);
341a2a6a:	68fb      	ldr	r3, [r7, #12]
341a2a6c:	681b      	ldr	r3, [r3, #0]
341a2a6e:	681b      	ldr	r3, [r3, #0]
341a2a70:	689b      	ldr	r3, [r3, #8]
341a2a72:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
341a2a76:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
341a2a7a:	041a      	lsls	r2, r3, #16
341a2a7c:	68fb      	ldr	r3, [r7, #12]
341a2a7e:	681b      	ldr	r3, [r3, #0]
341a2a80:	681b      	ldr	r3, [r3, #0]
341a2a82:	430a      	orrs	r2, r1
341a2a84:	609a      	str	r2, [r3, #8]
    break;
341a2a86:	e00b      	b.n	341a2aa0 <SAL_XSPI_MemoryConfig+0x288>
  }
  case PARAM_DUMMY_CYCLES:{
    uint8_t valParam = *((uint8_t *)ParamVal);
341a2a88:	687b      	ldr	r3, [r7, #4]
341a2a8a:	781b      	ldrb	r3, [r3, #0]
341a2a8c:	f887 305d 	strb.w	r3, [r7, #93]	@ 0x5d
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::PARAM_DUMMY_CYCLES::"); DEBUG_PARAM_INT(valParam); DEBUG_PARAM_END();
    s_commandbase.DummyCycles = valParam;
341a2a90:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
341a2a94:	657b      	str	r3, [r7, #84]	@ 0x54
    break;
341a2a96:	e003      	b.n	341a2aa0 <SAL_XSPI_MemoryConfig+0x288>
  }
  default:
    DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::SAL_XSPI_MemoryConfig::ERROR"); DEBUG_PARAM_END();
    retr = HAL_ERROR;
341a2a98:	2301      	movs	r3, #1
341a2a9a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
    break;
341a2a9e:	bf00      	nop
  }
  SalXspi->Commandbase = s_commandbase;
341a2aa0:	68fb      	ldr	r3, [r7, #12]
341a2aa2:	3304      	adds	r3, #4
341a2aa4:	f107 0110 	add.w	r1, r7, #16
341a2aa8:	224c      	movs	r2, #76	@ 0x4c
341a2aaa:	4618      	mov	r0, r3
341a2aac:	f002 fd9b 	bl	341a55e6 <memcpy>
  return retr;
341a2ab0:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2ab4:	4618      	mov	r0, r3
341a2ab6:	3760      	adds	r7, #96	@ 0x60
341a2ab8:	46bd      	mov	sp, r7
341a2aba:	bd80      	pop	{r7, pc}

341a2abc <SAL_XSPI_GetSFDP>:

HAL_StatusTypeDef SAL_XSPI_GetSFDP(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t Address, uint8_t *Data, uint32_t DataSize)
{
341a2abc:	b580      	push	{r7, lr}
341a2abe:	b098      	sub	sp, #96	@ 0x60
341a2ac0:	af00      	add	r7, sp, #0
341a2ac2:	60f8      	str	r0, [r7, #12]
341a2ac4:	60b9      	str	r1, [r7, #8]
341a2ac6:	607a      	str	r2, [r7, #4]
341a2ac8:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a2aca:	68fb      	ldr	r3, [r7, #12]
341a2acc:	f107 0010 	add.w	r0, r7, #16
341a2ad0:	3304      	adds	r3, #4
341a2ad2:	224c      	movs	r2, #76	@ 0x4c
341a2ad4:	4619      	mov	r1, r3
341a2ad6:	f002 fd86 	bl	341a55e6 <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
341a2ada:	68fb      	ldr	r3, [r7, #12]
341a2adc:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2ae0:	6a39      	ldr	r1, [r7, #32]
341a2ae2:	225a      	movs	r2, #90	@ 0x5a
341a2ae4:	4618      	mov	r0, r3
341a2ae6:	f000 fb51 	bl	341a318c <XSPI_FormatCommand>
341a2aea:	4603      	mov	r3, r0
341a2aec:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_SFDP_COMMAND);

  s_command.Address     = Address;
341a2aee:	68bb      	ldr	r3, [r7, #8]
341a2af0:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength  = DataSize;
341a2af2:	683b      	ldr	r3, [r7, #0]
341a2af4:	64fb      	str	r3, [r7, #76]	@ 0x4c
  /* Nb of Dummy cycles for READ SFDP command does not correspond to SFDPDummyCycle field of SAL structure,
     as initialised after SFDP Header analysis */
  s_command.DummyCycles = EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_DEFAULT;
341a2af6:	2308      	movs	r3, #8
341a2af8:	657b      	str	r3, [r7, #84]	@ 0x54

  if (s_command.AddressMode == HAL_XSPI_ADDRESS_1_LINE)
341a2afa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
341a2afc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
341a2b00:	d102      	bne.n	341a2b08 <SAL_XSPI_GetSFDP+0x4c>
  {
    s_command.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
341a2b02:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
341a2b06:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
341a2b08:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a2b0a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a2b0e:	d103      	bne.n	341a2b18 <SAL_XSPI_GetSFDP+0x5c>
  {
    s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
341a2b10:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a2b14:	65bb      	str	r3, [r7, #88]	@ 0x58
341a2b16:	e001      	b.n	341a2b1c <SAL_XSPI_GetSFDP+0x60>
  }
  else
  {
    s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
341a2b18:	2300      	movs	r3, #0
341a2b1a:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2b1c:	68fb      	ldr	r3, [r7, #12]
341a2b1e:	681b      	ldr	r3, [r3, #0]
341a2b20:	f107 0110 	add.w	r1, r7, #16
341a2b24:	2264      	movs	r2, #100	@ 0x64
341a2b26:	4618      	mov	r0, r3
341a2b28:	f7f3 fd8c 	bl	34196644 <HAL_XSPI_Command>
341a2b2c:	4603      	mov	r3, r0
341a2b2e:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if ( retr  != HAL_OK)
341a2b32:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2b36:	2b00      	cmp	r3, #0
341a2b38:	d10a      	bne.n	341a2b50 <SAL_XSPI_GetSFDP+0x94>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2b3a:	68fb      	ldr	r3, [r7, #12]
341a2b3c:	681b      	ldr	r3, [r3, #0]
341a2b3e:	2264      	movs	r2, #100	@ 0x64
341a2b40:	6879      	ldr	r1, [r7, #4]
341a2b42:	4618      	mov	r0, r3
341a2b44:	f7f3 fe81 	bl	3419684a <HAL_XSPI_Receive>
341a2b48:	4603      	mov	r3, r0
341a2b4a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a2b4e:	e000      	b.n	341a2b52 <SAL_XSPI_GetSFDP+0x96>
    goto error;
341a2b50:	bf00      	nop

error:
  if (retr != HAL_OK )
341a2b52:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2b56:	2b00      	cmp	r3, #0
341a2b58:	d004      	beq.n	341a2b64 <SAL_XSPI_GetSFDP+0xa8>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2b5a:	68fb      	ldr	r3, [r7, #12]
341a2b5c:	681b      	ldr	r3, [r3, #0]
341a2b5e:	4618      	mov	r0, r3
341a2b60:	f7f4 f80c 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2b64:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2b68:	4618      	mov	r0, r3
341a2b6a:	3760      	adds	r7, #96	@ 0x60
341a2b6c:	46bd      	mov	sp, r7
341a2b6e:	bd80      	pop	{r7, pc}

341a2b70 <SAL_XSPI_GetId>:

HAL_StatusTypeDef SAL_XSPI_GetId(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t *Data, uint32_t DataSize)
{
341a2b70:	b580      	push	{r7, lr}
341a2b72:	b098      	sub	sp, #96	@ 0x60
341a2b74:	af00      	add	r7, sp, #0
341a2b76:	60f8      	str	r0, [r7, #12]
341a2b78:	60b9      	str	r1, [r7, #8]
341a2b7a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a2b7c:	68fb      	ldr	r3, [r7, #12]
341a2b7e:	f107 0010 	add.w	r0, r7, #16
341a2b82:	3304      	adds	r3, #4
341a2b84:	224c      	movs	r2, #76	@ 0x4c
341a2b86:	4619      	mov	r1, r3
341a2b88:	f002 fd2d 	bl	341a55e6 <memcpy>

  /* Initialize the Read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
341a2b8c:	68fb      	ldr	r3, [r7, #12]
341a2b8e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2b92:	6a39      	ldr	r1, [r7, #32]
341a2b94:	229f      	movs	r2, #159	@ 0x9f
341a2b96:	4618      	mov	r0, r3
341a2b98:	f000 faf8 	bl	341a318c <XSPI_FormatCommand>
341a2b9c:	4603      	mov	r3, r0
341a2b9e:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_JEDEC_ID_SPI_COMMAND);

  s_command.DataLength  = DataSize;
341a2ba0:	687b      	ldr	r3, [r7, #4]
341a2ba2:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
341a2ba4:	69fb      	ldr	r3, [r7, #28]
341a2ba6:	2b01      	cmp	r3, #1
341a2ba8:	d107      	bne.n	341a2bba <SAL_XSPI_GetId+0x4a>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a2baa:	2300      	movs	r3, #0
341a2bac:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
341a2bae:	2300      	movs	r3, #0
341a2bb0:	657b      	str	r3, [r7, #84]	@ 0x54
    /* this behavior is linked with micron memory to read ID in 1S8S8S */
    s_command.DataMode = HAL_XSPI_DATA_1_LINE;
341a2bb2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a2bb6:	64bb      	str	r3, [r7, #72]	@ 0x48
341a2bb8:	e030      	b.n	341a2c1c <SAL_XSPI_GetId+0xac>
  }
  else if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_4_LINES)
341a2bba:	69fb      	ldr	r3, [r7, #28]
341a2bbc:	2b03      	cmp	r3, #3
341a2bbe:	d107      	bne.n	341a2bd0 <SAL_XSPI_GetId+0x60>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a2bc0:	2300      	movs	r3, #0
341a2bc2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
341a2bc4:	2300      	movs	r3, #0
341a2bc6:	657b      	str	r3, [r7, #84]	@ 0x54
    /* this behavior is linked with ISSI memory to read ID in 4S4S4S */
    s_command.DataMode          = HAL_XSPI_DATA_4_LINES;
341a2bc8:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
341a2bcc:	64bb      	str	r3, [r7, #72]	@ 0x48
341a2bce:	e025      	b.n	341a2c1c <SAL_XSPI_GetId+0xac>
  }
  else if  (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_8_LINES)
341a2bd0:	69fb      	ldr	r3, [r7, #28]
341a2bd2:	2b04      	cmp	r3, #4
341a2bd4:	d11e      	bne.n	341a2c14 <SAL_XSPI_GetId+0xa4>
  {
    s_command.Address = 0;
341a2bd6:	2300      	movs	r3, #0
341a2bd8:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Specific case for Macronix memories : RDID is not Data DTR  */
    if ((Data[0] == 0xC2) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a2bda:	68bb      	ldr	r3, [r7, #8]
341a2bdc:	781b      	ldrb	r3, [r3, #0]
341a2bde:	2bc2      	cmp	r3, #194	@ 0xc2
341a2be0:	d108      	bne.n	341a2bf4 <SAL_XSPI_GetId+0x84>
341a2be2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a2be4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a2be8:	d104      	bne.n	341a2bf4 <SAL_XSPI_GetId+0x84>
    {
      s_command.DummyCycles       = 4;
341a2bea:	2304      	movs	r3, #4
341a2bec:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.DataDTRMode       = HAL_XSPI_DATA_DTR_DISABLE;
341a2bee:	2300      	movs	r3, #0
341a2bf0:	653b      	str	r3, [r7, #80]	@ 0x50
341a2bf2:	e013      	b.n	341a2c1c <SAL_XSPI_GetId+0xac>
    }
    /* Specific case for GigaDevice memories : RDID has no address even in Octal mode  */
    else if ((Data[0] == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a2bf4:	68bb      	ldr	r3, [r7, #8]
341a2bf6:	781b      	ldrb	r3, [r3, #0]
341a2bf8:	2bc8      	cmp	r3, #200	@ 0xc8
341a2bfa:	d108      	bne.n	341a2c0e <SAL_XSPI_GetId+0x9e>
341a2bfc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a2bfe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a2c02:	d104      	bne.n	341a2c0e <SAL_XSPI_GetId+0x9e>
    {
      s_command.DummyCycles       = 8;
341a2c04:	2308      	movs	r3, #8
341a2c06:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
341a2c08:	2300      	movs	r3, #0
341a2c0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
341a2c0c:	e006      	b.n	341a2c1c <SAL_XSPI_GetId+0xac>
    }
    else
    {
      s_command.DummyCycles = 8;
341a2c0e:	2308      	movs	r3, #8
341a2c10:	657b      	str	r3, [r7, #84]	@ 0x54
341a2c12:	e003      	b.n	341a2c1c <SAL_XSPI_GetId+0xac>
    }
    /* Required behavior to be confirmed on the other memories */
  }
  else
  {
    s_command.Address = 0;
341a2c14:	2300      	movs	r3, #0
341a2c16:	62bb      	str	r3, [r7, #40]	@ 0x28
    s_command.DummyCycles = 8;
341a2c18:	2308      	movs	r3, #8
341a2c1a:	657b      	str	r3, [r7, #84]	@ 0x54
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2c1c:	68fb      	ldr	r3, [r7, #12]
341a2c1e:	681b      	ldr	r3, [r3, #0]
341a2c20:	f107 0110 	add.w	r1, r7, #16
341a2c24:	2264      	movs	r2, #100	@ 0x64
341a2c26:	4618      	mov	r0, r3
341a2c28:	f7f3 fd0c 	bl	34196644 <HAL_XSPI_Command>
341a2c2c:	4603      	mov	r3, r0
341a2c2e:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if ( retr  != HAL_OK)
341a2c32:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2c36:	2b00      	cmp	r3, #0
341a2c38:	d10a      	bne.n	341a2c50 <SAL_XSPI_GetId+0xe0>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2c3a:	68fb      	ldr	r3, [r7, #12]
341a2c3c:	681b      	ldr	r3, [r3, #0]
341a2c3e:	2264      	movs	r2, #100	@ 0x64
341a2c40:	68b9      	ldr	r1, [r7, #8]
341a2c42:	4618      	mov	r0, r3
341a2c44:	f7f3 fe01 	bl	3419684a <HAL_XSPI_Receive>
341a2c48:	4603      	mov	r3, r0
341a2c4a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a2c4e:	e000      	b.n	341a2c52 <SAL_XSPI_GetId+0xe2>
    goto error;
341a2c50:	bf00      	nop

error:
  if (retr != HAL_OK )
341a2c52:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2c56:	2b00      	cmp	r3, #0
341a2c58:	d004      	beq.n	341a2c64 <SAL_XSPI_GetId+0xf4>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2c5a:	68fb      	ldr	r3, [r7, #12]
341a2c5c:	681b      	ldr	r3, [r3, #0]
341a2c5e:	4618      	mov	r0, r3
341a2c60:	f7f3 ff8c 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2c64:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2c68:	4618      	mov	r0, r3
341a2c6a:	3760      	adds	r7, #96	@ 0x60
341a2c6c:	46bd      	mov	sp, r7
341a2c6e:	bd80      	pop	{r7, pc}

341a2c70 <SAL_XSPI_Read>:

HAL_StatusTypeDef SAL_XSPI_Read(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address, uint8_t *Data, uint32_t DataSize)
{
341a2c70:	b580      	push	{r7, lr}
341a2c72:	b098      	sub	sp, #96	@ 0x60
341a2c74:	af00      	add	r7, sp, #0
341a2c76:	60f8      	str	r0, [r7, #12]
341a2c78:	607a      	str	r2, [r7, #4]
341a2c7a:	603b      	str	r3, [r7, #0]
341a2c7c:	460b      	mov	r3, r1
341a2c7e:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a2c80:	68fb      	ldr	r3, [r7, #12]
341a2c82:	f107 0010 	add.w	r0, r7, #16
341a2c86:	3304      	adds	r3, #4
341a2c88:	224c      	movs	r2, #76	@ 0x4c
341a2c8a:	4619      	mov	r1, r3
341a2c8c:	f002 fcab 	bl	341a55e6 <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a2c90:	68fb      	ldr	r3, [r7, #12]
341a2c92:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2c96:	6a39      	ldr	r1, [r7, #32]
341a2c98:	7afa      	ldrb	r2, [r7, #11]
341a2c9a:	4618      	mov	r0, r3
341a2c9c:	f000 fa76 	bl	341a318c <XSPI_FormatCommand>
341a2ca0:	4603      	mov	r3, r0
341a2ca2:	61bb      	str	r3, [r7, #24]

  s_command.Address           = Address;
341a2ca4:	687b      	ldr	r3, [r7, #4]
341a2ca6:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength        = DataSize;
341a2ca8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a2caa:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* DTR management for single/dual/quad */
  switch(SalXspi->PhyLink)
341a2cac:	68fb      	ldr	r3, [r7, #12]
341a2cae:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
341a2cb2:	2b05      	cmp	r3, #5
341a2cb4:	d006      	beq.n	341a2cc4 <SAL_XSPI_Read+0x54>
341a2cb6:	2b05      	cmp	r3, #5
341a2cb8:	dc1a      	bgt.n	341a2cf0 <SAL_XSPI_Read+0x80>
341a2cba:	2b01      	cmp	r3, #1
341a2cbc:	d014      	beq.n	341a2ce8 <SAL_XSPI_Read+0x78>
341a2cbe:	2b02      	cmp	r3, #2
341a2cc0:	d00b      	beq.n	341a2cda <SAL_XSPI_Read+0x6a>
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
   break;
   }
   default :{
     /* keep default parameters */
   break;
341a2cc2:	e015      	b.n	341a2cf0 <SAL_XSPI_Read+0x80>
     s_command.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
341a2cc4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
341a2cc8:	637b      	str	r3, [r7, #52]	@ 0x34
     s_command.DataDTRMode    = HAL_XSPI_DATA_DTR_ENABLE;
341a2cca:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
341a2cce:	653b      	str	r3, [r7, #80]	@ 0x50
     s_command.DummyCycles    = SalXspi->DTRDummyCycle;
341a2cd0:	68fb      	ldr	r3, [r7, #12]
341a2cd2:	f893 3053 	ldrb.w	r3, [r3, #83]	@ 0x53
341a2cd6:	657b      	str	r3, [r7, #84]	@ 0x54
   break;
341a2cd8:	e00b      	b.n	341a2cf2 <SAL_XSPI_Read+0x82>
     s_command.AddressMode    = HAL_XSPI_ADDRESS_2_LINES;
341a2cda:	f44f 7300 	mov.w	r3, #512	@ 0x200
341a2cde:	62fb      	str	r3, [r7, #44]	@ 0x2c
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
341a2ce0:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341a2ce4:	64bb      	str	r3, [r7, #72]	@ 0x48
   break;
341a2ce6:	e004      	b.n	341a2cf2 <SAL_XSPI_Read+0x82>
     s_command.DataMode       = HAL_XSPI_DATA_2_LINES;
341a2ce8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
341a2cec:	64bb      	str	r3, [r7, #72]	@ 0x48
   break;
341a2cee:	e000      	b.n	341a2cf2 <SAL_XSPI_Read+0x82>
   break;
341a2cf0:	bf00      	nop
   }
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2cf2:	68fb      	ldr	r3, [r7, #12]
341a2cf4:	681b      	ldr	r3, [r3, #0]
341a2cf6:	f107 0110 	add.w	r1, r7, #16
341a2cfa:	2264      	movs	r2, #100	@ 0x64
341a2cfc:	4618      	mov	r0, r3
341a2cfe:	f7f3 fca1 	bl	34196644 <HAL_XSPI_Command>
341a2d02:	4603      	mov	r3, r0
341a2d04:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (retr  != HAL_OK)
341a2d08:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2d0c:	2b00      	cmp	r3, #0
341a2d0e:	d107      	bne.n	341a2d20 <SAL_XSPI_Read+0xb0>
  {
    goto error;
  }

  /* read the data */
  retr = XSPI_Receive(SalXspi, Data);
341a2d10:	6839      	ldr	r1, [r7, #0]
341a2d12:	68f8      	ldr	r0, [r7, #12]
341a2d14:	f000 fa76 	bl	341a3204 <XSPI_Receive>
341a2d18:	4603      	mov	r3, r0
341a2d1a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a2d1e:	e000      	b.n	341a2d22 <SAL_XSPI_Read+0xb2>
    goto error;
341a2d20:	bf00      	nop

error:
  if (retr != HAL_OK )
341a2d22:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2d26:	2b00      	cmp	r3, #0
341a2d28:	d004      	beq.n	341a2d34 <SAL_XSPI_Read+0xc4>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2d2a:	68fb      	ldr	r3, [r7, #12]
341a2d2c:	681b      	ldr	r3, [r3, #0]
341a2d2e:	4618      	mov	r0, r3
341a2d30:	f7f3 ff24 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2d34:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2d38:	4618      	mov	r0, r3
341a2d3a:	3760      	adds	r7, #96	@ 0x60
341a2d3c:	46bd      	mov	sp, r7
341a2d3e:	bd80      	pop	{r7, pc}

341a2d40 <SAL_XSPI_Write>:

HAL_StatusTypeDef SAL_XSPI_Write(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address, const uint8_t *Data, uint32_t DataSize)
{
341a2d40:	b580      	push	{r7, lr}
341a2d42:	b098      	sub	sp, #96	@ 0x60
341a2d44:	af00      	add	r7, sp, #0
341a2d46:	60f8      	str	r0, [r7, #12]
341a2d48:	607a      	str	r2, [r7, #4]
341a2d4a:	603b      	str	r3, [r7, #0]
341a2d4c:	460b      	mov	r3, r1
341a2d4e:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a2d50:	68fb      	ldr	r3, [r7, #12]
341a2d52:	f107 0010 	add.w	r0, r7, #16
341a2d56:	3304      	adds	r3, #4
341a2d58:	224c      	movs	r2, #76	@ 0x4c
341a2d5a:	4619      	mov	r1, r3
341a2d5c:	f002 fc43 	bl	341a55e6 <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a2d60:	68fb      	ldr	r3, [r7, #12]
341a2d62:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2d66:	6a39      	ldr	r1, [r7, #32]
341a2d68:	7afa      	ldrb	r2, [r7, #11]
341a2d6a:	4618      	mov	r0, r3
341a2d6c:	f000 fa0e 	bl	341a318c <XSPI_FormatCommand>
341a2d70:	4603      	mov	r3, r0
341a2d72:	61bb      	str	r3, [r7, #24]

  s_command.Address           = Address;
341a2d74:	687b      	ldr	r3, [r7, #4]
341a2d76:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength        = DataSize;
341a2d78:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a2d7a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DummyCycles       = 0u;
341a2d7c:	2300      	movs	r3, #0
341a2d7e:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DQSMode           = HAL_XSPI_DQS_DISABLE;
341a2d80:	2300      	movs	r3, #0
341a2d82:	65bb      	str	r3, [r7, #88]	@ 0x58

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2d84:	68fb      	ldr	r3, [r7, #12]
341a2d86:	681b      	ldr	r3, [r3, #0]
341a2d88:	f107 0110 	add.w	r1, r7, #16
341a2d8c:	2264      	movs	r2, #100	@ 0x64
341a2d8e:	4618      	mov	r0, r3
341a2d90:	f7f3 fc58 	bl	34196644 <HAL_XSPI_Command>
341a2d94:	4603      	mov	r3, r0
341a2d96:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (HAL_OK != retr)
341a2d9a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2d9e:	2b00      	cmp	r3, #0
341a2da0:	d107      	bne.n	341a2db2 <SAL_XSPI_Write+0x72>
  {
    goto error;
  }

  /* transmit data */
  retr = XSPI_Transmit(SalXspi, Data);
341a2da2:	6839      	ldr	r1, [r7, #0]
341a2da4:	68f8      	ldr	r0, [r7, #12]
341a2da6:	f000 fa1a 	bl	341a31de <XSPI_Transmit>
341a2daa:	4603      	mov	r3, r0
341a2dac:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
341a2db0:	e000      	b.n	341a2db4 <SAL_XSPI_Write+0x74>
    goto error;
341a2db2:	bf00      	nop

error:
  if (retr != HAL_OK )
341a2db4:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2db8:	2b00      	cmp	r3, #0
341a2dba:	d004      	beq.n	341a2dc6 <SAL_XSPI_Write+0x86>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2dbc:	68fb      	ldr	r3, [r7, #12]
341a2dbe:	681b      	ldr	r3, [r3, #0]
341a2dc0:	4618      	mov	r0, r3
341a2dc2:	f7f3 fedb 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2dc6:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2dca:	4618      	mov	r0, r3
341a2dcc:	3760      	adds	r7, #96	@ 0x60
341a2dce:	46bd      	mov	sp, r7
341a2dd0:	bd80      	pop	{r7, pc}

341a2dd2 <SAL_XSPI_CommandSendData>:
  return retr;
}

HAL_StatusTypeDef SAL_XSPI_CommandSendData(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
341a2dd2:	b580      	push	{r7, lr}
341a2dd4:	b098      	sub	sp, #96	@ 0x60
341a2dd6:	af00      	add	r7, sp, #0
341a2dd8:	60f8      	str	r0, [r7, #12]
341a2dda:	607a      	str	r2, [r7, #4]
341a2ddc:	461a      	mov	r2, r3
341a2dde:	460b      	mov	r3, r1
341a2de0:	72fb      	strb	r3, [r7, #11]
341a2de2:	4613      	mov	r3, r2
341a2de4:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a2de6:	68fb      	ldr	r3, [r7, #12]
341a2de8:	f107 0010 	add.w	r0, r7, #16
341a2dec:	3304      	adds	r3, #4
341a2dee:	224c      	movs	r2, #76	@ 0x4c
341a2df0:	4619      	mov	r1, r3
341a2df2:	f002 fbf8 	bl	341a55e6 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the writing of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a2df6:	68fb      	ldr	r3, [r7, #12]
341a2df8:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2dfc:	6a39      	ldr	r1, [r7, #32]
341a2dfe:	7afa      	ldrb	r2, [r7, #11]
341a2e00:	4618      	mov	r0, r3
341a2e02:	f000 f9c3 	bl	341a318c <XSPI_FormatCommand>
341a2e06:	4603      	mov	r3, r0
341a2e08:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
341a2e0a:	2300      	movs	r3, #0
341a2e0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0U;
341a2e0e:	2300      	movs	r3, #0
341a2e10:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a2e12:	893b      	ldrh	r3, [r7, #8]
341a2e14:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
341a2e16:	2300      	movs	r3, #0
341a2e18:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
341a2e1a:	893b      	ldrh	r3, [r7, #8]
341a2e1c:	2b00      	cmp	r3, #0
341a2e1e:	d101      	bne.n	341a2e24 <SAL_XSPI_CommandSendData+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
341a2e20:	2300      	movs	r3, #0
341a2e22:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2e24:	68fb      	ldr	r3, [r7, #12]
341a2e26:	681b      	ldr	r3, [r3, #0]
341a2e28:	f107 0110 	add.w	r1, r7, #16
341a2e2c:	2264      	movs	r2, #100	@ 0x64
341a2e2e:	4618      	mov	r0, r3
341a2e30:	f7f3 fc08 	bl	34196644 <HAL_XSPI_Command>
341a2e34:	4603      	mov	r3, r0
341a2e36:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if (( retr == HAL_OK) && (DataSize != 0u))
341a2e3a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2e3e:	2b00      	cmp	r3, #0
341a2e40:	d10c      	bne.n	341a2e5c <SAL_XSPI_CommandSendData+0x8a>
341a2e42:	893b      	ldrh	r3, [r7, #8]
341a2e44:	2b00      	cmp	r3, #0
341a2e46:	d009      	beq.n	341a2e5c <SAL_XSPI_CommandSendData+0x8a>
  {
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2e48:	68fb      	ldr	r3, [r7, #12]
341a2e4a:	681b      	ldr	r3, [r3, #0]
341a2e4c:	2264      	movs	r2, #100	@ 0x64
341a2e4e:	6879      	ldr	r1, [r7, #4]
341a2e50:	4618      	mov	r0, r3
341a2e52:	f7f3 fc87 	bl	34196764 <HAL_XSPI_Transmit>
341a2e56:	4603      	mov	r3, r0
341a2e58:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a2e5c:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2e60:	2b00      	cmp	r3, #0
341a2e62:	d004      	beq.n	341a2e6e <SAL_XSPI_CommandSendData+0x9c>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2e64:	68fb      	ldr	r3, [r7, #12]
341a2e66:	681b      	ldr	r3, [r3, #0]
341a2e68:	4618      	mov	r0, r3
341a2e6a:	f7f3 fe87 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2e6e:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2e72:	4618      	mov	r0, r3
341a2e74:	3760      	adds	r7, #96	@ 0x60
341a2e76:	46bd      	mov	sp, r7
341a2e78:	bd80      	pop	{r7, pc}

341a2e7a <SAL_XSPI_SendReadCommand>:

HAL_StatusTypeDef SAL_XSPI_SendReadCommand(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
341a2e7a:	b580      	push	{r7, lr}
341a2e7c:	b098      	sub	sp, #96	@ 0x60
341a2e7e:	af00      	add	r7, sp, #0
341a2e80:	60f8      	str	r0, [r7, #12]
341a2e82:	607a      	str	r2, [r7, #4]
341a2e84:	461a      	mov	r2, r3
341a2e86:	460b      	mov	r3, r1
341a2e88:	72fb      	strb	r3, [r7, #11]
341a2e8a:	4613      	mov	r3, r2
341a2e8c:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a2e8e:	68fb      	ldr	r3, [r7, #12]
341a2e90:	f107 0010 	add.w	r0, r7, #16
341a2e94:	3304      	adds	r3, #4
341a2e96:	224c      	movs	r2, #76	@ 0x4c
341a2e98:	4619      	mov	r1, r3
341a2e9a:	f002 fba4 	bl	341a55e6 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a2e9e:	68fb      	ldr	r3, [r7, #12]
341a2ea0:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2ea4:	6a39      	ldr	r1, [r7, #32]
341a2ea6:	7afa      	ldrb	r2, [r7, #11]
341a2ea8:	4618      	mov	r0, r3
341a2eaa:	f000 f96f 	bl	341a318c <XSPI_FormatCommand>
341a2eae:	4603      	mov	r3, r0
341a2eb0:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
341a2eb2:	2300      	movs	r3, #0
341a2eb4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0u;
341a2eb6:	2300      	movs	r3, #0
341a2eb8:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a2eba:	893b      	ldrh	r3, [r7, #8]
341a2ebc:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
341a2ebe:	2300      	movs	r3, #0
341a2ec0:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
341a2ec2:	893b      	ldrh	r3, [r7, #8]
341a2ec4:	2b00      	cmp	r3, #0
341a2ec6:	d101      	bne.n	341a2ecc <SAL_XSPI_SendReadCommand+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
341a2ec8:	2300      	movs	r3, #0
341a2eca:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2ecc:	68fb      	ldr	r3, [r7, #12]
341a2ece:	681b      	ldr	r3, [r3, #0]
341a2ed0:	f107 0110 	add.w	r1, r7, #16
341a2ed4:	2264      	movs	r2, #100	@ 0x64
341a2ed6:	4618      	mov	r0, r3
341a2ed8:	f7f3 fbb4 	bl	34196644 <HAL_XSPI_Command>
341a2edc:	4603      	mov	r3, r0
341a2ede:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if (( retr == HAL_OK) && (DataSize != 0u))
341a2ee2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2ee6:	2b00      	cmp	r3, #0
341a2ee8:	d10c      	bne.n	341a2f04 <SAL_XSPI_SendReadCommand+0x8a>
341a2eea:	893b      	ldrh	r3, [r7, #8]
341a2eec:	2b00      	cmp	r3, #0
341a2eee:	d009      	beq.n	341a2f04 <SAL_XSPI_SendReadCommand+0x8a>
  {
    /* Get the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2ef0:	68fb      	ldr	r3, [r7, #12]
341a2ef2:	681b      	ldr	r3, [r3, #0]
341a2ef4:	2264      	movs	r2, #100	@ 0x64
341a2ef6:	6879      	ldr	r1, [r7, #4]
341a2ef8:	4618      	mov	r0, r3
341a2efa:	f7f3 fca6 	bl	3419684a <HAL_XSPI_Receive>
341a2efe:	4603      	mov	r3, r0
341a2f00:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a2f04:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2f08:	2b00      	cmp	r3, #0
341a2f0a:	d004      	beq.n	341a2f16 <SAL_XSPI_SendReadCommand+0x9c>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2f0c:	68fb      	ldr	r3, [r7, #12]
341a2f0e:	681b      	ldr	r3, [r3, #0]
341a2f10:	4618      	mov	r0, r3
341a2f12:	f7f3 fe33 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2f16:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2f1a:	4618      	mov	r0, r3
341a2f1c:	3760      	adds	r7, #96	@ 0x60
341a2f1e:	46bd      	mov	sp, r7
341a2f20:	bd80      	pop	{r7, pc}

341a2f22 <SAL_XSPI_CommandSendReadAddress>:

HAL_StatusTypeDef SAL_XSPI_CommandSendReadAddress(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                                  uint32_t Address, uint8_t *Data, uint16_t DataSize,
                                                  uint8_t ManuId)
{
341a2f22:	b580      	push	{r7, lr}
341a2f24:	b098      	sub	sp, #96	@ 0x60
341a2f26:	af00      	add	r7, sp, #0
341a2f28:	60f8      	str	r0, [r7, #12]
341a2f2a:	607a      	str	r2, [r7, #4]
341a2f2c:	603b      	str	r3, [r7, #0]
341a2f2e:	460b      	mov	r3, r1
341a2f30:	72fb      	strb	r3, [r7, #11]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
341a2f32:	68fb      	ldr	r3, [r7, #12]
341a2f34:	f107 0010 	add.w	r0, r7, #16
341a2f38:	3304      	adds	r3, #4
341a2f3a:	224c      	movs	r2, #76	@ 0x4c
341a2f3c:	4619      	mov	r1, r3
341a2f3e:	f002 fb52 	bl	341a55e6 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a2f42:	68fb      	ldr	r3, [r7, #12]
341a2f44:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a2f48:	6a39      	ldr	r1, [r7, #32]
341a2f4a:	7afa      	ldrb	r2, [r7, #11]
341a2f4c:	4618      	mov	r0, r3
341a2f4e:	f000 f91d 	bl	341a318c <XSPI_FormatCommand>
341a2f52:	4603      	mov	r3, r0
341a2f54:	61bb      	str	r3, [r7, #24]

  s_command.Address            = Address;
341a2f56:	687b      	ldr	r3, [r7, #4]
341a2f58:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DummyCycles        = SalXspi->SFDPDummyCycle;
341a2f5a:	68fb      	ldr	r3, [r7, #12]
341a2f5c:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
341a2f60:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
341a2f62:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
341a2f66:	64fb      	str	r3, [r7, #76]	@ 0x4c
  /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
  if ((ManuId == EXTMEM_MANFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a2f68:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
341a2f6c:	2bc2      	cmp	r3, #194	@ 0xc2
341a2f6e:	d106      	bne.n	341a2f7e <SAL_XSPI_CommandSendReadAddress+0x5c>
341a2f70:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a2f72:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a2f76:	d102      	bne.n	341a2f7e <SAL_XSPI_CommandSendReadAddress+0x5c>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
341a2f78:	2300      	movs	r3, #0
341a2f7a:	653b      	str	r3, [r7, #80]	@ 0x50
341a2f7c:	e00e      	b.n	341a2f9c <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  /* Specific case for GigaDevice memories : Read Configuration Register are not Data DTR  */
  else if ((ManuId == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a2f7e:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
341a2f82:	2bc8      	cmp	r3, #200	@ 0xc8
341a2f84:	d108      	bne.n	341a2f98 <SAL_XSPI_CommandSendReadAddress+0x76>
341a2f86:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
341a2f88:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a2f8c:	d104      	bne.n	341a2f98 <SAL_XSPI_CommandSendReadAddress+0x76>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
341a2f8e:	2300      	movs	r3, #0
341a2f90:	653b      	str	r3, [r7, #80]	@ 0x50
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
341a2f92:	2300      	movs	r3, #0
341a2f94:	65bb      	str	r3, [r7, #88]	@ 0x58
341a2f96:	e001      	b.n	341a2f9c <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  else
  {
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
341a2f98:	2300      	movs	r3, #0
341a2f9a:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2f9c:	68fb      	ldr	r3, [r7, #12]
341a2f9e:	681b      	ldr	r3, [r3, #0]
341a2fa0:	f107 0110 	add.w	r1, r7, #16
341a2fa4:	2264      	movs	r2, #100	@ 0x64
341a2fa6:	4618      	mov	r0, r3
341a2fa8:	f7f3 fb4c 	bl	34196644 <HAL_XSPI_Command>
341a2fac:	4603      	mov	r3, r0
341a2fae:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if ( retr == HAL_OK)
341a2fb2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2fb6:	2b00      	cmp	r3, #0
341a2fb8:	d109      	bne.n	341a2fce <SAL_XSPI_CommandSendReadAddress+0xac>
  {
    /* Get the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a2fba:	68fb      	ldr	r3, [r7, #12]
341a2fbc:	681b      	ldr	r3, [r3, #0]
341a2fbe:	2264      	movs	r2, #100	@ 0x64
341a2fc0:	6839      	ldr	r1, [r7, #0]
341a2fc2:	4618      	mov	r0, r3
341a2fc4:	f7f3 fc41 	bl	3419684a <HAL_XSPI_Receive>
341a2fc8:	4603      	mov	r3, r0
341a2fca:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK )
341a2fce:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
341a2fd2:	2b00      	cmp	r3, #0
341a2fd4:	d004      	beq.n	341a2fe0 <SAL_XSPI_CommandSendReadAddress+0xbe>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a2fd6:	68fb      	ldr	r3, [r7, #12]
341a2fd8:	681b      	ldr	r3, [r3, #0]
341a2fda:	4618      	mov	r0, r3
341a2fdc:	f7f3 fdce 	bl	34196b7c <HAL_XSPI_Abort>
  }
  return retr;
341a2fe0:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
341a2fe4:	4618      	mov	r0, r3
341a2fe6:	3760      	adds	r7, #96	@ 0x60
341a2fe8:	46bd      	mov	sp, r7
341a2fea:	bd80      	pop	{r7, pc}

341a2fec <SAL_XSPI_CheckStatusRegister>:

HAL_StatusTypeDef SAL_XSPI_CheckStatusRegister(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address,
                                               uint8_t MatchValue, uint8_t MatchMask, uint8_t ManuId,
                                               uint32_t Timeout)
{
341a2fec:	b580      	push	{r7, lr}
341a2fee:	b09e      	sub	sp, #120	@ 0x78
341a2ff0:	af00      	add	r7, sp, #0
341a2ff2:	60f8      	str	r0, [r7, #12]
341a2ff4:	607a      	str	r2, [r7, #4]
341a2ff6:	461a      	mov	r2, r3
341a2ff8:	460b      	mov	r3, r1
341a2ffa:	72fb      	strb	r3, [r7, #11]
341a2ffc:	4613      	mov	r3, r2
341a2ffe:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
341a3000:	68fb      	ldr	r3, [r7, #12]
341a3002:	f107 0028 	add.w	r0, r7, #40	@ 0x28
341a3006:	3304      	adds	r3, #4
341a3008:	224c      	movs	r2, #76	@ 0x4c
341a300a:	4619      	mov	r1, r3
341a300c:	f002 faeb 	bl	341a55e6 <memcpy>
  XSPI_AutoPollingTypeDef  s_config = {
341a3010:	7abb      	ldrb	r3, [r7, #10]
341a3012:	617b      	str	r3, [r7, #20]
341a3014:	f897 3080 	ldrb.w	r3, [r7, #128]	@ 0x80
341a3018:	61bb      	str	r3, [r7, #24]
341a301a:	2300      	movs	r3, #0
341a301c:	61fb      	str	r3, [r7, #28]
341a301e:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
341a3022:	623b      	str	r3, [r7, #32]
341a3024:	2310      	movs	r3, #16
341a3026:	627b      	str	r3, [r7, #36]	@ 0x24
                                       .IntervalTime  = 0x10
                                      };
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
341a3028:	68fb      	ldr	r3, [r7, #12]
341a302a:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
341a302e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
341a3030:	7afa      	ldrb	r2, [r7, #11]
341a3032:	4618      	mov	r0, r3
341a3034:	f000 f8aa 	bl	341a318c <XSPI_FormatCommand>
341a3038:	4603      	mov	r3, r0
341a303a:	633b      	str	r3, [r7, #48]	@ 0x30

  s_command.DataLength     = 1u;
341a303c:	2301      	movs	r3, #1
341a303e:	667b      	str	r3, [r7, #100]	@ 0x64
  s_command.DQSMode        = HAL_XSPI_DQS_DISABLE;
341a3040:	2300      	movs	r3, #0
341a3042:	673b      	str	r3, [r7, #112]	@ 0x70

  if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
341a3044:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
341a3046:	2b01      	cmp	r3, #1
341a3048:	d106      	bne.n	341a3058 <SAL_XSPI_CheckStatusRegister+0x6c>
  {
    /* patch cypress to force 1 line on status read */
    s_command.DataMode    = HAL_XSPI_DATA_1_LINE;
341a304a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a304e:	663b      	str	r3, [r7, #96]	@ 0x60
    s_command.AddressMode = HAL_XSPI_DATA_NONE;
341a3050:	2300      	movs	r3, #0
341a3052:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.DummyCycles = 0u;
341a3054:	2300      	movs	r3, #0
341a3056:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* @ is used only in 8 LINES format */
  if (s_command.DataMode == HAL_XSPI_DATA_8_LINES)
341a3058:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
341a305a:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
341a305e:	d114      	bne.n	341a308a <SAL_XSPI_CheckStatusRegister+0x9e>
  {
    /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
    if ((ManuId == EXTMEM_MANFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
341a3060:	f897 3084 	ldrb.w	r3, [r7, #132]	@ 0x84
341a3064:	2bc2      	cmp	r3, #194	@ 0xc2
341a3066:	d108      	bne.n	341a307a <SAL_XSPI_CheckStatusRegister+0x8e>
341a3068:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
341a306a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
341a306e:	d104      	bne.n	341a307a <SAL_XSPI_CheckStatusRegister+0x8e>
    {
      s_command.DQSMode        = HAL_XSPI_DQS_ENABLE;
341a3070:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
341a3074:	673b      	str	r3, [r7, #112]	@ 0x70
      s_command.DataDTRMode    = HAL_XSPI_DATA_DTR_DISABLE;
341a3076:	2300      	movs	r3, #0
341a3078:	66bb      	str	r3, [r7, #104]	@ 0x68
    }
    s_command.AddressMode    = HAL_XSPI_ADDRESS_8_LINES;
341a307a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a307e:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.AddressWidth   = HAL_XSPI_ADDRESS_32_BITS;
341a3080:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
341a3084:	64bb      	str	r3, [r7, #72]	@ 0x48
    s_command.Address        = Address;
341a3086:	687b      	ldr	r3, [r7, #4]
341a3088:	643b      	str	r3, [r7, #64]	@ 0x40
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a308a:	68fb      	ldr	r3, [r7, #12]
341a308c:	681b      	ldr	r3, [r3, #0]
341a308e:	f107 0128 	add.w	r1, r7, #40	@ 0x28
341a3092:	2264      	movs	r2, #100	@ 0x64
341a3094:	4618      	mov	r0, r3
341a3096:	f7f3 fad5 	bl	34196644 <HAL_XSPI_Command>
341a309a:	4603      	mov	r3, r0
341a309c:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
  if ( retr == HAL_OK)
341a30a0:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
341a30a4:	2b00      	cmp	r3, #0
341a30a6:	d10b      	bne.n	341a30c0 <SAL_XSPI_CheckStatusRegister+0xd4>
  {
    retr = HAL_XSPI_AutoPolling(SalXspi->hxspi, &s_config, Timeout);
341a30a8:	68fb      	ldr	r3, [r7, #12]
341a30aa:	681b      	ldr	r3, [r3, #0]
341a30ac:	f107 0114 	add.w	r1, r7, #20
341a30b0:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
341a30b4:	4618      	mov	r0, r3
341a30b6:	f7f3 fc6b 	bl	34196990 <HAL_XSPI_AutoPolling>
341a30ba:	4603      	mov	r3, r0
341a30bc:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    DEBUG_AUTOPOLLING(SalXspi->hxspi->Instance->DR, s_config.MatchValue, s_config.MatchMask)
  }

  if (retr != HAL_OK )
341a30c0:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
341a30c4:	2b00      	cmp	r3, #0
341a30c6:	d004      	beq.n	341a30d2 <SAL_XSPI_CheckStatusRegister+0xe6>
  {
    /* abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
341a30c8:	68fb      	ldr	r3, [r7, #12]
341a30ca:	681b      	ldr	r3, [r3, #0]
341a30cc:	4618      	mov	r0, r3
341a30ce:	f7f3 fd55 	bl	34196b7c <HAL_XSPI_Abort>
  }
  /* return status */
  return retr;
341a30d2:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
341a30d6:	4618      	mov	r0, r3
341a30d8:	3778      	adds	r7, #120	@ 0x78
341a30da:	46bd      	mov	sp, r7
341a30dc:	bd80      	pop	{r7, pc}

341a30de <SAL_XSPI_DisableMapMode>:
  /* return status */
  return retr;
}

HAL_StatusTypeDef SAL_XSPI_DisableMapMode(SAL_XSPI_ObjectTypeDef *SalXspi)
{
341a30de:	b580      	push	{r7, lr}
341a30e0:	b082      	sub	sp, #8
341a30e2:	af00      	add	r7, sp, #0
341a30e4:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dsb 0xF":::"memory");
341a30e6:	f3bf 8f4f 	dsb	sy
}
341a30ea:	bf00      	nop
  __DSB();
  return HAL_XSPI_Abort(SalXspi->hxspi);
341a30ec:	687b      	ldr	r3, [r7, #4]
341a30ee:	681b      	ldr	r3, [r3, #0]
341a30f0:	4618      	mov	r0, r3
341a30f2:	f7f3 fd43 	bl	34196b7c <HAL_XSPI_Abort>
341a30f6:	4603      	mov	r3, r0
}
341a30f8:	4618      	mov	r0, r3
341a30fa:	3708      	adds	r7, #8
341a30fc:	46bd      	mov	sp, r7
341a30fe:	bd80      	pop	{r7, pc}

341a3100 <SAL_XSPI_UpdateMemoryType>:


HAL_StatusTypeDef SAL_XSPI_UpdateMemoryType(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_DataOrderTypeDef DataOrder)
{
341a3100:	b480      	push	{r7}
341a3102:	b085      	sub	sp, #20
341a3104:	af00      	add	r7, sp, #0
341a3106:	6078      	str	r0, [r7, #4]
341a3108:	460b      	mov	r3, r1
341a310a:	70fb      	strb	r3, [r7, #3]
HAL_StatusTypeDef retr = HAL_OK;
341a310c:	2300      	movs	r3, #0
341a310e:	73fb      	strb	r3, [r7, #15]

  /* read the memory type value */
  uint32_t memorytype = READ_REG(SalXspi->hxspi->Instance->DCR1) & XSPI_DCR1_MTYP;
341a3110:	687b      	ldr	r3, [r7, #4]
341a3112:	681b      	ldr	r3, [r3, #0]
341a3114:	681b      	ldr	r3, [r3, #0]
341a3116:	689b      	ldr	r3, [r3, #8]
341a3118:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
341a311c:	60bb      	str	r3, [r7, #8]

  switch(DataOrder)
341a311e:	78fb      	ldrb	r3, [r7, #3]
341a3120:	2b00      	cmp	r3, #0
341a3122:	d11e      	bne.n	341a3162 <SAL_XSPI_UpdateMemoryType+0x62>
  {
  case SAL_XSPI_ORDERINVERTED :
    if (memorytype == HAL_XSPI_MEMTYPE_MICRON) {
341a3124:	68bb      	ldr	r3, [r7, #8]
341a3126:	2b00      	cmp	r3, #0
341a3128:	d103      	bne.n	341a3132 <SAL_XSPI_UpdateMemoryType+0x32>
      memorytype = HAL_XSPI_MEMTYPE_MACRONIX;
341a312a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
341a312e:	60bb      	str	r3, [r7, #8]
341a3130:	e008      	b.n	341a3144 <SAL_XSPI_UpdateMemoryType+0x44>
    } else if (memorytype == HAL_XSPI_MEMTYPE_MACRONIX) {
341a3132:	68bb      	ldr	r3, [r7, #8]
341a3134:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
341a3138:	d102      	bne.n	341a3140 <SAL_XSPI_UpdateMemoryType+0x40>
      memorytype = HAL_XSPI_MEMTYPE_MICRON;
341a313a:	2300      	movs	r3, #0
341a313c:	60bb      	str	r3, [r7, #8]
341a313e:	e001      	b.n	341a3144 <SAL_XSPI_UpdateMemoryType+0x44>
    } else {
      retr = HAL_ERROR;
341a3140:	2301      	movs	r3, #1
341a3142:	73fb      	strb	r3, [r7, #15]
    }
    MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_MTYP, memorytype);
341a3144:	687b      	ldr	r3, [r7, #4]
341a3146:	681b      	ldr	r3, [r3, #0]
341a3148:	681b      	ldr	r3, [r3, #0]
341a314a:	689b      	ldr	r3, [r3, #8]
341a314c:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
341a3150:	687b      	ldr	r3, [r7, #4]
341a3152:	681b      	ldr	r3, [r3, #0]
341a3154:	681b      	ldr	r3, [r3, #0]
341a3156:	68ba      	ldr	r2, [r7, #8]
341a3158:	430a      	orrs	r2, r1
341a315a:	609a      	str	r2, [r3, #8]
    break;
341a315c:	bf00      	nop
    return HAL_ERROR;
    break;
  }

  DEBUG_PARAM_BEGIN(); DEBUG_PARAM_DATA("::SAL_XSPI_UpdateMemoryType::"); DEBUG_PARAM_INT(memorytype); DEBUG_PARAM_END();
  return retr;
341a315e:	7bfb      	ldrb	r3, [r7, #15]
341a3160:	e000      	b.n	341a3164 <SAL_XSPI_UpdateMemoryType+0x64>
    return HAL_ERROR;
341a3162:	2301      	movs	r3, #1
}
341a3164:	4618      	mov	r0, r3
341a3166:	3714      	adds	r7, #20
341a3168:	46bd      	mov	sp, r7
341a316a:	f85d 7b04 	ldr.w	r7, [sp], #4
341a316e:	4770      	bx	lr

341a3170 <SAL_XSPI_Abort>:

HAL_StatusTypeDef SAL_XSPI_Abort(SAL_XSPI_ObjectTypeDef *SalXspi)
{
341a3170:	b580      	push	{r7, lr}
341a3172:	b082      	sub	sp, #8
341a3174:	af00      	add	r7, sp, #0
341a3176:	6078      	str	r0, [r7, #4]
  return HAL_XSPI_Abort(SalXspi->hxspi);
341a3178:	687b      	ldr	r3, [r7, #4]
341a317a:	681b      	ldr	r3, [r3, #0]
341a317c:	4618      	mov	r0, r3
341a317e:	f7f3 fcfd 	bl	34196b7c <HAL_XSPI_Abort>
341a3182:	4603      	mov	r3, r0
}
341a3184:	4618      	mov	r0, r3
341a3186:	3708      	adds	r7, #8
341a3188:	46bd      	mov	sp, r7
341a318a:	bd80      	pop	{r7, pc}

341a318c <XSPI_FormatCommand>:
  * @param InstructionWidth instruction width
  * @param Command command
  * @return the formatted command
  */
uint16_t XSPI_FormatCommand(uint8_t CommandExtension, uint32_t InstructionWidth, uint8_t Command)
{
341a318c:	b480      	push	{r7}
341a318e:	b085      	sub	sp, #20
341a3190:	af00      	add	r7, sp, #0
341a3192:	4603      	mov	r3, r0
341a3194:	6039      	str	r1, [r7, #0]
341a3196:	71fb      	strb	r3, [r7, #7]
341a3198:	4613      	mov	r3, r2
341a319a:	71bb      	strb	r3, [r7, #6]
  uint16_t retr;
  if  (InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS)
341a319c:	683b      	ldr	r3, [r7, #0]
341a319e:	2b10      	cmp	r3, #16
341a31a0:	d114      	bne.n	341a31cc <XSPI_FormatCommand+0x40>
  {
    /* 0b00 The Command Extension is the same as the Command. (The Command / Command Extension has the same value for the whole clock period.)*/
    /* 0b01 The Command Extension is the inverse of the Command. The Command Extension acts as a confirmation of the Command */
    /* 0b11 Command and Command Extension forms a 16 bit command word :: Not yet handled */
    retr = ((uint16_t)Command << 8u);
341a31a2:	79bb      	ldrb	r3, [r7, #6]
341a31a4:	b29b      	uxth	r3, r3
341a31a6:	021b      	lsls	r3, r3, #8
341a31a8:	81fb      	strh	r3, [r7, #14]
    if (CommandExtension == 1u)
341a31aa:	79fb      	ldrb	r3, [r7, #7]
341a31ac:	2b01      	cmp	r3, #1
341a31ae:	d107      	bne.n	341a31c0 <XSPI_FormatCommand+0x34>
    {
       retr|=  (uint8_t)(~Command & 0xFFu);
341a31b0:	79bb      	ldrb	r3, [r7, #6]
341a31b2:	43db      	mvns	r3, r3
341a31b4:	b2db      	uxtb	r3, r3
341a31b6:	461a      	mov	r2, r3
341a31b8:	89fb      	ldrh	r3, [r7, #14]
341a31ba:	4313      	orrs	r3, r2
341a31bc:	81fb      	strh	r3, [r7, #14]
341a31be:	e007      	b.n	341a31d0 <XSPI_FormatCommand+0x44>
    }
    else
    {
       retr|=  (uint8_t)(Command & 0xFFu);
341a31c0:	79bb      	ldrb	r3, [r7, #6]
341a31c2:	b29a      	uxth	r2, r3
341a31c4:	89fb      	ldrh	r3, [r7, #14]
341a31c6:	4313      	orrs	r3, r2
341a31c8:	81fb      	strh	r3, [r7, #14]
341a31ca:	e001      	b.n	341a31d0 <XSPI_FormatCommand+0x44>
    }
  }
  else
  {
    retr = Command;
341a31cc:	79bb      	ldrb	r3, [r7, #6]
341a31ce:	81fb      	strh	r3, [r7, #14]
  }

  return retr;
341a31d0:	89fb      	ldrh	r3, [r7, #14]
}
341a31d2:	4618      	mov	r0, r3
341a31d4:	3714      	adds	r7, #20
341a31d6:	46bd      	mov	sp, r7
341a31d8:	f85d 7b04 	ldr.w	r7, [sp], #4
341a31dc:	4770      	bx	lr

341a31de <XSPI_Transmit>:
  * @param SalXspi handle on the XSPI IP
  * @param Data data pointer
  * @return none
  */
HAL_StatusTypeDef XSPI_Transmit(SAL_XSPI_ObjectTypeDef *SalXspi, const uint8_t *Data)
{
341a31de:	b580      	push	{r7, lr}
341a31e0:	b084      	sub	sp, #16
341a31e2:	af00      	add	r7, sp, #0
341a31e4:	6078      	str	r0, [r7, #4]
341a31e6:	6039      	str	r1, [r7, #0]
#if defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U)
  if (SalXspi->hxspi->hdmatx == NULL)
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  {
    /* transmit data */
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a31e8:	687b      	ldr	r3, [r7, #4]
341a31ea:	681b      	ldr	r3, [r3, #0]
341a31ec:	2264      	movs	r2, #100	@ 0x64
341a31ee:	6839      	ldr	r1, [r7, #0]
341a31f0:	4618      	mov	r0, r3
341a31f2:	f7f3 fab7 	bl	34196764 <HAL_XSPI_Transmit>
341a31f6:	4603      	mov	r3, r0
341a31f8:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

  return retr;
341a31fa:	7bfb      	ldrb	r3, [r7, #15]
}
341a31fc:	4618      	mov	r0, r3
341a31fe:	3710      	adds	r7, #16
341a3200:	46bd      	mov	sp, r7
341a3202:	bd80      	pop	{r7, pc}

341a3204 <XSPI_Receive>:
  * @param SalXspi handle on the XSPI IP
  * @param Data data pointer
  * @return none
  */
HAL_StatusTypeDef XSPI_Receive(SAL_XSPI_ObjectTypeDef *SalXspi,  uint8_t *Data)
{
341a3204:	b580      	push	{r7, lr}
341a3206:	b084      	sub	sp, #16
341a3208:	af00      	add	r7, sp, #0
341a320a:	6078      	str	r0, [r7, #4]
341a320c:	6039      	str	r1, [r7, #0]
#if defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U)
  if (SalXspi->hxspi->hdmarx == NULL)
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  {
    /* Reception of the data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
341a320e:	687b      	ldr	r3, [r7, #4]
341a3210:	681b      	ldr	r3, [r3, #0]
341a3212:	2264      	movs	r2, #100	@ 0x64
341a3214:	6839      	ldr	r1, [r7, #0]
341a3216:	4618      	mov	r0, r3
341a3218:	f7f3 fb17 	bl	3419684a <HAL_XSPI_Receive>
341a321c:	4603      	mov	r3, r0
341a321e:	73fb      	strb	r3, [r7, #15]
        retr = HAL_ERROR;
      }
    }
  }
#endif /* (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */
  return retr;
341a3220:	7bfb      	ldrb	r3, [r7, #15]
}
341a3222:	4618      	mov	r0, r3
341a3224:	3710      	adds	r7, #16
341a3226:	46bd      	mov	sp, r7
341a3228:	bd80      	pop	{r7, pc}

341a322a <SFDP_ReadHeader>:
 * @param Object memory Object
 * @param sfdp_header data of the SFDP header
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef SFDP_ReadHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
341a322a:	b580      	push	{r7, lr}
341a322c:	b084      	sub	sp, #16
341a322e:	af00      	add	r7, sp, #0
341a3230:	6078      	str	r0, [r7, #4]
341a3232:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr;
  uint8_t retry_counter = 0;
341a3234:	2300      	movs	r3, #0
341a3236:	73bb      	strb	r3, [r7, #14]
  SFDP_DEBUG_STR(__func__);

  do {
    /* Reset the signature value */
    sfdp_header->Signature = 0;
341a3238:	683b      	ldr	r3, [r7, #0]
341a323a:	2200      	movs	r2, #0
341a323c:	601a      	str	r2, [r3, #0]

    /* send the SFDP command to read the header */
    if(HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, 0, (uint8_t*)sfdp_header, SFDP_HEADER_SIZE))
341a323e:	687b      	ldr	r3, [r7, #4]
341a3240:	f103 0008 	add.w	r0, r3, #8
341a3244:	2308      	movs	r3, #8
341a3246:	683a      	ldr	r2, [r7, #0]
341a3248:	2100      	movs	r1, #0
341a324a:	f7ff fc37 	bl	341a2abc <SAL_XSPI_GetSFDP>
341a324e:	4603      	mov	r3, r0
341a3250:	2b00      	cmp	r3, #0
341a3252:	d002      	beq.n	341a325a <SFDP_ReadHeader+0x30>
    {
      retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a3254:	2303      	movs	r3, #3
341a3256:	73fb      	strb	r3, [r7, #15]
      goto error;
341a3258:	e01f      	b.n	341a329a <SFDP_ReadHeader+0x70>
    }

    /* view the header signature value  */
    SFDP_DEBUG_INT("SFDP signature::", sfdp_header->Signature);

    switch(CheckSFDP_Signature(Object, sfdp_header->Signature))
341a325a:	683b      	ldr	r3, [r7, #0]
341a325c:	681b      	ldr	r3, [r3, #0]
341a325e:	4619      	mov	r1, r3
341a3260:	6878      	ldr	r0, [r7, #4]
341a3262:	f001 fc53 	bl	341a4b0c <CheckSFDP_Signature>
341a3266:	4603      	mov	r3, r0
341a3268:	2b00      	cmp	r3, #0
341a326a:	d002      	beq.n	341a3272 <SFDP_ReadHeader+0x48>
341a326c:	2b05      	cmp	r3, #5
341a326e:	d005      	beq.n	341a327c <SFDP_ReadHeader+0x52>
341a3270:	e00a      	b.n	341a3288 <SFDP_ReadHeader+0x5e>
    {
    case EXTMEM_SFDP_OK:
      SFDP_DEBUG_INT("param_number=", sfdp_header->param_number);
      SFDP_DEBUG_INT("AccessProtocol=", sfdp_header->AccessProtocol);
      retr = EXTMEM_SFDP_OK;
341a3272:	2300      	movs	r3, #0
341a3274:	73fb      	strb	r3, [r7, #15]
      retry_counter = 2u;
341a3276:	2302      	movs	r3, #2
341a3278:	73bb      	strb	r3, [r7, #14]
    break;
341a327a:	e00a      	b.n	341a3292 <SFDP_ReadHeader+0x68>
    case EXTMEM_SFDP_ERROR_SIGNATUREMTYPE:
      retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a327c:	2304      	movs	r3, #4
341a327e:	73fb      	strb	r3, [r7, #15]
      retry_counter++;
341a3280:	7bbb      	ldrb	r3, [r7, #14]
341a3282:	3301      	adds	r3, #1
341a3284:	73bb      	strb	r3, [r7, #14]
      break;
341a3286:	e004      	b.n	341a3292 <SFDP_ReadHeader+0x68>
    /* case EXTMEM_SFDP_ERROR_SIGNATURE :*/
    default :
      retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a3288:	2304      	movs	r3, #4
341a328a:	73fb      	strb	r3, [r7, #15]
      retry_counter = 2u;
341a328c:	2302      	movs	r3, #2
341a328e:	73bb      	strb	r3, [r7, #14]
      break;
341a3290:	bf00      	nop
    }
  } while(retry_counter < 2u);
341a3292:	7bbb      	ldrb	r3, [r7, #14]
341a3294:	2b01      	cmp	r3, #1
341a3296:	d9cf      	bls.n	341a3238 <SFDP_ReadHeader+0xe>

error:
341a3298:	bf00      	nop
  return retr;
341a329a:	7bfb      	ldrb	r3, [r7, #15]
}
341a329c:	4618      	mov	r0, r3
341a329e:	3710      	adds	r7, #16
341a32a0:	46bd      	mov	sp, r7
341a32a2:	bd80      	pop	{r7, pc}

341a32a4 <SFDP_GetHeader>:


SFDP_StatusTypeDef SFDP_GetHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
341a32a4:	b590      	push	{r4, r7, lr}
341a32a6:	b089      	sub	sp, #36	@ 0x24
341a32a8:	af00      	add	r7, sp, #0
341a32aa:	6078      	str	r0, [r7, #4]
341a32ac:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a32ae:	2304      	movs	r3, #4
341a32b0:	77fb      	strb	r3, [r7, #31]
  SFDP_DEBUG_STR(__func__);
  const TableConfig_Typedef table_config[] =
341a32b2:	4b2a      	ldr	r3, [pc, #168]	@ (341a335c <SFDP_GetHeader+0xb8>)
341a32b4:	f107 040c 	add.w	r4, r7, #12
341a32b8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
341a32ba:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    {PHY_LINK_8D8D8D, 10u},
    {PHY_LINK_8D8D8D, 16u}
  };

  /* loop to find the link configuration of the memory */
  for (uint8_t index = 0u;
341a32be:	2300      	movs	r3, #0
341a32c0:	77bb      	strb	r3, [r7, #30]
341a32c2:	e040      	b.n	341a3346 <SFDP_GetHeader+0xa2>
  {
    /* Set the command mode */
    SFDP_DEBUG_STR("try a command configuration");

    /* Configure the link */
    Object->sfdp_private.DriverInfo.SpiPhyLink  = table_config[index].PhyLink;
341a32c4:	7fbb      	ldrb	r3, [r7, #30]
341a32c6:	005b      	lsls	r3, r3, #1
341a32c8:	3320      	adds	r3, #32
341a32ca:	443b      	add	r3, r7
341a32cc:	f813 2c14 	ldrb.w	r2, [r3, #-20]
341a32d0:	687b      	ldr	r3, [r7, #4]
341a32d2:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
    (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink);
341a32d6:	687b      	ldr	r3, [r7, #4]
341a32d8:	f103 0008 	add.w	r0, r3, #8
341a32dc:	687b      	ldr	r3, [r7, #4]
341a32de:	3364      	adds	r3, #100	@ 0x64
341a32e0:	461a      	mov	r2, r3
341a32e2:	2100      	movs	r1, #0
341a32e4:	f7ff fa98 	bl	341a2818 <SAL_XSPI_MemoryConfig>
    SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, table_config[index].DummyCycle);
341a32e8:	7fbb      	ldrb	r3, [r7, #30]
341a32ea:	005b      	lsls	r3, r3, #1
341a32ec:	3320      	adds	r3, #32
341a32ee:	443b      	add	r3, r7
341a32f0:	f813 2c13 	ldrb.w	r2, [r3, #-19]
341a32f4:	687b      	ldr	r3, [r7, #4]
341a32f6:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

    /* Loop on the instruction extension */
    for (uint8_t IExt = 0u;
341a32fa:	2300      	movs	r3, #0
341a32fc:	777b      	strb	r3, [r7, #29]
341a32fe:	e017      	b.n	341a3330 <SFDP_GetHeader+0x8c>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
    {
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject, IExt);
341a3300:	687b      	ldr	r3, [r7, #4]
341a3302:	7f7a      	ldrb	r2, [r7, #29]
341a3304:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
      /* Read the sfdp header */
      if (EXTMEM_SFDP_OK == SFDP_ReadHeader(Object, sfdp_header))
341a3308:	6839      	ldr	r1, [r7, #0]
341a330a:	6878      	ldr	r0, [r7, #4]
341a330c:	f7ff ff8d 	bl	341a322a <SFDP_ReadHeader>
341a3310:	4603      	mov	r3, r0
341a3312:	2b00      	cmp	r3, #0
341a3314:	d101      	bne.n	341a331a <SFDP_GetHeader+0x76>
      {
        retr = EXTMEM_SFDP_OK;
341a3316:	2300      	movs	r3, #0
341a3318:	77fb      	strb	r3, [r7, #31]
      }

      if (table_config[index].PhyLink < PHY_LINK_4S4S4S)
341a331a:	7fbb      	ldrb	r3, [r7, #30]
341a331c:	005b      	lsls	r3, r3, #1
341a331e:	3320      	adds	r3, #32
341a3320:	443b      	add	r3, r7
341a3322:	f813 3c14 	ldrb.w	r3, [r3, #-20]
341a3326:	2b03      	cmp	r3, #3
341a3328:	d909      	bls.n	341a333e <SFDP_GetHeader+0x9a>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
341a332a:	7f7b      	ldrb	r3, [r7, #29]
341a332c:	3301      	adds	r3, #1
341a332e:	777b      	strb	r3, [r7, #29]
341a3330:	7f7b      	ldrb	r3, [r7, #29]
341a3332:	2b01      	cmp	r3, #1
341a3334:	d804      	bhi.n	341a3340 <SFDP_GetHeader+0x9c>
341a3336:	7ffb      	ldrb	r3, [r7, #31]
341a3338:	2b04      	cmp	r3, #4
341a333a:	d0e1      	beq.n	341a3300 <SFDP_GetHeader+0x5c>
341a333c:	e000      	b.n	341a3340 <SFDP_GetHeader+0x9c>
      {
        /* Config 1 is invalid so exit the loop */
        break;
341a333e:	bf00      	nop
           ; index++)
341a3340:	7fbb      	ldrb	r3, [r7, #30]
341a3342:	3301      	adds	r3, #1
341a3344:	77bb      	strb	r3, [r7, #30]
       (index < (sizeof(table_config)/sizeof(TableConfig_Typedef))) &&
341a3346:	7fbb      	ldrb	r3, [r7, #30]
341a3348:	2b07      	cmp	r3, #7
341a334a:	d802      	bhi.n	341a3352 <SFDP_GetHeader+0xae>
341a334c:	7ffb      	ldrb	r3, [r7, #31]
341a334e:	2b04      	cmp	r3, #4
341a3350:	d0b8      	beq.n	341a32c4 <SFDP_GetHeader+0x20>
      }
    }
  }
  return retr;
341a3352:	7ffb      	ldrb	r3, [r7, #31]
}
341a3354:	4618      	mov	r0, r3
341a3356:	3724      	adds	r7, #36	@ 0x24
341a3358:	46bd      	mov	sp, r7
341a335a:	bd90      	pop	{r4, r7, pc}
341a335c:	341a7db4 	.word	0x341a7db4

341a3360 <SFDP_CollectData>:

SFDP_StatusTypeDef SFDP_CollectData(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a3360:	b580      	push	{r7, lr}
341a3362:	b088      	sub	sp, #32
341a3364:	af00      	add	r7, sp, #0
341a3366:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a3368:	2300      	movs	r3, #0
341a336a:	77fb      	strb	r3, [r7, #31]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
341a336c:	2308      	movs	r3, #8
341a336e:	61bb      	str	r3, [r7, #24]
  SFDP_DEBUG_STR(__func__);

  /* reset the table mask */
  Object->sfdp_private.Sfdp_table_mask = 0;
341a3370:	687b      	ldr	r3, [r7, #4]
341a3372:	2200      	movs	r2, #0
341a3374:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

  /* reset the param info */
  (void)memset(sfdp_param_info, 0x0, sizeof(sfdp_param_info));
341a3378:	2278      	movs	r2, #120	@ 0x78
341a337a:	2100      	movs	r1, #0
341a337c:	485f      	ldr	r0, [pc, #380]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a337e:	f002 f8b7 	bl	341a54f0 <memset>

  /* get the table param info */
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a3382:	2300      	movs	r3, #0
341a3384:	75fb      	strb	r3, [r7, #23]
341a3386:	e027      	b.n	341a33d8 <SFDP_CollectData+0x78>
  {
    CHECK_FUNCTION_CALL(sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[index]))
341a3388:	7dfa      	ldrb	r2, [r7, #23]
341a338a:	4613      	mov	r3, r2
341a338c:	005b      	lsls	r3, r3, #1
341a338e:	4413      	add	r3, r2
341a3390:	009b      	lsls	r3, r3, #2
341a3392:	4a5a      	ldr	r2, [pc, #360]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a3394:	4413      	add	r3, r2
341a3396:	461a      	mov	r2, r3
341a3398:	69b9      	ldr	r1, [r7, #24]
341a339a:	6878      	ldr	r0, [r7, #4]
341a339c:	f000 ffe4 	bl	341a4368 <sfdp_get_paraminfo>
341a33a0:	4603      	mov	r3, r0
341a33a2:	77fb      	strb	r3, [r7, #31]
341a33a4:	7ffb      	ldrb	r3, [r7, #31]
341a33a6:	2b00      	cmp	r3, #0
341a33a8:	f040 80a2 	bne.w	341a34f0 <SFDP_CollectData+0x190>
    Object->sfdp_private.Sfdp_table_mask |= (uint32_t)sfdp_param_info[index].type;
341a33ac:	687b      	ldr	r3, [r7, #4]
341a33ae:	f8d3 1094 	ldr.w	r1, [r3, #148]	@ 0x94
341a33b2:	7dfa      	ldrb	r2, [r7, #23]
341a33b4:	4851      	ldr	r0, [pc, #324]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a33b6:	4613      	mov	r3, r2
341a33b8:	005b      	lsls	r3, r3, #1
341a33ba:	4413      	add	r3, r2
341a33bc:	009b      	lsls	r3, r3, #2
341a33be:	4403      	add	r3, r0
341a33c0:	681b      	ldr	r3, [r3, #0]
341a33c2:	ea41 0203 	orr.w	r2, r1, r3
341a33c6:	687b      	ldr	r3, [r7, #4]
341a33c8:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    sfdp_address+= SFDP_PARAM_HEADER_SIZE;
341a33cc:	69bb      	ldr	r3, [r7, #24]
341a33ce:	3308      	adds	r3, #8
341a33d0:	61bb      	str	r3, [r7, #24]
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a33d2:	7dfb      	ldrb	r3, [r7, #23]
341a33d4:	3301      	adds	r3, #1
341a33d6:	75fb      	strb	r3, [r7, #23]
341a33d8:	7dfa      	ldrb	r2, [r7, #23]
341a33da:	687b      	ldr	r3, [r7, #4]
341a33dc:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
341a33e0:	3301      	adds	r3, #1
341a33e2:	429a      	cmp	r2, r3
341a33e4:	d3d0      	bcc.n	341a3388 <SFDP_CollectData+0x28>
  }

  /* Read each table param to extract the information to build the driver */
  for (uint8_t index = 0u;  sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
341a33e6:	2300      	movs	r3, #0
341a33e8:	75bb      	strb	r3, [r7, #22]
341a33ea:	e075      	b.n	341a34d8 <SFDP_CollectData+0x178>
  {
    uint8_t *ptr = NULL;
341a33ec:	2300      	movs	r3, #0
341a33ee:	613b      	str	r3, [r7, #16]
    uint32_t size = sfdp_param_info[index].size;
341a33f0:	7dba      	ldrb	r2, [r7, #22]
341a33f2:	4942      	ldr	r1, [pc, #264]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a33f4:	4613      	mov	r3, r2
341a33f6:	005b      	lsls	r3, r3, #1
341a33f8:	4413      	add	r3, r2
341a33fa:	009b      	lsls	r3, r3, #2
341a33fc:	440b      	add	r3, r1
341a33fe:	3308      	adds	r3, #8
341a3400:	781b      	ldrb	r3, [r3, #0]
341a3402:	60fb      	str	r3, [r7, #12]
    switch(sfdp_param_info[index].type)
341a3404:	7dba      	ldrb	r2, [r7, #22]
341a3406:	493d      	ldr	r1, [pc, #244]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a3408:	4613      	mov	r3, r2
341a340a:	005b      	lsls	r3, r3, #1
341a340c:	4413      	add	r3, r2
341a340e:	009b      	lsls	r3, r3, #2
341a3410:	440b      	add	r3, r1
341a3412:	681b      	ldr	r3, [r3, #0]
341a3414:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
341a3418:	d029      	beq.n	341a346e <SFDP_CollectData+0x10e>
341a341a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
341a341e:	d829      	bhi.n	341a3474 <SFDP_CollectData+0x114>
341a3420:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a3424:	d01d      	beq.n	341a3462 <SFDP_CollectData+0x102>
341a3426:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a342a:	d823      	bhi.n	341a3474 <SFDP_CollectData+0x114>
341a342c:	2b80      	cmp	r3, #128	@ 0x80
341a342e:	d01b      	beq.n	341a3468 <SFDP_CollectData+0x108>
341a3430:	2b80      	cmp	r3, #128	@ 0x80
341a3432:	d81f      	bhi.n	341a3474 <SFDP_CollectData+0x114>
341a3434:	2b08      	cmp	r3, #8
341a3436:	d002      	beq.n	341a343e <SFDP_CollectData+0xde>
341a3438:	2b40      	cmp	r3, #64	@ 0x40
341a343a:	d00f      	beq.n	341a345c <SFDP_CollectData+0xfc>
    case SFDP_PARAMID_OCTAL_DDR:
      ptr = JEDEC_OctalDdr.data_BYTE;
      break;
    default :
      SFDP_DEBUG_STR("the table is not yet handled by the SW");
      break;
341a343c:	e01a      	b.n	341a3474 <SFDP_CollectData+0x114>
      JEDEC_Basic.size = sfdp_param_info[index].size;
341a343e:	7dba      	ldrb	r2, [r7, #22]
341a3440:	492e      	ldr	r1, [pc, #184]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a3442:	4613      	mov	r3, r2
341a3444:	005b      	lsls	r3, r3, #1
341a3446:	4413      	add	r3, r2
341a3448:	009b      	lsls	r3, r3, #2
341a344a:	440b      	add	r3, r1
341a344c:	3308      	adds	r3, #8
341a344e:	781b      	ldrb	r3, [r3, #0]
341a3450:	461a      	mov	r2, r3
341a3452:	4b2b      	ldr	r3, [pc, #172]	@ (341a3500 <SFDP_CollectData+0x1a0>)
341a3454:	601a      	str	r2, [r3, #0]
      ptr = JEDEC_Basic.Params.data_BYTE;
341a3456:	4b2b      	ldr	r3, [pc, #172]	@ (341a3504 <SFDP_CollectData+0x1a4>)
341a3458:	613b      	str	r3, [r7, #16]
      break;
341a345a:	e00c      	b.n	341a3476 <SFDP_CollectData+0x116>
      ptr = JEDEC_Address4Bytes.data_BYTE;
341a345c:	4b2a      	ldr	r3, [pc, #168]	@ (341a3508 <SFDP_CollectData+0x1a8>)
341a345e:	613b      	str	r3, [r7, #16]
      break;
341a3460:	e009      	b.n	341a3476 <SFDP_CollectData+0x116>
      ptr = JEDEC_SCCR_Map.data_b;
341a3462:	4b2a      	ldr	r3, [pc, #168]	@ (341a350c <SFDP_CollectData+0x1ac>)
341a3464:	613b      	str	r3, [r7, #16]
      break;
341a3466:	e006      	b.n	341a3476 <SFDP_CollectData+0x116>
      ptr = JEDEC_XSPI10.data_BYTE;
341a3468:	4b29      	ldr	r3, [pc, #164]	@ (341a3510 <SFDP_CollectData+0x1b0>)
341a346a:	613b      	str	r3, [r7, #16]
      break;
341a346c:	e003      	b.n	341a3476 <SFDP_CollectData+0x116>
      ptr = JEDEC_OctalDdr.data_BYTE;
341a346e:	4b29      	ldr	r3, [pc, #164]	@ (341a3514 <SFDP_CollectData+0x1b4>)
341a3470:	613b      	str	r3, [r7, #16]
      break;
341a3472:	e000      	b.n	341a3476 <SFDP_CollectData+0x116>
      break;
341a3474:	bf00      	nop
    }
    if (ptr != NULL)
341a3476:	693b      	ldr	r3, [r7, #16]
341a3478:	2b00      	cmp	r3, #0
341a347a:	d016      	beq.n	341a34aa <SFDP_CollectData+0x14a>
    {
      if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a347c:	687b      	ldr	r3, [r7, #4]
341a347e:	f103 0008 	add.w	r0, r3, #8
341a3482:	7dba      	ldrb	r2, [r7, #22]
341a3484:	491d      	ldr	r1, [pc, #116]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a3486:	4613      	mov	r3, r2
341a3488:	005b      	lsls	r3, r3, #1
341a348a:	4413      	add	r3, r2
341a348c:	009b      	lsls	r3, r3, #2
341a348e:	440b      	add	r3, r1
341a3490:	3304      	adds	r3, #4
341a3492:	6819      	ldr	r1, [r3, #0]
341a3494:	68fb      	ldr	r3, [r7, #12]
341a3496:	009b      	lsls	r3, r3, #2
341a3498:	693a      	ldr	r2, [r7, #16]
341a349a:	f7ff fb0f 	bl	341a2abc <SAL_XSPI_GetSFDP>
341a349e:	4603      	mov	r3, r0
341a34a0:	2b00      	cmp	r3, #0
341a34a2:	d002      	beq.n	341a34aa <SFDP_CollectData+0x14a>
                                     sfdp_param_info[index].address,
                                     ptr, size * 4u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
341a34a4:	230c      	movs	r3, #12
341a34a6:	77fb      	strb	r3, [r7, #31]
        goto error;
341a34a8:	e022      	b.n	341a34f0 <SFDP_CollectData+0x190>
      }
    }

    if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[index].type)
341a34aa:	7dba      	ldrb	r2, [r7, #22]
341a34ac:	4913      	ldr	r1, [pc, #76]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a34ae:	4613      	mov	r3, r2
341a34b0:	005b      	lsls	r3, r3, #1
341a34b2:	4413      	add	r3, r2
341a34b4:	009b      	lsls	r3, r3, #2
341a34b6:	440b      	add	r3, r1
341a34b8:	681b      	ldr	r3, [r3, #0]
341a34ba:	2b08      	cmp	r3, #8
341a34bc:	d109      	bne.n	341a34d2 <SFDP_CollectData+0x172>
    {
      /* save data about the reset procedure */
      Object->sfdp_private.Reset_info = JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support;
341a34be:	4b10      	ldr	r3, [pc, #64]	@ (341a3500 <SFDP_CollectData+0x1a0>)
341a34c0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a34c4:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a34c8:	b2db      	uxtb	r3, r3
341a34ca:	461a      	mov	r2, r3
341a34cc:	687b      	ldr	r3, [r7, #4]
341a34ce:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
  for (uint8_t index = 0u;  sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
341a34d2:	7dbb      	ldrb	r3, [r7, #22]
341a34d4:	3301      	adds	r3, #1
341a34d6:	75bb      	strb	r3, [r7, #22]
341a34d8:	7dba      	ldrb	r2, [r7, #22]
341a34da:	4908      	ldr	r1, [pc, #32]	@ (341a34fc <SFDP_CollectData+0x19c>)
341a34dc:	4613      	mov	r3, r2
341a34de:	005b      	lsls	r3, r3, #1
341a34e0:	4413      	add	r3, r2
341a34e2:	009b      	lsls	r3, r3, #2
341a34e4:	440b      	add	r3, r1
341a34e6:	681b      	ldr	r3, [r3, #0]
341a34e8:	2b00      	cmp	r3, #0
341a34ea:	f47f af7f 	bne.w	341a33ec <SFDP_CollectData+0x8c>
    }
  }

error:
341a34ee:	bf00      	nop
  return retr;
341a34f0:	7ffb      	ldrb	r3, [r7, #31]
}
341a34f2:	4618      	mov	r0, r3
341a34f4:	3720      	adds	r7, #32
341a34f6:	46bd      	mov	sp, r7
341a34f8:	bd80      	pop	{r7, pc}
341a34fa:	bf00      	nop
341a34fc:	341c1cdc 	.word	0x341c1cdc
341a3500:	341c1d54 	.word	0x341c1d54
341a3504:	341c1d58 	.word	0x341c1d58
341a3508:	341c1db4 	.word	0x341c1db4
341a350c:	341c1dd4 	.word	0x341c1dd4
341a3510:	341c1dbc 	.word	0x341c1dbc
341a3514:	341c1e44 	.word	0x341c1e44

341a3518 <SFDP_MemoryReset>:

SFDP_StatusTypeDef SFDP_MemoryReset(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a3518:	b580      	push	{r7, lr}
341a351a:	b086      	sub	sp, #24
341a351c:	af00      	add	r7, sp, #0
341a351e:	6078      	str	r0, [r7, #4]
  RESET_METHOD reset_method;
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
341a3520:	2307      	movs	r3, #7
341a3522:	75bb      	strb	r3, [r7, #22]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
341a3524:	2308      	movs	r3, #8
341a3526:	613b      	str	r3, [r7, #16]
  uint8_t find = 0u;
341a3528:	2300      	movs	r3, #0
341a352a:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR(__func__);

  /* get the table param info */
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a352c:	2300      	movs	r3, #0
341a352e:	73bb      	strb	r3, [r7, #14]
341a3530:	e02e      	b.n	341a3590 <SFDP_MemoryReset+0x78>
  {
    retr = sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[0]);
341a3532:	4a64      	ldr	r2, [pc, #400]	@ (341a36c4 <SFDP_MemoryReset+0x1ac>)
341a3534:	6939      	ldr	r1, [r7, #16]
341a3536:	6878      	ldr	r0, [r7, #4]
341a3538:	f000 ff16 	bl	341a4368 <sfdp_get_paraminfo>
341a353c:	4603      	mov	r3, r0
341a353e:	75bb      	strb	r3, [r7, #22]
    if (EXTMEM_SFDP_OK == retr)
341a3540:	7dbb      	ldrb	r3, [r7, #22]
341a3542:	2b00      	cmp	r3, #0
341a3544:	d118      	bne.n	341a3578 <SFDP_MemoryReset+0x60>
    {
      /* check if the table is basic table */
      if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[0].type)
341a3546:	4b5f      	ldr	r3, [pc, #380]	@ (341a36c4 <SFDP_MemoryReset+0x1ac>)
341a3548:	681b      	ldr	r3, [r3, #0]
341a354a:	2b08      	cmp	r3, #8
341a354c:	d114      	bne.n	341a3578 <SFDP_MemoryReset+0x60>
      {
        /* read the JEDEC basic param */
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a354e:	687b      	ldr	r3, [r7, #4]
341a3550:	f103 0008 	add.w	r0, r3, #8
341a3554:	4b5b      	ldr	r3, [pc, #364]	@ (341a36c4 <SFDP_MemoryReset+0x1ac>)
341a3556:	6859      	ldr	r1, [r3, #4]
                                       sfdp_param_info[0].address,
                                       JEDEC_Basic.Params.data_BYTE,
                                       ((uint32_t)sfdp_param_info[0].size) * 4u))
341a3558:	4b5a      	ldr	r3, [pc, #360]	@ (341a36c4 <SFDP_MemoryReset+0x1ac>)
341a355a:	7a1b      	ldrb	r3, [r3, #8]
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
341a355c:	009b      	lsls	r3, r3, #2
341a355e:	4a5a      	ldr	r2, [pc, #360]	@ (341a36c8 <SFDP_MemoryReset+0x1b0>)
341a3560:	f7ff faac 	bl	341a2abc <SAL_XSPI_GetSFDP>
341a3564:	4603      	mov	r3, r0
341a3566:	2b00      	cmp	r3, #0
341a3568:	d002      	beq.n	341a3570 <SFDP_MemoryReset+0x58>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a356a:	230c      	movs	r3, #12
341a356c:	75bb      	strb	r3, [r7, #22]
341a356e:	e003      	b.n	341a3578 <SFDP_MemoryReset+0x60>
        }
        else
        {
          retr = EXTMEM_SFDP_OK;
341a3570:	2300      	movs	r3, #0
341a3572:	75bb      	strb	r3, [r7, #22]
          find = 1u;
341a3574:	2301      	movs	r3, #1
341a3576:	73fb      	strb	r3, [r7, #15]
        }
      }
    }

    if ((EXTMEM_SFDP_OK != retr) || (1u == find))
341a3578:	7dbb      	ldrb	r3, [r7, #22]
341a357a:	2b00      	cmp	r3, #0
341a357c:	d10f      	bne.n	341a359e <SFDP_MemoryReset+0x86>
341a357e:	7bfb      	ldrb	r3, [r7, #15]
341a3580:	2b01      	cmp	r3, #1
341a3582:	d00c      	beq.n	341a359e <SFDP_MemoryReset+0x86>
    {
        /* stop the read, if there is an error or if the table has been found */
        break;
    }
    /* look for the next table */
    sfdp_address+= SFDP_PARAM_HEADER_SIZE;
341a3584:	693b      	ldr	r3, [r7, #16]
341a3586:	3308      	adds	r3, #8
341a3588:	613b      	str	r3, [r7, #16]
  for(uint8_t index = 0u; index <  (Object->sfdp_private.Sfdp_param_number + 1u); index++)
341a358a:	7bbb      	ldrb	r3, [r7, #14]
341a358c:	3301      	adds	r3, #1
341a358e:	73bb      	strb	r3, [r7, #14]
341a3590:	7bba      	ldrb	r2, [r7, #14]
341a3592:	687b      	ldr	r3, [r7, #4]
341a3594:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
341a3598:	3301      	adds	r3, #1
341a359a:	429a      	cmp	r2, r3
341a359c:	d3c9      	bcc.n	341a3532 <SFDP_MemoryReset+0x1a>
  }

  /* if an error has been returned or if the table has not been found */
  if ((EXTMEM_SFDP_OK != retr) || (0u == find))
341a359e:	7dbb      	ldrb	r3, [r7, #22]
341a35a0:	2b00      	cmp	r3, #0
341a35a2:	d102      	bne.n	341a35aa <SFDP_MemoryReset+0x92>
341a35a4:	7bfb      	ldrb	r3, [r7, #15]
341a35a6:	2b00      	cmp	r3, #0
341a35a8:	d102      	bne.n	341a35b0 <SFDP_MemoryReset+0x98>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a35aa:	230c      	movs	r3, #12
341a35ac:	75bb      	strb	r3, [r7, #22]
    goto error;
341a35ae:	e083      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
  }

  /* determine how to proceed memory reset */
  if( 0x0u == JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support)
341a35b0:	4b46      	ldr	r3, [pc, #280]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a35b2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a35b6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
341a35ba:	b2db      	uxtb	r3, r3
341a35bc:	2b00      	cmp	r3, #0
341a35be:	d102      	bne.n	341a35c6 <SFDP_MemoryReset+0xae>
  {
    /* 00_0000b: no software reset instruction is supported */
    reset_method = RESET_NONE;
341a35c0:	2300      	movs	r3, #0
341a35c2:	75fb      	strb	r3, [r7, #23]
341a35c4:	e053      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x1u == (0x1u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a35c6:	4b41      	ldr	r3, [pc, #260]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a35c8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a35cc:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a35d0:	b2db      	uxtb	r3, r3
341a35d2:	f003 0301 	and.w	r3, r3, #1
341a35d6:	b2db      	uxtb	r3, r3
341a35d8:	2b00      	cmp	r3, #0
341a35da:	d002      	beq.n	341a35e2 <SFDP_MemoryReset+0xca>
  {
    /* xx_xxx1b: drive Fh on all 4 data wires for 8 clocks */
    reset_method = RESET_Fh_4DATA_8CLOCK;
341a35dc:	2301      	movs	r3, #1
341a35de:	75fb      	strb	r3, [r7, #23]
341a35e0:	e045      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x2u == (0x2u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a35e2:	4b3a      	ldr	r3, [pc, #232]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a35e4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a35e8:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a35ec:	b2db      	uxtb	r3, r3
341a35ee:	f003 0302 	and.w	r3, r3, #2
341a35f2:	b2db      	uxtb	r3, r3
341a35f4:	2b00      	cmp	r3, #0
341a35f6:	d002      	beq.n	341a35fe <SFDP_MemoryReset+0xe6>
  {
    /* xx_xx1xb: drive Fh on all 4 data wires for 10 clocks if device is operating in 4-byte address mode */
    reset_method = RESET_Fh_4DATA_10CLOCK;
341a35f8:	2302      	movs	r3, #2
341a35fa:	75fb      	strb	r3, [r7, #23]
341a35fc:	e037      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x4u == (0x4u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a35fe:	4b33      	ldr	r3, [pc, #204]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a3600:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a3604:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a3608:	b2db      	uxtb	r3, r3
341a360a:	f003 0304 	and.w	r3, r3, #4
341a360e:	b2db      	uxtb	r3, r3
341a3610:	2b00      	cmp	r3, #0
341a3612:	d002      	beq.n	341a361a <SFDP_MemoryReset+0x102>
  {
    /* xx_x1xxb: drive Fh on all 4 data wires for 16 clocks */
    reset_method = RESET_Fh_4DATA_16CLOCK;
341a3614:	2303      	movs	r3, #3
341a3616:	75fb      	strb	r3, [r7, #23]
341a3618:	e029      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x8u == (0x8u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a361a:	4b2c      	ldr	r3, [pc, #176]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a361c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a3620:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a3624:	b2db      	uxtb	r3, r3
341a3626:	f003 0308 	and.w	r3, r3, #8
341a362a:	b2db      	uxtb	r3, r3
341a362c:	2b00      	cmp	r3, #0
341a362e:	d002      	beq.n	341a3636 <SFDP_MemoryReset+0x11e>
  {
    /* xx_1xxxb: issue instruction F0h */
    reset_method = RESET_INSTRUCTION_F0;
341a3630:	2304      	movs	r3, #4
341a3632:	75fb      	strb	r3, [r7, #23]
341a3634:	e01b      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x10u == (0x10u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a3636:	4b25      	ldr	r3, [pc, #148]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a3638:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a363c:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a3640:	b2db      	uxtb	r3, r3
341a3642:	f003 0310 	and.w	r3, r3, #16
341a3646:	b2db      	uxtb	r3, r3
341a3648:	2b00      	cmp	r3, #0
341a364a:	d002      	beq.n	341a3652 <SFDP_MemoryReset+0x13a>
  {
    /* x1_xxxxb: issue reset enable instruction 66h, then issue reset instruction 99h. The reset enable,
    reset sequence may be issued on 1, 2, or 4 wires depending on the device operating mode.
    */
    reset_method = RESET_INSTRUCTION_66_99;
341a364c:	2305      	movs	r3, #5
341a364e:	75fb      	strb	r3, [r7, #23]
341a3650:	e00d      	b.n	341a366e <SFDP_MemoryReset+0x156>
  }
  else if (0x20u == (0x20u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
341a3652:	4b1e      	ldr	r3, [pc, #120]	@ (341a36cc <SFDP_MemoryReset+0x1b4>)
341a3654:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
341a3658:	f3c3 0305 	ubfx	r3, r3, #0, #6
341a365c:	b2db      	uxtb	r3, r3
341a365e:	2b1f      	cmp	r3, #31
341a3660:	d902      	bls.n	341a3668 <SFDP_MemoryReset+0x150>
    xx_xx1x_xxxxb: Hardware reset
    xx_x1xx_xxxxb: Software reset (see bits 13:8 in this DWORD)
    xx_1xxx_xxxxb: Power cycle
    x1_xxxx_xxxxb: Reserved
    */
    retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a3662:	230f      	movs	r3, #15
341a3664:	75bb      	strb	r3, [r7, #22]
    goto error;
341a3666:	e027      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
  }
  else
  {
    /* no coherence, should be managed as error */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3668:	230c      	movs	r3, #12
341a366a:	75bb      	strb	r3, [r7, #22]
    goto error;
341a366c:	e024      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
  }

  switch(reset_method)
341a366e:	7dfb      	ldrb	r3, [r7, #23]
341a3670:	2b05      	cmp	r3, #5
341a3672:	d009      	beq.n	341a3688 <SFDP_MemoryReset+0x170>
341a3674:	2b05      	cmp	r3, #5
341a3676:	dc1b      	bgt.n	341a36b0 <SFDP_MemoryReset+0x198>
341a3678:	2b00      	cmp	r3, #0
341a367a:	d01c      	beq.n	341a36b6 <SFDP_MemoryReset+0x19e>
341a367c:	2b00      	cmp	r3, #0
341a367e:	db17      	blt.n	341a36b0 <SFDP_MemoryReset+0x198>
341a3680:	3b01      	subs	r3, #1
341a3682:	2b03      	cmp	r3, #3
341a3684:	d814      	bhi.n	341a36b0 <SFDP_MemoryReset+0x198>
341a3686:	e010      	b.n	341a36aa <SFDP_MemoryReset+0x192>
  case RESET_NONE:
    break;
  case RESET_INSTRUCTION_66_99:
    /* perform the reset in 1, 2 and 4 lines */
    SFDP_DEBUG_STR("::reset 0x66 0x99");
    (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x66, NULL, 0);
341a3688:	687b      	ldr	r3, [r7, #4]
341a368a:	f103 0008 	add.w	r0, r3, #8
341a368e:	2300      	movs	r3, #0
341a3690:	2200      	movs	r2, #0
341a3692:	2166      	movs	r1, #102	@ 0x66
341a3694:	f7ff fb9d 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
    (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x99, NULL, 0);
341a3698:	687b      	ldr	r3, [r7, #4]
341a369a:	f103 0008 	add.w	r0, r3, #8
341a369e:	2300      	movs	r3, #0
341a36a0:	2200      	movs	r2, #0
341a36a2:	2199      	movs	r1, #153	@ 0x99
341a36a4:	f7ff fb95 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
    break;
341a36a8:	e006      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
  case RESET_INSTRUCTION_F0:
  case RESET_Fh_4DATA_8CLOCK:
  case RESET_Fh_4DATA_10CLOCK:
  case RESET_Fh_4DATA_16CLOCK:
    retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a36aa:	230f      	movs	r3, #15
341a36ac:	75bb      	strb	r3, [r7, #22]
    break;
341a36ae:	e003      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
  /* case RESET_ERROR:*/
  default :
    retr = EXTMEM_SFDP_ERROR_PARAM;
341a36b0:	2301      	movs	r3, #1
341a36b2:	75bb      	strb	r3, [r7, #22]
    break;
341a36b4:	e000      	b.n	341a36b8 <SFDP_MemoryReset+0x1a0>
    break;
341a36b6:	bf00      	nop
  }
error :
  return retr;
341a36b8:	7dbb      	ldrb	r3, [r7, #22]
}
341a36ba:	4618      	mov	r0, r3
341a36bc:	3718      	adds	r7, #24
341a36be:	46bd      	mov	sp, r7
341a36c0:	bd80      	pop	{r7, pc}
341a36c2:	bf00      	nop
341a36c4:	341c1cdc 	.word	0x341c1cdc
341a36c8:	341c1d58 	.word	0x341c1d58
341a36cc:	341c1d54 	.word	0x341c1d54

341a36d0 <SFDP_BuildGenericDriver>:

SFDP_StatusTypeDef SFDP_BuildGenericDriver(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint8_t *FreqUpdated)
{
341a36d0:	b5f0      	push	{r4, r5, r6, r7, lr}
341a36d2:	b08f      	sub	sp, #60	@ 0x3c
341a36d4:	af04      	add	r7, sp, #16
341a36d6:	6078      	str	r0, [r7, #4]
341a36d8:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a36da:	2300      	movs	r3, #0
341a36dc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  static const uint16_t block_erase_unit[] = { 16u, 256u, 4000u, 64000u};
  static const uint32_t chip_erase_unit[]  = { 16u, 256u, 4000u, 64000u};
  SFDP_DEBUG_STR(__func__);
  uint8_t flag4byteAddress = 0u;
341a36e0:	2300      	movs	r3, #0
341a36e2:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint32_t dummyCycles, dummyCyclesValue;
  uint8_t FlashSize;

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL) != (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
341a36e6:	687b      	ldr	r3, [r7, #4]
341a36e8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a36ec:	f003 0308 	and.w	r3, r3, #8
341a36f0:	2b00      	cmp	r3, #0
341a36f2:	d104      	bne.n	341a36fe <SFDP_BuildGenericDriver+0x2e>
  {
    /* This table is mandatory to build the driver data */
    retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
341a36f4:	2307      	movs	r3, #7
341a36f6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a36fa:	f000 bdbd 	b.w	341a4278 <SFDP_BuildGenericDriver+0xba8>
  /* ---------------------------------------------------
   *  Flash sizing
   * ---------------------------------------------------
   */
  /* Calculation of the flash density in puissance of 2 */
  if ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x80000000u) == 0x0u)
341a36fe:	4bba      	ldr	r3, [pc, #744]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3700:	689b      	ldr	r3, [r3, #8]
341a3702:	2b00      	cmp	r3, #0
341a3704:	db13      	blt.n	341a372e <SFDP_BuildGenericDriver+0x5e>
  {
#if( __CORTEX_M == 0)
#error "the assembly instruction is not available"
#else
    Object->sfdp_private.FlashSize = 31u - (uint8_t)__CLZ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize + 1u));
341a3706:	4bb8      	ldr	r3, [pc, #736]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3708:	689b      	ldr	r3, [r3, #8]
341a370a:	3301      	adds	r3, #1
341a370c:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
341a370e:	69bb      	ldr	r3, [r7, #24]
341a3710:	2b00      	cmp	r3, #0
341a3712:	d101      	bne.n	341a3718 <SFDP_BuildGenericDriver+0x48>
    return 32U;
341a3714:	2320      	movs	r3, #32
341a3716:	e003      	b.n	341a3720 <SFDP_BuildGenericDriver+0x50>
  return __builtin_clz(value);
341a3718:	69bb      	ldr	r3, [r7, #24]
341a371a:	fab3 f383 	clz	r3, r3
341a371e:	b2db      	uxtb	r3, r3
341a3720:	f1c3 031f 	rsb	r3, r3, #31
341a3724:	b2da      	uxtb	r2, r3
341a3726:	687b      	ldr	r3, [r7, #4]
341a3728:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
341a372c:	e005      	b.n	341a373a <SFDP_BuildGenericDriver+0x6a>
#endif /* __CORTEX_M */
  }
  else
  {
    Object->sfdp_private.FlashSize = (uint8_t)(JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x7FFFFFFFu);
341a372e:	4bae      	ldr	r3, [pc, #696]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3730:	689b      	ldr	r3, [r3, #8]
341a3732:	b2da      	uxtb	r2, r3
341a3734:	687b      	ldr	r3, [r7, #4]
341a3736:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
  }

  /* Conversion bit to byte */
  Object->sfdp_private.FlashSize = Object->sfdp_private.FlashSize - 3u; /* divide by eight the value */
341a373a:	687b      	ldr	r3, [r7, #4]
341a373c:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
341a3740:	3b03      	subs	r3, #3
341a3742:	b2da      	uxtb	r2, r3
341a3744:	687b      	ldr	r3, [r7, #4]
341a3746:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e

  SFDP_DEBUG_INT("-> flash size: 2^", Object->sfdp_private.FlashSize);
  FlashSize = Object->sfdp_private.FlashSize - 1u;
341a374a:	687b      	ldr	r3, [r7, #4]
341a374c:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
341a3750:	3b01      	subs	r3, #1
341a3752:	b2db      	uxtb	r3, r3
341a3754:	74fb      	strb	r3, [r7, #19]
  (void) SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_FLASHSIZE, &FlashSize);
341a3756:	687b      	ldr	r3, [r7, #4]
341a3758:	3308      	adds	r3, #8
341a375a:	f107 0213 	add.w	r2, r7, #19
341a375e:	2104      	movs	r1, #4
341a3760:	4618      	mov	r0, r3
341a3762:	f7ff f859 	bl	341a2818 <SAL_XSPI_MemoryConfig>

  /* get the page size info */
  Object->sfdp_private.PageSize = ((uint32_t)1u <<  JEDEC_Basic.Params.Param_DWORD.D11.PageSize);
341a3766:	4ba0      	ldr	r3, [pc, #640]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3768:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
341a376c:	f3c3 1303 	ubfx	r3, r3, #4, #4
341a3770:	b2db      	uxtb	r3, r3
341a3772:	461a      	mov	r2, r3
341a3774:	2301      	movs	r3, #1
341a3776:	fa03 f202 	lsl.w	r2, r3, r2
341a377a:	687b      	ldr	r3, [r7, #4]
341a377c:	661a      	str	r2, [r3, #96]	@ 0x60

  /* ---------------------------------------------------
   *  Set default command
   * ---------------------------------------------------
   */
  Object->sfdp_private.DriverInfo.PageProgramInstruction = SFDP_DRIVER_PAGE_PROGRAM_COMMAND;
341a377e:	687b      	ldr	r3, [r7, #4]
341a3780:	2202      	movs	r2, #2
341a3782:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
  /* ---------------------------------------------------
   *  Erase management
   * ---------------------------------------------------
   */
  /* Manage erase data */
  Object->sfdp_private.DriverInfo.EraseType1Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Size;
341a3786:	4b98      	ldr	r3, [pc, #608]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3788:	f893 2020 	ldrb.w	r2, [r3, #32]
341a378c:	687b      	ldr	r3, [r7, #4]
341a378e:	f883 2077 	strb.w	r2, [r3, #119]	@ 0x77
  Object->sfdp_private.DriverInfo.EraseType1Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Instruction;
341a3792:	4b95      	ldr	r3, [pc, #596]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3794:	f893 2021 	ldrb.w	r2, [r3, #33]	@ 0x21
341a3798:	687b      	ldr	r3, [r7, #4]
341a379a:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
  Object->sfdp_private.DriverInfo.EraseType2Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Size;
341a379e:	4b92      	ldr	r3, [pc, #584]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37a0:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
341a37a4:	687b      	ldr	r3, [r7, #4]
341a37a6:	f883 2079 	strb.w	r2, [r3, #121]	@ 0x79
  Object->sfdp_private.DriverInfo.EraseType2Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Instruction;
341a37aa:	4b8f      	ldr	r3, [pc, #572]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37ac:	f893 2023 	ldrb.w	r2, [r3, #35]	@ 0x23
341a37b0:	687b      	ldr	r3, [r7, #4]
341a37b2:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
  Object->sfdp_private.DriverInfo.EraseType3Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Size;
341a37b6:	4b8c      	ldr	r3, [pc, #560]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37b8:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
341a37bc:	687b      	ldr	r3, [r7, #4]
341a37be:	f883 207b 	strb.w	r2, [r3, #123]	@ 0x7b
  Object->sfdp_private.DriverInfo.EraseType3Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Instruction;
341a37c2:	4b89      	ldr	r3, [pc, #548]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37c4:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
341a37c8:	687b      	ldr	r3, [r7, #4]
341a37ca:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
  Object->sfdp_private.DriverInfo.EraseType4Size      = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Size;
341a37ce:	4b86      	ldr	r3, [pc, #536]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37d0:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
341a37d4:	687b      	ldr	r3, [r7, #4]
341a37d6:	f883 207d 	strb.w	r2, [r3, #125]	@ 0x7d
  Object->sfdp_private.DriverInfo.EraseType4Command   = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Instruction;
341a37da:	4b83      	ldr	r3, [pc, #524]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37dc:	f893 2027 	ldrb.w	r2, [r3, #39]	@ 0x27
341a37e0:	687b      	ldr	r3, [r7, #4]
341a37e2:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e

  if (Object->sfdp_private.DriverInfo.EraseType1Command != 0x0u)
341a37e6:	687b      	ldr	r3, [r7, #4]
341a37e8:	f893 3078 	ldrb.w	r3, [r3, #120]	@ 0x78
341a37ec:	2b00      	cmp	r3, #0
341a37ee:	d01d      	beq.n	341a382c <SFDP_BuildGenericDriver+0x15c>
  {
    Object->sfdp_private.DriverInfo.EraseType1Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_units];
341a37f0:	4b7d      	ldr	r3, [pc, #500]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a37f2:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a37f6:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a37fa:	b2db      	uxtb	r3, r3
341a37fc:	461a      	mov	r2, r3
341a37fe:	4b7a      	ldr	r3, [pc, #488]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3800:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
341a3802:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a3806:	b2db      	uxtb	r3, r3
341a3808:	3301      	adds	r3, #1
341a380a:	fb02 f303 	mul.w	r3, r2, r3
341a380e:	4a76      	ldr	r2, [pc, #472]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3810:	f892 2029 	ldrb.w	r2, [r2, #41]	@ 0x29
341a3814:	f3c2 0241 	ubfx	r2, r2, #1, #2
341a3818:	b2d2      	uxtb	r2, r2
341a381a:	4611      	mov	r1, r2
341a381c:	4a73      	ldr	r2, [pc, #460]	@ (341a39ec <SFDP_BuildGenericDriver+0x31c>)
341a381e:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a3822:	fb03 f202 	mul.w	r2, r3, r2
341a3826:	687b      	ldr	r3, [r7, #4]
341a3828:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  }

  if (Object->sfdp_private.DriverInfo.EraseType2Command != 0x0u)
341a382c:	687b      	ldr	r3, [r7, #4]
341a382e:	f893 307a 	ldrb.w	r3, [r3, #122]	@ 0x7a
341a3832:	2b00      	cmp	r3, #0
341a3834:	d01e      	beq.n	341a3874 <SFDP_BuildGenericDriver+0x1a4>
  {
    Object->sfdp_private.DriverInfo.EraseType2Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_units];
341a3836:	4b6c      	ldr	r3, [pc, #432]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3838:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a383c:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a3840:	b2db      	uxtb	r3, r3
341a3842:	461a      	mov	r2, r3
341a3844:	4b68      	ldr	r3, [pc, #416]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3846:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
341a384a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
341a384e:	b2db      	uxtb	r3, r3
341a3850:	3301      	adds	r3, #1
341a3852:	fb02 f303 	mul.w	r3, r2, r3
341a3856:	4a64      	ldr	r2, [pc, #400]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3858:	f892 202a 	ldrb.w	r2, [r2, #42]	@ 0x2a
341a385c:	f3c2 0201 	ubfx	r2, r2, #0, #2
341a3860:	b2d2      	uxtb	r2, r2
341a3862:	4611      	mov	r1, r2
341a3864:	4a61      	ldr	r2, [pc, #388]	@ (341a39ec <SFDP_BuildGenericDriver+0x31c>)
341a3866:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a386a:	fb03 f202 	mul.w	r2, r3, r2
341a386e:	687b      	ldr	r3, [r7, #4]
341a3870:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  }

  if (Object->sfdp_private.DriverInfo.EraseType3Command != 0x0u)
341a3874:	687b      	ldr	r3, [r7, #4]
341a3876:	f893 307c 	ldrb.w	r3, [r3, #124]	@ 0x7c
341a387a:	2b00      	cmp	r3, #0
341a387c:	d01d      	beq.n	341a38ba <SFDP_BuildGenericDriver+0x1ea>
  {
    Object->sfdp_private.DriverInfo.EraseType3Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_units];
341a387e:	4b5a      	ldr	r3, [pc, #360]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3880:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a3884:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a3888:	b2db      	uxtb	r3, r3
341a388a:	461a      	mov	r2, r3
341a388c:	4b56      	ldr	r3, [pc, #344]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a388e:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
341a3892:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a3896:	b2db      	uxtb	r3, r3
341a3898:	3301      	adds	r3, #1
341a389a:	fb02 f303 	mul.w	r3, r2, r3
341a389e:	4a52      	ldr	r2, [pc, #328]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a38a0:	8d52      	ldrh	r2, [r2, #42]	@ 0x2a
341a38a2:	f3c2 12c1 	ubfx	r2, r2, #7, #2
341a38a6:	b2d2      	uxtb	r2, r2
341a38a8:	4611      	mov	r1, r2
341a38aa:	4a50      	ldr	r2, [pc, #320]	@ (341a39ec <SFDP_BuildGenericDriver+0x31c>)
341a38ac:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a38b0:	fb03 f202 	mul.w	r2, r3, r2
341a38b4:	687b      	ldr	r3, [r7, #4]
341a38b6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  }

  if (Object->sfdp_private.DriverInfo.EraseType4Command != 0x0u)
341a38ba:	687b      	ldr	r3, [r7, #4]
341a38bc:	f893 307e 	ldrb.w	r3, [r3, #126]	@ 0x7e
341a38c0:	2b00      	cmp	r3, #0
341a38c2:	d01e      	beq.n	341a3902 <SFDP_BuildGenericDriver+0x232>
  {
    Object->sfdp_private.DriverInfo.EraseType4Timing   = (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_count + 1u)* block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_units];
341a38c4:	4b48      	ldr	r3, [pc, #288]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a38c6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a38ca:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a38ce:	b2db      	uxtb	r3, r3
341a38d0:	461a      	mov	r2, r3
341a38d2:	4b45      	ldr	r3, [pc, #276]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a38d4:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
341a38d8:	f3c3 0344 	ubfx	r3, r3, #1, #5
341a38dc:	b2db      	uxtb	r3, r3
341a38de:	3301      	adds	r3, #1
341a38e0:	fb02 f303 	mul.w	r3, r2, r3
341a38e4:	4a40      	ldr	r2, [pc, #256]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a38e6:	f892 202b 	ldrb.w	r2, [r2, #43]	@ 0x2b
341a38ea:	f3c2 1281 	ubfx	r2, r2, #6, #2
341a38ee:	b2d2      	uxtb	r2, r2
341a38f0:	4611      	mov	r1, r2
341a38f2:	4a3e      	ldr	r2, [pc, #248]	@ (341a39ec <SFDP_BuildGenericDriver+0x31c>)
341a38f4:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
341a38f8:	fb03 f202 	mul.w	r2, r3, r2
341a38fc:	687b      	ldr	r3, [r7, #4]
341a38fe:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  }

  Object->sfdp_private.DriverInfo.EraseChipTiming   = JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime * (JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_count + 1u)* chip_erase_unit[JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_units];
341a3902:	4b39      	ldr	r3, [pc, #228]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3904:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
341a3908:	f3c3 0303 	ubfx	r3, r3, #0, #4
341a390c:	b2db      	uxtb	r3, r3
341a390e:	461a      	mov	r2, r3
341a3910:	4b35      	ldr	r3, [pc, #212]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3912:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
341a3916:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a391a:	b2db      	uxtb	r3, r3
341a391c:	3301      	adds	r3, #1
341a391e:	fb02 f303 	mul.w	r3, r2, r3
341a3922:	4a31      	ldr	r2, [pc, #196]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3924:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
341a3928:	f3c2 1241 	ubfx	r2, r2, #5, #2
341a392c:	b2d2      	uxtb	r2, r2
341a392e:	4611      	mov	r1, r2
341a3930:	4a2f      	ldr	r2, [pc, #188]	@ (341a39f0 <SFDP_BuildGenericDriver+0x320>)
341a3932:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
341a3936:	fb03 f202 	mul.w	r2, r3, r2
341a393a:	687b      	ldr	r3, [r7, #4]
341a393c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
   *   WIP/WEL : write in progress/ write enable management
   * ------------------------------------------------------
   */
  /* This bit definition is maintained for legacy compatibility only. New system implementations
  should refer to 6.4.19 for a full definition of volatile and non-volatile behavior. */
  Object->sfdp_private.DriverInfo.ReadWELCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a3940:	687b      	ldr	r3, [r7, #4]
341a3942:	2205      	movs	r2, #5
341a3944:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
  Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a3948:	687b      	ldr	r3, [r7, #4]
341a394a:	2205      	movs	r2, #5
341a394c:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  if (JEDEC_Basic.Params.Param_DWORD.D1.WriteEnableInstructionVolatileRegister == 0u)
341a3950:	4b25      	ldr	r3, [pc, #148]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3952:	791b      	ldrb	r3, [r3, #4]
341a3954:	f003 0310 	and.w	r3, r3, #16
341a3958:	b2db      	uxtb	r3, r3
341a395a:	2b00      	cmp	r3, #0
341a395c:	d104      	bne.n	341a3968 <SFDP_BuildGenericDriver+0x298>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
341a395e:	687b      	ldr	r3, [r7, #4]
341a3960:	2250      	movs	r2, #80	@ 0x50
341a3962:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a3966:	e003      	b.n	341a3970 <SFDP_BuildGenericDriver+0x2a0>
  }
  else
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a3968:	687b      	ldr	r3, [r7, #4]
341a396a:	2206      	movs	r2, #6
341a396c:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
  /* Volatile or Non-Volatile Register and Write Enable Instruction for Status Register 1
     The instruction 01h is typically used to write status register 1 which contains Block Protection (BP) and other bits. Status register 1 is written by the first data byte following the instruction 01h. The protection bits must be written to zero to enable writes/erases to the device.
     This field describes how to modify the writable bits in status register 1 in either a volatile or non-volatile manner. Bits 1:0 in status register 1 are de-facto standard write enable and busy status and are excluded from the definitions below.
  */
  /* xxx_xxx1b: Non-Volatile Status Register 1, powers-up to last written value, use instruction 06h to enable write */
  if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x1u) != 0u)
341a3970:	4b1d      	ldr	r3, [pc, #116]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3972:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a3976:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a397a:	b2db      	uxtb	r3, r3
341a397c:	f003 0301 	and.w	r3, r3, #1
341a3980:	2b00      	cmp	r3, #0
341a3982:	d004      	beq.n	341a398e <SFDP_BuildGenericDriver+0x2be>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a3984:	687b      	ldr	r3, [r7, #4]
341a3986:	2206      	movs	r2, #6
341a3988:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a398c:	e046      	b.n	341a3a1c <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_xx1xb: Volatile Status Register 1, status register powers-up with bits set to "1"s, use instruction 06h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x02u) != 0u)
341a398e:	4b16      	ldr	r3, [pc, #88]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a3990:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a3994:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a3998:	b2db      	uxtb	r3, r3
341a399a:	f003 0302 	and.w	r3, r3, #2
341a399e:	2b00      	cmp	r3, #0
341a39a0:	d004      	beq.n	341a39ac <SFDP_BuildGenericDriver+0x2dc>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a39a2:	687b      	ldr	r3, [r7, #4]
341a39a4:	2206      	movs	r2, #6
341a39a6:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a39aa:	e037      	b.n	341a3a1c <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_x1xxb: Volatile Status Register 1, status register powers-up with bits set to "1"s, use instruction 50h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x04u) != 0u)
341a39ac:	4b0e      	ldr	r3, [pc, #56]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a39ae:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a39b2:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a39b6:	b2db      	uxtb	r3, r3
341a39b8:	f003 0304 	and.w	r3, r3, #4
341a39bc:	2b00      	cmp	r3, #0
341a39be:	d004      	beq.n	341a39ca <SFDP_BuildGenericDriver+0x2fa>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
341a39c0:	687b      	ldr	r3, [r7, #4]
341a39c2:	2250      	movs	r2, #80	@ 0x50
341a39c4:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a39c8:	e028      	b.n	341a3a1c <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_1xxxb: Non-Volatile/Volatile status register 1 powers-up to last written value in the non-volatile status register,
     use instruction 06h to enable write to non-volatile status register. Volatile status register may be activated after
     power-up to override the non-volatile status register, use instruction 50h to enable write and activate the volatile
     status register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x08u) != 0u)
341a39ca:	4b07      	ldr	r3, [pc, #28]	@ (341a39e8 <SFDP_BuildGenericDriver+0x318>)
341a39cc:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a39d0:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a39d4:	b2db      	uxtb	r3, r3
341a39d6:	f003 0308 	and.w	r3, r3, #8
341a39da:	2b00      	cmp	r3, #0
341a39dc:	d00a      	beq.n	341a39f4 <SFDP_BuildGenericDriver+0x324>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a39de:	687b      	ldr	r3, [r7, #4]
341a39e0:	2206      	movs	r2, #6
341a39e2:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a39e6:	e019      	b.n	341a3a1c <SFDP_BuildGenericDriver+0x34c>
341a39e8:	341c1d54 	.word	0x341c1d54
341a39ec:	341ae660 	.word	0x341ae660
341a39f0:	341ae668 	.word	0x341ae668
  }
  /* xx1_xxxxb: Status Register 1 contains a mix of volatile and non-volatile bits. The 06h instruction is used to
     enable writing of the register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x10u) != 0u)
341a39f4:	4b66      	ldr	r3, [pc, #408]	@ (341a3b90 <SFDP_BuildGenericDriver+0x4c0>)
341a39f6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
341a39fa:	f3c3 0306 	ubfx	r3, r3, #0, #7
341a39fe:	b2db      	uxtb	r3, r3
341a3a00:	f003 0310 	and.w	r3, r3, #16
341a3a04:	2b00      	cmp	r3, #0
341a3a06:	d004      	beq.n	341a3a12 <SFDP_BuildGenericDriver+0x342>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
341a3a08:	687b      	ldr	r3, [r7, #4]
341a3a0a:	2206      	movs	r2, #6
341a3a0c:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
341a3a10:	e004      	b.n	341a3a1c <SFDP_BuildGenericDriver+0x34c>
     1xx_xxxxb: Reserved
     NOTE If the status register is read-only then this field will contain all zeros in bits 4:0.
  */
  else
  {
    retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D16;
341a3a12:	230a      	movs	r3, #10
341a3a14:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a3a18:	f000 bc2e 	b.w	341a4278 <SFDP_BuildGenericDriver+0xba8>
  }

  if(0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
341a3a1c:	687b      	ldr	r3, [r7, #4]
341a3a1e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a3a22:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341a3a26:	2b00      	cmp	r3, #0
341a3a28:	d078      	beq.n	341a3b1c <SFDP_BuildGenericDriver+0x44c>
  {
    /* WIP */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitAvailable)
341a3a2a:	4b5a      	ldr	r3, [pc, #360]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a2c:	7cdb      	ldrb	r3, [r3, #19]
341a3a2e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a3a32:	b2db      	uxtb	r3, r3
341a3a34:	2b00      	cmp	r3, #0
341a3a36:	d034      	beq.n	341a3aa2 <SFDP_BuildGenericDriver+0x3d2>
    {
      Object->sfdp_private.DriverInfo.ReadWIPCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.CommandReadAccess;
341a3a38:	4b56      	ldr	r3, [pc, #344]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a3a:	7c5a      	ldrb	r2, [r3, #17]
341a3a3c:	687b      	ldr	r3, [r7, #4]
341a3a3e:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
341a3a42:	4b54      	ldr	r3, [pc, #336]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a44:	7cdb      	ldrb	r3, [r3, #19]
341a3a46:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3a4a:	b2db      	uxtb	r3, r3
341a3a4c:	461a      	mov	r2, r3
341a3a4e:	687b      	ldr	r3, [r7, #4]
341a3a50:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
      Object->sfdp_private.DriverInfo.WIPBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.WIPpolarity;
341a3a54:	4b4f      	ldr	r3, [pc, #316]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a56:	7cdb      	ldrb	r3, [r3, #19]
341a3a58:	f3c3 1380 	ubfx	r3, r3, #6, #1
341a3a5c:	b2db      	uxtb	r3, r3
341a3a5e:	461a      	mov	r2, r3
341a3a60:	687b      	ldr	r3, [r7, #4]
341a3a62:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
341a3a66:	4b4b      	ldr	r3, [pc, #300]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a68:	7cdb      	ldrb	r3, [r3, #19]
341a3a6a:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3a6e:	b2db      	uxtb	r3, r3
341a3a70:	461a      	mov	r2, r3
341a3a72:	687b      	ldr	r3, [r7, #4]
341a3a74:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
341a3a78:	4b46      	ldr	r3, [pc, #280]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a7a:	7cdb      	ldrb	r3, [r3, #19]
341a3a7c:	f003 0310 	and.w	r3, r3, #16
341a3a80:	b2db      	uxtb	r3, r3
341a3a82:	2b00      	cmp	r3, #0
341a3a84:	d009      	beq.n	341a3a9a <SFDP_BuildGenericDriver+0x3ca>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WIPAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.LocalAddressForWIP;
341a3a86:	4b43      	ldr	r3, [pc, #268]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3a88:	7cdb      	ldrb	r3, [r3, #19]
341a3a8a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
341a3a8e:	b2db      	uxtb	r3, r3
341a3a90:	461a      	mov	r2, r3
341a3a92:	687b      	ldr	r3, [r7, #4]
341a3a94:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
341a3a98:	e003      	b.n	341a3aa2 <SFDP_BuildGenericDriver+0x3d2>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WIPAddress = EXTMEM_ADDRESS_NONE;
341a3a9a:	687b      	ldr	r3, [r7, #4]
341a3a9c:	22ff      	movs	r2, #255	@ 0xff
341a3a9e:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
      }
    }

    /* WEL */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D6.WELBitAvailable)
341a3aa2:	4b3c      	ldr	r3, [pc, #240]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3aa4:	7ddb      	ldrb	r3, [r3, #23]
341a3aa6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a3aaa:	b2db      	uxtb	r3, r3
341a3aac:	2b00      	cmp	r3, #0
341a3aae:	d073      	beq.n	341a3b98 <SFDP_BuildGenericDriver+0x4c8>
    {
      Object->sfdp_private.DriverInfo.ReadWELCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.CommandReadAccess;
341a3ab0:	4b38      	ldr	r3, [pc, #224]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3ab2:	7d5a      	ldrb	r2, [r3, #21]
341a3ab4:	687b      	ldr	r3, [r7, #4]
341a3ab6:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
341a3aba:	4b36      	ldr	r3, [pc, #216]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3abc:	7ddb      	ldrb	r3, [r3, #23]
341a3abe:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3ac2:	b2db      	uxtb	r3, r3
341a3ac4:	461a      	mov	r2, r3
341a3ac6:	687b      	ldr	r3, [r7, #4]
341a3ac8:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
      Object->sfdp_private.DriverInfo.WELBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELpolarity;
341a3acc:	4b31      	ldr	r3, [pc, #196]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3ace:	7ddb      	ldrb	r3, [r3, #23]
341a3ad0:	f3c3 1380 	ubfx	r3, r3, #6, #1
341a3ad4:	b2db      	uxtb	r3, r3
341a3ad6:	461a      	mov	r2, r3
341a3ad8:	687b      	ldr	r3, [r7, #4]
341a3ada:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
341a3ade:	4b2d      	ldr	r3, [pc, #180]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3ae0:	7ddb      	ldrb	r3, [r3, #23]
341a3ae2:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a3ae6:	b2db      	uxtb	r3, r3
341a3ae8:	461a      	mov	r2, r3
341a3aea:	687b      	ldr	r3, [r7, #4]
341a3aec:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
341a3af0:	4b28      	ldr	r3, [pc, #160]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3af2:	7cdb      	ldrb	r3, [r3, #19]
341a3af4:	f003 0310 	and.w	r3, r3, #16
341a3af8:	b2db      	uxtb	r3, r3
341a3afa:	2b00      	cmp	r3, #0
341a3afc:	d009      	beq.n	341a3b12 <SFDP_BuildGenericDriver+0x442>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WELAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELLocalAddress;
341a3afe:	4b25      	ldr	r3, [pc, #148]	@ (341a3b94 <SFDP_BuildGenericDriver+0x4c4>)
341a3b00:	7ddb      	ldrb	r3, [r3, #23]
341a3b02:	f3c3 03c0 	ubfx	r3, r3, #3, #1
341a3b06:	b2db      	uxtb	r3, r3
341a3b08:	461a      	mov	r2, r3
341a3b0a:	687b      	ldr	r3, [r7, #4]
341a3b0c:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
341a3b10:	e042      	b.n	341a3b98 <SFDP_BuildGenericDriver+0x4c8>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WELAddress = EXTMEM_ADDRESS_NONE;
341a3b12:	687b      	ldr	r3, [r7, #4]
341a3b14:	22ff      	movs	r2, #255	@ 0xff
341a3b16:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
341a3b1a:	e03d      	b.n	341a3b98 <SFDP_BuildGenericDriver+0x4c8>
      }
    }
  }
  else
  {
      Object->sfdp_private.DriverInfo.WELPosition     = 1;
341a3b1c:	687b      	ldr	r3, [r7, #4]
341a3b1e:	2201      	movs	r2, #1
341a3b20:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
      Object->sfdp_private.DriverInfo.WELBusyPolarity = 0;
341a3b24:	687b      	ldr	r3, [r7, #4]
341a3b26:	2200      	movs	r2, #0
341a3b28:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73

      /*
       *   WIP : Status register read management
       *         Basic D14 Status register Polling device Busy
       */
      if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x01u))
341a3b2c:	4b18      	ldr	r3, [pc, #96]	@ (341a3b90 <SFDP_BuildGenericDriver+0x4c0>)
341a3b2e:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a3b32:	f3c3 0385 	ubfx	r3, r3, #2, #6
341a3b36:	b2db      	uxtb	r3, r3
341a3b38:	f003 0301 	and.w	r3, r3, #1
341a3b3c:	2b00      	cmp	r3, #0
341a3b3e:	d00c      	beq.n	341a3b5a <SFDP_BuildGenericDriver+0x48a>
      {
        /* xx_xxx1b: Use of legacy polling is supported by reading the Status Register with 05h instruction
           and checking WIP bit[0] (0=ready; 1=busy). */
        Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
341a3b40:	687b      	ldr	r3, [r7, #4]
341a3b42:	2205      	movs	r2, #5
341a3b44:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        Object->sfdp_private.DriverInfo.WIPPosition = 0u;
341a3b48:	687b      	ldr	r3, [r7, #4]
341a3b4a:	2200      	movs	r2, #0
341a3b4c:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
        Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
341a3b50:	687b      	ldr	r3, [r7, #4]
341a3b52:	2200      	movs	r2, #0
341a3b54:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
341a3b58:	e01e      	b.n	341a3b98 <SFDP_BuildGenericDriver+0x4c8>
      }
      else if (0x02u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x02u))
341a3b5a:	4b0d      	ldr	r3, [pc, #52]	@ (341a3b90 <SFDP_BuildGenericDriver+0x4c0>)
341a3b5c:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
341a3b60:	f3c3 0385 	ubfx	r3, r3, #2, #6
341a3b64:	b2db      	uxtb	r3, r3
341a3b66:	f003 0302 	and.w	r3, r3, #2
341a3b6a:	2b00      	cmp	r3, #0
341a3b6c:	d00c      	beq.n	341a3b88 <SFDP_BuildGenericDriver+0x4b8>
      {
        /* xx_xx1xb: Bit 7 of the Flag Status Register may be polled any time a Program, Erase, Suspend/Resume
           command is issued, or after a Reset command while the device is busy. The read instruction is 70h.
           Flag Status Register bit definitions: bit[7]: Program or erase controller status (0=busy; 1=ready)*/
        Object->sfdp_private.DriverInfo.ReadWIPCommand = 0x70;
341a3b6e:	687b      	ldr	r3, [r7, #4]
341a3b70:	2270      	movs	r2, #112	@ 0x70
341a3b72:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        Object->sfdp_private.DriverInfo.WIPPosition = 7u;
341a3b76:	687b      	ldr	r3, [r7, #4]
341a3b78:	2207      	movs	r2, #7
341a3b7a:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
        Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
341a3b7e:	687b      	ldr	r3, [r7, #4]
341a3b80:	2200      	movs	r2, #0
341a3b82:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
341a3b86:	e007      	b.n	341a3b98 <SFDP_BuildGenericDriver+0x4c8>
      }
      else
      {
          retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D14;
341a3b88:	2309      	movs	r3, #9
341a3b8a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a3b8e:	e373      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
341a3b90:	341c1d54 	.word	0x341c1d54
341a3b94:	341c1dd4 	.word	0x341c1dd4
      }
  }

  /* Set default value for Read instruction */
  Object->sfdp_private.DriverInfo.ReadInstruction     = SFDP_DRIVER_READ_COMMAND;
341a3b98:	687b      	ldr	r3, [r7, #4]
341a3b9a:	2203      	movs	r2, #3
341a3b9c:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76

  /* ---------------------------------------------------
   *  command based on SFDP_PARAMID_BASIC_SPIPROTOCOL
   * ---------------------------------------------------
   */
  if (((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
341a3ba0:	687b      	ldr	r3, [r7, #4]
341a3ba2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a3ba6:	f003 0308 	and.w	r3, r3, #8
341a3baa:	2b00      	cmp	r3, #0
341a3bac:	f000 80af 	beq.w	341a3d0e <SFDP_BuildGenericDriver+0x63e>
       == (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
      && (Object->sfdp_private.Config < EXTMEM_LINK_CONFIG_8LINES))
341a3bb0:	687b      	ldr	r3, [r7, #4]
341a3bb2:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a3bb6:	2b02      	cmp	r3, #2
341a3bb8:	f200 80a9 	bhi.w	341a3d0e <SFDP_BuildGenericDriver+0x63e>
  {
    dummyCycles = 0;
341a3bbc:	2300      	movs	r3, #0
341a3bbe:	617b      	str	r3, [r7, #20]
    Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
341a3bc0:	687b      	ldr	r3, [r7, #4]
341a3bc2:	2200      	movs	r2, #0
341a3bc4:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_1LINE)
341a3bc8:	687b      	ldr	r3, [r7, #4]
341a3bca:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a3bce:	2b00      	cmp	r3, #0
341a3bd0:	d04c      	beq.n	341a3c6c <SFDP_BuildGenericDriver+0x59c>
    {
      /* control if read 1s1s2s is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction != 0u)
341a3bd2:	4baa      	ldr	r3, [pc, #680]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3bd4:	7c5b      	ldrb	r3, [r3, #17]
341a3bd6:	2b00      	cmp	r3, #0
341a3bd8:	d015      	beq.n	341a3c06 <SFDP_BuildGenericDriver+0x536>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_ModeClock;
341a3bda:	4ba8      	ldr	r3, [pc, #672]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3bdc:	7c1b      	ldrb	r3, [r3, #16]
341a3bde:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a3be2:	b2db      	uxtb	r3, r3
341a3be4:	461a      	mov	r2, r3
341a3be6:	4ba5      	ldr	r3, [pc, #660]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3be8:	7c1b      	ldrb	r3, [r3, #16]
341a3bea:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a3bee:	b2db      	uxtb	r3, r3
341a3bf0:	4413      	add	r3, r2
341a3bf2:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction;
341a3bf4:	4ba1      	ldr	r3, [pc, #644]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3bf6:	7c5a      	ldrb	r2, [r3, #17]
341a3bf8:	687b      	ldr	r3, [r7, #4]
341a3bfa:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S2S;
341a3bfe:	687b      	ldr	r3, [r7, #4]
341a3c00:	2201      	movs	r2, #1
341a3c02:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* control if read 1S2S2S is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction != 0u)
341a3c06:	4b9d      	ldr	r3, [pc, #628]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c08:	7cdb      	ldrb	r3, [r3, #19]
341a3c0a:	2b00      	cmp	r3, #0
341a3c0c:	d015      	beq.n	341a3c3a <SFDP_BuildGenericDriver+0x56a>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_ModeClock;
341a3c0e:	4b9b      	ldr	r3, [pc, #620]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c10:	7c9b      	ldrb	r3, [r3, #18]
341a3c12:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a3c16:	b2db      	uxtb	r3, r3
341a3c18:	461a      	mov	r2, r3
341a3c1a:	4b98      	ldr	r3, [pc, #608]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c1c:	7c9b      	ldrb	r3, [r3, #18]
341a3c1e:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a3c22:	b2db      	uxtb	r3, r3
341a3c24:	4413      	add	r3, r2
341a3c26:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction;
341a3c28:	4b94      	ldr	r3, [pc, #592]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c2a:	7cda      	ldrb	r2, [r3, #19]
341a3c2c:	687b      	ldr	r3, [r7, #4]
341a3c2e:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S2S2S;
341a3c32:	687b      	ldr	r3, [r7, #4]
341a3c34:	2202      	movs	r2, #2
341a3c36:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* The memory work only in 2S2S2S */
      if (JEDEC_Basic.Params.Param_DWORD.D5._2S2S2S_FastReadSupport != 0u)
341a3c3a:	4b90      	ldr	r3, [pc, #576]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c3c:	7d1b      	ldrb	r3, [r3, #20]
341a3c3e:	f003 0301 	and.w	r3, r3, #1
341a3c42:	b2db      	uxtb	r3, r3
341a3c44:	2b00      	cmp	r3, #0
341a3c46:	d011      	beq.n	341a3c6c <SFDP_BuildGenericDriver+0x59c>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_ModeClock;
341a3c48:	4b8c      	ldr	r3, [pc, #560]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c4a:	7e9b      	ldrb	r3, [r3, #26]
341a3c4c:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a3c50:	b2db      	uxtb	r3, r3
341a3c52:	461a      	mov	r2, r3
341a3c54:	4b89      	ldr	r3, [pc, #548]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c56:	7e9b      	ldrb	r3, [r3, #26]
341a3c58:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a3c5c:	b2db      	uxtb	r3, r3
341a3c5e:	4413      	add	r3, r2
341a3c60:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_FastReadInstruction;
341a3c62:	4b86      	ldr	r3, [pc, #536]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c64:	7eda      	ldrb	r2, [r3, #27]
341a3c66:	687b      	ldr	r3, [r7, #4]
341a3c68:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      }
    }

    /* the command set is only based on this table */
    /* determine the best line configuration */
    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_2LINES)
341a3c6c:	687b      	ldr	r3, [r7, #4]
341a3c6e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a3c72:	2b01      	cmp	r3, #1
341a3c74:	d92c      	bls.n	341a3cd0 <SFDP_BuildGenericDriver+0x600>
    {
      if (JEDEC_Basic.Params.Param_DWORD.D5._4S4S4S_FastReadSupport != 0u)
341a3c76:	4b81      	ldr	r3, [pc, #516]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c78:	7d1b      	ldrb	r3, [r3, #20]
341a3c7a:	f003 0310 	and.w	r3, r3, #16
341a3c7e:	b2db      	uxtb	r3, r3
341a3c80:	2b00      	cmp	r3, #0
341a3c82:	d020      	beq.n	341a3cc6 <SFDP_BuildGenericDriver+0x5f6>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_DummyClock + JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_ModeClock;
341a3c84:	4b7d      	ldr	r3, [pc, #500]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c86:	7f9b      	ldrb	r3, [r3, #30]
341a3c88:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a3c8c:	b2db      	uxtb	r3, r3
341a3c8e:	461a      	mov	r2, r3
341a3c90:	4b7a      	ldr	r3, [pc, #488]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3c92:	7f9b      	ldrb	r3, [r3, #30]
341a3c94:	f3c3 1342 	ubfx	r3, r3, #5, #3
341a3c98:	b2db      	uxtb	r3, r3
341a3c9a:	4413      	add	r3, r2
341a3c9c:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_FastReadInstruction;
341a3c9e:	4b77      	ldr	r3, [pc, #476]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3ca0:	7fda      	ldrb	r2, [r3, #31]
341a3ca2:	687b      	ldr	r3, [r7, #4]
341a3ca4:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_4S4S4S;
341a3ca8:	687b      	ldr	r3, [r7, #4]
341a3caa:	2204      	movs	r2, #4
341a3cac:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

        retr = JEDEC_Basic_Manage4S4S4SEnableSequence(Object);
341a3cb0:	6878      	ldr	r0, [r7, #4]
341a3cb2:	f000 feeb 	bl	341a4a8c <JEDEC_Basic_Manage4S4S4SEnableSequence>
341a3cb6:	4603      	mov	r3, r0
341a3cb8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if ( retr != EXTMEM_SFDP_OK)
341a3cbc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
341a3cc0:	2b00      	cmp	r3, #0
341a3cc2:	f040 82d6 	bne.w	341a4272 <SFDP_BuildGenericDriver+0xba2>
      }
      else /* other configuration with more 4 lines */
      {
        /* not yet handled */
      }
      SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, (uint8_t)dummyCycles);
341a3cc6:	697b      	ldr	r3, [r7, #20]
341a3cc8:	b2da      	uxtb	r2, r3
341a3cca:	687b      	ldr	r3, [r7, #4]
341a3ccc:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
#endif /* IS25WP032D_ENABLE_DTR */

    }

    /* Configure the link */
    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a3cd0:	687b      	ldr	r3, [r7, #4]
341a3cd2:	f103 0008 	add.w	r0, r3, #8
341a3cd6:	687b      	ldr	r3, [r7, #4]
341a3cd8:	3364      	adds	r3, #100	@ 0x64
341a3cda:	461a      	mov	r2, r3
341a3cdc:	2100      	movs	r1, #0
341a3cde:	f7fe fd9b 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3ce2:	4603      	mov	r3, r0
341a3ce4:	2b00      	cmp	r3, #0
341a3ce6:	d003      	beq.n	341a3cf0 <SFDP_BuildGenericDriver+0x620>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3ce8:	230c      	movs	r3, #12
341a3cea:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a3cee:	e2c3      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
    }

    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, &dummyCycles))
341a3cf0:	687b      	ldr	r3, [r7, #4]
341a3cf2:	3308      	adds	r3, #8
341a3cf4:	f107 0214 	add.w	r2, r7, #20
341a3cf8:	2101      	movs	r1, #1
341a3cfa:	4618      	mov	r0, r3
341a3cfc:	f7fe fd8c 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3d00:	4603      	mov	r3, r0
341a3d02:	2b00      	cmp	r3, #0
341a3d04:	d003      	beq.n	341a3d0e <SFDP_BuildGenericDriver+0x63e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3d06:	230c      	movs	r3, #12
341a3d08:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a3d0c:	e2b4      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
  /* -------------------------------------------------------------------------------------------------------------------
     If an octal DDR table is present and the target is 8D8D8D,
     when switch in octal DDR mode
     -------------------------------------------------------------------------------------------------------------------
  */
  if (((uint32_t)SFDP_PARAMID_OCTAL_DDR == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_OCTAL_DDR))
341a3d0e:	687b      	ldr	r3, [r7, #4]
341a3d10:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a3d14:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
341a3d18:	2b00      	cmp	r3, #0
341a3d1a:	d073      	beq.n	341a3e04 <SFDP_BuildGenericDriver+0x734>
      && (EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config))
341a3d1c:	687b      	ldr	r3, [r7, #4]
341a3d1e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a3d22:	2b03      	cmp	r3, #3
341a3d24:	d16e      	bne.n	341a3e04 <SFDP_BuildGenericDriver+0x734>
  {
    /* check if we are not already in octal mode */
    if (PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)
341a3d26:	687b      	ldr	r3, [r7, #4]
341a3d28:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a3d2c:	2b09      	cmp	r3, #9
341a3d2e:	d103      	bne.n	341a3d38 <SFDP_BuildGenericDriver+0x668>
    {
      flag4byteAddress = 1u;
341a3d30:	2301      	movs	r3, #1
341a3d32:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
341a3d36:	e044      	b.n	341a3dc2 <SFDP_BuildGenericDriver+0x6f2>
    }
    else
    {
      /* Execute the flash command sequence to switch in octal DDR */
      if (EXTMEM_SFDP_OK == sfdp_enter_octal_mode(Object))
341a3d38:	6878      	ldr	r0, [r7, #4]
341a3d3a:	f000 fc11 	bl	341a4560 <sfdp_enter_octal_mode>
341a3d3e:	4603      	mov	r3, r0
341a3d40:	2b00      	cmp	r3, #0
341a3d42:	d13e      	bne.n	341a3dc2 <SFDP_BuildGenericDriver+0x6f2>
      {
        /* switch the memory interface configuration according to the Access protocol field */
        flag4byteAddress = 1u;
341a3d44:	2301      	movs	r3, #1
341a3d46:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        /* Specific case of GigaDevice memory GD25LX512ME whose Instruction mode remains on 8S (8bit commands) */
        if (Object->sfdp_private.ManuID == EXTMEM_MANFACTURER_GIGADEVICE)
341a3d4a:	687b      	ldr	r3, [r7, #4]
341a3d4c:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a3d50:	2bc8      	cmp	r3, #200	@ 0xc8
341a3d52:	d104      	bne.n	341a3d5e <SFDP_BuildGenericDriver+0x68e>
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8S8D8D;
341a3d54:	687b      	ldr	r3, [r7, #4]
341a3d56:	2208      	movs	r2, #8
341a3d58:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
341a3d5c:	e003      	b.n	341a3d66 <SFDP_BuildGenericDriver+0x696>
        }
        else
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8D8D8D;
341a3d5e:	687b      	ldr	r3, [r7, #4]
341a3d60:	2209      	movs	r2, #9
341a3d62:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        }

        /* update the physical link */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a3d66:	687b      	ldr	r3, [r7, #4]
341a3d68:	f103 0008 	add.w	r0, r3, #8
341a3d6c:	687b      	ldr	r3, [r7, #4]
341a3d6e:	3364      	adds	r3, #100	@ 0x64
341a3d70:	461a      	mov	r2, r3
341a3d72:	2100      	movs	r1, #0
341a3d74:	f7fe fd50 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3d78:	4603      	mov	r3, r0
341a3d7a:	2b00      	cmp	r3, #0
341a3d7c:	d003      	beq.n	341a3d86 <SFDP_BuildGenericDriver+0x6b6>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3d7e:	230c      	movs	r3, #12
341a3d80:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a3d84:	e278      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }

        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFDu)
341a3d86:	687b      	ldr	r3, [r7, #4]
341a3d88:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
341a3d8c:	2bfd      	cmp	r3, #253	@ 0xfd
341a3d8e:	d109      	bne.n	341a3da4 <SFDP_BuildGenericDriver+0x6d4>
        {
          /* set 20 wait state */
          dummyCycles = 20;
341a3d90:	2314      	movs	r3, #20
341a3d92:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a3d94:	687b      	ldr	r3, [r7, #4]
341a3d96:	3308      	adds	r3, #8
341a3d98:	f107 0214 	add.w	r2, r7, #20
341a3d9c:	2101      	movs	r1, #1
341a3d9e:	4618      	mov	r0, r3
341a3da0:	f7fe fd3a 	bl	341a2818 <SAL_XSPI_MemoryConfig>
        }
        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFEu)
341a3da4:	687b      	ldr	r3, [r7, #4]
341a3da6:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
341a3daa:	2bfe      	cmp	r3, #254	@ 0xfe
341a3dac:	d109      	bne.n	341a3dc2 <SFDP_BuildGenericDriver+0x6f2>
        {
          /* set 8 wait state */
          dummyCycles = 8;
341a3dae:	2308      	movs	r3, #8
341a3db0:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a3db2:	687b      	ldr	r3, [r7, #4]
341a3db4:	3308      	adds	r3, #8
341a3db6:	f107 0214 	add.w	r2, r7, #20
341a3dba:	2101      	movs	r1, #1
341a3dbc:	4618      	mov	r0, r3
341a3dbe:	f7fe fd2b 	bl	341a2818 <SAL_XSPI_MemoryConfig>
        /* an error occurs when trying to switch the mode                        */
        /* when continue the process and check if another mode could be targeted */
      }
    }

    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
341a3dc2:	687b      	ldr	r3, [r7, #4]
341a3dc4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a3dc8:	f003 0308 	and.w	r3, r3, #8
341a3dcc:	2b00      	cmp	r3, #0
341a3dce:	d019      	beq.n	341a3e04 <SFDP_BuildGenericDriver+0x734>
        (JEDEC_Basic.size > 16u))
341a3dd0:	4b2a      	ldr	r3, [pc, #168]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3dd2:	681b      	ldr	r3, [r3, #0]
    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
341a3dd4:	2b10      	cmp	r3, #16
341a3dd6:	d915      	bls.n	341a3e04 <SFDP_BuildGenericDriver+0x734>
    {
      /* check octal information to determine */
      /* 0b00 The Command Extension is the same as the Command. (The Command / Command Extension has the same value for the whole clock period.)*/
      /* 0b01 The Command Extension is the inverse of the Command. The Command Extension acts as a confirmation of the Command */
      /* 0b11 Command and Command Extension forms a 16-bit command word */
      if (JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension > 1u)
341a3dd8:	4b28      	ldr	r3, [pc, #160]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3dda:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
341a3dde:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a3de2:	b2db      	uxtb	r3, r3
341a3de4:	2b01      	cmp	r3, #1
341a3de6:	d903      	bls.n	341a3df0 <SFDP_BuildGenericDriver+0x720>
      {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a3de8:	230f      	movs	r3, #15
341a3dea:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a3dee:	e243      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
      }
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject, (uint8_t)JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension);
341a3df0:	4b22      	ldr	r3, [pc, #136]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3df2:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
341a3df6:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a3dfa:	b2db      	uxtb	r3, r3
341a3dfc:	461a      	mov	r2, r3
341a3dfe:	687b      	ldr	r3, [r7, #4]
341a3e00:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    }
  }

  /* Check WIP flag with new access mode */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a3e04:	2164      	movs	r1, #100	@ 0x64
341a3e06:	6878      	ldr	r0, [r7, #4]
341a3e08:	f000 fa4a 	bl	341a42a0 <driver_check_FlagBUSY>
341a3e0c:	4603      	mov	r3, r0
341a3e0e:	2b00      	cmp	r3, #0
341a3e10:	d003      	beq.n	341a3e1a <SFDP_BuildGenericDriver+0x74a>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3e12:	230c      	movs	r3, #12
341a3e14:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a3e18:	e22e      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
  }

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION) == (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION)
341a3e1a:	687b      	ldr	r3, [r7, #4]
341a3e1c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a3e20:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a3e24:	2b00      	cmp	r3, #0
341a3e26:	f000 8144 	beq.w	341a40b2 <SFDP_BuildGenericDriver+0x9e2>
  {
    if (0u == flag4byteAddress)
341a3e2a:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
341a3e2e:	2b00      	cmp	r3, #0
341a3e30:	f040 80a2 	bne.w	341a3f78 <SFDP_BuildGenericDriver+0x8a8>
    {
      /* xxxx_xxx1b: issue instruction B7h (preceding write enable not required) */
      if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x01u))
341a3e34:	4b11      	ldr	r3, [pc, #68]	@ (341a3e7c <SFDP_BuildGenericDriver+0x7ac>)
341a3e36:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a3e3a:	f003 0301 	and.w	r3, r3, #1
341a3e3e:	2b00      	cmp	r3, #0
341a3e40:	d01e      	beq.n	341a3e80 <SFDP_BuildGenericDriver+0x7b0>
      {
        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,0xB7, NULL, 0))
341a3e42:	687b      	ldr	r3, [r7, #4]
341a3e44:	f103 0008 	add.w	r0, r3, #8
341a3e48:	2300      	movs	r3, #0
341a3e4a:	2200      	movs	r2, #0
341a3e4c:	21b7      	movs	r1, #183	@ 0xb7
341a3e4e:	f7fe ffc0 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a3e52:	4603      	mov	r3, r0
341a3e54:	2b00      	cmp	r3, #0
341a3e56:	d003      	beq.n	341a3e60 <SFDP_BuildGenericDriver+0x790>
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3e58:	230c      	movs	r3, #12
341a3e5a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a3e5e:	e20b      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }

        /* Set 4-Byte addressing on PHY side */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
341a3e60:	687b      	ldr	r3, [r7, #4]
341a3e62:	3308      	adds	r3, #8
341a3e64:	2200      	movs	r2, #0
341a3e66:	2102      	movs	r1, #2
341a3e68:	4618      	mov	r0, r3
341a3e6a:	f7fe fcd5 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3e6e:	4603      	mov	r3, r0
341a3e70:	2b00      	cmp	r3, #0
341a3e72:	d06f      	beq.n	341a3f54 <SFDP_BuildGenericDriver+0x884>
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3e74:	230c      	movs	r3, #12
341a3e76:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a3e7a:	e1fd      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
341a3e7c:	341c1d54 	.word	0x341c1d54
        }

        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xxxx_xx1xb: issue write enable instruction 06h, then issue instruction B7h */
      else if (0x2u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x2u))
341a3e80:	4b53      	ldr	r3, [pc, #332]	@ (341a3fd0 <SFDP_BuildGenericDriver+0x900>)
341a3e82:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a3e86:	f003 0302 	and.w	r3, r3, #2
341a3e8a:	2b00      	cmp	r3, #0
341a3e8c:	d050      	beq.n	341a3f30 <SFDP_BuildGenericDriver+0x860>
      {
        /* send command to write enable */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
341a3e8e:	687b      	ldr	r3, [r7, #4]
341a3e90:	f103 0008 	add.w	r0, r3, #8
341a3e94:	687b      	ldr	r3, [r7, #4]
341a3e96:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a3e9a:	2300      	movs	r3, #0
341a3e9c:	2200      	movs	r2, #0
341a3e9e:	f7fe ff98 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a3ea2:	4603      	mov	r3, r0
341a3ea4:	2b00      	cmp	r3, #0
341a3ea6:	d003      	beq.n	341a3eb0 <SFDP_BuildGenericDriver+0x7e0>
                                           Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3ea8:	230c      	movs	r3, #12
341a3eaa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a3eae:	e1e3      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }

        /* control the write enable */
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a3eb0:	687b      	ldr	r3, [r7, #4]
341a3eb2:	f103 0008 	add.w	r0, r3, #8
341a3eb6:	687b      	ldr	r3, [r7, #4]
341a3eb8:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                                   Object->sfdp_private.DriverInfo.ReadWELCommand,
                                                   Object->sfdp_private.DriverInfo.WELAddress,
341a3ebc:	687b      	ldr	r3, [r7, #4]
341a3ebe:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a3ec2:	461e      	mov	r6, r3
                                                   ((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u: 0u) << Object->sfdp_private.DriverInfo.WELPosition,
341a3ec4:	687b      	ldr	r3, [r7, #4]
341a3ec6:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
341a3eca:	2b00      	cmp	r3, #0
341a3ecc:	d101      	bne.n	341a3ed2 <SFDP_BuildGenericDriver+0x802>
341a3ece:	2301      	movs	r3, #1
341a3ed0:	e000      	b.n	341a3ed4 <SFDP_BuildGenericDriver+0x804>
341a3ed2:	2300      	movs	r3, #0
341a3ed4:	687a      	ldr	r2, [r7, #4]
341a3ed6:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
341a3eda:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a3edc:	b2dc      	uxtb	r4, r3
                                                   1u << Object->sfdp_private.DriverInfo.WELPosition,
341a3ede:	687b      	ldr	r3, [r7, #4]
341a3ee0:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
341a3ee4:	461a      	mov	r2, r3
341a3ee6:	2301      	movs	r3, #1
341a3ee8:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a3eea:	b2db      	uxtb	r3, r3
341a3eec:	687a      	ldr	r2, [r7, #4]
341a3eee:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a3ef2:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
341a3ef6:	9502      	str	r5, [sp, #8]
341a3ef8:	9201      	str	r2, [sp, #4]
341a3efa:	9300      	str	r3, [sp, #0]
341a3efc:	4623      	mov	r3, r4
341a3efe:	4632      	mov	r2, r6
341a3f00:	f7ff f874 	bl	341a2fec <SAL_XSPI_CheckStatusRegister>
341a3f04:	4603      	mov	r3, r0
341a3f06:	2b00      	cmp	r3, #0
341a3f08:	d003      	beq.n	341a3f12 <SFDP_BuildGenericDriver+0x842>
                                                   Object->sfdp_private.ManuID, 1000))
        {
            retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3f0a:	230c      	movs	r3, #12
341a3f0c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            goto error;
341a3f10:	e1b2      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }

        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0xB7, NULL, 0u))
341a3f12:	687b      	ldr	r3, [r7, #4]
341a3f14:	f103 0008 	add.w	r0, r3, #8
341a3f18:	2300      	movs	r3, #0
341a3f1a:	2200      	movs	r2, #0
341a3f1c:	21b7      	movs	r1, #183	@ 0xb7
341a3f1e:	f7fe ff58 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a3f22:	4603      	mov	r3, r0
341a3f24:	2b00      	cmp	r3, #0
341a3f26:	d015      	beq.n	341a3f54 <SFDP_BuildGenericDriver+0x884>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3f28:	230c      	movs	r3, #12
341a3f2a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a3f2e:	e1a3      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }
      }
      /* x1xx_xxxxb: Always operates in 4-Byte address mode */
      else if (0x40u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x40u))
341a3f30:	4b27      	ldr	r3, [pc, #156]	@ (341a3fd0 <SFDP_BuildGenericDriver+0x900>)
341a3f32:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a3f36:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a3f3a:	2b00      	cmp	r3, #0
341a3f3c:	d10a      	bne.n	341a3f54 <SFDP_BuildGenericDriver+0x884>
      {
        /* nothing to do */
        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xx1x_xxxxb: Supports dedicated 4-Byte address instruction set. Consult vendor data sheet for the instruction set definition.*/
      else if (0x20u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x20u))
341a3f3e:	4b24      	ldr	r3, [pc, #144]	@ (341a3fd0 <SFDP_BuildGenericDriver+0x900>)
341a3f40:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
341a3f44:	f003 0320 	and.w	r3, r3, #32
341a3f48:	2b00      	cmp	r3, #0
341a3f4a:	d103      	bne.n	341a3f54 <SFDP_BuildGenericDriver+0x884>
        /* xxxx_x1xxb: 8-bit volatile extended address register used to define A[31:24] bits. Read with instruction C8h. Write instruction is C5h with 1 byte of data. Select the active 128 Mbit memory segment by setting the appropriate A[31:24] bits and use 3-Byte addressing.
           xxxx_1xxxb: 8-bit volatile bank register used to define A[30:A24] bits. MSB (bit[7]) is used to enable/disable 4-byte address mode. When MSB is set to 1, 4-byte address mode is active and A[30:24] bits are do not care. Read with instruction 16h. Write instruction is 17h with 1 byte of data. When MSB is cleared to 0, select the active 128 Mbit segment by setting the appropriate A[30:24] bits and use 3-Byte addressing.
           xxx1_xxxxb: A 16-bit nonvolatile configuration register controls 3-Byte/4-Byte address mode. Read instruction is B5h. Bit[0] controls address mode [0=3-Byte;1=4-Byte]. Write configuration register instruction is B1h, data length is 2 bytes.
        */
      else {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a3f4c:	230f      	movs	r3, #15
341a3f4e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a3f52:	e191      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>

      }

      /* Set 4 bytes addressing on PHY side */
      if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
341a3f54:	687b      	ldr	r3, [r7, #4]
341a3f56:	3308      	adds	r3, #8
341a3f58:	2200      	movs	r2, #0
341a3f5a:	2102      	movs	r1, #2
341a3f5c:	4618      	mov	r0, r3
341a3f5e:	f7fe fc5b 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3f62:	4603      	mov	r3, r0
341a3f64:	2b00      	cmp	r3, #0
341a3f66:	d003      	beq.n	341a3f70 <SFDP_BuildGenericDriver+0x8a0>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3f68:	230c      	movs	r3, #12
341a3f6a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a3f6e:	e183      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
      }

      /* Set the read function for 4 bytes Address */
      Object->sfdp_private.DriverInfo.ReadInstruction = 0x13U;
341a3f70:	687b      	ldr	r3, [r7, #4]
341a3f72:	2213      	movs	r2, #19
341a3f74:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if ((EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config) && (PHY_LINK_1S1S1S == Object->sfdp_private.DriverInfo.SpiPhyLink))
341a3f78:	687b      	ldr	r3, [r7, #4]
341a3f7a:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
341a3f7e:	2b03      	cmp	r3, #3
341a3f80:	d132      	bne.n	341a3fe8 <SFDP_BuildGenericDriver+0x918>
341a3f82:	687b      	ldr	r3, [r7, #4]
341a3f84:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a3f88:	2b00      	cmp	r3, #0
341a3f8a:	d12d      	bne.n	341a3fe8 <SFDP_BuildGenericDriver+0x918>
    {
      /* check if we can switch to if the config is still 1S8S8S */
      if ((0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)  && (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand))
341a3f8c:	4b11      	ldr	r3, [pc, #68]	@ (341a3fd4 <SFDP_BuildGenericDriver+0x904>)
341a3f8e:	789b      	ldrb	r3, [r3, #2]
341a3f90:	f003 0320 	and.w	r3, r3, #32
341a3f94:	b2db      	uxtb	r3, r3
341a3f96:	2b00      	cmp	r3, #0
341a3f98:	d026      	beq.n	341a3fe8 <SFDP_BuildGenericDriver+0x918>
341a3f9a:	4b0e      	ldr	r3, [pc, #56]	@ (341a3fd4 <SFDP_BuildGenericDriver+0x904>)
341a3f9c:	78db      	ldrb	r3, [r3, #3]
341a3f9e:	f003 0301 	and.w	r3, r3, #1
341a3fa2:	b2db      	uxtb	r3, r3
341a3fa4:	2b00      	cmp	r3, #0
341a3fa6:	d01f      	beq.n	341a3fe8 <SFDP_BuildGenericDriver+0x918>
      {
        /* Patch Micron write command 0x81 @0x0 0xE7 */
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S8S8S;
341a3fa8:	687b      	ldr	r3, [r7, #4]
341a3faa:	2207      	movs	r2, #7
341a3fac:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK, &Object->sfdp_private.DriverInfo.SpiPhyLink))
341a3fb0:	687b      	ldr	r3, [r7, #4]
341a3fb2:	f103 0008 	add.w	r0, r3, #8
341a3fb6:	687b      	ldr	r3, [r7, #4]
341a3fb8:	3364      	adds	r3, #100	@ 0x64
341a3fba:	461a      	mov	r2, r3
341a3fbc:	2100      	movs	r1, #0
341a3fbe:	f7fe fc2b 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a3fc2:	4603      	mov	r3, r0
341a3fc4:	2b00      	cmp	r3, #0
341a3fc6:	d007      	beq.n	341a3fd8 <SFDP_BuildGenericDriver+0x908>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
341a3fc8:	230c      	movs	r3, #12
341a3fca:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
341a3fce:	e153      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
341a3fd0:	341c1d54 	.word	0x341c1d54
341a3fd4:	341c1db4 	.word	0x341c1db4
        }
        Object->sfdp_private.DriverInfo.ReadInstruction = 0xCC;
341a3fd8:	687b      	ldr	r3, [r7, #4]
341a3fda:	22cc      	movs	r2, #204	@ 0xcc
341a3fdc:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x8E;
341a3fe0:	687b      	ldr	r3, [r7, #4]
341a3fe2:	228e      	movs	r2, #142	@ 0x8e
341a3fe4:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75

    /*
      need to be study more; it seems that Macronix used it to define the command maybe because only one mode is
      supported in their case
    */
    if ((Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8D8D8D) ||
341a3fe8:	687b      	ldr	r3, [r7, #4]
341a3fea:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a3fee:	2b09      	cmp	r3, #9
341a3ff0:	d004      	beq.n	341a3ffc <SFDP_BuildGenericDriver+0x92c>
        (Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_1S1S1S))
341a3ff2:	687b      	ldr	r3, [r7, #4]
341a3ff4:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
    if ((Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8D8D8D) ||
341a3ff8:	2b00      	cmp	r3, #0
341a3ffa:	d120      	bne.n	341a403e <SFDP_BuildGenericDriver+0x96e>
    {
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_PageProgramCommand) {Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x12u;}
341a3ffc:	4ba1      	ldr	r3, [pc, #644]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a3ffe:	781b      	ldrb	r3, [r3, #0]
341a4000:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a4004:	b2db      	uxtb	r3, r3
341a4006:	2b00      	cmp	r3, #0
341a4008:	d003      	beq.n	341a4012 <SFDP_BuildGenericDriver+0x942>
341a400a:	687b      	ldr	r3, [r7, #4]
341a400c:	2212      	movs	r2, #18
341a400e:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_ReadCommand)        {Object->sfdp_private.DriverInfo.ReadInstruction        = 0x13u;}
341a4012:	4b9c      	ldr	r3, [pc, #624]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a4014:	781b      	ldrb	r3, [r3, #0]
341a4016:	f003 0301 	and.w	r3, r3, #1
341a401a:	b2db      	uxtb	r3, r3
341a401c:	2b00      	cmp	r3, #0
341a401e:	d003      	beq.n	341a4028 <SFDP_BuildGenericDriver+0x958>
341a4020:	687b      	ldr	r3, [r7, #4]
341a4022:	2213      	movs	r2, #19
341a4024:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_FastReadCommand)    {Object->sfdp_private.DriverInfo.ReadInstruction        = 0x0Cu;}
341a4028:	4b96      	ldr	r3, [pc, #600]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a402a:	781b      	ldrb	r3, [r3, #0]
341a402c:	f003 0302 	and.w	r3, r3, #2
341a4030:	b2db      	uxtb	r3, r3
341a4032:	2b00      	cmp	r3, #0
341a4034:	d003      	beq.n	341a403e <SFDP_BuildGenericDriver+0x96e>
341a4036:	687b      	ldr	r3, [r7, #4]
341a4038:	220c      	movs	r2, #12
341a403a:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if (Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8S8D8D)
341a403e:	687b      	ldr	r3, [r7, #4]
341a4040:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a4044:	2b08      	cmp	r3, #8
341a4046:	d120      	bne.n	341a408a <SFDP_BuildGenericDriver+0x9ba>
    {
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand) {Object->sfdp_private.DriverInfo.PageProgramInstruction  = 0x02u;}
341a4048:	4b8e      	ldr	r3, [pc, #568]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a404a:	78db      	ldrb	r3, [r3, #3]
341a404c:	f003 0301 	and.w	r3, r3, #1
341a4050:	b2db      	uxtb	r3, r3
341a4052:	2b00      	cmp	r3, #0
341a4054:	d003      	beq.n	341a405e <SFDP_BuildGenericDriver+0x98e>
341a4056:	687b      	ldr	r3, [r7, #4]
341a4058:	2202      	movs	r2, #2
341a405a:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)    {Object->sfdp_private.DriverInfo.ReadInstruction         = 0xCCu;}
341a405e:	4b89      	ldr	r3, [pc, #548]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a4060:	789b      	ldrb	r3, [r3, #2]
341a4062:	f003 0320 	and.w	r3, r3, #32
341a4066:	b2db      	uxtb	r3, r3
341a4068:	2b00      	cmp	r3, #0
341a406a:	d003      	beq.n	341a4074 <SFDP_BuildGenericDriver+0x9a4>
341a406c:	687b      	ldr	r3, [r7, #4]
341a406e:	22cc      	movs	r2, #204	@ 0xcc
341a4070:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8D8D_DTRReadCommand)     {Object->sfdp_private.DriverInfo.ReadInstruction         = 0xFDu;}
341a4074:	4b83      	ldr	r3, [pc, #524]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a4076:	789b      	ldrb	r3, [r3, #2]
341a4078:	f003 0340 	and.w	r3, r3, #64	@ 0x40
341a407c:	b2db      	uxtb	r3, r3
341a407e:	2b00      	cmp	r3, #0
341a4080:	d003      	beq.n	341a408a <SFDP_BuildGenericDriver+0x9ba>
341a4082:	687b      	ldr	r3, [r7, #4]
341a4084:	22fd      	movs	r2, #253	@ 0xfd
341a4086:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    Object->sfdp_private.DriverInfo.EraseType1Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType1;
341a408a:	4b7e      	ldr	r3, [pc, #504]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a408c:	791a      	ldrb	r2, [r3, #4]
341a408e:	687b      	ldr	r3, [r7, #4]
341a4090:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
    Object->sfdp_private.DriverInfo.EraseType2Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType2;
341a4094:	4b7b      	ldr	r3, [pc, #492]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a4096:	795a      	ldrb	r2, [r3, #5]
341a4098:	687b      	ldr	r3, [r7, #4]
341a409a:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
    Object->sfdp_private.DriverInfo.EraseType3Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType3;
341a409e:	4b79      	ldr	r3, [pc, #484]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a40a0:	799a      	ldrb	r2, [r3, #6]
341a40a2:	687b      	ldr	r3, [r7, #4]
341a40a4:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
    Object->sfdp_private.DriverInfo.EraseType4Command   = (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType4;
341a40a8:	4b76      	ldr	r3, [pc, #472]	@ (341a4284 <SFDP_BuildGenericDriver+0xbb4>)
341a40aa:	79da      	ldrb	r2, [r3, #7]
341a40ac:	687b      	ldr	r3, [r7, #4]
341a40ae:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e
  }

  if(((uint32_t)SFDP_PARAMID_XSPI_V1_0 == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_XSPI_V1_0))
341a40b2:	687b      	ldr	r3, [r7, #4]
341a40b4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a40b8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
341a40bc:	2b00      	cmp	r3, #0
341a40be:	f000 80da 	beq.w	341a4276 <SFDP_BuildGenericDriver+0xba6>
      &&
      ((PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink) || (PHY_LINK_8S8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)))
341a40c2:	687b      	ldr	r3, [r7, #4]
341a40c4:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
      &&
341a40c8:	2b09      	cmp	r3, #9
341a40ca:	d005      	beq.n	341a40d8 <SFDP_BuildGenericDriver+0xa08>
      ((PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink) || (PHY_LINK_8S8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)))
341a40cc:	687b      	ldr	r3, [r7, #4]
341a40ce:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
341a40d2:	2b08      	cmp	r3, #8
341a40d4:	f040 80cf 	bne.w	341a4276 <SFDP_BuildGenericDriver+0xba6>
  {
    uint32_t ClockOut = 0u;
341a40d8:	2300      	movs	r3, #0
341a40da:	60fb      	str	r3, [r7, #12]
    uint32_t MaxFreqMhz;
    /* Read command */
    if (0u != JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand)
341a40dc:	4b6a      	ldr	r3, [pc, #424]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a40de:	785b      	ldrb	r3, [r3, #1]
341a40e0:	2b00      	cmp	r3, #0
341a40e2:	d004      	beq.n	341a40ee <SFDP_BuildGenericDriver+0xa1e>
    {
      Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand;
341a40e4:	4b68      	ldr	r3, [pc, #416]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a40e6:	785a      	ldrb	r2, [r3, #1]
341a40e8:	687b      	ldr	r3, [r7, #4]
341a40ea:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if (JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle != 0u)
341a40ee:	4b66      	ldr	r3, [pc, #408]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a40f0:	7d1b      	ldrb	r3, [r3, #20]
341a40f2:	f003 031f 	and.w	r3, r3, #31
341a40f6:	b2db      	uxtb	r3, r3
341a40f8:	2b00      	cmp	r3, #0
341a40fa:	d00d      	beq.n	341a4118 <SFDP_BuildGenericDriver+0xa48>
    {
      /* Set the default dummy cycle of this mode */
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle;
341a40fc:	4b62      	ldr	r3, [pc, #392]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a40fe:	7d1b      	ldrb	r3, [r3, #20]
341a4100:	f3c3 0304 	ubfx	r3, r3, #0, #5
341a4104:	b2db      	uxtb	r3, r3
341a4106:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a4108:	687b      	ldr	r3, [r7, #4]
341a410a:	3308      	adds	r3, #8
341a410c:	f107 0214 	add.w	r2, r7, #20
341a4110:	2101      	movs	r1, #1
341a4112:	4618      	mov	r0, r3
341a4114:	f7fe fb80 	bl	341a2818 <SAL_XSPI_MemoryConfig>
    }

    /* adapt the memory interface frequency according to its capabilities */
    MaxFreqMhz = sfdp_getfrequencevalue(JEDEC_Basic.Params.Param_DWORD.D20._8D8D8D_MaximunSpeedWithStrobe);
341a4118:	4b5c      	ldr	r3, [pc, #368]	@ (341a428c <SFDP_BuildGenericDriver+0xbbc>)
341a411a:	f893 3053 	ldrb.w	r3, [r3, #83]	@ 0x53
341a411e:	f3c3 1303 	ubfx	r3, r3, #4, #4
341a4122:	b2db      	uxtb	r3, r3
341a4124:	4618      	mov	r0, r3
341a4126:	f000 f8f9 	bl	341a431c <sfdp_getfrequencevalue>
341a412a:	61f8      	str	r0, [r7, #28]
    if (MaxFreqMhz > Object->sfdp_private.DriverInfo.ClockIn)
341a412c:	687b      	ldr	r3, [r7, #4]
341a412e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
341a4130:	69fa      	ldr	r2, [r7, #28]
341a4132:	429a      	cmp	r2, r3
341a4134:	d902      	bls.n	341a413c <SFDP_BuildGenericDriver+0xa6c>
    {
      /* Adjust the frequence with the ClockIn */
      MaxFreqMhz = Object->sfdp_private.DriverInfo.ClockIn;
341a4136:	687b      	ldr	r3, [r7, #4]
341a4138:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
341a413a:	61fb      	str	r3, [r7, #28]
    }

    /* Update the clock to be aligned with selected configuration */
    if(HAL_OK != SAL_XSPI_SetClock(&Object->sfdp_private.SALObject, Object->sfdp_private.DriverInfo.ClockIn, MaxFreqMhz, &ClockOut))
341a413c:	687b      	ldr	r3, [r7, #4]
341a413e:	f103 0008 	add.w	r0, r3, #8
341a4142:	687b      	ldr	r3, [r7, #4]
341a4144:	6e99      	ldr	r1, [r3, #104]	@ 0x68
341a4146:	f107 030c 	add.w	r3, r7, #12
341a414a:	69fa      	ldr	r2, [r7, #28]
341a414c:	f7fe faf1 	bl	341a2732 <SAL_XSPI_SetClock>
341a4150:	4603      	mov	r3, r0
341a4152:	2b00      	cmp	r3, #0
341a4154:	d003      	beq.n	341a415e <SFDP_BuildGenericDriver+0xa8e>
    {
      retr = EXTMEM_SFDP_ERROR_SETCLOCK;
341a4156:	230d      	movs	r3, #13
341a4158:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
341a415c:	e08c      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
    }
    *FreqUpdated = 1u; /* Used to indicate that the clock configuration has been updated */
341a415e:	683b      	ldr	r3, [r7, #0]
341a4160:	2201      	movs	r2, #1
341a4162:	701a      	strb	r2, [r3, #0]

    /* get the dummy cycle value according to the real output clock */
    if ((ClockOut >= CLOCK_200MHZ) && (JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle != 0u))
341a4164:	68fb      	ldr	r3, [r7, #12]
341a4166:	4a4a      	ldr	r2, [pc, #296]	@ (341a4290 <SFDP_BuildGenericDriver+0xbc0>)
341a4168:	4293      	cmp	r3, r2
341a416a:	d913      	bls.n	341a4194 <SFDP_BuildGenericDriver+0xac4>
341a416c:	4b46      	ldr	r3, [pc, #280]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a416e:	899b      	ldrh	r3, [r3, #12]
341a4170:	f403 6378 	and.w	r3, r3, #3968	@ 0xf80
341a4174:	b29b      	uxth	r3, r3
341a4176:	2b00      	cmp	r3, #0
341a4178:	d00c      	beq.n	341a4194 <SFDP_BuildGenericDriver+0xac4>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle;
341a417a:	4b43      	ldr	r3, [pc, #268]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a417c:	899b      	ldrh	r3, [r3, #12]
341a417e:	f3c3 13c4 	ubfx	r3, r3, #7, #5
341a4182:	b2db      	uxtb	r3, r3
341a4184:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_ConfigPattern;
341a4186:	4b40      	ldr	r3, [pc, #256]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a4188:	7b1b      	ldrb	r3, [r3, #12]
341a418a:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a418e:	b2db      	uxtb	r3, r3
341a4190:	623b      	str	r3, [r7, #32]
341a4192:	e03b      	b.n	341a420c <SFDP_BuildGenericDriver+0xb3c>
    }
    else if ((ClockOut >= CLOCK_166MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle != 0u))
341a4194:	68fb      	ldr	r3, [r7, #12]
341a4196:	4a3f      	ldr	r2, [pc, #252]	@ (341a4294 <SFDP_BuildGenericDriver+0xbc4>)
341a4198:	4293      	cmp	r3, r2
341a419a:	d913      	bls.n	341a41c4 <SFDP_BuildGenericDriver+0xaf4>
341a419c:	4b3a      	ldr	r3, [pc, #232]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a419e:	7cdb      	ldrb	r3, [r3, #19]
341a41a0:	f023 0307 	bic.w	r3, r3, #7
341a41a4:	b2db      	uxtb	r3, r3
341a41a6:	2b00      	cmp	r3, #0
341a41a8:	d00c      	beq.n	341a41c4 <SFDP_BuildGenericDriver+0xaf4>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle;
341a41aa:	4b37      	ldr	r3, [pc, #220]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41ac:	7cdb      	ldrb	r3, [r3, #19]
341a41ae:	f3c3 03c4 	ubfx	r3, r3, #3, #5
341a41b2:	b2db      	uxtb	r3, r3
341a41b4:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_ConfigPattern;
341a41b6:	4b34      	ldr	r3, [pc, #208]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41b8:	8a5b      	ldrh	r3, [r3, #18]
341a41ba:	f3c3 1384 	ubfx	r3, r3, #6, #5
341a41be:	b2db      	uxtb	r3, r3
341a41c0:	623b      	str	r3, [r7, #32]
341a41c2:	e023      	b.n	341a420c <SFDP_BuildGenericDriver+0xb3c>
    }
    else if ((ClockOut >= CLOCK_133MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle != 0u))
341a41c4:	68fb      	ldr	r3, [r7, #12]
341a41c6:	4a34      	ldr	r2, [pc, #208]	@ (341a4298 <SFDP_BuildGenericDriver+0xbc8>)
341a41c8:	4293      	cmp	r3, r2
341a41ca:	d913      	bls.n	341a41f4 <SFDP_BuildGenericDriver+0xb24>
341a41cc:	4b2e      	ldr	r3, [pc, #184]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41ce:	7c9b      	ldrb	r3, [r3, #18]
341a41d0:	f003 033e 	and.w	r3, r3, #62	@ 0x3e
341a41d4:	b2db      	uxtb	r3, r3
341a41d6:	2b00      	cmp	r3, #0
341a41d8:	d00c      	beq.n	341a41f4 <SFDP_BuildGenericDriver+0xb24>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle;
341a41da:	4b2b      	ldr	r3, [pc, #172]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41dc:	7c9b      	ldrb	r3, [r3, #18]
341a41de:	f3c3 0344 	ubfx	r3, r3, #1, #5
341a41e2:	b2db      	uxtb	r3, r3
341a41e4:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_ConfigPattern;
341a41e6:	4b28      	ldr	r3, [pc, #160]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41e8:	691b      	ldr	r3, [r3, #16]
341a41ea:	f3c3 3304 	ubfx	r3, r3, #12, #5
341a41ee:	b2db      	uxtb	r3, r3
341a41f0:	623b      	str	r3, [r7, #32]
341a41f2:	e00b      	b.n	341a420c <SFDP_BuildGenericDriver+0xb3c>
    }
    else /* if (ClockOut =< 100Mhz) */
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_DummyCycle;
341a41f4:	4b24      	ldr	r3, [pc, #144]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a41f6:	8a1b      	ldrh	r3, [r3, #16]
341a41f8:	f3c3 13c4 	ubfx	r3, r3, #7, #5
341a41fc:	b2db      	uxtb	r3, r3
341a41fe:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_ConfigPattern;
341a4200:	4b21      	ldr	r3, [pc, #132]	@ (341a4288 <SFDP_BuildGenericDriver+0xbb8>)
341a4202:	7c1b      	ldrb	r3, [r3, #16]
341a4204:	f3c3 0384 	ubfx	r3, r3, #2, #5
341a4208:	b2db      	uxtb	r3, r3
341a420a:	623b      	str	r3, [r7, #32]
    }

    /* Specific case of GigaDevice memory with wrongly coded SFDP table in JEDEC_SCCR_Map.Param_DWORD.D9 */
    if (Object->sfdp_private.ManuID == EXTMEM_MANFACTURER_GIGADEVICE)
341a420c:	687b      	ldr	r3, [r7, #4]
341a420e:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a4212:	2bc8      	cmp	r3, #200	@ 0xc8
341a4214:	d10a      	bne.n	341a422c <SFDP_BuildGenericDriver+0xb5c>
    {
      dummyCycles = 16;
341a4216:	2310      	movs	r3, #16
341a4218:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a421a:	687b      	ldr	r3, [r7, #4]
341a421c:	3308      	adds	r3, #8
341a421e:	f107 0214 	add.w	r2, r7, #20
341a4222:	2101      	movs	r1, #1
341a4224:	4618      	mov	r0, r3
341a4226:	f7fe faf7 	bl	341a2818 <SAL_XSPI_MemoryConfig>
341a422a:	e025      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
    }
    else
    {
      /* Write the dummy cycle value in the configuration register using information coming from SCCR Map */
      if((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
341a422c:	687b      	ldr	r3, [r7, #4]
341a422e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
341a4232:	f403 7300 	and.w	r3, r3, #512	@ 0x200
341a4236:	2b00      	cmp	r3, #0
341a4238:	d017      	beq.n	341a426a <SFDP_BuildGenericDriver+0xb9a>
         && (0u != JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable))
341a423a:	4b18      	ldr	r3, [pc, #96]	@ (341a429c <SFDP_BuildGenericDriver+0xbcc>)
341a423c:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4240:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a4244:	b2db      	uxtb	r3, r3
341a4246:	2b00      	cmp	r3, #0
341a4248:	d00f      	beq.n	341a426a <SFDP_BuildGenericDriver+0xb9a>
      {
        /* Update the frequence with MaxFreqMhz information */
        if( sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
341a424a:	6a39      	ldr	r1, [r7, #32]
341a424c:	6878      	ldr	r0, [r7, #4]
341a424e:	f000 fa6b 	bl	341a4728 <sfdp_set_dummycycle>
341a4252:	4603      	mov	r3, r0
341a4254:	2b00      	cmp	r3, #0
341a4256:	d10f      	bne.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        {
          /* Set the dummy cycle corresponding */
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void*)&dummyCycles);
341a4258:	687b      	ldr	r3, [r7, #4]
341a425a:	3308      	adds	r3, #8
341a425c:	f107 0214 	add.w	r2, r7, #20
341a4260:	2101      	movs	r1, #1
341a4262:	4618      	mov	r0, r3
341a4264:	f7fe fad8 	bl	341a2818 <SAL_XSPI_MemoryConfig>
        if( sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
341a4268:	e006      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
        }
      }
      else
      {
        retr = EXTMEM_SFDP_ERROR_CONFIGDUMMY;
341a426a:	230e      	movs	r3, #14
341a426c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
341a4270:	e002      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
          goto error;
341a4272:	bf00      	nop
341a4274:	e000      	b.n	341a4278 <SFDP_BuildGenericDriver+0xba8>
      }
    }
  }

error :
341a4276:	bf00      	nop
  return retr;
341a4278:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
341a427c:	4618      	mov	r0, r3
341a427e:	372c      	adds	r7, #44	@ 0x2c
341a4280:	46bd      	mov	sp, r7
341a4282:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a4284:	341c1db4 	.word	0x341c1db4
341a4288:	341c1dbc 	.word	0x341c1dbc
341a428c:	341c1d54 	.word	0x341c1d54
341a4290:	0bebc1ff 	.word	0x0bebc1ff
341a4294:	09e4f57f 	.word	0x09e4f57f
341a4298:	07ed6b3f 	.word	0x07ed6b3f
341a429c:	341c1dd4 	.word	0x341c1dd4

341a42a0 <driver_check_FlagBUSY>:


EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef driver_check_FlagBUSY(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject, uint32_t Timeout)
{
341a42a0:	b5f0      	push	{r4, r5, r6, r7, lr}
341a42a2:	b089      	sub	sp, #36	@ 0x24
341a42a4:	af04      	add	r7, sp, #16
341a42a6:	6078      	str	r0, [r7, #4]
341a42a8:	6039      	str	r1, [r7, #0]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUSY;
341a42aa:	23fb      	movs	r3, #251	@ 0xfb
341a42ac:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR((uint8_t *)__func__)
  if (0u != SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand)
341a42ae:	687b      	ldr	r3, [r7, #4]
341a42b0:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
341a42b4:	2b00      	cmp	r3, #0
341a42b6:	d02b      	beq.n	341a4310 <driver_check_FlagBUSY+0x70>
  {
    /* check that the WIP flag is not set */
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a42b8:	687b      	ldr	r3, [r7, #4]
341a42ba:	f103 0008 	add.w	r0, r3, #8
341a42be:	687b      	ldr	r3, [r7, #4]
341a42c0:	f893 406c 	ldrb.w	r4, [r3, #108]	@ 0x6c
                                               SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand,
                                               SFDPObject->sfdp_private.DriverInfo.WIPAddress,
341a42c4:	687b      	ldr	r3, [r7, #4]
341a42c6:	f893 306f 	ldrb.w	r3, [r3, #111]	@ 0x6f
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a42ca:	461e      	mov	r6, r3
                                               SFDPObject->sfdp_private.DriverInfo.WIPBusyPolarity << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
341a42cc:	687b      	ldr	r3, [r7, #4]
341a42ce:	f893 306e 	ldrb.w	r3, [r3, #110]	@ 0x6e
341a42d2:	461a      	mov	r2, r3
341a42d4:	687b      	ldr	r3, [r7, #4]
341a42d6:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
341a42da:	fa02 f303 	lsl.w	r3, r2, r3
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a42de:	b2dd      	uxtb	r5, r3
                                               1u << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
341a42e0:	687b      	ldr	r3, [r7, #4]
341a42e2:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
341a42e6:	461a      	mov	r2, r3
341a42e8:	2301      	movs	r3, #1
341a42ea:	4093      	lsls	r3, r2
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
341a42ec:	b2db      	uxtb	r3, r3
341a42ee:	687a      	ldr	r2, [r7, #4]
341a42f0:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a42f4:	6839      	ldr	r1, [r7, #0]
341a42f6:	9102      	str	r1, [sp, #8]
341a42f8:	9201      	str	r2, [sp, #4]
341a42fa:	9300      	str	r3, [sp, #0]
341a42fc:	462b      	mov	r3, r5
341a42fe:	4632      	mov	r2, r6
341a4300:	4621      	mov	r1, r4
341a4302:	f7fe fe73 	bl	341a2fec <SAL_XSPI_CheckStatusRegister>
341a4306:	4603      	mov	r3, r0
341a4308:	2b00      	cmp	r3, #0
341a430a:	d101      	bne.n	341a4310 <driver_check_FlagBUSY+0x70>
                                               SFDPObject->sfdp_private.ManuID, Timeout))
    {
      retr = EXTMEM_DRIVER_NOR_SFDP_OK;
341a430c:	2300      	movs	r3, #0
341a430e:	73fb      	strb	r3, [r7, #15]
    }
  }
  return retr;
341a4310:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
341a4314:	4618      	mov	r0, r3
341a4316:	3714      	adds	r7, #20
341a4318:	46bd      	mov	sp, r7
341a431a:	bdf0      	pop	{r4, r5, r6, r7, pc}

341a431c <sfdp_getfrequencevalue>:
 * @brief This function returns the frequency value corresponding to a frequency
 * @param BitField bit field value
 * @return frequency value
 */
uint32_t sfdp_getfrequencevalue(uint32_t BitField)
{
341a431c:	b4b0      	push	{r4, r5, r7}
341a431e:	b08b      	sub	sp, #44	@ 0x2c
341a4320:	af00      	add	r7, sp, #0
341a4322:	6078      	str	r0, [r7, #4]
  const uint16_t freqMhz_table[] = { 0x0, 33, 50, 66, 80, 100, 133, 166, 200, 250, 266, 333, 400 };
341a4324:	4b0e      	ldr	r3, [pc, #56]	@ (341a4360 <sfdp_getfrequencevalue+0x44>)
341a4326:	f107 040c 	add.w	r4, r7, #12
341a432a:	461d      	mov	r5, r3
341a432c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
341a432e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
341a4330:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
341a4334:	c403      	stmia	r4!, {r0, r1}
341a4336:	8022      	strh	r2, [r4, #0]
  SFDP_DEBUG_STR(__func__);

  if (BitField < 0b1010u)
341a4338:	687b      	ldr	r3, [r7, #4]
341a433a:	2b09      	cmp	r3, #9
341a433c:	d80a      	bhi.n	341a4354 <sfdp_getfrequencevalue+0x38>
  {
    return (uint32_t)freqMhz_table[BitField]* 1000000u;
341a433e:	687b      	ldr	r3, [r7, #4]
341a4340:	005b      	lsls	r3, r3, #1
341a4342:	3328      	adds	r3, #40	@ 0x28
341a4344:	443b      	add	r3, r7
341a4346:	f833 3c1c 	ldrh.w	r3, [r3, #-28]
341a434a:	461a      	mov	r2, r3
341a434c:	4b05      	ldr	r3, [pc, #20]	@ (341a4364 <sfdp_getfrequencevalue+0x48>)
341a434e:	fb02 f303 	mul.w	r3, r2, r3
341a4352:	e000      	b.n	341a4356 <sfdp_getfrequencevalue+0x3a>
  }
  return 0; /* the max frequency is unknown */
341a4354:	2300      	movs	r3, #0
}
341a4356:	4618      	mov	r0, r3
341a4358:	372c      	adds	r7, #44	@ 0x2c
341a435a:	46bd      	mov	sp, r7
341a435c:	bcb0      	pop	{r4, r5, r7}
341a435e:	4770      	bx	lr
341a4360:	341a7dc4 	.word	0x341a7dc4
341a4364:	000f4240 	.word	0x000f4240

341a4368 <sfdp_get_paraminfo>:
 * @param sfdp_param_info pointer on parameter info
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_get_paraminfo(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t sfdp_address,
                                      SFDP_ParameterTableTypeDef *Param_info)
{
341a4368:	b580      	push	{r7, lr}
341a436a:	b088      	sub	sp, #32
341a436c:	af00      	add	r7, sp, #0
341a436e:	60f8      	str	r0, [r7, #12]
341a4370:	60b9      	str	r1, [r7, #8]
341a4372:	607a      	str	r2, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a4374:	2300      	movs	r3, #0
341a4376:	77fb      	strb	r3, [r7, #31]
  SFDP_ParameterHeaderTypeDef sfdp_param_header = {0};
341a4378:	f107 0314 	add.w	r3, r7, #20
341a437c:	2200      	movs	r2, #0
341a437e:	601a      	str	r2, [r3, #0]
341a4380:	605a      	str	r2, [r3, #4]
  SFDP_DEBUG_STR(__func__);

  /* send the SFDP command to read the header */
  if(HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, sfdp_address,
341a4382:	68fb      	ldr	r3, [r7, #12]
341a4384:	f103 0008 	add.w	r0, r3, #8
341a4388:	f107 0214 	add.w	r2, r7, #20
341a438c:	2308      	movs	r3, #8
341a438e:	68b9      	ldr	r1, [r7, #8]
341a4390:	f7fe fb94 	bl	341a2abc <SAL_XSPI_GetSFDP>
341a4394:	4603      	mov	r3, r0
341a4396:	2b00      	cmp	r3, #0
341a4398:	d002      	beq.n	341a43a0 <sfdp_get_paraminfo+0x38>
                                (uint8_t*)&sfdp_param_header, SFDP_PARAM_HEADER_SIZE))
  {
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a439a:	2303      	movs	r3, #3
341a439c:	77fb      	strb	r3, [r7, #31]
    goto error;
341a439e:	e0d9      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
  }

  Param_info->type = SFDP_PARAMID_UNKNOWN;
341a43a0:	687b      	ldr	r3, [r7, #4]
341a43a2:	2200      	movs	r2, #0
341a43a4:	601a      	str	r2, [r3, #0]
  Param_info->size = sfdp_param_header.Length ;
341a43a6:	7dfa      	ldrb	r2, [r7, #23]
341a43a8:	687b      	ldr	r3, [r7, #4]
341a43aa:	721a      	strb	r2, [r3, #8]
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
341a43ac:	7ebb      	ldrb	r3, [r7, #26]
341a43ae:	041a      	lsls	r2, r3, #16
                        |((uint32_t)sfdp_param_header.TableAddressPointer[1u] << 8u)
341a43b0:	7e7b      	ldrb	r3, [r7, #25]
341a43b2:	021b      	lsls	r3, r3, #8
341a43b4:	4313      	orrs	r3, r2
                        |((uint32_t)sfdp_param_header.TableAddressPointer[0u]));
341a43b6:	7e3a      	ldrb	r2, [r7, #24]
341a43b8:	431a      	orrs	r2, r3
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
341a43ba:	687b      	ldr	r3, [r7, #4]
341a43bc:	605a      	str	r2, [r3, #4]

  if ((sfdp_param_header.ID_msb > 0x00u) && (sfdp_param_header.ID_msb < 0x80u))
341a43be:	7efb      	ldrb	r3, [r7, #27]
341a43c0:	2b00      	cmp	r3, #0
341a43c2:	d010      	beq.n	341a43e6 <sfdp_get_paraminfo+0x7e>
341a43c4:	7efb      	ldrb	r3, [r7, #27]
341a43c6:	b25b      	sxtb	r3, r3
341a43c8:	2b00      	cmp	r3, #0
341a43ca:	db0c      	blt.n	341a43e6 <sfdp_get_paraminfo+0x7e>
  {
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a43cc:	7d3b      	ldrb	r3, [r7, #20]
341a43ce:	f003 0301 	and.w	r3, r3, #1
341a43d2:	2b00      	cmp	r3, #0
341a43d4:	d003      	beq.n	341a43de <sfdp_get_paraminfo+0x76>
    {
      Param_info->type = SFDP_PARAMID_VENDOR;
341a43d6:	687b      	ldr	r3, [r7, #4]
341a43d8:	2201      	movs	r2, #1
341a43da:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a43dc:	e0ba      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_VENDOR");
    }
    else
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_VENDOR;
341a43de:	687b      	ldr	r3, [r7, #4]
341a43e0:	2202      	movs	r2, #2
341a43e2:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
341a43e4:	e0b6      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_VENDOR");
    }
  }
  else if (sfdp_param_header.ID_msb >= 0x80u)
341a43e6:	7efb      	ldrb	r3, [r7, #27]
341a43e8:	b25b      	sxtb	r3, r3
341a43ea:	2b00      	cmp	r3, #0
341a43ec:	f280 80ae 	bge.w	341a454c <sfdp_get_paraminfo+0x1e4>
  {
    if((sfdp_param_header.ID_lsb & 0x01u) == 0x00u)
341a43f0:	7d3b      	ldrb	r3, [r7, #20]
341a43f2:	f003 0301 	and.w	r3, r3, #1
341a43f6:	2b00      	cmp	r3, #0
341a43f8:	d102      	bne.n	341a4400 <sfdp_get_paraminfo+0x98>
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_JEDEC;
341a43fa:	687b      	ldr	r3, [r7, #4]
341a43fc:	2204      	movs	r2, #4
341a43fe:	601a      	str	r2, [r3, #0]
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_JEDEC");
    }

    if (sfdp_param_header.ID_msb == SFDP_BASIC_PARAMETER_TABLE_MSB)
341a4400:	7efb      	ldrb	r3, [r7, #27]
341a4402:	2bff      	cmp	r3, #255	@ 0xff
341a4404:	f040 80a6 	bne.w	341a4554 <sfdp_get_paraminfo+0x1ec>
    {
      switch(sfdp_param_header.ID_lsb)
341a4408:	7d3b      	ldrb	r3, [r7, #20]
341a440a:	2b0f      	cmp	r3, #15
341a440c:	dc4c      	bgt.n	341a44a8 <sfdp_get_paraminfo+0x140>
341a440e:	2b00      	cmp	r3, #0
341a4410:	da24      	bge.n	341a445c <sfdp_get_paraminfo+0xf4>
        Param_info->type = SFDP_PARAMID_RESERVED;
        SFDP_DEBUG_STR("-> info SFDP_PARAMID_RESERVED");
        break;
      default :
        SFDP_DEBUG_STR("-> info SFDP_PARAMID_????");
        break;
341a4412:	e09e      	b.n	341a4552 <sfdp_get_paraminfo+0x1ea>
      switch(sfdp_param_header.ID_lsb)
341a4414:	3b81      	subs	r3, #129	@ 0x81
341a4416:	2b0d      	cmp	r3, #13
341a4418:	f200 809b 	bhi.w	341a4552 <sfdp_get_paraminfo+0x1ea>
341a441c:	a201      	add	r2, pc, #4	@ (adr r2, 341a4424 <sfdp_get_paraminfo+0xbc>)
341a441e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a4422:	bf00      	nop
341a4424:	341a44c9 	.word	0x341a44c9
341a4428:	341a4553 	.word	0x341a4553
341a442c:	341a4553 	.word	0x341a4553
341a4430:	341a44d9 	.word	0x341a44d9
341a4434:	341a4553 	.word	0x341a4553
341a4438:	341a4553 	.word	0x341a4553
341a443c:	341a44f3 	.word	0x341a44f3
341a4440:	341a44fd 	.word	0x341a44fd
341a4444:	341a4553 	.word	0x341a4553
341a4448:	341a4553 	.word	0x341a4553
341a444c:	341a451b 	.word	0x341a451b
341a4450:	341a4553 	.word	0x341a4553
341a4454:	341a452f 	.word	0x341a452f
341a4458:	341a4539 	.word	0x341a4539
341a445c:	2b0f      	cmp	r3, #15
341a445e:	d878      	bhi.n	341a4552 <sfdp_get_paraminfo+0x1ea>
341a4460:	a201      	add	r2, pc, #4	@ (adr r2, 341a4468 <sfdp_get_paraminfo+0x100>)
341a4462:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a4466:	bf00      	nop
341a4468:	341a44b3 	.word	0x341a44b3
341a446c:	341a4553 	.word	0x341a4553
341a4470:	341a4553 	.word	0x341a4553
341a4474:	341a44d1 	.word	0x341a44d1
341a4478:	341a4553 	.word	0x341a4553
341a447c:	341a44e1 	.word	0x341a44e1
341a4480:	341a44e9 	.word	0x341a44e9
341a4484:	341a4553 	.word	0x341a4553
341a4488:	341a4553 	.word	0x341a4553
341a448c:	341a4507 	.word	0x341a4507
341a4490:	341a4511 	.word	0x341a4511
341a4494:	341a4553 	.word	0x341a4553
341a4498:	341a4525 	.word	0x341a4525
341a449c:	341a4553 	.word	0x341a4553
341a44a0:	341a4553 	.word	0x341a4553
341a44a4:	341a4543 	.word	0x341a4543
341a44a8:	2b8e      	cmp	r3, #142	@ 0x8e
341a44aa:	dc52      	bgt.n	341a4552 <sfdp_get_paraminfo+0x1ea>
341a44ac:	2b81      	cmp	r3, #129	@ 0x81
341a44ae:	dab1      	bge.n	341a4414 <sfdp_get_paraminfo+0xac>
        break;
341a44b0:	e04f      	b.n	341a4552 <sfdp_get_paraminfo+0x1ea>
        Param_info->type = SFDP_PARAMID_BASIC_SPIPROTOCOL;
341a44b2:	687b      	ldr	r3, [r7, #4]
341a44b4:	2208      	movs	r2, #8
341a44b6:	601a      	str	r2, [r3, #0]
        Param_info->size = ((sfdp_param_header.Length ) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
341a44b8:	7dfb      	ldrb	r3, [r7, #23]
                             ? sfdp_param_header.Length : SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE;
341a44ba:	2b17      	cmp	r3, #23
341a44bc:	bf28      	it	cs
341a44be:	2317      	movcs	r3, #23
341a44c0:	b2da      	uxtb	r2, r3
        Param_info->size = ((sfdp_param_header.Length ) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
341a44c2:	687b      	ldr	r3, [r7, #4]
341a44c4:	721a      	strb	r2, [r3, #8]
        break;
341a44c6:	e045      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_SECTORMAP;
341a44c8:	687b      	ldr	r3, [r7, #4]
341a44ca:	2210      	movs	r2, #16
341a44cc:	601a      	str	r2, [r3, #0]
        break;
341a44ce:	e041      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_RPMC;
341a44d0:	687b      	ldr	r3, [r7, #4]
341a44d2:	2220      	movs	r2, #32
341a44d4:	601a      	str	r2, [r3, #0]
        break;
341a44d6:	e03d      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION;
341a44d8:	687b      	ldr	r3, [r7, #4]
341a44da:	2240      	movs	r2, #64	@ 0x40
341a44dc:	601a      	str	r2, [r3, #0]
        break;
341a44de:	e039      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_XSPI_V1_0;
341a44e0:	687b      	ldr	r3, [r7, #4]
341a44e2:	2280      	movs	r2, #128	@ 0x80
341a44e4:	601a      	str	r2, [r3, #0]
        break;
341a44e6:	e035      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_XSPI_V2_0;
341a44e8:	687b      	ldr	r3, [r7, #4]
341a44ea:	f44f 7280 	mov.w	r2, #256	@ 0x100
341a44ee:	601a      	str	r2, [r3, #0]
        break;
341a44f0:	e030      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP;
341a44f2:	687b      	ldr	r3, [r7, #4]
341a44f4:	f44f 7200 	mov.w	r2, #512	@ 0x200
341a44f8:	601a      	str	r2, [r3, #0]
        break;
341a44fa:	e02b      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP_MULTICHIP;
341a44fc:	687b      	ldr	r3, [r7, #4]
341a44fe:	f44f 6280 	mov.w	r2, #1024	@ 0x400
341a4502:	601a      	str	r2, [r3, #0]
        break;
341a4504:	e026      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_XSPI_V2_0;
341a4506:	687b      	ldr	r3, [r7, #4]
341a4508:	f44f 6200 	mov.w	r2, #2048	@ 0x800
341a450c:	601a      	str	r2, [r3, #0]
        break;
341a450e:	e021      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_OCTAL_DDR;
341a4510:	687b      	ldr	r3, [r7, #4]
341a4512:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
341a4516:	601a      	str	r2, [r3, #0]
        break;
341a4518:	e01c      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_MSPT;
341a451a:	687b      	ldr	r3, [r7, #4]
341a451c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
341a4520:	601a      	str	r2, [r3, #0]
        break;
341a4522:	e017      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_X4QUAD_DS;
341a4524:	687b      	ldr	r3, [r7, #4]
341a4526:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
341a452a:	601a      	str	r2, [r3, #0]
        break;
341a452c:	e012      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_QUAD_DDR;
341a452e:	687b      	ldr	r3, [r7, #4]
341a4530:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
341a4534:	601a      	str	r2, [r3, #0]
        break;
341a4536:	e00d      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_SECURE_PACKET_READ_WRITE;
341a4538:	687b      	ldr	r3, [r7, #4]
341a453a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
341a453e:	601a      	str	r2, [r3, #0]
        break;
341a4540:	e008      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        Param_info->type = SFDP_PARAMID_RESERVED;
341a4542:	687b      	ldr	r3, [r7, #4]
341a4544:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
341a4548:	601a      	str	r2, [r3, #0]
        break;
341a454a:	e003      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
  }
  else
  {
    /* Unexpected value for MSB field of SFDP Parameter ID */
    SFDP_DEBUG_STR("-> Unexpected value for MSB field of SFDP Parameter ID");
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
341a454c:	2303      	movs	r3, #3
341a454e:	77fb      	strb	r3, [r7, #31]
    goto error;
341a4550:	e000      	b.n	341a4554 <sfdp_get_paraminfo+0x1ec>
        break;
341a4552:	bf00      	nop
  }

error:
  return retr;
341a4554:	7ffb      	ldrb	r3, [r7, #31]
}
341a4556:	4618      	mov	r0, r3
341a4558:	3720      	adds	r7, #32
341a455a:	46bd      	mov	sp, r7
341a455c:	bd80      	pop	{r7, pc}
341a455e:	bf00      	nop

341a4560 <sfdp_enter_octal_mode>:
 * @brief This function executes the octal DDR table to enter octal DDR mode
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_enter_octal_mode(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a4560:	b590      	push	{r4, r7, lr}
341a4562:	b085      	sub	sp, #20
341a4564:	af00      	add	r7, sp, #0
341a4566:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a4568:	2300      	movs	r3, #0
341a456a:	73fb      	strb	r3, [r7, #15]
  uint8_t data[7];
  SFDP_DEBUG_STR(__func__);
  /* D1-D2 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand)
341a456c:	4b6d      	ldr	r3, [pc, #436]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a456e:	78db      	ldrb	r3, [r3, #3]
341a4570:	2b00      	cmp	r3, #0
341a4572:	d028      	beq.n	341a45c6 <sfdp_enter_octal_mode+0x66>
  {
    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte1CommandSequence;
341a4574:	4b6b      	ldr	r3, [pc, #428]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4576:	789b      	ldrb	r3, [r3, #2]
341a4578:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte2CommandSequence;
341a457a:	4b6a      	ldr	r3, [pc, #424]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a457c:	785b      	ldrb	r3, [r3, #1]
341a457e:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte3CommandSequence;
341a4580:	4b68      	ldr	r3, [pc, #416]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4582:	781b      	ldrb	r3, [r3, #0]
341a4584:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte4CommandSequence;
341a4586:	4b67      	ldr	r3, [pc, #412]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4588:	79db      	ldrb	r3, [r3, #7]
341a458a:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte5CommandSequence;
341a458c:	4b65      	ldr	r3, [pc, #404]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a458e:	799b      	ldrb	r3, [r3, #6]
341a4590:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte6CommandSequence;
341a4592:	4b64      	ldr	r3, [pc, #400]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4594:	795b      	ldrb	r3, [r3, #5]
341a4596:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte7CommandSequence;
341a4598:	4b62      	ldr	r3, [pc, #392]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a459a:	791b      	ldrb	r3, [r3, #4]
341a459c:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a459e:	687b      	ldr	r3, [r7, #4]
341a45a0:	f103 0008 	add.w	r0, r3, #8
341a45a4:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand - 1u)))
341a45a6:	4b5f      	ldr	r3, [pc, #380]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45a8:	78db      	ldrb	r3, [r3, #3]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a45aa:	3b01      	subs	r3, #1
341a45ac:	b29c      	uxth	r4, r3
341a45ae:	f107 0308 	add.w	r3, r7, #8
341a45b2:	1c5a      	adds	r2, r3, #1
341a45b4:	4623      	mov	r3, r4
341a45b6:	f7fe fc0c 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a45ba:	4603      	mov	r3, r0
341a45bc:	2b00      	cmp	r3, #0
341a45be:	d002      	beq.n	341a45c6 <sfdp_enter_octal_mode+0x66>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a45c0:	230b      	movs	r3, #11
341a45c2:	73fb      	strb	r3, [r7, #15]
      goto error;
341a45c4:	e0a9      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D3-D4 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand)
341a45c6:	4b57      	ldr	r3, [pc, #348]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45c8:	7adb      	ldrb	r3, [r3, #11]
341a45ca:	2b00      	cmp	r3, #0
341a45cc:	d032      	beq.n	341a4634 <sfdp_enter_octal_mode+0xd4>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a45ce:	2164      	movs	r1, #100	@ 0x64
341a45d0:	6878      	ldr	r0, [r7, #4]
341a45d2:	f7ff fe65 	bl	341a42a0 <driver_check_FlagBUSY>
341a45d6:	4603      	mov	r3, r0
341a45d8:	2b00      	cmp	r3, #0
341a45da:	d002      	beq.n	341a45e2 <sfdp_enter_octal_mode+0x82>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a45dc:	230c      	movs	r3, #12
341a45de:	73fb      	strb	r3, [r7, #15]
      goto error;
341a45e0:	e09b      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte1CommandSequence;
341a45e2:	4b50      	ldr	r3, [pc, #320]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45e4:	7a9b      	ldrb	r3, [r3, #10]
341a45e6:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte2CommandSequence;
341a45e8:	4b4e      	ldr	r3, [pc, #312]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45ea:	7a5b      	ldrb	r3, [r3, #9]
341a45ec:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte3CommandSequence;
341a45ee:	4b4d      	ldr	r3, [pc, #308]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45f0:	7a1b      	ldrb	r3, [r3, #8]
341a45f2:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte4CommandSequence;
341a45f4:	4b4b      	ldr	r3, [pc, #300]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45f6:	7bdb      	ldrb	r3, [r3, #15]
341a45f8:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte5CommandSequence;
341a45fa:	4b4a      	ldr	r3, [pc, #296]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a45fc:	7b9b      	ldrb	r3, [r3, #14]
341a45fe:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte6CommandSequence;
341a4600:	4b48      	ldr	r3, [pc, #288]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4602:	7b5b      	ldrb	r3, [r3, #13]
341a4604:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte7CommandSequence;
341a4606:	4b47      	ldr	r3, [pc, #284]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4608:	7b1b      	ldrb	r3, [r3, #12]
341a460a:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a460c:	687b      	ldr	r3, [r7, #4]
341a460e:	f103 0008 	add.w	r0, r3, #8
341a4612:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand - 1u)))
341a4614:	4b43      	ldr	r3, [pc, #268]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4616:	7adb      	ldrb	r3, [r3, #11]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a4618:	3b01      	subs	r3, #1
341a461a:	b29c      	uxth	r4, r3
341a461c:	f107 0308 	add.w	r3, r7, #8
341a4620:	1c5a      	adds	r2, r3, #1
341a4622:	4623      	mov	r3, r4
341a4624:	f7fe fbd5 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a4628:	4603      	mov	r3, r0
341a462a:	2b00      	cmp	r3, #0
341a462c:	d002      	beq.n	341a4634 <sfdp_enter_octal_mode+0xd4>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a462e:	230b      	movs	r3, #11
341a4630:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4632:	e072      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D5-D6 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand)
341a4634:	4b3b      	ldr	r3, [pc, #236]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4636:	7cdb      	ldrb	r3, [r3, #19]
341a4638:	2b00      	cmp	r3, #0
341a463a:	d032      	beq.n	341a46a2 <sfdp_enter_octal_mode+0x142>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a463c:	2164      	movs	r1, #100	@ 0x64
341a463e:	6878      	ldr	r0, [r7, #4]
341a4640:	f7ff fe2e 	bl	341a42a0 <driver_check_FlagBUSY>
341a4644:	4603      	mov	r3, r0
341a4646:	2b00      	cmp	r3, #0
341a4648:	d002      	beq.n	341a4650 <sfdp_enter_octal_mode+0xf0>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a464a:	230c      	movs	r3, #12
341a464c:	73fb      	strb	r3, [r7, #15]
      goto error;
341a464e:	e064      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte1CommandSequence;
341a4650:	4b34      	ldr	r3, [pc, #208]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4652:	7c9b      	ldrb	r3, [r3, #18]
341a4654:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte2CommandSequence;
341a4656:	4b33      	ldr	r3, [pc, #204]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4658:	7c5b      	ldrb	r3, [r3, #17]
341a465a:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte3CommandSequence;
341a465c:	4b31      	ldr	r3, [pc, #196]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a465e:	7c1b      	ldrb	r3, [r3, #16]
341a4660:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte4CommandSequence;
341a4662:	4b30      	ldr	r3, [pc, #192]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4664:	7ddb      	ldrb	r3, [r3, #23]
341a4666:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte5CommandSequence;
341a4668:	4b2e      	ldr	r3, [pc, #184]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a466a:	7d9b      	ldrb	r3, [r3, #22]
341a466c:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte6CommandSequence;
341a466e:	4b2d      	ldr	r3, [pc, #180]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4670:	7d5b      	ldrb	r3, [r3, #21]
341a4672:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte7CommandSequence;
341a4674:	4b2b      	ldr	r3, [pc, #172]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4676:	7d1b      	ldrb	r3, [r3, #20]
341a4678:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a467a:	687b      	ldr	r3, [r7, #4]
341a467c:	f103 0008 	add.w	r0, r3, #8
341a4680:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand - 1u)))
341a4682:	4b28      	ldr	r3, [pc, #160]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a4684:	7cdb      	ldrb	r3, [r3, #19]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a4686:	3b01      	subs	r3, #1
341a4688:	b29c      	uxth	r4, r3
341a468a:	f107 0308 	add.w	r3, r7, #8
341a468e:	1c5a      	adds	r2, r3, #1
341a4690:	4623      	mov	r3, r4
341a4692:	f7fe fb9e 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a4696:	4603      	mov	r3, r0
341a4698:	2b00      	cmp	r3, #0
341a469a:	d002      	beq.n	341a46a2 <sfdp_enter_octal_mode+0x142>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a469c:	230b      	movs	r3, #11
341a469e:	73fb      	strb	r3, [r7, #15]
      goto error;
341a46a0:	e03b      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D7-D8 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand)
341a46a2:	4b20      	ldr	r3, [pc, #128]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46a4:	7edb      	ldrb	r3, [r3, #27]
341a46a6:	2b00      	cmp	r3, #0
341a46a8:	d032      	beq.n	341a4710 <sfdp_enter_octal_mode+0x1b0>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a46aa:	2164      	movs	r1, #100	@ 0x64
341a46ac:	6878      	ldr	r0, [r7, #4]
341a46ae:	f7ff fdf7 	bl	341a42a0 <driver_check_FlagBUSY>
341a46b2:	4603      	mov	r3, r0
341a46b4:	2b00      	cmp	r3, #0
341a46b6:	d002      	beq.n	341a46be <sfdp_enter_octal_mode+0x15e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a46b8:	230c      	movs	r3, #12
341a46ba:	73fb      	strb	r3, [r7, #15]
      goto error;
341a46bc:	e02d      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte1CommandSequence;
341a46be:	4b19      	ldr	r3, [pc, #100]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46c0:	7e9b      	ldrb	r3, [r3, #26]
341a46c2:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte2CommandSequence;
341a46c4:	4b17      	ldr	r3, [pc, #92]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46c6:	7e5b      	ldrb	r3, [r3, #25]
341a46c8:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte3CommandSequence;
341a46ca:	4b16      	ldr	r3, [pc, #88]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46cc:	7e1b      	ldrb	r3, [r3, #24]
341a46ce:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte4CommandSequence;
341a46d0:	4b14      	ldr	r3, [pc, #80]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46d2:	7fdb      	ldrb	r3, [r3, #31]
341a46d4:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte5CommandSequence;
341a46d6:	4b13      	ldr	r3, [pc, #76]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46d8:	7f9b      	ldrb	r3, [r3, #30]
341a46da:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte6CommandSequence;
341a46dc:	4b11      	ldr	r3, [pc, #68]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46de:	7f5b      	ldrb	r3, [r3, #29]
341a46e0:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte7CommandSequence;
341a46e2:	4b10      	ldr	r3, [pc, #64]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46e4:	7f1b      	ldrb	r3, [r3, #28]
341a46e6:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a46e8:	687b      	ldr	r3, [r7, #4]
341a46ea:	f103 0008 	add.w	r0, r3, #8
341a46ee:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand - 1u)))
341a46f0:	4b0c      	ldr	r3, [pc, #48]	@ (341a4724 <sfdp_enter_octal_mode+0x1c4>)
341a46f2:	7edb      	ldrb	r3, [r3, #27]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
341a46f4:	3b01      	subs	r3, #1
341a46f6:	b29c      	uxth	r4, r3
341a46f8:	f107 0308 	add.w	r3, r7, #8
341a46fc:	1c5a      	adds	r2, r3, #1
341a46fe:	4623      	mov	r3, r4
341a4700:	f7fe fb67 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a4704:	4603      	mov	r3, r0
341a4706:	2b00      	cmp	r3, #0
341a4708:	d002      	beq.n	341a4710 <sfdp_enter_octal_mode+0x1b0>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
341a470a:	230b      	movs	r3, #11
341a470c:	73fb      	strb	r3, [r7, #15]
      goto error;
341a470e:	e004      	b.n	341a471a <sfdp_enter_octal_mode+0x1ba>

    /* no more wait for busy flag clear here, as command format might have changed to Octal */
  }

  /* Abort any ongoing transfer to avoid performance issue */
  SAL_XSPI_Abort(&Object->sfdp_private.SALObject);
341a4710:	687b      	ldr	r3, [r7, #4]
341a4712:	3308      	adds	r3, #8
341a4714:	4618      	mov	r0, r3
341a4716:	f7fe fd2b 	bl	341a3170 <SAL_XSPI_Abort>

error:
  return retr;
341a471a:	7bfb      	ldrb	r3, [r7, #15]
}
341a471c:	4618      	mov	r0, r3
341a471e:	3714      	adds	r7, #20
341a4720:	46bd      	mov	sp, r7
341a4722:	bd90      	pop	{r4, r7, pc}
341a4724:	341c1e44 	.word	0x341c1e44

341a4728 <sfdp_set_dummycycle>:
 * @brief This function writes the config register to set dummy cycle
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef sfdp_set_dummycycle(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t DummyValue)
{
341a4728:	b5f0      	push	{r4, r5, r6, r7, lr}
341a472a:	b08b      	sub	sp, #44	@ 0x2c
341a472c:	af04      	add	r7, sp, #16
341a472e:	6078      	str	r0, [r7, #4]
341a4730:	6039      	str	r1, [r7, #0]
const uint8_t MaskWaitStateValue[4] = { 0x3u, 0x7u, 0xFu, 0x1Fu };
341a4732:	4b76      	ldr	r3, [pc, #472]	@ (341a490c <sfdp_set_dummycycle+0x1e4>)
341a4734:	60fb      	str	r3, [r7, #12]
SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
341a4736:	2300      	movs	r3, #0
341a4738:	75fb      	strb	r3, [r7, #23]
uint8_t localValue[2] = { 0 };
341a473a:	2300      	movs	r3, #0
341a473c:	813b      	strh	r3, [r7, #8]
uint32_t Address;

  if((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
341a473e:	4b74      	ldr	r3, [pc, #464]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4740:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4744:	f003 0310 	and.w	r3, r3, #16
341a4748:	b2db      	uxtb	r3, r3
341a474a:	2b00      	cmp	r3, #0
341a474c:	d10a      	bne.n	341a4764 <sfdp_set_dummycycle+0x3c>
    (JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable == 1u))
341a474e:	4b70      	ldr	r3, [pc, #448]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4750:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4754:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
341a4758:	b2db      	uxtb	r3, r3
  if((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
341a475a:	2b00      	cmp	r3, #0
341a475c:	d002      	beq.n	341a4764 <sfdp_set_dummycycle+0x3c>
  {
    /* Not yet supported */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a475e:	230c      	movs	r3, #12
341a4760:	75fb      	strb	r3, [r7, #23]
    goto error;
341a4762:	e0ce      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* Compute the Address */
  if (JEDEC_SCCR_Map.Param_DWORD.D9.LocalAddress == 1u)
341a4764:	4b6a      	ldr	r3, [pc, #424]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4766:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a476a:	f003 0308 	and.w	r3, r3, #8
341a476e:	b2db      	uxtb	r3, r3
341a4770:	2b00      	cmp	r3, #0
341a4772:	d005      	beq.n	341a4780 <sfdp_set_dummycycle+0x58>
  {
    /* Local Address is found in Byte 1 of 32-bit address */
    Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported << 8;
341a4774:	4b66      	ldr	r3, [pc, #408]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4776:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
341a477a:	021b      	lsls	r3, r3, #8
341a477c:	613b      	str	r3, [r7, #16]
341a477e:	e00b      	b.n	341a4798 <sfdp_set_dummycycle+0x70>
  }
  else
  {
    /* Specific case of GigaDevice GD25LX512ME where register address is wrongly coded in SFDP table */
    if (Object->sfdp_private.ManuID == 0xC8)
341a4780:	687b      	ldr	r3, [r7, #4]
341a4782:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a4786:	2bc8      	cmp	r3, #200	@ 0xc8
341a4788:	d102      	bne.n	341a4790 <sfdp_set_dummycycle+0x68>
    {
      /* Address value in datasheet : 1, address value coded in SFDP table 200 */
      Address = 1U;
341a478a:	2301      	movs	r3, #1
341a478c:	613b      	str	r3, [r7, #16]
341a478e:	e003      	b.n	341a4798 <sfdp_set_dummycycle+0x70>
    }
    else
    {
      /* Local address for Variable Dummy Cycle Settings bits is found in last byte of the address */
      Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported;
341a4790:	4b5f      	ldr	r3, [pc, #380]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4792:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
341a4796:	613b      	str	r3, [r7, #16]
    }
  }

  /* Read the configuration */
  if (HAL_OK != SAL_XSPI_CommandSendReadAddress(&Object->sfdp_private.SALObject,
341a4798:	687b      	ldr	r3, [r7, #4]
341a479a:	f103 0008 	add.w	r0, r3, #8
341a479e:	4b5c      	ldr	r3, [pc, #368]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a47a0:	f893 1021 	ldrb.w	r1, [r3, #33]	@ 0x21
341a47a4:	687b      	ldr	r3, [r7, #4]
341a47a6:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
341a47aa:	f107 0208 	add.w	r2, r7, #8
341a47ae:	9301      	str	r3, [sp, #4]
341a47b0:	2302      	movs	r3, #2
341a47b2:	9300      	str	r3, [sp, #0]
341a47b4:	4613      	mov	r3, r2
341a47b6:	693a      	ldr	r2, [r7, #16]
341a47b8:	f7fe fbb3 	bl	341a2f22 <SAL_XSPI_CommandSendReadAddress>
341a47bc:	4603      	mov	r3, r0
341a47be:	2b00      	cmp	r3, #0
341a47c0:	d002      	beq.n	341a47c8 <sfdp_set_dummycycle+0xa0>
                                                Address,
                                                (uint8_t *)localValue,
                                                2u,
                                                Object->sfdp_private.ManuID))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a47c2:	230c      	movs	r3, #12
341a47c4:	75fb      	strb	r3, [r7, #23]
    goto error;
341a47c6:	e09c      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* send command to write enable */
  if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
341a47c8:	687b      	ldr	r3, [r7, #4]
341a47ca:	f103 0008 	add.w	r0, r3, #8
341a47ce:	687b      	ldr	r3, [r7, #4]
341a47d0:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a47d4:	2300      	movs	r3, #0
341a47d6:	2200      	movs	r2, #0
341a47d8:	f7fe fafb 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a47dc:	4603      	mov	r3, r0
341a47de:	2b00      	cmp	r3, #0
341a47e0:	d002      	beq.n	341a47e8 <sfdp_set_dummycycle+0xc0>
                                         Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a47e2:	230c      	movs	r3, #12
341a47e4:	75fb      	strb	r3, [r7, #23]
    goto error;
341a47e6:	e08c      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* control the write enable */
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a47e8:	687b      	ldr	r3, [r7, #4]
341a47ea:	f103 0008 	add.w	r0, r3, #8
341a47ee:	687b      	ldr	r3, [r7, #4]
341a47f0:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                             Object->sfdp_private.DriverInfo.ReadWELCommand,
                                             Object->sfdp_private.DriverInfo.WELAddress,
341a47f4:	687b      	ldr	r3, [r7, #4]
341a47f6:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a47fa:	461e      	mov	r6, r3
                                             ((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u: 0u) << Object->sfdp_private.DriverInfo.WELPosition,
341a47fc:	687b      	ldr	r3, [r7, #4]
341a47fe:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
341a4802:	2b00      	cmp	r3, #0
341a4804:	d101      	bne.n	341a480a <sfdp_set_dummycycle+0xe2>
341a4806:	2301      	movs	r3, #1
341a4808:	e000      	b.n	341a480c <sfdp_set_dummycycle+0xe4>
341a480a:	2300      	movs	r3, #0
341a480c:	687a      	ldr	r2, [r7, #4]
341a480e:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
341a4812:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a4814:	b2dc      	uxtb	r4, r3
                                             1u << Object->sfdp_private.DriverInfo.WELPosition,
341a4816:	687b      	ldr	r3, [r7, #4]
341a4818:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
341a481c:	461a      	mov	r2, r3
341a481e:	2301      	movs	r3, #1
341a4820:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
341a4822:	b2db      	uxtb	r3, r3
341a4824:	687a      	ldr	r2, [r7, #4]
341a4826:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
341a482a:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
341a482e:	9502      	str	r5, [sp, #8]
341a4830:	9201      	str	r2, [sp, #4]
341a4832:	9300      	str	r3, [sp, #0]
341a4834:	4623      	mov	r3, r4
341a4836:	4632      	mov	r2, r6
341a4838:	f7fe fbd8 	bl	341a2fec <SAL_XSPI_CheckStatusRegister>
341a483c:	4603      	mov	r3, r0
341a483e:	2b00      	cmp	r3, #0
341a4840:	d002      	beq.n	341a4848 <sfdp_set_dummycycle+0x120>
                                             Object->sfdp_private.ManuID, 1000))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4842:	230c      	movs	r3, #12
341a4844:	75fb      	strb	r3, [r7, #23]
    goto error;
341a4846:	e05c      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* clear the value */
  localValue[0] = localValue[0] & ~(MaskWaitStateValue[JEDEC_SCCR_Map.Param_DWORD.D9.NumberBitsUsedToSetWaitStates] << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
341a4848:	7a3b      	ldrb	r3, [r7, #8]
341a484a:	b25a      	sxtb	r2, r3
341a484c:	4b30      	ldr	r3, [pc, #192]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a484e:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4852:	f3c3 1341 	ubfx	r3, r3, #5, #2
341a4856:	b2db      	uxtb	r3, r3
341a4858:	3318      	adds	r3, #24
341a485a:	443b      	add	r3, r7
341a485c:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
341a4860:	4619      	mov	r1, r3
341a4862:	4b2b      	ldr	r3, [pc, #172]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4864:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4868:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a486c:	b2db      	uxtb	r3, r3
341a486e:	fa01 f303 	lsl.w	r3, r1, r3
341a4872:	b25b      	sxtb	r3, r3
341a4874:	43db      	mvns	r3, r3
341a4876:	b25b      	sxtb	r3, r3
341a4878:	4013      	ands	r3, r2
341a487a:	b25b      	sxtb	r3, r3
341a487c:	b2db      	uxtb	r3, r3
341a487e:	723b      	strb	r3, [r7, #8]

  /* Apply the value with the mask */
  localValue[0] =  localValue[0] | (uint8_t)(DummyValue << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
341a4880:	7a3a      	ldrb	r2, [r7, #8]
341a4882:	4b23      	ldr	r3, [pc, #140]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a4884:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
341a4888:	f3c3 0302 	ubfx	r3, r3, #0, #3
341a488c:	b2db      	uxtb	r3, r3
341a488e:	4619      	mov	r1, r3
341a4890:	683b      	ldr	r3, [r7, #0]
341a4892:	408b      	lsls	r3, r1
341a4894:	b2db      	uxtb	r3, r3
341a4896:	4313      	orrs	r3, r2
341a4898:	b2db      	uxtb	r3, r3
341a489a:	723b      	strb	r3, [r7, #8]
  localValue[1] = localValue[0];
341a489c:	7a3b      	ldrb	r3, [r7, #8]
341a489e:	727b      	strb	r3, [r7, #9]

  /* Write de configuration */
  if (HAL_OK != SAL_XSPI_Write(&Object->sfdp_private.SALObject, (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D9.CommandWriteAccess, Address, (uint8_t *)localValue, 2u))
341a48a0:	687b      	ldr	r3, [r7, #4]
341a48a2:	f103 0008 	add.w	r0, r3, #8
341a48a6:	4b1a      	ldr	r3, [pc, #104]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a48a8:	f893 1020 	ldrb.w	r1, [r3, #32]
341a48ac:	f107 0308 	add.w	r3, r7, #8
341a48b0:	2202      	movs	r2, #2
341a48b2:	9200      	str	r2, [sp, #0]
341a48b4:	693a      	ldr	r2, [r7, #16]
341a48b6:	f7fe fa43 	bl	341a2d40 <SAL_XSPI_Write>
341a48ba:	4603      	mov	r3, r0
341a48bc:	2b00      	cmp	r3, #0
341a48be:	d002      	beq.n	341a48c6 <sfdp_set_dummycycle+0x19e>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a48c0:	230c      	movs	r3, #12
341a48c2:	75fb      	strb	r3, [r7, #23]
    goto error;
341a48c4:	e01d      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* wait for busy flag clear */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
341a48c6:	2164      	movs	r1, #100	@ 0x64
341a48c8:	6878      	ldr	r0, [r7, #4]
341a48ca:	f7ff fce9 	bl	341a42a0 <driver_check_FlagBUSY>
341a48ce:	4603      	mov	r3, r0
341a48d0:	2b00      	cmp	r3, #0
341a48d2:	d002      	beq.n	341a48da <sfdp_set_dummycycle+0x1b2>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a48d4:	230c      	movs	r3, #12
341a48d6:	75fb      	strb	r3, [r7, #23]
    goto error;
341a48d8:	e013      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

  /* Read the configuration, line can be removed it is only used for debug purpose */
  if (HAL_OK != SAL_XSPI_Read(&Object->sfdp_private.SALObject, (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D9.CommandReadAccess,
341a48da:	687b      	ldr	r3, [r7, #4]
341a48dc:	f103 0008 	add.w	r0, r3, #8
341a48e0:	4b0b      	ldr	r3, [pc, #44]	@ (341a4910 <sfdp_set_dummycycle+0x1e8>)
341a48e2:	f893 1021 	ldrb.w	r1, [r3, #33]	@ 0x21
341a48e6:	f107 0308 	add.w	r3, r7, #8
341a48ea:	2202      	movs	r2, #2
341a48ec:	9200      	str	r2, [sp, #0]
341a48ee:	693a      	ldr	r2, [r7, #16]
341a48f0:	f7fe f9be 	bl	341a2c70 <SAL_XSPI_Read>
341a48f4:	4603      	mov	r3, r0
341a48f6:	2b00      	cmp	r3, #0
341a48f8:	d002      	beq.n	341a4900 <sfdp_set_dummycycle+0x1d8>
                              Address, (uint8_t *)localValue, 2u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
341a48fa:	230c      	movs	r3, #12
341a48fc:	75fb      	strb	r3, [r7, #23]
    goto error;
341a48fe:	e000      	b.n	341a4902 <sfdp_set_dummycycle+0x1da>
  }

error :
341a4900:	bf00      	nop
  return retr;
341a4902:	7dfb      	ldrb	r3, [r7, #23]
}
341a4904:	4618      	mov	r0, r3
341a4906:	371c      	adds	r7, #28
341a4908:	46bd      	mov	sp, r7
341a490a:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a490c:	1f0f0703 	.word	0x1f0f0703
341a4910:	341c1dd4 	.word	0x341c1dd4

341a4914 <JEDEC_Basic_ManageQuadEnableRequirement>:
          JEDEC_Basic.Params.Param_DWORD.D15.QuadEnableRequirement parameter
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef JEDEC_Basic_ManageQuadEnableRequirement(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a4914:	b580      	push	{r7, lr}
341a4916:	b084      	sub	sp, #16
341a4918:	af00      	add	r7, sp, #0
341a491a:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a491c:	230f      	movs	r3, #15
341a491e:	73fb      	strb	r3, [r7, #15]
  uint8_t localValue[2];

  /* switch the mode in QSPI if available */
  switch (JEDEC_Basic.Params.Param_DWORD.D15.QuadEnableRequirement & 0x7u)
341a4920:	4b59      	ldr	r3, [pc, #356]	@ (341a4a88 <JEDEC_Basic_ManageQuadEnableRequirement+0x174>)
341a4922:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
341a4926:	f3c3 1302 	ubfx	r3, r3, #4, #3
341a492a:	b2db      	uxtb	r3, r3
341a492c:	2b07      	cmp	r3, #7
341a492e:	f200 80a4 	bhi.w	341a4a7a <JEDEC_Basic_ManageQuadEnableRequirement+0x166>
341a4932:	a201      	add	r2, pc, #4	@ (adr r2, 341a4938 <JEDEC_Basic_ManageQuadEnableRequirement+0x24>)
341a4934:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
341a4938:	341a4a7b 	.word	0x341a4a7b
341a493c:	341a4a7b 	.word	0x341a4a7b
341a4940:	341a4959 	.word	0x341a4959
341a4944:	341a4a7b 	.word	0x341a4a7b
341a4948:	341a49d9 	.word	0x341a49d9
341a494c:	341a4a7b 	.word	0x341a4a7b
341a4950:	341a4a7b 	.word	0x341a4a7b
341a4954:	341a4a7b 	.word	0x341a4a7b
              */
    break;
  case 0x2u: {/* 010b: QE is bit 6 of status register 1. It is set via Write Status with one data byte where bit 6 is one.
                 It is cleared via Write Status with one data byte where bit 6 is zero. */
    /* 1 - set the write enable */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject,
341a4958:	687b      	ldr	r3, [r7, #4]
341a495a:	f103 0008 	add.w	r0, r3, #8
341a495e:	687b      	ldr	r3, [r7, #4]
341a4960:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a4964:	2300      	movs	r3, #0
341a4966:	2200      	movs	r2, #0
341a4968:	f7fe fa87 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
341a496c:	4603      	mov	r3, r0
341a496e:	2b00      	cmp	r3, #0
341a4970:	d002      	beq.n	341a4978 <JEDEC_Basic_ManageQuadEnableRequirement+0x64>
                                           Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4972:	230c      	movs	r3, #12
341a4974:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4976:	e081      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* 2 - read the status register */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND,
341a4978:	687b      	ldr	r3, [r7, #4]
341a497a:	f103 0008 	add.w	r0, r3, #8
341a497e:	f107 020c 	add.w	r2, r7, #12
341a4982:	2301      	movs	r3, #1
341a4984:	2105      	movs	r1, #5
341a4986:	f7fe fa78 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
341a498a:	4603      	mov	r3, r0
341a498c:	2b00      	cmp	r3, #0
341a498e:	d002      	beq.n	341a4996 <JEDEC_Basic_ManageQuadEnableRequirement+0x82>
                                           (uint8_t *)&localValue[0], 1u))
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4990:	230c      	movs	r3, #12
341a4992:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4994:	e072      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* 3 - update the status register to enable QPI mode*/
    localValue[0] = localValue[0] | 0x40u;
341a4996:	7b3b      	ldrb	r3, [r7, #12]
341a4998:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a499c:	b2db      	uxtb	r3, r3
341a499e:	733b      	strb	r3, [r7, #12]

    /* 4 - write the status register with QPI mode to 1 */
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 1u))
341a49a0:	687b      	ldr	r3, [r7, #4]
341a49a2:	f103 0008 	add.w	r0, r3, #8
341a49a6:	f107 020c 	add.w	r2, r7, #12
341a49aa:	2301      	movs	r3, #1
341a49ac:	2101      	movs	r1, #1
341a49ae:	f7fe fa10 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a49b2:	4603      	mov	r3, r0
341a49b4:	2b00      	cmp	r3, #0
341a49b6:	d002      	beq.n	341a49be <JEDEC_Basic_ManageQuadEnableRequirement+0xaa>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a49b8:	230c      	movs	r3, #12
341a49ba:	73fb      	strb	r3, [r7, #15]
      goto error;
341a49bc:	e05e      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* wait busy flag  */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
341a49be:	2164      	movs	r1, #100	@ 0x64
341a49c0:	6878      	ldr	r0, [r7, #4]
341a49c2:	f7ff fc6d 	bl	341a42a0 <driver_check_FlagBUSY>
341a49c6:	4603      	mov	r3, r0
341a49c8:	2b00      	cmp	r3, #0
341a49ca:	d002      	beq.n	341a49d2 <JEDEC_Basic_ManageQuadEnableRequirement+0xbe>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a49cc:	230c      	movs	r3, #12
341a49ce:	73fb      	strb	r3, [r7, #15]
      goto error;
341a49d0:	e054      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    retr = EXTMEM_SFDP_OK;
341a49d2:	2300      	movs	r3, #0
341a49d4:	73fb      	strb	r3, [r7, #15]
    break;
341a49d6:	e051      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
  case 0x4u:{ /* 100b: QE is bit 1 of status register 2. It is set via Write Status with two data bytes where bit 1 of the second byte is one.
                It is cleared via Write Status with two data bytes where bit 1 of the second byte is zero.
                In contrast to the 001b code, writing one byte to the status register does not modify status register 2.*/

    /* read the status register */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
341a49d8:	687b      	ldr	r3, [r7, #4]
341a49da:	f103 0008 	add.w	r0, r3, #8
341a49de:	f107 020c 	add.w	r2, r7, #12
341a49e2:	2302      	movs	r3, #2
341a49e4:	2105      	movs	r1, #5
341a49e6:	f7fe fa48 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
341a49ea:	4603      	mov	r3, r0
341a49ec:	2b00      	cmp	r3, #0
341a49ee:	d002      	beq.n	341a49f6 <JEDEC_Basic_ManageQuadEnableRequirement+0xe2>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a49f0:	230c      	movs	r3, #12
341a49f2:	73fb      	strb	r3, [r7, #15]
      goto error;
341a49f4:	e042      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* update the status register */
    localValue[1] |= 2u;
341a49f6:	7b7b      	ldrb	r3, [r7, #13]
341a49f8:	f043 0302 	orr.w	r3, r3, #2
341a49fc:	b2db      	uxtb	r3, r3
341a49fe:	737b      	strb	r3, [r7, #13]

    /* WEL */
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
341a4a00:	687b      	ldr	r3, [r7, #4]
341a4a02:	f103 0008 	add.w	r0, r3, #8
341a4a06:	687b      	ldr	r3, [r7, #4]
341a4a08:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
341a4a0c:	2300      	movs	r3, #0
341a4a0e:	2200      	movs	r2, #0
341a4a10:	f7fe fa33 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
341a4a14:	4603      	mov	r3, r0
341a4a16:	2b00      	cmp	r3, #0
341a4a18:	d002      	beq.n	341a4a20 <JEDEC_Basic_ManageQuadEnableRequirement+0x10c>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4a1a:	230c      	movs	r3, #12
341a4a1c:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4a1e:	e02d      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* write the status register */
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 2u))
341a4a20:	687b      	ldr	r3, [r7, #4]
341a4a22:	f103 0008 	add.w	r0, r3, #8
341a4a26:	f107 020c 	add.w	r2, r7, #12
341a4a2a:	2302      	movs	r3, #2
341a4a2c:	2101      	movs	r1, #1
341a4a2e:	f7fe f9d0 	bl	341a2dd2 <SAL_XSPI_CommandSendData>
341a4a32:	4603      	mov	r3, r0
341a4a34:	2b00      	cmp	r3, #0
341a4a36:	d002      	beq.n	341a4a3e <JEDEC_Basic_ManageQuadEnableRequirement+0x12a>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4a38:	230c      	movs	r3, #12
341a4a3a:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4a3c:	e01e      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* wait busy flag  */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
341a4a3e:	2164      	movs	r1, #100	@ 0x64
341a4a40:	6878      	ldr	r0, [r7, #4]
341a4a42:	f7ff fc2d 	bl	341a42a0 <driver_check_FlagBUSY>
341a4a46:	4603      	mov	r3, r0
341a4a48:	2b00      	cmp	r3, #0
341a4a4a:	d002      	beq.n	341a4a52 <JEDEC_Basic_ManageQuadEnableRequirement+0x13e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4a4c:	230c      	movs	r3, #12
341a4a4e:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4a50:	e014      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    /* Optional : only for control read the status register and check write operation is OK */
    localValue[1] = 0xFF;
341a4a52:	23ff      	movs	r3, #255	@ 0xff
341a4a54:	737b      	strb	r3, [r7, #13]
    if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
341a4a56:	687b      	ldr	r3, [r7, #4]
341a4a58:	f103 0008 	add.w	r0, r3, #8
341a4a5c:	f107 020c 	add.w	r2, r7, #12
341a4a60:	2302      	movs	r3, #2
341a4a62:	2105      	movs	r1, #5
341a4a64:	f7fe fa09 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
341a4a68:	4603      	mov	r3, r0
341a4a6a:	2b00      	cmp	r3, #0
341a4a6c:	d002      	beq.n	341a4a74 <JEDEC_Basic_ManageQuadEnableRequirement+0x160>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
341a4a6e:	230c      	movs	r3, #12
341a4a70:	73fb      	strb	r3, [r7, #15]
      goto error;
341a4a72:	e003      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
    }

    retr = EXTMEM_SFDP_OK;
341a4a74:	2300      	movs	r3, #0
341a4a76:	73fb      	strb	r3, [r7, #15]
    break;
341a4a78:	e000      	b.n	341a4a7c <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
  case 0x6u: /* 110b: QE is bit 1 of the status register 2. Status register 1 is read using Read Status instruction 05h. Status register 2 is read using instruction 35h, and status register 3 is read using instruction 15h. QE is set via Write Status Register instruction 31h with one data byte where bit 1 is one. It is cleared via Write Status Register instruction 31h with one data byte where bit 1 is zero.*/
    break;
  case 0x7u: /*111b: Reserved */
    break;
  default :/* Added for Misra */
    break;
341a4a7a:	bf00      	nop
  }
error :
  return retr;
341a4a7c:	7bfb      	ldrb	r3, [r7, #15]
}
341a4a7e:	4618      	mov	r0, r3
341a4a80:	3710      	adds	r7, #16
341a4a82:	46bd      	mov	sp, r7
341a4a84:	bd80      	pop	{r7, pc}
341a4a86:	bf00      	nop
341a4a88:	341c1d54 	.word	0x341c1d54

341a4a8c <JEDEC_Basic_Manage4S4S4SEnableSequence>:
          JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence parameter
 * @param Object memory Object
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef JEDEC_Basic_Manage4S4S4SEnableSequence(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
341a4a8c:	b580      	push	{r7, lr}
341a4a8e:	b084      	sub	sp, #16
341a4a90:	af00      	add	r7, sp, #0
341a4a92:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
341a4a94:	230f      	movs	r3, #15
341a4a96:	73fb      	strb	r3, [r7, #15]
  uint8_t instruction = 0x00u;
341a4a98:	2300      	movs	r3, #0
341a4a9a:	73bb      	strb	r3, [r7, #14]

  /* 4-4-4 mode enable sequences; This field describes the supported methods to enter 4-4-4 mode from 1-1-1 mode */
  /* x_xxx1b: set QE per QER description above, then issue instruction 38h */
  if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x1u) == 0x1u)
341a4a9c:	4b1a      	ldr	r3, [pc, #104]	@ (341a4b08 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
341a4a9e:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
341a4aa0:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a4aa4:	b2db      	uxtb	r3, r3
341a4aa6:	f003 0301 	and.w	r3, r3, #1
341a4aaa:	2b00      	cmp	r3, #0
341a4aac:	d007      	beq.n	341a4abe <JEDEC_Basic_Manage4S4S4SEnableSequence+0x32>
  {
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
341a4aae:	6878      	ldr	r0, [r7, #4]
341a4ab0:	f7ff ff30 	bl	341a4914 <JEDEC_Basic_ManageQuadEnableRequirement>
341a4ab4:	4603      	mov	r3, r0
341a4ab6:	73fb      	strb	r3, [r7, #15]
    instruction = 0x38u;
341a4ab8:	2338      	movs	r3, #56	@ 0x38
341a4aba:	73bb      	strb	r3, [r7, #14]
341a4abc:	e00f      	b.n	341a4ade <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  }
  /* x_x1xxb: issue instruction 35h */
  else if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x4u) == 0x4u)
341a4abe:	4b12      	ldr	r3, [pc, #72]	@ (341a4b08 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
341a4ac0:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
341a4ac2:	f3c3 1304 	ubfx	r3, r3, #4, #5
341a4ac6:	b2db      	uxtb	r3, r3
341a4ac8:	f003 0304 	and.w	r3, r3, #4
341a4acc:	2b00      	cmp	r3, #0
341a4ace:	d006      	beq.n	341a4ade <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  {
    /* If QE bit exists, Quad Enable Requirement describes method to enable Quad operations */
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
341a4ad0:	6878      	ldr	r0, [r7, #4]
341a4ad2:	f7ff ff1f 	bl	341a4914 <JEDEC_Basic_ManageQuadEnableRequirement>
341a4ad6:	4603      	mov	r3, r0
341a4ad8:	73fb      	strb	r3, [r7, #15]
    instruction = 0x35u;
341a4ada:	2335      	movs	r3, #53	@ 0x35
341a4adc:	73bb      	strb	r3, [r7, #14]
       Device uses a read-modify-write sequence of operations:
       Read Volatile Enhanced Configuration Register using instruction 65h, no address is required, set bit 7 to 1.
       Write Volatile Enhanced Configuration Register using instruction 61h, no address is required. This configuration is volatile.
  NOTE If device is in 0-4-4 mode, then this mode must be exited before the 4-4-4 enable sequence is issued.
  */
  if ((retr == EXTMEM_SFDP_OK) && (instruction != 0u))
341a4ade:	7bfb      	ldrb	r3, [r7, #15]
341a4ae0:	2b00      	cmp	r3, #0
341a4ae2:	d10c      	bne.n	341a4afe <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
341a4ae4:	7bbb      	ldrb	r3, [r7, #14]
341a4ae6:	2b00      	cmp	r3, #0
341a4ae8:	d009      	beq.n	341a4afe <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
  {
    (void)SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, instruction, NULL, 0u);
341a4aea:	687b      	ldr	r3, [r7, #4]
341a4aec:	f103 0008 	add.w	r0, r3, #8
341a4af0:	7bb9      	ldrb	r1, [r7, #14]
341a4af2:	2300      	movs	r3, #0
341a4af4:	2200      	movs	r2, #0
341a4af6:	f7fe f9c0 	bl	341a2e7a <SAL_XSPI_SendReadCommand>
    /* @note on memory W25Q64JV the command 38h does not exist so the control on command execution has been removed */
    retr = EXTMEM_SFDP_OK;
341a4afa:	2300      	movs	r3, #0
341a4afc:	73fb      	strb	r3, [r7, #15]
  }

  return retr;
341a4afe:	7bfb      	ldrb	r3, [r7, #15]
}
341a4b00:	4618      	mov	r0, r3
341a4b02:	3710      	adds	r7, #16
341a4b04:	46bd      	mov	sp, r7
341a4b06:	bd80      	pop	{r7, pc}
341a4b08:	341c1d54 	.word	0x341c1d54

341a4b0c <CheckSFDP_Signature>:
 * @param Object memory Object
 * @param Signature value of the SFDP signature
 * @return @ref SFDP_StatusTypeDef
 */
SFDP_StatusTypeDef CheckSFDP_Signature(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t Signature )
{
341a4b0c:	b580      	push	{r7, lr}
341a4b0e:	b084      	sub	sp, #16
341a4b10:	af00      	add	r7, sp, #0
341a4b12:	6078      	str	r0, [r7, #4]
341a4b14:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
341a4b16:	2304      	movs	r3, #4
341a4b18:	73fb      	strb	r3, [r7, #15]

  /* check the magic number */
  switch(Signature)
341a4b1a:	683b      	ldr	r3, [r7, #0]
341a4b1c:	4a0e      	ldr	r2, [pc, #56]	@ (341a4b58 <CheckSFDP_Signature+0x4c>)
341a4b1e:	4293      	cmp	r3, r2
341a4b20:	d006      	beq.n	341a4b30 <CheckSFDP_Signature+0x24>
341a4b22:	683b      	ldr	r3, [r7, #0]
341a4b24:	4a0d      	ldr	r2, [pc, #52]	@ (341a4b5c <CheckSFDP_Signature+0x50>)
341a4b26:	4293      	cmp	r3, r2
341a4b28:	d10e      	bne.n	341a4b48 <CheckSFDP_Signature+0x3c>
  {
  case SFDP_SIGNATURE :
    SFDP_DEBUG_STR("signature of the header: OK");
    retr = EXTMEM_SFDP_OK;
341a4b2a:	2300      	movs	r3, #0
341a4b2c:	73fb      	strb	r3, [r7, #15]
    break;
341a4b2e:	e00e      	b.n	341a4b4e <CheckSFDP_Signature+0x42>
  case SFDP_SIGNATURE_INVERTED :
    SFDP_DEBUG_STR("signature of the header: KO inverted data order");
    /* Change the memory type settings */
    if (HAL_OK == SAL_XSPI_UpdateMemoryType(&Object->sfdp_private.SALObject, SAL_XSPI_ORDERINVERTED))
341a4b30:	687b      	ldr	r3, [r7, #4]
341a4b32:	3308      	adds	r3, #8
341a4b34:	2100      	movs	r1, #0
341a4b36:	4618      	mov	r0, r3
341a4b38:	f7fe fae2 	bl	341a3100 <SAL_XSPI_UpdateMemoryType>
341a4b3c:	4603      	mov	r3, r0
341a4b3e:	2b00      	cmp	r3, #0
341a4b40:	d104      	bne.n	341a4b4c <CheckSFDP_Signature+0x40>
    {
      retr = EXTMEM_SFDP_ERROR_SIGNATUREMTYPE;
341a4b42:	2305      	movs	r3, #5
341a4b44:	73fb      	strb	r3, [r7, #15]
    }
    break;
341a4b46:	e001      	b.n	341a4b4c <CheckSFDP_Signature+0x40>
  default :
    SFDP_DEBUG_STR("signature of the header: KO");
    break;
341a4b48:	bf00      	nop
341a4b4a:	e000      	b.n	341a4b4e <CheckSFDP_Signature+0x42>
    break;
341a4b4c:	bf00      	nop
  }
  return retr;
341a4b4e:	7bfb      	ldrb	r3, [r7, #15]
}
341a4b50:	4618      	mov	r0, r3
341a4b52:	3710      	adds	r7, #16
341a4b54:	46bd      	mov	sp, r7
341a4b56:	bd80      	pop	{r7, pc}
341a4b58:	44505346 	.word	0x44505346
341a4b5c:	50444653 	.word	0x50444653

341a4b60 <EXTMEM_DRIVER_NOR_SFDP_Init>:
/** @defgroup DRIVER_SFDP_Exported_Functions DRIVER SFDP Exported Functions
  * @{
  */

EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef EXTMEM_DRIVER_NOR_SFDP_Init(void *Peripheral, EXTMEM_LinkConfig_TypeDef Config, uint32_t ClockInput, EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject)
{
341a4b60:	b580      	push	{r7, lr}
341a4b62:	b08a      	sub	sp, #40	@ 0x28
341a4b64:	af00      	add	r7, sp, #0
341a4b66:	60f8      	str	r0, [r7, #12]
341a4b68:	607a      	str	r2, [r7, #4]
341a4b6a:	603b      	str	r3, [r7, #0]
341a4b6c:	460b      	mov	r3, r1
341a4b6e:	72fb      	strb	r3, [r7, #11]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_OK;
341a4b70:	2300      	movs	r3, #0
341a4b72:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  SFDP_HeaderTypeDef JEDEC_SFDP_Header;
  uint8_t FreqUpdate = 0u;
341a4b76:	2300      	movs	r3, #0
341a4b78:	76fb      	strb	r3, [r7, #27]
  uint8_t DataID[6];
  uint32_t ClockOut;

  /* reset data of SFDPObject to zero */
  SFDP_DEBUG_STR("1 - reset data SFDPObject to zero")
  (void)memset((void *)&SFDPObject->sfdp_private, 0x0, sizeof(SFDPObject->sfdp_private));
341a4b7a:	683b      	ldr	r3, [r7, #0]
341a4b7c:	3308      	adds	r3, #8
341a4b7e:	2298      	movs	r2, #152	@ 0x98
341a4b80:	2100      	movs	r1, #0
341a4b82:	4618      	mov	r0, r3
341a4b84:	f000 fcb4 	bl	341a54f0 <memset>

  /* initialize the SFDPObject */
  SFDP_DEBUG_STR("2 - initialize the SFDPObject")
  SFDPObject->sfdp_private.Config = Config;
341a4b88:	683b      	ldr	r3, [r7, #0]
341a4b8a:	7afa      	ldrb	r2, [r7, #11]
341a4b8c:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
  SFDPObject->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
341a4b90:	683b      	ldr	r3, [r7, #0]
341a4b92:	2200      	movs	r2, #0
341a4b94:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
  SFDPObject->sfdp_private.DriverInfo.ClockIn = ClockInput;
341a4b98:	683b      	ldr	r3, [r7, #0]
341a4b9a:	687a      	ldr	r2, [r7, #4]
341a4b9c:	669a      	str	r2, [r3, #104]	@ 0x68
  SAL_XSPI_SET_SFDPDUMMYCYLE(SFDPObject->sfdp_private.SALObject, EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_DEFAULT);
341a4b9e:	683b      	ldr	r3, [r7, #0]
341a4ba0:	2208      	movs	r2, #8
341a4ba2:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

  /* set memory speed to 50Mhz maximum */
  SFDP_DEBUG_STR("3 - set memory link and speed to 50Mhz maximum")
  (void)SAL_XSPI_Init(&SFDPObject->sfdp_private.SALObject, Peripheral);
341a4ba6:	683b      	ldr	r3, [r7, #0]
341a4ba8:	3308      	adds	r3, #8
341a4baa:	68f9      	ldr	r1, [r7, #12]
341a4bac:	4618      	mov	r0, r3
341a4bae:	f7fd fdff 	bl	341a27b0 <SAL_XSPI_Init>
  (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput, DRIVER_SFDP_DEFAULT_CLOCK, &ClockOut);
341a4bb2:	683b      	ldr	r3, [r7, #0]
341a4bb4:	f103 0008 	add.w	r0, r3, #8
341a4bb8:	f107 0310 	add.w	r3, r7, #16
341a4bbc:	4a45      	ldr	r2, [pc, #276]	@ (341a4cd4 <EXTMEM_DRIVER_NOR_SFDP_Init+0x174>)
341a4bbe:	6879      	ldr	r1, [r7, #4]
341a4bc0:	f7fd fdb7 	bl	341a2732 <SAL_XSPI_SetClock>

  /* Abort any ongoing XSPI action */
  (void)SAL_XSPI_DisableMapMode(&SFDPObject->sfdp_private.SALObject);
341a4bc4:	683b      	ldr	r3, [r7, #0]
341a4bc6:	3308      	adds	r3, #8
341a4bc8:	4618      	mov	r0, r3
341a4bca:	f7fe fa88 	bl	341a30de <SAL_XSPI_DisableMapMode>

  /* analyze the SFDP structure to get driver information */
  SFDP_DEBUG_STR("4 - analyze the SFDP structure to get driver information")
  if(EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
341a4bce:	f107 031c 	add.w	r3, r7, #28
341a4bd2:	4619      	mov	r1, r3
341a4bd4:	6838      	ldr	r0, [r7, #0]
341a4bd6:	f7fe fb65 	bl	341a32a4 <SFDP_GetHeader>
341a4bda:	4603      	mov	r3, r0
341a4bdc:	2b00      	cmp	r3, #0
341a4bde:	d003      	beq.n	341a4be8 <EXTMEM_DRIVER_NOR_SFDP_Init+0x88>
    /*
     *  for the future, we can try to get SFDP by using different mode
     *  the SFDP read is only performed in 1S1S1S mode
     */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a4be0:	23ff      	movs	r3, #255	@ 0xff
341a4be2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a4be6:	e06e      	b.n	341a4cc6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* Reset the memory */
  SFDP_DEBUG_STR("5 - reset the memory")
  if(EXTMEM_SFDP_OK != SFDP_MemoryReset(SFDPObject))
341a4be8:	6838      	ldr	r0, [r7, #0]
341a4bea:	f7fe fc95 	bl	341a3518 <SFDP_MemoryReset>
     */
    SFDP_DEBUG_STR("ERROR::on the call of SFDP_MemoryReset but no error returned")
  }

  /* wait few ms after the reset operation, this is done to avoid issue on SFDP read */
  HAL_Delay(10);
341a4bee:	200a      	movs	r0, #10
341a4bf0:	f7e1 fc9a 	bl	34186528 <HAL_Delay>

  /* analyze the SFDP structure to get driver information after the reset */
  SFDP_DEBUG_STR("6 - analyze the SFDP structure to get driver information")
  if(EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
341a4bf4:	f107 031c 	add.w	r3, r7, #28
341a4bf8:	4619      	mov	r1, r3
341a4bfa:	6838      	ldr	r0, [r7, #0]
341a4bfc:	f7fe fb52 	bl	341a32a4 <SFDP_GetHeader>
341a4c00:	4603      	mov	r3, r0
341a4c02:	2b00      	cmp	r3, #0
341a4c04:	d003      	beq.n	341a4c0e <EXTMEM_DRIVER_NOR_SFDP_Init+0xae>
    /*
     *  for the future, we can try to get SFDP by using different mode
     *  the SFDP read is only perform in 1S1S1S mode
     */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a4c06:	23ff      	movs	r3, #255	@ 0xff
341a4c08:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a4c0c:	e05b      	b.n	341a4cc6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* Save information from the SFDP table
     Nb of parameters starts at 0 (0 means 1 parameter) */
  if (JEDEC_SFDP_Header.param_number >= SFDP_MAX_NB_OF_PARAM)
341a4c0e:	f897 3022 	ldrb.w	r3, [r7, #34]	@ 0x22
341a4c12:	2b09      	cmp	r3, #9
341a4c14:	d904      	bls.n	341a4c20 <EXTMEM_DRIVER_NOR_SFDP_Init+0xc0>
  {
    SFDPObject->sfdp_private.Sfdp_param_number = SFDP_MAX_NB_OF_PARAM - 1;
341a4c16:	683b      	ldr	r3, [r7, #0]
341a4c18:	2209      	movs	r2, #9
341a4c1a:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
341a4c1e:	e004      	b.n	341a4c2a <EXTMEM_DRIVER_NOR_SFDP_Init+0xca>
  }
  else
  {
    SFDPObject->sfdp_private.Sfdp_param_number = JEDEC_SFDP_Header.param_number;
341a4c20:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
341a4c24:	683b      	ldr	r3, [r7, #0]
341a4c26:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
  }
  SFDPObject->sfdp_private.Sfdp_AccessProtocol = JEDEC_SFDP_Header.AccessProtocol;
341a4c2a:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
341a4c2e:	683b      	ldr	r3, [r7, #0]
341a4c30:	f883 209d 	strb.w	r2, [r3, #157]	@ 0x9d

  /* read the flash ID */
  SFDP_DEBUG_STR("7 - read the flash ID")
  (void)SAL_XSPI_GetId(&SFDPObject->sfdp_private.SALObject, DataID, EXTMEM_READ_JEDEC_ID_SIZE);
341a4c34:	683b      	ldr	r3, [r7, #0]
341a4c36:	3308      	adds	r3, #8
341a4c38:	f107 0114 	add.w	r1, r7, #20
341a4c3c:	2204      	movs	r2, #4
341a4c3e:	4618      	mov	r0, r3
341a4c40:	f7fd ff96 	bl	341a2b70 <SAL_XSPI_GetId>
  DEBUG_ID(DataID);

  /* Keep manufacturer information, it could be used to help in
     building of consistent driver */
  SFDPObject->sfdp_private.ManuID = DataID[0];
341a4c44:	7d3a      	ldrb	r2, [r7, #20]
341a4c46:	683b      	ldr	r3, [r7, #0]
341a4c48:	f883 205d 	strb.w	r2, [r3, #93]	@ 0x5d

  /* get the SFDP data */
  SFDP_DEBUG_STR("8 - collect the SFDP data")
  if(EXTMEM_SFDP_OK != SFDP_CollectData(SFDPObject))
341a4c4c:	6838      	ldr	r0, [r7, #0]
341a4c4e:	f7fe fb87 	bl	341a3360 <SFDP_CollectData>
341a4c52:	4603      	mov	r3, r0
341a4c54:	2b00      	cmp	r3, #0
341a4c56:	d003      	beq.n	341a4c60 <EXTMEM_DRIVER_NOR_SFDP_Init+0x100>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
341a4c58:	23ff      	movs	r3, #255	@ 0xff
341a4c5a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a4c5e:	e032      	b.n	341a4cc6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  /* setup the generic driver information and prepare the physical layer */
  SFDP_DEBUG_STR("9 - build the generic driver information and prepare the physical layer")
  if(EXTMEM_SFDP_OK != SFDP_BuildGenericDriver(SFDPObject, &FreqUpdate))
341a4c60:	f107 031b 	add.w	r3, r7, #27
341a4c64:	4619      	mov	r1, r3
341a4c66:	6838      	ldr	r0, [r7, #0]
341a4c68:	f7fe fd32 	bl	341a36d0 <SFDP_BuildGenericDriver>
341a4c6c:	4603      	mov	r3, r0
341a4c6e:	2b00      	cmp	r3, #0
341a4c70:	d003      	beq.n	341a4c7a <EXTMEM_DRIVER_NOR_SFDP_Init+0x11a>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD;
341a4c72:	23fd      	movs	r3, #253	@ 0xfd
341a4c74:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a4c78:	e025      	b.n	341a4cc6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  SFDP_DEBUG_STR("10 - adjust the frequency if required")
  if ((FreqUpdate == 0u) && (SFDPObject->sfdp_public.MaxFreq != 0u))
341a4c7a:	7efb      	ldrb	r3, [r7, #27]
341a4c7c:	2b00      	cmp	r3, #0
341a4c7e:	d10d      	bne.n	341a4c9c <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
341a4c80:	683b      	ldr	r3, [r7, #0]
341a4c82:	681b      	ldr	r3, [r3, #0]
341a4c84:	2b00      	cmp	r3, #0
341a4c86:	d009      	beq.n	341a4c9c <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
  {
    (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput, SFDPObject->sfdp_public.MaxFreq, &ClockOut);
341a4c88:	683b      	ldr	r3, [r7, #0]
341a4c8a:	f103 0008 	add.w	r0, r3, #8
341a4c8e:	683b      	ldr	r3, [r7, #0]
341a4c90:	681a      	ldr	r2, [r3, #0]
341a4c92:	f107 0310 	add.w	r3, r7, #16
341a4c96:	6879      	ldr	r1, [r7, #4]
341a4c98:	f7fd fd4b 	bl	341a2732 <SAL_XSPI_SetClock>
    SFDP_DEBUG_STR("--> new freq configured");
  }

  SFDP_DEBUG_STR("11 - read again the SFDP header to adjust memory type if necessary")
  if(EXTMEM_SFDP_OK != SFDP_ReadHeader(SFDPObject, &JEDEC_SFDP_Header))
341a4c9c:	f107 031c 	add.w	r3, r7, #28
341a4ca0:	4619      	mov	r1, r3
341a4ca2:	6838      	ldr	r0, [r7, #0]
341a4ca4:	f7fe fac1 	bl	341a322a <SFDP_ReadHeader>
341a4ca8:	4603      	mov	r3, r0
341a4caa:	2b00      	cmp	r3, #0
341a4cac:	d003      	beq.n	341a4cb6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x156>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_MEMTYPE_CHECK")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_MEMTYPE_CHECK;
341a4cae:	23f2      	movs	r3, #242	@ 0xf2
341a4cb0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
341a4cb4:	e007      	b.n	341a4cc6 <EXTMEM_DRIVER_NOR_SFDP_Init+0x166>
  }

  (void)SAL_XSPI_GetId(&SFDPObject->sfdp_private.SALObject, DataID, EXTMEM_READ_JEDEC_ID_SIZE);
341a4cb6:	683b      	ldr	r3, [r7, #0]
341a4cb8:	3308      	adds	r3, #8
341a4cba:	f107 0114 	add.w	r1, r7, #20
341a4cbe:	2204      	movs	r2, #4
341a4cc0:	4618      	mov	r0, r3
341a4cc2:	f7fd ff55 	bl	341a2b70 <SAL_XSPI_GetId>
  DEBUG_ID(DataID);

error:
  return retr;
341a4cc6:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
}
341a4cca:	4618      	mov	r0, r3
341a4ccc:	3728      	adds	r7, #40	@ 0x28
341a4cce:	46bd      	mov	sp, r7
341a4cd0:	bd80      	pop	{r7, pc}
341a4cd2:	bf00      	nop
341a4cd4:	02faf080 	.word	0x02faf080

341a4cd8 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
341a4cd8:	b580      	push	{r7, lr}
341a4cda:	b082      	sub	sp, #8
341a4cdc:	af00      	add	r7, sp, #0
341a4cde:	6078      	str	r0, [r7, #4]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
341a4ce0:	687b      	ldr	r3, [r7, #4]
341a4ce2:	681b      	ldr	r3, [r3, #0]
341a4ce4:	4a2b      	ldr	r2, [pc, #172]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4ce6:	6013      	str	r3, [r2, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
341a4ce8:	687b      	ldr	r3, [r7, #4]
341a4cea:	685b      	ldr	r3, [r3, #4]
341a4cec:	4a29      	ldr	r2, [pc, #164]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4cee:	6053      	str	r3, [r2, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
341a4cf0:	687b      	ldr	r3, [r7, #4]
341a4cf2:	689b      	ldr	r3, [r3, #8]
341a4cf4:	4a27      	ldr	r2, [pc, #156]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4cf6:	6093      	str	r3, [r2, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
341a4cf8:	687b      	ldr	r3, [r7, #4]
341a4cfa:	68db      	ldr	r3, [r3, #12]
341a4cfc:	4a25      	ldr	r2, [pc, #148]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4cfe:	60d3      	str	r3, [r2, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
341a4d00:	687b      	ldr	r3, [r7, #4]
341a4d02:	691b      	ldr	r3, [r3, #16]
341a4d04:	4a23      	ldr	r2, [pc, #140]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d06:	6113      	str	r3, [r2, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
341a4d08:	687b      	ldr	r3, [r7, #4]
341a4d0a:	695b      	ldr	r3, [r3, #20]
341a4d0c:	4a21      	ldr	r2, [pc, #132]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d0e:	6153      	str	r3, [r2, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
341a4d10:	687b      	ldr	r3, [r7, #4]
341a4d12:	699b      	ldr	r3, [r3, #24]
341a4d14:	4a1f      	ldr	r2, [pc, #124]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d16:	6193      	str	r3, [r2, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
341a4d18:	687b      	ldr	r3, [r7, #4]
341a4d1a:	69db      	ldr	r3, [r3, #28]
341a4d1c:	4a1d      	ldr	r2, [pc, #116]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d1e:	61d3      	str	r3, [r2, #28]
  FuncDriver.GetYSize       = pDrv->GetYSize;
341a4d20:	687b      	ldr	r3, [r7, #4]
341a4d22:	6a1b      	ldr	r3, [r3, #32]
341a4d24:	4a1b      	ldr	r2, [pc, #108]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d26:	6213      	str	r3, [r2, #32]
  FuncDriver.SetLayer       = pDrv->SetLayer;
341a4d28:	687b      	ldr	r3, [r7, #4]
341a4d2a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a4d2c:	4a19      	ldr	r2, [pc, #100]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d2e:	6253      	str	r3, [r2, #36]	@ 0x24
  FuncDriver.GetFormat      = pDrv->GetFormat;
341a4d30:	687b      	ldr	r3, [r7, #4]
341a4d32:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341a4d34:	4a17      	ldr	r2, [pc, #92]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d36:	6293      	str	r3, [r2, #40]	@ 0x28

  DrawProp->LcdLayer = 0;
341a4d38:	4b17      	ldr	r3, [pc, #92]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d3a:	2200      	movs	r2, #0
341a4d3c:	60da      	str	r2, [r3, #12]
  DrawProp->LcdDevice = 0;
341a4d3e:	4b16      	ldr	r3, [pc, #88]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d40:	2200      	movs	r2, #0
341a4d42:	611a      	str	r2, [r3, #16]
  FuncDriver.GetXSize(0, &DrawProp[DrawProp->LcdLayer].LcdXsize);
341a4d44:	4b13      	ldr	r3, [pc, #76]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d46:	69db      	ldr	r3, [r3, #28]
341a4d48:	4a13      	ldr	r2, [pc, #76]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d4a:	68d2      	ldr	r2, [r2, #12]
341a4d4c:	0152      	lsls	r2, r2, #5
341a4d4e:	3210      	adds	r2, #16
341a4d50:	4911      	ldr	r1, [pc, #68]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d52:	440a      	add	r2, r1
341a4d54:	3204      	adds	r2, #4
341a4d56:	4611      	mov	r1, r2
341a4d58:	2000      	movs	r0, #0
341a4d5a:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp[DrawProp->LcdLayer].LcdYsize);
341a4d5c:	4b0d      	ldr	r3, [pc, #52]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d5e:	6a1b      	ldr	r3, [r3, #32]
341a4d60:	4a0d      	ldr	r2, [pc, #52]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d62:	68d2      	ldr	r2, [r2, #12]
341a4d64:	0152      	lsls	r2, r2, #5
341a4d66:	3218      	adds	r2, #24
341a4d68:	490b      	ldr	r1, [pc, #44]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d6a:	440a      	add	r2, r1
341a4d6c:	4611      	mov	r1, r2
341a4d6e:	2000      	movs	r0, #0
341a4d70:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
341a4d72:	4b08      	ldr	r3, [pc, #32]	@ (341a4d94 <UTIL_LCD_SetFuncDriver+0xbc>)
341a4d74:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341a4d76:	4a08      	ldr	r2, [pc, #32]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d78:	68d2      	ldr	r2, [r2, #12]
341a4d7a:	0152      	lsls	r2, r2, #5
341a4d7c:	3218      	adds	r2, #24
341a4d7e:	4906      	ldr	r1, [pc, #24]	@ (341a4d98 <UTIL_LCD_SetFuncDriver+0xc0>)
341a4d80:	440a      	add	r2, r1
341a4d82:	3204      	adds	r2, #4
341a4d84:	4611      	mov	r1, r2
341a4d86:	2000      	movs	r0, #0
341a4d88:	4798      	blx	r3
}
341a4d8a:	bf00      	nop
341a4d8c:	3708      	adds	r7, #8
341a4d8e:	46bd      	mov	sp, r7
341a4d90:	bd80      	pop	{r7, pc}
341a4d92:	bf00      	nop
341a4d94:	341c1ea4 	.word	0x341c1ea4
341a4d98:	341c1e64 	.word	0x341c1e64

341a4d9c <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
341a4d9c:	b580      	push	{r7, lr}
341a4d9e:	b082      	sub	sp, #8
341a4da0:	af00      	add	r7, sp, #0
341a4da2:	6078      	str	r0, [r7, #4]
  if(FuncDriver.SetLayer != NULL)
341a4da4:	4b1d      	ldr	r3, [pc, #116]	@ (341a4e1c <UTIL_LCD_SetLayer+0x80>)
341a4da6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a4da8:	2b00      	cmp	r3, #0
341a4daa:	d032      	beq.n	341a4e12 <UTIL_LCD_SetLayer+0x76>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
341a4dac:	4b1b      	ldr	r3, [pc, #108]	@ (341a4e1c <UTIL_LCD_SetLayer+0x80>)
341a4dae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
341a4db0:	4a1b      	ldr	r2, [pc, #108]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4db2:	6912      	ldr	r2, [r2, #16]
341a4db4:	6879      	ldr	r1, [r7, #4]
341a4db6:	4610      	mov	r0, r2
341a4db8:	4798      	blx	r3
341a4dba:	4603      	mov	r3, r0
341a4dbc:	2b00      	cmp	r3, #0
341a4dbe:	d128      	bne.n	341a4e12 <UTIL_LCD_SetLayer+0x76>
    {
      DrawProp->LcdLayer = Layer;
341a4dc0:	4a17      	ldr	r2, [pc, #92]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dc2:	687b      	ldr	r3, [r7, #4]
341a4dc4:	60d3      	str	r3, [r2, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
341a4dc6:	4b15      	ldr	r3, [pc, #84]	@ (341a4e1c <UTIL_LCD_SetLayer+0x80>)
341a4dc8:	69db      	ldr	r3, [r3, #28]
341a4dca:	4a15      	ldr	r2, [pc, #84]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dcc:	6910      	ldr	r0, [r2, #16]
341a4dce:	4a14      	ldr	r2, [pc, #80]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dd0:	68d2      	ldr	r2, [r2, #12]
341a4dd2:	0152      	lsls	r2, r2, #5
341a4dd4:	3210      	adds	r2, #16
341a4dd6:	4912      	ldr	r1, [pc, #72]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dd8:	440a      	add	r2, r1
341a4dda:	3204      	adds	r2, #4
341a4ddc:	4611      	mov	r1, r2
341a4dde:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
341a4de0:	4b0e      	ldr	r3, [pc, #56]	@ (341a4e1c <UTIL_LCD_SetLayer+0x80>)
341a4de2:	6a1b      	ldr	r3, [r3, #32]
341a4de4:	4a0e      	ldr	r2, [pc, #56]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4de6:	6910      	ldr	r0, [r2, #16]
341a4de8:	4a0d      	ldr	r2, [pc, #52]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dea:	68d2      	ldr	r2, [r2, #12]
341a4dec:	0152      	lsls	r2, r2, #5
341a4dee:	3218      	adds	r2, #24
341a4df0:	490b      	ldr	r1, [pc, #44]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4df2:	440a      	add	r2, r1
341a4df4:	4611      	mov	r1, r2
341a4df6:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
341a4df8:	4b08      	ldr	r3, [pc, #32]	@ (341a4e1c <UTIL_LCD_SetLayer+0x80>)
341a4dfa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
341a4dfc:	4a08      	ldr	r2, [pc, #32]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4dfe:	6910      	ldr	r0, [r2, #16]
341a4e00:	4a07      	ldr	r2, [pc, #28]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4e02:	68d2      	ldr	r2, [r2, #12]
341a4e04:	0152      	lsls	r2, r2, #5
341a4e06:	3218      	adds	r2, #24
341a4e08:	4905      	ldr	r1, [pc, #20]	@ (341a4e20 <UTIL_LCD_SetLayer+0x84>)
341a4e0a:	440a      	add	r2, r1
341a4e0c:	3204      	adds	r2, #4
341a4e0e:	4611      	mov	r1, r2
341a4e10:	4798      	blx	r3
    }
  }
}
341a4e12:	bf00      	nop
341a4e14:	3708      	adds	r7, #8
341a4e16:	46bd      	mov	sp, r7
341a4e18:	bd80      	pop	{r7, pc}
341a4e1a:	bf00      	nop
341a4e1c:	341c1ea4 	.word	0x341c1ea4
341a4e20:	341c1e64 	.word	0x341c1e64

341a4e24 <UTIL_LCD_SetTextColor>:
/**
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
341a4e24:	b480      	push	{r7}
341a4e26:	b083      	sub	sp, #12
341a4e28:	af00      	add	r7, sp, #0
341a4e2a:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
341a4e2c:	4b06      	ldr	r3, [pc, #24]	@ (341a4e48 <UTIL_LCD_SetTextColor+0x24>)
341a4e2e:	68db      	ldr	r3, [r3, #12]
341a4e30:	4a05      	ldr	r2, [pc, #20]	@ (341a4e48 <UTIL_LCD_SetTextColor+0x24>)
341a4e32:	015b      	lsls	r3, r3, #5
341a4e34:	4413      	add	r3, r2
341a4e36:	687a      	ldr	r2, [r7, #4]
341a4e38:	601a      	str	r2, [r3, #0]
}
341a4e3a:	bf00      	nop
341a4e3c:	370c      	adds	r7, #12
341a4e3e:	46bd      	mov	sp, r7
341a4e40:	f85d 7b04 	ldr.w	r7, [sp], #4
341a4e44:	4770      	bx	lr
341a4e46:	bf00      	nop
341a4e48:	341c1e64 	.word	0x341c1e64

341a4e4c <UTIL_LCD_SetBackColor>:
/**
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
341a4e4c:	b480      	push	{r7}
341a4e4e:	b083      	sub	sp, #12
341a4e50:	af00      	add	r7, sp, #0
341a4e52:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
341a4e54:	4b06      	ldr	r3, [pc, #24]	@ (341a4e70 <UTIL_LCD_SetBackColor+0x24>)
341a4e56:	68db      	ldr	r3, [r3, #12]
341a4e58:	4a05      	ldr	r2, [pc, #20]	@ (341a4e70 <UTIL_LCD_SetBackColor+0x24>)
341a4e5a:	015b      	lsls	r3, r3, #5
341a4e5c:	4413      	add	r3, r2
341a4e5e:	3304      	adds	r3, #4
341a4e60:	687a      	ldr	r2, [r7, #4]
341a4e62:	601a      	str	r2, [r3, #0]
}
341a4e64:	bf00      	nop
341a4e66:	370c      	adds	r7, #12
341a4e68:	46bd      	mov	sp, r7
341a4e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
341a4e6e:	4770      	bx	lr
341a4e70:	341c1e64 	.word	0x341c1e64

341a4e74 <UTIL_LCD_SetFont>:
/**
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
341a4e74:	b480      	push	{r7}
341a4e76:	b083      	sub	sp, #12
341a4e78:	af00      	add	r7, sp, #0
341a4e7a:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
341a4e7c:	4b06      	ldr	r3, [pc, #24]	@ (341a4e98 <UTIL_LCD_SetFont+0x24>)
341a4e7e:	68db      	ldr	r3, [r3, #12]
341a4e80:	4a05      	ldr	r2, [pc, #20]	@ (341a4e98 <UTIL_LCD_SetFont+0x24>)
341a4e82:	015b      	lsls	r3, r3, #5
341a4e84:	4413      	add	r3, r2
341a4e86:	3308      	adds	r3, #8
341a4e88:	687a      	ldr	r2, [r7, #4]
341a4e8a:	601a      	str	r2, [r3, #0]
}
341a4e8c:	bf00      	nop
341a4e8e:	370c      	adds	r7, #12
341a4e90:	46bd      	mov	sp, r7
341a4e92:	f85d 7b04 	ldr.w	r7, [sp], #4
341a4e96:	4770      	bx	lr
341a4e98:	341c1e64 	.word	0x341c1e64

341a4e9c <UTIL_LCD_Clear>:
/**
  * @brief  Clears the whole currently active layer of LTDC.
  * @param  Color  Color of the background
  */
void UTIL_LCD_Clear(uint32_t Color)
{
341a4e9c:	b580      	push	{r7, lr}
341a4e9e:	b084      	sub	sp, #16
341a4ea0:	af02      	add	r7, sp, #8
341a4ea2:	6078      	str	r0, [r7, #4]
  /* Clear the LCD */
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
341a4ea4:	4b0c      	ldr	r3, [pc, #48]	@ (341a4ed8 <UTIL_LCD_Clear+0x3c>)
341a4ea6:	68db      	ldr	r3, [r3, #12]
341a4ea8:	4a0b      	ldr	r2, [pc, #44]	@ (341a4ed8 <UTIL_LCD_Clear+0x3c>)
341a4eaa:	015b      	lsls	r3, r3, #5
341a4eac:	4413      	add	r3, r2
341a4eae:	3314      	adds	r3, #20
341a4eb0:	681a      	ldr	r2, [r3, #0]
341a4eb2:	4b09      	ldr	r3, [pc, #36]	@ (341a4ed8 <UTIL_LCD_Clear+0x3c>)
341a4eb4:	68db      	ldr	r3, [r3, #12]
341a4eb6:	4908      	ldr	r1, [pc, #32]	@ (341a4ed8 <UTIL_LCD_Clear+0x3c>)
341a4eb8:	015b      	lsls	r3, r3, #5
341a4eba:	440b      	add	r3, r1
341a4ebc:	3318      	adds	r3, #24
341a4ebe:	6819      	ldr	r1, [r3, #0]
341a4ec0:	687b      	ldr	r3, [r7, #4]
341a4ec2:	9300      	str	r3, [sp, #0]
341a4ec4:	460b      	mov	r3, r1
341a4ec6:	2100      	movs	r1, #0
341a4ec8:	2000      	movs	r0, #0
341a4eca:	f000 f807 	bl	341a4edc <UTIL_LCD_FillRect>
}
341a4ece:	bf00      	nop
341a4ed0:	3708      	adds	r7, #8
341a4ed2:	46bd      	mov	sp, r7
341a4ed4:	bd80      	pop	{r7, pc}
341a4ed6:	bf00      	nop
341a4ed8:	341c1e64 	.word	0x341c1e64

341a4edc <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
341a4edc:	b590      	push	{r4, r7, lr}
341a4ede:	b087      	sub	sp, #28
341a4ee0:	af02      	add	r7, sp, #8
341a4ee2:	60f8      	str	r0, [r7, #12]
341a4ee4:	60b9      	str	r1, [r7, #8]
341a4ee6:	607a      	str	r2, [r7, #4]
341a4ee8:	603b      	str	r3, [r7, #0]
  /* Fill the rectangle */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
341a4eea:	4b3a      	ldr	r3, [pc, #232]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4eec:	68db      	ldr	r3, [r3, #12]
341a4eee:	4a39      	ldr	r2, [pc, #228]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4ef0:	015b      	lsls	r3, r3, #5
341a4ef2:	4413      	add	r3, r2
341a4ef4:	331c      	adds	r3, #28
341a4ef6:	681b      	ldr	r3, [r3, #0]
341a4ef8:	2b02      	cmp	r3, #2
341a4efa:	d11a      	bne.n	341a4f32 <UTIL_LCD_FillRect+0x56>
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
341a4efc:	4b36      	ldr	r3, [pc, #216]	@ (341a4fd8 <UTIL_LCD_FillRect+0xfc>)
341a4efe:	691c      	ldr	r4, [r3, #16]
341a4f00:	4b34      	ldr	r3, [pc, #208]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f02:	6918      	ldr	r0, [r3, #16]
341a4f04:	6a3b      	ldr	r3, [r7, #32]
341a4f06:	08db      	lsrs	r3, r3, #3
341a4f08:	f003 021f 	and.w	r2, r3, #31
341a4f0c:	6a3b      	ldr	r3, [r7, #32]
341a4f0e:	0a9b      	lsrs	r3, r3, #10
341a4f10:	015b      	lsls	r3, r3, #5
341a4f12:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
341a4f16:	431a      	orrs	r2, r3
341a4f18:	6a3b      	ldr	r3, [r7, #32]
341a4f1a:	0cdb      	lsrs	r3, r3, #19
341a4f1c:	02db      	lsls	r3, r3, #11
341a4f1e:	b29b      	uxth	r3, r3
341a4f20:	4313      	orrs	r3, r2
341a4f22:	9301      	str	r3, [sp, #4]
341a4f24:	683b      	ldr	r3, [r7, #0]
341a4f26:	9300      	str	r3, [sp, #0]
341a4f28:	687b      	ldr	r3, [r7, #4]
341a4f2a:	68ba      	ldr	r2, [r7, #8]
341a4f2c:	68f9      	ldr	r1, [r7, #12]
341a4f2e:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
  }
}
341a4f30:	e04b      	b.n	341a4fca <UTIL_LCD_FillRect+0xee>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
341a4f32:	4b28      	ldr	r3, [pc, #160]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f34:	68db      	ldr	r3, [r3, #12]
341a4f36:	4a27      	ldr	r2, [pc, #156]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f38:	015b      	lsls	r3, r3, #5
341a4f3a:	4413      	add	r3, r2
341a4f3c:	331c      	adds	r3, #28
341a4f3e:	681b      	ldr	r3, [r3, #0]
341a4f40:	2b01      	cmp	r3, #1
341a4f42:	d10e      	bne.n	341a4f62 <UTIL_LCD_FillRect+0x86>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
341a4f44:	4b24      	ldr	r3, [pc, #144]	@ (341a4fd8 <UTIL_LCD_FillRect+0xfc>)
341a4f46:	691c      	ldr	r4, [r3, #16]
341a4f48:	4b22      	ldr	r3, [pc, #136]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f4a:	6918      	ldr	r0, [r3, #16]
341a4f4c:	6a3b      	ldr	r3, [r7, #32]
341a4f4e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
341a4f52:	9301      	str	r3, [sp, #4]
341a4f54:	683b      	ldr	r3, [r7, #0]
341a4f56:	9300      	str	r3, [sp, #0]
341a4f58:	687b      	ldr	r3, [r7, #4]
341a4f5a:	68ba      	ldr	r2, [r7, #8]
341a4f5c:	68f9      	ldr	r1, [r7, #12]
341a4f5e:	47a0      	blx	r4
}
341a4f60:	e033      	b.n	341a4fca <UTIL_LCD_FillRect+0xee>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
341a4f62:	4b1c      	ldr	r3, [pc, #112]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f64:	68db      	ldr	r3, [r3, #12]
341a4f66:	4a1b      	ldr	r2, [pc, #108]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f68:	015b      	lsls	r3, r3, #5
341a4f6a:	4413      	add	r3, r2
341a4f6c:	331c      	adds	r3, #28
341a4f6e:	681b      	ldr	r3, [r3, #0]
341a4f70:	2b04      	cmp	r3, #4
341a4f72:	d11e      	bne.n	341a4fb2 <UTIL_LCD_FillRect+0xd6>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
341a4f74:	4b18      	ldr	r3, [pc, #96]	@ (341a4fd8 <UTIL_LCD_FillRect+0xfc>)
341a4f76:	691c      	ldr	r4, [r3, #16]
341a4f78:	4b16      	ldr	r3, [pc, #88]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4f7a:	6918      	ldr	r0, [r3, #16]
341a4f7c:	6a3b      	ldr	r3, [r7, #32]
341a4f7e:	091b      	lsrs	r3, r3, #4
341a4f80:	f003 020f 	and.w	r2, r3, #15
341a4f84:	6a3b      	ldr	r3, [r7, #32]
341a4f86:	0b1b      	lsrs	r3, r3, #12
341a4f88:	011b      	lsls	r3, r3, #4
341a4f8a:	b2db      	uxtb	r3, r3
341a4f8c:	431a      	orrs	r2, r3
341a4f8e:	6a3b      	ldr	r3, [r7, #32]
341a4f90:	0d1b      	lsrs	r3, r3, #20
341a4f92:	021b      	lsls	r3, r3, #8
341a4f94:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
341a4f98:	431a      	orrs	r2, r3
341a4f9a:	6a3b      	ldr	r3, [r7, #32]
341a4f9c:	0f1b      	lsrs	r3, r3, #28
341a4f9e:	031b      	lsls	r3, r3, #12
341a4fa0:	4313      	orrs	r3, r2
341a4fa2:	9301      	str	r3, [sp, #4]
341a4fa4:	683b      	ldr	r3, [r7, #0]
341a4fa6:	9300      	str	r3, [sp, #0]
341a4fa8:	687b      	ldr	r3, [r7, #4]
341a4faa:	68ba      	ldr	r2, [r7, #8]
341a4fac:	68f9      	ldr	r1, [r7, #12]
341a4fae:	47a0      	blx	r4
}
341a4fb0:	e00b      	b.n	341a4fca <UTIL_LCD_FillRect+0xee>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
341a4fb2:	4b09      	ldr	r3, [pc, #36]	@ (341a4fd8 <UTIL_LCD_FillRect+0xfc>)
341a4fb4:	691c      	ldr	r4, [r3, #16]
341a4fb6:	4b07      	ldr	r3, [pc, #28]	@ (341a4fd4 <UTIL_LCD_FillRect+0xf8>)
341a4fb8:	6918      	ldr	r0, [r3, #16]
341a4fba:	6a3b      	ldr	r3, [r7, #32]
341a4fbc:	9301      	str	r3, [sp, #4]
341a4fbe:	683b      	ldr	r3, [r7, #0]
341a4fc0:	9300      	str	r3, [sp, #0]
341a4fc2:	687b      	ldr	r3, [r7, #4]
341a4fc4:	68ba      	ldr	r2, [r7, #8]
341a4fc6:	68f9      	ldr	r1, [r7, #12]
341a4fc8:	47a0      	blx	r4
}
341a4fca:	bf00      	nop
341a4fcc:	3714      	adds	r7, #20
341a4fce:	46bd      	mov	sp, r7
341a4fd0:	bd90      	pop	{r4, r7, pc}
341a4fd2:	bf00      	nop
341a4fd4:	341c1e64 	.word	0x341c1e64
341a4fd8:	341c1ea4 	.word	0x341c1ea4

341a4fdc <__assert_func>:
341a4fdc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
341a4fde:	4614      	mov	r4, r2
341a4fe0:	461a      	mov	r2, r3
341a4fe2:	4b09      	ldr	r3, [pc, #36]	@ (341a5008 <__assert_func+0x2c>)
341a4fe4:	4605      	mov	r5, r0
341a4fe6:	681b      	ldr	r3, [r3, #0]
341a4fe8:	68d8      	ldr	r0, [r3, #12]
341a4fea:	b14c      	cbz	r4, 341a5000 <__assert_func+0x24>
341a4fec:	4b07      	ldr	r3, [pc, #28]	@ (341a500c <__assert_func+0x30>)
341a4fee:	9100      	str	r1, [sp, #0]
341a4ff0:	4907      	ldr	r1, [pc, #28]	@ (341a5010 <__assert_func+0x34>)
341a4ff2:	e9cd 3401 	strd	r3, r4, [sp, #4]
341a4ff6:	462b      	mov	r3, r5
341a4ff8:	f000 f8b2 	bl	341a5160 <fiprintf>
341a4ffc:	f000 fb00 	bl	341a5600 <abort>
341a5000:	4b04      	ldr	r3, [pc, #16]	@ (341a5014 <__assert_func+0x38>)
341a5002:	461c      	mov	r4, r3
341a5004:	e7f3      	b.n	341a4fee <__assert_func+0x12>
341a5006:	bf00      	nop
341a5008:	341c0144 	.word	0x341c0144
341a500c:	341afbf5 	.word	0x341afbf5
341a5010:	341afc02 	.word	0x341afc02
341a5014:	341af7ad 	.word	0x341af7ad

341a5018 <std>:
341a5018:	2300      	movs	r3, #0
341a501a:	b510      	push	{r4, lr}
341a501c:	4604      	mov	r4, r0
341a501e:	6083      	str	r3, [r0, #8]
341a5020:	8181      	strh	r1, [r0, #12]
341a5022:	4619      	mov	r1, r3
341a5024:	6643      	str	r3, [r0, #100]	@ 0x64
341a5026:	81c2      	strh	r2, [r0, #14]
341a5028:	2208      	movs	r2, #8
341a502a:	6183      	str	r3, [r0, #24]
341a502c:	e9c0 3300 	strd	r3, r3, [r0]
341a5030:	e9c0 3304 	strd	r3, r3, [r0, #16]
341a5034:	305c      	adds	r0, #92	@ 0x5c
341a5036:	f000 fa5b 	bl	341a54f0 <memset>
341a503a:	4b0d      	ldr	r3, [pc, #52]	@ (341a5070 <std+0x58>)
341a503c:	6224      	str	r4, [r4, #32]
341a503e:	6263      	str	r3, [r4, #36]	@ 0x24
341a5040:	4b0c      	ldr	r3, [pc, #48]	@ (341a5074 <std+0x5c>)
341a5042:	62a3      	str	r3, [r4, #40]	@ 0x28
341a5044:	4b0c      	ldr	r3, [pc, #48]	@ (341a5078 <std+0x60>)
341a5046:	62e3      	str	r3, [r4, #44]	@ 0x2c
341a5048:	4b0c      	ldr	r3, [pc, #48]	@ (341a507c <std+0x64>)
341a504a:	6323      	str	r3, [r4, #48]	@ 0x30
341a504c:	4b0c      	ldr	r3, [pc, #48]	@ (341a5080 <std+0x68>)
341a504e:	429c      	cmp	r4, r3
341a5050:	d006      	beq.n	341a5060 <std+0x48>
341a5052:	f103 0268 	add.w	r2, r3, #104	@ 0x68
341a5056:	4294      	cmp	r4, r2
341a5058:	d002      	beq.n	341a5060 <std+0x48>
341a505a:	33d0      	adds	r3, #208	@ 0xd0
341a505c:	429c      	cmp	r4, r3
341a505e:	d105      	bne.n	341a506c <std+0x54>
341a5060:	f104 0058 	add.w	r0, r4, #88	@ 0x58
341a5064:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a5068:	f000 baba 	b.w	341a55e0 <__retarget_lock_init_recursive>
341a506c:	bd10      	pop	{r4, pc}
341a506e:	bf00      	nop
341a5070:	341a530d 	.word	0x341a530d
341a5074:	341a532f 	.word	0x341a532f
341a5078:	341a5367 	.word	0x341a5367
341a507c:	341a538b 	.word	0x341a538b
341a5080:	341c1ed0 	.word	0x341c1ed0

341a5084 <stdio_exit_handler>:
341a5084:	4a02      	ldr	r2, [pc, #8]	@ (341a5090 <stdio_exit_handler+0xc>)
341a5086:	4903      	ldr	r1, [pc, #12]	@ (341a5094 <stdio_exit_handler+0x10>)
341a5088:	4803      	ldr	r0, [pc, #12]	@ (341a5098 <stdio_exit_handler+0x14>)
341a508a:	f000 b87b 	b.w	341a5184 <_fwalk_sglue>
341a508e:	bf00      	nop
341a5090:	341c0138 	.word	0x341c0138
341a5094:	341a615d 	.word	0x341a615d
341a5098:	341c0148 	.word	0x341c0148

341a509c <cleanup_stdio>:
341a509c:	6841      	ldr	r1, [r0, #4]
341a509e:	4b0c      	ldr	r3, [pc, #48]	@ (341a50d0 <cleanup_stdio+0x34>)
341a50a0:	4299      	cmp	r1, r3
341a50a2:	b510      	push	{r4, lr}
341a50a4:	4604      	mov	r4, r0
341a50a6:	d001      	beq.n	341a50ac <cleanup_stdio+0x10>
341a50a8:	f001 f858 	bl	341a615c <_fflush_r>
341a50ac:	68a1      	ldr	r1, [r4, #8]
341a50ae:	4b09      	ldr	r3, [pc, #36]	@ (341a50d4 <cleanup_stdio+0x38>)
341a50b0:	4299      	cmp	r1, r3
341a50b2:	d002      	beq.n	341a50ba <cleanup_stdio+0x1e>
341a50b4:	4620      	mov	r0, r4
341a50b6:	f001 f851 	bl	341a615c <_fflush_r>
341a50ba:	68e1      	ldr	r1, [r4, #12]
341a50bc:	4b06      	ldr	r3, [pc, #24]	@ (341a50d8 <cleanup_stdio+0x3c>)
341a50be:	4299      	cmp	r1, r3
341a50c0:	d004      	beq.n	341a50cc <cleanup_stdio+0x30>
341a50c2:	4620      	mov	r0, r4
341a50c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a50c8:	f001 b848 	b.w	341a615c <_fflush_r>
341a50cc:	bd10      	pop	{r4, pc}
341a50ce:	bf00      	nop
341a50d0:	341c1ed0 	.word	0x341c1ed0
341a50d4:	341c1f38 	.word	0x341c1f38
341a50d8:	341c1fa0 	.word	0x341c1fa0

341a50dc <global_stdio_init.part.0>:
341a50dc:	b510      	push	{r4, lr}
341a50de:	4b0b      	ldr	r3, [pc, #44]	@ (341a510c <global_stdio_init.part.0+0x30>)
341a50e0:	2104      	movs	r1, #4
341a50e2:	4c0b      	ldr	r4, [pc, #44]	@ (341a5110 <global_stdio_init.part.0+0x34>)
341a50e4:	4a0b      	ldr	r2, [pc, #44]	@ (341a5114 <global_stdio_init.part.0+0x38>)
341a50e6:	4620      	mov	r0, r4
341a50e8:	601a      	str	r2, [r3, #0]
341a50ea:	2200      	movs	r2, #0
341a50ec:	f7ff ff94 	bl	341a5018 <std>
341a50f0:	f104 0068 	add.w	r0, r4, #104	@ 0x68
341a50f4:	2201      	movs	r2, #1
341a50f6:	2109      	movs	r1, #9
341a50f8:	f7ff ff8e 	bl	341a5018 <std>
341a50fc:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
341a5100:	2202      	movs	r2, #2
341a5102:	2112      	movs	r1, #18
341a5104:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a5108:	f7ff bf86 	b.w	341a5018 <std>
341a510c:	341c2008 	.word	0x341c2008
341a5110:	341c1ed0 	.word	0x341c1ed0
341a5114:	341a5085 	.word	0x341a5085

341a5118 <__sfp_lock_acquire>:
341a5118:	4801      	ldr	r0, [pc, #4]	@ (341a5120 <__sfp_lock_acquire+0x8>)
341a511a:	f000 ba62 	b.w	341a55e2 <__retarget_lock_acquire_recursive>
341a511e:	bf00      	nop
341a5120:	341c2011 	.word	0x341c2011

341a5124 <__sfp_lock_release>:
341a5124:	4801      	ldr	r0, [pc, #4]	@ (341a512c <__sfp_lock_release+0x8>)
341a5126:	f000 ba5d 	b.w	341a55e4 <__retarget_lock_release_recursive>
341a512a:	bf00      	nop
341a512c:	341c2011 	.word	0x341c2011

341a5130 <__sinit>:
341a5130:	b510      	push	{r4, lr}
341a5132:	4604      	mov	r4, r0
341a5134:	f7ff fff0 	bl	341a5118 <__sfp_lock_acquire>
341a5138:	6a23      	ldr	r3, [r4, #32]
341a513a:	b11b      	cbz	r3, 341a5144 <__sinit+0x14>
341a513c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
341a5140:	f7ff bff0 	b.w	341a5124 <__sfp_lock_release>
341a5144:	4b04      	ldr	r3, [pc, #16]	@ (341a5158 <__sinit+0x28>)
341a5146:	6223      	str	r3, [r4, #32]
341a5148:	4b04      	ldr	r3, [pc, #16]	@ (341a515c <__sinit+0x2c>)
341a514a:	681b      	ldr	r3, [r3, #0]
341a514c:	2b00      	cmp	r3, #0
341a514e:	d1f5      	bne.n	341a513c <__sinit+0xc>
341a5150:	f7ff ffc4 	bl	341a50dc <global_stdio_init.part.0>
341a5154:	e7f2      	b.n	341a513c <__sinit+0xc>
341a5156:	bf00      	nop
341a5158:	341a509d 	.word	0x341a509d
341a515c:	341c2008 	.word	0x341c2008

341a5160 <fiprintf>:
341a5160:	b40e      	push	{r1, r2, r3}
341a5162:	b503      	push	{r0, r1, lr}
341a5164:	ab03      	add	r3, sp, #12
341a5166:	4601      	mov	r1, r0
341a5168:	4805      	ldr	r0, [pc, #20]	@ (341a5180 <fiprintf+0x20>)
341a516a:	f853 2b04 	ldr.w	r2, [r3], #4
341a516e:	6800      	ldr	r0, [r0, #0]
341a5170:	9301      	str	r3, [sp, #4]
341a5172:	f000 fcc7 	bl	341a5b04 <_vfiprintf_r>
341a5176:	b002      	add	sp, #8
341a5178:	f85d eb04 	ldr.w	lr, [sp], #4
341a517c:	b003      	add	sp, #12
341a517e:	4770      	bx	lr
341a5180:	341c0144 	.word	0x341c0144

341a5184 <_fwalk_sglue>:
341a5184:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
341a5188:	4607      	mov	r7, r0
341a518a:	4688      	mov	r8, r1
341a518c:	4614      	mov	r4, r2
341a518e:	2600      	movs	r6, #0
341a5190:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
341a5194:	f1b9 0901 	subs.w	r9, r9, #1
341a5198:	d505      	bpl.n	341a51a6 <_fwalk_sglue+0x22>
341a519a:	6824      	ldr	r4, [r4, #0]
341a519c:	2c00      	cmp	r4, #0
341a519e:	d1f7      	bne.n	341a5190 <_fwalk_sglue+0xc>
341a51a0:	4630      	mov	r0, r6
341a51a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
341a51a6:	89ab      	ldrh	r3, [r5, #12]
341a51a8:	2b01      	cmp	r3, #1
341a51aa:	d907      	bls.n	341a51bc <_fwalk_sglue+0x38>
341a51ac:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
341a51b0:	3301      	adds	r3, #1
341a51b2:	d003      	beq.n	341a51bc <_fwalk_sglue+0x38>
341a51b4:	4629      	mov	r1, r5
341a51b6:	4638      	mov	r0, r7
341a51b8:	47c0      	blx	r8
341a51ba:	4306      	orrs	r6, r0
341a51bc:	3568      	adds	r5, #104	@ 0x68
341a51be:	e7e9      	b.n	341a5194 <_fwalk_sglue+0x10>

341a51c0 <iprintf>:
341a51c0:	b40f      	push	{r0, r1, r2, r3}
341a51c2:	b507      	push	{r0, r1, r2, lr}
341a51c4:	4906      	ldr	r1, [pc, #24]	@ (341a51e0 <iprintf+0x20>)
341a51c6:	ab04      	add	r3, sp, #16
341a51c8:	6808      	ldr	r0, [r1, #0]
341a51ca:	f853 2b04 	ldr.w	r2, [r3], #4
341a51ce:	6881      	ldr	r1, [r0, #8]
341a51d0:	9301      	str	r3, [sp, #4]
341a51d2:	f000 fc97 	bl	341a5b04 <_vfiprintf_r>
341a51d6:	b003      	add	sp, #12
341a51d8:	f85d eb04 	ldr.w	lr, [sp], #4
341a51dc:	b004      	add	sp, #16
341a51de:	4770      	bx	lr
341a51e0:	341c0144 	.word	0x341c0144

341a51e4 <_puts_r>:
341a51e4:	6a03      	ldr	r3, [r0, #32]
341a51e6:	b570      	push	{r4, r5, r6, lr}
341a51e8:	4605      	mov	r5, r0
341a51ea:	460e      	mov	r6, r1
341a51ec:	6884      	ldr	r4, [r0, #8]
341a51ee:	b90b      	cbnz	r3, 341a51f4 <_puts_r+0x10>
341a51f0:	f7ff ff9e 	bl	341a5130 <__sinit>
341a51f4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a51f6:	07db      	lsls	r3, r3, #31
341a51f8:	d405      	bmi.n	341a5206 <_puts_r+0x22>
341a51fa:	89a3      	ldrh	r3, [r4, #12]
341a51fc:	0598      	lsls	r0, r3, #22
341a51fe:	d402      	bmi.n	341a5206 <_puts_r+0x22>
341a5200:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a5202:	f000 f9ee 	bl	341a55e2 <__retarget_lock_acquire_recursive>
341a5206:	89a3      	ldrh	r3, [r4, #12]
341a5208:	0719      	lsls	r1, r3, #28
341a520a:	d502      	bpl.n	341a5212 <_puts_r+0x2e>
341a520c:	6923      	ldr	r3, [r4, #16]
341a520e:	2b00      	cmp	r3, #0
341a5210:	d135      	bne.n	341a527e <_puts_r+0x9a>
341a5212:	4621      	mov	r1, r4
341a5214:	4628      	mov	r0, r5
341a5216:	f000 f8fb 	bl	341a5410 <__swsetup_r>
341a521a:	b380      	cbz	r0, 341a527e <_puts_r+0x9a>
341a521c:	f04f 35ff 	mov.w	r5, #4294967295
341a5220:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a5222:	07da      	lsls	r2, r3, #31
341a5224:	d405      	bmi.n	341a5232 <_puts_r+0x4e>
341a5226:	89a3      	ldrh	r3, [r4, #12]
341a5228:	059b      	lsls	r3, r3, #22
341a522a:	d402      	bmi.n	341a5232 <_puts_r+0x4e>
341a522c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a522e:	f000 f9d9 	bl	341a55e4 <__retarget_lock_release_recursive>
341a5232:	4628      	mov	r0, r5
341a5234:	bd70      	pop	{r4, r5, r6, pc}
341a5236:	2b00      	cmp	r3, #0
341a5238:	da04      	bge.n	341a5244 <_puts_r+0x60>
341a523a:	69a2      	ldr	r2, [r4, #24]
341a523c:	429a      	cmp	r2, r3
341a523e:	dc17      	bgt.n	341a5270 <_puts_r+0x8c>
341a5240:	290a      	cmp	r1, #10
341a5242:	d015      	beq.n	341a5270 <_puts_r+0x8c>
341a5244:	6823      	ldr	r3, [r4, #0]
341a5246:	1c5a      	adds	r2, r3, #1
341a5248:	6022      	str	r2, [r4, #0]
341a524a:	7019      	strb	r1, [r3, #0]
341a524c:	68a3      	ldr	r3, [r4, #8]
341a524e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
341a5252:	3b01      	subs	r3, #1
341a5254:	60a3      	str	r3, [r4, #8]
341a5256:	2900      	cmp	r1, #0
341a5258:	d1ed      	bne.n	341a5236 <_puts_r+0x52>
341a525a:	2b00      	cmp	r3, #0
341a525c:	da11      	bge.n	341a5282 <_puts_r+0x9e>
341a525e:	4622      	mov	r2, r4
341a5260:	210a      	movs	r1, #10
341a5262:	4628      	mov	r0, r5
341a5264:	f000 f895 	bl	341a5392 <__swbuf_r>
341a5268:	3001      	adds	r0, #1
341a526a:	d0d7      	beq.n	341a521c <_puts_r+0x38>
341a526c:	250a      	movs	r5, #10
341a526e:	e7d7      	b.n	341a5220 <_puts_r+0x3c>
341a5270:	4622      	mov	r2, r4
341a5272:	4628      	mov	r0, r5
341a5274:	f000 f88d 	bl	341a5392 <__swbuf_r>
341a5278:	3001      	adds	r0, #1
341a527a:	d1e7      	bne.n	341a524c <_puts_r+0x68>
341a527c:	e7ce      	b.n	341a521c <_puts_r+0x38>
341a527e:	3e01      	subs	r6, #1
341a5280:	e7e4      	b.n	341a524c <_puts_r+0x68>
341a5282:	6823      	ldr	r3, [r4, #0]
341a5284:	1c5a      	adds	r2, r3, #1
341a5286:	6022      	str	r2, [r4, #0]
341a5288:	220a      	movs	r2, #10
341a528a:	701a      	strb	r2, [r3, #0]
341a528c:	e7ee      	b.n	341a526c <_puts_r+0x88>
	...

341a5290 <puts>:
341a5290:	4b02      	ldr	r3, [pc, #8]	@ (341a529c <puts+0xc>)
341a5292:	4601      	mov	r1, r0
341a5294:	6818      	ldr	r0, [r3, #0]
341a5296:	f7ff bfa5 	b.w	341a51e4 <_puts_r>
341a529a:	bf00      	nop
341a529c:	341c0144 	.word	0x341c0144

341a52a0 <sniprintf>:
341a52a0:	b40c      	push	{r2, r3}
341a52a2:	4b19      	ldr	r3, [pc, #100]	@ (341a5308 <sniprintf+0x68>)
341a52a4:	b530      	push	{r4, r5, lr}
341a52a6:	1e0c      	subs	r4, r1, #0
341a52a8:	b09d      	sub	sp, #116	@ 0x74
341a52aa:	681d      	ldr	r5, [r3, #0]
341a52ac:	da08      	bge.n	341a52c0 <sniprintf+0x20>
341a52ae:	238b      	movs	r3, #139	@ 0x8b
341a52b0:	f04f 30ff 	mov.w	r0, #4294967295
341a52b4:	602b      	str	r3, [r5, #0]
341a52b6:	b01d      	add	sp, #116	@ 0x74
341a52b8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a52bc:	b002      	add	sp, #8
341a52be:	4770      	bx	lr
341a52c0:	f44f 7302 	mov.w	r3, #520	@ 0x208
341a52c4:	9002      	str	r0, [sp, #8]
341a52c6:	9006      	str	r0, [sp, #24]
341a52c8:	a902      	add	r1, sp, #8
341a52ca:	f8ad 3014 	strh.w	r3, [sp, #20]
341a52ce:	f04f 0300 	mov.w	r3, #0
341a52d2:	9a20      	ldr	r2, [sp, #128]	@ 0x80
341a52d4:	4628      	mov	r0, r5
341a52d6:	931b      	str	r3, [sp, #108]	@ 0x6c
341a52d8:	bf14      	ite	ne
341a52da:	f104 33ff 	addne.w	r3, r4, #4294967295
341a52de:	4623      	moveq	r3, r4
341a52e0:	9304      	str	r3, [sp, #16]
341a52e2:	9307      	str	r3, [sp, #28]
341a52e4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
341a52e8:	f8ad 3016 	strh.w	r3, [sp, #22]
341a52ec:	ab21      	add	r3, sp, #132	@ 0x84
341a52ee:	9301      	str	r3, [sp, #4]
341a52f0:	f000 fae2 	bl	341a58b8 <_svfiprintf_r>
341a52f4:	1c43      	adds	r3, r0, #1
341a52f6:	bfbc      	itt	lt
341a52f8:	238b      	movlt	r3, #139	@ 0x8b
341a52fa:	602b      	strlt	r3, [r5, #0]
341a52fc:	2c00      	cmp	r4, #0
341a52fe:	d0da      	beq.n	341a52b6 <sniprintf+0x16>
341a5300:	9b02      	ldr	r3, [sp, #8]
341a5302:	2200      	movs	r2, #0
341a5304:	701a      	strb	r2, [r3, #0]
341a5306:	e7d6      	b.n	341a52b6 <sniprintf+0x16>
341a5308:	341c0144 	.word	0x341c0144

341a530c <__sread>:
341a530c:	b510      	push	{r4, lr}
341a530e:	460c      	mov	r4, r1
341a5310:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a5314:	f000 f916 	bl	341a5544 <_read_r>
341a5318:	2800      	cmp	r0, #0
341a531a:	bfab      	itete	ge
341a531c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
341a531e:	89a3      	ldrhlt	r3, [r4, #12]
341a5320:	181b      	addge	r3, r3, r0
341a5322:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
341a5326:	bfac      	ite	ge
341a5328:	6563      	strge	r3, [r4, #84]	@ 0x54
341a532a:	81a3      	strhlt	r3, [r4, #12]
341a532c:	bd10      	pop	{r4, pc}

341a532e <__swrite>:
341a532e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a5332:	461f      	mov	r7, r3
341a5334:	898b      	ldrh	r3, [r1, #12]
341a5336:	4605      	mov	r5, r0
341a5338:	460c      	mov	r4, r1
341a533a:	05db      	lsls	r3, r3, #23
341a533c:	4616      	mov	r6, r2
341a533e:	d505      	bpl.n	341a534c <__swrite+0x1e>
341a5340:	2302      	movs	r3, #2
341a5342:	2200      	movs	r2, #0
341a5344:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a5348:	f000 f8ea 	bl	341a5520 <_lseek_r>
341a534c:	89a3      	ldrh	r3, [r4, #12]
341a534e:	4632      	mov	r2, r6
341a5350:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
341a5354:	4628      	mov	r0, r5
341a5356:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
341a535a:	81a3      	strh	r3, [r4, #12]
341a535c:	463b      	mov	r3, r7
341a535e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
341a5362:	f000 b901 	b.w	341a5568 <_write_r>

341a5366 <__sseek>:
341a5366:	b510      	push	{r4, lr}
341a5368:	460c      	mov	r4, r1
341a536a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a536e:	f000 f8d7 	bl	341a5520 <_lseek_r>
341a5372:	1c43      	adds	r3, r0, #1
341a5374:	89a3      	ldrh	r3, [r4, #12]
341a5376:	bf15      	itete	ne
341a5378:	6560      	strne	r0, [r4, #84]	@ 0x54
341a537a:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
341a537e:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
341a5382:	81a3      	strheq	r3, [r4, #12]
341a5384:	bf18      	it	ne
341a5386:	81a3      	strhne	r3, [r4, #12]
341a5388:	bd10      	pop	{r4, pc}

341a538a <__sclose>:
341a538a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a538e:	f000 b8b7 	b.w	341a5500 <_close_r>

341a5392 <__swbuf_r>:
341a5392:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a5394:	460e      	mov	r6, r1
341a5396:	4614      	mov	r4, r2
341a5398:	4605      	mov	r5, r0
341a539a:	b118      	cbz	r0, 341a53a4 <__swbuf_r+0x12>
341a539c:	6a03      	ldr	r3, [r0, #32]
341a539e:	b90b      	cbnz	r3, 341a53a4 <__swbuf_r+0x12>
341a53a0:	f7ff fec6 	bl	341a5130 <__sinit>
341a53a4:	69a3      	ldr	r3, [r4, #24]
341a53a6:	60a3      	str	r3, [r4, #8]
341a53a8:	89a3      	ldrh	r3, [r4, #12]
341a53aa:	071a      	lsls	r2, r3, #28
341a53ac:	d501      	bpl.n	341a53b2 <__swbuf_r+0x20>
341a53ae:	6923      	ldr	r3, [r4, #16]
341a53b0:	b943      	cbnz	r3, 341a53c4 <__swbuf_r+0x32>
341a53b2:	4621      	mov	r1, r4
341a53b4:	4628      	mov	r0, r5
341a53b6:	f000 f82b 	bl	341a5410 <__swsetup_r>
341a53ba:	b118      	cbz	r0, 341a53c4 <__swbuf_r+0x32>
341a53bc:	f04f 37ff 	mov.w	r7, #4294967295
341a53c0:	4638      	mov	r0, r7
341a53c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
341a53c4:	6823      	ldr	r3, [r4, #0]
341a53c6:	b2f6      	uxtb	r6, r6
341a53c8:	6922      	ldr	r2, [r4, #16]
341a53ca:	4637      	mov	r7, r6
341a53cc:	1a98      	subs	r0, r3, r2
341a53ce:	6963      	ldr	r3, [r4, #20]
341a53d0:	4283      	cmp	r3, r0
341a53d2:	dc05      	bgt.n	341a53e0 <__swbuf_r+0x4e>
341a53d4:	4621      	mov	r1, r4
341a53d6:	4628      	mov	r0, r5
341a53d8:	f000 fec0 	bl	341a615c <_fflush_r>
341a53dc:	2800      	cmp	r0, #0
341a53de:	d1ed      	bne.n	341a53bc <__swbuf_r+0x2a>
341a53e0:	68a3      	ldr	r3, [r4, #8]
341a53e2:	3b01      	subs	r3, #1
341a53e4:	60a3      	str	r3, [r4, #8]
341a53e6:	6823      	ldr	r3, [r4, #0]
341a53e8:	1c5a      	adds	r2, r3, #1
341a53ea:	6022      	str	r2, [r4, #0]
341a53ec:	701e      	strb	r6, [r3, #0]
341a53ee:	1c43      	adds	r3, r0, #1
341a53f0:	6962      	ldr	r2, [r4, #20]
341a53f2:	429a      	cmp	r2, r3
341a53f4:	d004      	beq.n	341a5400 <__swbuf_r+0x6e>
341a53f6:	89a3      	ldrh	r3, [r4, #12]
341a53f8:	07db      	lsls	r3, r3, #31
341a53fa:	d5e1      	bpl.n	341a53c0 <__swbuf_r+0x2e>
341a53fc:	2e0a      	cmp	r6, #10
341a53fe:	d1df      	bne.n	341a53c0 <__swbuf_r+0x2e>
341a5400:	4621      	mov	r1, r4
341a5402:	4628      	mov	r0, r5
341a5404:	f000 feaa 	bl	341a615c <_fflush_r>
341a5408:	2800      	cmp	r0, #0
341a540a:	d0d9      	beq.n	341a53c0 <__swbuf_r+0x2e>
341a540c:	e7d6      	b.n	341a53bc <__swbuf_r+0x2a>
	...

341a5410 <__swsetup_r>:
341a5410:	b538      	push	{r3, r4, r5, lr}
341a5412:	4b29      	ldr	r3, [pc, #164]	@ (341a54b8 <__swsetup_r+0xa8>)
341a5414:	4605      	mov	r5, r0
341a5416:	460c      	mov	r4, r1
341a5418:	6818      	ldr	r0, [r3, #0]
341a541a:	b118      	cbz	r0, 341a5424 <__swsetup_r+0x14>
341a541c:	6a03      	ldr	r3, [r0, #32]
341a541e:	b90b      	cbnz	r3, 341a5424 <__swsetup_r+0x14>
341a5420:	f7ff fe86 	bl	341a5130 <__sinit>
341a5424:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a5428:	0719      	lsls	r1, r3, #28
341a542a:	d422      	bmi.n	341a5472 <__swsetup_r+0x62>
341a542c:	06da      	lsls	r2, r3, #27
341a542e:	d407      	bmi.n	341a5440 <__swsetup_r+0x30>
341a5430:	2209      	movs	r2, #9
341a5432:	602a      	str	r2, [r5, #0]
341a5434:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a5438:	f04f 30ff 	mov.w	r0, #4294967295
341a543c:	81a3      	strh	r3, [r4, #12]
341a543e:	e033      	b.n	341a54a8 <__swsetup_r+0x98>
341a5440:	0758      	lsls	r0, r3, #29
341a5442:	d512      	bpl.n	341a546a <__swsetup_r+0x5a>
341a5444:	6b61      	ldr	r1, [r4, #52]	@ 0x34
341a5446:	b141      	cbz	r1, 341a545a <__swsetup_r+0x4a>
341a5448:	f104 0344 	add.w	r3, r4, #68	@ 0x44
341a544c:	4299      	cmp	r1, r3
341a544e:	d002      	beq.n	341a5456 <__swsetup_r+0x46>
341a5450:	4628      	mov	r0, r5
341a5452:	f000 f8dd 	bl	341a5610 <_free_r>
341a5456:	2300      	movs	r3, #0
341a5458:	6363      	str	r3, [r4, #52]	@ 0x34
341a545a:	89a3      	ldrh	r3, [r4, #12]
341a545c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
341a5460:	81a3      	strh	r3, [r4, #12]
341a5462:	2300      	movs	r3, #0
341a5464:	6063      	str	r3, [r4, #4]
341a5466:	6923      	ldr	r3, [r4, #16]
341a5468:	6023      	str	r3, [r4, #0]
341a546a:	89a3      	ldrh	r3, [r4, #12]
341a546c:	f043 0308 	orr.w	r3, r3, #8
341a5470:	81a3      	strh	r3, [r4, #12]
341a5472:	6923      	ldr	r3, [r4, #16]
341a5474:	b94b      	cbnz	r3, 341a548a <__swsetup_r+0x7a>
341a5476:	89a3      	ldrh	r3, [r4, #12]
341a5478:	f403 7320 	and.w	r3, r3, #640	@ 0x280
341a547c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
341a5480:	d003      	beq.n	341a548a <__swsetup_r+0x7a>
341a5482:	4621      	mov	r1, r4
341a5484:	4628      	mov	r0, r5
341a5486:	f000 feb6 	bl	341a61f6 <__smakebuf_r>
341a548a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a548e:	f013 0201 	ands.w	r2, r3, #1
341a5492:	d00a      	beq.n	341a54aa <__swsetup_r+0x9a>
341a5494:	2200      	movs	r2, #0
341a5496:	60a2      	str	r2, [r4, #8]
341a5498:	6962      	ldr	r2, [r4, #20]
341a549a:	4252      	negs	r2, r2
341a549c:	61a2      	str	r2, [r4, #24]
341a549e:	6922      	ldr	r2, [r4, #16]
341a54a0:	b942      	cbnz	r2, 341a54b4 <__swsetup_r+0xa4>
341a54a2:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
341a54a6:	d1c5      	bne.n	341a5434 <__swsetup_r+0x24>
341a54a8:	bd38      	pop	{r3, r4, r5, pc}
341a54aa:	0799      	lsls	r1, r3, #30
341a54ac:	bf58      	it	pl
341a54ae:	6962      	ldrpl	r2, [r4, #20]
341a54b0:	60a2      	str	r2, [r4, #8]
341a54b2:	e7f4      	b.n	341a549e <__swsetup_r+0x8e>
341a54b4:	2000      	movs	r0, #0
341a54b6:	e7f7      	b.n	341a54a8 <__swsetup_r+0x98>
341a54b8:	341c0144 	.word	0x341c0144

341a54bc <memmove>:
341a54bc:	4288      	cmp	r0, r1
341a54be:	b510      	push	{r4, lr}
341a54c0:	eb01 0402 	add.w	r4, r1, r2
341a54c4:	d902      	bls.n	341a54cc <memmove+0x10>
341a54c6:	4284      	cmp	r4, r0
341a54c8:	4623      	mov	r3, r4
341a54ca:	d807      	bhi.n	341a54dc <memmove+0x20>
341a54cc:	1e43      	subs	r3, r0, #1
341a54ce:	42a1      	cmp	r1, r4
341a54d0:	d008      	beq.n	341a54e4 <memmove+0x28>
341a54d2:	f811 2b01 	ldrb.w	r2, [r1], #1
341a54d6:	f803 2f01 	strb.w	r2, [r3, #1]!
341a54da:	e7f8      	b.n	341a54ce <memmove+0x12>
341a54dc:	4402      	add	r2, r0
341a54de:	4601      	mov	r1, r0
341a54e0:	428a      	cmp	r2, r1
341a54e2:	d100      	bne.n	341a54e6 <memmove+0x2a>
341a54e4:	bd10      	pop	{r4, pc}
341a54e6:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
341a54ea:	f802 4d01 	strb.w	r4, [r2, #-1]!
341a54ee:	e7f7      	b.n	341a54e0 <memmove+0x24>

341a54f0 <memset>:
341a54f0:	4402      	add	r2, r0
341a54f2:	4603      	mov	r3, r0
341a54f4:	4293      	cmp	r3, r2
341a54f6:	d100      	bne.n	341a54fa <memset+0xa>
341a54f8:	4770      	bx	lr
341a54fa:	f803 1b01 	strb.w	r1, [r3], #1
341a54fe:	e7f9      	b.n	341a54f4 <memset+0x4>

341a5500 <_close_r>:
341a5500:	b538      	push	{r3, r4, r5, lr}
341a5502:	2300      	movs	r3, #0
341a5504:	4d05      	ldr	r5, [pc, #20]	@ (341a551c <_close_r+0x1c>)
341a5506:	4604      	mov	r4, r0
341a5508:	4608      	mov	r0, r1
341a550a:	602b      	str	r3, [r5, #0]
341a550c:	f7dd fdee 	bl	341830ec <_close>
341a5510:	1c43      	adds	r3, r0, #1
341a5512:	d102      	bne.n	341a551a <_close_r+0x1a>
341a5514:	682b      	ldr	r3, [r5, #0]
341a5516:	b103      	cbz	r3, 341a551a <_close_r+0x1a>
341a5518:	6023      	str	r3, [r4, #0]
341a551a:	bd38      	pop	{r3, r4, r5, pc}
341a551c:	341c200c 	.word	0x341c200c

341a5520 <_lseek_r>:
341a5520:	b538      	push	{r3, r4, r5, lr}
341a5522:	4604      	mov	r4, r0
341a5524:	4d06      	ldr	r5, [pc, #24]	@ (341a5540 <_lseek_r+0x20>)
341a5526:	4608      	mov	r0, r1
341a5528:	4611      	mov	r1, r2
341a552a:	2200      	movs	r2, #0
341a552c:	602a      	str	r2, [r5, #0]
341a552e:	461a      	mov	r2, r3
341a5530:	f7dd fe03 	bl	3418313a <_lseek>
341a5534:	1c43      	adds	r3, r0, #1
341a5536:	d102      	bne.n	341a553e <_lseek_r+0x1e>
341a5538:	682b      	ldr	r3, [r5, #0]
341a553a:	b103      	cbz	r3, 341a553e <_lseek_r+0x1e>
341a553c:	6023      	str	r3, [r4, #0]
341a553e:	bd38      	pop	{r3, r4, r5, pc}
341a5540:	341c200c 	.word	0x341c200c

341a5544 <_read_r>:
341a5544:	b538      	push	{r3, r4, r5, lr}
341a5546:	4604      	mov	r4, r0
341a5548:	4d06      	ldr	r5, [pc, #24]	@ (341a5564 <_read_r+0x20>)
341a554a:	4608      	mov	r0, r1
341a554c:	4611      	mov	r1, r2
341a554e:	2200      	movs	r2, #0
341a5550:	602a      	str	r2, [r5, #0]
341a5552:	461a      	mov	r2, r3
341a5554:	f7dd fd91 	bl	3418307a <_read>
341a5558:	1c43      	adds	r3, r0, #1
341a555a:	d102      	bne.n	341a5562 <_read_r+0x1e>
341a555c:	682b      	ldr	r3, [r5, #0]
341a555e:	b103      	cbz	r3, 341a5562 <_read_r+0x1e>
341a5560:	6023      	str	r3, [r4, #0]
341a5562:	bd38      	pop	{r3, r4, r5, pc}
341a5564:	341c200c 	.word	0x341c200c

341a5568 <_write_r>:
341a5568:	b538      	push	{r3, r4, r5, lr}
341a556a:	4604      	mov	r4, r0
341a556c:	4d06      	ldr	r5, [pc, #24]	@ (341a5588 <_write_r+0x20>)
341a556e:	4608      	mov	r0, r1
341a5570:	4611      	mov	r1, r2
341a5572:	2200      	movs	r2, #0
341a5574:	602a      	str	r2, [r5, #0]
341a5576:	461a      	mov	r2, r3
341a5578:	f7dd fd9c 	bl	341830b4 <_write>
341a557c:	1c43      	adds	r3, r0, #1
341a557e:	d102      	bne.n	341a5586 <_write_r+0x1e>
341a5580:	682b      	ldr	r3, [r5, #0]
341a5582:	b103      	cbz	r3, 341a5586 <_write_r+0x1e>
341a5584:	6023      	str	r3, [r4, #0]
341a5586:	bd38      	pop	{r3, r4, r5, pc}
341a5588:	341c200c 	.word	0x341c200c

341a558c <__errno>:
341a558c:	4b01      	ldr	r3, [pc, #4]	@ (341a5594 <__errno+0x8>)
341a558e:	6818      	ldr	r0, [r3, #0]
341a5590:	4770      	bx	lr
341a5592:	bf00      	nop
341a5594:	341c0144 	.word	0x341c0144

341a5598 <__libc_init_array>:
341a5598:	b570      	push	{r4, r5, r6, lr}
341a559a:	4d0d      	ldr	r5, [pc, #52]	@ (341a55d0 <__libc_init_array+0x38>)
341a559c:	2600      	movs	r6, #0
341a559e:	4c0d      	ldr	r4, [pc, #52]	@ (341a55d4 <__libc_init_array+0x3c>)
341a55a0:	1b64      	subs	r4, r4, r5
341a55a2:	10a4      	asrs	r4, r4, #2
341a55a4:	42a6      	cmp	r6, r4
341a55a6:	d109      	bne.n	341a55bc <__libc_init_array+0x24>
341a55a8:	4d0b      	ldr	r5, [pc, #44]	@ (341a55d8 <__libc_init_array+0x40>)
341a55aa:	2600      	movs	r6, #0
341a55ac:	4c0b      	ldr	r4, [pc, #44]	@ (341a55dc <__libc_init_array+0x44>)
341a55ae:	f001 fda3 	bl	341a70f8 <_init>
341a55b2:	1b64      	subs	r4, r4, r5
341a55b4:	10a4      	asrs	r4, r4, #2
341a55b6:	42a6      	cmp	r6, r4
341a55b8:	d105      	bne.n	341a55c6 <__libc_init_array+0x2e>
341a55ba:	bd70      	pop	{r4, r5, r6, pc}
341a55bc:	f855 3b04 	ldr.w	r3, [r5], #4
341a55c0:	3601      	adds	r6, #1
341a55c2:	4798      	blx	r3
341a55c4:	e7ee      	b.n	341a55a4 <__libc_init_array+0xc>
341a55c6:	f855 3b04 	ldr.w	r3, [r5], #4
341a55ca:	3601      	adds	r6, #1
341a55cc:	4798      	blx	r3
341a55ce:	e7f2      	b.n	341a55b6 <__libc_init_array+0x1e>
341a55d0:	341b2034 	.word	0x341b2034
341a55d4:	341b2034 	.word	0x341b2034
341a55d8:	341b2034 	.word	0x341b2034
341a55dc:	341b2038 	.word	0x341b2038

341a55e0 <__retarget_lock_init_recursive>:
341a55e0:	4770      	bx	lr

341a55e2 <__retarget_lock_acquire_recursive>:
341a55e2:	4770      	bx	lr

341a55e4 <__retarget_lock_release_recursive>:
341a55e4:	4770      	bx	lr

341a55e6 <memcpy>:
341a55e6:	440a      	add	r2, r1
341a55e8:	1e43      	subs	r3, r0, #1
341a55ea:	4291      	cmp	r1, r2
341a55ec:	d100      	bne.n	341a55f0 <memcpy+0xa>
341a55ee:	4770      	bx	lr
341a55f0:	b510      	push	{r4, lr}
341a55f2:	f811 4b01 	ldrb.w	r4, [r1], #1
341a55f6:	4291      	cmp	r1, r2
341a55f8:	f803 4f01 	strb.w	r4, [r3, #1]!
341a55fc:	d1f9      	bne.n	341a55f2 <memcpy+0xc>
341a55fe:	bd10      	pop	{r4, pc}

341a5600 <abort>:
341a5600:	2006      	movs	r0, #6
341a5602:	b508      	push	{r3, lr}
341a5604:	f000 fe5c 	bl	341a62c0 <raise>
341a5608:	2001      	movs	r0, #1
341a560a:	f7dd fd2b 	bl	34183064 <_exit>
	...

341a5610 <_free_r>:
341a5610:	b538      	push	{r3, r4, r5, lr}
341a5612:	4605      	mov	r5, r0
341a5614:	2900      	cmp	r1, #0
341a5616:	d041      	beq.n	341a569c <_free_r+0x8c>
341a5618:	f851 3c04 	ldr.w	r3, [r1, #-4]
341a561c:	1f0c      	subs	r4, r1, #4
341a561e:	2b00      	cmp	r3, #0
341a5620:	bfb8      	it	lt
341a5622:	18e4      	addlt	r4, r4, r3
341a5624:	f000 f8e0 	bl	341a57e8 <__malloc_lock>
341a5628:	4a1d      	ldr	r2, [pc, #116]	@ (341a56a0 <_free_r+0x90>)
341a562a:	6813      	ldr	r3, [r2, #0]
341a562c:	b933      	cbnz	r3, 341a563c <_free_r+0x2c>
341a562e:	6063      	str	r3, [r4, #4]
341a5630:	6014      	str	r4, [r2, #0]
341a5632:	4628      	mov	r0, r5
341a5634:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
341a5638:	f000 b8dc 	b.w	341a57f4 <__malloc_unlock>
341a563c:	42a3      	cmp	r3, r4
341a563e:	d908      	bls.n	341a5652 <_free_r+0x42>
341a5640:	6820      	ldr	r0, [r4, #0]
341a5642:	1821      	adds	r1, r4, r0
341a5644:	428b      	cmp	r3, r1
341a5646:	bf01      	itttt	eq
341a5648:	6819      	ldreq	r1, [r3, #0]
341a564a:	685b      	ldreq	r3, [r3, #4]
341a564c:	1809      	addeq	r1, r1, r0
341a564e:	6021      	streq	r1, [r4, #0]
341a5650:	e7ed      	b.n	341a562e <_free_r+0x1e>
341a5652:	461a      	mov	r2, r3
341a5654:	685b      	ldr	r3, [r3, #4]
341a5656:	b10b      	cbz	r3, 341a565c <_free_r+0x4c>
341a5658:	42a3      	cmp	r3, r4
341a565a:	d9fa      	bls.n	341a5652 <_free_r+0x42>
341a565c:	6811      	ldr	r1, [r2, #0]
341a565e:	1850      	adds	r0, r2, r1
341a5660:	42a0      	cmp	r0, r4
341a5662:	d10b      	bne.n	341a567c <_free_r+0x6c>
341a5664:	6820      	ldr	r0, [r4, #0]
341a5666:	4401      	add	r1, r0
341a5668:	1850      	adds	r0, r2, r1
341a566a:	6011      	str	r1, [r2, #0]
341a566c:	4283      	cmp	r3, r0
341a566e:	d1e0      	bne.n	341a5632 <_free_r+0x22>
341a5670:	6818      	ldr	r0, [r3, #0]
341a5672:	685b      	ldr	r3, [r3, #4]
341a5674:	4408      	add	r0, r1
341a5676:	6053      	str	r3, [r2, #4]
341a5678:	6010      	str	r0, [r2, #0]
341a567a:	e7da      	b.n	341a5632 <_free_r+0x22>
341a567c:	d902      	bls.n	341a5684 <_free_r+0x74>
341a567e:	230c      	movs	r3, #12
341a5680:	602b      	str	r3, [r5, #0]
341a5682:	e7d6      	b.n	341a5632 <_free_r+0x22>
341a5684:	6820      	ldr	r0, [r4, #0]
341a5686:	1821      	adds	r1, r4, r0
341a5688:	428b      	cmp	r3, r1
341a568a:	bf02      	ittt	eq
341a568c:	6819      	ldreq	r1, [r3, #0]
341a568e:	685b      	ldreq	r3, [r3, #4]
341a5690:	1809      	addeq	r1, r1, r0
341a5692:	6063      	str	r3, [r4, #4]
341a5694:	bf08      	it	eq
341a5696:	6021      	streq	r1, [r4, #0]
341a5698:	6054      	str	r4, [r2, #4]
341a569a:	e7ca      	b.n	341a5632 <_free_r+0x22>
341a569c:	bd38      	pop	{r3, r4, r5, pc}
341a569e:	bf00      	nop
341a56a0:	341c2018 	.word	0x341c2018

341a56a4 <sbrk_aligned>:
341a56a4:	b570      	push	{r4, r5, r6, lr}
341a56a6:	4e0f      	ldr	r6, [pc, #60]	@ (341a56e4 <sbrk_aligned+0x40>)
341a56a8:	460c      	mov	r4, r1
341a56aa:	4605      	mov	r5, r0
341a56ac:	6831      	ldr	r1, [r6, #0]
341a56ae:	b911      	cbnz	r1, 341a56b6 <sbrk_aligned+0x12>
341a56b0:	f000 fe44 	bl	341a633c <_sbrk_r>
341a56b4:	6030      	str	r0, [r6, #0]
341a56b6:	4621      	mov	r1, r4
341a56b8:	4628      	mov	r0, r5
341a56ba:	f000 fe3f 	bl	341a633c <_sbrk_r>
341a56be:	1c43      	adds	r3, r0, #1
341a56c0:	d103      	bne.n	341a56ca <sbrk_aligned+0x26>
341a56c2:	f04f 34ff 	mov.w	r4, #4294967295
341a56c6:	4620      	mov	r0, r4
341a56c8:	bd70      	pop	{r4, r5, r6, pc}
341a56ca:	1cc4      	adds	r4, r0, #3
341a56cc:	f024 0403 	bic.w	r4, r4, #3
341a56d0:	42a0      	cmp	r0, r4
341a56d2:	d0f8      	beq.n	341a56c6 <sbrk_aligned+0x22>
341a56d4:	1a21      	subs	r1, r4, r0
341a56d6:	4628      	mov	r0, r5
341a56d8:	f000 fe30 	bl	341a633c <_sbrk_r>
341a56dc:	3001      	adds	r0, #1
341a56de:	d1f2      	bne.n	341a56c6 <sbrk_aligned+0x22>
341a56e0:	e7ef      	b.n	341a56c2 <sbrk_aligned+0x1e>
341a56e2:	bf00      	nop
341a56e4:	341c2014 	.word	0x341c2014

341a56e8 <_malloc_r>:
341a56e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
341a56ec:	1ccd      	adds	r5, r1, #3
341a56ee:	4606      	mov	r6, r0
341a56f0:	f025 0503 	bic.w	r5, r5, #3
341a56f4:	3508      	adds	r5, #8
341a56f6:	2d0c      	cmp	r5, #12
341a56f8:	bf38      	it	cc
341a56fa:	250c      	movcc	r5, #12
341a56fc:	2d00      	cmp	r5, #0
341a56fe:	db01      	blt.n	341a5704 <_malloc_r+0x1c>
341a5700:	42a9      	cmp	r1, r5
341a5702:	d904      	bls.n	341a570e <_malloc_r+0x26>
341a5704:	230c      	movs	r3, #12
341a5706:	6033      	str	r3, [r6, #0]
341a5708:	2000      	movs	r0, #0
341a570a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
341a570e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 341a57e4 <_malloc_r+0xfc>
341a5712:	f000 f869 	bl	341a57e8 <__malloc_lock>
341a5716:	f8d8 3000 	ldr.w	r3, [r8]
341a571a:	461c      	mov	r4, r3
341a571c:	bb44      	cbnz	r4, 341a5770 <_malloc_r+0x88>
341a571e:	4629      	mov	r1, r5
341a5720:	4630      	mov	r0, r6
341a5722:	f7ff ffbf 	bl	341a56a4 <sbrk_aligned>
341a5726:	1c43      	adds	r3, r0, #1
341a5728:	4604      	mov	r4, r0
341a572a:	d158      	bne.n	341a57de <_malloc_r+0xf6>
341a572c:	f8d8 4000 	ldr.w	r4, [r8]
341a5730:	4627      	mov	r7, r4
341a5732:	2f00      	cmp	r7, #0
341a5734:	d143      	bne.n	341a57be <_malloc_r+0xd6>
341a5736:	2c00      	cmp	r4, #0
341a5738:	d04b      	beq.n	341a57d2 <_malloc_r+0xea>
341a573a:	6823      	ldr	r3, [r4, #0]
341a573c:	4639      	mov	r1, r7
341a573e:	4630      	mov	r0, r6
341a5740:	eb04 0903 	add.w	r9, r4, r3
341a5744:	f000 fdfa 	bl	341a633c <_sbrk_r>
341a5748:	4581      	cmp	r9, r0
341a574a:	d142      	bne.n	341a57d2 <_malloc_r+0xea>
341a574c:	6821      	ldr	r1, [r4, #0]
341a574e:	4630      	mov	r0, r6
341a5750:	1a6d      	subs	r5, r5, r1
341a5752:	4629      	mov	r1, r5
341a5754:	f7ff ffa6 	bl	341a56a4 <sbrk_aligned>
341a5758:	3001      	adds	r0, #1
341a575a:	d03a      	beq.n	341a57d2 <_malloc_r+0xea>
341a575c:	6823      	ldr	r3, [r4, #0]
341a575e:	442b      	add	r3, r5
341a5760:	6023      	str	r3, [r4, #0]
341a5762:	f8d8 3000 	ldr.w	r3, [r8]
341a5766:	685a      	ldr	r2, [r3, #4]
341a5768:	bb62      	cbnz	r2, 341a57c4 <_malloc_r+0xdc>
341a576a:	f8c8 7000 	str.w	r7, [r8]
341a576e:	e00f      	b.n	341a5790 <_malloc_r+0xa8>
341a5770:	6822      	ldr	r2, [r4, #0]
341a5772:	1b52      	subs	r2, r2, r5
341a5774:	d420      	bmi.n	341a57b8 <_malloc_r+0xd0>
341a5776:	2a0b      	cmp	r2, #11
341a5778:	d917      	bls.n	341a57aa <_malloc_r+0xc2>
341a577a:	1961      	adds	r1, r4, r5
341a577c:	42a3      	cmp	r3, r4
341a577e:	6025      	str	r5, [r4, #0]
341a5780:	bf18      	it	ne
341a5782:	6059      	strne	r1, [r3, #4]
341a5784:	6863      	ldr	r3, [r4, #4]
341a5786:	bf08      	it	eq
341a5788:	f8c8 1000 	streq.w	r1, [r8]
341a578c:	5162      	str	r2, [r4, r5]
341a578e:	604b      	str	r3, [r1, #4]
341a5790:	4630      	mov	r0, r6
341a5792:	f000 f82f 	bl	341a57f4 <__malloc_unlock>
341a5796:	f104 000b 	add.w	r0, r4, #11
341a579a:	1d23      	adds	r3, r4, #4
341a579c:	f020 0007 	bic.w	r0, r0, #7
341a57a0:	1ac2      	subs	r2, r0, r3
341a57a2:	bf1c      	itt	ne
341a57a4:	1a1b      	subne	r3, r3, r0
341a57a6:	50a3      	strne	r3, [r4, r2]
341a57a8:	e7af      	b.n	341a570a <_malloc_r+0x22>
341a57aa:	6862      	ldr	r2, [r4, #4]
341a57ac:	42a3      	cmp	r3, r4
341a57ae:	bf0c      	ite	eq
341a57b0:	f8c8 2000 	streq.w	r2, [r8]
341a57b4:	605a      	strne	r2, [r3, #4]
341a57b6:	e7eb      	b.n	341a5790 <_malloc_r+0xa8>
341a57b8:	4623      	mov	r3, r4
341a57ba:	6864      	ldr	r4, [r4, #4]
341a57bc:	e7ae      	b.n	341a571c <_malloc_r+0x34>
341a57be:	463c      	mov	r4, r7
341a57c0:	687f      	ldr	r7, [r7, #4]
341a57c2:	e7b6      	b.n	341a5732 <_malloc_r+0x4a>
341a57c4:	461a      	mov	r2, r3
341a57c6:	685b      	ldr	r3, [r3, #4]
341a57c8:	42a3      	cmp	r3, r4
341a57ca:	d1fb      	bne.n	341a57c4 <_malloc_r+0xdc>
341a57cc:	2300      	movs	r3, #0
341a57ce:	6053      	str	r3, [r2, #4]
341a57d0:	e7de      	b.n	341a5790 <_malloc_r+0xa8>
341a57d2:	230c      	movs	r3, #12
341a57d4:	4630      	mov	r0, r6
341a57d6:	6033      	str	r3, [r6, #0]
341a57d8:	f000 f80c 	bl	341a57f4 <__malloc_unlock>
341a57dc:	e794      	b.n	341a5708 <_malloc_r+0x20>
341a57de:	6005      	str	r5, [r0, #0]
341a57e0:	e7d6      	b.n	341a5790 <_malloc_r+0xa8>
341a57e2:	bf00      	nop
341a57e4:	341c2018 	.word	0x341c2018

341a57e8 <__malloc_lock>:
341a57e8:	4801      	ldr	r0, [pc, #4]	@ (341a57f0 <__malloc_lock+0x8>)
341a57ea:	f7ff befa 	b.w	341a55e2 <__retarget_lock_acquire_recursive>
341a57ee:	bf00      	nop
341a57f0:	341c2010 	.word	0x341c2010

341a57f4 <__malloc_unlock>:
341a57f4:	4801      	ldr	r0, [pc, #4]	@ (341a57fc <__malloc_unlock+0x8>)
341a57f6:	f7ff bef5 	b.w	341a55e4 <__retarget_lock_release_recursive>
341a57fa:	bf00      	nop
341a57fc:	341c2010 	.word	0x341c2010

341a5800 <__ssputs_r>:
341a5800:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
341a5804:	461f      	mov	r7, r3
341a5806:	688e      	ldr	r6, [r1, #8]
341a5808:	4682      	mov	sl, r0
341a580a:	460c      	mov	r4, r1
341a580c:	42be      	cmp	r6, r7
341a580e:	4690      	mov	r8, r2
341a5810:	680b      	ldr	r3, [r1, #0]
341a5812:	d82d      	bhi.n	341a5870 <__ssputs_r+0x70>
341a5814:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
341a5818:	f412 6f90 	tst.w	r2, #1152	@ 0x480
341a581c:	d026      	beq.n	341a586c <__ssputs_r+0x6c>
341a581e:	6965      	ldr	r5, [r4, #20]
341a5820:	6909      	ldr	r1, [r1, #16]
341a5822:	eb05 0545 	add.w	r5, r5, r5, lsl #1
341a5826:	eba3 0901 	sub.w	r9, r3, r1
341a582a:	1c7b      	adds	r3, r7, #1
341a582c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
341a5830:	444b      	add	r3, r9
341a5832:	106d      	asrs	r5, r5, #1
341a5834:	429d      	cmp	r5, r3
341a5836:	bf38      	it	cc
341a5838:	461d      	movcc	r5, r3
341a583a:	0553      	lsls	r3, r2, #21
341a583c:	d527      	bpl.n	341a588e <__ssputs_r+0x8e>
341a583e:	4629      	mov	r1, r5
341a5840:	f7ff ff52 	bl	341a56e8 <_malloc_r>
341a5844:	4606      	mov	r6, r0
341a5846:	b360      	cbz	r0, 341a58a2 <__ssputs_r+0xa2>
341a5848:	464a      	mov	r2, r9
341a584a:	6921      	ldr	r1, [r4, #16]
341a584c:	f7ff fecb 	bl	341a55e6 <memcpy>
341a5850:	89a3      	ldrh	r3, [r4, #12]
341a5852:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
341a5856:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
341a585a:	81a3      	strh	r3, [r4, #12]
341a585c:	6126      	str	r6, [r4, #16]
341a585e:	444e      	add	r6, r9
341a5860:	6165      	str	r5, [r4, #20]
341a5862:	eba5 0509 	sub.w	r5, r5, r9
341a5866:	6026      	str	r6, [r4, #0]
341a5868:	463e      	mov	r6, r7
341a586a:	60a5      	str	r5, [r4, #8]
341a586c:	42be      	cmp	r6, r7
341a586e:	d900      	bls.n	341a5872 <__ssputs_r+0x72>
341a5870:	463e      	mov	r6, r7
341a5872:	4632      	mov	r2, r6
341a5874:	4641      	mov	r1, r8
341a5876:	6820      	ldr	r0, [r4, #0]
341a5878:	f7ff fe20 	bl	341a54bc <memmove>
341a587c:	68a3      	ldr	r3, [r4, #8]
341a587e:	2000      	movs	r0, #0
341a5880:	1b9b      	subs	r3, r3, r6
341a5882:	60a3      	str	r3, [r4, #8]
341a5884:	6823      	ldr	r3, [r4, #0]
341a5886:	4433      	add	r3, r6
341a5888:	6023      	str	r3, [r4, #0]
341a588a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a588e:	462a      	mov	r2, r5
341a5890:	f000 fd72 	bl	341a6378 <_realloc_r>
341a5894:	4606      	mov	r6, r0
341a5896:	2800      	cmp	r0, #0
341a5898:	d1e0      	bne.n	341a585c <__ssputs_r+0x5c>
341a589a:	6921      	ldr	r1, [r4, #16]
341a589c:	4650      	mov	r0, sl
341a589e:	f7ff feb7 	bl	341a5610 <_free_r>
341a58a2:	230c      	movs	r3, #12
341a58a4:	f04f 30ff 	mov.w	r0, #4294967295
341a58a8:	f8ca 3000 	str.w	r3, [sl]
341a58ac:	89a3      	ldrh	r3, [r4, #12]
341a58ae:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a58b2:	81a3      	strh	r3, [r4, #12]
341a58b4:	e7e9      	b.n	341a588a <__ssputs_r+0x8a>
	...

341a58b8 <_svfiprintf_r>:
341a58b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a58bc:	4698      	mov	r8, r3
341a58be:	898b      	ldrh	r3, [r1, #12]
341a58c0:	b09d      	sub	sp, #116	@ 0x74
341a58c2:	4607      	mov	r7, r0
341a58c4:	061b      	lsls	r3, r3, #24
341a58c6:	460d      	mov	r5, r1
341a58c8:	4614      	mov	r4, r2
341a58ca:	d510      	bpl.n	341a58ee <_svfiprintf_r+0x36>
341a58cc:	690b      	ldr	r3, [r1, #16]
341a58ce:	b973      	cbnz	r3, 341a58ee <_svfiprintf_r+0x36>
341a58d0:	2140      	movs	r1, #64	@ 0x40
341a58d2:	f7ff ff09 	bl	341a56e8 <_malloc_r>
341a58d6:	6028      	str	r0, [r5, #0]
341a58d8:	6128      	str	r0, [r5, #16]
341a58da:	b930      	cbnz	r0, 341a58ea <_svfiprintf_r+0x32>
341a58dc:	230c      	movs	r3, #12
341a58de:	603b      	str	r3, [r7, #0]
341a58e0:	f04f 30ff 	mov.w	r0, #4294967295
341a58e4:	b01d      	add	sp, #116	@ 0x74
341a58e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a58ea:	2340      	movs	r3, #64	@ 0x40
341a58ec:	616b      	str	r3, [r5, #20]
341a58ee:	2300      	movs	r3, #0
341a58f0:	f8cd 800c 	str.w	r8, [sp, #12]
341a58f4:	f04f 0901 	mov.w	r9, #1
341a58f8:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 341a5a9c <_svfiprintf_r+0x1e4>
341a58fc:	9309      	str	r3, [sp, #36]	@ 0x24
341a58fe:	2320      	movs	r3, #32
341a5900:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
341a5904:	2330      	movs	r3, #48	@ 0x30
341a5906:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
341a590a:	4623      	mov	r3, r4
341a590c:	469a      	mov	sl, r3
341a590e:	f813 2b01 	ldrb.w	r2, [r3], #1
341a5912:	b10a      	cbz	r2, 341a5918 <_svfiprintf_r+0x60>
341a5914:	2a25      	cmp	r2, #37	@ 0x25
341a5916:	d1f9      	bne.n	341a590c <_svfiprintf_r+0x54>
341a5918:	ebba 0b04 	subs.w	fp, sl, r4
341a591c:	d00b      	beq.n	341a5936 <_svfiprintf_r+0x7e>
341a591e:	465b      	mov	r3, fp
341a5920:	4622      	mov	r2, r4
341a5922:	4629      	mov	r1, r5
341a5924:	4638      	mov	r0, r7
341a5926:	f7ff ff6b 	bl	341a5800 <__ssputs_r>
341a592a:	3001      	adds	r0, #1
341a592c:	f000 80a7 	beq.w	341a5a7e <_svfiprintf_r+0x1c6>
341a5930:	9a09      	ldr	r2, [sp, #36]	@ 0x24
341a5932:	445a      	add	r2, fp
341a5934:	9209      	str	r2, [sp, #36]	@ 0x24
341a5936:	f89a 3000 	ldrb.w	r3, [sl]
341a593a:	2b00      	cmp	r3, #0
341a593c:	f000 809f 	beq.w	341a5a7e <_svfiprintf_r+0x1c6>
341a5940:	2300      	movs	r3, #0
341a5942:	f04f 32ff 	mov.w	r2, #4294967295
341a5946:	f10a 0a01 	add.w	sl, sl, #1
341a594a:	9304      	str	r3, [sp, #16]
341a594c:	9307      	str	r3, [sp, #28]
341a594e:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
341a5952:	931a      	str	r3, [sp, #104]	@ 0x68
341a5954:	e9cd 2305 	strd	r2, r3, [sp, #20]
341a5958:	4654      	mov	r4, sl
341a595a:	2205      	movs	r2, #5
341a595c:	484f      	ldr	r0, [pc, #316]	@ (341a5a9c <_svfiprintf_r+0x1e4>)
341a595e:	f814 1b01 	ldrb.w	r1, [r4], #1
341a5962:	f000 fcfb 	bl	341a635c <memchr>
341a5966:	9a04      	ldr	r2, [sp, #16]
341a5968:	b9d8      	cbnz	r0, 341a59a2 <_svfiprintf_r+0xea>
341a596a:	06d0      	lsls	r0, r2, #27
341a596c:	bf44      	itt	mi
341a596e:	2320      	movmi	r3, #32
341a5970:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a5974:	0711      	lsls	r1, r2, #28
341a5976:	bf44      	itt	mi
341a5978:	232b      	movmi	r3, #43	@ 0x2b
341a597a:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a597e:	f89a 3000 	ldrb.w	r3, [sl]
341a5982:	2b2a      	cmp	r3, #42	@ 0x2a
341a5984:	d015      	beq.n	341a59b2 <_svfiprintf_r+0xfa>
341a5986:	9a07      	ldr	r2, [sp, #28]
341a5988:	4654      	mov	r4, sl
341a598a:	2000      	movs	r0, #0
341a598c:	f04f 0c0a 	mov.w	ip, #10
341a5990:	4621      	mov	r1, r4
341a5992:	f811 3b01 	ldrb.w	r3, [r1], #1
341a5996:	3b30      	subs	r3, #48	@ 0x30
341a5998:	2b09      	cmp	r3, #9
341a599a:	d94b      	bls.n	341a5a34 <_svfiprintf_r+0x17c>
341a599c:	b1b0      	cbz	r0, 341a59cc <_svfiprintf_r+0x114>
341a599e:	9207      	str	r2, [sp, #28]
341a59a0:	e014      	b.n	341a59cc <_svfiprintf_r+0x114>
341a59a2:	eba0 0308 	sub.w	r3, r0, r8
341a59a6:	46a2      	mov	sl, r4
341a59a8:	fa09 f303 	lsl.w	r3, r9, r3
341a59ac:	4313      	orrs	r3, r2
341a59ae:	9304      	str	r3, [sp, #16]
341a59b0:	e7d2      	b.n	341a5958 <_svfiprintf_r+0xa0>
341a59b2:	9b03      	ldr	r3, [sp, #12]
341a59b4:	1d19      	adds	r1, r3, #4
341a59b6:	681b      	ldr	r3, [r3, #0]
341a59b8:	2b00      	cmp	r3, #0
341a59ba:	9103      	str	r1, [sp, #12]
341a59bc:	bfbb      	ittet	lt
341a59be:	425b      	neglt	r3, r3
341a59c0:	f042 0202 	orrlt.w	r2, r2, #2
341a59c4:	9307      	strge	r3, [sp, #28]
341a59c6:	9307      	strlt	r3, [sp, #28]
341a59c8:	bfb8      	it	lt
341a59ca:	9204      	strlt	r2, [sp, #16]
341a59cc:	7823      	ldrb	r3, [r4, #0]
341a59ce:	2b2e      	cmp	r3, #46	@ 0x2e
341a59d0:	d10a      	bne.n	341a59e8 <_svfiprintf_r+0x130>
341a59d2:	7863      	ldrb	r3, [r4, #1]
341a59d4:	2b2a      	cmp	r3, #42	@ 0x2a
341a59d6:	d132      	bne.n	341a5a3e <_svfiprintf_r+0x186>
341a59d8:	9b03      	ldr	r3, [sp, #12]
341a59da:	3402      	adds	r4, #2
341a59dc:	1d1a      	adds	r2, r3, #4
341a59de:	681b      	ldr	r3, [r3, #0]
341a59e0:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
341a59e4:	9203      	str	r2, [sp, #12]
341a59e6:	9305      	str	r3, [sp, #20]
341a59e8:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 341a5aac <_svfiprintf_r+0x1f4>
341a59ec:	2203      	movs	r2, #3
341a59ee:	7821      	ldrb	r1, [r4, #0]
341a59f0:	4650      	mov	r0, sl
341a59f2:	f000 fcb3 	bl	341a635c <memchr>
341a59f6:	b138      	cbz	r0, 341a5a08 <_svfiprintf_r+0x150>
341a59f8:	eba0 000a 	sub.w	r0, r0, sl
341a59fc:	2240      	movs	r2, #64	@ 0x40
341a59fe:	9b04      	ldr	r3, [sp, #16]
341a5a00:	3401      	adds	r4, #1
341a5a02:	4082      	lsls	r2, r0
341a5a04:	4313      	orrs	r3, r2
341a5a06:	9304      	str	r3, [sp, #16]
341a5a08:	f814 1b01 	ldrb.w	r1, [r4], #1
341a5a0c:	2206      	movs	r2, #6
341a5a0e:	4824      	ldr	r0, [pc, #144]	@ (341a5aa0 <_svfiprintf_r+0x1e8>)
341a5a10:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
341a5a14:	f000 fca2 	bl	341a635c <memchr>
341a5a18:	2800      	cmp	r0, #0
341a5a1a:	d036      	beq.n	341a5a8a <_svfiprintf_r+0x1d2>
341a5a1c:	4b21      	ldr	r3, [pc, #132]	@ (341a5aa4 <_svfiprintf_r+0x1ec>)
341a5a1e:	bb1b      	cbnz	r3, 341a5a68 <_svfiprintf_r+0x1b0>
341a5a20:	9b03      	ldr	r3, [sp, #12]
341a5a22:	3307      	adds	r3, #7
341a5a24:	f023 0307 	bic.w	r3, r3, #7
341a5a28:	3308      	adds	r3, #8
341a5a2a:	9303      	str	r3, [sp, #12]
341a5a2c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
341a5a2e:	4433      	add	r3, r6
341a5a30:	9309      	str	r3, [sp, #36]	@ 0x24
341a5a32:	e76a      	b.n	341a590a <_svfiprintf_r+0x52>
341a5a34:	fb0c 3202 	mla	r2, ip, r2, r3
341a5a38:	460c      	mov	r4, r1
341a5a3a:	2001      	movs	r0, #1
341a5a3c:	e7a8      	b.n	341a5990 <_svfiprintf_r+0xd8>
341a5a3e:	2300      	movs	r3, #0
341a5a40:	3401      	adds	r4, #1
341a5a42:	f04f 0c0a 	mov.w	ip, #10
341a5a46:	4619      	mov	r1, r3
341a5a48:	9305      	str	r3, [sp, #20]
341a5a4a:	4620      	mov	r0, r4
341a5a4c:	f810 2b01 	ldrb.w	r2, [r0], #1
341a5a50:	3a30      	subs	r2, #48	@ 0x30
341a5a52:	2a09      	cmp	r2, #9
341a5a54:	d903      	bls.n	341a5a5e <_svfiprintf_r+0x1a6>
341a5a56:	2b00      	cmp	r3, #0
341a5a58:	d0c6      	beq.n	341a59e8 <_svfiprintf_r+0x130>
341a5a5a:	9105      	str	r1, [sp, #20]
341a5a5c:	e7c4      	b.n	341a59e8 <_svfiprintf_r+0x130>
341a5a5e:	fb0c 2101 	mla	r1, ip, r1, r2
341a5a62:	4604      	mov	r4, r0
341a5a64:	2301      	movs	r3, #1
341a5a66:	e7f0      	b.n	341a5a4a <_svfiprintf_r+0x192>
341a5a68:	ab03      	add	r3, sp, #12
341a5a6a:	462a      	mov	r2, r5
341a5a6c:	a904      	add	r1, sp, #16
341a5a6e:	4638      	mov	r0, r7
341a5a70:	9300      	str	r3, [sp, #0]
341a5a72:	4b0d      	ldr	r3, [pc, #52]	@ (341a5aa8 <_svfiprintf_r+0x1f0>)
341a5a74:	f3af 8000 	nop.w
341a5a78:	1c42      	adds	r2, r0, #1
341a5a7a:	4606      	mov	r6, r0
341a5a7c:	d1d6      	bne.n	341a5a2c <_svfiprintf_r+0x174>
341a5a7e:	89ab      	ldrh	r3, [r5, #12]
341a5a80:	065b      	lsls	r3, r3, #25
341a5a82:	f53f af2d 	bmi.w	341a58e0 <_svfiprintf_r+0x28>
341a5a86:	9809      	ldr	r0, [sp, #36]	@ 0x24
341a5a88:	e72c      	b.n	341a58e4 <_svfiprintf_r+0x2c>
341a5a8a:	ab03      	add	r3, sp, #12
341a5a8c:	462a      	mov	r2, r5
341a5a8e:	a904      	add	r1, sp, #16
341a5a90:	4638      	mov	r0, r7
341a5a92:	9300      	str	r3, [sp, #0]
341a5a94:	4b04      	ldr	r3, [pc, #16]	@ (341a5aa8 <_svfiprintf_r+0x1f0>)
341a5a96:	f000 f9bf 	bl	341a5e18 <_printf_i>
341a5a9a:	e7ed      	b.n	341a5a78 <_svfiprintf_r+0x1c0>
341a5a9c:	341afc31 	.word	0x341afc31
341a5aa0:	341afc3b 	.word	0x341afc3b
341a5aa4:	00000000 	.word	0x00000000
341a5aa8:	341a5801 	.word	0x341a5801
341a5aac:	341afc37 	.word	0x341afc37

341a5ab0 <__sfputc_r>:
341a5ab0:	6893      	ldr	r3, [r2, #8]
341a5ab2:	3b01      	subs	r3, #1
341a5ab4:	2b00      	cmp	r3, #0
341a5ab6:	b410      	push	{r4}
341a5ab8:	6093      	str	r3, [r2, #8]
341a5aba:	da08      	bge.n	341a5ace <__sfputc_r+0x1e>
341a5abc:	6994      	ldr	r4, [r2, #24]
341a5abe:	42a3      	cmp	r3, r4
341a5ac0:	db01      	blt.n	341a5ac6 <__sfputc_r+0x16>
341a5ac2:	290a      	cmp	r1, #10
341a5ac4:	d103      	bne.n	341a5ace <__sfputc_r+0x1e>
341a5ac6:	f85d 4b04 	ldr.w	r4, [sp], #4
341a5aca:	f7ff bc62 	b.w	341a5392 <__swbuf_r>
341a5ace:	6813      	ldr	r3, [r2, #0]
341a5ad0:	1c58      	adds	r0, r3, #1
341a5ad2:	6010      	str	r0, [r2, #0]
341a5ad4:	4608      	mov	r0, r1
341a5ad6:	7019      	strb	r1, [r3, #0]
341a5ad8:	f85d 4b04 	ldr.w	r4, [sp], #4
341a5adc:	4770      	bx	lr

341a5ade <__sfputs_r>:
341a5ade:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a5ae0:	4606      	mov	r6, r0
341a5ae2:	460f      	mov	r7, r1
341a5ae4:	4614      	mov	r4, r2
341a5ae6:	18d5      	adds	r5, r2, r3
341a5ae8:	42ac      	cmp	r4, r5
341a5aea:	d101      	bne.n	341a5af0 <__sfputs_r+0x12>
341a5aec:	2000      	movs	r0, #0
341a5aee:	e007      	b.n	341a5b00 <__sfputs_r+0x22>
341a5af0:	463a      	mov	r2, r7
341a5af2:	f814 1b01 	ldrb.w	r1, [r4], #1
341a5af6:	4630      	mov	r0, r6
341a5af8:	f7ff ffda 	bl	341a5ab0 <__sfputc_r>
341a5afc:	1c43      	adds	r3, r0, #1
341a5afe:	d1f3      	bne.n	341a5ae8 <__sfputs_r+0xa>
341a5b00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

341a5b04 <_vfiprintf_r>:
341a5b04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a5b08:	460d      	mov	r5, r1
341a5b0a:	b09d      	sub	sp, #116	@ 0x74
341a5b0c:	4614      	mov	r4, r2
341a5b0e:	4698      	mov	r8, r3
341a5b10:	4606      	mov	r6, r0
341a5b12:	b118      	cbz	r0, 341a5b1c <_vfiprintf_r+0x18>
341a5b14:	6a03      	ldr	r3, [r0, #32]
341a5b16:	b90b      	cbnz	r3, 341a5b1c <_vfiprintf_r+0x18>
341a5b18:	f7ff fb0a 	bl	341a5130 <__sinit>
341a5b1c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a5b1e:	07d9      	lsls	r1, r3, #31
341a5b20:	d405      	bmi.n	341a5b2e <_vfiprintf_r+0x2a>
341a5b22:	89ab      	ldrh	r3, [r5, #12]
341a5b24:	059a      	lsls	r2, r3, #22
341a5b26:	d402      	bmi.n	341a5b2e <_vfiprintf_r+0x2a>
341a5b28:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a5b2a:	f7ff fd5a 	bl	341a55e2 <__retarget_lock_acquire_recursive>
341a5b2e:	89ab      	ldrh	r3, [r5, #12]
341a5b30:	071b      	lsls	r3, r3, #28
341a5b32:	d501      	bpl.n	341a5b38 <_vfiprintf_r+0x34>
341a5b34:	692b      	ldr	r3, [r5, #16]
341a5b36:	b99b      	cbnz	r3, 341a5b60 <_vfiprintf_r+0x5c>
341a5b38:	4629      	mov	r1, r5
341a5b3a:	4630      	mov	r0, r6
341a5b3c:	f7ff fc68 	bl	341a5410 <__swsetup_r>
341a5b40:	b170      	cbz	r0, 341a5b60 <_vfiprintf_r+0x5c>
341a5b42:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a5b44:	07dc      	lsls	r4, r3, #31
341a5b46:	d504      	bpl.n	341a5b52 <_vfiprintf_r+0x4e>
341a5b48:	f04f 30ff 	mov.w	r0, #4294967295
341a5b4c:	b01d      	add	sp, #116	@ 0x74
341a5b4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a5b52:	89ab      	ldrh	r3, [r5, #12]
341a5b54:	0598      	lsls	r0, r3, #22
341a5b56:	d4f7      	bmi.n	341a5b48 <_vfiprintf_r+0x44>
341a5b58:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a5b5a:	f7ff fd43 	bl	341a55e4 <__retarget_lock_release_recursive>
341a5b5e:	e7f3      	b.n	341a5b48 <_vfiprintf_r+0x44>
341a5b60:	2300      	movs	r3, #0
341a5b62:	f8cd 800c 	str.w	r8, [sp, #12]
341a5b66:	f04f 0901 	mov.w	r9, #1
341a5b6a:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 341a5d20 <_vfiprintf_r+0x21c>
341a5b6e:	9309      	str	r3, [sp, #36]	@ 0x24
341a5b70:	2320      	movs	r3, #32
341a5b72:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
341a5b76:	2330      	movs	r3, #48	@ 0x30
341a5b78:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
341a5b7c:	4623      	mov	r3, r4
341a5b7e:	469a      	mov	sl, r3
341a5b80:	f813 2b01 	ldrb.w	r2, [r3], #1
341a5b84:	b10a      	cbz	r2, 341a5b8a <_vfiprintf_r+0x86>
341a5b86:	2a25      	cmp	r2, #37	@ 0x25
341a5b88:	d1f9      	bne.n	341a5b7e <_vfiprintf_r+0x7a>
341a5b8a:	ebba 0b04 	subs.w	fp, sl, r4
341a5b8e:	d00b      	beq.n	341a5ba8 <_vfiprintf_r+0xa4>
341a5b90:	465b      	mov	r3, fp
341a5b92:	4622      	mov	r2, r4
341a5b94:	4629      	mov	r1, r5
341a5b96:	4630      	mov	r0, r6
341a5b98:	f7ff ffa1 	bl	341a5ade <__sfputs_r>
341a5b9c:	3001      	adds	r0, #1
341a5b9e:	f000 80a7 	beq.w	341a5cf0 <_vfiprintf_r+0x1ec>
341a5ba2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
341a5ba4:	445a      	add	r2, fp
341a5ba6:	9209      	str	r2, [sp, #36]	@ 0x24
341a5ba8:	f89a 3000 	ldrb.w	r3, [sl]
341a5bac:	2b00      	cmp	r3, #0
341a5bae:	f000 809f 	beq.w	341a5cf0 <_vfiprintf_r+0x1ec>
341a5bb2:	2300      	movs	r3, #0
341a5bb4:	f04f 32ff 	mov.w	r2, #4294967295
341a5bb8:	f10a 0a01 	add.w	sl, sl, #1
341a5bbc:	9304      	str	r3, [sp, #16]
341a5bbe:	9307      	str	r3, [sp, #28]
341a5bc0:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
341a5bc4:	931a      	str	r3, [sp, #104]	@ 0x68
341a5bc6:	e9cd 2305 	strd	r2, r3, [sp, #20]
341a5bca:	4654      	mov	r4, sl
341a5bcc:	2205      	movs	r2, #5
341a5bce:	4854      	ldr	r0, [pc, #336]	@ (341a5d20 <_vfiprintf_r+0x21c>)
341a5bd0:	f814 1b01 	ldrb.w	r1, [r4], #1
341a5bd4:	f000 fbc2 	bl	341a635c <memchr>
341a5bd8:	9a04      	ldr	r2, [sp, #16]
341a5bda:	b9d8      	cbnz	r0, 341a5c14 <_vfiprintf_r+0x110>
341a5bdc:	06d1      	lsls	r1, r2, #27
341a5bde:	bf44      	itt	mi
341a5be0:	2320      	movmi	r3, #32
341a5be2:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a5be6:	0713      	lsls	r3, r2, #28
341a5be8:	bf44      	itt	mi
341a5bea:	232b      	movmi	r3, #43	@ 0x2b
341a5bec:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
341a5bf0:	f89a 3000 	ldrb.w	r3, [sl]
341a5bf4:	2b2a      	cmp	r3, #42	@ 0x2a
341a5bf6:	d015      	beq.n	341a5c24 <_vfiprintf_r+0x120>
341a5bf8:	9a07      	ldr	r2, [sp, #28]
341a5bfa:	4654      	mov	r4, sl
341a5bfc:	2000      	movs	r0, #0
341a5bfe:	f04f 0c0a 	mov.w	ip, #10
341a5c02:	4621      	mov	r1, r4
341a5c04:	f811 3b01 	ldrb.w	r3, [r1], #1
341a5c08:	3b30      	subs	r3, #48	@ 0x30
341a5c0a:	2b09      	cmp	r3, #9
341a5c0c:	d94b      	bls.n	341a5ca6 <_vfiprintf_r+0x1a2>
341a5c0e:	b1b0      	cbz	r0, 341a5c3e <_vfiprintf_r+0x13a>
341a5c10:	9207      	str	r2, [sp, #28]
341a5c12:	e014      	b.n	341a5c3e <_vfiprintf_r+0x13a>
341a5c14:	eba0 0308 	sub.w	r3, r0, r8
341a5c18:	46a2      	mov	sl, r4
341a5c1a:	fa09 f303 	lsl.w	r3, r9, r3
341a5c1e:	4313      	orrs	r3, r2
341a5c20:	9304      	str	r3, [sp, #16]
341a5c22:	e7d2      	b.n	341a5bca <_vfiprintf_r+0xc6>
341a5c24:	9b03      	ldr	r3, [sp, #12]
341a5c26:	1d19      	adds	r1, r3, #4
341a5c28:	681b      	ldr	r3, [r3, #0]
341a5c2a:	2b00      	cmp	r3, #0
341a5c2c:	9103      	str	r1, [sp, #12]
341a5c2e:	bfbb      	ittet	lt
341a5c30:	425b      	neglt	r3, r3
341a5c32:	f042 0202 	orrlt.w	r2, r2, #2
341a5c36:	9307      	strge	r3, [sp, #28]
341a5c38:	9307      	strlt	r3, [sp, #28]
341a5c3a:	bfb8      	it	lt
341a5c3c:	9204      	strlt	r2, [sp, #16]
341a5c3e:	7823      	ldrb	r3, [r4, #0]
341a5c40:	2b2e      	cmp	r3, #46	@ 0x2e
341a5c42:	d10a      	bne.n	341a5c5a <_vfiprintf_r+0x156>
341a5c44:	7863      	ldrb	r3, [r4, #1]
341a5c46:	2b2a      	cmp	r3, #42	@ 0x2a
341a5c48:	d132      	bne.n	341a5cb0 <_vfiprintf_r+0x1ac>
341a5c4a:	9b03      	ldr	r3, [sp, #12]
341a5c4c:	3402      	adds	r4, #2
341a5c4e:	1d1a      	adds	r2, r3, #4
341a5c50:	681b      	ldr	r3, [r3, #0]
341a5c52:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
341a5c56:	9203      	str	r2, [sp, #12]
341a5c58:	9305      	str	r3, [sp, #20]
341a5c5a:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 341a5d30 <_vfiprintf_r+0x22c>
341a5c5e:	2203      	movs	r2, #3
341a5c60:	7821      	ldrb	r1, [r4, #0]
341a5c62:	4650      	mov	r0, sl
341a5c64:	f000 fb7a 	bl	341a635c <memchr>
341a5c68:	b138      	cbz	r0, 341a5c7a <_vfiprintf_r+0x176>
341a5c6a:	eba0 000a 	sub.w	r0, r0, sl
341a5c6e:	2240      	movs	r2, #64	@ 0x40
341a5c70:	9b04      	ldr	r3, [sp, #16]
341a5c72:	3401      	adds	r4, #1
341a5c74:	4082      	lsls	r2, r0
341a5c76:	4313      	orrs	r3, r2
341a5c78:	9304      	str	r3, [sp, #16]
341a5c7a:	f814 1b01 	ldrb.w	r1, [r4], #1
341a5c7e:	2206      	movs	r2, #6
341a5c80:	4828      	ldr	r0, [pc, #160]	@ (341a5d24 <_vfiprintf_r+0x220>)
341a5c82:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
341a5c86:	f000 fb69 	bl	341a635c <memchr>
341a5c8a:	2800      	cmp	r0, #0
341a5c8c:	d03f      	beq.n	341a5d0e <_vfiprintf_r+0x20a>
341a5c8e:	4b26      	ldr	r3, [pc, #152]	@ (341a5d28 <_vfiprintf_r+0x224>)
341a5c90:	bb1b      	cbnz	r3, 341a5cda <_vfiprintf_r+0x1d6>
341a5c92:	9b03      	ldr	r3, [sp, #12]
341a5c94:	3307      	adds	r3, #7
341a5c96:	f023 0307 	bic.w	r3, r3, #7
341a5c9a:	3308      	adds	r3, #8
341a5c9c:	9303      	str	r3, [sp, #12]
341a5c9e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
341a5ca0:	443b      	add	r3, r7
341a5ca2:	9309      	str	r3, [sp, #36]	@ 0x24
341a5ca4:	e76a      	b.n	341a5b7c <_vfiprintf_r+0x78>
341a5ca6:	fb0c 3202 	mla	r2, ip, r2, r3
341a5caa:	460c      	mov	r4, r1
341a5cac:	2001      	movs	r0, #1
341a5cae:	e7a8      	b.n	341a5c02 <_vfiprintf_r+0xfe>
341a5cb0:	2300      	movs	r3, #0
341a5cb2:	3401      	adds	r4, #1
341a5cb4:	f04f 0c0a 	mov.w	ip, #10
341a5cb8:	4619      	mov	r1, r3
341a5cba:	9305      	str	r3, [sp, #20]
341a5cbc:	4620      	mov	r0, r4
341a5cbe:	f810 2b01 	ldrb.w	r2, [r0], #1
341a5cc2:	3a30      	subs	r2, #48	@ 0x30
341a5cc4:	2a09      	cmp	r2, #9
341a5cc6:	d903      	bls.n	341a5cd0 <_vfiprintf_r+0x1cc>
341a5cc8:	2b00      	cmp	r3, #0
341a5cca:	d0c6      	beq.n	341a5c5a <_vfiprintf_r+0x156>
341a5ccc:	9105      	str	r1, [sp, #20]
341a5cce:	e7c4      	b.n	341a5c5a <_vfiprintf_r+0x156>
341a5cd0:	fb0c 2101 	mla	r1, ip, r1, r2
341a5cd4:	4604      	mov	r4, r0
341a5cd6:	2301      	movs	r3, #1
341a5cd8:	e7f0      	b.n	341a5cbc <_vfiprintf_r+0x1b8>
341a5cda:	ab03      	add	r3, sp, #12
341a5cdc:	462a      	mov	r2, r5
341a5cde:	a904      	add	r1, sp, #16
341a5ce0:	4630      	mov	r0, r6
341a5ce2:	9300      	str	r3, [sp, #0]
341a5ce4:	4b11      	ldr	r3, [pc, #68]	@ (341a5d2c <_vfiprintf_r+0x228>)
341a5ce6:	f3af 8000 	nop.w
341a5cea:	4607      	mov	r7, r0
341a5cec:	1c78      	adds	r0, r7, #1
341a5cee:	d1d6      	bne.n	341a5c9e <_vfiprintf_r+0x19a>
341a5cf0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
341a5cf2:	07d9      	lsls	r1, r3, #31
341a5cf4:	d405      	bmi.n	341a5d02 <_vfiprintf_r+0x1fe>
341a5cf6:	89ab      	ldrh	r3, [r5, #12]
341a5cf8:	059a      	lsls	r2, r3, #22
341a5cfa:	d402      	bmi.n	341a5d02 <_vfiprintf_r+0x1fe>
341a5cfc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
341a5cfe:	f7ff fc71 	bl	341a55e4 <__retarget_lock_release_recursive>
341a5d02:	89ab      	ldrh	r3, [r5, #12]
341a5d04:	065b      	lsls	r3, r3, #25
341a5d06:	f53f af1f 	bmi.w	341a5b48 <_vfiprintf_r+0x44>
341a5d0a:	9809      	ldr	r0, [sp, #36]	@ 0x24
341a5d0c:	e71e      	b.n	341a5b4c <_vfiprintf_r+0x48>
341a5d0e:	ab03      	add	r3, sp, #12
341a5d10:	462a      	mov	r2, r5
341a5d12:	a904      	add	r1, sp, #16
341a5d14:	4630      	mov	r0, r6
341a5d16:	9300      	str	r3, [sp, #0]
341a5d18:	4b04      	ldr	r3, [pc, #16]	@ (341a5d2c <_vfiprintf_r+0x228>)
341a5d1a:	f000 f87d 	bl	341a5e18 <_printf_i>
341a5d1e:	e7e4      	b.n	341a5cea <_vfiprintf_r+0x1e6>
341a5d20:	341afc31 	.word	0x341afc31
341a5d24:	341afc3b 	.word	0x341afc3b
341a5d28:	00000000 	.word	0x00000000
341a5d2c:	341a5adf 	.word	0x341a5adf
341a5d30:	341afc37 	.word	0x341afc37

341a5d34 <_printf_common>:
341a5d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
341a5d38:	4616      	mov	r6, r2
341a5d3a:	4698      	mov	r8, r3
341a5d3c:	688a      	ldr	r2, [r1, #8]
341a5d3e:	4607      	mov	r7, r0
341a5d40:	690b      	ldr	r3, [r1, #16]
341a5d42:	460c      	mov	r4, r1
341a5d44:	f8dd 9020 	ldr.w	r9, [sp, #32]
341a5d48:	4293      	cmp	r3, r2
341a5d4a:	bfb8      	it	lt
341a5d4c:	4613      	movlt	r3, r2
341a5d4e:	6033      	str	r3, [r6, #0]
341a5d50:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
341a5d54:	b10a      	cbz	r2, 341a5d5a <_printf_common+0x26>
341a5d56:	3301      	adds	r3, #1
341a5d58:	6033      	str	r3, [r6, #0]
341a5d5a:	6823      	ldr	r3, [r4, #0]
341a5d5c:	0699      	lsls	r1, r3, #26
341a5d5e:	bf42      	ittt	mi
341a5d60:	6833      	ldrmi	r3, [r6, #0]
341a5d62:	3302      	addmi	r3, #2
341a5d64:	6033      	strmi	r3, [r6, #0]
341a5d66:	6825      	ldr	r5, [r4, #0]
341a5d68:	f015 0506 	ands.w	r5, r5, #6
341a5d6c:	d106      	bne.n	341a5d7c <_printf_common+0x48>
341a5d6e:	f104 0a19 	add.w	sl, r4, #25
341a5d72:	68e3      	ldr	r3, [r4, #12]
341a5d74:	6832      	ldr	r2, [r6, #0]
341a5d76:	1a9b      	subs	r3, r3, r2
341a5d78:	42ab      	cmp	r3, r5
341a5d7a:	dc2b      	bgt.n	341a5dd4 <_printf_common+0xa0>
341a5d7c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
341a5d80:	6822      	ldr	r2, [r4, #0]
341a5d82:	3b00      	subs	r3, #0
341a5d84:	bf18      	it	ne
341a5d86:	2301      	movne	r3, #1
341a5d88:	0692      	lsls	r2, r2, #26
341a5d8a:	d430      	bmi.n	341a5dee <_printf_common+0xba>
341a5d8c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
341a5d90:	4641      	mov	r1, r8
341a5d92:	4638      	mov	r0, r7
341a5d94:	47c8      	blx	r9
341a5d96:	3001      	adds	r0, #1
341a5d98:	d023      	beq.n	341a5de2 <_printf_common+0xae>
341a5d9a:	6823      	ldr	r3, [r4, #0]
341a5d9c:	341a      	adds	r4, #26
341a5d9e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
341a5da2:	f003 0306 	and.w	r3, r3, #6
341a5da6:	2b04      	cmp	r3, #4
341a5da8:	bf0a      	itet	eq
341a5daa:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
341a5dae:	2500      	movne	r5, #0
341a5db0:	6833      	ldreq	r3, [r6, #0]
341a5db2:	f04f 0600 	mov.w	r6, #0
341a5db6:	bf08      	it	eq
341a5db8:	1aed      	subeq	r5, r5, r3
341a5dba:	f854 3c12 	ldr.w	r3, [r4, #-18]
341a5dbe:	bf08      	it	eq
341a5dc0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
341a5dc4:	4293      	cmp	r3, r2
341a5dc6:	bfc4      	itt	gt
341a5dc8:	1a9b      	subgt	r3, r3, r2
341a5dca:	18ed      	addgt	r5, r5, r3
341a5dcc:	42b5      	cmp	r5, r6
341a5dce:	d11a      	bne.n	341a5e06 <_printf_common+0xd2>
341a5dd0:	2000      	movs	r0, #0
341a5dd2:	e008      	b.n	341a5de6 <_printf_common+0xb2>
341a5dd4:	2301      	movs	r3, #1
341a5dd6:	4652      	mov	r2, sl
341a5dd8:	4641      	mov	r1, r8
341a5dda:	4638      	mov	r0, r7
341a5ddc:	47c8      	blx	r9
341a5dde:	3001      	adds	r0, #1
341a5de0:	d103      	bne.n	341a5dea <_printf_common+0xb6>
341a5de2:	f04f 30ff 	mov.w	r0, #4294967295
341a5de6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a5dea:	3501      	adds	r5, #1
341a5dec:	e7c1      	b.n	341a5d72 <_printf_common+0x3e>
341a5dee:	18e1      	adds	r1, r4, r3
341a5df0:	1c5a      	adds	r2, r3, #1
341a5df2:	2030      	movs	r0, #48	@ 0x30
341a5df4:	3302      	adds	r3, #2
341a5df6:	4422      	add	r2, r4
341a5df8:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
341a5dfc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
341a5e00:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
341a5e04:	e7c2      	b.n	341a5d8c <_printf_common+0x58>
341a5e06:	2301      	movs	r3, #1
341a5e08:	4622      	mov	r2, r4
341a5e0a:	4641      	mov	r1, r8
341a5e0c:	4638      	mov	r0, r7
341a5e0e:	47c8      	blx	r9
341a5e10:	3001      	adds	r0, #1
341a5e12:	d0e6      	beq.n	341a5de2 <_printf_common+0xae>
341a5e14:	3601      	adds	r6, #1
341a5e16:	e7d9      	b.n	341a5dcc <_printf_common+0x98>

341a5e18 <_printf_i>:
341a5e18:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
341a5e1c:	7e0f      	ldrb	r7, [r1, #24]
341a5e1e:	4691      	mov	r9, r2
341a5e20:	4680      	mov	r8, r0
341a5e22:	460c      	mov	r4, r1
341a5e24:	2f78      	cmp	r7, #120	@ 0x78
341a5e26:	469a      	mov	sl, r3
341a5e28:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
341a5e2a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
341a5e2e:	d807      	bhi.n	341a5e40 <_printf_i+0x28>
341a5e30:	2f62      	cmp	r7, #98	@ 0x62
341a5e32:	d80a      	bhi.n	341a5e4a <_printf_i+0x32>
341a5e34:	2f00      	cmp	r7, #0
341a5e36:	f000 80d1 	beq.w	341a5fdc <_printf_i+0x1c4>
341a5e3a:	2f58      	cmp	r7, #88	@ 0x58
341a5e3c:	f000 80b8 	beq.w	341a5fb0 <_printf_i+0x198>
341a5e40:	f104 0642 	add.w	r6, r4, #66	@ 0x42
341a5e44:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
341a5e48:	e03a      	b.n	341a5ec0 <_printf_i+0xa8>
341a5e4a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
341a5e4e:	2b15      	cmp	r3, #21
341a5e50:	d8f6      	bhi.n	341a5e40 <_printf_i+0x28>
341a5e52:	a101      	add	r1, pc, #4	@ (adr r1, 341a5e58 <_printf_i+0x40>)
341a5e54:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
341a5e58:	341a5eb1 	.word	0x341a5eb1
341a5e5c:	341a5ec5 	.word	0x341a5ec5
341a5e60:	341a5e41 	.word	0x341a5e41
341a5e64:	341a5e41 	.word	0x341a5e41
341a5e68:	341a5e41 	.word	0x341a5e41
341a5e6c:	341a5e41 	.word	0x341a5e41
341a5e70:	341a5ec5 	.word	0x341a5ec5
341a5e74:	341a5e41 	.word	0x341a5e41
341a5e78:	341a5e41 	.word	0x341a5e41
341a5e7c:	341a5e41 	.word	0x341a5e41
341a5e80:	341a5e41 	.word	0x341a5e41
341a5e84:	341a5fc3 	.word	0x341a5fc3
341a5e88:	341a5eef 	.word	0x341a5eef
341a5e8c:	341a5f7d 	.word	0x341a5f7d
341a5e90:	341a5e41 	.word	0x341a5e41
341a5e94:	341a5e41 	.word	0x341a5e41
341a5e98:	341a5fe5 	.word	0x341a5fe5
341a5e9c:	341a5e41 	.word	0x341a5e41
341a5ea0:	341a5eef 	.word	0x341a5eef
341a5ea4:	341a5e41 	.word	0x341a5e41
341a5ea8:	341a5e41 	.word	0x341a5e41
341a5eac:	341a5f85 	.word	0x341a5f85
341a5eb0:	6833      	ldr	r3, [r6, #0]
341a5eb2:	1d1a      	adds	r2, r3, #4
341a5eb4:	681b      	ldr	r3, [r3, #0]
341a5eb6:	6032      	str	r2, [r6, #0]
341a5eb8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
341a5ebc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
341a5ec0:	2301      	movs	r3, #1
341a5ec2:	e09c      	b.n	341a5ffe <_printf_i+0x1e6>
341a5ec4:	6833      	ldr	r3, [r6, #0]
341a5ec6:	6820      	ldr	r0, [r4, #0]
341a5ec8:	1d19      	adds	r1, r3, #4
341a5eca:	6031      	str	r1, [r6, #0]
341a5ecc:	0606      	lsls	r6, r0, #24
341a5ece:	d501      	bpl.n	341a5ed4 <_printf_i+0xbc>
341a5ed0:	681d      	ldr	r5, [r3, #0]
341a5ed2:	e003      	b.n	341a5edc <_printf_i+0xc4>
341a5ed4:	0645      	lsls	r5, r0, #25
341a5ed6:	d5fb      	bpl.n	341a5ed0 <_printf_i+0xb8>
341a5ed8:	f9b3 5000 	ldrsh.w	r5, [r3]
341a5edc:	2d00      	cmp	r5, #0
341a5ede:	da03      	bge.n	341a5ee8 <_printf_i+0xd0>
341a5ee0:	232d      	movs	r3, #45	@ 0x2d
341a5ee2:	426d      	negs	r5, r5
341a5ee4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
341a5ee8:	4858      	ldr	r0, [pc, #352]	@ (341a604c <_printf_i+0x234>)
341a5eea:	230a      	movs	r3, #10
341a5eec:	e011      	b.n	341a5f12 <_printf_i+0xfa>
341a5eee:	6821      	ldr	r1, [r4, #0]
341a5ef0:	6833      	ldr	r3, [r6, #0]
341a5ef2:	0608      	lsls	r0, r1, #24
341a5ef4:	f853 5b04 	ldr.w	r5, [r3], #4
341a5ef8:	d402      	bmi.n	341a5f00 <_printf_i+0xe8>
341a5efa:	0649      	lsls	r1, r1, #25
341a5efc:	bf48      	it	mi
341a5efe:	b2ad      	uxthmi	r5, r5
341a5f00:	2f6f      	cmp	r7, #111	@ 0x6f
341a5f02:	6033      	str	r3, [r6, #0]
341a5f04:	4851      	ldr	r0, [pc, #324]	@ (341a604c <_printf_i+0x234>)
341a5f06:	bf14      	ite	ne
341a5f08:	230a      	movne	r3, #10
341a5f0a:	2308      	moveq	r3, #8
341a5f0c:	2100      	movs	r1, #0
341a5f0e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
341a5f12:	6866      	ldr	r6, [r4, #4]
341a5f14:	2e00      	cmp	r6, #0
341a5f16:	60a6      	str	r6, [r4, #8]
341a5f18:	db05      	blt.n	341a5f26 <_printf_i+0x10e>
341a5f1a:	6821      	ldr	r1, [r4, #0]
341a5f1c:	432e      	orrs	r6, r5
341a5f1e:	f021 0104 	bic.w	r1, r1, #4
341a5f22:	6021      	str	r1, [r4, #0]
341a5f24:	d04b      	beq.n	341a5fbe <_printf_i+0x1a6>
341a5f26:	4616      	mov	r6, r2
341a5f28:	fbb5 f1f3 	udiv	r1, r5, r3
341a5f2c:	fb03 5711 	mls	r7, r3, r1, r5
341a5f30:	5dc7      	ldrb	r7, [r0, r7]
341a5f32:	f806 7d01 	strb.w	r7, [r6, #-1]!
341a5f36:	462f      	mov	r7, r5
341a5f38:	460d      	mov	r5, r1
341a5f3a:	42bb      	cmp	r3, r7
341a5f3c:	d9f4      	bls.n	341a5f28 <_printf_i+0x110>
341a5f3e:	2b08      	cmp	r3, #8
341a5f40:	d10b      	bne.n	341a5f5a <_printf_i+0x142>
341a5f42:	6823      	ldr	r3, [r4, #0]
341a5f44:	07df      	lsls	r7, r3, #31
341a5f46:	d508      	bpl.n	341a5f5a <_printf_i+0x142>
341a5f48:	6923      	ldr	r3, [r4, #16]
341a5f4a:	6861      	ldr	r1, [r4, #4]
341a5f4c:	4299      	cmp	r1, r3
341a5f4e:	bfde      	ittt	le
341a5f50:	2330      	movle	r3, #48	@ 0x30
341a5f52:	f806 3c01 	strble.w	r3, [r6, #-1]
341a5f56:	f106 36ff 	addle.w	r6, r6, #4294967295
341a5f5a:	1b92      	subs	r2, r2, r6
341a5f5c:	6122      	str	r2, [r4, #16]
341a5f5e:	464b      	mov	r3, r9
341a5f60:	aa03      	add	r2, sp, #12
341a5f62:	4621      	mov	r1, r4
341a5f64:	4640      	mov	r0, r8
341a5f66:	f8cd a000 	str.w	sl, [sp]
341a5f6a:	f7ff fee3 	bl	341a5d34 <_printf_common>
341a5f6e:	3001      	adds	r0, #1
341a5f70:	d14a      	bne.n	341a6008 <_printf_i+0x1f0>
341a5f72:	f04f 30ff 	mov.w	r0, #4294967295
341a5f76:	b004      	add	sp, #16
341a5f78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
341a5f7c:	6823      	ldr	r3, [r4, #0]
341a5f7e:	f043 0320 	orr.w	r3, r3, #32
341a5f82:	6023      	str	r3, [r4, #0]
341a5f84:	2778      	movs	r7, #120	@ 0x78
341a5f86:	4832      	ldr	r0, [pc, #200]	@ (341a6050 <_printf_i+0x238>)
341a5f88:	6823      	ldr	r3, [r4, #0]
341a5f8a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
341a5f8e:	061f      	lsls	r7, r3, #24
341a5f90:	6831      	ldr	r1, [r6, #0]
341a5f92:	f851 5b04 	ldr.w	r5, [r1], #4
341a5f96:	d402      	bmi.n	341a5f9e <_printf_i+0x186>
341a5f98:	065f      	lsls	r7, r3, #25
341a5f9a:	bf48      	it	mi
341a5f9c:	b2ad      	uxthmi	r5, r5
341a5f9e:	6031      	str	r1, [r6, #0]
341a5fa0:	07d9      	lsls	r1, r3, #31
341a5fa2:	bf44      	itt	mi
341a5fa4:	f043 0320 	orrmi.w	r3, r3, #32
341a5fa8:	6023      	strmi	r3, [r4, #0]
341a5faa:	b11d      	cbz	r5, 341a5fb4 <_printf_i+0x19c>
341a5fac:	2310      	movs	r3, #16
341a5fae:	e7ad      	b.n	341a5f0c <_printf_i+0xf4>
341a5fb0:	4826      	ldr	r0, [pc, #152]	@ (341a604c <_printf_i+0x234>)
341a5fb2:	e7e9      	b.n	341a5f88 <_printf_i+0x170>
341a5fb4:	6823      	ldr	r3, [r4, #0]
341a5fb6:	f023 0320 	bic.w	r3, r3, #32
341a5fba:	6023      	str	r3, [r4, #0]
341a5fbc:	e7f6      	b.n	341a5fac <_printf_i+0x194>
341a5fbe:	4616      	mov	r6, r2
341a5fc0:	e7bd      	b.n	341a5f3e <_printf_i+0x126>
341a5fc2:	6833      	ldr	r3, [r6, #0]
341a5fc4:	6825      	ldr	r5, [r4, #0]
341a5fc6:	1d18      	adds	r0, r3, #4
341a5fc8:	6961      	ldr	r1, [r4, #20]
341a5fca:	6030      	str	r0, [r6, #0]
341a5fcc:	062e      	lsls	r6, r5, #24
341a5fce:	681b      	ldr	r3, [r3, #0]
341a5fd0:	d501      	bpl.n	341a5fd6 <_printf_i+0x1be>
341a5fd2:	6019      	str	r1, [r3, #0]
341a5fd4:	e002      	b.n	341a5fdc <_printf_i+0x1c4>
341a5fd6:	0668      	lsls	r0, r5, #25
341a5fd8:	d5fb      	bpl.n	341a5fd2 <_printf_i+0x1ba>
341a5fda:	8019      	strh	r1, [r3, #0]
341a5fdc:	2300      	movs	r3, #0
341a5fde:	4616      	mov	r6, r2
341a5fe0:	6123      	str	r3, [r4, #16]
341a5fe2:	e7bc      	b.n	341a5f5e <_printf_i+0x146>
341a5fe4:	6833      	ldr	r3, [r6, #0]
341a5fe6:	2100      	movs	r1, #0
341a5fe8:	1d1a      	adds	r2, r3, #4
341a5fea:	6032      	str	r2, [r6, #0]
341a5fec:	681e      	ldr	r6, [r3, #0]
341a5fee:	6862      	ldr	r2, [r4, #4]
341a5ff0:	4630      	mov	r0, r6
341a5ff2:	f000 f9b3 	bl	341a635c <memchr>
341a5ff6:	b108      	cbz	r0, 341a5ffc <_printf_i+0x1e4>
341a5ff8:	1b80      	subs	r0, r0, r6
341a5ffa:	6060      	str	r0, [r4, #4]
341a5ffc:	6863      	ldr	r3, [r4, #4]
341a5ffe:	6123      	str	r3, [r4, #16]
341a6000:	2300      	movs	r3, #0
341a6002:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
341a6006:	e7aa      	b.n	341a5f5e <_printf_i+0x146>
341a6008:	6923      	ldr	r3, [r4, #16]
341a600a:	4632      	mov	r2, r6
341a600c:	4649      	mov	r1, r9
341a600e:	4640      	mov	r0, r8
341a6010:	47d0      	blx	sl
341a6012:	3001      	adds	r0, #1
341a6014:	d0ad      	beq.n	341a5f72 <_printf_i+0x15a>
341a6016:	6823      	ldr	r3, [r4, #0]
341a6018:	079b      	lsls	r3, r3, #30
341a601a:	d413      	bmi.n	341a6044 <_printf_i+0x22c>
341a601c:	68e0      	ldr	r0, [r4, #12]
341a601e:	9b03      	ldr	r3, [sp, #12]
341a6020:	4298      	cmp	r0, r3
341a6022:	bfb8      	it	lt
341a6024:	4618      	movlt	r0, r3
341a6026:	e7a6      	b.n	341a5f76 <_printf_i+0x15e>
341a6028:	2301      	movs	r3, #1
341a602a:	4632      	mov	r2, r6
341a602c:	4649      	mov	r1, r9
341a602e:	4640      	mov	r0, r8
341a6030:	47d0      	blx	sl
341a6032:	3001      	adds	r0, #1
341a6034:	d09d      	beq.n	341a5f72 <_printf_i+0x15a>
341a6036:	3501      	adds	r5, #1
341a6038:	68e3      	ldr	r3, [r4, #12]
341a603a:	9903      	ldr	r1, [sp, #12]
341a603c:	1a5b      	subs	r3, r3, r1
341a603e:	42ab      	cmp	r3, r5
341a6040:	dcf2      	bgt.n	341a6028 <_printf_i+0x210>
341a6042:	e7eb      	b.n	341a601c <_printf_i+0x204>
341a6044:	2500      	movs	r5, #0
341a6046:	f104 0619 	add.w	r6, r4, #25
341a604a:	e7f5      	b.n	341a6038 <_printf_i+0x220>
341a604c:	341afc42 	.word	0x341afc42
341a6050:	341afc53 	.word	0x341afc53

341a6054 <__sflush_r>:
341a6054:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
341a6058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a605c:	0716      	lsls	r6, r2, #28
341a605e:	4605      	mov	r5, r0
341a6060:	460c      	mov	r4, r1
341a6062:	d454      	bmi.n	341a610e <__sflush_r+0xba>
341a6064:	684b      	ldr	r3, [r1, #4]
341a6066:	2b00      	cmp	r3, #0
341a6068:	dc02      	bgt.n	341a6070 <__sflush_r+0x1c>
341a606a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
341a606c:	2b00      	cmp	r3, #0
341a606e:	dd48      	ble.n	341a6102 <__sflush_r+0xae>
341a6070:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
341a6072:	2e00      	cmp	r6, #0
341a6074:	d045      	beq.n	341a6102 <__sflush_r+0xae>
341a6076:	2300      	movs	r3, #0
341a6078:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
341a607c:	682f      	ldr	r7, [r5, #0]
341a607e:	6a21      	ldr	r1, [r4, #32]
341a6080:	602b      	str	r3, [r5, #0]
341a6082:	d030      	beq.n	341a60e6 <__sflush_r+0x92>
341a6084:	6d62      	ldr	r2, [r4, #84]	@ 0x54
341a6086:	89a3      	ldrh	r3, [r4, #12]
341a6088:	0759      	lsls	r1, r3, #29
341a608a:	d505      	bpl.n	341a6098 <__sflush_r+0x44>
341a608c:	6863      	ldr	r3, [r4, #4]
341a608e:	1ad2      	subs	r2, r2, r3
341a6090:	6b63      	ldr	r3, [r4, #52]	@ 0x34
341a6092:	b10b      	cbz	r3, 341a6098 <__sflush_r+0x44>
341a6094:	6c23      	ldr	r3, [r4, #64]	@ 0x40
341a6096:	1ad2      	subs	r2, r2, r3
341a6098:	2300      	movs	r3, #0
341a609a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
341a609c:	6a21      	ldr	r1, [r4, #32]
341a609e:	4628      	mov	r0, r5
341a60a0:	47b0      	blx	r6
341a60a2:	1c43      	adds	r3, r0, #1
341a60a4:	89a3      	ldrh	r3, [r4, #12]
341a60a6:	d106      	bne.n	341a60b6 <__sflush_r+0x62>
341a60a8:	6829      	ldr	r1, [r5, #0]
341a60aa:	291d      	cmp	r1, #29
341a60ac:	d82b      	bhi.n	341a6106 <__sflush_r+0xb2>
341a60ae:	4a2a      	ldr	r2, [pc, #168]	@ (341a6158 <__sflush_r+0x104>)
341a60b0:	40ca      	lsrs	r2, r1
341a60b2:	07d6      	lsls	r6, r2, #31
341a60b4:	d527      	bpl.n	341a6106 <__sflush_r+0xb2>
341a60b6:	2200      	movs	r2, #0
341a60b8:	04d9      	lsls	r1, r3, #19
341a60ba:	6062      	str	r2, [r4, #4]
341a60bc:	6922      	ldr	r2, [r4, #16]
341a60be:	6022      	str	r2, [r4, #0]
341a60c0:	d504      	bpl.n	341a60cc <__sflush_r+0x78>
341a60c2:	1c42      	adds	r2, r0, #1
341a60c4:	d101      	bne.n	341a60ca <__sflush_r+0x76>
341a60c6:	682b      	ldr	r3, [r5, #0]
341a60c8:	b903      	cbnz	r3, 341a60cc <__sflush_r+0x78>
341a60ca:	6560      	str	r0, [r4, #84]	@ 0x54
341a60cc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
341a60ce:	602f      	str	r7, [r5, #0]
341a60d0:	b1b9      	cbz	r1, 341a6102 <__sflush_r+0xae>
341a60d2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
341a60d6:	4299      	cmp	r1, r3
341a60d8:	d002      	beq.n	341a60e0 <__sflush_r+0x8c>
341a60da:	4628      	mov	r0, r5
341a60dc:	f7ff fa98 	bl	341a5610 <_free_r>
341a60e0:	2300      	movs	r3, #0
341a60e2:	6363      	str	r3, [r4, #52]	@ 0x34
341a60e4:	e00d      	b.n	341a6102 <__sflush_r+0xae>
341a60e6:	2301      	movs	r3, #1
341a60e8:	4628      	mov	r0, r5
341a60ea:	47b0      	blx	r6
341a60ec:	4602      	mov	r2, r0
341a60ee:	1c50      	adds	r0, r2, #1
341a60f0:	d1c9      	bne.n	341a6086 <__sflush_r+0x32>
341a60f2:	682b      	ldr	r3, [r5, #0]
341a60f4:	2b00      	cmp	r3, #0
341a60f6:	d0c6      	beq.n	341a6086 <__sflush_r+0x32>
341a60f8:	2b1d      	cmp	r3, #29
341a60fa:	d001      	beq.n	341a6100 <__sflush_r+0xac>
341a60fc:	2b16      	cmp	r3, #22
341a60fe:	d11d      	bne.n	341a613c <__sflush_r+0xe8>
341a6100:	602f      	str	r7, [r5, #0]
341a6102:	2000      	movs	r0, #0
341a6104:	e021      	b.n	341a614a <__sflush_r+0xf6>
341a6106:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a610a:	b21b      	sxth	r3, r3
341a610c:	e01a      	b.n	341a6144 <__sflush_r+0xf0>
341a610e:	690f      	ldr	r7, [r1, #16]
341a6110:	2f00      	cmp	r7, #0
341a6112:	d0f6      	beq.n	341a6102 <__sflush_r+0xae>
341a6114:	0793      	lsls	r3, r2, #30
341a6116:	680e      	ldr	r6, [r1, #0]
341a6118:	600f      	str	r7, [r1, #0]
341a611a:	bf0c      	ite	eq
341a611c:	694b      	ldreq	r3, [r1, #20]
341a611e:	2300      	movne	r3, #0
341a6120:	eba6 0807 	sub.w	r8, r6, r7
341a6124:	608b      	str	r3, [r1, #8]
341a6126:	f1b8 0f00 	cmp.w	r8, #0
341a612a:	ddea      	ble.n	341a6102 <__sflush_r+0xae>
341a612c:	4643      	mov	r3, r8
341a612e:	463a      	mov	r2, r7
341a6130:	6a21      	ldr	r1, [r4, #32]
341a6132:	4628      	mov	r0, r5
341a6134:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
341a6136:	47b0      	blx	r6
341a6138:	2800      	cmp	r0, #0
341a613a:	dc08      	bgt.n	341a614e <__sflush_r+0xfa>
341a613c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a6140:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
341a6144:	f04f 30ff 	mov.w	r0, #4294967295
341a6148:	81a3      	strh	r3, [r4, #12]
341a614a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
341a614e:	4407      	add	r7, r0
341a6150:	eba8 0800 	sub.w	r8, r8, r0
341a6154:	e7e7      	b.n	341a6126 <__sflush_r+0xd2>
341a6156:	bf00      	nop
341a6158:	20400001 	.word	0x20400001

341a615c <_fflush_r>:
341a615c:	b538      	push	{r3, r4, r5, lr}
341a615e:	690b      	ldr	r3, [r1, #16]
341a6160:	4605      	mov	r5, r0
341a6162:	460c      	mov	r4, r1
341a6164:	b913      	cbnz	r3, 341a616c <_fflush_r+0x10>
341a6166:	2500      	movs	r5, #0
341a6168:	4628      	mov	r0, r5
341a616a:	bd38      	pop	{r3, r4, r5, pc}
341a616c:	b118      	cbz	r0, 341a6176 <_fflush_r+0x1a>
341a616e:	6a03      	ldr	r3, [r0, #32]
341a6170:	b90b      	cbnz	r3, 341a6176 <_fflush_r+0x1a>
341a6172:	f7fe ffdd 	bl	341a5130 <__sinit>
341a6176:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a617a:	2b00      	cmp	r3, #0
341a617c:	d0f3      	beq.n	341a6166 <_fflush_r+0xa>
341a617e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
341a6180:	07d0      	lsls	r0, r2, #31
341a6182:	d404      	bmi.n	341a618e <_fflush_r+0x32>
341a6184:	0599      	lsls	r1, r3, #22
341a6186:	d402      	bmi.n	341a618e <_fflush_r+0x32>
341a6188:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a618a:	f7ff fa2a 	bl	341a55e2 <__retarget_lock_acquire_recursive>
341a618e:	4628      	mov	r0, r5
341a6190:	4621      	mov	r1, r4
341a6192:	f7ff ff5f 	bl	341a6054 <__sflush_r>
341a6196:	6e63      	ldr	r3, [r4, #100]	@ 0x64
341a6198:	4605      	mov	r5, r0
341a619a:	07da      	lsls	r2, r3, #31
341a619c:	d4e4      	bmi.n	341a6168 <_fflush_r+0xc>
341a619e:	89a3      	ldrh	r3, [r4, #12]
341a61a0:	059b      	lsls	r3, r3, #22
341a61a2:	d4e1      	bmi.n	341a6168 <_fflush_r+0xc>
341a61a4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
341a61a6:	f7ff fa1d 	bl	341a55e4 <__retarget_lock_release_recursive>
341a61aa:	e7dd      	b.n	341a6168 <_fflush_r+0xc>

341a61ac <__swhatbuf_r>:
341a61ac:	b570      	push	{r4, r5, r6, lr}
341a61ae:	460c      	mov	r4, r1
341a61b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
341a61b4:	b096      	sub	sp, #88	@ 0x58
341a61b6:	4615      	mov	r5, r2
341a61b8:	2900      	cmp	r1, #0
341a61ba:	461e      	mov	r6, r3
341a61bc:	da0c      	bge.n	341a61d8 <__swhatbuf_r+0x2c>
341a61be:	89a3      	ldrh	r3, [r4, #12]
341a61c0:	2100      	movs	r1, #0
341a61c2:	f013 0f80 	tst.w	r3, #128	@ 0x80
341a61c6:	bf14      	ite	ne
341a61c8:	2340      	movne	r3, #64	@ 0x40
341a61ca:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
341a61ce:	2000      	movs	r0, #0
341a61d0:	6031      	str	r1, [r6, #0]
341a61d2:	602b      	str	r3, [r5, #0]
341a61d4:	b016      	add	sp, #88	@ 0x58
341a61d6:	bd70      	pop	{r4, r5, r6, pc}
341a61d8:	466a      	mov	r2, sp
341a61da:	f000 f879 	bl	341a62d0 <_fstat_r>
341a61de:	2800      	cmp	r0, #0
341a61e0:	dbed      	blt.n	341a61be <__swhatbuf_r+0x12>
341a61e2:	9901      	ldr	r1, [sp, #4]
341a61e4:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
341a61e8:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
341a61ec:	4259      	negs	r1, r3
341a61ee:	4159      	adcs	r1, r3
341a61f0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
341a61f4:	e7eb      	b.n	341a61ce <__swhatbuf_r+0x22>

341a61f6 <__smakebuf_r>:
341a61f6:	898b      	ldrh	r3, [r1, #12]
341a61f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
341a61fa:	079d      	lsls	r5, r3, #30
341a61fc:	4606      	mov	r6, r0
341a61fe:	460c      	mov	r4, r1
341a6200:	d507      	bpl.n	341a6212 <__smakebuf_r+0x1c>
341a6202:	f104 0347 	add.w	r3, r4, #71	@ 0x47
341a6206:	6023      	str	r3, [r4, #0]
341a6208:	6123      	str	r3, [r4, #16]
341a620a:	2301      	movs	r3, #1
341a620c:	6163      	str	r3, [r4, #20]
341a620e:	b003      	add	sp, #12
341a6210:	bdf0      	pop	{r4, r5, r6, r7, pc}
341a6212:	ab01      	add	r3, sp, #4
341a6214:	466a      	mov	r2, sp
341a6216:	f7ff ffc9 	bl	341a61ac <__swhatbuf_r>
341a621a:	9f00      	ldr	r7, [sp, #0]
341a621c:	4605      	mov	r5, r0
341a621e:	4630      	mov	r0, r6
341a6220:	4639      	mov	r1, r7
341a6222:	f7ff fa61 	bl	341a56e8 <_malloc_r>
341a6226:	b948      	cbnz	r0, 341a623c <__smakebuf_r+0x46>
341a6228:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
341a622c:	059a      	lsls	r2, r3, #22
341a622e:	d4ee      	bmi.n	341a620e <__smakebuf_r+0x18>
341a6230:	f023 0303 	bic.w	r3, r3, #3
341a6234:	f043 0302 	orr.w	r3, r3, #2
341a6238:	81a3      	strh	r3, [r4, #12]
341a623a:	e7e2      	b.n	341a6202 <__smakebuf_r+0xc>
341a623c:	89a3      	ldrh	r3, [r4, #12]
341a623e:	6020      	str	r0, [r4, #0]
341a6240:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
341a6244:	81a3      	strh	r3, [r4, #12]
341a6246:	9b01      	ldr	r3, [sp, #4]
341a6248:	e9c4 0704 	strd	r0, r7, [r4, #16]
341a624c:	b15b      	cbz	r3, 341a6266 <__smakebuf_r+0x70>
341a624e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
341a6252:	4630      	mov	r0, r6
341a6254:	f000 f84e 	bl	341a62f4 <_isatty_r>
341a6258:	b128      	cbz	r0, 341a6266 <__smakebuf_r+0x70>
341a625a:	89a3      	ldrh	r3, [r4, #12]
341a625c:	f023 0303 	bic.w	r3, r3, #3
341a6260:	f043 0301 	orr.w	r3, r3, #1
341a6264:	81a3      	strh	r3, [r4, #12]
341a6266:	89a3      	ldrh	r3, [r4, #12]
341a6268:	431d      	orrs	r5, r3
341a626a:	81a5      	strh	r5, [r4, #12]
341a626c:	e7cf      	b.n	341a620e <__smakebuf_r+0x18>

341a626e <_raise_r>:
341a626e:	291f      	cmp	r1, #31
341a6270:	b538      	push	{r3, r4, r5, lr}
341a6272:	4605      	mov	r5, r0
341a6274:	460c      	mov	r4, r1
341a6276:	d904      	bls.n	341a6282 <_raise_r+0x14>
341a6278:	2316      	movs	r3, #22
341a627a:	6003      	str	r3, [r0, #0]
341a627c:	f04f 30ff 	mov.w	r0, #4294967295
341a6280:	bd38      	pop	{r3, r4, r5, pc}
341a6282:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
341a6284:	b112      	cbz	r2, 341a628c <_raise_r+0x1e>
341a6286:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
341a628a:	b94b      	cbnz	r3, 341a62a0 <_raise_r+0x32>
341a628c:	4628      	mov	r0, r5
341a628e:	f000 f853 	bl	341a6338 <_getpid_r>
341a6292:	4622      	mov	r2, r4
341a6294:	4601      	mov	r1, r0
341a6296:	4628      	mov	r0, r5
341a6298:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
341a629c:	f000 b83a 	b.w	341a6314 <_kill_r>
341a62a0:	2b01      	cmp	r3, #1
341a62a2:	d00a      	beq.n	341a62ba <_raise_r+0x4c>
341a62a4:	1c59      	adds	r1, r3, #1
341a62a6:	d103      	bne.n	341a62b0 <_raise_r+0x42>
341a62a8:	2316      	movs	r3, #22
341a62aa:	6003      	str	r3, [r0, #0]
341a62ac:	2001      	movs	r0, #1
341a62ae:	e7e7      	b.n	341a6280 <_raise_r+0x12>
341a62b0:	2100      	movs	r1, #0
341a62b2:	4620      	mov	r0, r4
341a62b4:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
341a62b8:	4798      	blx	r3
341a62ba:	2000      	movs	r0, #0
341a62bc:	e7e0      	b.n	341a6280 <_raise_r+0x12>
	...

341a62c0 <raise>:
341a62c0:	4b02      	ldr	r3, [pc, #8]	@ (341a62cc <raise+0xc>)
341a62c2:	4601      	mov	r1, r0
341a62c4:	6818      	ldr	r0, [r3, #0]
341a62c6:	f7ff bfd2 	b.w	341a626e <_raise_r>
341a62ca:	bf00      	nop
341a62cc:	341c0144 	.word	0x341c0144

341a62d0 <_fstat_r>:
341a62d0:	b538      	push	{r3, r4, r5, lr}
341a62d2:	2300      	movs	r3, #0
341a62d4:	4d06      	ldr	r5, [pc, #24]	@ (341a62f0 <_fstat_r+0x20>)
341a62d6:	4604      	mov	r4, r0
341a62d8:	4608      	mov	r0, r1
341a62da:	4611      	mov	r1, r2
341a62dc:	602b      	str	r3, [r5, #0]
341a62de:	f7dc ff11 	bl	34183104 <_fstat>
341a62e2:	1c43      	adds	r3, r0, #1
341a62e4:	d102      	bne.n	341a62ec <_fstat_r+0x1c>
341a62e6:	682b      	ldr	r3, [r5, #0]
341a62e8:	b103      	cbz	r3, 341a62ec <_fstat_r+0x1c>
341a62ea:	6023      	str	r3, [r4, #0]
341a62ec:	bd38      	pop	{r3, r4, r5, pc}
341a62ee:	bf00      	nop
341a62f0:	341c200c 	.word	0x341c200c

341a62f4 <_isatty_r>:
341a62f4:	b538      	push	{r3, r4, r5, lr}
341a62f6:	2300      	movs	r3, #0
341a62f8:	4d05      	ldr	r5, [pc, #20]	@ (341a6310 <_isatty_r+0x1c>)
341a62fa:	4604      	mov	r4, r0
341a62fc:	4608      	mov	r0, r1
341a62fe:	602b      	str	r3, [r5, #0]
341a6300:	f7dc ff10 	bl	34183124 <_isatty>
341a6304:	1c43      	adds	r3, r0, #1
341a6306:	d102      	bne.n	341a630e <_isatty_r+0x1a>
341a6308:	682b      	ldr	r3, [r5, #0]
341a630a:	b103      	cbz	r3, 341a630e <_isatty_r+0x1a>
341a630c:	6023      	str	r3, [r4, #0]
341a630e:	bd38      	pop	{r3, r4, r5, pc}
341a6310:	341c200c 	.word	0x341c200c

341a6314 <_kill_r>:
341a6314:	b538      	push	{r3, r4, r5, lr}
341a6316:	2300      	movs	r3, #0
341a6318:	4d06      	ldr	r5, [pc, #24]	@ (341a6334 <_kill_r+0x20>)
341a631a:	4604      	mov	r4, r0
341a631c:	4608      	mov	r0, r1
341a631e:	4611      	mov	r1, r2
341a6320:	602b      	str	r3, [r5, #0]
341a6322:	f7dc fe8f 	bl	34183044 <_kill>
341a6326:	1c43      	adds	r3, r0, #1
341a6328:	d102      	bne.n	341a6330 <_kill_r+0x1c>
341a632a:	682b      	ldr	r3, [r5, #0]
341a632c:	b103      	cbz	r3, 341a6330 <_kill_r+0x1c>
341a632e:	6023      	str	r3, [r4, #0]
341a6330:	bd38      	pop	{r3, r4, r5, pc}
341a6332:	bf00      	nop
341a6334:	341c200c 	.word	0x341c200c

341a6338 <_getpid_r>:
341a6338:	f7dc be7c 	b.w	34183034 <_getpid>

341a633c <_sbrk_r>:
341a633c:	b538      	push	{r3, r4, r5, lr}
341a633e:	2300      	movs	r3, #0
341a6340:	4d05      	ldr	r5, [pc, #20]	@ (341a6358 <_sbrk_r+0x1c>)
341a6342:	4604      	mov	r4, r0
341a6344:	4608      	mov	r0, r1
341a6346:	602b      	str	r3, [r5, #0]
341a6348:	f7dc ff04 	bl	34183154 <_sbrk>
341a634c:	1c43      	adds	r3, r0, #1
341a634e:	d102      	bne.n	341a6356 <_sbrk_r+0x1a>
341a6350:	682b      	ldr	r3, [r5, #0]
341a6352:	b103      	cbz	r3, 341a6356 <_sbrk_r+0x1a>
341a6354:	6023      	str	r3, [r4, #0]
341a6356:	bd38      	pop	{r3, r4, r5, pc}
341a6358:	341c200c 	.word	0x341c200c

341a635c <memchr>:
341a635c:	b2c9      	uxtb	r1, r1
341a635e:	4603      	mov	r3, r0
341a6360:	4402      	add	r2, r0
341a6362:	b510      	push	{r4, lr}
341a6364:	4293      	cmp	r3, r2
341a6366:	4618      	mov	r0, r3
341a6368:	d101      	bne.n	341a636e <memchr+0x12>
341a636a:	2000      	movs	r0, #0
341a636c:	e003      	b.n	341a6376 <memchr+0x1a>
341a636e:	7804      	ldrb	r4, [r0, #0]
341a6370:	3301      	adds	r3, #1
341a6372:	428c      	cmp	r4, r1
341a6374:	d1f6      	bne.n	341a6364 <memchr+0x8>
341a6376:	bd10      	pop	{r4, pc}

341a6378 <_realloc_r>:
341a6378:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
341a637c:	4607      	mov	r7, r0
341a637e:	4614      	mov	r4, r2
341a6380:	460d      	mov	r5, r1
341a6382:	b921      	cbnz	r1, 341a638e <_realloc_r+0x16>
341a6384:	4611      	mov	r1, r2
341a6386:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
341a638a:	f7ff b9ad 	b.w	341a56e8 <_malloc_r>
341a638e:	b92a      	cbnz	r2, 341a639c <_realloc_r+0x24>
341a6390:	4625      	mov	r5, r4
341a6392:	f7ff f93d 	bl	341a5610 <_free_r>
341a6396:	4628      	mov	r0, r5
341a6398:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
341a639c:	f000 f81a 	bl	341a63d4 <_malloc_usable_size_r>
341a63a0:	4284      	cmp	r4, r0
341a63a2:	4606      	mov	r6, r0
341a63a4:	d802      	bhi.n	341a63ac <_realloc_r+0x34>
341a63a6:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
341a63aa:	d8f4      	bhi.n	341a6396 <_realloc_r+0x1e>
341a63ac:	4621      	mov	r1, r4
341a63ae:	4638      	mov	r0, r7
341a63b0:	f7ff f99a 	bl	341a56e8 <_malloc_r>
341a63b4:	4680      	mov	r8, r0
341a63b6:	b908      	cbnz	r0, 341a63bc <_realloc_r+0x44>
341a63b8:	4645      	mov	r5, r8
341a63ba:	e7ec      	b.n	341a6396 <_realloc_r+0x1e>
341a63bc:	42b4      	cmp	r4, r6
341a63be:	4622      	mov	r2, r4
341a63c0:	4629      	mov	r1, r5
341a63c2:	bf28      	it	cs
341a63c4:	4632      	movcs	r2, r6
341a63c6:	f7ff f90e 	bl	341a55e6 <memcpy>
341a63ca:	4629      	mov	r1, r5
341a63cc:	4638      	mov	r0, r7
341a63ce:	f7ff f91f 	bl	341a5610 <_free_r>
341a63d2:	e7f1      	b.n	341a63b8 <_realloc_r+0x40>

341a63d4 <_malloc_usable_size_r>:
341a63d4:	f851 3c04 	ldr.w	r3, [r1, #-4]
341a63d8:	1f18      	subs	r0, r3, #4
341a63da:	2b00      	cmp	r3, #0
341a63dc:	bfbc      	itt	lt
341a63de:	580b      	ldrlt	r3, [r1, r0]
341a63e0:	18c0      	addlt	r0, r0, r3
341a63e2:	4770      	bx	lr
341a63e4:	0000      	movs	r0, r0
	...

341a63e8 <log10>:
341a63e8:	b508      	push	{r3, lr}
341a63ea:	ed2d 8b02 	vpush	{d8}
341a63ee:	eeb0 8b40 	vmov.f64	d8, d0
341a63f2:	f000 fca1 	bl	341a6d38 <__ieee754_log10>
341a63f6:	eeb4 8b48 	vcmp.f64	d8, d8
341a63fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a63fe:	d60f      	bvs.n	341a6420 <log10+0x38>
341a6400:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
341a6404:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6408:	d80a      	bhi.n	341a6420 <log10+0x38>
341a640a:	eeb5 8b40 	vcmp.f64	d8, #0.0
341a640e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6412:	d108      	bne.n	341a6426 <log10+0x3e>
341a6414:	f7ff f8ba 	bl	341a558c <__errno>
341a6418:	2322      	movs	r3, #34	@ 0x22
341a641a:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 341a6440 <log10+0x58>
341a641e:	6003      	str	r3, [r0, #0]
341a6420:	ecbd 8b02 	vpop	{d8}
341a6424:	bd08      	pop	{r3, pc}
341a6426:	f7ff f8b1 	bl	341a558c <__errno>
341a642a:	2321      	movs	r3, #33	@ 0x21
341a642c:	ecbd 8b02 	vpop	{d8}
341a6430:	6003      	str	r3, [r0, #0]
341a6432:	4805      	ldr	r0, [pc, #20]	@ (341a6448 <log10+0x60>)
341a6434:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
341a6438:	f000 b82a 	b.w	341a6490 <nan>
341a643c:	f3af 8000 	nop.w
341a6440:	00000000 	.word	0x00000000
341a6444:	fff00000 	.word	0xfff00000
341a6448:	341af7ad 	.word	0x341af7ad
341a644c:	00000000 	.word	0x00000000

341a6450 <sqrt>:
341a6450:	b508      	push	{r3, lr}
341a6452:	ed2d 8b04 	vpush	{d8-d9}
341a6456:	eeb0 8b40 	vmov.f64	d8, d0
341a645a:	f000 fc6a 	bl	341a6d32 <__ieee754_sqrt>
341a645e:	eeb4 8b48 	vcmp.f64	d8, d8
341a6462:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6466:	d60c      	bvs.n	341a6482 <sqrt+0x32>
341a6468:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 341a6488 <sqrt+0x38>
341a646c:	eeb4 8bc9 	vcmpe.f64	d8, d9
341a6470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6474:	d505      	bpl.n	341a6482 <sqrt+0x32>
341a6476:	f7ff f889 	bl	341a558c <__errno>
341a647a:	ee89 0b09 	vdiv.f64	d0, d9, d9
341a647e:	2321      	movs	r3, #33	@ 0x21
341a6480:	6003      	str	r3, [r0, #0]
341a6482:	ecbd 8b04 	vpop	{d8-d9}
341a6486:	bd08      	pop	{r3, pc}
	...

341a6490 <nan>:
341a6490:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a6498 <nan+0x8>
341a6494:	4770      	bx	lr
341a6496:	bf00      	nop
341a6498:	00000000 	.word	0x00000000
341a649c:	7ff80000 	.word	0x7ff80000

341a64a0 <checkint>:
341a64a0:	f3c1 520a 	ubfx	r2, r1, #20, #11
341a64a4:	f240 33fe 	movw	r3, #1022	@ 0x3fe
341a64a8:	429a      	cmp	r2, r3
341a64aa:	b570      	push	{r4, r5, r6, lr}
341a64ac:	dd2a      	ble.n	341a6504 <checkint+0x64>
341a64ae:	f240 4333 	movw	r3, #1075	@ 0x433
341a64b2:	429a      	cmp	r2, r3
341a64b4:	dc24      	bgt.n	341a6500 <checkint+0x60>
341a64b6:	1a9b      	subs	r3, r3, r2
341a64b8:	f04f 32ff 	mov.w	r2, #4294967295
341a64bc:	f1a3 0620 	sub.w	r6, r3, #32
341a64c0:	fa02 f403 	lsl.w	r4, r2, r3
341a64c4:	f1c3 0520 	rsb	r5, r3, #32
341a64c8:	fa02 f606 	lsl.w	r6, r2, r6
341a64cc:	fa22 f505 	lsr.w	r5, r2, r5
341a64d0:	409a      	lsls	r2, r3
341a64d2:	4334      	orrs	r4, r6
341a64d4:	ea20 0202 	bic.w	r2, r0, r2
341a64d8:	432c      	orrs	r4, r5
341a64da:	ea21 0404 	bic.w	r4, r1, r4
341a64de:	4322      	orrs	r2, r4
341a64e0:	f1a3 0420 	sub.w	r4, r3, #32
341a64e4:	f1c3 0220 	rsb	r2, r3, #32
341a64e8:	d10c      	bne.n	341a6504 <checkint+0x64>
341a64ea:	40d8      	lsrs	r0, r3
341a64ec:	fa01 f302 	lsl.w	r3, r1, r2
341a64f0:	40e1      	lsrs	r1, r4
341a64f2:	4318      	orrs	r0, r3
341a64f4:	4308      	orrs	r0, r1
341a64f6:	f000 0001 	and.w	r0, r0, #1
341a64fa:	f1d0 0002 	rsbs	r0, r0, #2
341a64fe:	bd70      	pop	{r4, r5, r6, pc}
341a6500:	2002      	movs	r0, #2
341a6502:	e7fc      	b.n	341a64fe <checkint+0x5e>
341a6504:	2000      	movs	r0, #0
341a6506:	e7fa      	b.n	341a64fe <checkint+0x5e>

341a6508 <pow>:
341a6508:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a650c:	ee10 4a90 	vmov	r4, s1
341a6510:	f240 73fd 	movw	r3, #2045	@ 0x7fd
341a6514:	ee11 aa90 	vmov	sl, s3
341a6518:	ee10 5a10 	vmov	r5, s0
341a651c:	ea4f 5814 	mov.w	r8, r4, lsr #20
341a6520:	ee11 0a10 	vmov	r0, s2
341a6524:	ea4f 561a 	mov.w	r6, sl, lsr #20
341a6528:	f108 32ff 	add.w	r2, r8, #4294967295
341a652c:	46c4      	mov	ip, r8
341a652e:	429a      	cmp	r2, r3
341a6530:	ed2d 8b0a 	vpush	{d8-d12}
341a6534:	b087      	sub	sp, #28
341a6536:	d806      	bhi.n	341a6546 <pow+0x3e>
341a6538:	f3c6 030a 	ubfx	r3, r6, #0, #11
341a653c:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
341a6540:	2b7f      	cmp	r3, #127	@ 0x7f
341a6542:	f240 8157 	bls.w	341a67f4 <pow+0x2ec>
341a6546:	1802      	adds	r2, r0, r0
341a6548:	f06f 0b01 	mvn.w	fp, #1
341a654c:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
341a6550:	eb4a 010a 	adc.w	r1, sl, sl
341a6554:	1e57      	subs	r7, r2, #1
341a6556:	f141 33ff 	adc.w	r3, r1, #4294967295
341a655a:	45bb      	cmp	fp, r7
341a655c:	eb7e 0303 	sbcs.w	r3, lr, r3
341a6560:	d242      	bcs.n	341a65e8 <pow+0xe0>
341a6562:	ea52 0301 	orrs.w	r3, r2, r1
341a6566:	f04f 0300 	mov.w	r3, #0
341a656a:	d10c      	bne.n	341a6586 <pow+0x7e>
341a656c:	196d      	adds	r5, r5, r5
341a656e:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
341a6572:	4164      	adcs	r4, r4
341a6574:	42ab      	cmp	r3, r5
341a6576:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
341a657a:	41a3      	sbcs	r3, r4
341a657c:	f0c0 808f 	bcc.w	341a669e <pow+0x196>
341a6580:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a6584:	e02b      	b.n	341a65de <pow+0xd6>
341a6586:	4ed4      	ldr	r6, [pc, #848]	@ (341a68d8 <pow+0x3d0>)
341a6588:	42b4      	cmp	r4, r6
341a658a:	bf08      	it	eq
341a658c:	429d      	cmpeq	r5, r3
341a658e:	d109      	bne.n	341a65a4 <pow+0x9c>
341a6590:	1800      	adds	r0, r0, r0
341a6592:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
341a6596:	eb4a 0a0a 	adc.w	sl, sl, sl
341a659a:	4283      	cmp	r3, r0
341a659c:	4bcf      	ldr	r3, [pc, #828]	@ (341a68dc <pow+0x3d4>)
341a659e:	eb73 030a 	sbcs.w	r3, r3, sl
341a65a2:	e7eb      	b.n	341a657c <pow+0x74>
341a65a4:	196d      	adds	r5, r5, r5
341a65a6:	48ce      	ldr	r0, [pc, #824]	@ (341a68e0 <pow+0x3d8>)
341a65a8:	4164      	adcs	r4, r4
341a65aa:	42ab      	cmp	r3, r5
341a65ac:	eb70 0604 	sbcs.w	r6, r0, r4
341a65b0:	d375      	bcc.n	341a669e <pow+0x196>
341a65b2:	4281      	cmp	r1, r0
341a65b4:	bf08      	it	eq
341a65b6:	429a      	cmpeq	r2, r3
341a65b8:	d171      	bne.n	341a669e <pow+0x196>
341a65ba:	4aca      	ldr	r2, [pc, #808]	@ (341a68e4 <pow+0x3dc>)
341a65bc:	4294      	cmp	r4, r2
341a65be:	bf08      	it	eq
341a65c0:	429d      	cmpeq	r5, r3
341a65c2:	d0dd      	beq.n	341a6580 <pow+0x78>
341a65c4:	4294      	cmp	r4, r2
341a65c6:	ea6f 0a0a 	mvn.w	sl, sl
341a65ca:	bf34      	ite	cc
341a65cc:	2400      	movcc	r4, #0
341a65ce:	2401      	movcs	r4, #1
341a65d0:	ea4f 7ada 	mov.w	sl, sl, lsr #31
341a65d4:	4554      	cmp	r4, sl
341a65d6:	f040 81dc 	bne.w	341a6992 <pow+0x48a>
341a65da:	ee21 0b01 	vmul.f64	d0, d1, d1
341a65de:	b007      	add	sp, #28
341a65e0:	ecbd 8b0a 	vpop	{d8-d12}
341a65e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
341a65e8:	196f      	adds	r7, r5, r5
341a65ea:	eb44 0904 	adc.w	r9, r4, r4
341a65ee:	1e7a      	subs	r2, r7, #1
341a65f0:	f169 0300 	sbc.w	r3, r9, #0
341a65f4:	4593      	cmp	fp, r2
341a65f6:	eb7e 0303 	sbcs.w	r3, lr, r3
341a65fa:	d225      	bcs.n	341a6648 <pow+0x140>
341a65fc:	2c00      	cmp	r4, #0
341a65fe:	ee20 0b00 	vmul.f64	d0, d0, d0
341a6602:	da13      	bge.n	341a662c <pow+0x124>
341a6604:	4651      	mov	r1, sl
341a6606:	f7ff ff4b 	bl	341a64a0 <checkint>
341a660a:	2801      	cmp	r0, #1
341a660c:	d10e      	bne.n	341a662c <pow+0x124>
341a660e:	eeb1 0b40 	vneg.f64	d0, d0
341a6612:	ea57 0909 	orrs.w	r9, r7, r9
341a6616:	d10b      	bne.n	341a6630 <pow+0x128>
341a6618:	f1ba 0f00 	cmp.w	sl, #0
341a661c:	dadf      	bge.n	341a65de <pow+0xd6>
341a661e:	b007      	add	sp, #28
341a6620:	ecbd 8b0a 	vpop	{d8-d12}
341a6624:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a6628:	f000 bc26 	b.w	341a6e78 <__math_divzero>
341a662c:	2000      	movs	r0, #0
341a662e:	e7f0      	b.n	341a6612 <pow+0x10a>
341a6630:	f1ba 0f00 	cmp.w	sl, #0
341a6634:	dad3      	bge.n	341a65de <pow+0xd6>
341a6636:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
341a663a:	ee86 7b00 	vdiv.f64	d7, d6, d0
341a663e:	ed8d 7b00 	vstr	d7, [sp]
341a6642:	ed9d 0b00 	vldr	d0, [sp]
341a6646:	e7ca      	b.n	341a65de <pow+0xd6>
341a6648:	2c00      	cmp	r4, #0
341a664a:	da2b      	bge.n	341a66a4 <pow+0x19c>
341a664c:	4651      	mov	r1, sl
341a664e:	f7ff ff27 	bl	341a64a0 <checkint>
341a6652:	b930      	cbnz	r0, 341a6662 <pow+0x15a>
341a6654:	b007      	add	sp, #28
341a6656:	ecbd 8b0a 	vpop	{d8-d12}
341a665a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a665e:	f000 bc27 	b.w	341a6eb0 <__math_invalid>
341a6662:	1e41      	subs	r1, r0, #1
341a6664:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
341a6668:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
341a666c:	4248      	negs	r0, r1
341a666e:	4148      	adcs	r0, r1
341a6670:	0480      	lsls	r0, r0, #18
341a6672:	f3c6 020a 	ubfx	r2, r6, #0, #11
341a6676:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
341a667a:	2b7f      	cmp	r3, #127	@ 0x7f
341a667c:	d92d      	bls.n	341a66da <pow+0x1d2>
341a667e:	2000      	movs	r0, #0
341a6680:	4b95      	ldr	r3, [pc, #596]	@ (341a68d8 <pow+0x3d0>)
341a6682:	429c      	cmp	r4, r3
341a6684:	bf08      	it	eq
341a6686:	4285      	cmpeq	r5, r0
341a6688:	f43f af7a 	beq.w	341a6580 <pow+0x78>
341a668c:	f240 31bd 	movw	r1, #957	@ 0x3bd
341a6690:	428a      	cmp	r2, r1
341a6692:	d80c      	bhi.n	341a66ae <pow+0x1a6>
341a6694:	42a8      	cmp	r0, r5
341a6696:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a669a:	41a3      	sbcs	r3, r4
341a669c:	d204      	bcs.n	341a66a8 <pow+0x1a0>
341a669e:	ee31 0b00 	vadd.f64	d0, d1, d0
341a66a2:	e79c      	b.n	341a65de <pow+0xd6>
341a66a4:	2000      	movs	r0, #0
341a66a6:	e7e4      	b.n	341a6672 <pow+0x16a>
341a66a8:	ee30 0b41 	vsub.f64	d0, d0, d1
341a66ac:	e797      	b.n	341a65de <pow+0xd6>
341a66ae:	2d01      	cmp	r5, #1
341a66b0:	f240 72ff 	movw	r2, #2047	@ 0x7ff
341a66b4:	eb74 0303 	sbcs.w	r3, r4, r3
341a66b8:	bf34      	ite	cc
341a66ba:	2301      	movcc	r3, #1
341a66bc:	2300      	movcs	r3, #0
341a66be:	4296      	cmp	r6, r2
341a66c0:	bf8c      	ite	hi
341a66c2:	2600      	movhi	r6, #0
341a66c4:	2601      	movls	r6, #1
341a66c6:	42b3      	cmp	r3, r6
341a66c8:	f000 809c 	beq.w	341a6804 <pow+0x2fc>
341a66cc:	b007      	add	sp, #28
341a66ce:	ecbd 8b0a 	vpop	{d8-d12}
341a66d2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a66d6:	f000 bbc7 	b.w	341a6e68 <__math_oflow>
341a66da:	f1bc 0f00 	cmp.w	ip, #0
341a66de:	d10a      	bne.n	341a66f6 <pow+0x1ee>
341a66e0:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 341a68c8 <pow+0x3c0>
341a66e4:	ee20 7b07 	vmul.f64	d7, d0, d7
341a66e8:	ec53 2b17 	vmov	r2, r3, d7
341a66ec:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
341a66f0:	4615      	mov	r5, r2
341a66f2:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
341a66f6:	4a7c      	ldr	r2, [pc, #496]	@ (341a68e8 <pow+0x3e0>)
341a66f8:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
341a66fc:	4422      	add	r2, r4
341a66fe:	1513      	asrs	r3, r2, #20
341a6700:	f3c2 3146 	ubfx	r1, r2, #13, #7
341a6704:	f36f 0213 	bfc	r2, #0, #20
341a6708:	ee03 3a10 	vmov	s6, r3
341a670c:	4b77      	ldr	r3, [pc, #476]	@ (341a68ec <pow+0x3e4>)
341a670e:	1aa7      	subs	r7, r4, r2
341a6710:	eb03 1641 	add.w	r6, r3, r1, lsl #5
341a6714:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
341a6718:	eb03 1241 	add.w	r2, r3, r1, lsl #5
341a671c:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
341a6720:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
341a6724:	1e2e      	subs	r6, r5, #0
341a6726:	ec47 6b14 	vmov	d4, r6, r7
341a672a:	eea4 6b05 	vfma.f64	d6, d4, d5
341a672e:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
341a6732:	ed93 5b00 	vldr	d5, [r3]
341a6736:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
341a673a:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
341a673e:	eea3 2b05 	vfma.f64	d2, d3, d5
341a6742:	ed93 5b02 	vldr	d5, [r3, #8]
341a6746:	eea3 7b05 	vfma.f64	d7, d3, d5
341a674a:	ee36 4b02 	vadd.f64	d4, d6, d2
341a674e:	ed93 5b04 	vldr	d5, [r3, #16]
341a6752:	ee32 2b44 	vsub.f64	d2, d2, d4
341a6756:	ee26 5b05 	vmul.f64	d5, d6, d5
341a675a:	ee32 2b06 	vadd.f64	d2, d2, d6
341a675e:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
341a6762:	ee26 0b05 	vmul.f64	d0, d6, d5
341a6766:	ee37 7b02 	vadd.f64	d7, d7, d2
341a676a:	ee34 8b00 	vadd.f64	d8, d4, d0
341a676e:	eeb0 9b40 	vmov.f64	d9, d0
341a6772:	ee26 bb00 	vmul.f64	d11, d6, d0
341a6776:	ee34 4b48 	vsub.f64	d4, d4, d8
341a677a:	ee96 9b05 	vfnms.f64	d9, d6, d5
341a677e:	ee34 ab00 	vadd.f64	d10, d4, d0
341a6782:	ed93 5b06 	vldr	d5, [r3, #24]
341a6786:	ed93 4b08 	vldr	d4, [r3, #32]
341a678a:	eea6 5b04 	vfma.f64	d5, d6, d4
341a678e:	ee37 7b09 	vadd.f64	d7, d7, d9
341a6792:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
341a6796:	ee37 7b0a 	vadd.f64	d7, d7, d10
341a679a:	eea6 4b03 	vfma.f64	d4, d6, d3
341a679e:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
341a67a2:	eea6 3b0c 	vfma.f64	d3, d6, d12
341a67a6:	eea0 4b03 	vfma.f64	d4, d0, d3
341a67aa:	eea0 5b04 	vfma.f64	d5, d0, d4
341a67ae:	eeab 7b05 	vfma.f64	d7, d11, d5
341a67b2:	ee38 4b07 	vadd.f64	d4, d8, d7
341a67b6:	ee21 6b04 	vmul.f64	d6, d1, d4
341a67ba:	ee38 8b44 	vsub.f64	d8, d8, d4
341a67be:	eeb0 5b46 	vmov.f64	d5, d6
341a67c2:	ee16 3a90 	vmov	r3, s13
341a67c6:	ee38 8b07 	vadd.f64	d8, d8, d7
341a67ca:	f3c3 560a 	ubfx	r6, r3, #20, #11
341a67ce:	ee91 5b04 	vfnms.f64	d5, d1, d4
341a67d2:	18b2      	adds	r2, r6, r2
341a67d4:	2a3e      	cmp	r2, #62	@ 0x3e
341a67d6:	eea1 5b08 	vfma.f64	d5, d1, d8
341a67da:	d91b      	bls.n	341a6814 <pow+0x30c>
341a67dc:	2a00      	cmp	r2, #0
341a67de:	da0b      	bge.n	341a67f8 <pow+0x2f0>
341a67e0:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a67e4:	ee36 0b00 	vadd.f64	d0, d6, d0
341a67e8:	2800      	cmp	r0, #0
341a67ea:	f43f aef8 	beq.w	341a65de <pow+0xd6>
341a67ee:	eeb1 0b40 	vneg.f64	d0, d0
341a67f2:	e6f4      	b.n	341a65de <pow+0xd6>
341a67f4:	2000      	movs	r0, #0
341a67f6:	e77e      	b.n	341a66f6 <pow+0x1ee>
341a67f8:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
341a67fc:	d909      	bls.n	341a6812 <pow+0x30a>
341a67fe:	2b00      	cmp	r3, #0
341a6800:	f6bf af64 	bge.w	341a66cc <pow+0x1c4>
341a6804:	b007      	add	sp, #28
341a6806:	ecbd 8b0a 	vpop	{d8-d12}
341a680a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a680e:	f000 bb23 	b.w	341a6e58 <__math_uflow>
341a6812:	2600      	movs	r6, #0
341a6814:	4936      	ldr	r1, [pc, #216]	@ (341a68f0 <pow+0x3e8>)
341a6816:	2700      	movs	r7, #0
341a6818:	ed91 4b02 	vldr	d4, [r1, #8]
341a681c:	ed91 3b00 	vldr	d3, [r1]
341a6820:	eeb0 7b44 	vmov.f64	d7, d4
341a6824:	eea6 7b03 	vfma.f64	d7, d6, d3
341a6828:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
341a682c:	ee17 5a10 	vmov	r5, s14
341a6830:	ee37 7b44 	vsub.f64	d7, d7, d4
341a6834:	ed91 4b04 	vldr	d4, [r1, #16]
341a6838:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
341a683c:	eea7 6b04 	vfma.f64	d6, d7, d4
341a6840:	18dc      	adds	r4, r3, r3
341a6842:	1940      	adds	r0, r0, r5
341a6844:	f104 030f 	add.w	r3, r4, #15
341a6848:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
341a684c:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
341a6850:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
341a6854:	ed91 4b06 	vldr	d4, [r1, #24]
341a6858:	f8d2 e004 	ldr.w	lr, [r2, #4]
341a685c:	eb17 020c 	adds.w	r2, r7, ip
341a6860:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
341a6864:	eea7 6b04 	vfma.f64	d6, d7, d4
341a6868:	ed91 4b08 	vldr	d4, [r1, #32]
341a686c:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
341a6870:	ee35 5b06 	vadd.f64	d5, d5, d6
341a6874:	eea5 4b03 	vfma.f64	d4, d5, d3
341a6878:	ee25 6b05 	vmul.f64	d6, d5, d5
341a687c:	ee35 7b07 	vadd.f64	d7, d5, d7
341a6880:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
341a6884:	eea6 7b04 	vfma.f64	d7, d6, d4
341a6888:	ee26 6b06 	vmul.f64	d6, d6, d6
341a688c:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
341a6890:	eea5 4b03 	vfma.f64	d4, d5, d3
341a6894:	eea6 7b04 	vfma.f64	d7, d6, d4
341a6898:	2e00      	cmp	r6, #0
341a689a:	d175      	bne.n	341a6988 <pow+0x480>
341a689c:	42bd      	cmp	r5, r7
341a689e:	db29      	blt.n	341a68f4 <pow+0x3ec>
341a68a0:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
341a68a4:	4610      	mov	r0, r2
341a68a6:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
341a68aa:	ec41 0b10 	vmov	d0, r0, r1
341a68ae:	eea7 0b00 	vfma.f64	d0, d7, d0
341a68b2:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 341a68d0 <pow+0x3c8>
341a68b6:	ee20 0b07 	vmul.f64	d0, d0, d7
341a68ba:	b007      	add	sp, #28
341a68bc:	ecbd 8b0a 	vpop	{d8-d12}
341a68c0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a68c4:	f000 bb0c 	b.w	341a6ee0 <__math_check_oflow>
341a68c8:	00000000 	.word	0x00000000
341a68cc:	43300000 	.word	0x43300000
341a68d0:	00000000 	.word	0x00000000
341a68d4:	7f000000 	.word	0x7f000000
341a68d8:	3ff00000 	.word	0x3ff00000
341a68dc:	fff00000 	.word	0xfff00000
341a68e0:	ffe00000 	.word	0xffe00000
341a68e4:	7fe00000 	.word	0x7fe00000
341a68e8:	c0196aab 	.word	0xc0196aab
341a68ec:	341afc68 	.word	0x341afc68
341a68f0:	341b0cb0 	.word	0x341b0cb0
341a68f4:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
341a68f8:	4610      	mov	r0, r2
341a68fa:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
341a68fe:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
341a6902:	ec41 0b15 	vmov	d5, r0, r1
341a6906:	ee27 6b05 	vmul.f64	d6, d7, d5
341a690a:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 341a6998 <pow+0x490>
341a690e:	ee35 7b06 	vadd.f64	d7, d5, d6
341a6912:	eeb0 4bc7 	vabs.f64	d4, d7
341a6916:	eeb4 4bc3 	vcmpe.f64	d4, d3
341a691a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a691e:	d52a      	bpl.n	341a6976 <pow+0x46e>
341a6920:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
341a6924:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
341a6928:	ee35 5b47 	vsub.f64	d5, d5, d7
341a692c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6930:	ee35 5b06 	vadd.f64	d5, d5, d6
341a6934:	bf58      	it	pl
341a6936:	eeb0 4b43 	vmovpl.f64	d4, d3
341a693a:	ee37 3b04 	vadd.f64	d3, d7, d4
341a693e:	ee34 6b43 	vsub.f64	d6, d4, d3
341a6942:	ee36 6b07 	vadd.f64	d6, d6, d7
341a6946:	ee36 6b05 	vadd.f64	d6, d6, d5
341a694a:	ee36 6b03 	vadd.f64	d6, d6, d3
341a694e:	ee36 7b44 	vsub.f64	d7, d6, d4
341a6952:	eeb5 7b40 	vcmp.f64	d7, #0.0
341a6956:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a695a:	d104      	bne.n	341a6966 <pow+0x45e>
341a695c:	4632      	mov	r2, r6
341a695e:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
341a6962:	ec43 2b17 	vmov	d7, r2, r3
341a6966:	ed8d 0b02 	vstr	d0, [sp, #8]
341a696a:	ed9d 6b02 	vldr	d6, [sp, #8]
341a696e:	ee26 6b00 	vmul.f64	d6, d6, d0
341a6972:	ed8d 6b04 	vstr	d6, [sp, #16]
341a6976:	ee27 0b00 	vmul.f64	d0, d7, d0
341a697a:	b007      	add	sp, #28
341a697c:	ecbd 8b0a 	vpop	{d8-d12}
341a6980:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
341a6984:	f000 baa3 	b.w	341a6ece <__math_check_uflow>
341a6988:	ec43 2b10 	vmov	d0, r2, r3
341a698c:	eea7 0b00 	vfma.f64	d0, d7, d0
341a6990:	e625      	b.n	341a65de <pow+0xd6>
341a6992:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 341a69a0 <pow+0x498>
341a6996:	e622      	b.n	341a65de <pow+0xd6>
341a6998:	00000000 	.word	0x00000000
341a699c:	00100000 	.word	0x00100000
	...

341a69a8 <checkint>:
341a69a8:	f3c0 53c7 	ubfx	r3, r0, #23, #8
341a69ac:	2b7e      	cmp	r3, #126	@ 0x7e
341a69ae:	d910      	bls.n	341a69d2 <checkint+0x2a>
341a69b0:	2b96      	cmp	r3, #150	@ 0x96
341a69b2:	d80c      	bhi.n	341a69ce <checkint+0x26>
341a69b4:	2201      	movs	r2, #1
341a69b6:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
341a69ba:	fa02 f303 	lsl.w	r3, r2, r3
341a69be:	1e5a      	subs	r2, r3, #1
341a69c0:	4202      	tst	r2, r0
341a69c2:	d106      	bne.n	341a69d2 <checkint+0x2a>
341a69c4:	4203      	tst	r3, r0
341a69c6:	bf14      	ite	ne
341a69c8:	2001      	movne	r0, #1
341a69ca:	2002      	moveq	r0, #2
341a69cc:	4770      	bx	lr
341a69ce:	2002      	movs	r0, #2
341a69d0:	4770      	bx	lr
341a69d2:	2000      	movs	r0, #0
341a69d4:	4770      	bx	lr
	...

341a69d8 <powf>:
341a69d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
341a69da:	ee10 1a10 	vmov	r1, s0
341a69de:	ee10 4a90 	vmov	r4, s1
341a69e2:	eef0 7a40 	vmov.f32	s15, s0
341a69e6:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
341a69ea:	0063      	lsls	r3, r4, #1
341a69ec:	eeb0 7a60 	vmov.f32	s14, s1
341a69f0:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
341a69f4:	f103 30ff 	add.w	r0, r3, #4294967295
341a69f8:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
341a69fc:	d252      	bcs.n	341a6aa4 <powf+0xcc>
341a69fe:	4290      	cmp	r0, r2
341a6a00:	d258      	bcs.n	341a6ab4 <powf+0xdc>
341a6a02:	2000      	movs	r0, #0
341a6a04:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
341a6a08:	4a9f      	ldr	r2, [pc, #636]	@ (341a6c88 <powf+0x2b0>)
341a6a0a:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
341a6a0e:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
341a6a12:	f3c3 44c3 	ubfx	r4, r3, #19, #4
341a6a16:	f36f 0316 	bfc	r3, #0, #23
341a6a1a:	1ac9      	subs	r1, r1, r3
341a6a1c:	eb02 1404 	add.w	r4, r2, r4, lsl #4
341a6a20:	15db      	asrs	r3, r3, #23
341a6a22:	ee07 1a90 	vmov	s15, r1
341a6a26:	ed94 4b00 	vldr	d4, [r4]
341a6a2a:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
341a6a2e:	ee07 3a90 	vmov	s15, r3
341a6a32:	ed94 5b02 	vldr	d5, [r4, #8]
341a6a36:	eea4 2b06 	vfma.f64	d2, d4, d6
341a6a3a:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341a6a3e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
341a6a42:	ee36 6b05 	vadd.f64	d6, d6, d5
341a6a46:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
341a6a4a:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
341a6a4e:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
341a6a52:	ee22 4b02 	vmul.f64	d4, d2, d2
341a6a56:	eea2 1b05 	vfma.f64	d1, d2, d5
341a6a5a:	ee24 0b04 	vmul.f64	d0, d4, d4
341a6a5e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
341a6a62:	eea2 5b03 	vfma.f64	d5, d2, d3
341a6a66:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
341a6a6a:	eea2 6b03 	vfma.f64	d6, d2, d3
341a6a6e:	eea4 6b05 	vfma.f64	d6, d4, d5
341a6a72:	eea1 6b00 	vfma.f64	d6, d1, d0
341a6a76:	ee27 7b06 	vmul.f64	d7, d7, d6
341a6a7a:	ee17 3a90 	vmov	r3, s15
341a6a7e:	f3c3 32cf 	ubfx	r2, r3, #15, #16
341a6a82:	f248 03bf 	movw	r3, #32959	@ 0x80bf
341a6a86:	429a      	cmp	r2, r3
341a6a88:	f0c0 8098 	bcc.w	341a6bbc <powf+0x1e4>
341a6a8c:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 341a6c68 <powf+0x290>
341a6a90:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a6a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6a98:	dd79      	ble.n	341a6b8e <powf+0x1b6>
341a6a9a:	b003      	add	sp, #12
341a6a9c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a6aa0:	f000 b920 	b.w	341a6ce4 <__math_oflowf>
341a6aa4:	4290      	cmp	r0, r2
341a6aa6:	d330      	bcc.n	341a6b0a <powf+0x132>
341a6aa8:	b12b      	cbz	r3, 341a6ab6 <powf+0xde>
341a6aaa:	0049      	lsls	r1, r1, #1
341a6aac:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
341a6ab0:	d808      	bhi.n	341a6ac4 <powf+0xec>
341a6ab2:	e015      	b.n	341a6ae0 <powf+0x108>
341a6ab4:	b953      	cbnz	r3, 341a6acc <powf+0xf4>
341a6ab6:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
341a6aba:	0049      	lsls	r1, r1, #1
341a6abc:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
341a6ac0:	f240 80ca 	bls.w	341a6c58 <powf+0x280>
341a6ac4:	ee37 0a87 	vadd.f32	s0, s15, s14
341a6ac8:	b003      	add	sp, #12
341a6aca:	bd30      	pop	{r4, r5, pc}
341a6acc:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
341a6ad0:	d105      	bne.n	341a6ade <powf+0x106>
341a6ad2:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
341a6ad6:	0064      	lsls	r4, r4, #1
341a6ad8:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
341a6adc:	e7f0      	b.n	341a6ac0 <powf+0xe8>
341a6ade:	0049      	lsls	r1, r1, #1
341a6ae0:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
341a6ae4:	d1ee      	bne.n	341a6ac4 <powf+0xec>
341a6ae6:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
341a6aea:	f000 80b5 	beq.w	341a6c58 <powf+0x280>
341a6aee:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
341a6af2:	ea6f 0404 	mvn.w	r4, r4
341a6af6:	bf34      	ite	cc
341a6af8:	2100      	movcc	r1, #0
341a6afa:	2101      	movcs	r1, #1
341a6afc:	0fe4      	lsrs	r4, r4, #31
341a6afe:	42a1      	cmp	r1, r4
341a6b00:	f040 80ad 	bne.w	341a6c5e <powf+0x286>
341a6b04:	ee27 0a07 	vmul.f32	s0, s14, s14
341a6b08:	e7de      	b.n	341a6ac8 <powf+0xf0>
341a6b0a:	004d      	lsls	r5, r1, #1
341a6b0c:	1e6b      	subs	r3, r5, #1
341a6b0e:	4293      	cmp	r3, r2
341a6b10:	d31b      	bcc.n	341a6b4a <powf+0x172>
341a6b12:	2900      	cmp	r1, #0
341a6b14:	ee20 0a00 	vmul.f32	s0, s0, s0
341a6b18:	da0e      	bge.n	341a6b38 <powf+0x160>
341a6b1a:	4620      	mov	r0, r4
341a6b1c:	f7ff ff44 	bl	341a69a8 <checkint>
341a6b20:	2801      	cmp	r0, #1
341a6b22:	d109      	bne.n	341a6b38 <powf+0x160>
341a6b24:	eeb1 0a40 	vneg.f32	s0, s0
341a6b28:	b945      	cbnz	r5, 341a6b3c <powf+0x164>
341a6b2a:	2c00      	cmp	r4, #0
341a6b2c:	dacc      	bge.n	341a6ac8 <powf+0xf0>
341a6b2e:	b003      	add	sp, #12
341a6b30:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a6b34:	f000 b8dc 	b.w	341a6cf0 <__math_divzerof>
341a6b38:	2000      	movs	r0, #0
341a6b3a:	e7f5      	b.n	341a6b28 <powf+0x150>
341a6b3c:	2c00      	cmp	r4, #0
341a6b3e:	dac3      	bge.n	341a6ac8 <powf+0xf0>
341a6b40:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341a6b44:	ee87 0a80 	vdiv.f32	s0, s15, s0
341a6b48:	e7be      	b.n	341a6ac8 <powf+0xf0>
341a6b4a:	2900      	cmp	r1, #0
341a6b4c:	da1d      	bge.n	341a6b8a <powf+0x1b2>
341a6b4e:	4620      	mov	r0, r4
341a6b50:	f7ff ff2a 	bl	341a69a8 <checkint>
341a6b54:	b920      	cbnz	r0, 341a6b60 <powf+0x188>
341a6b56:	b003      	add	sp, #12
341a6b58:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a6b5c:	f000 b8da 	b.w	341a6d14 <__math_invalidf>
341a6b60:	1e43      	subs	r3, r0, #1
341a6b62:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
341a6b66:	4258      	negs	r0, r3
341a6b68:	4158      	adcs	r0, r3
341a6b6a:	0400      	lsls	r0, r0, #16
341a6b6c:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
341a6b70:	f4bf af48 	bcs.w	341a6a04 <powf+0x2c>
341a6b74:	eddf 6a45 	vldr	s13, [pc, #276]	@ 341a6c8c <powf+0x2b4>
341a6b78:	ee27 0aa6 	vmul.f32	s0, s15, s13
341a6b7c:	ee10 3a10 	vmov	r3, s0
341a6b80:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
341a6b84:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
341a6b88:	e73c      	b.n	341a6a04 <powf+0x2c>
341a6b8a:	2000      	movs	r0, #0
341a6b8c:	e7ee      	b.n	341a6b6c <powf+0x194>
341a6b8e:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 341a6c70 <powf+0x298>
341a6b92:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a6b96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6b9a:	dd45      	ble.n	341a6c28 <powf+0x250>
341a6b9c:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
341a6ba0:	b3d0      	cbz	r0, 341a6c18 <powf+0x240>
341a6ba2:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
341a6ba6:	9301      	str	r3, [sp, #4]
341a6ba8:	eddd 6a01 	vldr	s13, [sp, #4]
341a6bac:	ee76 6a66 	vsub.f32	s13, s12, s13
341a6bb0:	eef4 6a46 	vcmp.f32	s13, s12
341a6bb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6bb8:	f47f af6f 	bne.w	341a6a9a <powf+0xc2>
341a6bbc:	4b34      	ldr	r3, [pc, #208]	@ (341a6c90 <powf+0x2b8>)
341a6bbe:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
341a6bc2:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
341a6bc6:	ee37 6b05 	vadd.f64	d6, d7, d5
341a6bca:	ee16 2a10 	vmov	r2, s12
341a6bce:	ee36 6b45 	vsub.f64	d6, d6, d5
341a6bd2:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
341a6bd6:	ee37 7b46 	vsub.f64	d7, d7, d6
341a6bda:	f002 011f 	and.w	r1, r2, #31
341a6bde:	1880      	adds	r0, r0, r2
341a6be0:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
341a6be4:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
341a6be8:	ee27 4b07 	vmul.f64	d4, d7, d7
341a6bec:	2100      	movs	r1, #0
341a6bee:	686d      	ldr	r5, [r5, #4]
341a6bf0:	190a      	adds	r2, r1, r4
341a6bf2:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
341a6bf6:	eea7 6b05 	vfma.f64	d6, d7, d5
341a6bfa:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
341a6bfe:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
341a6c02:	eea7 0b05 	vfma.f64	d0, d7, d5
341a6c06:	ec43 2b17 	vmov	d7, r2, r3
341a6c0a:	eea6 0b04 	vfma.f64	d0, d6, d4
341a6c0e:	ee20 0b07 	vmul.f64	d0, d0, d7
341a6c12:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
341a6c16:	e757      	b.n	341a6ac8 <powf+0xf0>
341a6c18:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
341a6c1c:	9300      	str	r3, [sp, #0]
341a6c1e:	eddd 6a00 	vldr	s13, [sp]
341a6c22:	ee76 6a86 	vadd.f32	s13, s13, s12
341a6c26:	e7c3      	b.n	341a6bb0 <powf+0x1d8>
341a6c28:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 341a6c78 <powf+0x2a0>
341a6c2c:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a6c30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6c34:	d804      	bhi.n	341a6c40 <powf+0x268>
341a6c36:	b003      	add	sp, #12
341a6c38:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a6c3c:	f000 b846 	b.w	341a6ccc <__math_uflowf>
341a6c40:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 341a6c80 <powf+0x2a8>
341a6c44:	eeb4 7bc6 	vcmpe.f64	d7, d6
341a6c48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6c4c:	d5b6      	bpl.n	341a6bbc <powf+0x1e4>
341a6c4e:	b003      	add	sp, #12
341a6c50:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
341a6c54:	f000 b840 	b.w	341a6cd8 <__math_may_uflowf>
341a6c58:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
341a6c5c:	e734      	b.n	341a6ac8 <powf+0xf0>
341a6c5e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 341a6c94 <powf+0x2bc>
341a6c62:	e731      	b.n	341a6ac8 <powf+0xf0>
341a6c64:	f3af 8000 	nop.w
341a6c68:	ffd1d571 	.word	0xffd1d571
341a6c6c:	405fffff 	.word	0x405fffff
341a6c70:	ffa3aae2 	.word	0xffa3aae2
341a6c74:	405fffff 	.word	0x405fffff
341a6c78:	00000000 	.word	0x00000000
341a6c7c:	c062c000 	.word	0xc062c000
341a6c80:	00000000 	.word	0x00000000
341a6c84:	c062a000 	.word	0xc062a000
341a6c88:	341b1ef8 	.word	0x341b1ef8
341a6c8c:	4b000000 	.word	0x4b000000
341a6c90:	341b1db0 	.word	0x341b1db0
341a6c94:	00000000 	.word	0x00000000

341a6c98 <with_errnof>:
341a6c98:	b510      	push	{r4, lr}
341a6c9a:	ed2d 8b02 	vpush	{d8}
341a6c9e:	eeb0 8a40 	vmov.f32	s16, s0
341a6ca2:	4604      	mov	r4, r0
341a6ca4:	f7fe fc72 	bl	341a558c <__errno>
341a6ca8:	6004      	str	r4, [r0, #0]
341a6caa:	eeb0 0a48 	vmov.f32	s0, s16
341a6cae:	ecbd 8b02 	vpop	{d8}
341a6cb2:	bd10      	pop	{r4, pc}

341a6cb4 <xflowf>:
341a6cb4:	b130      	cbz	r0, 341a6cc4 <xflowf+0x10>
341a6cb6:	eef1 7a40 	vneg.f32	s15, s0
341a6cba:	ee27 0a80 	vmul.f32	s0, s15, s0
341a6cbe:	2022      	movs	r0, #34	@ 0x22
341a6cc0:	f7ff bfea 	b.w	341a6c98 <with_errnof>
341a6cc4:	eef0 7a40 	vmov.f32	s15, s0
341a6cc8:	e7f7      	b.n	341a6cba <xflowf+0x6>
	...

341a6ccc <__math_uflowf>:
341a6ccc:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a6cd4 <__math_uflowf+0x8>
341a6cd0:	f7ff bff0 	b.w	341a6cb4 <xflowf>
341a6cd4:	10000000 	.word	0x10000000

341a6cd8 <__math_may_uflowf>:
341a6cd8:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a6ce0 <__math_may_uflowf+0x8>
341a6cdc:	f7ff bfea 	b.w	341a6cb4 <xflowf>
341a6ce0:	1a200000 	.word	0x1a200000

341a6ce4 <__math_oflowf>:
341a6ce4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 341a6cec <__math_oflowf+0x8>
341a6ce8:	f7ff bfe4 	b.w	341a6cb4 <xflowf>
341a6cec:	70000000 	.word	0x70000000

341a6cf0 <__math_divzerof>:
341a6cf0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
341a6cf4:	2800      	cmp	r0, #0
341a6cf6:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
341a6cfa:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 341a6d10 <__math_divzerof+0x20>
341a6cfe:	f04f 0022 	mov.w	r0, #34	@ 0x22
341a6d02:	fe47 7a87 	vseleq.f32	s15, s15, s14
341a6d06:	ee87 0a80 	vdiv.f32	s0, s15, s0
341a6d0a:	f7ff bfc5 	b.w	341a6c98 <with_errnof>
341a6d0e:	bf00      	nop
341a6d10:	00000000 	.word	0x00000000

341a6d14 <__math_invalidf>:
341a6d14:	eef0 7a40 	vmov.f32	s15, s0
341a6d18:	ee30 7a40 	vsub.f32	s14, s0, s0
341a6d1c:	eef4 7a67 	vcmp.f32	s15, s15
341a6d20:	ee87 0a07 	vdiv.f32	s0, s14, s14
341a6d24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6d28:	d602      	bvs.n	341a6d30 <__math_invalidf+0x1c>
341a6d2a:	2021      	movs	r0, #33	@ 0x21
341a6d2c:	f7ff bfb4 	b.w	341a6c98 <with_errnof>
341a6d30:	4770      	bx	lr

341a6d32 <__ieee754_sqrt>:
341a6d32:	eeb1 0bc0 	vsqrt.f64	d0, d0
341a6d36:	4770      	bx	lr

341a6d38 <__ieee754_log10>:
341a6d38:	ee10 3a90 	vmov	r3, s1
341a6d3c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
341a6d40:	b510      	push	{r4, lr}
341a6d42:	ed2d 8b02 	vpush	{d8}
341a6d46:	da21      	bge.n	341a6d8c <__ieee754_log10+0x54>
341a6d48:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
341a6d4c:	ee10 1a10 	vmov	r1, s0
341a6d50:	430a      	orrs	r2, r1
341a6d52:	d108      	bne.n	341a6d66 <__ieee754_log10+0x2e>
341a6d54:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 341a6de0 <__ieee754_log10+0xa8>
341a6d58:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 341a6de8 <__ieee754_log10+0xb0>
341a6d5c:	ee86 0b07 	vdiv.f64	d0, d6, d7
341a6d60:	ecbd 8b02 	vpop	{d8}
341a6d64:	bd10      	pop	{r4, pc}
341a6d66:	2b00      	cmp	r3, #0
341a6d68:	da02      	bge.n	341a6d70 <__ieee754_log10+0x38>
341a6d6a:	ee30 6b40 	vsub.f64	d6, d0, d0
341a6d6e:	e7f3      	b.n	341a6d58 <__ieee754_log10+0x20>
341a6d70:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 341a6df0 <__ieee754_log10+0xb8>
341a6d74:	f06f 0235 	mvn.w	r2, #53	@ 0x35
341a6d78:	ee20 0b07 	vmul.f64	d0, d0, d7
341a6d7c:	ee10 3a90 	vmov	r3, s1
341a6d80:	4923      	ldr	r1, [pc, #140]	@ (341a6e10 <__ieee754_log10+0xd8>)
341a6d82:	428b      	cmp	r3, r1
341a6d84:	dd04      	ble.n	341a6d90 <__ieee754_log10+0x58>
341a6d86:	ee30 0b00 	vadd.f64	d0, d0, d0
341a6d8a:	e7e9      	b.n	341a6d60 <__ieee754_log10+0x28>
341a6d8c:	2200      	movs	r2, #0
341a6d8e:	e7f7      	b.n	341a6d80 <__ieee754_log10+0x48>
341a6d90:	1518      	asrs	r0, r3, #20
341a6d92:	f240 34ff 	movw	r4, #1023	@ 0x3ff
341a6d96:	f3c3 0113 	ubfx	r1, r3, #0, #20
341a6d9a:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
341a6d9e:	4410      	add	r0, r2
341a6da0:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
341a6da4:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
341a6da8:	ee08 3a10 	vmov	s16, r3
341a6dac:	ec53 2b10 	vmov	r2, r3, d0
341a6db0:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
341a6db4:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
341a6db8:	ec43 2b10 	vmov	d0, r2, r3
341a6dbc:	f000 f8a4 	bl	341a6f08 <log>
341a6dc0:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a6df8 <__ieee754_log10+0xc0>
341a6dc4:	ee20 0b07 	vmul.f64	d0, d0, d7
341a6dc8:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a6e00 <__ieee754_log10+0xc8>
341a6dcc:	eea8 0b07 	vfma.f64	d0, d8, d7
341a6dd0:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 341a6e08 <__ieee754_log10+0xd0>
341a6dd4:	eea8 0b07 	vfma.f64	d0, d8, d7
341a6dd8:	e7c2      	b.n	341a6d60 <__ieee754_log10+0x28>
341a6dda:	bf00      	nop
341a6ddc:	f3af 8000 	nop.w
341a6de0:	00000000 	.word	0x00000000
341a6de4:	c3500000 	.word	0xc3500000
	...
341a6df4:	43500000 	.word	0x43500000
341a6df8:	1526e50e 	.word	0x1526e50e
341a6dfc:	3fdbcb7b 	.word	0x3fdbcb7b
341a6e00:	11f12b36 	.word	0x11f12b36
341a6e04:	3d59fef3 	.word	0x3d59fef3
341a6e08:	509f6000 	.word	0x509f6000
341a6e0c:	3fd34413 	.word	0x3fd34413
341a6e10:	7fefffff 	.word	0x7fefffff

341a6e14 <with_errno>:
341a6e14:	b510      	push	{r4, lr}
341a6e16:	ed2d 8b02 	vpush	{d8}
341a6e1a:	eeb0 8b40 	vmov.f64	d8, d0
341a6e1e:	4604      	mov	r4, r0
341a6e20:	f7fe fbb4 	bl	341a558c <__errno>
341a6e24:	6004      	str	r4, [r0, #0]
341a6e26:	eeb0 0b48 	vmov.f64	d0, d8
341a6e2a:	ecbd 8b02 	vpop	{d8}
341a6e2e:	bd10      	pop	{r4, pc}

341a6e30 <xflow>:
341a6e30:	b082      	sub	sp, #8
341a6e32:	b158      	cbz	r0, 341a6e4c <xflow+0x1c>
341a6e34:	eeb1 7b40 	vneg.f64	d7, d0
341a6e38:	2022      	movs	r0, #34	@ 0x22
341a6e3a:	ed8d 7b00 	vstr	d7, [sp]
341a6e3e:	ed9d 7b00 	vldr	d7, [sp]
341a6e42:	ee20 0b07 	vmul.f64	d0, d0, d7
341a6e46:	b002      	add	sp, #8
341a6e48:	f7ff bfe4 	b.w	341a6e14 <with_errno>
341a6e4c:	eeb0 7b40 	vmov.f64	d7, d0
341a6e50:	e7f2      	b.n	341a6e38 <xflow+0x8>
341a6e52:	0000      	movs	r0, r0
341a6e54:	0000      	movs	r0, r0
	...

341a6e58 <__math_uflow>:
341a6e58:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a6e60 <__math_uflow+0x8>
341a6e5c:	f7ff bfe8 	b.w	341a6e30 <xflow>
341a6e60:	00000000 	.word	0x00000000
341a6e64:	10000000 	.word	0x10000000

341a6e68 <__math_oflow>:
341a6e68:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 341a6e70 <__math_oflow+0x8>
341a6e6c:	f7ff bfe0 	b.w	341a6e30 <xflow>
341a6e70:	00000000 	.word	0x00000000
341a6e74:	70000000 	.word	0x70000000

341a6e78 <__math_divzero>:
341a6e78:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
341a6e7c:	b082      	sub	sp, #8
341a6e7e:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
341a6e82:	2800      	cmp	r0, #0
341a6e84:	f04f 0022 	mov.w	r0, #34	@ 0x22
341a6e88:	fe07 7b06 	vseleq.f64	d7, d7, d6
341a6e8c:	ed8d 7b00 	vstr	d7, [sp]
341a6e90:	ed9d 0b00 	vldr	d0, [sp]
341a6e94:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 341a6ea8 <__math_divzero+0x30>
341a6e98:	ee80 0b07 	vdiv.f64	d0, d0, d7
341a6e9c:	b002      	add	sp, #8
341a6e9e:	f7ff bfb9 	b.w	341a6e14 <with_errno>
341a6ea2:	bf00      	nop
341a6ea4:	f3af 8000 	nop.w
	...

341a6eb0 <__math_invalid>:
341a6eb0:	eeb0 7b40 	vmov.f64	d7, d0
341a6eb4:	ee30 6b40 	vsub.f64	d6, d0, d0
341a6eb8:	eeb4 7b47 	vcmp.f64	d7, d7
341a6ebc:	ee86 0b06 	vdiv.f64	d0, d6, d6
341a6ec0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6ec4:	d602      	bvs.n	341a6ecc <__math_invalid+0x1c>
341a6ec6:	2021      	movs	r0, #33	@ 0x21
341a6ec8:	f7ff bfa4 	b.w	341a6e14 <with_errno>
341a6ecc:	4770      	bx	lr

341a6ece <__math_check_uflow>:
341a6ece:	eeb5 0b40 	vcmp.f64	d0, #0.0
341a6ed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6ed6:	d102      	bne.n	341a6ede <__math_check_uflow+0x10>
341a6ed8:	2022      	movs	r0, #34	@ 0x22
341a6eda:	f7ff bf9b 	b.w	341a6e14 <with_errno>
341a6ede:	4770      	bx	lr

341a6ee0 <__math_check_oflow>:
341a6ee0:	eeb0 7bc0 	vabs.f64	d7, d0
341a6ee4:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 341a6f00 <__math_check_oflow+0x20>
341a6ee8:	eeb4 7b46 	vcmp.f64	d7, d6
341a6eec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
341a6ef0:	dd02      	ble.n	341a6ef8 <__math_check_oflow+0x18>
341a6ef2:	2022      	movs	r0, #34	@ 0x22
341a6ef4:	f7ff bf8e 	b.w	341a6e14 <with_errno>
341a6ef8:	4770      	bx	lr
341a6efa:	bf00      	nop
341a6efc:	f3af 8000 	nop.w
341a6f00:	ffffffff 	.word	0xffffffff
341a6f04:	7fefffff 	.word	0x7fefffff

341a6f08 <log>:
341a6f08:	ee10 0a90 	vmov	r0, s1
341a6f0c:	ee10 3a10 	vmov	r3, s0
341a6f10:	b4f0      	push	{r4, r5, r6, r7}
341a6f12:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
341a6f16:	f04f 34ff 	mov.w	r4, #4294967295
341a6f1a:	0c02      	lsrs	r2, r0, #16
341a6f1c:	429c      	cmp	r4, r3
341a6f1e:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
341a6f22:	4c71      	ldr	r4, [pc, #452]	@ (341a70e8 <log+0x1e0>)
341a6f24:	418c      	sbcs	r4, r1
341a6f26:	ed2d 8b02 	vpush	{d8}
341a6f2a:	d35a      	bcc.n	341a6fe2 <log+0xda>
341a6f2c:	4a6f      	ldr	r2, [pc, #444]	@ (341a70ec <log+0x1e4>)
341a6f2e:	4290      	cmp	r0, r2
341a6f30:	bf08      	it	eq
341a6f32:	2b00      	cmpeq	r3, #0
341a6f34:	f000 80c7 	beq.w	341a70c6 <log+0x1be>
341a6f38:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
341a6f3c:	4b6c      	ldr	r3, [pc, #432]	@ (341a70f0 <log+0x1e8>)
341a6f3e:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
341a6f42:	ee30 0b47 	vsub.f64	d0, d0, d7
341a6f46:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
341a6f4a:	ee20 2b00 	vmul.f64	d2, d0, d0
341a6f4e:	eea6 7b00 	vfma.f64	d7, d6, d0
341a6f52:	ee20 4b02 	vmul.f64	d4, d0, d2
341a6f56:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
341a6f5a:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
341a6f5e:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
341a6f62:	eea6 7b02 	vfma.f64	d7, d6, d2
341a6f66:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
341a6f6a:	eea5 6b00 	vfma.f64	d6, d5, d0
341a6f6e:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
341a6f72:	eea5 6b02 	vfma.f64	d6, d5, d2
341a6f76:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
341a6f7a:	eea3 5b00 	vfma.f64	d5, d3, d0
341a6f7e:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
341a6f82:	eea3 5b02 	vfma.f64	d5, d3, d2
341a6f86:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
341a6f8a:	eea3 5b04 	vfma.f64	d5, d3, d4
341a6f8e:	eeb0 3b40 	vmov.f64	d3, d0
341a6f92:	eea5 6b04 	vfma.f64	d6, d5, d4
341a6f96:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
341a6f9a:	eea6 7b04 	vfma.f64	d7, d6, d4
341a6f9e:	eeb0 6b40 	vmov.f64	d6, d0
341a6fa2:	eeb0 2b47 	vmov.f64	d2, d7
341a6fa6:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 341a70d0 <log+0x1c8>
341a6faa:	eea0 6b07 	vfma.f64	d6, d0, d7
341a6fae:	eea0 6b47 	vfms.f64	d6, d0, d7
341a6fb2:	ee26 1b06 	vmul.f64	d1, d6, d6
341a6fb6:	ee30 8b46 	vsub.f64	d8, d0, d6
341a6fba:	eea1 3b05 	vfma.f64	d3, d1, d5
341a6fbe:	ee30 7b43 	vsub.f64	d7, d0, d3
341a6fc2:	ee30 0b06 	vadd.f64	d0, d0, d6
341a6fc6:	eea1 7b05 	vfma.f64	d7, d1, d5
341a6fca:	ee25 5b08 	vmul.f64	d5, d5, d8
341a6fce:	eea5 7b00 	vfma.f64	d7, d5, d0
341a6fd2:	eea2 7b04 	vfma.f64	d7, d2, d4
341a6fd6:	ee33 0b07 	vadd.f64	d0, d3, d7
341a6fda:	ecbd 8b02 	vpop	{d8}
341a6fde:	bcf0      	pop	{r4, r5, r6, r7}
341a6fe0:	4770      	bx	lr
341a6fe2:	f1a2 0410 	sub.w	r4, r2, #16
341a6fe6:	f647 71df 	movw	r1, #32735	@ 0x7fdf
341a6fea:	428c      	cmp	r4, r1
341a6fec:	d923      	bls.n	341a7036 <log+0x12e>
341a6fee:	18d9      	adds	r1, r3, r3
341a6ff0:	eb40 0400 	adc.w	r4, r0, r0
341a6ff4:	4321      	orrs	r1, r4
341a6ff6:	d105      	bne.n	341a7004 <log+0xfc>
341a6ff8:	2001      	movs	r0, #1
341a6ffa:	ecbd 8b02 	vpop	{d8}
341a6ffe:	bcf0      	pop	{r4, r5, r6, r7}
341a7000:	f7ff bf3a 	b.w	341a6e78 <__math_divzero>
341a7004:	493b      	ldr	r1, [pc, #236]	@ (341a70f4 <log+0x1ec>)
341a7006:	4288      	cmp	r0, r1
341a7008:	bf08      	it	eq
341a700a:	2b00      	cmpeq	r3, #0
341a700c:	d0e5      	beq.n	341a6fda <log+0xd2>
341a700e:	0413      	lsls	r3, r2, #16
341a7010:	d403      	bmi.n	341a701a <log+0x112>
341a7012:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
341a7016:	4393      	bics	r3, r2
341a7018:	d104      	bne.n	341a7024 <log+0x11c>
341a701a:	ecbd 8b02 	vpop	{d8}
341a701e:	bcf0      	pop	{r4, r5, r6, r7}
341a7020:	f7ff bf46 	b.w	341a6eb0 <__math_invalid>
341a7024:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 341a70d8 <log+0x1d0>
341a7028:	ee20 7b07 	vmul.f64	d7, d0, d7
341a702c:	ec53 2b17 	vmov	r2, r3, d7
341a7030:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
341a7034:	4613      	mov	r3, r2
341a7036:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
341a703a:	492d      	ldr	r1, [pc, #180]	@ (341a70f0 <log+0x1e8>)
341a703c:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
341a7040:	1e1e      	subs	r6, r3, #0
341a7042:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
341a7046:	f3c2 3446 	ubfx	r4, r2, #13, #7
341a704a:	ea4f 5c12 	mov.w	ip, r2, lsr #20
341a704e:	1512      	asrs	r2, r2, #20
341a7050:	eb01 1504 	add.w	r5, r1, r4, lsl #4
341a7054:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
341a7058:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
341a705c:	eba0 070c 	sub.w	r7, r0, ip
341a7060:	ec47 6b16 	vmov	d6, r6, r7
341a7064:	eea7 5b06 	vfma.f64	d5, d7, d6
341a7068:	ee07 2a90 	vmov	s15, r2
341a706c:	eeb8 6be7 	vcvt.f64.s32	d6, s15
341a7070:	ed91 4b00 	vldr	d4, [r1]
341a7074:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
341a7078:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
341a707c:	eea4 7b06 	vfma.f64	d7, d4, d6
341a7080:	ee25 2b05 	vmul.f64	d2, d5, d5
341a7084:	ee35 4b07 	vadd.f64	d4, d5, d7
341a7088:	ee25 1b02 	vmul.f64	d1, d5, d2
341a708c:	ee37 0b44 	vsub.f64	d0, d7, d4
341a7090:	ed91 7b02 	vldr	d7, [r1, #8]
341a7094:	ee30 0b05 	vadd.f64	d0, d0, d5
341a7098:	eea7 0b06 	vfma.f64	d0, d7, d6
341a709c:	ed91 7b04 	vldr	d7, [r1, #16]
341a70a0:	ed91 6b08 	vldr	d6, [r1, #32]
341a70a4:	eea7 0b02 	vfma.f64	d0, d7, d2
341a70a8:	ed91 7b06 	vldr	d7, [r1, #24]
341a70ac:	eea6 7b05 	vfma.f64	d7, d6, d5
341a70b0:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
341a70b4:	eea3 6b05 	vfma.f64	d6, d3, d5
341a70b8:	eea6 7b02 	vfma.f64	d7, d6, d2
341a70bc:	eea1 0b07 	vfma.f64	d0, d1, d7
341a70c0:	ee30 0b04 	vadd.f64	d0, d0, d4
341a70c4:	e789      	b.n	341a6fda <log+0xd2>
341a70c6:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 341a70e0 <log+0x1d8>
341a70ca:	e786      	b.n	341a6fda <log+0xd2>
341a70cc:	f3af 8000 	nop.w
341a70d0:	00000000 	.word	0x00000000
341a70d4:	41a00000 	.word	0x41a00000
341a70d8:	00000000 	.word	0x00000000
341a70dc:	43300000 	.word	0x43300000
	...
341a70e8:	000308ff 	.word	0x000308ff
341a70ec:	3ff00000 	.word	0x3ff00000
341a70f0:	341b1520 	.word	0x341b1520
341a70f4:	7ff00000 	.word	0x7ff00000

341a70f8 <_init>:
341a70f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a70fa:	bf00      	nop
341a70fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
341a70fe:	bc08      	pop	{r3}
341a7100:	469e      	mov	lr, r3
341a7102:	4770      	bx	lr

341a7104 <_fini>:
341a7104:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
341a7106:	bf00      	nop
341a7108:	bcf8      	pop	{r3, r4, r5, r6, r7}
341a710a:	bc08      	pop	{r3}
341a710c:	469e      	mov	lr, r3
341a710e:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

341b21e0 <SECURE_SystemCoreClockUpdate>:
341b21e0:	e97f e97f 	sg
341b21e4:	f7d1 bc76 	b.w	34183ad4 <__acle_se_SECURE_SystemCoreClockUpdate>
	...
